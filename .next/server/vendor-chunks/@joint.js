"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@joint";
exports.ids = ["vendor-chunks/@joint"];
exports.modules = {

/***/ "(ssr)/./node_modules/@joint/core/dist/version.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/dist/version.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\nvar version = \"4.1.3\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvZGlzdC92ZXJzaW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9kaXN0L3ZlcnNpb24ubWpzP2MwNmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHZlcnNpb24gPSBcIjQuMS4zXCI7XG5cbmV4cG9ydCB7IHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/dist/version.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/joint.mjs":
/*!********************************************!*\
  !*** ./node_modules/@joint/core/joint.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_15__[\"default\"]),\n/* harmony export */   Vectorizer: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__.Vectorizer),\n/* harmony export */   anchors: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   config: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_1__.config),\n/* harmony export */   connectionPoints: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_5__),\n/* harmony export */   connectionStrategies: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   connectors: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   dia: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   elementTools: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_14__),\n/* harmony export */   env: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_2__.env),\n/* harmony export */   g: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_17__),\n/* harmony export */   highlighters: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   layout: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__.layout),\n/* harmony export */   linkAnchors: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   linkTools: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   mvc: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   routers: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   setTheme: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__.setTheme),\n/* harmony export */   shapes: () => (/* reexport module object */ _src_shapes_index_mjs__WEBPACK_IMPORTED_MODULE_18__),\n/* harmony export */   util: () => (/* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   version: () => (/* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_16__.version)\n/* harmony export */ });\n/* harmony import */ var _src_shapes_index_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/shapes/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/shapes/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/core.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/env/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/anchors/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectionPoints/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/elementTools/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/dist/version.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/core.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/index.mjs\");\n\n\n// joint core\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvam9pbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7O0FBRWpEO0FBc0J3Qjs7QUFFTiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvam9pbnQubWpzP2JiMjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2hhcGVzIGZyb20gJy4vc3JjL3NoYXBlcy9pbmRleC5tanMnO1xuXG4vLyBqb2ludCBjb3JlXG5leHBvcnQge1xuICAgIHNldFRoZW1lLFxuICAgIGNvbmZpZyxcbiAgICBlbnYsXG4gICAgYW5jaG9ycyxcbiAgICBsYXlvdXQsXG4gICAgbGlua0FuY2hvcnMsXG4gICAgY29ubmVjdGlvblBvaW50cyxcbiAgICBjb25uZWN0aW9uU3RyYXRlZ2llcyxcbiAgICBjb25uZWN0b3JzLFxuICAgIGRpYSxcbiAgICBoaWdobGlnaHRlcnMsXG4gICAgbXZjLFxuICAgIHJvdXRlcnMsXG4gICAgdXRpbCxcbiAgICBsaW5rVG9vbHMsXG4gICAgZWxlbWVudFRvb2xzLFxuICAgIFZlY3Rvcml6ZXIsXG4gICAgVixcbiAgICB2ZXJzaW9uLFxuICAgIGdcbn0gZnJvbSAnLi9zcmMvY29yZS5tanMnO1xuXG5leHBvcnQgeyBzaGFwZXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/joint.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/V/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/V/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/index.mjs\");\n// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\n\n\nconst V = (function() {\n\n    var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n    // SVG support is required.\n    if (!hasSvg) {\n\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error('SVG is required to use Vectorizer.');\n        };\n    }\n\n    // XML namespaces.\n    var ns = {\n        svg: 'http://www.w3.org/2000/svg',\n        xmlns: 'http://www.w3.org/2000/xmlns/',\n        xml: 'http://www.w3.org/XML/1998/namespace',\n        xlink: 'http://www.w3.org/1999/xlink',\n        xhtml: 'http://www.w3.org/1999/xhtml'\n    };\n\n    var SVGVersion = '1.1';\n\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n\n    var V = function(el, attrs, children) {\n\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n\n        if (!el) return;\n\n        if (V.isV(el)) {\n            el = el.node;\n        }\n\n        attrs = attrs || {};\n\n        if (V.isString(el)) {\n\n            el = el.trim();\n\n            if (el.toLowerCase() === 'svg') {\n\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n\n            } else if (el[0] === '<') {\n\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n                var svgDoc = V.createSvgDocument(el);\n\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n\n                    return arrayOfVels;\n                }\n\n                el = document.importNode(svgDoc.firstChild, true);\n\n            } else {\n\n                el = document.createElementNS(ns.svg, el);\n            }\n\n            V.ensureId(el);\n        }\n\n        this.node = el;\n\n        this.setAttributes(attrs);\n\n        if (children) {\n            this.append(children);\n        }\n\n        return this;\n    };\n\n    var VPrototype = V.prototype;\n\n    Object.defineProperty(VPrototype, 'id', {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */\n    VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */\n    VPrototype.transform = function(matrix, opt) {\n\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr('transform'));\n        }\n\n        if (opt && opt.absolute) {\n            return this.attr('transform', V.matrixToTransformString(matrix));\n        }\n\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n\n    VPrototype.translate = function(tx, ty, opt) {\n\n        opt = opt || {};\n        ty = ty || 0;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n        return this;\n    };\n\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n        opt = opt || {};\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n        angle %= 360;\n\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n        return this;\n    };\n\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n\n        sy = V.isUndefined(sy) ? sx : sy;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n        return this;\n    };\n\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);\n        }\n\n        try {\n\n            box = node.getBBox();\n\n        } catch (e) {\n\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n\n        if (withoutTransformations) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(box);\n        }\n\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n        return V.transformRect(box, matrix);\n    };\n\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n\n        var options = {};\n\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);\n        }\n\n        if (opt) {\n            if (opt.target) { // check if target exists\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else { // if we want to calculate the bbox recursively\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n            var children = this.children();\n            var n = children.length;\n\n            if (n === 0) {\n                return this.getBBox({ target: options.target, recursive: false });\n            }\n\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n\n            for (var i = 0; i < n; i++) {\n                var currentChild = children[i];\n\n                var childBBox;\n\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n                }\n\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n\n            return outputBBox;\n        }\n    };\n\n    // Text() helpers\n\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V('textPath');\n        var d = attrs.d;\n        if (d && attrs['xlink:href'] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for (var j = 0; j <= lastJ; j++) {\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V('tspan', annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs['class'];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs['font-size']);\n                if (!isFinite(fontSize)) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || ' ');\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = (maxFontSize * 1.2);\n        }\n        return fontMetrics;\n    }\n\n    var emRegex = /em$/;\n\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for (var i = 1; i < n; i++) {\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch (alignment) {\n            case 'middle':\n                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n                break;\n            case 'bottom':\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            case 'top':\n            default:\n                dy = (0.8 * flMaxFont);\n                break;\n        }\n        return dy;\n    }\n\n    VPrototype.text = function(content, opt) {\n\n        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr('x') || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [annotations];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = (defaultLineHeight === 'auto');\n        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            'xml:space': 'preserve',\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            'display': (content || displayEmpty) ? null : 'none'\n        });\n\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr('font-size'));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n        }\n\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === 'string') textPath = { d: textPath };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split('\\n');\n        var linesMetrics = [];\n        var annotatedY;\n        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n            var dy = lineHeight;\n            var lineClassName = 'v-line';\n            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: (i !== lastI && eol),\n                        lineHeight: (autoLineHeight) ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = '-';\n                lineClassName += ' v-empty-line';\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) {\n                    // Empty line with annotations.\n                    lineMetrics = {};\n                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                    let lineFontSize = fontSize;\n                    // Check if any of the annotations overrides the font size.\n                    for (let j = lineAnnotations.length; j > 0; j--) {\n                        const attrs = lineAnnotations[j - 1].attrs;\n                        if (!attrs || !('font-size' in attrs)) continue;\n                        const fs = parseFloat(attrs['font-size']);\n                        if (isFinite(fs)) {\n                            lineFontSize = fs;\n                            break;\n                        }\n                    }\n                    if (autoLineHeight) {\n                        if (i > 0) {\n                            dy = lineFontSize * 1.2;\n                        } else {\n                            annotatedY = lineFontSize * 0.8;\n                        }\n                    }\n                    // The font size is important for the native selection box height.\n                    lineNode.setAttribute('font-size', lineFontSize);\n                    lineMetrics.maxFontSize = lineFontSize;\n                }\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute('dy', dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute('x', x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1;      // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === 'top') {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = '0.8em';\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch (verticalAnchor) {\n                    case 'middle':\n                        dy = (0.3 - (rh / 2)) + 'em';\n                        break;\n                    case 'bottom':\n                        dy = (-rh - 0.3) + 'em';\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = '0em';\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n            }\n        }\n        containerNode.firstChild.setAttribute('dy', dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */\n    VPrototype.removeAttr = function(name) {\n\n        const trueName = attributeNames[name];\n\n        const { ns, local } = V.qualifyAttr(trueName);\n        const el = this.node;\n\n        if (ns) {\n            if (el.hasAttributeNS(ns, local)) {\n                el.removeAttributeNS(ns, local);\n            }\n        } else if (el.hasAttribute(trueName)) {\n            el.removeAttribute(trueName);\n        }\n        return this;\n    };\n\n    VPrototype.attr = function(name, value) {\n\n        if (V.isUndefined(name)) {\n\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n\n            for (var i = 0; i < attributes.length; i++) {\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n\n            return attrs;\n        }\n\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(attributeNames[name]);\n        }\n\n        if (typeof name === 'object') {\n\n            for (var attrName in name) {\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n\n        } else {\n\n            this.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    VPrototype.normalizePath = function() {\n\n        var tagName = this.tagName();\n        if (tagName === 'PATH') {\n            this.attr('d', V.normalizePathData(this.attr('d')));\n        }\n\n        return this;\n    };\n\n    VPrototype.remove = function() {\n\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n\n        return this;\n    };\n\n    VPrototype.empty = function() {\n\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttributes = function(attrs) {\n\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.append = function(els) {\n\n        if (!V.isArray(els)) {\n            els = [els];\n        }\n\n        for (var i = 0, len = els.length; i < len; i++) {\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n\n        return this;\n    };\n\n    VPrototype.prepend = function(els) {\n\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n\n    VPrototype.before = function(els) {\n\n        var node = this.node;\n        var parent = node.parentNode;\n\n        if (parent) {\n\n            if (!V.isArray(els)) {\n                els = [els];\n            }\n\n            for (var i = 0, len = els.length; i < len; i++) {\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n\n    VPrototype.svg = function() {\n\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n\n    VPrototype.tagName = function() {\n\n        return this.node.tagName.toUpperCase();\n    };\n\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) return V(defsNode);\n        return V('defs').appendTo(context);\n    };\n\n    VPrototype.clone = function() {\n\n        var clone = V(this.node.cloneNode(true/* deep */));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n\n    VPrototype.findOne = function(selector) {\n\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n\n    VPrototype.find = function(selector) {\n\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n\n        if (nodes) {\n\n            // Map DOM elements to `V`s.\n            for (var i = 0; i < nodes.length; i++) {\n                vels.push(V(nodes[i]));\n            }\n        }\n\n        return vels;\n    };\n\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n\n        var children = this.node.childNodes;\n\n        var outputArray = [];\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    },\n\n    // Find an index of an element inside its container.\n    VPrototype.index = function() {\n\n        var index = 0;\n        var node = this.node.previousSibling;\n\n        while (node) {\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n\n        return index;\n    };\n\n    VPrototype.findParentByClass = function(className, terminator) {\n\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n\n        while (node && node !== terminator && node !== ownerSVGElement) {\n\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n\n            node = node.parentNode;\n        }\n\n        return null;\n    };\n\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n    };\n\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n\n        var svg = this.svg().node;\n\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n\n        try {\n\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n\n    VPrototype.translateCenterToPoint = function(p) {\n\n        var bbox = this.getBBox({ target: this.svg() });\n        var center = bbox.center();\n\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n        position = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(position);\n        reference =  new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(reference);\n        target || (target = this.svg());\n\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr('transform', '');\n        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(\n            translateFromOrigin.matrix.multiply(\n                rotateAroundOrigin.matrix.multiply(\n                    translateToOrigin.matrix.multiply(\n                        ctm.scale(scale.sx, scale.sy)))));\n\n        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n        return this;\n    };\n\n    VPrototype.animateAlongPath = function(attrs, path) {\n\n        path = V.toNode(path);\n\n        var id = V.ensureId(path);\n        var animateMotion = V('animateMotion', attrs);\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n        animateMotion.append(mpath);\n\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n\n                var animationID = animation.getAttribute('id');\n                if (animationID) id2anim[animationID] = animation;\n\n                var targets = getTargets(animation);\n                for (var i = 0, len = targets.length; i < len; i++) {\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n\n\n    // Split a string into an array of tokens.\n    // https://infra.spec.whatwg.org/#ascii-whitespace\n    const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n    function getTokenList(str) {\n        if (!V.isString(str)) return [];\n        return str.trim().match(noHTMLWhitespaceRegex) || [];\n    }\n\n    VPrototype.hasClass = function(className) {\n        if (!V.isString(className)) return false;\n        return this.node.classList.contains(className.trim());\n    };\n\n    VPrototype.addClass = function(className) {\n        this.node.classList.add(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.removeClass = function(className) {\n        this.node.classList.remove(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.toggleClass = function(className, toAdd) {\n        const tokens = getTokenList(className);\n        for (let i = 0; i < tokens.length; i++) {\n            this.node.classList.toggle(tokens[i], toAdd);\n        }\n        return this;\n    };\n\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while (distance < length) {\n            sample = node.getPointAtLength(distance);\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\n            distance += interval;\n        }\n        return samples;\n    };\n\n    VPrototype.convertToPath = function() {\n\n        var path = V('path');\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr('d', d);\n        }\n        return path;\n    };\n\n    VPrototype.convertToPathData = function() {\n\n        var tagName = this.tagName();\n\n        switch (tagName) {\n            case 'PATH':\n                return this.attr('d');\n            case 'LINE':\n                return V.convertLineToPathData(this.node);\n            case 'POLYGON':\n                return V.convertPolygonToPathData(this.node);\n            case 'POLYLINE':\n                return V.convertPolylineToPathData(this.node);\n            case 'ELLIPSE':\n                return V.convertEllipseToPathData(this.node);\n            case 'CIRCLE':\n                return V.convertCircleToPathData(this.node);\n            case 'RECT':\n                return V.convertRectToPathData(this.node);\n        }\n\n        throw new Error(tagName + ' cannot be converted to PATH.');\n    };\n\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch (this.tagName()) {\n\n            case 'RECT':\n                x = parseFloat(this.attr('x')) || 0;\n                y = parseFloat(this.attr('y')) || 0;\n                width = parseFloat(this.attr('width')) || 0;\n                height = parseFloat(this.attr('height')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, width, height);\n\n            case 'CIRCLE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                r = parseFloat(this.attr('r')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse({ x: cx, y: cy }, r, r);\n\n            case 'ELLIPSE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                rx = parseFloat(this.attr('rx')) || 0;\n                ry = parseFloat(this.attr('ry')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse({ x: cx, y: cy }, rx, ry);\n\n            case 'POLYLINE':\n                points = V.getPointsFromSvgNode(this);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n\n            case 'POLYGON':\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n\n            case 'PATH':\n                d = this.attr('d');\n                if (!_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path(d);\n\n            case 'LINE':\n                x1 = parseFloat(this.attr('x1')) || 0;\n                y1 = parseFloat(this.attr('y1')) || 0;\n                x2 = parseFloat(this.attr('x2')) || 0;\n                y2 = parseFloat(this.attr('y2')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n        }\n\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({ target: target });\n        var center = bbox.center();\n\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\n        var spot;\n        var tagName = this.tagName();\n\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === 'RECT') {\n\n            var gRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(\n                parseFloat(this.attr('x') || 0),\n                parseFloat(this.attr('y') || 0),\n                parseFloat(this.attr('width')),\n                parseFloat(this.attr('height'))\n            );\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n\n            var i, sample, gp, centerDistance, refDistance, distance;\n\n            for (i = 0; i < samples.length; i++) {\n\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\n                }\n            }\n\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n\n        return spot;\n    };\n\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttribute = function(name, value) {\n\n        const el = this.node;\n\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n\n        const trueName = attributeNames[name];\n\n        const { ns } = V.qualifyAttr(trueName);\n        if (ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(ns, trueName, value);\n        } else if (trueName === 'id') {\n            el.id = value;\n        } else {\n            el.setAttribute(trueName, value);\n        }\n\n        return this;\n    };\n\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, { async: false });\n            return documentElement;\n        }\n\n        const svg = document.createElementNS(ns.svg, 'svg');\n        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n        svg.setAttribute('version', SVGVersion);\n        return svg;\n    };\n\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V('style', { type: 'text/css' }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    },\n\n    V.createCDATASection = function(data = '') {\n        const xml = document.implementation.createDocument(null, 'xml', null);\n        return xml.createCDATASection(data);\n    };\n\n    V.idCounter = 0;\n\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n\n        return 'v-' + (++V.idCounter);\n    };\n\n    V.toNode = function(el) {\n\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n    };\n\n    V.ensureId = function(node) {\n\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n\n        return (text || '').replace(/ /g, '\\u00A0');\n    };\n\n    V.isUndefined = function(value) {\n\n        return typeof value === 'undefined';\n    };\n\n    V.isString = function(value) {\n\n        return typeof value === 'string';\n    };\n\n    V.isObject = function(value) {\n\n        return value && (typeof value === 'object');\n    };\n\n    V.isArray = Array.isArray;\n\n    V.parseXML = function(data, opt) {\n\n        opt = opt || {};\n\n        var xml;\n\n        try {\n            var parser = new DOMParser();\n\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n\n            xml = parser.parseFromString(data, 'text/xml');\n        } catch (error) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\n            throw new Error('Invalid XML: ' + data);\n        }\n\n        return xml;\n    };\n\n    // Create an empty object which does not inherit any properties from `Object.prototype`.\n    // This is useful when we want to use an object as a dictionary without having to\n    // worry about inherited properties such as `toString`, `valueOf` etc.\n    const _attributeNames = Object.create(null);\n\n    // List of attributes for which not to split camel case words.\n    // It contains known SVG attribute names and may be extended with user-defined attribute names.\n    [\n        'baseFrequency',\n        'baseProfile',\n        'clipPathUnits',\n        'contentScriptType',\n        'contentStyleType',\n        'diffuseConstant',\n        'edgeMode',\n        'externalResourcesRequired',\n        'filterRes', // deprecated\n        'filterUnits',\n        'gradientTransform',\n        'gradientUnits',\n        'kernelMatrix',\n        'kernelUnitLength',\n        'keyPoints',\n        'lengthAdjust',\n        'limitingConeAngle',\n        'markerHeight',\n        'markerUnits',\n        'markerWidth',\n        'maskContentUnits',\n        'maskUnits',\n        'numOctaves',\n        'pathLength',\n        'patternContentUnits',\n        'patternTransform',\n        'patternUnits',\n        'pointsAtX',\n        'pointsAtY',\n        'pointsAtZ',\n        'preserveAlpha',\n        'preserveAspectRatio',\n        'primitiveUnits',\n        'refX',\n        'refY',\n        'requiredExtensions',\n        'requiredFeatures',\n        'specularConstant',\n        'specularExponent',\n        'spreadMethod',\n        'startOffset',\n        'stdDeviation',\n        'stitchTiles',\n        'surfaceScale',\n        'systemLanguage',\n        'tableValues',\n        'targetX',\n        'targetY',\n        'textLength',\n        'viewBox',\n        'viewTarget', // deprecated\n        'xChannelSelector',\n        'yChannelSelector',\n        'zoomAndPan' // deprecated\n    ].forEach((name) => _attributeNames[name] = name);\n\n    _attributeNames['xlinkShow'] = 'xlink:show';\n    _attributeNames['xlinkRole'] = 'xlink:role';\n    _attributeNames['xlinkActuate'] = 'xlink:actuate';\n    _attributeNames['xlinkHref'] = 'xlink:href';\n    _attributeNames['xlinkType'] = 'xlink:type';\n    _attributeNames['xlinkTitle'] = 'xlink:title';\n    _attributeNames['xmlBase'] = 'xml:base';\n    _attributeNames['xmlLang'] = 'xml:lang';\n    _attributeNames['xmlSpace'] = 'xml:space';\n\n    const attributeNames = new Proxy(_attributeNames, {\n        get(cache, name) {\n            // The cache is a dictionary of attribute names. See `_attributeNames` above.\n            // If the attribute name is not in the cache, it means that it is not\n            // a camel-case attribute name. In that case, we need to convert\n            // the attribute name to dash-separated words.\n            if (!V.supportCamelCaseAttributes) return name;\n            if (name in cache) {\n                return cache[name];\n            }\n            // Convert camel case to dash-separated words.\n            return (cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n    });\n\n    // Dictionary of attribute names\n    Object.defineProperty(V, 'attributeNames', {\n        enumerable: true,\n        value: attributeNames,\n        writable: false,\n    });\n\n    // Should camel case attributes be supported?\n    Object.defineProperty(V, 'supportCamelCaseAttributes', {\n        enumerable: true,\n        value: true,\n        writable: true,\n    });\n\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */\n    V.qualifyAttr = function(name) {\n\n        if (name.indexOf(':') !== -1) {\n            var combinedKey = name.split(':');\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n\n        return {\n            ns: null,\n            local: name\n        };\n    };\n\n    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n    // This regex is used by `split()`, so it doesn't need to use /g\n    V.transformSeparatorRegex = /[ ,]+/;\n    // Note: All following regexes are more restrictive than SVG specification\n    // ReDoS mitigation: Use an anchor at the beginning of the match\n    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n    // ReDoS mitigation: Don't match initial `(` inside repeated part\n    // The following regex needs to use /g (= cannot use capturing groups)\n    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n    // The following regexes need to use capturing groups (= cannot use /g)\n    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\n    V.transformStringToMatrix = function(transform) {\n\n        // Initialize result matrix as identity matrix\n        let transformationMatrix = V.createSVGMatrix();\n\n        // Note: Multiple transform functions are allowed in `transform` string\n        // `match()` returns `null` if none found\n        const transformMatches = transform && transform.match(V.transformRegex);\n        if (!transformMatches) {\n            // Return identity matrix\n            return transformationMatrix;\n        }\n\n        const numMatches = transformMatches.length;\n        for (let i = 0; i < numMatches; i++) {\n\n            const transformMatch = transformMatches[i];\n            // Use same regex as above, but with capturing groups\n            // `match()` returns values of capturing groups as `[1]`, `[2]`\n            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n            if (transformFunctionMatch) {\n\n                let sx, sy, tx, ty, angle;\n                let ctm = V.createSVGMatrix();\n                const transformFunction = transformFunctionMatch[1].toLowerCase();\n                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                switch (transformFunction) {\n\n                    case 'scale':\n                        sx = parseFloat(args[0]);\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n\n                    case 'translate':\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n\n                    case 'rotate':\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n\n                    case 'skewx':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n\n                    case 'skewy':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n\n                    case 'matrix':\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n\n                    default:\n                        continue;\n                }\n\n                // Multiply current transformation into result matrix\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n\n        }\n        return transformationMatrix;\n    };\n\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n\n        return 'matrix(' +\n            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n            (matrix.f !== undefined ? matrix.f : 0) +\n            ')';\n    };\n\n    V.parseTransformString = function(transform) {\n\n        var translate, rotate, scale;\n\n        if (transform) {\n\n            var separator = V.transformSeparatorRegex;\n\n            // Special handling for `transform` with one or more matrix functions\n            if (transform.trim().indexOf('matrix') >= 0) {\n\n                // Convert EVERYTHING in `transform` string to a matrix\n                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                // Note: In non-matrix case, we only take first one of each (if any)\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n                // Extract `translate`, `scale`, `rotate` from matrix\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n                rotate = [decomposedMatrix.rotation];\n\n                // Rewrite `transform` string in `translate scale rotate` format\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push('translate(' + translate + ')');\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push('scale(' + scale + ')');\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push('rotate(' + rotate + ')');\n                }\n                transform = transformations.join(' ');\n\n            } else {\n\n                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                // Note: We only detect the first match of each (if any)\n                // `match()` returns value of capturing group as `[1]`\n                const translateMatch = transform.match(V.transformTranslateRegex);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                const rotateMatch = transform.match(V.transformRotateRegex);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                const scaleMatch = transform.match(V.transformScaleRegex);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n        return {\n            value: transform,\n            translate: {\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n\n    V.deltaTransformPoint = function(matrix, point) {\n\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return { x: dx, y: dy };\n    };\n\n    V.decomposeMatrix = function(matrix) {\n\n        // @see https://gist.github.com/2052247\n\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n        // calculate skew\n        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n        return {\n\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n\n        var p = { x: 0, y: 1 };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n\n        return {\n            angle: _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.normalizeAngle(_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n\n        return {\n            tx: (matrix && matrix.e) || 0,\n            ty: (matrix && matrix.f) || 0\n        };\n    };\n\n    V.isV = function(object) {\n\n        return object instanceof V;\n    };\n\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n    };\n\n    var svgDocument = V('svg').node;\n\n    V.createSVGMatrix = function(matrix) {\n\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for (var component in matrix) {\n            svgMatrix[component] = matrix[component];\n        }\n\n        return svgMatrix;\n    };\n\n    V.createSVGTransform = function(matrix) {\n\n        if (!V.isUndefined(matrix)) {\n\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n\n        return svgDocument.createSVGTransform();\n    };\n\n    V.createSVGPoint = function(x, y) {\n\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n\n    V.transformRect = function(r, matrix) {\n\n        var p = svgDocument.createSVGPoint();\n\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n\n    V.transformPoint = function(p, matrix) {\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n\n    V.transformLine = function(l, matrix) {\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Line(\n            V.transformPoint(l.start, matrix),\n            V.transformPoint(l.end, matrix)\n        );\n    };\n\n    V.transformPolyline = function(p, matrix) {\n\n        var inPoints = (p instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline) ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(outPoints);\n    };\n\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(';');\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            var pair = style.split('=');\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? '0' : '1';\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n\n        return (da >= svgArcMax)\n            ? (r0\n                ? 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'M0,' + r0\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n                + 'Z'\n                : 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'Z')\n            : (r0\n                ? 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L' + r0 * c1 + ',' + r0 * s1\n                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n                + 'Z'\n                : 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L0,0'\n                + 'Z');\n    };\n\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n\n        for (var attr in b) {\n\n            if (attr === 'class') {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n            } else if (attr === 'style') {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n\n        return a;\n    };\n\n    V.annotateString = function(t, annotations, opt) {\n\n        annotations = annotations || [];\n        opt = opt || {};\n\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n\n        for (var i = 0; i < t.length; i++) {\n\n            item = ret[i] = t[i];\n\n            for (var j = 0; j < annotations.length; j++) {\n\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n\n            prev = ret[i - 1];\n\n            if (!prev) {\n\n                batch = item;\n\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || '') + item;\n            }\n        }\n\n        if (batch) {\n            compacted.push(batch);\n        }\n\n        return compacted;\n    };\n\n    V.findAnnotationsAtIndex = function(annotations, index) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n\n        return annotations;\n    };\n\n    V.convertLineToPathData = function(line) {\n\n        line = V(line);\n        var d = [\n            'M', line.attr('x1'), line.attr('y1'),\n            'L', line.attr('x2'), line.attr('y2')\n        ].join(' ');\n        return d;\n    };\n\n    V.convertPolygonToPathData = function(polygon) {\n\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points) + ' Z';\n    };\n\n    V.convertPolylineToPathData = function(polyline) {\n\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points);\n    };\n\n    V.svgPointsToPath = function(points) {\n\n        for (var i = 0, n = points.length; i < n; i++) {\n            points[i] = points[i].x + ' ' + points[i].y;\n        }\n\n        return 'M ' + points.join(' L');\n    };\n\n    V.getPointsFromSvgNode = function(node) {\n\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n                points.push(nodePoints.getItem(i));\n            }\n        }\n\n        return points;\n    };\n\n    V.KAPPA = 0.551784;\n\n    V.convertCircleToPathData = function(circle) {\n\n        circle = V(circle);\n        var cx = parseFloat(circle.attr('cx')) || 0;\n        var cy = parseFloat(circle.attr('cy')) || 0;\n        var r = parseFloat(circle.attr('r'));\n        var cd = r * V.KAPPA; // Control distance.\n\n        var d = [\n            'M', cx, cy - r,    // Move to the first point.\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertEllipseToPathData = function(ellipse) {\n\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\n        var rx = parseFloat(ellipse.attr('rx'));\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n\n        var d = [\n            'M', cx, cy - ry,    // Move to the first point.\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertRectToPathData = function(rect) {\n\n        rect = V(rect);\n\n        return V.rectToPath({\n            x: parseFloat(rect.attr('x')) || 0,\n            y: parseFloat(rect.attr('y')) || 0,\n            width: parseFloat(rect.attr('width')) || 0,\n            height: parseFloat(rect.attr('height')) || 0,\n            rx: parseFloat(rect.attr('rx')) || 0,\n            ry: parseFloat(rect.attr('ry')) || 0\n        });\n    };\n\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                'M', x, y + topRy,\n                'v', height - topRy - bottomRy,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n                'h', width - 2 * bottomRx,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n                'v', -(height - bottomRy - topRy),\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n                'h', -(width - 2 * topRx),\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n                'Z'\n            ];\n        } else {\n            d = [\n                'M', x, y,\n                'H', x + width,\n                'V', y + height,\n                'H', x,\n                'V', y,\n                'Z'\n            ];\n        }\n\n        return d.join(' ');\n    };\n\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = (function() {\n\n        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n\n        function q2c(x1, y1, ax, ay, x2, y2) {\n\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n        }\n\n        function rotate(x, y, rad) {\n\n            var X = (x * cos(rad)) - (y * sin(rad));\n            var Y = (x * sin(rad)) + (y * cos(rad));\n            return { x: X, y: Y };\n        }\n\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = (PI * 120) / 180;\n            var rad = (PI / 180) * (+angle || 0);\n            var res = [];\n            var xy;\n\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n\n                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n                if (!Number.isFinite(k)) {\n                    // Arc is a single point\n                    return [x1, y1, x2, y2, x2, y2];\n                }\n\n                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = ((x1 < cx) ? (PI - f1) : f1);\n                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n                if (f1 < 0) f1 = (PI * 2) + f1;\n                if (f2 < 0) f2 = (PI * 2) + f2;\n\n                if (sweep_flag && (f1 > f2)) f1 = f1 - (PI * 2);\n                if (!sweep_flag && (f2 > f1)) f2 = f2 - (PI * 2);\n\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n                x2 = cx + (rx * cos(f2));\n                y2 = cy + (ry * sin(f2));\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = (4 / 3) * (rx * t);\n            var hy = (4 / 3) * (ry * t);\n            var m1 = [x1, y1];\n            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n            var m4 = [x2, y2];\n\n            m2[0] = (2 * m1[0]) - m2[0];\n            m2[1] = (2 * m1[1]) - m2[1];\n\n            if (recursive) {\n                return [m2, m3, m4].concat(res);\n            } else {\n                res = [m2, m3, m4].concat(res).join().split(',');\n                var newres = [];\n                var ii = res.length;\n                for (var i = 0; i < ii; i++) {\n                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n\n        function parsePathString(pathString) {\n\n            if (!pathString) return null;\n\n            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n            var data = [];\n\n            String(pathString).replace(pathCommand, function(a, b, c) {\n\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n\n                if ((name === 'm') && (params.length > 2)) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = 'l';\n                    b = ((b === 'm') ? 'l' : 'L');\n                }\n\n                while (params.length >= paramCounts[name]) {\n                    data.push([b].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n\n            return data;\n        }\n\n        function pathToAbsolute(pathArray) {\n\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n                pathArray = parsePathString(pathArray);\n            }\n\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n\n            var ii = pathArray.length;\n            for (var i = start; i < ii; i++) {\n\n                var r = [];\n                res.push(r);\n\n                var pa = pathArray[i];\n                pa0 = pa[0];\n\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n\n                    var jj;\n                    var j;\n                    switch (r[0]) {\n                        case 'A':\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n\n                        case 'V':\n                            r[1] = +pa[1] + y;\n                            break;\n\n                        case 'H':\n                            r[1] = +pa[1] + x;\n                            break;\n\n                        case 'M':\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n\n                        default:\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for (var k = 0; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n\n                switch (r[0]) {\n                    case 'Z':\n                        x = +mx;\n                        y = +my;\n                        break;\n\n                    case 'H':\n                        x = r[1];\n                        break;\n\n                    case 'V':\n                        y = r[1];\n                        break;\n\n                    case 'M':\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n\n            return res;\n        }\n\n        function normalize(path) {\n\n            var p = pathToAbsolute(path);\n            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n            function processPath(path, d, pcom) {\n\n                var nx, ny;\n\n                if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n                if (!(path[0] in { T: 1, Q: 1 })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n\n                switch (path[0]) {\n                    case 'M':\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n\n                    case 'A':\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = ['L', path[6], path[7]];\n                        } else {\n                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        }\n                        break;\n\n                    case 'S':\n                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n                        } else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = ['C', nx, ny].concat(path.slice(1));\n                        break;\n\n                    case 'T':\n                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n                        } else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n\n                    case 'Q':\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n\n                    case 'H':\n                        path = ['L'].concat(path[1], d.y);\n                        break;\n\n                    case 'V':\n                        path = ['L'].concat(d.x, path[1]);\n                        break;\n\n                    case 'L':\n                        break;\n\n                    case 'Z':\n                        break;\n                }\n\n                return path;\n            }\n\n            function fixArc(pp, i) {\n\n                if (pp[i].length > 7) {\n\n                    pp[i].shift();\n                    var pi = pp[i];\n\n                    while (pi.length) {\n                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n                    }\n\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n\n            var pcoms = []; // path commands of original path p\n            var pfirst = ''; // temporary holder for original path command\n            var pcom = ''; // holder for previous path command of original path\n\n            var ii = p.length;\n            for (var i = 0; i < ii; i++) {\n                if (p[i]) pfirst = p[i][0]; // save current path command\n\n                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n                var seg = p[i];\n                var seglen = seg.length;\n\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== 'M') {\n                p.unshift(['M', 0, 0]);\n            }\n\n            return p;\n        }\n\n        return function(pathData) {\n            return normalize(pathData).join(',').split(',').join(' ');\n        };\n    })();\n\n    V.namespace = ns;\n\n    V.g = _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__;\n\n    return V;\n\n})();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (V);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL1YvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFb0M7O0FBRXBDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0UsU0FBUzs7QUFFekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYzs7QUFFZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3Qjs7QUFFQTs7QUFFQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsOENBQU07QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0Ryx5SUFBeUk7QUFDekk7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNO0FBQzdCOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQU07QUFDakMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsMENBQTBDO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLDRCQUE0QixPQUFPO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsMENBQTBDO0FBQ2pHLGtCQUFrQjtBQUNsQjtBQUNBLHVEQUF1RCx5Q0FBeUM7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxrQ0FBa0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7O0FBRVY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25ELHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0Msb0JBQW9CO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLCtDQUFPO0FBQzlCLHlCQUF5QiwrQ0FBTztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCOztBQUV6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUE4QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUFTLEdBQUcsY0FBYzs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpREFBUyxHQUFHLGNBQWM7O0FBRXJEO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQVU7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBVTs7QUFFckM7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBTTtBQUMzQiwyQkFBMkIsOENBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQU0sR0FBRyxjQUFjLElBQUksY0FBYztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsOENBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBTTs7QUFFOUIsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0Isb0JBQW9COztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QywwQ0FBMEM7QUFDbEYsa0JBQWtCO0FBQ2xCLDBDQUEwQywwQ0FBMEM7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsT0FBTyxpQkFBaUIsU0FBUyxhQUFhLFdBQVcsSUFBSSxRQUFRO0FBQ2xILG9CQUFvQixrQkFBa0IsMEJBQTBCLGNBQWM7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU8sZUFBZSxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnQkFBZ0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxVQUFVLDJJQUEySTtBQUNySjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBLDBGQUEwRjtBQUMxRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsUUFBUTs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTs7QUFFQTs7QUFFQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLDJCQUEyQjs7QUFFM0I7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQyw0Q0FBNEM7O0FBRTVDLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsb0RBQW9EO0FBQ3BEOztBQUVBLHVEQUF1RDs7QUFFdkQsd0VBQXdFO0FBQ3hFO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxVQUFVLHlDQUFDOztBQUVYOztBQUVBLENBQUM7O0FBRUQsaUVBQWUsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvVi9pbmRleC5tanM/YzQ0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBWZWN0b3JpemVyLlxuLy8gLS0tLS0tLS0tLS1cblxuLy8gQSB0aW55IGxpYnJhcnkgZm9yIG1ha2luZyB5b3VyIGxpZmUgZWFzaWVyIHdoZW4gZGVhbGluZyB3aXRoIFNWRy5cbi8vIFRoZSBvbmx5IFZlY3Rvcml6ZXIgZGVwZW5kZW5jeSBpcyB0aGUgR2VvbWV0cnkgbGlicmFyeS5cblxuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbmNvbnN0IFYgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaGFzU3ZnID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgISF3aW5kb3cuU1ZHQW5nbGU7XG5cbiAgICAvLyBTVkcgc3VwcG9ydCBpcyByZXF1aXJlZC5cbiAgICBpZiAoIWhhc1N2Zykge1xuXG4gICAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgdGhyb3dzIGFuIGVycm9yIHdoZW4gaXQgaXMgdXNlZC5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTVkcgaXMgcmVxdWlyZWQgdG8gdXNlIFZlY3Rvcml6ZXIuJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gWE1MIG5hbWVzcGFjZXMuXG4gICAgdmFyIG5zID0ge1xuICAgICAgICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nLFxuICAgICAgICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxuICAgICAgICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICAgICB4aHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnXG4gICAgfTtcblxuICAgIHZhciBTVkdWZXJzaW9uID0gJzEuMSc7XG5cbiAgICAvLyBEZWNsYXJlIHNob3J0aGFuZHMgdG8gdGhlIG1vc3QgdXNlZCBtYXRoIGZ1bmN0aW9ucy5cbiAgICB2YXIgbWF0aCA9IE1hdGg7XG4gICAgdmFyIFBJID0gbWF0aC5QSTtcbiAgICB2YXIgYXRhbjIgPSBtYXRoLmF0YW4yO1xuICAgIHZhciBzcXJ0ID0gbWF0aC5zcXJ0O1xuICAgIHZhciBtaW4gPSBtYXRoLm1pbjtcbiAgICB2YXIgbWF4ID0gbWF0aC5tYXg7XG4gICAgdmFyIGNvcyA9IG1hdGguY29zO1xuICAgIHZhciBzaW4gPSBtYXRoLnNpbjtcblxuICAgIHZhciBWID0gZnVuY3Rpb24oZWwsIGF0dHJzLCBjaGlsZHJlbikge1xuXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHVzaW5nIFYoKSB3aXRob3V0IHRoZSBuZXcga2V5d29yZC5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFYpKSB7XG4gICAgICAgICAgICByZXR1cm4gVi5hcHBseShPYmplY3QuY3JlYXRlKFYucHJvdG90eXBlKSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZWwpIHJldHVybjtcblxuICAgICAgICBpZiAoVi5pc1YoZWwpKSB7XG4gICAgICAgICAgICBlbCA9IGVsLm5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuXG4gICAgICAgIGlmIChWLmlzU3RyaW5nKGVsKSkge1xuXG4gICAgICAgICAgICBlbCA9IGVsLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKGVsLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgU1ZHIGNhbnZhcy5cbiAgICAgICAgICAgICAgICBlbCA9IFYuY3JlYXRlU3ZnRG9jdW1lbnQoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbFswXSA9PT0gJzwnKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZWxlbWVudCBmcm9tIGFuIFNWRyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgLy8gQWxsb3dzIGNvbnN0cnVjdHMgb2YgdHlwZTogYGRvY3VtZW50LmFwcGVuZENoaWxkKFYoJzxyZWN0PjwvcmVjdD4nKS5ub2RlKWAuXG5cbiAgICAgICAgICAgICAgICB2YXIgc3ZnRG9jID0gVi5jcmVhdGVTdmdEb2N1bWVudChlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgYFYoKWAgbWlnaHQgYWxzbyByZXR1cm4gYW4gYXJyYXkgc2hvdWxkIHRoZSBTVkcgc3RyaW5nIHBhc3NlZCBhc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBhcmd1bWVudCBjb250YWluIG1vcmUgdGhhbiBvbmUgcm9vdCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGlmIChzdmdEb2MuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFwIGNoaWxkIG5vZGVzIHRvIGBWYHMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU9mVmVscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN2Z0RvYy5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBzdmdEb2MuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5T2ZWZWxzLnB1c2gobmV3IFYoZG9jdW1lbnQuaW1wb3J0Tm9kZShjaGlsZE5vZGUsIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlPZlZlbHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5pbXBvcnROb2RlKHN2Z0RvYy5maXJzdENoaWxkLCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLnN2ZywgZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBWLmVuc3VyZUlkKGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubm9kZSA9IGVsO1xuXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyhhdHRycyk7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChjaGlsZHJlbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdmFyIFZQcm90b3R5cGUgPSBWLnByb3RvdHlwZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWUHJvdG90eXBlLCAnaWQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmlkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTVkdHRWxlbWVudH0gdG9FbGVtXG4gICAgICogQHJldHVybnMge1NWR01hdHJpeH1cbiAgICAgKi9cbiAgICBWUHJvdG90eXBlLmdldFRyYW5zZm9ybVRvRWxlbWVudCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgaWYgKFYuaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSAmJiBWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q1RNID0gVi50b05vZGUodGFyZ2V0KS5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICAgIHZhciBub2RlQ1RNID0gbm9kZS5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDVE0gJiYgbm9kZUNUTSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRDVE0uaW52ZXJzZSgpLm11bHRpcGx5KG5vZGVDVE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvdWxkIG5vdCBnZXQgYWN0dWFsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTVkdNYXRyaXh9IG1hdHJpeFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0XG4gICAgICogQHJldHVybnMge1ZlY3Rvcml6ZXJ8U1ZHTWF0cml4fSBTZXR0ZXIgLyBHZXR0ZXJcbiAgICAgKi9cbiAgICBWUHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG1hdHJpeCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmIChWLmlzVW5kZWZpbmVkKG1hdHJpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVN0cmluZ1RvTWF0cml4KHRoaXMuYXR0cigndHJhbnNmb3JtJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdCAmJiBvcHQuYWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcobWF0cml4KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ZnVHJhbnNmb3JtID0gVi5jcmVhdGVTVkdUcmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgbm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5hcHBlbmRJdGVtKHN2Z1RyYW5zZm9ybSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHR4LCB0eSwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB0eSA9IHR5IHx8IDA7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybUF0dHIgPSB0aGlzLmF0dHIoJ3RyYW5zZm9ybScpIHx8ICcnO1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gVi5wYXJzZVRyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1BdHRyKTtcbiAgICAgICAgdHJhbnNmb3JtQXR0ciA9IHRyYW5zZm9ybS52YWx1ZTtcbiAgICAgICAgLy8gSXMgaXQgYSBnZXR0ZXI/XG4gICAgICAgIGlmIChWLmlzVW5kZWZpbmVkKHR4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtQXR0ci5yZXBsYWNlKC90cmFuc2xhdGVcXChbXildKlxcKS9nLCAnJykudHJpbSgpO1xuXG4gICAgICAgIHZhciBuZXdUeCA9IG9wdC5hYnNvbHV0ZSA/IHR4IDogdHJhbnNmb3JtLnRyYW5zbGF0ZS50eCArIHR4O1xuICAgICAgICB2YXIgbmV3VHkgPSBvcHQuYWJzb2x1dGUgPyB0eSA6IHRyYW5zZm9ybS50cmFuc2xhdGUudHkgKyB0eTtcbiAgICAgICAgdmFyIG5ld1RyYW5zbGF0ZSA9ICd0cmFuc2xhdGUoJyArIG5ld1R4ICsgJywnICsgbmV3VHkgKyAnKSc7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGB0cmFuc2xhdGUoKWAgaXMgYWx3YXlzIHRoZSBmaXJzdCB0cmFuc2Zvcm1hdGlvbi4gVGhpcyBpc1xuICAgICAgICAvLyB1c3VhbGx5IHRoZSBkZXNpcmVkIGNhc2UuXG4gICAgICAgIHRoaXMuYXR0cigndHJhbnNmb3JtJywgKG5ld1RyYW5zbGF0ZSArICcgJyArIHRyYW5zZm9ybUF0dHIpLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCBjeCwgY3ksIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtQXR0ciA9IHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJyc7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBWLnBhcnNlVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybUF0dHIpO1xuICAgICAgICB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtLnZhbHVlO1xuXG4gICAgICAgIC8vIElzIGl0IGEgZ2V0dGVyP1xuICAgICAgICBpZiAoVi5pc1VuZGVmaW5lZChhbmdsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0ucm90YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNmb3JtQXR0ciA9IHRyYW5zZm9ybUF0dHIucmVwbGFjZSgvcm90YXRlXFwoW14pXSpcXCkvZywgJycpLnRyaW0oKTtcblxuICAgICAgICBhbmdsZSAlPSAzNjA7XG5cbiAgICAgICAgdmFyIG5ld0FuZ2xlID0gb3B0LmFic29sdXRlID8gYW5nbGUgOiB0cmFuc2Zvcm0ucm90YXRlLmFuZ2xlICsgYW5nbGU7XG4gICAgICAgIHZhciBuZXdPcmlnaW4gPSAoY3ggIT09IHVuZGVmaW5lZCAmJiBjeSAhPT0gdW5kZWZpbmVkKSA/ICcsJyArIGN4ICsgJywnICsgY3kgOiAnJztcbiAgICAgICAgdmFyIG5ld1JvdGF0ZSA9ICdyb3RhdGUoJyArIG5ld0FuZ2xlICsgbmV3T3JpZ2luICsgJyknO1xuXG4gICAgICAgIHRoaXMuYXR0cigndHJhbnNmb3JtJywgKHRyYW5zZm9ybUF0dHIgKyAnICcgKyBuZXdSb3RhdGUpLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBOb3RlIHRoYXQgYHNjYWxlYCBhcyB0aGUgb25seSB0cmFuc2Zvcm1hdGlvbiBkb2VzIG5vdCBjb21iaW5lIHdpdGggcHJldmlvdXMgdmFsdWVzLlxuICAgIFZQcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihzeCwgc3kpIHtcblxuICAgICAgICBzeSA9IFYuaXNVbmRlZmluZWQoc3kpID8gc3ggOiBzeTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtQXR0ciA9IHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJyc7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBWLnBhcnNlVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybUF0dHIpO1xuICAgICAgICB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtLnZhbHVlO1xuXG4gICAgICAgIC8vIElzIGl0IGEgZ2V0dGVyP1xuICAgICAgICBpZiAoVi5pc1VuZGVmaW5lZChzeCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm0uc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtQXR0ci5yZXBsYWNlKC9zY2FsZVxcKFteKV0qXFwpL2csICcnKS50cmltKCk7XG5cbiAgICAgICAgdmFyIG5ld1NjYWxlID0gJ3NjYWxlKCcgKyBzeCArICcsJyArIHN5ICsgJyknO1xuXG4gICAgICAgIHRoaXMuYXR0cigndHJhbnNmb3JtJywgKHRyYW5zZm9ybUF0dHIgKyAnICcgKyBuZXdTY2FsZSkudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEdldCBTVkdSZWN0IHRoYXQgY29udGFpbnMgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbiBvZiB0aGUgcmVhbCBib3VuZGluZyBib3gsXG4gICAgLy8gaS5lLiBhZnRlciB0cmFuc2Zvcm1hdGlvbnMgYXJlIGFwcGxpZWQuXG4gICAgLy8gSWYgYHRhcmdldGAgaXMgc3BlY2lmaWVkLCBib3VuZGluZyBib3ggd2lsbCBiZSBjb21wdXRlZCByZWxhdGl2ZWx5IHRvIGB0YXJnZXRgIGVsZW1lbnQuXG4gICAgVlByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24od2l0aG91dFRyYW5zZm9ybWF0aW9ucywgdGFyZ2V0KSB7XG5cbiAgICAgICAgdmFyIGJveDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIHZhciBvd25lclNWR0VsZW1lbnQgPSBub2RlLm93bmVyU1ZHRWxlbWVudDtcblxuICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgaW4gdGhlIGxpdmUgRE9NLCBpdCBkb2VzIG5vdCBoYXZlIGEgYm91bmRpbmcgYm94IGRlZmluZWQgYW5kXG4gICAgICAgIC8vIHNvIGZhbGwgYmFjayB0byAnemVybycgZGltZW5zaW9uIGVsZW1lbnQuXG4gICAgICAgIGlmICghb3duZXJTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGcuUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIGJveCA9IG5vZGUuZ2V0QkJveCgpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIElFLlxuICAgICAgICAgICAgYm94ID0ge1xuICAgICAgICAgICAgICAgIHg6IG5vZGUuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgICB5OiBub2RlLmNsaWVudFRvcCxcbiAgICAgICAgICAgICAgICB3aWR0aDogbm9kZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpdGhvdXRUcmFuc2Zvcm1hdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZy5SZWN0KGJveCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQodGFyZ2V0IHx8IG93bmVyU1ZHRWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuIFYudHJhbnNmb3JtUmVjdChib3gsIG1hdHJpeCk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgYW4gU1ZHUmVjdCB0aGF0IGNvbnRhaW5zIGNvb3JkaW5hdGVzIGFuZCBkaW1lbnNpb25zIG9mIHRoZSByZWFsIGJvdW5kaW5nIGJveCxcbiAgICAvLyBpLmUuIGFmdGVyIHRyYW5zZm9ybWF0aW9ucyBhcmUgYXBwbGllZC5cbiAgICAvLyBGaXhlcyBhIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gYnVnIHRoYXQgcmV0dXJucyBpbmNvcnJlY3QgYm91bmRpbmcgYm94ZXMgZm9yIGdyb3VwcyBvZiBzdmcgZWxlbWVudHMuXG4gICAgLy8gVGFrZXMgYW4gKE9iamVjdCkgYG9wdGAgYXJndW1lbnQgKG9wdGlvbmFsKSB3aXRoIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICAvLyAoT2JqZWN0KSBgdGFyZ2V0YCAob3B0aW9uYWwpOiBpZiBub3QgdW5kZWZpbmVkLCB0cmFuc2Zvcm0gYm91bmRpbmcgYm94ZXMgcmVsYXRpdmUgdG8gYHRhcmdldGA7IGlmIHVuZGVmaW5lZCwgdHJhbnNmb3JtIHJlbGF0aXZlIHRvIHRoaXNcbiAgICAvLyAoQm9vbGVhbikgYHJlY3Vyc2l2ZWAgKG9wdGlvbmFsKTogaWYgdHJ1ZSwgcmVjdXJzaXZlbHkgZW50ZXIgYWxsIGdyb3VwcyBhbmQgZ2V0IGEgdW5pb24gb2YgZWxlbWVudCBib3VuZGluZyBib3hlcyAoc3ZnIGJib3ggZml4KTsgaWYgZmFsc2Ugb3IgdW5kZWZpbmVkLCByZXR1cm4gcmVzdWx0IG9mIG5hdGl2ZSBmdW5jdGlvbiB0aGlzLm5vZGUuZ2V0QkJveCgpO1xuICAgIFZQcm90b3R5cGUuZ2V0QkJveCA9IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICAgICAgdmFyIG91dHB1dEJCb3g7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICB2YXIgb3duZXJTVkdFbGVtZW50ID0gbm9kZS5vd25lclNWR0VsZW1lbnQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IGluIHRoZSBsaXZlIERPTSwgaXQgZG9lcyBub3QgaGF2ZSBhIGJvdW5kaW5nIGJveCBkZWZpbmVkIGFuZFxuICAgICAgICAvLyBzbyBmYWxsIGJhY2sgdG8gJ3plcm8nIGRpbWVuc2lvbiBlbGVtZW50LlxuICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgYW4gU1ZHR3JhcGhpY3NFbGVtZW50LCB3ZSBjb3VsZCBub3QgbWVhc3VyZSB0aGUgYm91bmRpbmcgYm94IGVpdGhlclxuICAgICAgICBpZiAoIW93bmVyU1ZHRWxlbWVudCB8fCAhVi5pc1NWR0dyYXBoaWNzRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3QoMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICBpZiAob3B0LnRhcmdldCkgeyAvLyBjaGVjayBpZiB0YXJnZXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgb3B0aW9ucy50YXJnZXQgPSBWLnRvTm9kZShvcHQudGFyZ2V0KTsgLy8gd29ya3MgZm9yIFYgb2JqZWN0cywganF1ZXJ5IG9iamVjdHMsIGFuZCBub2RlIG9iamVjdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQucmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWN1cnNpdmUgPSBvcHQucmVjdXJzaXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXRCQm94ID0gbm9kZS5nZXRCQm94KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIElFLlxuICAgICAgICAgICAgICAgIG91dHB1dEJCb3ggPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG5vZGUuY2xpZW50TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgeTogbm9kZS5jbGllbnRUb3AsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBsaWtlIHRoaXMgKHRoYXQgaXMsIG5vdCBhdCBhbGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3Qob3V0cHV0QkJveCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBsaWtlIHRhcmdldFxuICAgICAgICAgICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmdldFRyYW5zZm9ybVRvRWxlbWVudChvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYudHJhbnNmb3JtUmVjdChvdXRwdXRCQm94LCBtYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBpZiB3ZSB3YW50IHRvIGNhbGN1bGF0ZSB0aGUgYmJveCByZWN1cnNpdmVseVxuICAgICAgICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IGNvcnJlY3QgYmJveCBhcm91bmQgc3ZnIGVsZW1lbnRzIChvbmUgdGhhdCBlbnZlbG9wcyB0aGUgcGF0aCBsaW5lcyB0aWdodGx5KVxuICAgICAgICAgICAgLy8gYnV0IHNvbWUgYnJvd3NlcnMgZmFpbCB0byByZXBvcnQgdGhlIHNhbWUgYmJveCB3aGVuIHRoZSBlbGVtZW50cyBhcmUgaW4gYSBncm91cCAocmV0dXJuaW5nIGEgbG9vc2VyIGJib3ggdGhhdCBhbHNvIGluY2x1ZGVzIGNvbnRyb2wgcG9pbnRzLCBsaWtlIG5vZGUuZ2V0Q2xpZW50UmVjdCgpKVxuICAgICAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGV2ZW4gaWYgd2Ugd3JhcCBhIHNpbmdsZSBzdmcgZWxlbWVudCBpbnRvIGEgZ3JvdXAhXG4gICAgICAgICAgICAvLyB0aGlzIG9wdGlvbiBzZXR0aW5nIG1ha2VzIHRoZSBmdW5jdGlvbiByZWN1cnNpdmVseSBlbnRlciBhbGwgdGhlIGdyb3VwcyBmcm9tIHRoaXMgYW5kIGRlZXBlciwgZ2V0IGJib3hlcyBvZiB0aGUgZWxlbWVudHMgaW5zaWRlLCB0aGVuIHJldHVybiBhIHVuaW9uIG9mIHRob3NlIGJib3hlc1xuXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCQm94KHsgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCwgcmVjdXJzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVjdXJzaW9uJ3MgaW5pdGlhbCBwYXNzLXRocm91Z2ggc2V0dGluZzpcbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZSBwYXNzZXMtdGhyb3VnaCBqdXN0IGtlZXAgdGhlIHRhcmdldCBhcyB3aGF0ZXZlciB3YXMgc2V0IHVwIGhlcmUgZHVyaW5nIHRoZSBpbml0aWFsIHBhc3MtdGhyb3VnaFxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBjaGlsZHJlbi9kZXNjZW5kYW50cyBsaWtlIHRoaXMgKHRoZWlyIHBhcmVudC9hbmNlc3RvcilcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICB9IC8vIGVsc2UgdHJhbnNmb3JtIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIGxpa2UgdGFyZ2V0XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQkJveDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGN1cnJlbnRDaGlsZCBpcyBub3QgYSBncm91cCBlbGVtZW50LCBnZXQgaXRzIGJib3ggd2l0aCBhIG5vbnJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGlsZC5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEJCb3ggPSBjdXJyZW50Q2hpbGQuZ2V0QkJveCh7IHRhcmdldDogb3B0aW9ucy50YXJnZXQsIHJlY3Vyc2l2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudENoaWxkIGlzIGEgZ3JvdXAgZWxlbWVudCAoZGV0ZXJtaW5lZCBieSBjaGVja2luZyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuKSwgZW50ZXIgaXQgd2l0aCBhIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IGN1cnJlbnRDaGlsZC5nZXRCQm94KHsgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCwgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0QkJveCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0QkJveCA9IGNoaWxkQkJveDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgbmV3IGJvdW5kaW5nIGJveCByZWN0YW5nbGUgdGhhdCBjb250YWlucyB0aGlzIGNoaWxkJ3MgYm91bmRpbmcgYm94IGFuZCBwcmV2aW91cyBib3VuZGluZyBib3hcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0QkJveCA9IG91dHB1dEJCb3gudW5pb24oY2hpbGRCQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRCQm94O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRleHQoKSBoZWxwZXJzXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUZXh0UGF0aE5vZGUoYXR0cnMsIHZlbCkge1xuICAgICAgICBhdHRycyB8fCAoYXR0cnMgPSB7fSk7XG4gICAgICAgIHZhciB0ZXh0UGF0aEVsZW1lbnQgPSBWKCd0ZXh0UGF0aCcpO1xuICAgICAgICB2YXIgZCA9IGF0dHJzLmQ7XG4gICAgICAgIGlmIChkICYmIGF0dHJzWyd4bGluazpocmVmJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gSWYgYG9wdC5hdHRyc2AgaXMgYSBwbGFpbiBzdHJpbmcsIGNvbnNpZGVyIGl0IHRvIGJlIGRpcmVjdGx5IHRoZVxuICAgICAgICAgICAgLy8gU1ZHIHBhdGggZGF0YSBmb3IgdGhlIHRleHQgdG8gZ28gYWxvbmcgKHRoaXMgaXMgYSBzaG9ydGN1dCkuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgaXQgaXMgYW4gb2JqZWN0IGFuZCBjb250YWlucyB0aGUgYGRgIHByb3BlcnR5LCB0aGVuIHRoaXMgaXMgb3VyIHBhdGguXG4gICAgICAgICAgICAvLyBXcmFwIHRoZSB0ZXh0IGluIHRoZSBTVkcgPHRleHRQYXRoPiBlbGVtZW50IHRoYXQgcG9pbnRzXG4gICAgICAgICAgICAvLyB0byBhIHBhdGggZGVmaW5lZCBieSBgb3B0LmF0dHJzYCBpbnNpZGUgdGhlIGA8ZGVmcz5gIGVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbGlua2VkUGF0aCA9IFYoJ3BhdGgnKS5hdHRyKCdkJywgZCkuYXBwZW5kVG8odmVsLmRlZnMoKSk7XG4gICAgICAgICAgICB0ZXh0UGF0aEVsZW1lbnQuYXR0cigneGxpbms6aHJlZicsICcjJyArIGxpbmtlZFBhdGguaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChWLmlzT2JqZWN0KGF0dHJzKSkge1xuICAgICAgICAgICAgLy8gU2V0IGF0dHJpYnV0ZXMgb24gdGhlIGA8dGV4dFBhdGg+YC4gVGhlIG1vc3QgaW1wb3J0YW50IG9uZVxuICAgICAgICAgICAgLy8gaXMgdGhlIGB4bGluazpocmVmYCB0aGF0IHBvaW50cyB0byBvdXIgbmV3bHkgY3JlYXRlZCBgPHBhdGgvPmAgZWxlbWVudCBpbiBgPGRlZnMvPmAuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgYWxzbyBhbGxvdyB0aGUgZm9sbG93aW5nIGNvbnN0cnVjdDpcbiAgICAgICAgICAgIC8vIGB0LnRleHQoJ215IHRleHQnLCB7IHRleHRQYXRoOiB7ICd4bGluazpocmVmJzogJyNteS1vdGhlci1wYXRoJyB9IH0pYC5cbiAgICAgICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCBvbmUgY2FuIGNvbXBsZXRlbHkgc2tpcCB0aGUgYXV0by1jcmVhdGlvbiBvZiB0aGUgcGF0aFxuICAgICAgICAgICAgLy8gYW5kIHVzZSBhbnkgb3RoZXIgYXJiaXRyYXJ5IHBhdGggdGhhdCBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICB0ZXh0UGF0aEVsZW1lbnQuYXR0cihhdHRycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRQYXRoRWxlbWVudC5ub2RlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFubm90YXRlVGV4dExpbmUobGluZU5vZGUsIGxpbmVBbm5vdGF0aW9ucywgb3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB2YXIgaW5jbHVkZUFubm90YXRpb25JbmRpY2VzID0gb3B0LmluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlcztcbiAgICAgICAgdmFyIGVvbCA9IG9wdC5lb2w7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gb3B0LmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBiYXNlU2l6ZSA9IG9wdC5iYXNlU2l6ZTtcbiAgICAgICAgdmFyIG1heEZvbnRTaXplID0gMDtcbiAgICAgICAgdmFyIGZvbnRNZXRyaWNzID0ge307XG4gICAgICAgIHZhciBsYXN0SiA9IGxpbmVBbm5vdGF0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBsYXN0SjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IGxpbmVBbm5vdGF0aW9uc1tqXTtcbiAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAoVi5pc09iamVjdChhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uQXR0cnMgPSBhbm5vdGF0aW9uLmF0dHJzO1xuICAgICAgICAgICAgICAgIHZhciB2VFNwYW4gPSBWKCd0c3BhbicsIGFubm90YXRpb25BdHRycyk7XG4gICAgICAgICAgICAgICAgdmFyIHRzcGFuTm9kZSA9IHZUU3Bhbi5ub2RlO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gYW5ub3RhdGlvbi50O1xuICAgICAgICAgICAgICAgIGlmIChlb2wgJiYgaiA9PT0gbGFzdEopIHQgKz0gZW9sO1xuICAgICAgICAgICAgICAgIHRzcGFuTm9kZS50ZXh0Q29udGVudCA9IHQ7XG4gICAgICAgICAgICAgICAgLy8gUGVyIGFubm90YXRpb24gY2xhc3NOYW1lXG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25DbGFzcyA9IGFubm90YXRpb25BdHRyc1snY2xhc3MnXTtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbkNsYXNzKSB2VFNwYW4uYWRkQ2xhc3MoYW5ub3RhdGlvbkNsYXNzKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBgb3B0LmluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlc2AgaXMgYHRydWVgLFxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgbGlzdCBvZiBpbmRpY2VzIG9mIGFsbCB0aGUgYXBwbGllZCBhbm5vdGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBgYW5ub3RhdGlvbnNgIGF0dHJpYnV0ZS4gVGhpcyBsaXN0IGlzIGEgY29tbWFcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZWQgbGlzdCBvZiBpbmRpY2VzLlxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlQW5ub3RhdGlvbkluZGljZXMpIHZUU3Bhbi5hdHRyKCdhbm5vdGF0aW9ucycsIGFubm90YXRpb24uYW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBtYXggZm9udCBzaXplXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSBwYXJzZUZsb2F0KGFubm90YXRpb25BdHRyc1snZm9udC1zaXplJ10pO1xuICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoZm9udFNpemUpKSBmb250U2l6ZSA9IGJhc2VTaXplO1xuICAgICAgICAgICAgICAgIGlmIChmb250U2l6ZSAmJiBmb250U2l6ZSA+IG1heEZvbnRTaXplKSBtYXhGb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZW9sICYmIGogPT09IGxhc3RKKSBhbm5vdGF0aW9uICs9IGVvbDtcbiAgICAgICAgICAgICAgICB0c3Bhbk5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhbm5vdGF0aW9uIHx8ICcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VTaXplICYmIGJhc2VTaXplID4gbWF4Rm9udFNpemUpIG1heEZvbnRTaXplID0gYmFzZVNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lTm9kZS5hcHBlbmRDaGlsZCh0c3Bhbk5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heEZvbnRTaXplKSBmb250TWV0cmljcy5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xuICAgICAgICBpZiAobGluZUhlaWdodCkge1xuICAgICAgICAgICAgZm9udE1ldHJpY3MubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWF4Rm9udFNpemUpIHtcbiAgICAgICAgICAgIGZvbnRNZXRyaWNzLmxpbmVIZWlnaHQgPSAobWF4Rm9udFNpemUgKiAxLjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb250TWV0cmljcztcbiAgICB9XG5cbiAgICB2YXIgZW1SZWdleCA9IC9lbSQvO1xuXG4gICAgZnVuY3Rpb24gY29udmVydEVtVG9QeChlbSwgZm9udFNpemUpIHtcbiAgICAgICAgdmFyIG51bWVyaWNhbCA9IHBhcnNlRmxvYXQoZW0pO1xuICAgICAgICBpZiAoZW1SZWdleC50ZXN0KGVtKSkgcmV0dXJuIG51bWVyaWNhbCAqIGZvbnRTaXplO1xuICAgICAgICByZXR1cm4gbnVtZXJpY2FsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZURZKGFsaWdubWVudCwgbGluZXNNZXRyaWNzLCBiYXNlU2l6ZVB4LCBsaW5lSGVpZ2h0KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaW5lc01ldHJpY3MpKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIG4gPSBsaW5lc01ldHJpY3MubGVuZ3RoO1xuICAgICAgICBpZiAoIW4pIHJldHVybiAwO1xuICAgICAgICB2YXIgbGluZU1ldHJpY3MgPSBsaW5lc01ldHJpY3NbMF07XG4gICAgICAgIHZhciBmbE1heEZvbnQgPSBjb252ZXJ0RW1Ub1B4KGxpbmVNZXRyaWNzLm1heEZvbnRTaXplLCBiYXNlU2l6ZVB4KSB8fCBiYXNlU2l6ZVB4O1xuICAgICAgICB2YXIgckxpbmVIZWlnaHRzID0gMDtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHRQeCA9IGNvbnZlcnRFbVRvUHgobGluZUhlaWdodCwgYmFzZVNpemVQeCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lTWV0cmljcyA9IGxpbmVzTWV0cmljc1tpXTtcbiAgICAgICAgICAgIHZhciBpTGluZUhlaWdodCA9IGNvbnZlcnRFbVRvUHgobGluZU1ldHJpY3MubGluZUhlaWdodCwgYmFzZVNpemVQeCkgfHwgbGluZUhlaWdodFB4O1xuICAgICAgICAgICAgckxpbmVIZWlnaHRzICs9IGlMaW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBsbE1heEZvbnQgPSBjb252ZXJ0RW1Ub1B4KGxpbmVNZXRyaWNzLm1heEZvbnRTaXplLCBiYXNlU2l6ZVB4KSB8fCBiYXNlU2l6ZVB4O1xuICAgICAgICB2YXIgZHk7XG4gICAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIGR5ID0gKGZsTWF4Rm9udCAvIDIpIC0gKDAuMTUgKiBsbE1heEZvbnQpIC0gKHJMaW5lSGVpZ2h0cyAvIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBkeSA9IC0oMC4yNSAqIGxsTWF4Rm9udCkgLSByTGluZUhlaWdodHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBkeSA9ICgwLjggKiBmbE1heEZvbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeTtcbiAgICB9XG5cbiAgICBWUHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbihjb250ZW50LCBvcHQpIHtcblxuICAgICAgICBpZiAoY29udGVudCAmJiB0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignVmVjdG9yaXplcjogdGV4dCgpIGV4cGVjdHMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgc3RyaW5nLicpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIHNwYWNlcyB3aXRoIHRoZSBVbmljb2RlIE5vLWJyZWFrIHNwYWNlIChodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9pbmZvL3VuaWNvZGUvY2hhci9hMC9pbmRleC5odG0pLlxuICAgICAgICAvLyBJRSB3b3VsZCBvdGhlcndpc2UgY29sbGFwc2UgYWxsIHNwYWNlcyBpbnRvIG9uZS5cbiAgICAgICAgY29udGVudCA9IFYuc2FuaXRpemVUZXh0KGNvbnRlbnQpO1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgLy8gU2hvdWxkIHdlIGFsbG93IHRoZSB0ZXh0IHRvIGJlIHNlbGVjdGVkP1xuICAgICAgICB2YXIgZGlzcGxheUVtcHR5ID0gb3B0LmRpc3BsYXlFbXB0eTtcbiAgICAgICAgLy8gRW5kIG9mIExpbmUgY2hhcmFjdGVyXG4gICAgICAgIHZhciBlb2wgPSBvcHQuZW9sO1xuICAgICAgICAvLyBUZXh0IGFsb25nIHBhdGhcbiAgICAgICAgdmFyIHRleHRQYXRoID0gb3B0LnRleHRQYXRoO1xuICAgICAgICAvLyBWZXJ0aWNhbCBzaGlmdFxuICAgICAgICB2YXIgdmVydGljYWxBbmNob3IgPSBvcHQudGV4dFZlcnRpY2FsQW5jaG9yO1xuICAgICAgICB2YXIgbmFtZWRWZXJ0aWNhbEFuY2hvciA9ICh2ZXJ0aWNhbEFuY2hvciA9PT0gJ21pZGRsZScgfHwgdmVydGljYWxBbmNob3IgPT09ICdib3R0b20nIHx8IHZlcnRpY2FsQW5jaG9yID09PSAndG9wJyk7XG4gICAgICAgIC8vIEhvcml6b250YWwgc2hpZnQgYXBwbGllZCB0byBhbGwgdGhlIGxpbmVzIGJ1dCB0aGUgZmlyc3QuXG4gICAgICAgIHZhciB4ID0gb3B0Lng7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHggPSB0aGlzLmF0dHIoJ3gnKSB8fCAwO1xuICAgICAgICAvLyBBbm5vdGF0aW9uc1xuICAgICAgICB2YXIgaWFpID0gb3B0LmluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlcztcbiAgICAgICAgdmFyIGFubm90YXRpb25zID0gb3B0LmFubm90YXRpb25zO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbnMgJiYgIVYuaXNBcnJheShhbm5vdGF0aW9ucykpIGFubm90YXRpb25zID0gW2Fubm90YXRpb25zXTtcbiAgICAgICAgLy8gU2hpZnQgYWxsIHRoZSA8dHNwYW4+IGJ1dCBmaXJzdCBieSBvbmUgbGluZSAoYDFlbWApXG4gICAgICAgIHZhciBkZWZhdWx0TGluZUhlaWdodCA9IG9wdC5saW5lSGVpZ2h0O1xuICAgICAgICB2YXIgYXV0b0xpbmVIZWlnaHQgPSAoZGVmYXVsdExpbmVIZWlnaHQgPT09ICdhdXRvJyk7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gKGF1dG9MaW5lSGVpZ2h0KSA/ICcxLjVlbScgOiAoZGVmYXVsdExpbmVIZWlnaHQgfHwgJzFlbScpO1xuICAgICAgICAvLyBDbGVhcmluZyB0aGUgZWxlbWVudFxuICAgICAgICB0aGlzLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuYXR0cih7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBzcGFjZXMuIEluIG90aGVyIHdvcmRzLCB3ZSBkbyBub3Qgd2FudCBjb25zZWN1dGl2ZSBzcGFjZXMgdG8gZ2V0IGNvbGxhcHNlZCB0byBvbmUuXG4gICAgICAgICAgICAneG1sOnNwYWNlJzogJ3ByZXNlcnZlJyxcbiAgICAgICAgICAgIC8vIEFuIGVtcHR5IHRleHQgZ2V0cyByZW5kZXJlZCBpbnRvIHRoZSBET00gaW4gd2Via2l0LWJhc2VkIGJyb3dzZXJzLlxuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gdW5pZnkgdGhpcyBiZWhhdmlvdXIgYWNyb3NzIGFsbCBicm93c2Vyc1xuICAgICAgICAgICAgLy8gd2UgcmF0aGVyIGhpZGUgdGhlIHRleHQgZWxlbWVudCB3aGVuIGl0J3MgZW1wdHkuXG4gICAgICAgICAgICAnZGlzcGxheSc6IChjb250ZW50IHx8IGRpc3BsYXlFbXB0eSkgPyBudWxsIDogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCBkZWZhdWx0IGZvbnQtc2l6ZSBpZiBub25lXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdmb250LXNpemUnKSk7XG4gICAgICAgIGlmICghZm9udFNpemUpIHtcbiAgICAgICAgICAgIGZvbnRTaXplID0gMTY7XG4gICAgICAgICAgICBpZiAobmFtZWRWZXJ0aWNhbEFuY2hvciB8fCBhbm5vdGF0aW9ucykgdGhpcy5hdHRyKCdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gICAgICAgIHZhciBjb250YWluZXJOb2RlO1xuICAgICAgICBpZiAodGV4dFBhdGgpIHtcbiAgICAgICAgICAgIC8vIE5vdyBhbGwgdGhlIGA8dHNwYW4+YHMgd2lsbCBiZSBpbnNpZGUgdGhlIGA8dGV4dFBhdGg+YC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dFBhdGggPT09ICdzdHJpbmcnKSB0ZXh0UGF0aCA9IHsgZDogdGV4dFBhdGggfTtcbiAgICAgICAgICAgIGNvbnRhaW5lck5vZGUgPSBjcmVhdGVUZXh0UGF0aE5vZGUodGV4dFBhdGgsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGFpbmVyTm9kZSA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgbGluZXNNZXRyaWNzID0gW107XG4gICAgICAgIHZhciBhbm5vdGF0ZWRZO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGFzdEkgPSBsaW5lcy5sZW5ndGggLSAxOyBpIDw9IGxhc3RJOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkeSA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGluZUNsYXNzTmFtZSA9ICd2LWxpbmUnO1xuICAgICAgICAgICAgdmFyIGxpbmVOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhucy5zdmcsICd0c3BhbicpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIHZhciBsaW5lTWV0cmljcztcbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlICpjb21wYWN0ZWQqIGFubm90YXRpb25zIGZvciB0aGlzIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lQW5ub3RhdGlvbnMgPSBWLmFubm90YXRlU3RyaW5nKGxpbmUsIGFubm90YXRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IC1vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlQW5ub3RhdGlvbkluZGljZXM6IGlhaVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGluZU1ldHJpY3MgPSBhbm5vdGF0ZVRleHRMaW5lKGxpbmVOb2RlLCBsaW5lQW5ub3RhdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlczogaWFpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW9sOiAoaSAhPT0gbGFzdEkgJiYgZW9sKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IChhdXRvTGluZUhlaWdodCkgPyBudWxsIDogbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VTaXplOiBmb250U2l6ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBsaW5lIGhlaWdodCBiYXNlZCBvbiB0aGUgYmlnZ2VzdCBmb250IHNpemUgaW4gdGhlIGFubm90YXRpb25zIGZvciB0aGlzIGxpbmUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpTGluZUhlaWdodCA9IGxpbmVNZXRyaWNzLmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpTGluZUhlaWdodCAmJiBhdXRvTGluZUhlaWdodCAmJiBpICE9PSAwKSBkeSA9IGlMaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgYW5ub3RhdGVkWSA9IGxpbmVNZXRyaWNzLm1heEZvbnRTaXplICogMC44O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlb2wgJiYgaSAhPT0gbGFzdEkpIGxpbmUgKz0gZW9sO1xuICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZS50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHRleHRDb250ZW50IGlzIG5ldmVyIGVtcHR5LiBJZiBpdCBpcywgYWRkIGEgZHVtbXlcbiAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIgYW5kIG1ha2UgaXQgaW52aXNpYmxlLCBtYWtpbmcgdGhlIGZvbGxvd2luZyBsaW5lcyBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyByZWxhdGl2ZWx5IHBvc2l0aW9uZWQuIGBkeT0xZW1gIHdvbid0IHdvcmsgd2l0aCBlbXB0eSBsaW5lcyBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgbGluZU5vZGUudGV4dENvbnRlbnQgPSAnLSc7XG4gICAgICAgICAgICAgICAgbGluZUNsYXNzTmFtZSArPSAnIHYtZW1wdHktbGluZSc7XG4gICAgICAgICAgICAgICAgLy8gJ29wYWNpdHknIG5lZWRzIHRvIGJlIHNwZWNpZmllZCB3aXRoIGZpbGwsIHN0cm9rZS4gT3BhY2l0eSB3aXRob3V0IHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgYXBwbGllZCBpbiBGaXJlZm94XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVOb2RlU3R5bGUgPSBsaW5lTm9kZS5zdHlsZTtcbiAgICAgICAgICAgICAgICBsaW5lTm9kZVN0eWxlLmZpbGxPcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICBsaW5lTm9kZVN0eWxlLnN0cm9rZU9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBsaW5lIHdpdGggYW5ub3RhdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgIGxpbmVNZXRyaWNzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGxpbmVBbm5vdGF0aW9ucyA9IFYuZmluZEFubm90YXRpb25zQXRJbmRleChhbm5vdGF0aW9ucywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVGb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlIGFubm90YXRpb25zIG92ZXJyaWRlcyB0aGUgZm9udCBzaXplLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbGluZUFubm90YXRpb25zLmxlbmd0aDsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBsaW5lQW5ub3RhdGlvbnNbaiAtIDFdLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRycyB8fCAhKCdmb250LXNpemUnIGluIGF0dHJzKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcyA9IHBhcnNlRmxvYXQoYXR0cnNbJ2ZvbnQtc2l6ZSddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lRm9udFNpemUgPSBmcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b0xpbmVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gbGluZUZvbnRTaXplICogMS4yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWRZID0gbGluZUZvbnRTaXplICogMC44O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb250IHNpemUgaXMgaW1wb3J0YW50IGZvciB0aGUgbmF0aXZlIHNlbGVjdGlvbiBib3ggaGVpZ2h0LlxuICAgICAgICAgICAgICAgICAgICBsaW5lTm9kZS5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIGxpbmVGb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVNZXRyaWNzLm1heEZvbnRTaXplID0gbGluZUZvbnRTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW5lTWV0cmljcykgbGluZXNNZXRyaWNzLnB1c2gobGluZU1ldHJpY3MpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSBsaW5lTm9kZS5zZXRBdHRyaWJ1dGUoJ2R5JywgZHkpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXF1aXJlcyAneCcgdG8gYmUgc2V0IG9uIHRoZSBmaXJzdCBsaW5lIHdoZW4gaW5zaWRlIGEgdGV4dCBwYXRoXG4gICAgICAgICAgICBpZiAoaSA+IDAgfHwgdGV4dFBhdGgpIGxpbmVOb2RlLnNldEF0dHJpYnV0ZSgneCcsIHgpO1xuICAgICAgICAgICAgbGluZU5vZGUuY2xhc3NOYW1lLmJhc2VWYWwgPSBsaW5lQ2xhc3NOYW1lO1xuICAgICAgICAgICAgY29udGFpbmVyTm9kZS5hcHBlbmRDaGlsZChsaW5lTm9kZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGluZS5sZW5ndGggKyAxOyAgICAgIC8vICsgMSA9IG5ld2xpbmUgY2hhcmFjdGVyLlxuICAgICAgICB9XG4gICAgICAgIC8vIFkgQWxpZ25tZW50IGNhbGN1bGF0aW9uXG4gICAgICAgIGlmIChuYW1lZFZlcnRpY2FsQW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBkeSA9IGNhbGN1bGF0ZURZKHZlcnRpY2FsQW5jaG9yLCBsaW5lc01ldHJpY3MsIGZvbnRTaXplLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGljYWxBbmNob3IgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBzaG9ydGN1dCBmb3IgdG9wIGFsaWdubWVudC4gSXQgZG9lcyBub3QgZGVwZW5kIG9uIGZvbnQtc2l6ZSBub3IgbGluZS1oZWlnaHRcbiAgICAgICAgICAgICAgICBkeSA9ICcwLjhlbSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByaDsgLy8gcmVtYWluaW5nIGhlaWdodFxuICAgICAgICAgICAgICAgIGlmIChsYXN0SSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmggPSBwYXJzZUZsb2F0KGxpbmVIZWlnaHQpIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIHJoICo9IGxhc3RJO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVtUmVnZXgudGVzdChsaW5lSGVpZ2h0KSkgcmggLz0gZm9udFNpemU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlLWxpbmUgdGV4dFxuICAgICAgICAgICAgICAgICAgICByaCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodmVydGljYWxBbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gKDAuMyAtIChyaCAvIDIpKSArICdlbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gKC1yaCAtIDAuMykgKyAnZW0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZlcnRpY2FsQW5jaG9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZHkgPSAnMGVtJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmVydGljYWxBbmNob3IpIHtcbiAgICAgICAgICAgICAgICBkeSA9IHZlcnRpY2FsQW5jaG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyB2ZXJ0aWNhbCBhbmNob3IgaXMgZGVmaW5lZFxuICAgICAgICAgICAgICAgIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIHdlIGNoYW5nZSB0aGUgYHlgIGF0dHJpYnV0ZSBpbnN0ZWFkIG9mIGBkeWAuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXR0cigneScpID09PSBudWxsKSB0aGlzLmF0dHIoJ3knLCBhbm5vdGF0ZWRZIHx8ICcwLjhlbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lck5vZGUuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywgZHkpO1xuICAgICAgICAvLyBBcHBlbmRpbmcgbGluZXMgdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuYXBwZW5kKGNvbnRhaW5lck5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge1ZlY3Rvcml6ZXJ9XG4gICAgICovXG4gICAgVlByb3RvdHlwZS5yZW1vdmVBdHRyID0gZnVuY3Rpb24obmFtZSkge1xuXG4gICAgICAgIGNvbnN0IHRydWVOYW1lID0gYXR0cmlidXRlTmFtZXNbbmFtZV07XG5cbiAgICAgICAgY29uc3QgeyBucywgbG9jYWwgfSA9IFYucXVhbGlmeUF0dHIodHJ1ZU5hbWUpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMubm9kZTtcblxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGVOUyhucywgbG9jYWwpKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMobnMsIGxvY2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChlbC5oYXNBdHRyaWJ1dGUodHJ1ZU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUodHJ1ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChWLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBhbGwgYXR0cmlidXRlcy5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5ub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbYXR0cmlidXRlc1tpXS5uYW1lXSA9IGF0dHJpYnV0ZXNbaV0udmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChWLmlzU3RyaW5nKG5hbWUpICYmIFYuaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lc1tuYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIG5hbWVbYXR0ck5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUubm9ybWFsaXplUGF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy50YWdOYW1lKCk7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnUEFUSCcpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cignZCcsIFYubm9ybWFsaXplUGF0aERhdGEodGhpcy5hdHRyKCdkJykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMubm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJzXG4gICAgICogQHJldHVybnMge1ZlY3Rvcml6ZXJ9XG4gICAgICovXG4gICAgVlByb3RvdHlwZS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGVscykge1xuXG4gICAgICAgIGlmICghVi5pc0FycmF5KGVscykpIHtcbiAgICAgICAgICAgIGVscyA9IFtlbHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKFYudG9Ob2RlKGVsc1tpXSkpOyAvLyBsZ3RtIFtqcy94c3MtdGhyb3VnaC1kb21dXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oZWxzKSB7XG5cbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5ub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHJldHVybiBjaGlsZCA/IFYoY2hpbGQpLmJlZm9yZShlbHMpIDogdGhpcy5hcHBlbmQoZWxzKTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5iZWZvcmUgPSBmdW5jdGlvbihlbHMpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG5cbiAgICAgICAgICAgIGlmICghVi5pc0FycmF5KGVscykpIHtcbiAgICAgICAgICAgICAgICBlbHMgPSBbZWxzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoVi50b05vZGUoZWxzW2ldKSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5hcHBlbmRUbyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgVi50b05vZGUobm9kZSkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTsgLy8gbGd0bSBbanMveHNzLXRocm91Z2gtZG9tXVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlIGluc3RhbmNlb2Ygd2luZG93LlNWR1NWR0VsZW1lbnQgPyB0aGlzIDogVih0aGlzLm5vZGUub3duZXJTVkdFbGVtZW50KTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS50YWdOYW1lID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuZGVmcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuc3ZnKCkgfHwgdGhpcztcbiAgICAgICAgdmFyIGRlZnNOb2RlID0gY29udGV4dC5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkZWZzJylbMF07XG4gICAgICAgIGlmIChkZWZzTm9kZSkgcmV0dXJuIFYoZGVmc05vZGUpO1xuICAgICAgICByZXR1cm4gVignZGVmcycpLmFwcGVuZFRvKGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNsb25lID0gVih0aGlzLm5vZGUuY2xvbmVOb2RlKHRydWUvKiBkZWVwICovKSk7XG4gICAgICAgIC8vIE5vdGUgdGhhdCBjbG9uZSBpbmhlcml0cyBhbHNvIElELiBUaGVyZWZvcmUsIHdlIG5lZWQgdG8gY2hhbmdlIGl0IGhlcmUuXG4gICAgICAgIGNsb25lLm5vZGUuaWQgPSBWLnVuaXF1ZUlkKCk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblxuICAgICAgICB2YXIgZm91bmQgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBmb3VuZCA/IFYoZm91bmQpIDogdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuXG4gICAgICAgIHZhciB2ZWxzID0gW107XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgICAgICBpZiAobm9kZXMpIHtcblxuICAgICAgICAgICAgLy8gTWFwIERPTSBlbGVtZW50cyB0byBgVmBzLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZlbHMucHVzaChWKG5vZGVzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmVscztcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBWIGVsZW1lbnRzIG1hZGUgZnJvbSBjaGlsZHJlbiBvZiB0aGlzLm5vZGUuXG4gICAgVlByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMubm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICAgIHZhciBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudENoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChWKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBWIGVsZW1lbnQgZnJvbSBwYXJlbnROb2RlIG9mIHRoaXMubm9kZS5cbiAgICBWUHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gVih0aGlzLm5vZGUucGFyZW50Tm9kZSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbiBpbmRleCBvZiBhbiBlbGVtZW50IGluc2lkZSBpdHMgY29udGFpbmVyLlxuICAgIFZQcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZS5wcmV2aW91c1NpYmxpbmc7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIG5vZGVUeXBlIDEgZm9yIEVMRU1FTlRfTk9ERVxuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIGluZGV4Kys7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuZmluZFBhcmVudEJ5Q2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUsIHRlcm1pbmF0b3IpIHtcblxuICAgICAgICB2YXIgb3duZXJTVkdFbGVtZW50ID0gdGhpcy5ub2RlLm93bmVyU1ZHRWxlbWVudDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9PSB0ZXJtaW5hdG9yICYmIG5vZGUgIT09IG93bmVyU1ZHRWxlbWVudCkge1xuXG4gICAgICAgICAgICB2YXIgdmVsID0gVihub2RlKTtcbiAgICAgICAgICAgIGlmICh2ZWwuaGFzQ2xhc3MoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2ZWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2dldC1jb21tb24tcGFyZW50XG4gICAgVlByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLm5vZGU7XG4gICAgICAgIHZhciBiID0gVi50b05vZGUoZWwpO1xuICAgICAgICB2YXIgYnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cbiAgICAgICAgcmV0dXJuIChhID09PSBidXApIHx8ICEhKGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYnVwKSAmIDE2KSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgZ2xvYmFsIHBvaW50IGludG8gdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgdGhpcyBlbGVtZW50LlxuICAgIFZQcm90b3R5cGUudG9Mb2NhbFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHZhciBzdmcgPSB0aGlzLnN2ZygpLm5vZGU7XG5cbiAgICAgICAgdmFyIHAgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgcC54ID0geDtcbiAgICAgICAgcC55ID0geTtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICB2YXIgZ2xvYmFsUG9pbnQgPSBwLm1hdHJpeFRyYW5zZm9ybShzdmcuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxUb0xvY2FsTWF0cml4ID0gdGhpcy5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQoc3ZnKS5pbnZlcnNlKCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSUU5IHRocm93cyBhbiBleGNlcHRpb24gaW4gb2RkIGNhc2VzLiAoYFVuZXhwZWN0ZWQgY2FsbCB0byBtZXRob2Qgb3IgcHJvcGVydHkgYWNjZXNzYClcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFrZSBkbyB3aXRoIHRoZSBvcmlnaW5hbCBjb29yZGlhbmF0ZXMuXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxQb2ludC5tYXRyaXhUcmFuc2Zvcm0oZ2xvYmFsVG9Mb2NhbE1hdHJpeCk7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUudHJhbnNsYXRlQ2VudGVyVG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCh7IHRhcmdldDogdGhpcy5zdmcoKSB9KTtcbiAgICAgICAgdmFyIGNlbnRlciA9IGJib3guY2VudGVyKCk7XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUocC54IC0gY2VudGVyLngsIHAueSAtIGNlbnRlci55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIEVmZmljaWVudGx5IGF1dG8tb3JpZW50IGFuIGVsZW1lbnQuIFRoaXMgYmFzaWNhbGx5IGltcGxlbWVudHMgdGhlIG9yaWVudD1hdXRvIGF0dHJpYnV0ZVxuICAgIC8vIG9mIG1hcmtlcnMuIFRoZSBlYXNpZXN0IHdheSBvZiB1bmRlcnN0YW5kaW5nIG9uIHdoYXQgdGhpcyBkb2VzIGlzIHRvIGltYWdpbmUgdGhlIGVsZW1lbnQgaXMgYW5cbiAgICAvLyBhcnJvd2hlYWQuIENhbGxpbmcgdGhpcyBtZXRob2Qgb24gdGhlIGFycm93aGVhZCBtYWtlcyBpdCBwb2ludCB0byB0aGUgYHBvc2l0aW9uYCBwb2ludCB3aGlsZVxuICAgIC8vIGJlaW5nIGF1dG8tb3JpZW50ZWQgKHByb3Blcmx5IHJvdGF0ZWQpIHRvd2FyZHMgdGhlIGByZWZlcmVuY2VgIHBvaW50LlxuICAgIC8vIGB0YXJnZXRgIGlzIHRoZSBlbGVtZW50IHJlbGF0aXZlIHRvIHdoaWNoIHRoZSB0cmFuc2Zvcm1hdGlvbnMgYXJlIGFwcGxpZWQuIFVzdWFsbHkgYSB2aWV3cG9ydC5cbiAgICBWUHJvdG90eXBlLnRyYW5zbGF0ZUFuZEF1dG9PcmllbnQgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmVmZXJlbmNlLCB0YXJnZXQpIHtcblxuICAgICAgICBwb3NpdGlvbiA9IG5ldyBnLlBvaW50KHBvc2l0aW9uKTtcbiAgICAgICAgcmVmZXJlbmNlID0gIG5ldyBnLlBvaW50KHJlZmVyZW5jZSk7XG4gICAgICAgIHRhcmdldCB8fCAodGFyZ2V0ID0gdGhpcy5zdmcoKSk7XG5cbiAgICAgICAgLy8gQ2xlYW4tdXAgcHJldmlvdXNseSBzZXQgdHJhbnNmb3JtYXRpb25zIGV4Y2VwdCB0aGUgc2NhbGUuIElmIHdlIGRpZG4ndCBjbGVhbiB1cCB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgdHJhbnNmb3JtYXRpb25zIHRoZW4gdGhleSdkIGFkZCB1cCB3aXRoIHRoZSBvbGQgb25lcy4gU2NhbGUgaXMgYW4gZXhjZXB0aW9uIGFzXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgYWRkIHVwLCBjb25zaWRlcjogYHRoaXMuc2NhbGUoMikuc2NhbGUoMikuc2NhbGUoMilgLiBUaGUgcmVzdWx0IGlzIHRoYXQgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgc2NhbGVkIGJ5IHRoZSBmYWN0b3IgMiwgbm90IDguXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoKTtcbiAgICAgICAgdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KHsgdGFyZ2V0OiB0YXJnZXQgfSkuc2NhbGUoc2NhbGUuc3gsIHNjYWxlLnN5KTtcblxuICAgICAgICAvLyAxLiBUcmFuc2xhdGUgdG8gb3JpZ2luLlxuICAgICAgICB2YXIgdHJhbnNsYXRlVG9PcmlnaW4gPSBWLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgICAgICB0cmFuc2xhdGVUb09yaWdpbi5zZXRUcmFuc2xhdGUoLWJib3gueCAtIGJib3gud2lkdGggLyAyLCAtYmJveC55IC0gYmJveC5oZWlnaHQgLyAyKTtcblxuICAgICAgICAvLyAyLiBSb3RhdGUgYXJvdW5kIG9yaWdpbi5cbiAgICAgICAgdmFyIHJvdGF0ZUFyb3VuZE9yaWdpbiA9IFYuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgICAgIHZhciBhbmdsZSA9IHBvc2l0aW9uLmFuZ2xlQmV0d2VlbihyZWZlcmVuY2UsIHBvc2l0aW9uLmNsb25lKCkub2Zmc2V0KDEsIDApKTtcbiAgICAgICAgaWYgKGFuZ2xlKSByb3RhdGVBcm91bmRPcmlnaW4uc2V0Um90YXRlKGFuZ2xlLCAwLCAwKTtcblxuICAgICAgICAvLyAzLiBUcmFuc2xhdGUgdG8gdGhlIGBwb3NpdGlvbmAgKyB0aGUgb2Zmc2V0IChoYWxmIG15IHdpZHRoKSB0b3dhcmRzIHRoZSBgcmVmZXJlbmNlYCBwb2ludC5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZUZyb21PcmlnaW4gPSBWLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgICAgICB2YXIgZmluYWxQb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCkubW92ZShyZWZlcmVuY2UsIGJib3gud2lkdGggLyAyKTtcbiAgICAgICAgdHJhbnNsYXRlRnJvbU9yaWdpbi5zZXRUcmFuc2xhdGUoMiAqIHBvc2l0aW9uLnggLSBmaW5hbFBvc2l0aW9uLngsIDIgKiBwb3NpdGlvbi55IC0gZmluYWxQb3NpdGlvbi55KTtcblxuICAgICAgICAvLyA0LiBHZXQgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoaXMgbm9kZVxuICAgICAgICB2YXIgY3RtID0gdGhpcy5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQodGFyZ2V0KTtcblxuICAgICAgICAvLyA1LiBBcHBseSB0cmFuc2Zvcm1hdGlvbnMgYW5kIHRoZSBzY2FsZVxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gVi5jcmVhdGVTVkdUcmFuc2Zvcm0oKTtcbiAgICAgICAgdHJhbnNmb3JtLnNldE1hdHJpeChcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZyb21PcmlnaW4ubWF0cml4Lm11bHRpcGx5KFxuICAgICAgICAgICAgICAgIHJvdGF0ZUFyb3VuZE9yaWdpbi5tYXRyaXgubXVsdGlwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVRvT3JpZ2luLm1hdHJpeC5tdWx0aXBseShcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5zY2FsZShzY2FsZS5zeCwgc2NhbGUuc3kpKSkpKTtcblxuICAgICAgICB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtLm1hdHJpeCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmFuaW1hdGVBbG9uZ1BhdGggPSBmdW5jdGlvbihhdHRycywgcGF0aCkge1xuXG4gICAgICAgIHBhdGggPSBWLnRvTm9kZShwYXRoKTtcblxuICAgICAgICB2YXIgaWQgPSBWLmVuc3VyZUlkKHBhdGgpO1xuICAgICAgICB2YXIgYW5pbWF0ZU1vdGlvbiA9IFYoJ2FuaW1hdGVNb3Rpb24nLCBhdHRycyk7XG4gICAgICAgIHZhciBtcGF0aCA9IFYoJ21wYXRoJywgeyAneGxpbms6aHJlZic6ICcjJyArIGlkIH0pO1xuXG4gICAgICAgIGFuaW1hdGVNb3Rpb24uYXBwZW5kKG1wYXRoKTtcblxuICAgICAgICB0aGlzLmFwcGVuZChhbmltYXRlTW90aW9uKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFuaW1hdGVNb3Rpb24ubm9kZS5iZWdpbkVsZW1lbnQoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgZm9yIElFIDkuXG4gICAgICAgICAgICAvLyBSdW4gdGhlIGFuaW1hdGlvbiBwcm9ncmFtbWF0aWNhbGx5IGlmIEZha2VTbWlsZSAoYGh0dHA6Ly9sZXVuZW4ubWUvZmFrZXNtaWxlL2ApIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzbWlsaW5nJykgPT09ICdmYWtlJykge1xuICAgICAgICAgICAgICAgIC8qIGdsb2JhbCBnZXRUYXJnZXRzOnRydWUsIEFuaW1hdG9yOnRydWUsIGFuaW1hdG9yczp0cnVlIGlkMmFuaW06dHJ1ZSAqL1xuICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBhbmltYXRpb24uIChTZWUgYGh0dHBzOi8vYW5zd2Vycy5sYXVuY2hwYWQubmV0L3NtaWwvK3F1ZXN0aW9uLzIwMzMzM2ApXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGFuaW1hdGVNb3Rpb24ubm9kZTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uYW5pbWF0b3JzID0gW107XG5cbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSUQgPSBhbmltYXRpb24uZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JRCkgaWQyYW5pbVthbmltYXRpb25JRF0gPSBhbmltYXRpb247XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IGdldFRhcmdldHMoYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKGFuaW1hdGlvbiwgdGFyZ2V0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uYW5pbWF0b3JzW2ldID0gYW5pbWF0b3I7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yLnJlZ2lzdGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuICAgIC8vIFNwbGl0IGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgIC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS13aGl0ZXNwYWNlXG4gICAgY29uc3Qgbm9IVE1MV2hpdGVzcGFjZVJlZ2V4ID0gL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuICAgIGZ1bmN0aW9uIGdldFRva2VuTGlzdChzdHIpIHtcbiAgICAgICAgaWYgKCFWLmlzU3RyaW5nKHN0cikpIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHN0ci50cmltKCkubWF0Y2gobm9IVE1MV2hpdGVzcGFjZVJlZ2V4KSB8fCBbXTtcbiAgICB9XG5cbiAgICBWUHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmICghVi5pc1N0cmluZyhjbGFzc05hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZS50cmltKCkpO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QuYWRkKC4uLmdldFRva2VuTGlzdChjbGFzc05hbWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoLi4uZ2V0VG9rZW5MaXN0KGNsYXNzTmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS50b2dnbGVDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgdG9BZGQpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gZ2V0VG9rZW5MaXN0KGNsYXNzTmFtZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnRvZ2dsZSh0b2tlbnNbaV0sIHRvQWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJwb2xhdGUgcGF0aCBieSBkaXNjcmV0ZSBwb2ludHMuIFRoZSBwcmVjaXNpb24gb2YgdGhlIHNhbXBsaW5nXG4gICAgLy8gaXMgY29udHJvbGxlZCBieSBgaW50ZXJ2YWxgLiBJbiBvdGhlciB3b3JkcywgYHNhbXBsZSgpYCB3aWxsIGdlbmVyYXRlXG4gICAgLy8gYSBwb2ludCBvbiB0aGUgcGF0aCBzdGFydGluZyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRoIGdvaW5nIHRvIHRoZSBlbmRcbiAgICAvLyBldmVyeSBgaW50ZXJ2YWxgIHBpeGVscy5cbiAgICAvLyBUaGUgc2FtcGxlciBjYW4gYmUgdmVyeSB1c2VmdWwgZm9yIGUuZy4gZmluZGluZyBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0d29cbiAgICAvLyBwYXRocyAoZmluZGluZyB0aGUgdHdvIGNsb3Nlc3QgcG9pbnRzIGZyb20gdHdvIHNhbXBsZXMpLlxuICAgIFZQcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcblxuICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDE7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgICAgICB2YXIgc2FtcGxlcyA9IFtdO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSAwO1xuICAgICAgICB2YXIgc2FtcGxlO1xuICAgICAgICB3aGlsZSAoZGlzdGFuY2UgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHNhbXBsZSA9IG5vZGUuZ2V0UG9pbnRBdExlbmd0aChkaXN0YW5jZSk7XG4gICAgICAgICAgICBzYW1wbGVzLnB1c2goeyB4OiBzYW1wbGUueCwgeTogc2FtcGxlLnksIGRpc3RhbmNlOiBkaXN0YW5jZSB9KTtcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYW1wbGVzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmNvbnZlcnRUb1BhdGggPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IFYoJ3BhdGgnKTtcbiAgICAgICAgcGF0aC5hdHRyKHRoaXMuYXR0cigpKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmNvbnZlcnRUb1BhdGhEYXRhKCk7XG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgICBwYXRoLmF0dHIoJ2QnLCBkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5jb252ZXJ0VG9QYXRoRGF0YSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy50YWdOYW1lKCk7XG5cbiAgICAgICAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdQQVRIJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJyk7XG4gICAgICAgICAgICBjYXNlICdMSU5FJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVi5jb252ZXJ0TGluZVRvUGF0aERhdGEodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ1BPTFlHT04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBWLmNvbnZlcnRQb2x5Z29uVG9QYXRoRGF0YSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnUE9MWUxJTkUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBWLmNvbnZlcnRQb2x5bGluZVRvUGF0aERhdGEodGhpcy5ub2RlKTtcbiAgICAgICAgICAgIGNhc2UgJ0VMTElQU0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBWLmNvbnZlcnRFbGxpcHNlVG9QYXRoRGF0YSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnQ0lSQ0xFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVi5jb252ZXJ0Q2lyY2xlVG9QYXRoRGF0YSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnUkVDVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYuY29udmVydFJlY3RUb1BhdGhEYXRhKHRoaXMubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGFnTmFtZSArICcgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBQQVRILicpO1xuICAgIH07XG5cbiAgICBWLnByb3RvdHlwZS50b0dlb21ldHJ5U2hhcGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHgsIHksIHdpZHRoLCBoZWlnaHQsIGN4LCBjeSwgciwgcngsIHJ5LCBwb2ludHMsIGQsIHgxLCB4MiwgeTEsIHkyO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudGFnTmFtZSgpKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ1JFQ1QnOlxuICAgICAgICAgICAgICAgIHggPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigneCcpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHkgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigneScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3dpZHRoJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2hlaWdodCcpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5SZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICBjYXNlICdDSVJDTEUnOlxuICAgICAgICAgICAgICAgIGN4ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2N4JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgY3kgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignY3knKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3InKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuRWxsaXBzZSh7IHg6IGN4LCB5OiBjeSB9LCByLCByKTtcblxuICAgICAgICAgICAgY2FzZSAnRUxMSVBTRSc6XG4gICAgICAgICAgICAgICAgY3ggPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignY3gnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjeSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdjeScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJ4ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3J4JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgcnkgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigncnknKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuRWxsaXBzZSh7IHg6IGN4LCB5OiBjeSB9LCByeCwgcnkpO1xuXG4gICAgICAgICAgICBjYXNlICdQT0xZTElORSc6XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gVi5nZXRQb2ludHNGcm9tU3ZnTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuUG9seWxpbmUocG9pbnRzKTtcblxuICAgICAgICAgICAgY2FzZSAnUE9MWUdPTic6XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gVi5nZXRQb2ludHNGcm9tU3ZnTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlBvbHlsaW5lKHBvaW50cyk7XG5cbiAgICAgICAgICAgIGNhc2UgJ1BBVEgnOlxuICAgICAgICAgICAgICAgIGQgPSB0aGlzLmF0dHIoJ2QnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWcuUGF0aC5pc0RhdGFTdXBwb3J0ZWQoZCkpIGQgPSBWLm5vcm1hbGl6ZVBhdGhEYXRhKGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5QYXRoKGQpO1xuXG4gICAgICAgICAgICBjYXNlICdMSU5FJzpcbiAgICAgICAgICAgICAgICB4MSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd4MScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHkxID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3kxJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgeDIgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigneDInKSkgfHwgMDtcbiAgICAgICAgICAgICAgICB5MiA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd5MicpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5MaW5lKHsgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBpcyBhIHJlY3RhbmdsZVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCQm94KCk7XG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIGludGVyc2VjdGlvbiBvZiBhIGxpbmUgc3RhcnRpbmcgaW4gdGhlIGNlbnRlclxuICAgIC8vIG9mIHRoZSBTVkcgYG5vZGVgIGVuZGluZyBpbiB0aGUgcG9pbnQgYHJlZmAuXG4gICAgLy8gYHRhcmdldGAgaXMgYW4gU1ZHIGVsZW1lbnQgdG8gd2hpY2ggYG5vZGVgcyB0cmFuc2Zvcm1hdGlvbnMgYXJlIHJlbGF0aXZlIHRvLlxuICAgIC8vIE5vdGUgdGhhdCBgcmVmYCBwb2ludCBtdXN0IGJlIGluIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGUgYHRhcmdldGAgZm9yIHRoaXMgZnVuY3Rpb24gdG8gd29yayBwcm9wZXJseS5cbiAgICAvLyBSZXR1cm5zIGEgcG9pbnQgaW4gdGhlIGB0YXJnZXRgIGNvb3JkaW5hdGUgc3lzdGVtICh0aGUgc2FtZSBzeXN0ZW0gYXMgYHJlZmAgaXMgaW4pIGlmXG4gICAgLy8gYW4gaW50ZXJzZWN0aW9uIGlzIGZvdW5kLiBSZXR1cm5zIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICBWUHJvdG90eXBlLmZpbmRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihyZWYsIHRhcmdldCkge1xuXG4gICAgICAgIHZhciBzdmcgPSB0aGlzLnN2ZygpLm5vZGU7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBzdmc7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KHsgdGFyZ2V0OiB0YXJnZXQgfSk7XG4gICAgICAgIHZhciBjZW50ZXIgPSBiYm94LmNlbnRlcigpO1xuXG4gICAgICAgIGlmICghYmJveC5pbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50KHJlZikpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIHNwb3Q7XG4gICAgICAgIHZhciB0YWdOYW1lID0gdGhpcy50YWdOYW1lKCk7XG5cbiAgICAgICAgLy8gTGl0dGxlIHNwZWVkIHVwIG9wdGltaXphdGlvbiBmb3IgYDxyZWN0PmAgZWxlbWVudC4gV2UgZG8gbm90IGRvIGNvbnZlcnNpb25cbiAgICAgICAgLy8gdG8gcGF0aCBlbGVtZW50IGFuZCBzYW1wbGluZyBidXQgZGlyZWN0bHkgY2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBhIHRyYW5zZm9ybWVkIGdlb21ldHJpY2FsIHJlY3RhbmdsZS5cbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdSRUNUJykge1xuXG4gICAgICAgICAgICB2YXIgZ1JlY3QgPSBuZXcgZy5SZWN0KFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5hdHRyKCd4JykgfHwgMCksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3knKSB8fCAwKSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMuYXR0cignd2lkdGgnKSksXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2hlaWdodCcpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjdCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggd2l0aCByZWdhcmRzIHRvIHRoZSBTVkcgZG9jdW1lbnQuXG4gICAgICAgICAgICB2YXIgcmVjdE1hdHJpeCA9IHRoaXMuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBEZWNvbXBvc2UgdGhlIG1hdHJpeCB0byBmaW5kIHRoZSByb3RhdGlvbiBhbmdsZS5cbiAgICAgICAgICAgIHZhciByZWN0TWF0cml4Q29tcG9uZW50cyA9IFYuZGVjb21wb3NlTWF0cml4KHJlY3RNYXRyaXgpO1xuICAgICAgICAgICAgLy8gTm93IHdlIHdhbnQgdG8gcm90YXRlIHRoZSByZWN0YW5nbGUgYmFjayBzbyB0aGF0IHdlXG4gICAgICAgICAgICAvLyBjYW4gdXNlIGBpbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50KClgIHBhc3NpbmcgdGhlIGFuZ2xlIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAgICAgICAgICB2YXIgcmVzZXRSb3RhdGlvbiA9IHN2Zy5jcmVhdGVTVkdUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHJlc2V0Um90YXRpb24uc2V0Um90YXRlKC1yZWN0TWF0cml4Q29tcG9uZW50cy5yb3RhdGlvbiwgY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gVi50cmFuc2Zvcm1SZWN0KGdSZWN0LCByZXNldFJvdGF0aW9uLm1hdHJpeC5tdWx0aXBseShyZWN0TWF0cml4KSk7XG4gICAgICAgICAgICBzcG90ID0gKG5ldyBnLlJlY3QocmVjdCkpLmludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQocmVmLCByZWN0TWF0cml4Q29tcG9uZW50cy5yb3RhdGlvbik7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnUEFUSCcgfHwgdGFnTmFtZSA9PT0gJ1BPTFlHT04nIHx8IHRhZ05hbWUgPT09ICdQT0xZTElORScgfHwgdGFnTmFtZSA9PT0gJ0NJUkNMRScgfHwgdGFnTmFtZSA9PT0gJ0VMTElQU0UnKSB7XG5cbiAgICAgICAgICAgIHZhciBwYXRoTm9kZSA9ICh0YWdOYW1lID09PSAnUEFUSCcpID8gdGhpcyA6IHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICAgICAgdmFyIHNhbXBsZXMgPSBwYXRoTm9kZS5zYW1wbGUoKTtcbiAgICAgICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3RTYW1wbGVzID0gW107XG5cbiAgICAgICAgICAgIHZhciBpLCBzYW1wbGUsIGdwLCBjZW50ZXJEaXN0YW5jZSwgcmVmRGlzdGFuY2UsIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzYW1wbGUgcG9pbnQgaW4gdGhlIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHRoZSBnbG9iYWwgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgICAgICAgICAgICAgZ3AgPSBWLmNyZWF0ZVNWR1BvaW50KHNhbXBsZS54LCBzYW1wbGUueSk7XG4gICAgICAgICAgICAgICAgZ3AgPSBncC5tYXRyaXhUcmFuc2Zvcm0odGhpcy5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQodGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgc2FtcGxlID0gbmV3IGcuUG9pbnQoZ3ApO1xuICAgICAgICAgICAgICAgIGNlbnRlckRpc3RhbmNlID0gc2FtcGxlLmRpc3RhbmNlKGNlbnRlcik7XG4gICAgICAgICAgICAgICAgLy8gUGVuYWxpemUgYSBoaWdoZXIgZGlzdGFuY2UgdG8gdGhlIHJlZmVyZW5jZSBwb2ludCBieSAxMCUuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyBiZXR0ZXIgcmVzdWx0cy4gVGhpcyBpcyBkdWUgdG9cbiAgICAgICAgICAgICAgICAvLyBpbmFjY3VyYWNpZXMgaW50cm9kdWNlZCBieSByb3VuZGluZyBlcnJvcnMgYW5kIGdldFBvaW50QXRMZW5ndGgoKSByZXR1cm5zLlxuICAgICAgICAgICAgICAgIHJlZkRpc3RhbmNlID0gc2FtcGxlLmRpc3RhbmNlKHJlZikgKiAxLjE7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBjZW50ZXJEaXN0YW5jZSArIHJlZkRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFNhbXBsZXMgPSBbeyBzYW1wbGU6IHNhbXBsZSwgcmVmRGlzdGFuY2U6IHJlZkRpc3RhbmNlIH1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFNhbXBsZXMucHVzaCh7IHNhbXBsZTogc2FtcGxlLCByZWZEaXN0YW5jZTogcmVmRGlzdGFuY2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbG9zZXN0U2FtcGxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yZWZEaXN0YW5jZSAtIGIucmVmRGlzdGFuY2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNsb3Nlc3RTYW1wbGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgc3BvdCA9IGNsb3Nlc3RTYW1wbGVzWzBdLnNhbXBsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcG90O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMge1ZlY3Rvcml6ZXJ9XG4gICAgICovXG4gICAgVlByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuXG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5ub2RlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0cnVlTmFtZSA9IGF0dHJpYnV0ZU5hbWVzW25hbWVdO1xuXG4gICAgICAgIGNvbnN0IHsgbnMgfSA9IFYucXVhbGlmeUF0dHIodHJ1ZU5hbWUpO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gYmUgbmFtZXNwYWNlZC4gRS5nLiBgaW1hZ2VgIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBoYXZlIGEgYHhsaW5rOmhyZWZgIGF0dHJpYnV0ZSB0byBzZXQgdGhlIHNvdXJjZSBvZiB0aGUgaW1hZ2UuXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyhucywgdHJ1ZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0cnVlTmFtZSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgZWwuaWQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSh0cnVlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhbiBTVkcgZG9jdW1lbnQgZWxlbWVudC5cbiAgICAvLyBJZiBgY29udGVudGAgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIFNWRyBjb250ZW50IG9mIHRoZSBgPHN2Zz5gIHJvb3QgZWxlbWVudC5cbiAgICBWLmNyZWF0ZVN2Z0RvY3VtZW50ID0gZnVuY3Rpb24oY29udGVudCkge1xuXG4gICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBYTUxTdHJpbmcgPSBgPHN2ZyB4bWxucz1cIiR7bnMuc3ZnfVwiIHhtbG5zOnhsaW5rPVwiJHtucy54bGlua31cIiB2ZXJzaW9uPVwiJHtTVkdWZXJzaW9ufVwiPiR7Y29udGVudH08L3N2Zz5gO1xuICAgICAgICAgICAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQgfSA9IFYucGFyc2VYTUwoWE1MU3RyaW5nLCB7IGFzeW5jOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMuc3ZnLCAnc3ZnJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyhucy54bWxucywgJ3htbG5zOnhsaW5rJywgbnMueGxpbmspO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCd2ZXJzaW9uJywgU1ZHVmVyc2lvbik7XG4gICAgICAgIHJldHVybiBzdmc7XG4gICAgfTtcblxuICAgIFYuY3JlYXRlU1ZHU3R5bGUgPSBmdW5jdGlvbihzdHlsZXNoZWV0KSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZSB9ID0gVignc3R5bGUnLCB7IHR5cGU6ICd0ZXh0L2NzcycgfSwgW1xuICAgICAgICAgICAgVi5jcmVhdGVDREFUQVNlY3Rpb24oc3R5bGVzaGVldClcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBWLmNyZWF0ZUNEQVRBU2VjdGlvbiA9IGZ1bmN0aW9uKGRhdGEgPSAnJykge1xuICAgICAgICBjb25zdCB4bWwgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChudWxsLCAneG1sJywgbnVsbCk7XG4gICAgICAgIHJldHVybiB4bWwuY3JlYXRlQ0RBVEFTZWN0aW9uKGRhdGEpO1xuICAgIH07XG5cbiAgICBWLmlkQ291bnRlciA9IDA7XG5cbiAgICAvLyBBIGZ1bmN0aW9uIHJldHVybmluZyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGNsaWVudCBzZXNzaW9uIHdpdGggZXZlcnkgY2FsbC5cbiAgICBWLnVuaXF1ZUlkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICd2LScgKyAoKytWLmlkQ291bnRlcik7XG4gICAgfTtcblxuICAgIFYudG9Ob2RlID0gZnVuY3Rpb24oZWwpIHtcblxuICAgICAgICByZXR1cm4gVi5pc1YoZWwpID8gZWwubm9kZSA6IChlbC5ub2RlTmFtZSAmJiBlbCB8fCBlbFswXSk7XG4gICAgfTtcblxuICAgIFYuZW5zdXJlSWQgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICAgICAgbm9kZSA9IFYudG9Ob2RlKG5vZGUpO1xuICAgICAgICByZXR1cm4gbm9kZS5pZCB8fCAobm9kZS5pZCA9IFYudW5pcXVlSWQoKSk7XG4gICAgfTtcblxuICAgIC8vIFJlcGxhY2UgYWxsIHNwYWNlcyB3aXRoIHRoZSBVbmljb2RlIE5vLWJyZWFrIHNwYWNlIChodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9pbmZvL3VuaWNvZGUvY2hhci9hMC9pbmRleC5odG0pLlxuICAgIC8vIElFIHdvdWxkIG90aGVyd2lzZSBjb2xsYXBzZSBhbGwgc3BhY2VzIGludG8gb25lLiBUaGlzIGlzIHVzZWQgaW4gdGhlIHRleHQoKSBtZXRob2QgYnV0IGl0IGlzXG4gICAgLy8gYWxzbyBleHBvc2VkIHNvIHRoYXQgdGhlIHByb2dyYW1tZXIgY2FuIHVzZSBpdCBpbiBjYXNlIGhlIG5lZWRzIHRvLiBUaGlzIGlzIHVzZWZ1bCBlLmcuIGluIHRlc3RzXG4gICAgLy8gd2hlbiB5b3Ugd2FudCB0byBjb21wYXJlIHRoZSBhY3R1YWwgRE9NIHRleHQgY29udGVudCB3aXRob3V0IGhhdmluZyB0byBhZGQgdGhlIHVuaWNvZGUgY2hhcmFjdGVyIGluXG4gICAgLy8gdGhlIHBsYWNlIG9mIGFsbCBzcGFjZXMuXG4gICAgVi5zYW5pdGl6ZVRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG5cbiAgICAgICAgcmV0dXJuICh0ZXh0IHx8ICcnKS5yZXBsYWNlKC8gL2csICdcXHUwMEEwJyk7XG4gICAgfTtcblxuICAgIFYuaXNVbmRlZmluZWQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuICAgIH07XG5cbiAgICBWLmlzU3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9O1xuXG4gICAgVi5pc09iamVjdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICB9O1xuXG4gICAgVi5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIFYucGFyc2VYTUwgPSBmdW5jdGlvbihkYXRhLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIHhtbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuICAgICAgICAgICAgaWYgKCFWLmlzVW5kZWZpbmVkKG9wdC5hc3luYykpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYXN5bmMgPSBvcHQuYXN5bmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoZGF0YSwgJ3RleHQveG1sJyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB4bWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgWE1MOiAnICsgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geG1sO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgYW4gZW1wdHkgb2JqZWN0IHdoaWNoIGRvZXMgbm90IGluaGVyaXQgYW55IHByb3BlcnRpZXMgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgLy8gVGhpcyBpcyB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvIHVzZSBhbiBvYmplY3QgYXMgYSBkaWN0aW9uYXJ5IHdpdGhvdXQgaGF2aW5nIHRvXG4gICAgLy8gd29ycnkgYWJvdXQgaW5oZXJpdGVkIHByb3BlcnRpZXMgc3VjaCBhcyBgdG9TdHJpbmdgLCBgdmFsdWVPZmAgZXRjLlxuICAgIGNvbnN0IF9hdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBMaXN0IG9mIGF0dHJpYnV0ZXMgZm9yIHdoaWNoIG5vdCB0byBzcGxpdCBjYW1lbCBjYXNlIHdvcmRzLlxuICAgIC8vIEl0IGNvbnRhaW5zIGtub3duIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYW5kIG1heSBiZSBleHRlbmRlZCB3aXRoIHVzZXItZGVmaW5lZCBhdHRyaWJ1dGUgbmFtZXMuXG4gICAgW1xuICAgICAgICAnYmFzZUZyZXF1ZW5jeScsXG4gICAgICAgICdiYXNlUHJvZmlsZScsXG4gICAgICAgICdjbGlwUGF0aFVuaXRzJyxcbiAgICAgICAgJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgICAgICAgJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICAgICAgICAnZGlmZnVzZUNvbnN0YW50JyxcbiAgICAgICAgJ2VkZ2VNb2RlJyxcbiAgICAgICAgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICAgICAgICAnZmlsdGVyUmVzJywgLy8gZGVwcmVjYXRlZFxuICAgICAgICAnZmlsdGVyVW5pdHMnLFxuICAgICAgICAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgICAgICAnZ3JhZGllbnRVbml0cycsXG4gICAgICAgICdrZXJuZWxNYXRyaXgnLFxuICAgICAgICAna2VybmVsVW5pdExlbmd0aCcsXG4gICAgICAgICdrZXlQb2ludHMnLFxuICAgICAgICAnbGVuZ3RoQWRqdXN0JyxcbiAgICAgICAgJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgICAgICAgJ21hcmtlckhlaWdodCcsXG4gICAgICAgICdtYXJrZXJVbml0cycsXG4gICAgICAgICdtYXJrZXJXaWR0aCcsXG4gICAgICAgICdtYXNrQ29udGVudFVuaXRzJyxcbiAgICAgICAgJ21hc2tVbml0cycsXG4gICAgICAgICdudW1PY3RhdmVzJyxcbiAgICAgICAgJ3BhdGhMZW5ndGgnLFxuICAgICAgICAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgICAgICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgICAgICAgJ3BhdHRlcm5Vbml0cycsXG4gICAgICAgICdwb2ludHNBdFgnLFxuICAgICAgICAncG9pbnRzQXRZJyxcbiAgICAgICAgJ3BvaW50c0F0WicsXG4gICAgICAgICdwcmVzZXJ2ZUFscGhhJyxcbiAgICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICAgICAgICAncHJpbWl0aXZlVW5pdHMnLFxuICAgICAgICAncmVmWCcsXG4gICAgICAgICdyZWZZJyxcbiAgICAgICAgJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gICAgICAgICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgICAgICAgJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICAgICAgICAnc3BlY3VsYXJFeHBvbmVudCcsXG4gICAgICAgICdzcHJlYWRNZXRob2QnLFxuICAgICAgICAnc3RhcnRPZmZzZXQnLFxuICAgICAgICAnc3RkRGV2aWF0aW9uJyxcbiAgICAgICAgJ3N0aXRjaFRpbGVzJyxcbiAgICAgICAgJ3N1cmZhY2VTY2FsZScsXG4gICAgICAgICdzeXN0ZW1MYW5ndWFnZScsXG4gICAgICAgICd0YWJsZVZhbHVlcycsXG4gICAgICAgICd0YXJnZXRYJyxcbiAgICAgICAgJ3RhcmdldFknLFxuICAgICAgICAndGV4dExlbmd0aCcsXG4gICAgICAgICd2aWV3Qm94JyxcbiAgICAgICAgJ3ZpZXdUYXJnZXQnLCAvLyBkZXByZWNhdGVkXG4gICAgICAgICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgICAgICAgJ3lDaGFubmVsU2VsZWN0b3InLFxuICAgICAgICAnem9vbUFuZFBhbicgLy8gZGVwcmVjYXRlZFxuICAgIF0uZm9yRWFjaCgobmFtZSkgPT4gX2F0dHJpYnV0ZU5hbWVzW25hbWVdID0gbmFtZSk7XG5cbiAgICBfYXR0cmlidXRlTmFtZXNbJ3hsaW5rU2hvdyddID0gJ3hsaW5rOnNob3cnO1xuICAgIF9hdHRyaWJ1dGVOYW1lc1sneGxpbmtSb2xlJ10gPSAneGxpbms6cm9sZSc7XG4gICAgX2F0dHJpYnV0ZU5hbWVzWyd4bGlua0FjdHVhdGUnXSA9ICd4bGluazphY3R1YXRlJztcbiAgICBfYXR0cmlidXRlTmFtZXNbJ3hsaW5rSHJlZiddID0gJ3hsaW5rOmhyZWYnO1xuICAgIF9hdHRyaWJ1dGVOYW1lc1sneGxpbmtUeXBlJ10gPSAneGxpbms6dHlwZSc7XG4gICAgX2F0dHJpYnV0ZU5hbWVzWyd4bGlua1RpdGxlJ10gPSAneGxpbms6dGl0bGUnO1xuICAgIF9hdHRyaWJ1dGVOYW1lc1sneG1sQmFzZSddID0gJ3htbDpiYXNlJztcbiAgICBfYXR0cmlidXRlTmFtZXNbJ3htbExhbmcnXSA9ICd4bWw6bGFuZyc7XG4gICAgX2F0dHJpYnV0ZU5hbWVzWyd4bWxTcGFjZSddID0gJ3htbDpzcGFjZSc7XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IG5ldyBQcm94eShfYXR0cmlidXRlTmFtZXMsIHtcbiAgICAgICAgZ2V0KGNhY2hlLCBuYW1lKSB7XG4gICAgICAgICAgICAvLyBUaGUgY2FjaGUgaXMgYSBkaWN0aW9uYXJ5IG9mIGF0dHJpYnV0ZSBuYW1lcy4gU2VlIGBfYXR0cmlidXRlTmFtZXNgIGFib3ZlLlxuICAgICAgICAgICAgLy8gSWYgdGhlIGF0dHJpYnV0ZSBuYW1lIGlzIG5vdCBpbiB0aGUgY2FjaGUsIGl0IG1lYW5zIHRoYXQgaXQgaXMgbm90XG4gICAgICAgICAgICAvLyBhIGNhbWVsLWNhc2UgYXR0cmlidXRlIG5hbWUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBjb252ZXJ0XG4gICAgICAgICAgICAvLyB0aGUgYXR0cmlidXRlIG5hbWUgdG8gZGFzaC1zZXBhcmF0ZWQgd29yZHMuXG4gICAgICAgICAgICBpZiAoIVYuc3VwcG9ydENhbWVsQ2FzZUF0dHJpYnV0ZXMpIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGNhbWVsIGNhc2UgdG8gZGFzaC1zZXBhcmF0ZWQgd29yZHMuXG4gICAgICAgICAgICByZXR1cm4gKGNhY2hlW25hbWVdID0gbmFtZS5yZXBsYWNlKC9bQS1aXS9nLCAnLSQmJykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpY3Rpb25hcnkgb2YgYXR0cmlidXRlIG5hbWVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFYsICdhdHRyaWJ1dGVOYW1lcycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG5cbiAgICAvLyBTaG91bGQgY2FtZWwgY2FzZSBhdHRyaWJ1dGVzIGJlIHN1cHBvcnRlZD9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoViwgJ3N1cHBvcnRDYW1lbENhc2VBdHRyaWJ1dGVzJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHt7bnM6IHN0cmluZ3xudWxsLCBsb2NhbDogc3RyaW5nfX0gbmFtZXNwYWNlIGFuZCBhdHRyaWJ1dGUgbmFtZVxuICAgICAqL1xuICAgIFYucXVhbGlmeUF0dHIgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGNvbWJpbmVkS2V5ID0gbmFtZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuczogbnNbY29tYmluZWRLZXlbMF1dLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBjb21iaW5lZEtleVsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuczogbnVsbCxcbiAgICAgICAgICAgIGxvY2FsOiBuYW1lXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IFRoaXMgcmVnZXggYWxsb3dzIG11bHRpcGxlIGNvbW1hcyBhcyBzZXBhcmF0b3Igd2hpY2ggaXMgaW5jb3JyZWN0IGluIFNWR1xuICAgIC8vIFRoaXMgcmVnZXggaXMgdXNlZCBieSBgc3BsaXQoKWAsIHNvIGl0IGRvZXNuJ3QgbmVlZCB0byB1c2UgL2dcbiAgICBWLnRyYW5zZm9ybVNlcGFyYXRvclJlZ2V4ID0gL1sgLF0rLztcbiAgICAvLyBOb3RlOiBBbGwgZm9sbG93aW5nIHJlZ2V4ZXMgYXJlIG1vcmUgcmVzdHJpY3RpdmUgdGhhbiBTVkcgc3BlY2lmaWNhdGlvblxuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IFVzZSBhbiBhbmNob3IgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWF0Y2hcbiAgICAvLyBSZURvUyBtaXRpZ2F0aW9uOiBBdm9pZCBiYWNrdHJhY2tpbmcgKHVzZXMgYFteKCldK2AgaW5zdGVhZCBvZiBgLio/YClcbiAgICAvLyBSZURvUyBtaXRpZ2F0aW9uOiBEb24ndCBtYXRjaCBpbml0aWFsIGAoYCBpbnNpZGUgcmVwZWF0ZWQgcGFydFxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVnZXggbmVlZHMgdG8gdXNlIC9nICg9IGNhbm5vdCB1c2UgY2FwdHVyaW5nIGdyb3VwcylcbiAgICBWLnRyYW5zZm9ybVJlZ2V4ID0gL1xcYlxcdytcXChbXigpXStcXCkvZztcbiAgICAvLyBUaGUgZm9sbG93aW5nIHJlZ2V4ZXMgbmVlZCB0byB1c2UgY2FwdHVyaW5nIGdyb3VwcyAoPSBjYW5ub3QgdXNlIC9nKVxuICAgIFYudHJhbnNmb3JtRnVuY3Rpb25SZWdleCA9IC9cXGIoXFx3KylcXCgoW14oKV0rKVxcKS87XG4gICAgVi50cmFuc2Zvcm1UcmFuc2xhdGVSZWdleCA9IC9cXGJ0cmFuc2xhdGVcXCgoW14oKV0rKVxcKS87XG4gICAgVi50cmFuc2Zvcm1Sb3RhdGVSZWdleCA9IC9cXGJyb3RhdGVcXCgoW14oKV0rKVxcKS87XG4gICAgVi50cmFuc2Zvcm1TY2FsZVJlZ2V4ID0gL1xcYnNjYWxlXFwoKFteKCldKylcXCkvO1xuXG4gICAgVi50cmFuc2Zvcm1TdHJpbmdUb01hdHJpeCA9IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgcmVzdWx0IG1hdHJpeCBhcyBpZGVudGl0eSBtYXRyaXhcbiAgICAgICAgbGV0IHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKTtcblxuICAgICAgICAvLyBOb3RlOiBNdWx0aXBsZSB0cmFuc2Zvcm0gZnVuY3Rpb25zIGFyZSBhbGxvd2VkIGluIGB0cmFuc2Zvcm1gIHN0cmluZ1xuICAgICAgICAvLyBgbWF0Y2goKWAgcmV0dXJucyBgbnVsbGAgaWYgbm9uZSBmb3VuZFxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1NYXRjaGVzID0gdHJhbnNmb3JtICYmIHRyYW5zZm9ybS5tYXRjaChWLnRyYW5zZm9ybVJlZ2V4KTtcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1NYXRjaGVzKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaWRlbnRpdHkgbWF0cml4XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25NYXRyaXg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBudW1NYXRjaGVzID0gdHJhbnNmb3JtTWF0Y2hlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWF0Y2hlczsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdGNoID0gdHJhbnNmb3JtTWF0Y2hlc1tpXTtcbiAgICAgICAgICAgIC8vIFVzZSBzYW1lIHJlZ2V4IGFzIGFib3ZlLCBidXQgd2l0aCBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAvLyBgbWF0Y2goKWAgcmV0dXJucyB2YWx1ZXMgb2YgY2FwdHVyaW5nIGdyb3VwcyBhcyBgWzFdYCwgYFsyXWBcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybUZ1bmN0aW9uTWF0Y2ggPSB0cmFuc2Zvcm1NYXRjaC5tYXRjaChWLnRyYW5zZm9ybUZ1bmN0aW9uUmVnZXgpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybUZ1bmN0aW9uTWF0Y2gpIHtcblxuICAgICAgICAgICAgICAgIGxldCBzeCwgc3ksIHR4LCB0eSwgYW5nbGU7XG4gICAgICAgICAgICAgICAgbGV0IGN0bSA9IFYuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtRnVuY3Rpb24gPSB0cmFuc2Zvcm1GdW5jdGlvbk1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRyYW5zZm9ybUZ1bmN0aW9uTWF0Y2hbMl0uc3BsaXQoVi50cmFuc2Zvcm1TZXBhcmF0b3JSZWdleCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cmFuc2Zvcm1GdW5jdGlvbikge1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4ID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5ID0gKGFyZ3NbMV0gPT09IHVuZGVmaW5lZCkgPyBzeCA6IHBhcnNlRmxvYXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG0gPSBjdG0uc2NhbGVOb25Vbmlmb3JtKHN4LCBzeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSBwYXJzZUZsb2F0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtID0gY3RtLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncm90YXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gcGFyc2VGbG9hdChhcmdzWzFdKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHkgPSBwYXJzZUZsb2F0KGFyZ3NbMl0pIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHggIT09IDAgfHwgdHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdG0gPSBjdG0udHJhbnNsYXRlKHR4LCB0eSkucm90YXRlKGFuZ2xlKS50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdG0gPSBjdG0ucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NrZXd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5za2V3WChhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdza2V3eSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG0gPSBjdG0uc2tld1koYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5hID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5iID0gcGFyc2VGbG9hdChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5jID0gcGFyc2VGbG9hdChhcmdzWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5kID0gcGFyc2VGbG9hdChhcmdzWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5lID0gcGFyc2VGbG9hdChhcmdzWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bS5mID0gcGFyc2VGbG9hdChhcmdzWzVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBseSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGludG8gcmVzdWx0IG1hdHJpeFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdHJhbnNmb3JtYXRpb25NYXRyaXgubXVsdGlwbHkoY3RtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbk1hdHJpeDtcbiAgICB9O1xuXG4gICAgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgICAgICBtYXRyaXggfHwgKG1hdHJpeCA9IHRydWUpO1xuXG4gICAgICAgIHJldHVybiAnbWF0cml4KCcgK1xuICAgICAgICAgICAgKG1hdHJpeC5hICE9PSB1bmRlZmluZWQgPyBtYXRyaXguYSA6IDEpICsgJywnICtcbiAgICAgICAgICAgIChtYXRyaXguYiAhPT0gdW5kZWZpbmVkID8gbWF0cml4LmIgOiAwKSArICcsJyArXG4gICAgICAgICAgICAobWF0cml4LmMgIT09IHVuZGVmaW5lZCA/IG1hdHJpeC5jIDogMCkgKyAnLCcgK1xuICAgICAgICAgICAgKG1hdHJpeC5kICE9PSB1bmRlZmluZWQgPyBtYXRyaXguZCA6IDEpICsgJywnICtcbiAgICAgICAgICAgIChtYXRyaXguZSAhPT0gdW5kZWZpbmVkID8gbWF0cml4LmUgOiAwKSArICcsJyArXG4gICAgICAgICAgICAobWF0cml4LmYgIT09IHVuZGVmaW5lZCA/IG1hdHJpeC5mIDogMCkgK1xuICAgICAgICAgICAgJyknO1xuICAgIH07XG5cbiAgICBWLnBhcnNlVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZSwgcm90YXRlLCBzY2FsZTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG5cbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBWLnRyYW5zZm9ybVNlcGFyYXRvclJlZ2V4O1xuXG4gICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBgdHJhbnNmb3JtYCB3aXRoIG9uZSBvciBtb3JlIG1hdHJpeCBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0udHJpbSgpLmluZGV4T2YoJ21hdHJpeCcpID49IDApIHtcblxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgRVZFUllUSElORyBpbiBgdHJhbnNmb3JtYCBzdHJpbmcgdG8gYSBtYXRyaXhcbiAgICAgICAgICAgICAgICAvLyBXaWxsIGNvbWJpbmUgQUxMIG1hdHJpeGVzICogQUxMIHRyYW5zbGF0ZXMgKiBBTEwgc2NhbGVzICogQUxMIHJvdGF0ZXNcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBJbiBub24tbWF0cml4IGNhc2UsIHdlIG9ubHkgdGFrZSBmaXJzdCBvbmUgb2YgZWFjaCAoaWYgYW55KVxuICAgICAgICAgICAgICAgIHZhciBtYXRyaXggPSBWLnRyYW5zZm9ybVN0cmluZ1RvTWF0cml4KHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29tcG9zZWRNYXRyaXggPSBWLmRlY29tcG9zZU1hdHJpeChtYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBgdHJhbnNsYXRlYCwgYHNjYWxlYCwgYHJvdGF0ZWAgZnJvbSBtYXRyaXhcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGUgPSBbZGVjb21wb3NlZE1hdHJpeC50cmFuc2xhdGVYLCBkZWNvbXBvc2VkTWF0cml4LnRyYW5zbGF0ZVldO1xuICAgICAgICAgICAgICAgIHNjYWxlID0gW2RlY29tcG9zZWRNYXRyaXguc2NhbGVYLCBkZWNvbXBvc2VkTWF0cml4LnNjYWxlWV07XG4gICAgICAgICAgICAgICAgcm90YXRlID0gW2RlY29tcG9zZWRNYXRyaXgucm90YXRpb25dO1xuXG4gICAgICAgICAgICAgICAgLy8gUmV3cml0ZSBgdHJhbnNmb3JtYCBzdHJpbmcgaW4gYHRyYW5zbGF0ZSBzY2FsZSByb3RhdGVgIGZvcm1hdFxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlWzBdICE9PSAwIHx8IHRyYW5zbGF0ZVsxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaCgndHJhbnNsYXRlKCcgKyB0cmFuc2xhdGUgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVbMF0gIT09IDEgfHwgc2NhbGVbMV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goJ3NjYWxlKCcgKyBzY2FsZSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGVbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goJ3JvdGF0ZSgnICsgcm90YXRlICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtYXRpb25zLmpvaW4oJyAnKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgYHRyYW5zbGF0ZWAsIGByb3RhdGVgLCBgc2NhbGVgIGZ1bmN0aW9ucyBmcm9tIGB0cmFuc2Zvcm1gIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIG9ubHkgZGV0ZWN0IHRoZSBmaXJzdCBtYXRjaCBvZiBlYWNoIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgLy8gYG1hdGNoKClgIHJldHVybnMgdmFsdWUgb2YgY2FwdHVyaW5nIGdyb3VwIGFzIGBbMV1gXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlTWF0Y2ggPSB0cmFuc2Zvcm0ubWF0Y2goVi50cmFuc2Zvcm1UcmFuc2xhdGVSZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSA9IHRyYW5zbGF0ZU1hdGNoWzFdLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdGF0ZU1hdGNoID0gdHJhbnNmb3JtLm1hdGNoKFYudHJhbnNmb3JtUm90YXRlUmVnZXgpO1xuICAgICAgICAgICAgICAgIGlmIChyb3RhdGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByb3RhdGUgPSByb3RhdGVNYXRjaFsxXS5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZU1hdGNoID0gdHJhbnNmb3JtLm1hdGNoKFYudHJhbnNmb3JtU2NhbGVSZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGUgPSBzY2FsZU1hdGNoWzFdLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN4ID0gKHNjYWxlICYmIHNjYWxlWzBdKSA/IHBhcnNlRmxvYXQoc2NhbGVbMF0pIDogMTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHRyYW5zZm9ybSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZToge1xuICAgICAgICAgICAgICAgIHR4OiAodHJhbnNsYXRlICYmIHRyYW5zbGF0ZVswXSkgPyBwYXJzZUludCh0cmFuc2xhdGVbMF0sIDEwKSA6IDAsXG4gICAgICAgICAgICAgICAgdHk6ICh0cmFuc2xhdGUgJiYgdHJhbnNsYXRlWzFdKSA/IHBhcnNlSW50KHRyYW5zbGF0ZVsxXSwgMTApIDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdGF0ZToge1xuICAgICAgICAgICAgICAgIGFuZ2xlOiAocm90YXRlICYmIHJvdGF0ZVswXSkgPyBwYXJzZUludChyb3RhdGVbMF0sIDEwKSA6IDAsXG4gICAgICAgICAgICAgICAgY3g6IChyb3RhdGUgJiYgcm90YXRlWzFdKSA/IHBhcnNlSW50KHJvdGF0ZVsxXSwgMTApIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGN5OiAocm90YXRlICYmIHJvdGF0ZVsyXSkgPyBwYXJzZUludChyb3RhdGVbMl0sIDEwKSA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICAgICAgc3g6IHN4LFxuICAgICAgICAgICAgICAgIHN5OiAoc2NhbGUgJiYgc2NhbGVbMV0pID8gcGFyc2VGbG9hdChzY2FsZVsxXSkgOiBzeFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBWLmRlbHRhVHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbihtYXRyaXgsIHBvaW50KSB7XG5cbiAgICAgICAgdmFyIGR4ID0gcG9pbnQueCAqIG1hdHJpeC5hICsgcG9pbnQueSAqIG1hdHJpeC5jICsgMDtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnQueCAqIG1hdHJpeC5iICsgcG9pbnQueSAqIG1hdHJpeC5kICsgMDtcbiAgICAgICAgcmV0dXJuIHsgeDogZHgsIHk6IGR5IH07XG4gICAgfTtcblxuICAgIFYuZGVjb21wb3NlTWF0cml4ID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8yMDUyMjQ3XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGRlbHRhIHRyYW5zZm9ybSBwb2ludFxuICAgICAgICB2YXIgcHggPSBWLmRlbHRhVHJhbnNmb3JtUG9pbnQobWF0cml4LCB7IHg6IDAsIHk6IDEgfSk7XG4gICAgICAgIHZhciBweSA9IFYuZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHsgeDogMSwgeTogMCB9KTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc2tld1xuICAgICAgICB2YXIgc2tld1ggPSAoKDE4MCAvIFBJKSAqIGF0YW4yKHB4LnksIHB4LngpIC0gOTApO1xuICAgICAgICB2YXIgc2tld1kgPSAoKDE4MCAvIFBJKSAqIGF0YW4yKHB5LnksIHB5LngpKTtcblxuICAgICAgICByZXR1cm4ge1xuXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiBtYXRyaXguZSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZVk6IG1hdHJpeC5mLFxuICAgICAgICAgICAgc2NhbGVYOiBzcXJ0KG1hdHJpeC5hICogbWF0cml4LmEgKyBtYXRyaXguYiAqIG1hdHJpeC5iKSxcbiAgICAgICAgICAgIHNjYWxlWTogc3FydChtYXRyaXguYyAqIG1hdHJpeC5jICsgbWF0cml4LmQgKiBtYXRyaXguZCksXG4gICAgICAgICAgICBza2V3WDogc2tld1gsXG4gICAgICAgICAgICBza2V3WTogc2tld1ksXG4gICAgICAgICAgICByb3RhdGlvbjogc2tld1ggLy8gcm90YXRpb24gaXMgdGhlIHNhbWUgYXMgc2tldyB4XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgYHNjYWxlYCB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBmb2xsb3dpbmcgZXF1YXRpb246XG4gICAgLy8gYHRyYW5zbGF0ZSh0eCwgdHkpIC4gcm90YXRlKGFuZ2xlKSAuIHNjYWxlKHN4LCBzeSkgPT09IG1hdHJpeChhLGIsYyxkLGUsZilgXG4gICAgVi5tYXRyaXhUb1NjYWxlID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgdmFyIGEsIGIsIGMsIGQ7XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIGEgPSBWLmlzVW5kZWZpbmVkKG1hdHJpeC5hKSA/IDEgOiBtYXRyaXguYTtcbiAgICAgICAgICAgIGQgPSBWLmlzVW5kZWZpbmVkKG1hdHJpeC5kKSA/IDEgOiBtYXRyaXguZDtcbiAgICAgICAgICAgIGIgPSBtYXRyaXguYjtcbiAgICAgICAgICAgIGMgPSBtYXRyaXguYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGEgPSBkID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3g6IGIgPyBzcXJ0KGEgKiBhICsgYiAqIGIpIDogYSxcbiAgICAgICAgICAgIHN5OiBjID8gc3FydChjICogYyArIGQgKiBkKSA6IGRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBgcm90YXRlYCB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBmb2xsb3dpbmcgZXF1YXRpb246XG4gICAgLy8gYHRyYW5zbGF0ZSh0eCwgdHkpIC4gcm90YXRlKGFuZ2xlKSAuIHNjYWxlKHN4LCBzeSkgPT09IG1hdHJpeChhLGIsYyxkLGUsZilgXG4gICAgVi5tYXRyaXhUb1JvdGF0ZSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXG4gICAgICAgIHZhciBwID0geyB4OiAwLCB5OiAxIH07XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHAgPSBWLmRlbHRhVHJhbnNmb3JtUG9pbnQobWF0cml4LCBwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbmdsZTogZy5ub3JtYWxpemVBbmdsZShnLnRvRGVnKGF0YW4yKHAueSwgcC54KSkgLSA5MClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBgdHJhbnNsYXRlYCB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBmb2xsb3dpbmcgZXF1YXRpb246XG4gICAgLy8gYHRyYW5zbGF0ZSh0eCwgdHkpIC4gcm90YXRlKGFuZ2xlKSAuIHNjYWxlKHN4LCBzeSkgPT09IG1hdHJpeChhLGIsYyxkLGUsZilgXG4gICAgVi5tYXRyaXhUb1RyYW5zbGF0ZSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eDogKG1hdHJpeCAmJiBtYXRyaXguZSkgfHwgMCxcbiAgICAgICAgICAgIHR5OiAobWF0cml4ICYmIG1hdHJpeC5mKSB8fCAwXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFYuaXNWID0gZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFY7XG4gICAgfTtcblxuICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbiAgICBWLmlzVkVsZW1lbnQgPSBWLmlzVjtcblxuICAgIC8vIEVsZW1lbnQgaW1wbGVtZW50cyBgZ2V0QkJveCgpYCwgYGdldENUTSgpYCBhbmQgYGdldFNjcmVlbkNUTSgpYFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdHcmFwaGljc0VsZW1lbnRcbiAgICBWLmlzU1ZHR3JhcGhpY3NFbGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbm9kZSA9IFYudG9Ob2RlKG5vZGUpO1xuICAgICAgICAvLyBJRS9FZGdlIGRvZXMgbm90IGltcGxlbWVudCBTVkdHcmFwaGljc0VsZW1lbnQgaW50ZXJmYWNlLCB0aHVzIGNoZWNrIGZvciBgZ2V0U2NyZWVuQ1RNYCBiZWxvd1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgdHlwZW9mIG5vZGUuZ2V0U2NyZWVuQ1RNID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG5cbiAgICB2YXIgc3ZnRG9jdW1lbnQgPSBWKCdzdmcnKS5ub2RlO1xuXG4gICAgVi5jcmVhdGVTVkdNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblxuICAgICAgICB2YXIgc3ZnTWF0cml4ID0gc3ZnRG9jdW1lbnQuY3JlYXRlU1ZHTWF0cml4KCk7XG4gICAgICAgIGZvciAodmFyIGNvbXBvbmVudCBpbiBtYXRyaXgpIHtcbiAgICAgICAgICAgIHN2Z01hdHJpeFtjb21wb25lbnRdID0gbWF0cml4W2NvbXBvbmVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3ZnTWF0cml4O1xuICAgIH07XG5cbiAgICBWLmNyZWF0ZVNWR1RyYW5zZm9ybSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXG4gICAgICAgIGlmICghVi5pc1VuZGVmaW5lZChtYXRyaXgpKSB7XG5cbiAgICAgICAgICAgIGlmICghKG1hdHJpeCBpbnN0YW5jZW9mIFNWR01hdHJpeCkpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeChtYXRyaXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3ZnRG9jdW1lbnQuY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeChtYXRyaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN2Z0RvY3VtZW50LmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgIH07XG5cbiAgICBWLmNyZWF0ZVNWR1BvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHZhciBwID0gc3ZnRG9jdW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgcC54ID0geDtcbiAgICAgICAgcC55ID0geTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIFYudHJhbnNmb3JtUmVjdCA9IGZ1bmN0aW9uKHIsIG1hdHJpeCkge1xuXG4gICAgICAgIHZhciBwID0gc3ZnRG9jdW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcblxuICAgICAgICBwLnggPSByLng7XG4gICAgICAgIHAueSA9IHIueTtcbiAgICAgICAgdmFyIGNvcm5lcjEgPSBwLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xuXG4gICAgICAgIHAueCA9IHIueCArIHIud2lkdGg7XG4gICAgICAgIHAueSA9IHIueTtcbiAgICAgICAgdmFyIGNvcm5lcjIgPSBwLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xuXG4gICAgICAgIHAueCA9IHIueCArIHIud2lkdGg7XG4gICAgICAgIHAueSA9IHIueSArIHIuaGVpZ2h0O1xuICAgICAgICB2YXIgY29ybmVyMyA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgcC54ID0gci54O1xuICAgICAgICBwLnkgPSByLnkgKyByLmhlaWdodDtcbiAgICAgICAgdmFyIGNvcm5lcjQgPSBwLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xuXG4gICAgICAgIHZhciBtaW5YID0gbWluKGNvcm5lcjEueCwgY29ybmVyMi54LCBjb3JuZXIzLngsIGNvcm5lcjQueCk7XG4gICAgICAgIHZhciBtYXhYID0gbWF4KGNvcm5lcjEueCwgY29ybmVyMi54LCBjb3JuZXIzLngsIGNvcm5lcjQueCk7XG4gICAgICAgIHZhciBtaW5ZID0gbWluKGNvcm5lcjEueSwgY29ybmVyMi55LCBjb3JuZXIzLnksIGNvcm5lcjQueSk7XG4gICAgICAgIHZhciBtYXhZID0gbWF4KGNvcm5lcjEueSwgY29ybmVyMi55LCBjb3JuZXIzLnksIGNvcm5lcjQueSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3QobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICB9O1xuXG4gICAgVi50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKHAsIG1hdHJpeCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2ludChWLmNyZWF0ZVNWR1BvaW50KHAueCwgcC55KS5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KSk7XG4gICAgfTtcblxuICAgIFYudHJhbnNmb3JtTGluZSA9IGZ1bmN0aW9uKGwsIG1hdHJpeCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgZy5MaW5lKFxuICAgICAgICAgICAgVi50cmFuc2Zvcm1Qb2ludChsLnN0YXJ0LCBtYXRyaXgpLFxuICAgICAgICAgICAgVi50cmFuc2Zvcm1Qb2ludChsLmVuZCwgbWF0cml4KVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBWLnRyYW5zZm9ybVBvbHlsaW5lID0gZnVuY3Rpb24ocCwgbWF0cml4KSB7XG5cbiAgICAgICAgdmFyIGluUG9pbnRzID0gKHAgaW5zdGFuY2VvZiBnLlBvbHlsaW5lKSA/IHAucG9pbnRzIDogcDtcbiAgICAgICAgaWYgKCFWLmlzQXJyYXkoaW5Qb2ludHMpKSBpblBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgb3V0UG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaW5Qb2ludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSBvdXRQb2ludHNbaV0gPSBWLnRyYW5zZm9ybVBvaW50KGluUG9pbnRzW2ldLCBtYXRyaXgpO1xuICAgICAgICByZXR1cm4gbmV3IGcuUG9seWxpbmUob3V0UG9pbnRzKTtcbiAgICB9O1xuXG4gICAgLy8gQ29udmVydCBhIHN0eWxlIHJlcHJlc2VudGVkIGFzIHN0cmluZyAoZS5nLiBgJ2ZpbGw9XCJibHVlXCI7IHN0cm9rZT1cInJlZFwiJ2ApIHRvXG4gICAgLy8gYW4gb2JqZWN0IChgeyBmaWxsOiAnYmx1ZScsIHN0cm9rZTogJ3JlZCcgfWApLlxuICAgIFYuc3R5bGVUb09iamVjdCA9IGZ1bmN0aW9uKHN0eWxlU3RyaW5nKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHN0eWxlU3RyaW5nLnNwbGl0KCc7Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgICAgICAgICB2YXIgcGFpciA9IHN0eWxlLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICByZXRbcGFpclswXS50cmltKCldID0gcGFpclsxXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLy8gSW5zcGlyZWQgYnkgZDMuanMgaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL2Jsb2IvbWFzdGVyL3NyYy9zdmcvYXJjLmpzXG4gICAgVi5jcmVhdGVTbGljZVBhdGhEYXRhID0gZnVuY3Rpb24oaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkge1xuXG4gICAgICAgIHZhciBzdmdBcmNNYXggPSAyICogUEkgLSAxZS02O1xuICAgICAgICB2YXIgcjAgPSBpbm5lclJhZGl1cztcbiAgICAgICAgdmFyIHIxID0gb3V0ZXJSYWRpdXM7XG4gICAgICAgIHZhciBhMCA9IHN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBhMSA9IGVuZEFuZ2xlO1xuICAgICAgICB2YXIgZGEgPSAoYTEgPCBhMCAmJiAoZGEgPSBhMCwgYTAgPSBhMSwgYTEgPSBkYSksIGExIC0gYTApO1xuICAgICAgICB2YXIgZGYgPSBkYSA8IFBJID8gJzAnIDogJzEnO1xuICAgICAgICB2YXIgYzAgPSBjb3MoYTApO1xuICAgICAgICB2YXIgczAgPSBzaW4oYTApO1xuICAgICAgICB2YXIgYzEgPSBjb3MoYTEpO1xuICAgICAgICB2YXIgczEgPSBzaW4oYTEpO1xuXG4gICAgICAgIHJldHVybiAoZGEgPj0gc3ZnQXJjTWF4KVxuICAgICAgICAgICAgPyAocjBcbiAgICAgICAgICAgICAgICA/ICdNMCwnICsgcjFcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgMSwxIDAsJyArICgtcjEpXG4gICAgICAgICAgICAgICAgKyAnQScgKyByMSArICcsJyArIHIxICsgJyAwIDEsMSAwLCcgKyByMVxuICAgICAgICAgICAgICAgICsgJ00wLCcgKyByMFxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjAgKyAnLCcgKyByMCArICcgMCAxLDAgMCwnICsgKC1yMClcbiAgICAgICAgICAgICAgICArICdBJyArIHIwICsgJywnICsgcjAgKyAnIDAgMSwwIDAsJyArIHIwXG4gICAgICAgICAgICAgICAgKyAnWidcbiAgICAgICAgICAgICAgICA6ICdNMCwnICsgcjFcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgMSwxIDAsJyArICgtcjEpXG4gICAgICAgICAgICAgICAgKyAnQScgKyByMSArICcsJyArIHIxICsgJyAwIDEsMSAwLCcgKyByMVxuICAgICAgICAgICAgICAgICsgJ1onKVxuICAgICAgICAgICAgOiAocjBcbiAgICAgICAgICAgICAgICA/ICdNJyArIHIxICogYzAgKyAnLCcgKyByMSAqIHMwXG4gICAgICAgICAgICAgICAgKyAnQScgKyByMSArICcsJyArIHIxICsgJyAwICcgKyBkZiArICcsMSAnICsgcjEgKiBjMSArICcsJyArIHIxICogczFcbiAgICAgICAgICAgICAgICArICdMJyArIHIwICogYzEgKyAnLCcgKyByMCAqIHMxXG4gICAgICAgICAgICAgICAgKyAnQScgKyByMCArICcsJyArIHIwICsgJyAwICcgKyBkZiArICcsMCAnICsgcjAgKiBjMCArICcsJyArIHIwICogczBcbiAgICAgICAgICAgICAgICArICdaJ1xuICAgICAgICAgICAgICAgIDogJ00nICsgcjEgKiBjMCArICcsJyArIHIxICogczBcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgJyArIGRmICsgJywxICcgKyByMSAqIGMxICsgJywnICsgcjEgKiBzMVxuICAgICAgICAgICAgICAgICsgJ0wwLDAnXG4gICAgICAgICAgICAgICAgKyAnWicpO1xuICAgIH07XG5cbiAgICAvLyBNZXJnZSBhdHRyaWJ1dGVzIGZyb20gb2JqZWN0IGBiYCB3aXRoIGF0dHJpYnV0ZXMgaW4gb2JqZWN0IGBhYC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBtb2RpZmllcyB0aGUgb2JqZWN0IGBhYC5cbiAgICAvLyBBbHNvIGltcG9ydGFudCB0byBub3RlIHRoYXQgYXR0cmlidXRlcyBhcmUgbWVyZ2VkIGJ1dCBDU1MgY2xhc3NlcyBhcmUgY29uY2F0ZW5hdGVkLlxuICAgIFYubWVyZ2VBdHRycyA9IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGIpIHtcblxuICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAvLyBDb25jYXRlbmF0ZSBjbGFzc2VzLlxuICAgICAgICAgICAgICAgIGFbYXR0cl0gPSBhW2F0dHJdID8gYVthdHRyXSArICcgJyArIGJbYXR0cl0gOiBiW2F0dHJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUgY2FuIGJlIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICBpZiAoVi5pc09iamVjdChhW2F0dHJdKSAmJiBWLmlzT2JqZWN0KGJbYXR0cl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzdHlsZWAgc3RvcmVkIGluIGBhYCBpcyBhbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgIGFbYXR0cl0gPSBWLm1lcmdlQXR0cnMoYVthdHRyXSwgYlthdHRyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChWLmlzT2JqZWN0KGFbYXR0cl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzdHlsZWAgaW4gYGFgIGlzIGFuIG9iamVjdCBidXQgaXQncyBhIHN0cmluZyBpbiBgYmAuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0eWxlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIHRvIGFuIG9iamVjdCBpbiBgYmAuXG4gICAgICAgICAgICAgICAgICAgIGFbYXR0cl0gPSBWLm1lcmdlQXR0cnMoYVthdHRyXSwgVi5zdHlsZVRvT2JqZWN0KGJbYXR0cl0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFYuaXNPYmplY3QoYlthdHRyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0eWxlYCBpbiBgYWAgaXMgYSBzdHJpbmcsIGluIGBiYCBpdCdzIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgYVthdHRyXSA9IFYubWVyZ2VBdHRycyhWLnN0eWxlVG9PYmplY3QoYVthdHRyXSksIGJbYXR0cl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJvdGggc3R5bGVzIGFyZSBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBhW2F0dHJdID0gVi5tZXJnZUF0dHJzKFYuc3R5bGVUb09iamVjdChhW2F0dHJdKSwgVi5zdHlsZVRvT2JqZWN0KGJbYXR0cl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFbYXR0cl0gPSBiW2F0dHJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcblxuICAgIFYuYW5ub3RhdGVTdHJpbmcgPSBmdW5jdGlvbih0LCBhbm5vdGF0aW9ucywgb3B0KSB7XG5cbiAgICAgICAgYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucyB8fCBbXTtcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBvcHQub2Zmc2V0IHx8IDA7XG4gICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcbiAgICAgICAgdmFyIGJhdGNoO1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICB2YXIgcHJldjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgaXRlbSA9IHJldFtpXSA9IHRbaV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyBqKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbal07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5ub3RhdGlvbi5zdGFydCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gYW5ub3RhdGlvbi5lbmQgKyBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBzdGFydCAmJiBpIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFubm90YXRpb24gYXBwbGllcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKFYuaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgYW5ub3RhdGlvbiB0byBiZSBhcHBsaWVkID0+IE1lcmdlIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJzID0gVi5tZXJnZUF0dHJzKFYubWVyZ2VBdHRycyh7fSwgaXRlbS5hdHRycyksIGFubm90YXRpb24uYXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHJldFtpXSA9IHsgdDogdFtpXSwgYXR0cnM6IGFubm90YXRpb24uYXR0cnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0LmluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGl0ZW0uYW5ub3RhdGlvbnMgfHwgKGl0ZW0uYW5ub3RhdGlvbnMgPSBbXSkpLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXYgPSByZXRbaSAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoIXByZXYpIHtcblxuICAgICAgICAgICAgICAgIGJhdGNoID0gaXRlbTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChWLmlzT2JqZWN0KGl0ZW0pICYmIFYuaXNPYmplY3QocHJldikpIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIHByZXZpb3VzIGl0ZW0gYW5kIHRoZSBjdXJyZW50IG9uZSBhcmUgYW5ub3RhdGlvbnMuIElmIHRoZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLy8gZGlkbid0IGNoYW5nZSwgbWVyZ2UgdGhlIHRleHQuXG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGl0ZW0uYXR0cnMpID09PSBKU09OLnN0cmluZ2lmeShwcmV2LmF0dHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBiYXRjaC50ICs9IGl0ZW0udDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChiYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoID0gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVi5pc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZpb3VzIGl0ZW0gd2FzIGEgc3RyaW5nLCBjdXJyZW50IGl0ZW0gaXMgYW4gYW5ub3RhdGlvbi5cbiAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChiYXRjaCk7XG4gICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFYuaXNPYmplY3QocHJldikpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91cyBpdGVtIHdhcyBhbiBhbm5vdGF0aW9uLCBjdXJyZW50IGl0ZW0gaXMgYSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgICAgIGJhdGNoID0gaXRlbTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIHByZXZpb3VzIGFuZCBjdXJyZW50IGl0ZW0gYXJlIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgYmF0Y2ggPSAoYmF0Y2ggfHwgJycpICsgaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYXRjaCkge1xuICAgICAgICAgICAgY29tcGFjdGVkLnB1c2goYmF0Y2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhY3RlZDtcbiAgICB9O1xuXG4gICAgVi5maW5kQW5ub3RhdGlvbnNBdEluZGV4ID0gZnVuY3Rpb24oYW5ub3RhdGlvbnMsIGluZGV4KSB7XG5cbiAgICAgICAgdmFyIGZvdW5kID0gW107XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG5cbiAgICAgICAgICAgIGFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24oYW5ub3RhdGlvbikge1xuXG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24uc3RhcnQgPCBpbmRleCAmJiBpbmRleCA8PSBhbm5vdGF0aW9uLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICBWLmZpbmRBbm5vdGF0aW9uc0JldHdlZW5JbmRleGVzID0gZnVuY3Rpb24oYW5ub3RhdGlvbnMsIHN0YXJ0LCBlbmQpIHtcblxuICAgICAgICB2YXIgZm91bmQgPSBbXTtcblxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcblxuICAgICAgICAgICAgYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbm5vdGF0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHN0YXJ0ID49IGFubm90YXRpb24uc3RhcnQgJiYgc3RhcnQgPCBhbm5vdGF0aW9uLmVuZCkgfHwgKGVuZCA+IGFubm90YXRpb24uc3RhcnQgJiYgZW5kIDw9IGFubm90YXRpb24uZW5kKSB8fCAoYW5ub3RhdGlvbi5zdGFydCA+PSBzdGFydCAmJiBhbm5vdGF0aW9uLmVuZCA8IGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xuXG4gICAgLy8gU2hpZnQgYWxsIHRoZSB0ZXh0IGFubm90YXRpb25zIGFmdGVyIGNoYXJhY3RlciBgaW5kZXhgIGJ5IGBvZmZzZXRgIHBvc2l0aW9ucy5cbiAgICBWLnNoaWZ0QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihhbm5vdGF0aW9ucywgaW5kZXgsIG9mZnNldCkge1xuXG4gICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuXG4gICAgICAgICAgICBhbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFubm90YXRpb24pIHtcblxuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uLnN0YXJ0IDwgaW5kZXggJiYgYW5ub3RhdGlvbi5lbmQgPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5lbmQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYW5ub3RhdGlvbi5zdGFydCA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLnN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbi5lbmQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgIH07XG5cbiAgICBWLmNvbnZlcnRMaW5lVG9QYXRoRGF0YSA9IGZ1bmN0aW9uKGxpbmUpIHtcblxuICAgICAgICBsaW5lID0gVihsaW5lKTtcbiAgICAgICAgdmFyIGQgPSBbXG4gICAgICAgICAgICAnTScsIGxpbmUuYXR0cigneDEnKSwgbGluZS5hdHRyKCd5MScpLFxuICAgICAgICAgICAgJ0wnLCBsaW5lLmF0dHIoJ3gyJyksIGxpbmUuYXR0cigneTInKVxuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIFYuY29udmVydFBvbHlnb25Ub1BhdGhEYXRhID0gZnVuY3Rpb24ocG9seWdvbikge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBWLmdldFBvaW50c0Zyb21TdmdOb2RlKHBvbHlnb24pO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIFYuc3ZnUG9pbnRzVG9QYXRoKHBvaW50cykgKyAnIFonO1xuICAgIH07XG5cbiAgICBWLmNvbnZlcnRQb2x5bGluZVRvUGF0aERhdGEgPSBmdW5jdGlvbihwb2x5bGluZSkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBWLmdldFBvaW50c0Zyb21TdmdOb2RlKHBvbHlsaW5lKTtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBWLnN2Z1BvaW50c1RvUGF0aChwb2ludHMpO1xuICAgIH07XG5cbiAgICBWLnN2Z1BvaW50c1RvUGF0aCA9IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzW2ldID0gcG9pbnRzW2ldLnggKyAnICcgKyBwb2ludHNbaV0ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnTSAnICsgcG9pbnRzLmpvaW4oJyBMJyk7XG4gICAgfTtcblxuICAgIFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICAgICAgbm9kZSA9IFYudG9Ob2RlKG5vZGUpO1xuICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgIHZhciBub2RlUG9pbnRzID0gbm9kZS5wb2ludHM7XG4gICAgICAgIGlmIChub2RlUG9pbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVQb2ludHMubnVtYmVyT2ZJdGVtczsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKG5vZGVQb2ludHMuZ2V0SXRlbShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH07XG5cbiAgICBWLktBUFBBID0gMC41NTE3ODQ7XG5cbiAgICBWLmNvbnZlcnRDaXJjbGVUb1BhdGhEYXRhID0gZnVuY3Rpb24oY2lyY2xlKSB7XG5cbiAgICAgICAgY2lyY2xlID0gVihjaXJjbGUpO1xuICAgICAgICB2YXIgY3ggPSBwYXJzZUZsb2F0KGNpcmNsZS5hdHRyKCdjeCcpKSB8fCAwO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUZsb2F0KGNpcmNsZS5hdHRyKCdjeScpKSB8fCAwO1xuICAgICAgICB2YXIgciA9IHBhcnNlRmxvYXQoY2lyY2xlLmF0dHIoJ3InKSk7XG4gICAgICAgIHZhciBjZCA9IHIgKiBWLktBUFBBOyAvLyBDb250cm9sIGRpc3RhbmNlLlxuXG4gICAgICAgIHZhciBkID0gW1xuICAgICAgICAgICAgJ00nLCBjeCwgY3kgLSByLCAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgICAgICAgICdDJywgY3ggKyBjZCwgY3kgLSByLCBjeCArIHIsIGN5IC0gY2QsIGN4ICsgciwgY3ksIC8vIEkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCArIHIsIGN5ICsgY2QsIGN4ICsgY2QsIGN5ICsgciwgY3gsIGN5ICsgciwgLy8gSUkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCAtIGNkLCBjeSArIHIsIGN4IC0gciwgY3kgKyBjZCwgY3ggLSByLCBjeSwgLy8gSUlJLiBRdWFkcmFudC5cbiAgICAgICAgICAgICdDJywgY3ggLSByLCBjeSAtIGNkLCBjeCAtIGNkLCBjeSAtIHIsIGN4LCBjeSAtIHIsIC8vIElWLiBRdWFkcmFudC5cbiAgICAgICAgICAgICdaJ1xuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIFYuY29udmVydEVsbGlwc2VUb1BhdGhEYXRhID0gZnVuY3Rpb24oZWxsaXBzZSkge1xuXG4gICAgICAgIGVsbGlwc2UgPSBWKGVsbGlwc2UpO1xuICAgICAgICB2YXIgY3ggPSBwYXJzZUZsb2F0KGVsbGlwc2UuYXR0cignY3gnKSkgfHwgMDtcbiAgICAgICAgdmFyIGN5ID0gcGFyc2VGbG9hdChlbGxpcHNlLmF0dHIoJ2N5JykpIHx8IDA7XG4gICAgICAgIHZhciByeCA9IHBhcnNlRmxvYXQoZWxsaXBzZS5hdHRyKCdyeCcpKTtcbiAgICAgICAgdmFyIHJ5ID0gcGFyc2VGbG9hdChlbGxpcHNlLmF0dHIoJ3J5JykpIHx8IHJ4O1xuICAgICAgICB2YXIgY2R4ID0gcnggKiBWLktBUFBBOyAvLyBDb250cm9sIGRpc3RhbmNlIHguXG4gICAgICAgIHZhciBjZHkgPSByeSAqIFYuS0FQUEE7IC8vIENvbnRyb2wgZGlzdGFuY2UgeS5cblxuICAgICAgICB2YXIgZCA9IFtcbiAgICAgICAgICAgICdNJywgY3gsIGN5IC0gcnksICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IHBvaW50LlxuICAgICAgICAgICAgJ0MnLCBjeCArIGNkeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgLSBjZHksIGN4ICsgcngsIGN5LCAvLyBJLiBRdWFkcmFudC5cbiAgICAgICAgICAgICdDJywgY3ggKyByeCwgY3kgKyBjZHksIGN4ICsgY2R4LCBjeSArIHJ5LCBjeCwgY3kgKyByeSwgLy8gSUkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCAtIGNkeCwgY3kgKyByeSwgY3ggLSByeCwgY3kgKyBjZHksIGN4IC0gcngsIGN5LCAvLyBJSUkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCAtIHJ4LCBjeSAtIGNkeSwgY3ggLSBjZHgsIGN5IC0gcnksIGN4LCBjeSAtIHJ5LCAvLyBJVi4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnWidcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICBWLmNvbnZlcnRSZWN0VG9QYXRoRGF0YSA9IGZ1bmN0aW9uKHJlY3QpIHtcblxuICAgICAgICByZWN0ID0gVihyZWN0KTtcblxuICAgICAgICByZXR1cm4gVi5yZWN0VG9QYXRoKHtcbiAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQocmVjdC5hdHRyKCd4JykpIHx8IDAsXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHJlY3QuYXR0cigneScpKSB8fCAwLFxuICAgICAgICAgICAgd2lkdGg6IHBhcnNlRmxvYXQocmVjdC5hdHRyKCd3aWR0aCcpKSB8fCAwLFxuICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHJlY3QuYXR0cignaGVpZ2h0JykpIHx8IDAsXG4gICAgICAgICAgICByeDogcGFyc2VGbG9hdChyZWN0LmF0dHIoJ3J4JykpIHx8IDAsXG4gICAgICAgICAgICByeTogcGFyc2VGbG9hdChyZWN0LmF0dHIoJ3J5JykpIHx8IDBcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgYSByZWN0YW5nbGUgdG8gU1ZHIHBhdGggY29tbWFuZHMuIGByYCBpcyBhbiBvYmplY3Qgb2YgdGhlIGZvcm06XG4gICAgLy8gYHsgeDogW251bWJlcl0sIHk6IFtudW1iZXJdLCB3aWR0aDogW251bWJlcl0sIGhlaWdodDogW251bWJlcl0sIHRvcC1yeTogW251bWJlcl0sIHRvcC1yeTogW251bWJlcl0sIGJvdHRvbS1yeDogW251bWJlcl0sIGJvdHRvbS1yeTogW251bWJlcl0gfWAsXG4gICAgLy8gd2hlcmUgYHgsIHksIHdpZHRoLCBoZWlnaHRgIGFyZSB0aGUgdXN1YWwgcmVjdGFuZ2xlIGF0dHJpYnV0ZXMgYW5kIFt0b3AtL2JvdHRvbS1dcngvcnkgYWxsb3dzIGZvclxuICAgIC8vIHNwZWNpZnlpbmcgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgZm9yIGFsbCBpdHMgc2lkZXMgKGFzIG9wcG9zZWQgdG8gdGhlIGJ1aWx0LWluIFNWRyByZWN0YW5nbGVcbiAgICAvLyB0aGF0IGhhcyBvbmx5IGByeGAgYW5kIGByeWAgYXR0cmlidXRlcykuXG4gICAgVi5yZWN0VG9QYXRoID0gZnVuY3Rpb24ocikge1xuXG4gICAgICAgIHZhciBkO1xuICAgICAgICB2YXIgeCA9IHIueDtcbiAgICAgICAgdmFyIHkgPSByLnk7XG4gICAgICAgIHZhciB3aWR0aCA9IHIud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSByLmhlaWdodDtcbiAgICAgICAgdmFyIHRvcFJ4ID0gbWluKHIucnggfHwgclsndG9wLXJ4J10gfHwgMCwgd2lkdGggLyAyKTtcbiAgICAgICAgdmFyIGJvdHRvbVJ4ID0gbWluKHIucnggfHwgclsnYm90dG9tLXJ4J10gfHwgMCwgd2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHRvcFJ5ID0gbWluKHIucnkgfHwgclsndG9wLXJ5J10gfHwgMCwgaGVpZ2h0IC8gMik7XG4gICAgICAgIHZhciBib3R0b21SeSA9IG1pbihyLnJ5IHx8IHJbJ2JvdHRvbS1yeSddIHx8IDAsIGhlaWdodCAvIDIpO1xuXG4gICAgICAgIGlmICh0b3BSeCB8fCBib3R0b21SeCB8fCB0b3BSeSB8fCBib3R0b21SeSkge1xuICAgICAgICAgICAgZCA9IFtcbiAgICAgICAgICAgICAgICAnTScsIHgsIHkgKyB0b3BSeSxcbiAgICAgICAgICAgICAgICAndicsIGhlaWdodCAtIHRvcFJ5IC0gYm90dG9tUnksXG4gICAgICAgICAgICAgICAgJ2EnLCBib3R0b21SeCwgYm90dG9tUnksIDAsIDAsIDAsIGJvdHRvbVJ4LCBib3R0b21SeSxcbiAgICAgICAgICAgICAgICAnaCcsIHdpZHRoIC0gMiAqIGJvdHRvbVJ4LFxuICAgICAgICAgICAgICAgICdhJywgYm90dG9tUngsIGJvdHRvbVJ5LCAwLCAwLCAwLCBib3R0b21SeCwgLWJvdHRvbVJ5LFxuICAgICAgICAgICAgICAgICd2JywgLShoZWlnaHQgLSBib3R0b21SeSAtIHRvcFJ5KSxcbiAgICAgICAgICAgICAgICAnYScsIHRvcFJ4LCB0b3BSeSwgMCwgMCwgMCwgLXRvcFJ4LCAtdG9wUnksXG4gICAgICAgICAgICAgICAgJ2gnLCAtKHdpZHRoIC0gMiAqIHRvcFJ4KSxcbiAgICAgICAgICAgICAgICAnYScsIHRvcFJ4LCB0b3BSeSwgMCwgMCwgMCwgLXRvcFJ4LCB0b3BSeSxcbiAgICAgICAgICAgICAgICAnWidcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gW1xuICAgICAgICAgICAgICAgICdNJywgeCwgeSxcbiAgICAgICAgICAgICAgICAnSCcsIHggKyB3aWR0aCxcbiAgICAgICAgICAgICAgICAnVicsIHkgKyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgJ0gnLCB4LFxuICAgICAgICAgICAgICAgICdWJywgeSxcbiAgICAgICAgICAgICAgICAnWidcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZC5qb2luKCcgJyk7XG4gICAgfTtcblxuICAgIC8vIFRha2UgYSBwYXRoIGRhdGEgc3RyaW5nXG4gICAgLy8gUmV0dXJuIGEgbm9ybWFsaXplZCBwYXRoIGRhdGEgc3RyaW5nXG4gICAgLy8gSWYgZGF0YSBjYW5ub3QgYmUgcGFyc2VkLCByZXR1cm4gJ00gMCAwJ1xuICAgIC8vIEhpZ2hseSBpbnNwaXJlZCBieSBSYXBoYWVsIExpYnJhcnkgKHd3dy5yYXBoYWVsLmNvbSlcbiAgICBWLm5vcm1hbGl6ZVBhdGhEYXRhID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzcGFjZXMgPSAnXFx4MDlcXHgwYVxceDBiXFx4MGNcXHgwZFxceDIwXFx4YTBcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1MjAyOFxcdTIwMjknO1xuICAgICAgICB2YXIgcGF0aENvbW1hbmQgPSBuZXcgUmVnRXhwKCcoW2Etel0pWycgKyBzcGFjZXMgKyAnLF0qKCgtP1xcXFxkKlxcXFwuP1xcXFxkKig/OmVbXFxcXC0rXT9cXFxcZCspP1snICsgc3BhY2VzICsgJ10qLD9bJyArIHNwYWNlcyArICddKikrKScsICdpZycpO1xuICAgICAgICB2YXIgcGF0aFZhbHVlcyA9IG5ldyBSZWdFeHAoJygtP1xcXFxkKlxcXFwuP1xcXFxkKig/OmVbXFxcXC0rXT9cXFxcZCspPylbJyArIHNwYWNlcyArICddKiw/WycgKyBzcGFjZXMgKyAnXSonLCAnaWcnKTtcblxuICAgICAgICB2YXIgbWF0aCA9IE1hdGg7XG4gICAgICAgIHZhciBQSSA9IG1hdGguUEk7XG4gICAgICAgIHZhciBzaW4gPSBtYXRoLnNpbjtcbiAgICAgICAgdmFyIGNvcyA9IG1hdGguY29zO1xuICAgICAgICB2YXIgdGFuID0gbWF0aC50YW47XG4gICAgICAgIHZhciBhc2luID0gbWF0aC5hc2luO1xuICAgICAgICB2YXIgc3FydCA9IG1hdGguc3FydDtcbiAgICAgICAgdmFyIGFicyA9IG1hdGguYWJzO1xuXG4gICAgICAgIGZ1bmN0aW9uIHEyYyh4MSwgeTEsIGF4LCBheSwgeDIsIHkyKSB7XG5cbiAgICAgICAgICAgIHZhciBfMTMgPSAxIC8gMztcbiAgICAgICAgICAgIHZhciBfMjMgPSAyIC8gMztcbiAgICAgICAgICAgIHJldHVybiBbKF8xMyAqIHgxKSArIChfMjMgKiBheCksIChfMTMgKiB5MSkgKyAoXzIzICogYXkpLCAoXzEzICogeDIpICsgKF8yMyAqIGF4KSwgKF8xMyAqIHkyKSArIChfMjMgKiBheSksIHgyLCB5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByb3RhdGUoeCwgeSwgcmFkKSB7XG5cbiAgICAgICAgICAgIHZhciBYID0gKHggKiBjb3MocmFkKSkgLSAoeSAqIHNpbihyYWQpKTtcbiAgICAgICAgICAgIHZhciBZID0gKHggKiBzaW4ocmFkKSkgKyAoeSAqIGNvcyhyYWQpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGEyYyh4MSwgeTEsIHJ4LCByeSwgYW5nbGUsIGxhcmdlX2FyY19mbGFnLCBzd2VlcF9mbGFnLCB4MiwgeTIsIHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgLy8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb2Ygd2hlcmUgdGhpcyBtYXRoIGNhbWUgZnJvbSB2aXNpdDpcbiAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgICAgICAgdmFyIF8xMjAgPSAoUEkgKiAxMjApIC8gMTgwO1xuICAgICAgICAgICAgdmFyIHJhZCA9IChQSSAvIDE4MCkgKiAoK2FuZ2xlIHx8IDApO1xuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHh5O1xuXG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIHh5ID0gcm90YXRlKHgxLCB5MSwgLXJhZCk7XG4gICAgICAgICAgICAgICAgeDEgPSB4eS54O1xuICAgICAgICAgICAgICAgIHkxID0geHkueTtcblxuICAgICAgICAgICAgICAgIHh5ID0gcm90YXRlKHgyLCB5MiwgLXJhZCk7XG4gICAgICAgICAgICAgICAgeDIgPSB4eS54O1xuICAgICAgICAgICAgICAgIHkyID0geHkueTtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gKHgxIC0geDIpIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgeSA9ICh5MSAtIHkyKSAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIGggPSAoKHggKiB4KSAvIChyeCAqIHJ4KSkgKyAoKHkgKiB5KSAvIChyeSAqIHJ5KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNxcnQoaCk7XG4gICAgICAgICAgICAgICAgICAgIHJ4ID0gaCAqIHJ4O1xuICAgICAgICAgICAgICAgICAgICByeSA9IGggKiByeTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcngyID0gcnggKiByeDtcbiAgICAgICAgICAgICAgICB2YXIgcnkyID0gcnkgKiByeTtcblxuICAgICAgICAgICAgICAgIHZhciBrID0gKChsYXJnZV9hcmNfZmxhZyA9PSBzd2VlcF9mbGFnKSA/IC0xIDogMSkgKiBzcXJ0KGFicygoKHJ4MiAqIHJ5MikgLSAocngyICogeSAqIHkpIC0gKHJ5MiAqIHggKiB4KSkgLyAoKHJ4MiAqIHkgKiB5KSArIChyeTIgKiB4ICogeCkpKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJjIGlzIGEgc2luZ2xlIHBvaW50XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTIsIHgyLCB5Ml07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGN4ID0gKChrICogcnggKiB5KSAvIHJ5KSArICgoeDEgKyB4MikgLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSAoKGsgKiAtcnkgKiB4KSAvIHJ4KSArICgoeTEgKyB5MikgLyAyKTtcblxuICAgICAgICAgICAgICAgIHZhciBmMSA9IGFzaW4oKCh5MSAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcbiAgICAgICAgICAgICAgICB2YXIgZjIgPSBhc2luKCgoeTIgLSBjeSkgLyByeSkudG9GaXhlZCg5KSk7XG5cbiAgICAgICAgICAgICAgICBmMSA9ICgoeDEgPCBjeCkgPyAoUEkgLSBmMSkgOiBmMSk7XG4gICAgICAgICAgICAgICAgZjIgPSAoKHgyIDwgY3gpID8gKFBJIC0gZjIpIDogZjIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGYxIDwgMCkgZjEgPSAoUEkgKiAyKSArIGYxO1xuICAgICAgICAgICAgICAgIGlmIChmMiA8IDApIGYyID0gKFBJICogMikgKyBmMjtcblxuICAgICAgICAgICAgICAgIGlmIChzd2VlcF9mbGFnICYmIChmMSA+IGYyKSkgZjEgPSBmMSAtIChQSSAqIDIpO1xuICAgICAgICAgICAgICAgIGlmICghc3dlZXBfZmxhZyAmJiAoZjIgPiBmMSkpIGYyID0gZjIgLSAoUEkgKiAyKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmMSA9IHJlY3Vyc2l2ZVswXTtcbiAgICAgICAgICAgICAgICBmMiA9IHJlY3Vyc2l2ZVsxXTtcbiAgICAgICAgICAgICAgICBjeCA9IHJlY3Vyc2l2ZVsyXTtcbiAgICAgICAgICAgICAgICBjeSA9IHJlY3Vyc2l2ZVszXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRmID0gZjIgLSBmMTtcbiAgICAgICAgICAgIGlmIChhYnMoZGYpID4gXzEyMCkge1xuICAgICAgICAgICAgICAgIHZhciBmMm9sZCA9IGYyO1xuICAgICAgICAgICAgICAgIHZhciB4Mm9sZCA9IHgyO1xuICAgICAgICAgICAgICAgIHZhciB5Mm9sZCA9IHkyO1xuICAgICAgICAgICAgICAgIGYyID0gZjEgKyAoXzEyMCAqICgoc3dlZXBfZmxhZyAmJiAoZjIgPiBmMSkpID8gMSA6IC0xKSk7XG4gICAgICAgICAgICAgICAgeDIgPSBjeCArIChyeCAqIGNvcyhmMikpO1xuICAgICAgICAgICAgICAgIHkyID0gY3kgKyAocnkgKiBzaW4oZjIpKTtcbiAgICAgICAgICAgICAgICByZXMgPSBhMmMoeDIsIHkyLCByeCwgcnksIGFuZ2xlLCAwLCBzd2VlcF9mbGFnLCB4Mm9sZCwgeTJvbGQsIFtmMiwgZjJvbGQsIGN4LCBjeV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZiA9IGYyIC0gZjE7XG5cbiAgICAgICAgICAgIHZhciBjMSA9IGNvcyhmMSk7XG4gICAgICAgICAgICB2YXIgczEgPSBzaW4oZjEpO1xuICAgICAgICAgICAgdmFyIGMyID0gY29zKGYyKTtcbiAgICAgICAgICAgIHZhciBzMiA9IHNpbihmMik7XG4gICAgICAgICAgICB2YXIgdCA9IHRhbihkZiAvIDQpO1xuICAgICAgICAgICAgdmFyIGh4ID0gKDQgLyAzKSAqIChyeCAqIHQpO1xuICAgICAgICAgICAgdmFyIGh5ID0gKDQgLyAzKSAqIChyeSAqIHQpO1xuICAgICAgICAgICAgdmFyIG0xID0gW3gxLCB5MV07XG4gICAgICAgICAgICB2YXIgbTIgPSBbeDEgKyAoaHggKiBzMSksIHkxIC0gKGh5ICogYzEpXTtcbiAgICAgICAgICAgIHZhciBtMyA9IFt4MiArIChoeCAqIHMyKSwgeTIgLSAoaHkgKiBjMildO1xuICAgICAgICAgICAgdmFyIG00ID0gW3gyLCB5Ml07XG5cbiAgICAgICAgICAgIG0yWzBdID0gKDIgKiBtMVswXSkgLSBtMlswXTtcbiAgICAgICAgICAgIG0yWzFdID0gKDIgKiBtMVsxXSkgLSBtMlsxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbbTIsIG0zLCBtNF0uY29uY2F0KHJlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcyA9IFttMiwgbTMsIG00XS5jb25jYXQocmVzKS5qb2luKCkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3cmVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGlpID0gcmVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3cmVzW2ldID0gKGkgJSAyKSA/IHJvdGF0ZShyZXNbaSAtIDFdLCByZXNbaV0sIHJhZCkueSA6IHJvdGF0ZShyZXNbaV0sIHJlc1tpICsgMV0sIHJhZCkueDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld3JlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlUGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG5cbiAgICAgICAgICAgIGlmICghcGF0aFN0cmluZykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbUNvdW50cyA9IHsgYTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMCB9O1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBbXTtcblxuICAgICAgICAgICAgU3RyaW5nKHBhdGhTdHJpbmcpLnJlcGxhY2UocGF0aENvbW1hbmQsIGZ1bmN0aW9uKGEsIGIsIGMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjLnJlcGxhY2UocGF0aFZhbHVlcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYikgcGFyYW1zLnB1c2goK2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKChuYW1lID09PSAnbScpICYmIChwYXJhbXMubGVuZ3RoID4gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKFtiXS5jb25jYXQocGFyYW1zLnNwbGljZSgwLCAyKSkpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICBiID0gKChiID09PSAnbScpID8gJ2wnIDogJ0wnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyYW1zLmxlbmd0aCA+PSBwYXJhbUNvdW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIHBhcmFtQ291bnRzW25hbWVdKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtQ291bnRzW25hbWVdKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXRoVG9BYnNvbHV0ZShwYXRoQXJyYXkpIHtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhBcnJheSkgfHwgIUFycmF5LmlzQXJyYXkocGF0aEFycmF5ICYmIHBhdGhBcnJheVswXSkpIHsgLy8gcm91Z2ggYXNzdW1wdGlvblxuICAgICAgICAgICAgICAgIHBhdGhBcnJheSA9IHBhcnNlUGF0aFN0cmluZyhwYXRoQXJyYXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpbnZhbGlkIHN0cmluZywgcmV0dXJuICdNIDAgMCdcbiAgICAgICAgICAgIGlmICghcGF0aEFycmF5IHx8ICFwYXRoQXJyYXkubGVuZ3RoKSByZXR1cm4gW1snTScsIDAsIDBdXTtcblxuICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICAgICAgdmFyIG14ID0gMDtcbiAgICAgICAgICAgIHZhciBteSA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICAgICAgdmFyIHBhMDtcblxuICAgICAgICAgICAgdmFyIGlpID0gcGF0aEFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGlpOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciByID0gW107XG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocik7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGEgPSBwYXRoQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgcGEwID0gcGFbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAocGEwICE9IHBhMC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJbMF0gPSBwYTAudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgamo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSBwYVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzJdID0gcGFbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclszXSA9IHBhWzNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNF0gPSBwYVs0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzVdID0gcGFbNV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls2XSA9ICtwYVs2XSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls3XSA9ICtwYVs3XSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzFdID0gK3BhWzFdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXggPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gK3BhWzJdICsgeTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpqID0gcGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDE7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbal0gPSArcGFbal0gKyAoKGogJSAyKSA/IHggOiB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgamogPSBwYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICtwYVtqXSArICgoaiAlIDIpID8geCA6IHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrayA9IHBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrazsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByW2tdID0gcGFba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gK214O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9ICtteTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBteCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15ID0gcltyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHJbci5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuXG4gICAgICAgICAgICB2YXIgcCA9IHBhdGhUb0Fic29sdXRlKHBhdGgpO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0geyB4OiAwLCB5OiAwLCBieDogMCwgYnk6IDAsIFg6IDAsIFk6IDAsIHF4OiBudWxsLCBxeTogbnVsbCB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9jZXNzUGF0aChwYXRoLCBkLCBwY29tKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbngsIG55O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gWydDJywgZC54LCBkLnksIGQueCwgZC55LCBkLngsIGQueV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIShwYXRoWzBdIGluIHsgVDogMSwgUTogMSB9KSkge1xuICAgICAgICAgICAgICAgICAgICBkLnF4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZC5xeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAgZC5YID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuWSA9IHBhdGhbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHBhdGhbMV0pID09PSAwIHx8IHBhcnNlRmxvYXQocGF0aFsyXSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjQXJjT3V0T2ZSYW5nZVBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcIklmIGVpdGhlciByeCBvciByeSBpcyAwLCB0aGVuIHRoaXMgYXJjIGlzIHRyZWF0ZWQgYXMgYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmFpZ2h0IGxpbmUgc2VnbWVudCAoYSBcImxpbmV0b1wiKSBqb2luaW5nIHRoZSBlbmRwb2ludHMuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydMJywgcGF0aFs2XSwgcGF0aFs3XV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQoYTJjLmFwcGx5KDAsIFtkLngsIGQueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09PSAnQycgfHwgcGNvbSA9PT0gJ1MnKSB7IC8vIEluICdTJyBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIEMvUy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBueCA9IChkLnggKiAyKSAtIGQuYng7ICAgICAgICAgIC8vIEFuZCByZWZsZWN0IHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG55ID0gKGQueSAqIDIpIC0gZC5ieTsgICAgICAgICAgLy8gY29tbWFuZCdzIGNvbnRyb2wgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21lIGVsc2Ugb3Igbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG54ID0gZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG55ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnQycsIG54LCBueV0uY29uY2F0KHBhdGguc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGNvbSA9PT0gJ1EnIHx8IHBjb20gPT09ICdUJykgeyAvLyBJbiAnVCcgY2FzZSB3ZSBoYXZlIHRvIHRha2UgaW50byBhY2NvdW50LCBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCBpcyBRL1QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IChkLnggKiAyKSAtIGQucXg7ICAgICAgICAvLyBBbmQgbWFrZSBhIHJlZmxlY3Rpb24gc2ltaWxhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSAoZC55ICogMikgLSBkLnF5OyAgICAgICAgLy8gdG8gY2FzZSAnUycuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBzb21ldGhpbmcgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IGQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gZC55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxMmMoZC54LCBkLnksIGQucXgsIGQucXksIHBhdGhbMV0sIHBhdGhbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZC5xeCA9IHBhdGhbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF5ID0gcGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0MnXS5jb25jYXQocTJjKGQueCwgZC55LCBwYXRoWzFdLCBwYXRoWzJdLCBwYXRoWzNdLCBwYXRoWzRdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0wnXS5jb25jYXQocGF0aFsxXSwgZC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnTCddLmNvbmNhdChkLngsIHBhdGhbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBmaXhBcmMocHAsIGkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwcFtpXS5sZW5ndGggPiA3KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHBbaV0uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpID0gcHBbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGNvbXNbaV0gPSAnQSc7IC8vIGlmIGNyZWF0ZWQgbXVsdGlwbGUgJ0MncywgdGhlaXIgb3JpZ2luYWwgc2VnIGlzIHNhdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSsrLCAwLCBbJ0MnXS5jb25jYXQocGkuc3BsaWNlKDAsIDYpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlpID0gcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGNvbXMgPSBbXTsgLy8gcGF0aCBjb21tYW5kcyBvZiBvcmlnaW5hbCBwYXRoIHBcbiAgICAgICAgICAgIHZhciBwZmlyc3QgPSAnJzsgLy8gdGVtcG9yYXJ5IGhvbGRlciBmb3Igb3JpZ2luYWwgcGF0aCBjb21tYW5kXG4gICAgICAgICAgICB2YXIgcGNvbSA9ICcnOyAvLyBob2xkZXIgZm9yIHByZXZpb3VzIHBhdGggY29tbWFuZCBvZiBvcmlnaW5hbCBwYXRoXG5cbiAgICAgICAgICAgIHZhciBpaSA9IHAubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBbaV0pIHBmaXJzdCA9IHBbaV1bMF07IC8vIHNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcblxuICAgICAgICAgICAgICAgIGlmIChwZmlyc3QgIT09ICdDJykgeyAvLyBDIGlzIG5vdCBzYXZlZCB5ZXQsIGJlY2F1c2UgaXQgbWF5IGJlIHJlc3VsdCBvZiBjb252ZXJzaW9uXG4gICAgICAgICAgICAgICAgICAgIHBjb21zW2ldID0gcGZpcnN0OyAvLyBTYXZlIGN1cnJlbnQgcGF0aCBjb21tYW5kXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkgcGNvbSA9IHBjb21zW2kgLSAxXTsgLy8gR2V0IHByZXZpb3VzIHBhdGggY29tbWFuZCBwY29tXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcFtpXSA9IHByb2Nlc3NQYXRoKHBbaV0sIGF0dHJzLCBwY29tKTsgLy8gUHJldmlvdXMgcGF0aCBjb21tYW5kIGlzIGlucHV0dGVkIHRvIHByb2Nlc3NQYXRoXG5cbiAgICAgICAgICAgICAgICBpZiAocGNvbXNbaV0gIT09ICdBJyAmJiBwZmlyc3QgPT09ICdDJykgcGNvbXNbaV0gPSAnQyc7IC8vICdBJyBpcyB0aGUgb25seSBjb21tYW5kXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggbWF5IHByb2R1Y2UgbXVsdGlwbGUgJ0Mnc1xuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgJ0MnIGlzIGFsc28gJ0MnIGluIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgICAgIGZpeEFyYyhwLCBpKTsgLy8gZml4QXJjIGFkZHMgYWxzbyB0aGUgcmlnaHQgYW1vdW50IG9mICdBJ3MgdG8gcGNvbXNcblxuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBwW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZWdsZW4gPSBzZWcubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgYXR0cnMueCA9IHNlZ1tzZWdsZW4gLSAyXTtcbiAgICAgICAgICAgICAgICBhdHRycy55ID0gc2VnW3NlZ2xlbiAtIDFdO1xuXG4gICAgICAgICAgICAgICAgYXR0cnMuYnggPSBwYXJzZUZsb2F0KHNlZ1tzZWdsZW4gLSA0XSkgfHwgYXR0cnMueDtcbiAgICAgICAgICAgICAgICBhdHRycy5ieSA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDNdKSB8fCBhdHRycy55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgbm9ybWFsaXplZCBwYXRoIGRhdGEgc3RyaW5nIHN0YXJ0cyB3aXRoIGFuIE0gc2VnbWVudFxuICAgICAgICAgICAgaWYgKCFwWzBdWzBdIHx8IHBbMF1bMF0gIT09ICdNJykge1xuICAgICAgICAgICAgICAgIHAudW5zaGlmdChbJ00nLCAwLCAwXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKHBhdGhEYXRhKS5qb2luKCcsJykuc3BsaXQoJywnKS5qb2luKCcgJyk7XG4gICAgICAgIH07XG4gICAgfSkoKTtcblxuICAgIFYubmFtZXNwYWNlID0gbnM7XG5cbiAgICBWLmcgPSBnO1xuXG4gICAgcmV0dXJuIFY7XG5cbn0pKCk7XG5cbmV4cG9ydCBkZWZhdWx0IFY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/V/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/anchors/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/anchors/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   bottomLeft: () => (/* binding */ bottomLeft),\n/* harmony export */   bottomRight: () => (/* binding */ bottomRight),\n/* harmony export */   center: () => (/* binding */ center),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   midSide: () => (/* binding */ midSide),\n/* harmony export */   modelCenter: () => (/* binding */ modelCenter),\n/* harmony export */   perpendicular: () => (/* binding */ perpendicular),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   top: () => (/* binding */ top),\n/* harmony export */   topLeft: () => (/* binding */ topLeft),\n/* harmony export */   topRight: () => (/* binding */ topRight)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../linkAnchors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n\n\n\n\nfunction bboxWrapper(method) {\n\n    return function(view, magnet, ref, opt) {\n\n        var rotate = !!opt.rotate;\n        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n\n        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n\n    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n        var dy = (refPoint.y - anchor.y);\n        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toRad)(angle));\n        anchor.y += dy;\n    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n        var dx = (refPoint.x - anchor.x);\n        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toRad)(angle));\n        anchor.x += dx;\n    }\n\n    return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n\n    if (rotate) refPoint.rotate(center, angle);\n\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch (side) {\n        case 'left':\n            anchor = bbox.leftMiddle();\n            break;\n        case 'right':\n            anchor = bbox.rightMiddle();\n            break;\n        case 'top':\n            anchor = bbox.topMiddle();\n            break;\n        case 'bottom':\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n\n    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nconst center = bboxWrapper('center');\nconst top = bboxWrapper('topMiddle');\nconst bottom = bboxWrapper('bottomMiddle');\nconst left = bboxWrapper('leftMiddle');\nconst right = bboxWrapper('rightMiddle');\nconst topLeft = bboxWrapper('origin');\nconst topRight = bboxWrapper('topRight');\nconst bottomLeft = bboxWrapper('bottomLeft');\nconst bottomRight = bboxWrapper('corner');\nconst perpendicular = (0,_linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveRef)(_perpendicular);\nconst midSide = (0,_linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveRef)(_midSide);\nconst modelCenter = _modelCenter;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2FuY2hvcnMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNIO0FBQ2U7O0FBRXREOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQix5REFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRSxtREFBSztBQUNoRjtBQUNBLE1BQU07QUFDTjtBQUNBLHdFQUF3RSxtREFBSztBQUM3RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0VBQVU7QUFDaEMsZ0JBQWdCLGtFQUFVO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvYW5jaG9ycy9pbmRleC5tanM/ZGE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IHRvUmFkIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVJlZiB9IGZyb20gJy4uL2xpbmtBbmNob3JzL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIGJib3hXcmFwcGVyKG1ldGhvZCkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIG1hZ25ldCwgcmVmLCBvcHQpIHtcblxuICAgICAgICB2YXIgcm90YXRlID0gISFvcHQucm90YXRlO1xuICAgICAgICB2YXIgYmJveCA9IChyb3RhdGUpID8gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpIDogdmlldy5nZXROb2RlQkJveChtYWduZXQpO1xuICAgICAgICB2YXIgYW5jaG9yID0gYmJveFttZXRob2RdKCk7XG5cbiAgICAgICAgdmFyIGR4ID0gb3B0LmR4O1xuICAgICAgICBpZiAoZHgpIHtcbiAgICAgICAgICAgIHZhciBkeFBlcmNlbnRhZ2UgPSB1dGlsLmlzUGVyY2VudGFnZShkeCk7XG4gICAgICAgICAgICBkeCA9IHBhcnNlRmxvYXQoZHgpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGR4KSkge1xuICAgICAgICAgICAgICAgIGlmIChkeFBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZHggLz0gMTAwO1xuICAgICAgICAgICAgICAgICAgICBkeCAqPSBiYm94LndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmNob3IueCArPSBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeSA9IG9wdC5keTtcbiAgICAgICAgaWYgKGR5KSB7XG4gICAgICAgICAgICB2YXIgZHlQZXJjZW50YWdlID0gdXRpbC5pc1BlcmNlbnRhZ2UoZHkpO1xuICAgICAgICAgICAgZHkgPSBwYXJzZUZsb2F0KGR5KTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHlQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGR5IC89IDEwMDtcbiAgICAgICAgICAgICAgICAgICAgZHkgKj0gYmJveC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2hvci55ICs9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChyb3RhdGUpID8gYW5jaG9yLnJvdGF0ZSh2aWV3Lm1vZGVsLmdldEJCb3goKS5jZW50ZXIoKSwgLXZpZXcubW9kZWwuYW5nbGUoKSkgOiBhbmNob3I7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gX3BlcnBlbmRpY3VsYXIodmlldywgbWFnbmV0LCByZWZQb2ludCwgb3B0KSB7XG5cbiAgICB2YXIgYW5nbGUgPSB2aWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgdmFyIGJib3ggPSB2aWV3LmdldE5vZGVCQm94KG1hZ25ldCk7XG4gICAgdmFyIGFuY2hvciA9IGJib3guY2VudGVyKCk7XG4gICAgdmFyIHRvcExlZnQgPSBiYm94Lm9yaWdpbigpO1xuICAgIHZhciBib3R0b21SaWdodCA9IGJib3guY29ybmVyKCk7XG5cbiAgICB2YXIgcGFkZGluZyA9IG9wdC5wYWRkaW5nO1xuICAgIGlmICghaXNGaW5pdGUocGFkZGluZykpIHBhZGRpbmcgPSAwO1xuXG4gICAgaWYgKCh0b3BMZWZ0LnkgKyBwYWRkaW5nKSA8PSByZWZQb2ludC55ICYmIHJlZlBvaW50LnkgPD0gKGJvdHRvbVJpZ2h0LnkgLSBwYWRkaW5nKSkge1xuICAgICAgICB2YXIgZHkgPSAocmVmUG9pbnQueSAtIGFuY2hvci55KTtcbiAgICAgICAgYW5jaG9yLnggKz0gKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApID8gMCA6IGR5ICogMSAvIE1hdGgudGFuKHRvUmFkKGFuZ2xlKSk7XG4gICAgICAgIGFuY2hvci55ICs9IGR5O1xuICAgIH0gZWxzZSBpZiAoKHRvcExlZnQueCArIHBhZGRpbmcpIDw9IHJlZlBvaW50LnggJiYgcmVmUG9pbnQueCA8PSAoYm90dG9tUmlnaHQueCAtIHBhZGRpbmcpKSB7XG4gICAgICAgIHZhciBkeCA9IChyZWZQb2ludC54IC0gYW5jaG9yLngpO1xuICAgICAgICBhbmNob3IueSArPSAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApID8gMCA6IGR4ICogTWF0aC50YW4odG9SYWQoYW5nbGUpKTtcbiAgICAgICAgYW5jaG9yLnggKz0gZHg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2hvcjtcbn1cblxuZnVuY3Rpb24gX21pZFNpZGUodmlldywgbWFnbmV0LCByZWZQb2ludCwgb3B0KSB7XG5cbiAgICB2YXIgcm90YXRlID0gISFvcHQucm90YXRlO1xuICAgIHZhciBiYm94LCBhbmdsZSwgY2VudGVyO1xuICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgYmJveCA9IHZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobWFnbmV0KTtcbiAgICAgICAgY2VudGVyID0gdmlldy5tb2RlbC5nZXRCQm94KCkuY2VudGVyKCk7XG4gICAgICAgIGFuZ2xlID0gdmlldy5tb2RlbC5hbmdsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJib3ggPSB2aWV3LmdldE5vZGVCQm94KG1hZ25ldCk7XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSBvcHQucGFkZGluZztcbiAgICBpZiAoaXNGaW5pdGUocGFkZGluZykpIGJib3guaW5mbGF0ZShwYWRkaW5nKTtcblxuICAgIGlmIChyb3RhdGUpIHJlZlBvaW50LnJvdGF0ZShjZW50ZXIsIGFuZ2xlKTtcblxuICAgIHZhciBzaWRlID0gYmJveC5zaWRlTmVhcmVzdFRvUG9pbnQocmVmUG9pbnQpO1xuICAgIHZhciBhbmNob3I7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgYW5jaG9yID0gYmJveC5sZWZ0TWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgYW5jaG9yID0gYmJveC5yaWdodE1pZGRsZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBhbmNob3IgPSBiYm94LnRvcE1pZGRsZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBhbmNob3IgPSBiYm94LmJvdHRvbU1pZGRsZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIChyb3RhdGUpID8gYW5jaG9yLnJvdGF0ZShjZW50ZXIsIC1hbmdsZSkgOiBhbmNob3I7XG59XG5cbi8vIENhbiBmaW5kIGFuY2hvciBmcm9tIG1vZGVsLCB3aGVuIHRoZXJlIGlzIG5vIHNlbGVjdG9yIG9yIHRoZSBsaW5rIGVuZFxuLy8gaXMgY29ubmVjdGVkIHRvIGEgcG9ydFxuZnVuY3Rpb24gX21vZGVsQ2VudGVyKHZpZXcsIF9tYWduZXQsIF9yZWZQb2ludCwgb3B0LCBlbmRUeXBlKSB7XG4gICAgcmV0dXJuIHZpZXcubW9kZWwuZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluayh0aGlzLm1vZGVsLCBlbmRUeXBlKS5vZmZzZXQob3B0LmR4LCBvcHQuZHkpO1xufVxuXG4vL2pvaW50LmFuY2hvcnNcbmV4cG9ydCBjb25zdCBjZW50ZXIgPSBiYm94V3JhcHBlcignY2VudGVyJyk7XG5leHBvcnQgY29uc3QgdG9wID0gYmJveFdyYXBwZXIoJ3RvcE1pZGRsZScpO1xuZXhwb3J0IGNvbnN0IGJvdHRvbSA9IGJib3hXcmFwcGVyKCdib3R0b21NaWRkbGUnKTtcbmV4cG9ydCBjb25zdCBsZWZ0ID0gYmJveFdyYXBwZXIoJ2xlZnRNaWRkbGUnKTtcbmV4cG9ydCBjb25zdCByaWdodCA9IGJib3hXcmFwcGVyKCdyaWdodE1pZGRsZScpO1xuZXhwb3J0IGNvbnN0IHRvcExlZnQgPSBiYm94V3JhcHBlcignb3JpZ2luJyk7XG5leHBvcnQgY29uc3QgdG9wUmlnaHQgPSBiYm94V3JhcHBlcigndG9wUmlnaHQnKTtcbmV4cG9ydCBjb25zdCBib3R0b21MZWZ0ID0gYmJveFdyYXBwZXIoJ2JvdHRvbUxlZnQnKTtcbmV4cG9ydCBjb25zdCBib3R0b21SaWdodCA9IGJib3hXcmFwcGVyKCdjb3JuZXInKTtcbmV4cG9ydCBjb25zdCBwZXJwZW5kaWN1bGFyID0gcmVzb2x2ZVJlZihfcGVycGVuZGljdWxhcik7XG5leHBvcnQgY29uc3QgbWlkU2lkZSA9IHJlc29sdmVSZWYoX21pZFNpZGUpO1xuZXhwb3J0IGNvbnN0IG1vZGVsQ2VudGVyID0gX21vZGVsQ2VudGVyO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/anchors/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/cellTools/Boundary.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Boundary.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Boundary: () => (/* binding */ Boundary)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\nconst Boundary = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    name: 'boundary',\n    tagName: 'rect',\n    options: {\n        padding: 10,\n        useModelGeometry: false,\n    },\n    attributes: {\n        'fill': 'none',\n        'stroke': '#33334F',\n        'stroke-width': .5,\n        'stroke-dasharray': '5, 5',\n        'pointer-events': 'none'\n    },\n    onRender: function() {\n        this.update();\n    },\n    update: function() {\n        const { relatedView: view, options, vel } = this;\n        const { useModelGeometry, rotate } = options;\n        const padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeSides(options.padding);\n        let bbox = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getViewBBox)(view, useModelGeometry).moveAndExpand({\n            x: -padding.left,\n            y: -padding.top,\n            width: padding.left + padding.right,\n            height: padding.top + padding.bottom\n        });\n        var model = view.model;\n        if (model.isElement()) {\n            var angle = model.angle();\n            if (angle) {\n                if (rotate) {\n                    var origin = model.getBBox().center();\n                    vel.rotate(angle, origin.x, origin.y, { absolute: true });\n                } else {\n                    bbox = bbox.bbox(angle);\n                }\n            }\n        }\n        vel.attr(bbox.toJSON());\n        return this;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9Cb3VuZGFyeS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDMEM7QUFDSztBQUNIOztBQUVyQyxpQkFBaUIsdURBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQsZ0JBQWdCLDJCQUEyQjtBQUMzQyx3QkFBd0IsMkRBQW1CO0FBQzNDLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jZWxsVG9vbHMvQm91bmRhcnkubWpzPzg2ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFRvb2xWaWV3IH0gZnJvbSAnLi4vZGlhL1Rvb2xWaWV3Lm1qcyc7XG5pbXBvcnQgeyBnZXRWaWV3QkJveCB9IGZyb20gJy4vaGVscGVycy5tanMnO1xuXG5leHBvcnQgY29uc3QgQm91bmRhcnkgPSBUb29sVmlldy5leHRlbmQoe1xuICAgIG5hbWU6ICdib3VuZGFyeScsXG4gICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzogMTAsXG4gICAgICAgIHVzZU1vZGVsR2VvbWV0cnk6IGZhbHNlLFxuICAgIH0sXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgJ3N0cm9rZSc6ICcjMzMzMzRGJyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IC41LFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICc1LCA1JyxcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3OiB2aWV3LCBvcHRpb25zLCB2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdXNlTW9kZWxHZW9tZXRyeSwgcm90YXRlIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdXRpbC5ub3JtYWxpemVTaWRlcyhvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgICBsZXQgYmJveCA9IGdldFZpZXdCQm94KHZpZXcsIHVzZU1vZGVsR2VvbWV0cnkpLm1vdmVBbmRFeHBhbmQoe1xuICAgICAgICAgICAgeDogLXBhZGRpbmcubGVmdCxcbiAgICAgICAgICAgIHk6IC1wYWRkaW5nLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0OiBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICBpZiAobW9kZWwuaXNFbGVtZW50KCkpIHtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IG1vZGVsLmFuZ2xlKCk7XG4gICAgICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBtb2RlbC5nZXRCQm94KCkuY2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHZlbC5yb3RhdGUoYW5nbGUsIG9yaWdpbi54LCBvcmlnaW4ueSwgeyBhYnNvbHV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYm94ID0gYmJveC5iYm94KGFuZ2xlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmVsLmF0dHIoYmJveC50b0pTT04oKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/cellTools/Boundary.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/cellTools/Button.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Button.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: () => (/* binding */ Button),\n/* harmony export */   Remove: () => (/* binding */ Remove)\n/* harmony export */ });\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\n\n\nconst Button = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    name: 'button',\n    events: {\n        'mousedown': 'onPointerDown',\n        'touchstart': 'onPointerDown'\n    },\n    options: {\n        distance: 0,\n        offset: 0,\n        scale: null,\n        rotate: false\n    },\n    onRender: function() {\n        this.renderChildren(this.options.markup);\n        this.update();\n    },\n    update: function() {\n        this.position();\n        return this;\n    },\n    position: function() {\n        const { vel } = this;\n        vel.transform(this.getCellMatrix(), { absolute: true });\n    },\n    getCellMatrix() {\n        return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n    },\n    getElementMatrix() {\n        const { relatedView: view, options } = this;\n        let { x = 0, y = 0, offset = {}, useModelGeometry, rotate, scale } = options;\n        let bbox = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.getViewBBox)(view, useModelGeometry);\n        const angle = view.model.angle();\n        if (!rotate) bbox = bbox.bbox(angle);\n        const { x: offsetX = 0, y: offsetY = 0 } = offset;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(x)) {\n            x = parseFloat(x) / 100 * bbox.width;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isCalcExpression(x)) {\n            x = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.evalCalcExpression(x, bbox));\n        }\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(y)) {\n            y = parseFloat(y) / 100 * bbox.height;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isCalcExpression(y)) {\n            y = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.evalCalcExpression(y, bbox));\n        }\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n        if (rotate) matrix = matrix.rotate(angle);\n        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n    getLinkMatrix() {\n        const { relatedView: view, options } = this;\n        const { offset = 0, distance: distanceOpt = 0, rotate, scale } = options;\n        const distance = (typeof distanceOpt === 'function')\n            ? distanceOpt.call(this, view, this)\n            : distanceOpt;\n        let tangent, position, angle;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(distance)) {\n            tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n        } else {\n            tangent = view.getTangentAtLength(distance);\n        }\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(1, 0)) || 0;\n        } else {\n            position = view.getConnection().start;\n            angle = 0;\n        }\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix()\n            .translate(position.x, position.y)\n            .rotate(angle)\n            .translate(0, offset);\n        if (!rotate) matrix = matrix.rotate(-angle);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var actionFn = this.options.action;\n        if (typeof actionFn === 'function') {\n            actionFn.call(this.relatedView, evt, this.relatedView, this);\n        }\n    }\n});\n\nconst Remove = Button.extend({\n    name: 'remove',\n    children: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#FF1D00',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -3 -3 3 3 M -3 3 3 -3',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    options: {\n        distance: 60,\n        offset: 0,\n        action: function(evt, view, tool) {\n            view.model.remove({ ui: true, tool: tool.cid });\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9CdXR0b24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStDO0FBQ0g7QUFDRjtBQUNOO0FBQ0w7O0FBRXhCLGVBQWUsdURBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsOENBQThDLGdCQUFnQjtBQUM5RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsY0FBYyx5QkFBeUIsb0NBQW9DO0FBQzNFLG1CQUFtQix5REFBVztBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRCxZQUFZLHlEQUFpQjtBQUM3QjtBQUNBLFVBQVUsU0FBUyw2REFBcUI7QUFDeEMsdUJBQXVCLCtEQUF1QjtBQUM5QztBQUNBLFlBQVkseURBQWlCO0FBQzdCO0FBQ0EsVUFBVSxTQUFTLDZEQUFxQjtBQUN4Qyx1QkFBdUIsK0RBQXVCO0FBQzlDO0FBQ0EscUJBQXFCLG9EQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0IsdURBQXVEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBaUI7QUFDN0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsK0NBQU87QUFDNUQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0J1dHRvbi5tanM/YzE5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUb29sVmlldyB9IGZyb20gJy4uL2RpYS9Ub29sVmlldy5tanMnO1xuaW1wb3J0IHsgZ2V0Vmlld0JCb3ggfSBmcm9tICcuL2hlbHBlcnMubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBCdXR0b24gPSBUb29sVmlldy5leHRlbmQoe1xuICAgIG5hbWU6ICdidXR0b24nLFxuICAgIGV2ZW50czoge1xuICAgICAgICAnbW91c2Vkb3duJzogJ29uUG9pbnRlckRvd24nLFxuICAgICAgICAndG91Y2hzdGFydCc6ICdvblBvaW50ZXJEb3duJ1xuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBzY2FsZTogbnVsbCxcbiAgICAgICAgcm90YXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKHRoaXMub3B0aW9ucy5tYXJrdXApO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyB2ZWwgfSA9IHRoaXM7XG4gICAgICAgIHZlbC50cmFuc2Zvcm0odGhpcy5nZXRDZWxsTWF0cml4KCksIHsgYWJzb2x1dGU6IHRydWUgfSk7XG4gICAgfSxcbiAgICBnZXRDZWxsTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGVkVmlldy5tb2RlbC5pc0xpbmsoKSA/IHRoaXMuZ2V0TGlua01hdHJpeCgpIDogdGhpcy5nZXRFbGVtZW50TWF0cml4KCk7XG4gICAgfSxcbiAgICBnZXRFbGVtZW50TWF0cml4KCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3OiB2aWV3LCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB4ID0gMCwgeSA9IDAsIG9mZnNldCA9IHt9LCB1c2VNb2RlbEdlb21ldHJ5LCByb3RhdGUsIHNjYWxlIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgYmJveCA9IGdldFZpZXdCQm94KHZpZXcsIHVzZU1vZGVsR2VvbWV0cnkpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKCFyb3RhdGUpIGJib3ggPSBiYm94LmJib3goYW5nbGUpO1xuICAgICAgICBjb25zdCB7IHg6IG9mZnNldFggPSAwLCB5OiBvZmZzZXRZID0gMCB9ID0gb2Zmc2V0O1xuICAgICAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoeCkpIHtcbiAgICAgICAgICAgIHggPSBwYXJzZUZsb2F0KHgpIC8gMTAwICogYmJveC53aWR0aDtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzQ2FsY0V4cHJlc3Npb24oeCkpIHtcbiAgICAgICAgICAgIHggPSBOdW1iZXIodXRpbC5ldmFsQ2FsY0V4cHJlc3Npb24oeCwgYmJveCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsLmlzUGVyY2VudGFnZSh5KSkge1xuICAgICAgICAgICAgeSA9IHBhcnNlRmxvYXQoeSkgLyAxMDAgKiBiYm94LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzQ2FsY0V4cHJlc3Npb24oeSkpIHtcbiAgICAgICAgICAgIHkgPSBOdW1iZXIodXRpbC5ldmFsQ2FsY0V4cHJlc3Npb24oeSwgYmJveCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShiYm94LnggKyBiYm94LndpZHRoIC8gMiwgYmJveC55ICsgYmJveC5oZWlnaHQgLyAyKTtcbiAgICAgICAgaWYgKHJvdGF0ZSkgbWF0cml4ID0gbWF0cml4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC50cmFuc2xhdGUoeCArIG9mZnNldFggLSBiYm94LndpZHRoIC8gMiwgeSArIG9mZnNldFkgLSBiYm94LmhlaWdodCAvIDIpO1xuICAgICAgICBpZiAoc2NhbGUpIG1hdHJpeCA9IG1hdHJpeC5zY2FsZShzY2FsZSk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcbiAgICBnZXRMaW5rTWF0cml4KCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3OiB2aWV3LCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9mZnNldCA9IDAsIGRpc3RhbmNlOiBkaXN0YW5jZU9wdCA9IDAsIHJvdGF0ZSwgc2NhbGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gKHR5cGVvZiBkaXN0YW5jZU9wdCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgID8gZGlzdGFuY2VPcHQuY2FsbCh0aGlzLCB2aWV3LCB0aGlzKVxuICAgICAgICAgICAgOiBkaXN0YW5jZU9wdDtcbiAgICAgICAgbGV0IHRhbmdlbnQsIHBvc2l0aW9uLCBhbmdsZTtcbiAgICAgICAgaWYgKHV0aWwuaXNQZXJjZW50YWdlKGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgdGFuZ2VudCA9IHZpZXcuZ2V0VGFuZ2VudEF0UmF0aW8ocGFyc2VGbG9hdChkaXN0YW5jZSkgLyAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFuZ2VudCA9IHZpZXcuZ2V0VGFuZ2VudEF0TGVuZ3RoKGRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFuZ2VudCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0YW5nZW50LnN0YXJ0O1xuICAgICAgICAgICAgYW5nbGUgPSB0YW5nZW50LnZlY3RvcigpLnZlY3RvckFuZ2xlKG5ldyBnLlBvaW50KDEsIDApKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB2aWV3LmdldENvbm5lY3Rpb24oKS5zdGFydDtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KVxuICAgICAgICAgICAgLnJvdGF0ZShhbmdsZSlcbiAgICAgICAgICAgIC50cmFuc2xhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFyb3RhdGUpIG1hdHJpeCA9IG1hdHJpeC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgaWYgKHNjYWxlKSBtYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG4gICAgb25Qb2ludGVyRG93bjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCkpIHJldHVybjtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGFjdGlvbkZuID0gdGhpcy5vcHRpb25zLmFjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25GbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWN0aW9uRm4uY2FsbCh0aGlzLnJlbGF0ZWRWaWV3LCBldnQsIHRoaXMucmVsYXRlZFZpZXcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBSZW1vdmUgPSBCdXR0b24uZXh0ZW5kKHtcbiAgICBuYW1lOiAncmVtb3ZlJyxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnTmFtZTogJ2NpcmNsZScsXG4gICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3InOiA3LFxuICAgICAgICAgICAgJ2ZpbGwnOiAnI0ZGMUQwMCcsXG4gICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdpY29uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2QnOiAnTSAtMyAtMyAzIDMgTSAtMyAzIDMgLTMnLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZGlzdGFuY2U6IDYwLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZXZ0LCB2aWV3LCB0b29sKSB7XG4gICAgICAgICAgICB2aWV3Lm1vZGVsLnJlbW92ZSh7IHVpOiB0cnVlLCB0b29sOiB0b29sLmNpZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/cellTools/Button.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/cellTools/Connect.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Connect.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Connect: () => (/* binding */ Connect)\n/* harmony export */ });\n/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Button.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nconst Connect = _Button_mjs__WEBPACK_IMPORTED_MODULE_0__.Button.extend({\n    name: 'connect',\n    documentEvents: {\n        mousemove: 'drag',\n        touchmove: 'drag',\n        mouseup: 'dragend',\n        touchend: 'dragend',\n        touchcancel: 'dragend'\n    },\n    children: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#333333',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n            'fill': '#FFFFFF',\n            'stroke': 'none',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    options: {\n        distance: 80,\n        offset: 0,\n        magnet: (view) => view.el,\n        action: (evt, _view, tool) => tool.dragstart(evt),\n    },\n    getMagnetNode: function() {\n        const { options, relatedView } = this;\n        const { magnet } = options;\n        let magnetNode;\n        switch (typeof magnet) {\n            case 'function': {\n                magnetNode = magnet.call(this, relatedView, this);\n                break;\n            }\n            case 'string': {\n                magnetNode = relatedView.findNode(magnet);\n                break;\n            }\n            default: {\n                magnetNode = magnet;\n                break;\n            }\n        }\n        if (!magnetNode) magnetNode = relatedView.el;\n        if (magnetNode instanceof SVGElement) return magnetNode;\n        throw new Error('Connect: magnet must be an SVGElement');\n    },\n    dragstart: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const { x, y } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n        paper.undelegateEvents();\n        this.delegateDocumentEvents(null, normalizedEvent.data);\n        this.focus();\n    },\n    drag: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const { x, y } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLink(normalizedEvent, x, y);\n    },\n    dragend: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const { x, y } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLinkEnd(normalizedEvent, x, y);\n        this.undelegateDocumentEvents();\n        paper.delegateEvents();\n        this.blur();\n        relatedView.checkMouseleave(normalizedEvent);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9Db25uZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0M7QUFDSTs7QUFFbkMsZ0JBQWdCLCtDQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsZ0NBQWdDLDJEQUFtQjtBQUNuRCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsZ0NBQWdDLDJEQUFtQjtBQUNuRCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsZ0NBQWdDLDJEQUFtQjtBQUNuRCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0Nvbm5lY3QubWpzP2M2MTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAnLi9CdXR0b24ubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3QgQ29ubmVjdCA9IEJ1dHRvbi5leHRlbmQoe1xuICAgIG5hbWU6ICdjb25uZWN0JyxcbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICdkcmFnJyxcbiAgICAgICAgdG91Y2htb3ZlOiAnZHJhZycsXG4gICAgICAgIG1vdXNldXA6ICdkcmFnZW5kJyxcbiAgICAgICAgdG91Y2hlbmQ6ICdkcmFnZW5kJyxcbiAgICAgICAgdG91Y2hjYW5jZWw6ICdkcmFnZW5kJ1xuICAgIH0sXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICBzZWxlY3RvcjogJ2J1dHRvbicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdyJzogNyxcbiAgICAgICAgICAgICdmaWxsJzogJyMzMzMzMzMnLFxuICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJ1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnaWNvbicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdkJzogJ00gLTQgLTEgTCAwIC0xIEwgMCAtNCBMIDQgMCBMIDAgNCAwIDEgLTQgMSB6JyxcbiAgICAgICAgICAgICdmaWxsJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgJ3N0cm9rZSc6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGRpc3RhbmNlOiA4MCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBtYWduZXQ6ICh2aWV3KSA9PiB2aWV3LmVsLFxuICAgICAgICBhY3Rpb246IChldnQsIF92aWV3LCB0b29sKSA9PiB0b29sLmRyYWdzdGFydChldnQpLFxuICAgIH0sXG4gICAgZ2V0TWFnbmV0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcmVsYXRlZFZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbWFnbmV0IH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgbWFnbmV0Tm9kZTtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgbWFnbmV0KSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6IHtcbiAgICAgICAgICAgICAgICBtYWduZXROb2RlID0gbWFnbmV0LmNhbGwodGhpcywgcmVsYXRlZFZpZXcsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgIG1hZ25ldE5vZGUgPSByZWxhdGVkVmlldy5maW5kTm9kZShtYWduZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIG1hZ25ldE5vZGUgPSBtYWduZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYWduZXROb2RlKSBtYWduZXROb2RlID0gcmVsYXRlZFZpZXcuZWw7XG4gICAgICAgIGlmIChtYWduZXROb2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkgcmV0dXJuIG1hZ25ldE5vZGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29ubmVjdDogbWFnbmV0IG11c3QgYmUgYW4gU1ZHRWxlbWVudCcpO1xuICAgIH0sXG4gICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciwgcmVsYXRlZFZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwYXBlci5jbGllbnRUb0xvY2FsUG9pbnQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgcmVsYXRlZFZpZXcuZHJhZ0xpbmtTdGFydChub3JtYWxpemVkRXZlbnQsIHRoaXMuZ2V0TWFnbmV0Tm9kZSgpLCB4LCB5KTtcbiAgICAgICAgcGFwZXIudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRG9jdW1lbnRFdmVudHMobnVsbCwgbm9ybWFsaXplZEV2ZW50LmRhdGEpO1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgfSxcbiAgICBkcmFnOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciwgcmVsYXRlZFZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwYXBlci5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdmVudC5jbGllbnRYLCBub3JtYWxpemVkRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHJlbGF0ZWRWaWV3LmRyYWdMaW5rKG5vcm1hbGl6ZWRFdmVudCwgeCwgeSk7XG4gICAgfSxcbiAgICBkcmFnZW5kOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciwgcmVsYXRlZFZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwYXBlci5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdmVudC5jbGllbnRYLCBub3JtYWxpemVkRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHJlbGF0ZWRWaWV3LmRyYWdMaW5rRW5kKG5vcm1hbGl6ZWRFdmVudCwgeCwgeSk7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIHBhcGVyLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICByZWxhdGVkVmlldy5jaGVja01vdXNlbGVhdmUobm9ybWFsaXplZEV2ZW50KTtcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/cellTools/Connect.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/cellTools/Control.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Control.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Control: () => (/* binding */ Control)\n/* harmony export */ });\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nconst Control = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    tagName: 'g',\n    children: [{\n        tagName: 'circle',\n        selector: 'handle',\n        attributes: {\n            'cursor': 'pointer',\n            'stroke-width': 2,\n            'stroke': '#FFFFFF',\n            'fill': '#33334F',\n            'r': 6\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'extras',\n        attributes: {\n            'pointer-events': 'none',\n            'fill': 'none',\n            'stroke': '#33334F',\n            'stroke-dasharray': '2,4',\n            'rx': 5,\n            'ry': 5\n        }\n    }],\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onPointerDblClick',\n        dbltap: 'onPointerDblClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        handleAttributes: null,\n        selector: 'root',\n        padding: 6,\n        scale: null\n    },\n\n    getPosition: function() {\n        // To be overridden\n    },\n    setPosition: function() {\n        // To be overridden\n    },\n    resetPosition: function() {\n        // To be overridden\n    },\n    onRender: function() {\n        this.renderChildren();\n        this.toggleExtras(false);\n        this.update();\n    },\n    update: function() {\n        const { handle, extras } = this.childNodes;\n        if (handle) {\n            this.updateHandle(handle);\n        } else {\n            throw new Error('Control: markup selector `handle` is required');\n        }\n        if (extras) {\n            this.updateExtras(extras);\n        }\n        return this;\n    },\n    updateHandle: function(handleNode) {\n        const { relatedView, options } = this;\n        const { model } = relatedView;\n        const relativePos = this.getPosition(relatedView, this);\n        const absolutePos = model.getAbsolutePointFromRelative(relativePos);\n        const { handleAttributes, scale } = options;\n        let transformString =  `translate(${absolutePos.x},${absolutePos.y})`;\n        if (scale) {\n            transformString += ` scale(${scale})`;\n        }\n        handleNode.setAttribute('transform', transformString);\n        if (handleAttributes) {\n            for (let attrName in handleAttributes) {\n                handleNode.setAttribute(attrName, handleAttributes[attrName]);\n            }\n        }\n    },\n    updateExtras: function(extrasNode) {\n        const { relatedView, options } = this;\n        const { selector } = this.options;\n        if (!selector) {\n            this.toggleExtras(false);\n            return;\n        }\n        const magnet = relatedView.findNode(selector);\n        if (!magnet) throw new Error('Control: invalid selector.');\n        let padding = options.padding;\n        if (!isFinite(padding)) padding = 0;\n        const bbox = relatedView.getNodeUnrotatedBBox(magnet);\n        const model = relatedView.model;\n        const angle = model.angle();\n        const center = bbox.center();\n        if (angle) center.rotate(model.getBBox().center(), -angle);\n        bbox.inflate(padding);\n        extrasNode.setAttribute('x', -bbox.width / 2);\n        extrasNode.setAttribute('y', -bbox.height / 2);\n        extrasNode.setAttribute('width', bbox.width);\n        extrasNode.setAttribute('height', bbox.height);\n        extrasNode.setAttribute('transform', `translate(${center.x},${center.y}) rotate(${angle})`);\n    },\n    toggleExtras: function(visible) {\n        const { extras } = this.childNodes;\n        if (!extras) return;\n        extras.style.display = (visible) ? '' : 'none';\n    },\n    onPointerDown: function(evt) {\n        const { relatedView, paper } = this;\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        paper.undelegateEvents();\n        this.delegateDocumentEvents();\n        this.focus();\n        this.toggleExtras(true);\n        relatedView.model.startBatch('control-move', { ui: true, tool: this.cid });\n    },\n    onPointerMove: function(evt) {\n        const { relatedView, paper } = this;\n        const { model } = relatedView;\n        const { clientX, clientY } = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const coords = paper.clientToLocalPoint(clientX, clientY);\n        const relativeCoords = model.getRelativePointFromAbsolute(coords);\n        this.setPosition(relatedView, relativeCoords, evt);\n        this.update();\n    },\n    onPointerUp: function(_evt) {\n        const { relatedView, paper } = this;\n        paper.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleExtras(false);\n        relatedView.model.stopBatch('control-move', { ui: true, tool: this.cid });\n    },\n    onPointerDblClick: function(evt) {\n        const { relatedView } = this;\n        this.resetPosition(relatedView, evt);\n        this.update();\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9Db250cm9sLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDTDs7QUFFbkMsZ0JBQWdCLHVEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQyw0Q0FBNEMsY0FBYyxHQUFHLGNBQWM7QUFDM0U7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVMsR0FBRyxTQUFTLFdBQVcsTUFBTTtBQUNoRyxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwQkFBMEI7QUFDakYsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsbUJBQW1CLEVBQUUsMkRBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwwQkFBMEI7QUFDaEYsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jZWxsVG9vbHMvQ29udHJvbC5tanM/OTczYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUb29sVmlldyB9IGZyb20gJy4uL2RpYS9Ub29sVmlldy5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBDb250cm9sID0gVG9vbFZpZXcuZXh0ZW5kKHtcbiAgICB0YWdOYW1lOiAnZycsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICBzZWxlY3RvcjogJ2hhbmRsZScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdjdXJzb3InOiAncG9pbnRlcicsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgICAgICdzdHJva2UnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAnZmlsbCc6ICcjMzMzMzRGJyxcbiAgICAgICAgICAgICdyJzogNlxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgIHNlbGVjdG9yOiAnZXh0cmFzJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyMzMzMzNEYnLFxuICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnMiw0JyxcbiAgICAgICAgICAgICdyeCc6IDUsXG4gICAgICAgICAgICAncnknOiA1XG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgbW91c2Vkb3duOiAnb25Qb2ludGVyRG93bicsXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgZGJsY2xpY2s6ICdvblBvaW50ZXJEYmxDbGljaycsXG4gICAgICAgIGRibHRhcDogJ29uUG9pbnRlckRibENsaWNrJ1xuICAgIH0sXG4gICAgZG9jdW1lbnRFdmVudHM6IHtcbiAgICAgICAgbW91c2Vtb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIHRvdWNobW92ZTogJ29uUG9pbnRlck1vdmUnLFxuICAgICAgICBtb3VzZXVwOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGVuZDogJ29uUG9pbnRlclVwJyxcbiAgICAgICAgdG91Y2hjYW5jZWw6ICdvblBvaW50ZXJVcCdcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaGFuZGxlQXR0cmlidXRlczogbnVsbCxcbiAgICAgICAgc2VsZWN0b3I6ICdyb290JyxcbiAgICAgICAgcGFkZGluZzogNixcbiAgICAgICAgc2NhbGU6IG51bGxcbiAgICB9LFxuXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuXG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuICAgIHJlc2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuXG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy50b2dnbGVFeHRyYXMoZmFsc2UpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBoYW5kbGUsIGV4dHJhcyB9ID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoaGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZShoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cm9sOiBtYXJrdXAgc2VsZWN0b3IgYGhhbmRsZWAgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4dHJhcyhleHRyYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdXBkYXRlSGFuZGxlOiBmdW5jdGlvbihoYW5kbGVOb2RlKSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXcsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHJlbGF0ZWRWaWV3O1xuICAgICAgICBjb25zdCByZWxhdGl2ZVBvcyA9IHRoaXMuZ2V0UG9zaXRpb24ocmVsYXRlZFZpZXcsIHRoaXMpO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBvcyA9IG1vZGVsLmdldEFic29sdXRlUG9pbnRGcm9tUmVsYXRpdmUocmVsYXRpdmVQb3MpO1xuICAgICAgICBjb25zdCB7IGhhbmRsZUF0dHJpYnV0ZXMsIHNjYWxlIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgdHJhbnNmb3JtU3RyaW5nID0gIGB0cmFuc2xhdGUoJHthYnNvbHV0ZVBvcy54fSwke2Fic29sdXRlUG9zLnl9KWA7XG4gICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nICs9IGAgc2NhbGUoJHtzY2FsZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVOb2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdHJhbnNmb3JtU3RyaW5nKTtcbiAgICAgICAgaWYgKGhhbmRsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGhhbmRsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVOb2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgaGFuZGxlQXR0cmlidXRlc1thdHRyTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVFeHRyYXM6IGZ1bmN0aW9uKGV4dHJhc05vZGUpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RvciB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUV4dHJhcyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFnbmV0ID0gcmVsYXRlZFZpZXcuZmluZE5vZGUoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIW1hZ25ldCkgdGhyb3cgbmV3IEVycm9yKCdDb250cm9sOiBpbnZhbGlkIHNlbGVjdG9yLicpO1xuICAgICAgICBsZXQgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShwYWRkaW5nKSkgcGFkZGluZyA9IDA7XG4gICAgICAgIGNvbnN0IGJib3ggPSByZWxhdGVkVmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgICAgICBjb25zdCBtb2RlbCA9IHJlbGF0ZWRWaWV3Lm1vZGVsO1xuICAgICAgICBjb25zdCBhbmdsZSA9IG1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGJib3guY2VudGVyKCk7XG4gICAgICAgIGlmIChhbmdsZSkgY2VudGVyLnJvdGF0ZShtb2RlbC5nZXRCQm94KCkuY2VudGVyKCksIC1hbmdsZSk7XG4gICAgICAgIGJib3guaW5mbGF0ZShwYWRkaW5nKTtcbiAgICAgICAgZXh0cmFzTm9kZS5zZXRBdHRyaWJ1dGUoJ3gnLCAtYmJveC53aWR0aCAvIDIpO1xuICAgICAgICBleHRyYXNOb2RlLnNldEF0dHJpYnV0ZSgneScsIC1iYm94LmhlaWdodCAvIDIpO1xuICAgICAgICBleHRyYXNOb2RlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBiYm94LndpZHRoKTtcbiAgICAgICAgZXh0cmFzTm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgZXh0cmFzTm9kZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtjZW50ZXIueH0sJHtjZW50ZXIueX0pIHJvdGF0ZSgke2FuZ2xlfSlgKTtcbiAgICB9LFxuICAgIHRvZ2dsZUV4dHJhczogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgICBjb25zdCB7IGV4dHJhcyB9ID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIWV4dHJhcykgcmV0dXJuO1xuICAgICAgICBleHRyYXMuc3R5bGUuZGlzcGxheSA9ICh2aXNpYmxlKSA/ICcnIDogJ25vbmUnO1xuICAgIH0sXG4gICAgb25Qb2ludGVyRG93bjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXcsIHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQpKSByZXR1cm47XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHBhcGVyLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy50b2dnbGVFeHRyYXModHJ1ZSk7XG4gICAgICAgIHJlbGF0ZWRWaWV3Lm1vZGVsLnN0YXJ0QmF0Y2goJ2NvbnRyb2wtbW92ZScsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgIH0sXG4gICAgb25Qb2ludGVyTW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXcsIHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG1vZGVsIH0gPSByZWxhdGVkVmlldztcbiAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSB1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHBhcGVyLmNsaWVudFRvTG9jYWxQb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVDb29yZHMgPSBtb2RlbC5nZXRSZWxhdGl2ZVBvaW50RnJvbUFic29sdXRlKGNvb3Jkcyk7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocmVsYXRlZFZpZXcsIHJlbGF0aXZlQ29vcmRzLCBldnQpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgb25Qb2ludGVyVXA6IGZ1bmN0aW9uKF9ldnQpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIHBhcGVyLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICB0aGlzLnRvZ2dsZUV4dHJhcyhmYWxzZSk7XG4gICAgICAgIHJlbGF0ZWRWaWV3Lm1vZGVsLnN0b3BCYXRjaCgnY29udHJvbC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEYmxDbGljazogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXcgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihyZWxhdGVkVmlldywgZXZ0KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/cellTools/Control.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/HoverConnect.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HoverConnect: () => (/* binding */ HoverConnect)\n/* harmony export */ });\n/* harmony import */ var _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Connect.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Connect.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\n\n\n\n\nconst HoverConnect = _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__.Connect.extend({\n\n    name: 'hover-connect',\n\n    defaultMarkup: [\n        {\n            tagName: 'circle',\n            attributes: {\n                'r': 7,\n                'fill': '#333333',\n                'cursor': 'pointer'\n            }\n        },\n        {\n            tagName: 'path',\n            attributes: {\n                'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n                'fill': '#FFFFFF',\n                'stroke': 'none',\n                'stroke-width': 2\n            }\n        }\n    ],\n\n    children() {\n        const { options, defaultMarkup } = this;\n        return [\n            {\n                tagName: 'path',\n                selector: 'track',\n                attributes: {\n                    'fill': 'none',\n                    'stroke': 'transparent',\n                    'stroke-width': options.trackWidth || 15,\n                    'cursor': 'pointer'\n                }\n            },\n            {\n                tagName: 'g',\n                selector: 'button',\n                attributes: {\n                    'pointer-events': 'none',\n                    'display': 'none'\n                },\n                children: options.markup || defaultMarkup\n            }\n        ];\n    },\n\n    events: Object.assign({\n        mousemove: 'onMousemove',\n        mouseenter: 'onMouseenter',\n        mouseleave: 'onMouseleave'\n    }, _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__.Connect.prototype.events),\n\n    onRender: function() {\n        this.renderChildren();\n        this.update();\n    },\n\n    trackPath: null,\n\n    update() {\n        const { childNodes } = this;\n        this.trackPath = this.getTrackPath();\n        _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__.Connect.prototype.update.apply(this, arguments);\n        childNodes.track.setAttribute(\n            'd',\n            this.trackPath.serialize()\n        );\n    },\n\n    position() {\n        const { el, childNodes } = this;\n        childNodes.button.setAttribute(\n            'transform',\n            _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(this.getButtonMatrix())\n        );\n        el.setAttribute(\n            'transform',\n            _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(this.getTrackMatrix())\n        );\n    },\n\n    getButtonMatrix() {\n        const { options, trackPath } = this;\n        const { offset = 0, distance = 0, rotate, scale } = options;\n        let tangent, position, angle;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(distance)) {\n            tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n        } else {\n            tangent = trackPath.tangentAtLength(distance);\n        }\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(1, 0)) || 0;\n        } else {\n            position = trackPath.start;\n            angle = 0;\n        }\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix()\n            .translate(position.x, position.y)\n            .rotate(angle)\n            .translate(0, offset);\n        if (!rotate) matrix = matrix.rotate(-angle);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n\n    getTrackPath() {\n        return this.relatedView.getConnection();\n    },\n\n    getTrackMatrix() {\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix();\n    },\n\n    getTrackRatioFromEvent(evt) {\n        const { relatedView, trackPath } = this;\n        const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n        const trackPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformPoint(localPoint, this.getTrackMatrix().inverse());\n        return trackPath.closestPointLength(trackPoint);\n    },\n\n    canShowButton() {\n        // Has been the paper events undelegated? If so, we can't show the button.\n        // TODO: add a method to the paper to check if the events are delegated.\n        return _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].event.has(this.paper.el);\n    },\n\n    showButton() {\n        this.childNodes.button.style.display = 'block';\n    },\n\n    hideButton() {\n        this.childNodes.button.style.display = '';\n    },\n\n    onMousemove(evt) {\n        const { trackPath } = this;\n        if (!trackPath) return;\n        const { options } = this;\n        options.distance = this.getTrackRatioFromEvent(evt);\n        this.position();\n    },\n\n    onMouseenter() {\n        if (!this.canShowButton()) return;\n        this.showButton();\n    },\n\n    onMouseleave() {\n        this.hideButton();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9Ib3ZlckNvbm5lY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QztBQUNUO0FBQ007QUFDSztBQUNOOztBQUU3QixxQkFBcUIsaURBQU87O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLGlEQUFPOztBQUVkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBLFFBQVEsaURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxZQUFZLG9EQUFDO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBQztBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBLFlBQVkseURBQWlCO0FBQzdCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtDQUFPO0FBQzVELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsb0RBQUM7QUFDaEIsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSwyQkFBMkIsb0RBQUM7QUFDNUI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQUM7QUFDaEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0hvdmVyQ29ubmVjdC5tanM/NzljYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0IH0gZnJvbSAnLi9Db25uZWN0Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgJCBmcm9tICcuLi9tdmMvRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3QgSG92ZXJDb25uZWN0ID0gQ29ubmVjdC5leHRlbmQoe1xuXG4gICAgbmFtZTogJ2hvdmVyLWNvbm5lY3QnLFxuXG4gICAgZGVmYXVsdE1hcmt1cDogW1xuICAgICAgICB7XG4gICAgICAgICAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAncic6IDcsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnOiAnIzMzMzMzMycsXG4gICAgICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgJ2QnOiAnTSAtNCAtMSBMIDAgLTEgTCAwIC00IEwgNCAwIEwgMCA0IDAgMSAtNCAxIHonLFxuICAgICAgICAgICAgICAgICdmaWxsJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0sXG5cbiAgICBjaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCBkZWZhdWx0TWFya3VwIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3RyYWNrJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG9wdGlvbnMudHJhY2tXaWR0aCB8fCAxNSxcbiAgICAgICAgICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2cnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnbm9uZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBvcHRpb25zLm1hcmt1cCB8fCBkZWZhdWx0TWFya3VwXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGV2ZW50czogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1vdXNlbW92ZTogJ29uTW91c2Vtb3ZlJyxcbiAgICAgICAgbW91c2VlbnRlcjogJ29uTW91c2VlbnRlcicsXG4gICAgICAgIG1vdXNlbGVhdmU6ICdvbk1vdXNlbGVhdmUnXG4gICAgfSwgQ29ubmVjdC5wcm90b3R5cGUuZXZlbnRzKSxcblxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICB0cmFja1BhdGg6IG51bGwsXG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGROb2RlcyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFja1BhdGggPSB0aGlzLmdldFRyYWNrUGF0aCgpO1xuICAgICAgICBDb25uZWN0LnByb3RvdHlwZS51cGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY2hpbGROb2Rlcy50cmFjay5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICB0aGlzLnRyYWNrUGF0aC5zZXJpYWxpemUoKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBlbCwgY2hpbGROb2RlcyB9ID0gdGhpcztcbiAgICAgICAgY2hpbGROb2Rlcy5idXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKHRoaXMuZ2V0QnV0dG9uTWF0cml4KCkpXG4gICAgICAgICk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICd0cmFuc2Zvcm0nLFxuICAgICAgICAgICAgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyh0aGlzLmdldFRyYWNrTWF0cml4KCkpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGdldEJ1dHRvbk1hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCB0cmFja1BhdGggfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0ID0gMCwgZGlzdGFuY2UgPSAwLCByb3RhdGUsIHNjYWxlIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgdGFuZ2VudCwgcG9zaXRpb24sIGFuZ2xlO1xuICAgICAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICB0YW5nZW50ID0gdHJhY2tQYXRoLnRhbmdlbnRBdFJhdGlvKHBhcnNlRmxvYXQoZGlzdGFuY2UpIC8gMTAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhbmdlbnQgPSB0cmFja1BhdGgudGFuZ2VudEF0TGVuZ3RoKGRpc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFuZ2VudCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0YW5nZW50LnN0YXJ0O1xuICAgICAgICAgICAgYW5nbGUgPSB0YW5nZW50LnZlY3RvcigpLnZlY3RvckFuZ2xlKG5ldyBnLlBvaW50KDEsIDApKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0cmFja1BhdGguc3RhcnQ7XG4gICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgICAgIC50cmFuc2xhdGUocG9zaXRpb24ueCwgcG9zaXRpb24ueSlcbiAgICAgICAgICAgIC5yb3RhdGUoYW5nbGUpXG4gICAgICAgICAgICAudHJhbnNsYXRlKDAsIG9mZnNldCk7XG4gICAgICAgIGlmICghcm90YXRlKSBtYXRyaXggPSBtYXRyaXgucm90YXRlKC1hbmdsZSk7XG4gICAgICAgIGlmIChzY2FsZSkgbWF0cml4ID0gbWF0cml4LnNjYWxlKHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuXG4gICAgZ2V0VHJhY2tQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGVkVmlldy5nZXRDb25uZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIGdldFRyYWNrTWF0cml4KCkge1xuICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgZ2V0VHJhY2tSYXRpb0Zyb21FdmVudChldnQpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgdHJhY2tQYXRoIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsb2NhbFBvaW50ID0gcmVsYXRlZFZpZXcucGFwZXIuY2xpZW50VG9Mb2NhbFBvaW50KGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IHRyYWNrUG9pbnQgPSBWLnRyYW5zZm9ybVBvaW50KGxvY2FsUG9pbnQsIHRoaXMuZ2V0VHJhY2tNYXRyaXgoKS5pbnZlcnNlKCkpO1xuICAgICAgICByZXR1cm4gdHJhY2tQYXRoLmNsb3Nlc3RQb2ludExlbmd0aCh0cmFja1BvaW50KTtcbiAgICB9LFxuXG4gICAgY2FuU2hvd0J1dHRvbigpIHtcbiAgICAgICAgLy8gSGFzIGJlZW4gdGhlIHBhcGVyIGV2ZW50cyB1bmRlbGVnYXRlZD8gSWYgc28sIHdlIGNhbid0IHNob3cgdGhlIGJ1dHRvbi5cbiAgICAgICAgLy8gVE9ETzogYWRkIGEgbWV0aG9kIHRvIHRoZSBwYXBlciB0byBjaGVjayBpZiB0aGUgZXZlbnRzIGFyZSBkZWxlZ2F0ZWQuXG4gICAgICAgIHJldHVybiAkLmV2ZW50Lmhhcyh0aGlzLnBhcGVyLmVsKTtcbiAgICB9LFxuXG4gICAgc2hvd0J1dHRvbigpIHtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9LFxuXG4gICAgaGlkZUJ1dHRvbigpIHtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgfSxcblxuICAgIG9uTW91c2Vtb3ZlKGV2dCkge1xuICAgICAgICBjb25zdCB7IHRyYWNrUGF0aCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF0cmFja1BhdGgpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBvcHRpb25zLmRpc3RhbmNlID0gdGhpcy5nZXRUcmFja1JhdGlvRnJvbUV2ZW50KGV2dCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICB9LFxuXG4gICAgb25Nb3VzZWVudGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuU2hvd0J1dHRvbigpKSByZXR1cm47XG4gICAgICAgIHRoaXMuc2hvd0J1dHRvbigpO1xuICAgIH0sXG5cbiAgICBvbk1vdXNlbGVhdmUoKSB7XG4gICAgICAgIHRoaXMuaGlkZUJ1dHRvbigpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/helpers.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnchor: () => (/* binding */ getAnchor),\n/* harmony export */   getViewBBox: () => (/* binding */ getViewBBox),\n/* harmony export */   snapAnchor: () => (/* binding */ snapAnchor)\n/* harmony export */ });\n/* harmony import */ var _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connectionStrategies/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\");\n\n\nfunction getViewBBox(view, useModelGeometry) {\n    const { model } = view;\n    if (useModelGeometry) return model.getBBox();\n    return (model.isLink()) ? view.getConnection().bbox() : view.getNodeUnrotatedBBox(view.el);\n}\n\nfunction getAnchor(coords, view, magnet) {\n    // take advantage of an existing logic inside of the\n    // pin relative connection strategy\n    var end = _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_0__.pinRelative.call(\n        this.paper,\n        {},\n        view,\n        magnet,\n        coords,\n        this.model\n    );\n    return end.anchor;\n}\n\nfunction snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n    var snapRadius = toolView.options.snapRadius;\n    var isSource = (type === 'source');\n    var refIndex = (isSource ? 0 : -1);\n    var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n    if (ref) {\n        if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;\n        if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;\n    }\n    return coords;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBFOztBQUVuRTtBQUNQLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsY0FBYyx3RUFBZ0M7QUFDOUM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9oZWxwZXJzLm1qcz9jYTI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvbm5lY3Rpb25TdHJhdGVnaWVzIGZyb20gJy4uL2Nvbm5lY3Rpb25TdHJhdGVnaWVzL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3QkJveCh2aWV3LCB1c2VNb2RlbEdlb21ldHJ5KSB7XG4gICAgY29uc3QgeyBtb2RlbCB9ID0gdmlldztcbiAgICBpZiAodXNlTW9kZWxHZW9tZXRyeSkgcmV0dXJuIG1vZGVsLmdldEJCb3goKTtcbiAgICByZXR1cm4gKG1vZGVsLmlzTGluaygpKSA/IHZpZXcuZ2V0Q29ubmVjdGlvbigpLmJib3goKSA6IHZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3godmlldy5lbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmNob3IoY29vcmRzLCB2aWV3LCBtYWduZXQpIHtcbiAgICAvLyB0YWtlIGFkdmFudGFnZSBvZiBhbiBleGlzdGluZyBsb2dpYyBpbnNpZGUgb2YgdGhlXG4gICAgLy8gcGluIHJlbGF0aXZlIGNvbm5lY3Rpb24gc3RyYXRlZ3lcbiAgICB2YXIgZW5kID0gY29ubmVjdGlvblN0cmF0ZWdpZXMucGluUmVsYXRpdmUuY2FsbChcbiAgICAgICAgdGhpcy5wYXBlcixcbiAgICAgICAge30sXG4gICAgICAgIHZpZXcsXG4gICAgICAgIG1hZ25ldCxcbiAgICAgICAgY29vcmRzLFxuICAgICAgICB0aGlzLm1vZGVsXG4gICAgKTtcbiAgICByZXR1cm4gZW5kLmFuY2hvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNuYXBBbmNob3IoY29vcmRzLCB2aWV3LCBtYWduZXQsIHR5cGUsIHJlbGF0ZWRWaWV3LCB0b29sVmlldykge1xuICAgIHZhciBzbmFwUmFkaXVzID0gdG9vbFZpZXcub3B0aW9ucy5zbmFwUmFkaXVzO1xuICAgIHZhciBpc1NvdXJjZSA9ICh0eXBlID09PSAnc291cmNlJyk7XG4gICAgdmFyIHJlZkluZGV4ID0gKGlzU291cmNlID8gMCA6IC0xKTtcbiAgICB2YXIgcmVmID0gdGhpcy5tb2RlbC52ZXJ0ZXgocmVmSW5kZXgpIHx8IHRoaXMuZ2V0RW5kQW5jaG9yKGlzU291cmNlID8gJ3RhcmdldCcgOiAnc291cmNlJyk7XG4gICAgaWYgKHJlZikge1xuICAgICAgICBpZiAoTWF0aC5hYnMocmVmLnggLSBjb29yZHMueCkgPCBzbmFwUmFkaXVzKSBjb29yZHMueCA9IHJlZi54O1xuICAgICAgICBpZiAoTWF0aC5hYnMocmVmLnkgLSBjb29yZHMueSkgPCBzbmFwUmFkaXVzKSBjb29yZHMueSA9IHJlZi55O1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/config/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/config/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config)\n/* harmony export */ });\nconst config = {\n    // When set to `true` the cell selectors could be defined as CSS selectors.\n    // If not, only JSON Markup selectors are taken into account.\n    useCSSSelectors: false,\n    // The class name prefix config is for advanced use only.\n    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n    classNamePrefix: 'joint-',\n    defaultTheme: 'default',\n    // The maximum delay required for two consecutive touchend events to be interpreted\n    // as a double-tap.\n    doubleTapInterval: 300\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NvbmZpZy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NvbmZpZy9pbmRleC5tanM/ZjFhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY29uZmlnID0ge1xuICAgIC8vIFdoZW4gc2V0IHRvIGB0cnVlYCB0aGUgY2VsbCBzZWxlY3RvcnMgY291bGQgYmUgZGVmaW5lZCBhcyBDU1Mgc2VsZWN0b3JzLlxuICAgIC8vIElmIG5vdCwgb25seSBKU09OIE1hcmt1cCBzZWxlY3RvcnMgYXJlIHRha2VuIGludG8gYWNjb3VudC5cbiAgICB1c2VDU1NTZWxlY3RvcnM6IGZhbHNlLFxuICAgIC8vIFRoZSBjbGFzcyBuYW1lIHByZWZpeCBjb25maWcgaXMgZm9yIGFkdmFuY2VkIHVzZSBvbmx5LlxuICAgIC8vIEJlIGF3YXJlIHRoYXQgaWYgeW91IGNoYW5nZSB0aGUgcHJlZml4LCB0aGUgSm9pbnRKUyBDU1Mgd2lsbCBubyBsb25nZXIgZnVuY3Rpb24gcHJvcGVybHkuXG4gICAgY2xhc3NOYW1lUHJlZml4OiAnam9pbnQtJyxcbiAgICBkZWZhdWx0VGhlbWU6ICdkZWZhdWx0JyxcbiAgICAvLyBUaGUgbWF4aW11bSBkZWxheSByZXF1aXJlZCBmb3IgdHdvIGNvbnNlY3V0aXZlIHRvdWNoZW5kIGV2ZW50cyB0byBiZSBpbnRlcnByZXRlZFxuICAgIC8vIGFzIGEgZG91YmxlLXRhcC5cbiAgICBkb3VibGVUYXBJbnRlcnZhbDogMzAwXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/config/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectionPoints/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectionPoints/index.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anchor: () => (/* binding */ anchor),\n/* harmony export */   bbox: () => (/* binding */ bbox),\n/* harmony export */   boundary: () => (/* binding */ boundary),\n/* harmony export */   rectangle: () => (/* binding */ rectangle)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\n\nfunction offsetPoint(p1, p2, offset) {\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findNode(selector);\n    } else if (selector === false) {\n        node = magnet;\n    } else if (Array.isArray(selector)) {\n        node = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isSVGGraphicsElement(node)) {\n        if (node === magnet || !_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nconst anchor = anchorConnectionPoint;\nconst bbox = bboxIntersection;\nconst rectangle = rectangleIntersection;\nconst boundary = boundaryIntersection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3Rpb25Qb2ludHMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0w7QUFDVzs7QUFFMUM7QUFDQSxRQUFRLDBEQUFrQjtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLDhCQUE4Qiw4Q0FBTTtBQUNwQyxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLGVBQWUsc0RBQWM7QUFDN0IsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsU0FBUyxvREFBQztBQUNWLGdDQUFnQyxvREFBQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBQztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBTTtBQUNwQztBQUNBLG9HQUFvRyxzQkFBc0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFDO0FBQ2IsTUFBTTtBQUNOO0FBQ0Esa0NBQWtDLDhDQUFNO0FBQ3hDO0FBQ0EsVUFBVSwrQkFBK0IsaURBQVM7QUFDbEQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixvREFBQztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0aW9uUG9pbnRzL2luZGV4Lm1qcz9iYTE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIG9mZnNldFBvaW50KHAxLCBwMiwgb2Zmc2V0KSB7XG4gICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChvZmZzZXQpKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gb2Zmc2V0O1xuICAgICAgICBpZiAoaXNGaW5pdGUoeSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSAgbmV3IGcuTGluZShwMiwgcDEpO1xuICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBsaW5lLnBhcmFsbGVsKHkpO1xuICAgICAgICAgICAgcDIgPSBzdGFydDtcbiAgICAgICAgICAgIHAxID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHg7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUob2Zmc2V0KSkgcmV0dXJuIHAxO1xuICAgIHZhciBsZW5ndGggPSBwMS5kaXN0YW5jZShwMik7XG4gICAgaWYgKG9mZnNldCA9PT0gMCAmJiBsZW5ndGggPiAwKSByZXR1cm4gcDE7XG4gICAgcmV0dXJuIHAxLm1vdmUocDIsIC1NYXRoLm1pbihvZmZzZXQsIGxlbmd0aCAtIDEpKTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlKG1hZ25ldCkge1xuXG4gICAgdmFyIHN0cm9rZSA9IG1hZ25ldC5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpO1xuICAgIGlmIChzdHJva2UgPT09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHN0cm9rZSkgfHwgMDtcbn1cblxuZnVuY3Rpb24gYWxpZ25MaW5lKGxpbmUsIHR5cGUsIG9mZnNldCA9IDApIHtcbiAgICBsZXQgY29vcmRpbmF0ZSwgYSwgYiwgZGlyZWN0aW9uO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gbGluZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3gnO1xuICAgICAgICAgICAgYSA9IGVuZDtcbiAgICAgICAgICAgIGIgPSBzdGFydDtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneCc7XG4gICAgICAgICAgICBhID0gc3RhcnQ7XG4gICAgICAgICAgICBiID0gZW5kO1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd5JztcbiAgICAgICAgICAgIGEgPSBlbmQ7XG4gICAgICAgICAgICBiID0gc3RhcnQ7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd5JztcbiAgICAgICAgICAgIGEgPSBzdGFydDtcbiAgICAgICAgICAgIGIgPSBlbmQ7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGFydFtjb29yZGluYXRlXSA8IGVuZFtjb29yZGluYXRlXSkge1xuICAgICAgICBhW2Nvb3JkaW5hdGVdID0gYltjb29yZGluYXRlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBiW2Nvb3JkaW5hdGVdID0gYVtjb29yZGluYXRlXTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgYVtjb29yZGluYXRlXSArPSBkaXJlY3Rpb24gKiBvZmZzZXQ7XG4gICAgICAgIGJbY29vcmRpbmF0ZV0gKz0gZGlyZWN0aW9uICogb2Zmc2V0O1xuICAgIH1cbn1cblxuLy8gQ29ubmVjdGlvbiBQb2ludHNcblxuZnVuY3Rpb24gYW5jaG9yQ29ubmVjdGlvblBvaW50KGxpbmUsIF92aWV3LCBfbWFnbmV0LCBvcHQpIHtcbiAgICBsZXQgeyBvZmZzZXQsIGFsaWduT2Zmc2V0LCBhbGlnbiB9ID0gb3B0O1xuICAgIGlmIChhbGlnbikgYWxpZ25MaW5lKGxpbmUsIGFsaWduLCBhbGlnbk9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldFBvaW50KGxpbmUuZW5kLCBsaW5lLnN0YXJ0LCBvZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBiYm94SW50ZXJzZWN0aW9uKGxpbmUsIHZpZXcsIG1hZ25ldCwgb3B0KSB7XG5cbiAgICB2YXIgYmJveCA9IHZpZXcuZ2V0Tm9kZUJCb3gobWFnbmV0KTtcbiAgICBpZiAob3B0LnN0cm9rZSkgYmJveC5pbmZsYXRlKHN0cm9rZShtYWduZXQpIC8gMik7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBsaW5lLmludGVyc2VjdChiYm94KTtcbiAgICB2YXIgY3AgPSAoaW50ZXJzZWN0aW9ucylcbiAgICAgICAgPyBsaW5lLnN0YXJ0LmNob29zZUNsb3Nlc3QoaW50ZXJzZWN0aW9ucylcbiAgICAgICAgOiBsaW5lLmVuZDtcbiAgICByZXR1cm4gb2Zmc2V0UG9pbnQoY3AsIGxpbmUuc3RhcnQsIG9wdC5vZmZzZXQpO1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVJbnRlcnNlY3Rpb24obGluZSwgdmlldywgbWFnbmV0LCBvcHQpIHtcblxuICAgIHZhciBhbmdsZSA9IHZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJib3hJbnRlcnNlY3Rpb24obGluZSwgdmlldywgbWFnbmV0LCBvcHQpO1xuICAgIH1cblxuICAgIHZhciBiYm94V09Sb3RhdGlvbiA9IHZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobWFnbmV0KTtcbiAgICBpZiAob3B0LnN0cm9rZSkgYmJveFdPUm90YXRpb24uaW5mbGF0ZShzdHJva2UobWFnbmV0KSAvIDIpO1xuICAgIHZhciBjZW50ZXIgPSBiYm94V09Sb3RhdGlvbi5jZW50ZXIoKTtcbiAgICB2YXIgbGluZVdPUm90YXRpb24gPSBsaW5lLmNsb25lKCkucm90YXRlKGNlbnRlciwgYW5nbGUpO1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gbGluZVdPUm90YXRpb24uc2V0TGVuZ3RoKDFlNikuaW50ZXJzZWN0KGJib3hXT1JvdGF0aW9uKTtcbiAgICB2YXIgY3AgPSAoaW50ZXJzZWN0aW9ucylcbiAgICAgICAgPyBsaW5lV09Sb3RhdGlvbi5zdGFydC5jaG9vc2VDbG9zZXN0KGludGVyc2VjdGlvbnMpLnJvdGF0ZShjZW50ZXIsIC1hbmdsZSlcbiAgICAgICAgOiBsaW5lLmVuZDtcbiAgICByZXR1cm4gb2Zmc2V0UG9pbnQoY3AsIGxpbmUuc3RhcnQsIG9wdC5vZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBmaW5kU2hhcGVOb2RlKG1hZ25ldCkge1xuICAgIGlmICghbWFnbmV0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgbm9kZSA9IG1hZ25ldDtcbiAgICBkbyB7XG4gICAgICAgIHZhciB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT09ICdzdHJpbmcnKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdHJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnTmFtZSA9PT0gJ1RJVExFJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgfSB3aGlsZSAobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbnZhciBCTkRSX1NVQkRJVklTSU9OUyA9ICdzZWdtZW50U3ViZGl2aXNvbnMnO1xudmFyIEJORFJfU0hBUEVfQkJPWCA9ICdzaGFwZUJCb3gnO1xuXG5mdW5jdGlvbiBib3VuZGFyeUludGVyc2VjdGlvbihsaW5lLCB2aWV3LCBtYWduZXQsIG9wdCkge1xuXG4gICAgdmFyIG5vZGUsIGludGVyc2VjdGlvbjtcbiAgICB2YXIgc2VsZWN0b3IgPSBvcHQuc2VsZWN0b3I7XG4gICAgdmFyIGFuY2hvciA9IGxpbmUuZW5kO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZSA9IHZpZXcuZmluZE5vZGUoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUgPSBtYWduZXQ7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdG9yKSkge1xuICAgICAgICBub2RlID0gdXRpbC5nZXRCeVBhdGgobWFnbmV0LCBzZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IGZpbmRTaGFwZU5vZGUobWFnbmV0KTtcbiAgICB9XG5cbiAgICBpZiAoIVYuaXNTVkdHcmFwaGljc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG1hZ25ldCB8fCAhVi5pc1NWR0dyYXBoaWNzRWxlbWVudChtYWduZXQpKSByZXR1cm4gYW5jaG9yO1xuICAgICAgICBub2RlID0gbWFnbmV0O1xuICAgIH1cblxuICAgIHZhciBsb2NhbFNoYXBlID0gdmlldy5nZXROb2RlU2hhcGUobm9kZSk7XG4gICAgdmFyIG1hZ25ldE1hdHJpeCA9IHZpZXcuZ2V0Tm9kZU1hdHJpeChub2RlKTtcbiAgICB2YXIgdHJhbnNsYXRlTWF0cml4ID0gdmlldy5nZXRSb290VHJhbnNsYXRlTWF0cml4KCk7XG4gICAgdmFyIHJvdGF0ZU1hdHJpeCA9IHZpZXcuZ2V0Um9vdFJvdGF0ZU1hdHJpeCgpO1xuICAgIHZhciB0YXJnZXRNYXRyaXggPSB0cmFuc2xhdGVNYXRyaXgubXVsdGlwbHkocm90YXRlTWF0cml4KS5tdWx0aXBseShtYWduZXRNYXRyaXgpO1xuICAgIHZhciBsb2NhbE1hdHJpeCA9IHRhcmdldE1hdHJpeC5pbnZlcnNlKCk7XG4gICAgdmFyIGxvY2FsTGluZSA9IFYudHJhbnNmb3JtTGluZShsaW5lLCBsb2NhbE1hdHJpeCk7XG4gICAgdmFyIGxvY2FsUmVmID0gbG9jYWxMaW5lLnN0YXJ0LmNsb25lKCk7XG4gICAgdmFyIGRhdGEgPSB2aWV3LmdldE5vZGVEYXRhKG5vZGUpO1xuXG4gICAgaWYgKG9wdC5pbnNpZGVvdXQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghZGF0YVtCTkRSX1NIQVBFX0JCT1hdKSBkYXRhW0JORFJfU0hBUEVfQkJPWF0gPSBsb2NhbFNoYXBlLmJib3goKTtcbiAgICAgICAgdmFyIGxvY2FsQkJveCA9IGRhdGFbQk5EUl9TSEFQRV9CQk9YXTtcbiAgICAgICAgaWYgKGxvY2FsQkJveC5jb250YWluc1BvaW50KGxvY2FsUmVmKSkgcmV0dXJuIGFuY2hvcjtcbiAgICB9XG5cbiAgICAvLyBDYWNoaW5nIHNlZ21lbnQgc3ViZGl2aXNpb25zIGZvciBwYXRoc1xuICAgIHZhciBwYXRoT3B0O1xuICAgIGlmIChsb2NhbFNoYXBlIGluc3RhbmNlb2YgZy5QYXRoKSB7XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBvcHQucHJlY2lzaW9uIHx8IDI7XG4gICAgICAgIGlmICghZGF0YVtCTkRSX1NVQkRJVklTSU9OU10pIGRhdGFbQk5EUl9TVUJESVZJU0lPTlNdID0gbG9jYWxTaGFwZS5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSk7XG4gICAgICAgIHBhdGhPcHQgPSB7XG4gICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgIHNlZ21lbnRTdWJkaXZpc2lvbnM6IGRhdGFbQk5EUl9TVUJESVZJU0lPTlNdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdC5leHRyYXBvbGF0ZSA9PT0gdHJ1ZSkgbG9jYWxMaW5lLnNldExlbmd0aCgxZTYpO1xuXG4gICAgaW50ZXJzZWN0aW9uID0gbG9jYWxMaW5lLmludGVyc2VjdChsb2NhbFNoYXBlLCBwYXRoT3B0KTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIC8vIE1vcmUgdGhhbiBvbmUgaW50ZXJzZWN0aW9uXG4gICAgICAgIGlmIChWLmlzQXJyYXkoaW50ZXJzZWN0aW9uKSkgaW50ZXJzZWN0aW9uID0gbG9jYWxSZWYuY2hvb3NlQ2xvc2VzdChpbnRlcnNlY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAob3B0LnN0aWNreSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb24sIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgaW5zdGVhZFxuICAgICAgICBpZiAobG9jYWxTaGFwZSBpbnN0YW5jZW9mIGcuUmVjdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gbG9jYWxTaGFwZS5wb2ludE5lYXJlc3RUb1BvaW50KGxvY2FsUmVmKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbFNoYXBlIGluc3RhbmNlb2YgZy5FbGxpcHNlKSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbFNoYXBlLmludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQobG9jYWxSZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gbG9jYWxTaGFwZS5jbG9zZXN0UG9pbnQobG9jYWxSZWYsIHBhdGhPcHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNwID0gKGludGVyc2VjdGlvbikgPyBWLnRyYW5zZm9ybVBvaW50KGludGVyc2VjdGlvbiwgdGFyZ2V0TWF0cml4KSA6IGFuY2hvcjtcbiAgICB2YXIgY3BPZmZzZXQgPSBvcHQub2Zmc2V0IHx8IDA7XG4gICAgaWYgKG9wdC5zdHJva2UpIGNwT2Zmc2V0ICs9IHN0cm9rZShub2RlKSAvIDI7XG5cbiAgICByZXR1cm4gb2Zmc2V0UG9pbnQoY3AsIGxpbmUuc3RhcnQsIGNwT2Zmc2V0KTtcbn1cblxuZXhwb3J0IGNvbnN0IGFuY2hvciA9IGFuY2hvckNvbm5lY3Rpb25Qb2ludDtcbmV4cG9ydCBjb25zdCBiYm94ID0gYmJveEludGVyc2VjdGlvbjtcbmV4cG9ydCBjb25zdCByZWN0YW5nbGUgPSByZWN0YW5nbGVJbnRlcnNlY3Rpb247XG5leHBvcnQgY29uc3QgYm91bmRhcnkgPSBib3VuZGFyeUludGVyc2VjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectionPoints/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectionStrategies/index.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectionStrategies/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pinAbsolute: () => (/* binding */ pinAbsolute),\n/* harmony export */   pinRelative: () => (/* binding */ pinRelative),\n/* harmony export */   useDefaults: () => (/* binding */ useDefaults)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\nfunction abs2rel(absolute, max) {\n\n    if (max === 0) return '0%';\n    // round to 3 decimal places\n    const dp = 1000;\n    const relative = Math.round(absolute / max * 100 * dp) / dp;\n    return `${relative}%`;\n}\n\nfunction pin(relative) {\n\n    return function(end, view, magnet, coords) {\n        var fn = (view.isNodeConnection(magnet)) ? pinnedLinkEnd : pinnedElementEnd;\n        return fn(relative, end, view, magnet, coords);\n    };\n}\n\nfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeUnrotatedBBox(magnet);\n    var origin = view.model.getBBox().center();\n    coords.rotate(origin, angle);\n    var dx = coords.x - bbox.x;\n    var dy = coords.y - bbox.y;\n\n    if (relative) {\n        dx = abs2rel(dx, bbox.width);\n        dy = abs2rel(dy, bbox.height);\n    }\n\n    end.anchor = {\n        name: 'topLeft',\n        args: {\n            dx: dx,\n            dy: dy,\n            rotate: true\n        }\n    };\n\n    return end;\n}\n\nfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\n    var connection = view.getConnection();\n    if (!connection) return end;\n    var length = connection.closestPointLength(coords);\n    if (relative) {\n        var totalLength = connection.length();\n        end.anchor = {\n            name: 'connectionRatio',\n            args: {\n                ratio: length / totalLength\n            }\n        };\n    } else {\n        end.anchor = {\n            name: 'connectionLength',\n            args: {\n                length: length\n            }\n        };\n    }\n    return end;\n}\n\nconst useDefaults = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\nconst pinAbsolute = pin(false);\nconst pinRelative = pin(true);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3Rpb25TdHJhdGVnaWVzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sb0JBQW9CLGlEQUFTO0FBQzdCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0aW9uU3RyYXRlZ2llcy9pbmRleC5tanM/ZWE2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gYWJzMnJlbChhYnNvbHV0ZSwgbWF4KSB7XG5cbiAgICBpZiAobWF4ID09PSAwKSByZXR1cm4gJzAlJztcbiAgICAvLyByb3VuZCB0byAzIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3QgZHAgPSAxMDAwO1xuICAgIGNvbnN0IHJlbGF0aXZlID0gTWF0aC5yb3VuZChhYnNvbHV0ZSAvIG1heCAqIDEwMCAqIGRwKSAvIGRwO1xuICAgIHJldHVybiBgJHtyZWxhdGl2ZX0lYDtcbn1cblxuZnVuY3Rpb24gcGluKHJlbGF0aXZlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZW5kLCB2aWV3LCBtYWduZXQsIGNvb3Jkcykge1xuICAgICAgICB2YXIgZm4gPSAodmlldy5pc05vZGVDb25uZWN0aW9uKG1hZ25ldCkpID8gcGlubmVkTGlua0VuZCA6IHBpbm5lZEVsZW1lbnRFbmQ7XG4gICAgICAgIHJldHVybiBmbihyZWxhdGl2ZSwgZW5kLCB2aWV3LCBtYWduZXQsIGNvb3Jkcyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGlubmVkRWxlbWVudEVuZChyZWxhdGl2ZSwgZW5kLCB2aWV3LCBtYWduZXQsIGNvb3Jkcykge1xuXG4gICAgdmFyIGFuZ2xlID0gdmlldy5tb2RlbC5hbmdsZSgpO1xuICAgIHZhciBiYm94ID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgIHZhciBvcmlnaW4gPSB2aWV3Lm1vZGVsLmdldEJCb3goKS5jZW50ZXIoKTtcbiAgICBjb29yZHMucm90YXRlKG9yaWdpbiwgYW5nbGUpO1xuICAgIHZhciBkeCA9IGNvb3Jkcy54IC0gYmJveC54O1xuICAgIHZhciBkeSA9IGNvb3Jkcy55IC0gYmJveC55O1xuXG4gICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgIGR4ID0gYWJzMnJlbChkeCwgYmJveC53aWR0aCk7XG4gICAgICAgIGR5ID0gYWJzMnJlbChkeSwgYmJveC5oZWlnaHQpO1xuICAgIH1cblxuICAgIGVuZC5hbmNob3IgPSB7XG4gICAgICAgIG5hbWU6ICd0b3BMZWZ0JyxcbiAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgZHg6IGR4LFxuICAgICAgICAgICAgZHk6IGR5LFxuICAgICAgICAgICAgcm90YXRlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGVuZDtcbn1cblxuZnVuY3Rpb24gcGlubmVkTGlua0VuZChyZWxhdGl2ZSwgZW5kLCB2aWV3LCBfbWFnbmV0LCBjb29yZHMpIHtcblxuICAgIHZhciBjb25uZWN0aW9uID0gdmlldy5nZXRDb25uZWN0aW9uKCk7XG4gICAgaWYgKCFjb25uZWN0aW9uKSByZXR1cm4gZW5kO1xuICAgIHZhciBsZW5ndGggPSBjb25uZWN0aW9uLmNsb3Nlc3RQb2ludExlbmd0aChjb29yZHMpO1xuICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICB2YXIgdG90YWxMZW5ndGggPSBjb25uZWN0aW9uLmxlbmd0aCgpO1xuICAgICAgICBlbmQuYW5jaG9yID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25SYXRpbycsXG4gICAgICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICAgICAgcmF0aW86IGxlbmd0aCAvIHRvdGFsTGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kLmFuY2hvciA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0aW9uTGVuZ3RoJyxcbiAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG5leHBvcnQgY29uc3QgdXNlRGVmYXVsdHMgPSB1dGlsLm5vb3A7XG5leHBvcnQgY29uc3QgcGluQWJzb2x1dGUgPSBwaW4oZmFsc2UpO1xuZXhwb3J0IGNvbnN0IHBpblJlbGF0aXZlID0gcGluKHRydWUpO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/curve.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/curve.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curve: () => (/* binding */ curve)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/curve.mjs\");\n\n\nconst Directions = {\n    AUTO: 'auto',\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst TangentDirections = {\n    UP: 'up',\n    DOWN: 'down',\n    LEFT: 'left',\n    RIGHT: 'right',\n    AUTO: 'auto',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.targetTangent) : null,\n        rotate: Boolean(opt.rotate)\n    };\n    if (typeof opt.sourceDirection === 'string')\n        options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === 'number')\n        options.sourceDirection = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0).rotate(null, opt.sourceDirection);\n    else\n        options.sourceDirection = opt.sourceDirection ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.sourceDirection).normalize() : null;\n\n    if (typeof opt.targetDirection === 'string')\n        options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === 'number')\n        options.targetDirection = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0).rotate(null, opt.targetDirection);\n    else\n        options.targetDirection = opt.targetDirection ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.targetDirection).normalize() : null;\n\n    const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p));\n\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n    const path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(bezierCurves).round(precision);\n\n    return (raw) ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.x > route[1].x)\n            sourceSide = 'right';\n        else\n            sourceSide = 'left';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.x > route[route.length - 2].x)\n            targetSide = 'left';\n        else\n            targetSide = 'right';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.y > route[1].y)\n            sourceSide = 'bottom';\n        else\n            sourceSide = 'top';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.y > route[route.length - 2].y)\n            targetSide = 'top';\n        else\n            targetSide = 'bottom';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n        case 'right':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n        case 'right':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch (options.sourceDirection) {\n            case TangentDirections.UP:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            case TangentDirections.DOWN:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            case TangentDirections.LEFT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch (options.targetDirection) {\n            case TangentDirections.UP:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            case TangentDirections.DOWN:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            case TangentDirections.LEFT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\n\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n\n    for (let i = 0; i < n; i++) {\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n\n    // The calculation of tangents of vertices\n    for (let i = 1; i < n; i++) {\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n\n        tangents[i] = [t1, t2];\n    }\n\n    // The building of a Catmull-Rom curve based of tangents of points\n    for (let i = 0; i < n; i++) {\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n\n        catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n    }\n    return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n\n    const bcp1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n    const bcp2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Curve(\n        points[1],\n        bcp1,\n        bcp2,\n        points[2]\n    );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvY3VydmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxxRUFBcUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQUs7QUFDcEQsK0NBQStDLCtDQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQUs7QUFDM0M7QUFDQSw0REFBNEQsK0NBQUs7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQ0FBSztBQUMzQztBQUNBLDREQUE0RCwrQ0FBSzs7QUFFakUsNEVBQTRFLCtDQUFLOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBSTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQ0FBSztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07O0FBRWxCLHFCQUFxQiwrQ0FBSztBQUMxQjtBQUNBOztBQUVBLHFCQUFxQiwrQ0FBSztBQUMxQjtBQUNBO0FBQ0EsZUFBZSwrQ0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0b3JzL2N1cnZlLm1qcz9kNmMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhdGgsIFBvaW50LCBDdXJ2ZSB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgRGlyZWN0aW9ucyA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgSE9SSVpPTlRBTDogJ2hvcml6b250YWwnLFxuICAgIFZFUlRJQ0FMOiAndmVydGljYWwnLFxuICAgIENMT1NFU1RfUE9JTlQ6ICdjbG9zZXN0LXBvaW50JyxcbiAgICBPVVRXQVJEUzogJ291dHdhcmRzJ1xufTtcblxuY29uc3QgVGFuZ2VudERpcmVjdGlvbnMgPSB7XG4gICAgVVA6ICd1cCcsXG4gICAgRE9XTjogJ2Rvd24nLFxuICAgIExFRlQ6ICdsZWZ0JyxcbiAgICBSSUdIVDogJ3JpZ2h0JyxcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgQ0xPU0VTVF9QT0lOVDogJ2Nsb3Nlc3QtcG9pbnQnLFxuICAgIE9VVFdBUkRTOiAnb3V0d2FyZHMnXG59O1xuXG5leHBvcnQgY29uc3QgY3VydmUgPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlID0gW10sIG9wdCA9IHt9LCBsaW5rVmlldykge1xuICAgIGNvbnN0IHJhdyA9IEJvb2xlYW4ob3B0LnJhdyk7XG4gICAgLy8gZGlzdGFuY2VDb2VmZmljaWVudCAtIGEgY29lZmZpY2llbnQgb2YgdGhlIHRhbmdlbnQgdmVjdG9yIGxlbmd0aCByZWxhdGl2ZSB0byB0aGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMuXG4gICAgLy8gYW5nbGVUYW5nZW50Q29lZmZpY2llbnQgLSBhIGNvZWZmaWNpZW50IG9mIHRoZSBlbmQgdGFuZ2VudHMgbGVuZ3RoIGluIHRoZSBjYXNlIG9mIGFuZ2xlcyBsYXJnZXIgdGhhbiA0NSBkZWdyZWVzLlxuICAgIC8vIHRlbnNpb24gLSBhIENhdG11bGwtUm9tIGN1cnZlIHRlbnNpb24gcGFyYW1ldGVyLlxuICAgIC8vIHNvdXJjZVRhbmdlbnQgLSBhIHRhbmdlbnQgdmVjdG9yIGFsb25nIHRoZSBjdXJ2ZSBhdCB0aGUgc291cmNlUG9pbnQuXG4gICAgLy8gc291cmNlRGlyZWN0aW9uIC0gYSB1bml0IGRpcmVjdGlvbiB2ZWN0b3IgYWxvbmcgdGhlIGN1cnZlIGF0IHRoZSBzb3VyY2VQb2ludC5cbiAgICAvLyB0YXJnZXRUYW5nZW50IC0gYSB0YW5nZW50IHZlY3RvciBhbG9uZyB0aGUgY3VydmUgYXQgdGhlIHRhcmdldFBvaW50LlxuICAgIC8vIHRhcmdldERpcmVjdGlvbiAtIGEgdW5pdCBkaXJlY3Rpb24gdmVjdG9yIGFsb25nIHRoZSBjdXJ2ZSBhdCB0aGUgdGFyZ2V0UG9pbnQuXG4gICAgLy8gcHJlY2lzaW9uIC0gYSByb3VuZGluZyBwcmVjaXNpb24gZm9yIHBhdGggdmFsdWVzLlxuICAgIGNvbnN0IHsgZGlyZWN0aW9uID0gRGlyZWN0aW9ucy5BVVRPLCBwcmVjaXNpb24gPSAzIH0gPSBvcHQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgY29lZmY6IG9wdC5kaXN0YW5jZUNvZWZmaWNpZW50IHx8IDAuNixcbiAgICAgICAgYW5nbGVUYW5nZW50Q29lZmZpY2llbnQ6IG9wdC5hbmdsZVRhbmdlbnRDb2VmZmljaWVudCB8fCA4MCxcbiAgICAgICAgdGF1OiBvcHQudGVuc2lvbiB8fCAwLjUsXG4gICAgICAgIHNvdXJjZVRhbmdlbnQ6IG9wdC5zb3VyY2VUYW5nZW50ID8gbmV3IFBvaW50KG9wdC5zb3VyY2VUYW5nZW50KSA6IG51bGwsXG4gICAgICAgIHRhcmdldFRhbmdlbnQ6IG9wdC50YXJnZXRUYW5nZW50ID8gbmV3IFBvaW50KG9wdC50YXJnZXRUYW5nZW50KSA6IG51bGwsXG4gICAgICAgIHJvdGF0ZTogQm9vbGVhbihvcHQucm90YXRlKVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHQuc291cmNlRGlyZWN0aW9uID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VEaXJlY3Rpb24gPSBvcHQuc291cmNlRGlyZWN0aW9uO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHQuc291cmNlRGlyZWN0aW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VEaXJlY3Rpb24gPSBuZXcgUG9pbnQoMSwgMCkucm90YXRlKG51bGwsIG9wdC5zb3VyY2VEaXJlY3Rpb24pO1xuICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VEaXJlY3Rpb24gPSBvcHQuc291cmNlRGlyZWN0aW9uID8gbmV3IFBvaW50KG9wdC5zb3VyY2VEaXJlY3Rpb24pLm5vcm1hbGl6ZSgpIDogbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0LnRhcmdldERpcmVjdGlvbiA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0RGlyZWN0aW9uID0gb3B0LnRhcmdldERpcmVjdGlvbjtcbiAgICBlbHNlIGlmICh0eXBlb2Ygb3B0LnRhcmdldERpcmVjdGlvbiA9PT0gJ251bWJlcicpXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0RGlyZWN0aW9uID0gbmV3IFBvaW50KDEsIDApLnJvdGF0ZShudWxsLCBvcHQudGFyZ2V0RGlyZWN0aW9uKTtcbiAgICBlbHNlXG4gICAgICAgIG9wdGlvbnMudGFyZ2V0RGlyZWN0aW9uID0gb3B0LnRhcmdldERpcmVjdGlvbiA/IG5ldyBQb2ludChvcHQudGFyZ2V0RGlyZWN0aW9uKS5ub3JtYWxpemUoKSA6IG51bGw7XG5cbiAgICBjb25zdCBjb21wbGV0ZVJvdXRlID0gW3NvdXJjZVBvaW50LCAuLi5yb3V0ZSwgdGFyZ2V0UG9pbnRdLm1hcChwID0+IG5ldyBQb2ludChwKSk7XG5cbiAgICAvLyBUaGUgY2FsY3VsYXRpb24gb2YgYSBzb3VyY2VUYW5nZW50XG4gICAgbGV0IHNvdXJjZVRhbmdlbnQ7XG4gICAgaWYgKG9wdGlvbnMuc291cmNlVGFuZ2VudCkge1xuICAgICAgICBzb3VyY2VUYW5nZW50ID0gb3B0aW9ucy5zb3VyY2VUYW5nZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZURpcmVjdGlvbiA9IGdldFNvdXJjZVRhbmdlbnREaXJlY3Rpb24obGlua1ZpZXcsIGNvbXBsZXRlUm91dGUsIGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHRhbmdlbnRMZW5ndGggPSBjb21wbGV0ZVJvdXRlWzBdLmRpc3RhbmNlKGNvbXBsZXRlUm91dGVbMV0pICogb3B0aW9ucy5jb2VmZjtcbiAgICAgICAgY29uc3QgcG9pbnRzVmVjdG9yID0gY29tcGxldGVSb3V0ZVsxXS5kaWZmZXJlbmNlKGNvbXBsZXRlUm91dGVbMF0pLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IGFuZ2xlQmV0d2VlblZlY3RvcnMoc291cmNlRGlyZWN0aW9uLCBwb2ludHNWZWN0b3IpO1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gNCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZExlbmd0aCA9IHRhbmdlbnRMZW5ndGggKyAoYW5nbGUgLSBNYXRoLlBJIC8gNCkgKiBvcHRpb25zLmFuZ2xlVGFuZ2VudENvZWZmaWNpZW50O1xuICAgICAgICAgICAgc291cmNlVGFuZ2VudCA9IHNvdXJjZURpcmVjdGlvbi5jbG9uZSgpLnNjYWxlKHVwZGF0ZWRMZW5ndGgsIHVwZGF0ZWRMZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlVGFuZ2VudCA9IHNvdXJjZURpcmVjdGlvbi5jbG9uZSgpLnNjYWxlKHRhbmdlbnRMZW5ndGgsIHRhbmdlbnRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGNhbGN1bGF0aW9uIG9mIGEgdGFyZ2V0VGFuZ2VudFxuICAgIGxldCB0YXJnZXRUYW5nZW50O1xuICAgIGlmIChvcHRpb25zLnRhcmdldFRhbmdlbnQpIHtcbiAgICAgICAgdGFyZ2V0VGFuZ2VudCA9IG9wdGlvbnMudGFyZ2V0VGFuZ2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXREaXJlY3Rpb24gPSBnZXRUYXJnZXRUYW5nZW50RGlyZWN0aW9uKGxpbmtWaWV3LCBjb21wbGV0ZVJvdXRlLCBkaXJlY3Rpb24sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBsYXN0ID0gY29tcGxldGVSb3V0ZS5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCB0YW5nZW50TGVuZ3RoID0gY29tcGxldGVSb3V0ZVtsYXN0IC0gMV0uZGlzdGFuY2UoY29tcGxldGVSb3V0ZVtsYXN0XSkgKiBvcHRpb25zLmNvZWZmO1xuICAgICAgICBjb25zdCBwb2ludHNWZWN0b3IgPSBjb21wbGV0ZVJvdXRlW2xhc3QgLSAxXS5kaWZmZXJlbmNlKGNvbXBsZXRlUm91dGVbbGFzdF0pLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IGFuZ2xlQmV0d2VlblZlY3RvcnModGFyZ2V0RGlyZWN0aW9uLCBwb2ludHNWZWN0b3IpO1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gNCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZExlbmd0aCA9IHRhbmdlbnRMZW5ndGggKyAoYW5nbGUgLSBNYXRoLlBJIC8gNCkgKiBvcHRpb25zLmFuZ2xlVGFuZ2VudENvZWZmaWNpZW50O1xuICAgICAgICAgICAgdGFyZ2V0VGFuZ2VudCA9IHRhcmdldERpcmVjdGlvbi5jbG9uZSgpLnNjYWxlKHVwZGF0ZWRMZW5ndGgsIHVwZGF0ZWRMZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0VGFuZ2VudCA9IHRhcmdldERpcmVjdGlvbi5jbG9uZSgpLnNjYWxlKHRhbmdlbnRMZW5ndGgsIHRhbmdlbnRMZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2F0bXVsbFJvbUN1cnZlcyA9IGNyZWF0ZUNhdG11bGxSb21DdXJ2ZXMoY29tcGxldGVSb3V0ZSwgc291cmNlVGFuZ2VudCwgdGFyZ2V0VGFuZ2VudCwgb3B0aW9ucyk7XG4gICAgY29uc3QgYmV6aWVyQ3VydmVzID0gY2F0bXVsbFJvbUN1cnZlcy5tYXAoY3VydmUgPT4gY2F0bXVsbFJvbVRvQmV6aWVyKGN1cnZlLCBvcHRpb25zKSk7XG4gICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKGJlemllckN1cnZlcykucm91bmQocHJlY2lzaW9uKTtcblxuICAgIHJldHVybiAocmF3KSA/IHBhdGggOiBwYXRoLnNlcmlhbGl6ZSgpO1xufTtcbmN1cnZlLkRpcmVjdGlvbnMgPSBEaXJlY3Rpb25zO1xuY3VydmUuVGFuZ2VudERpcmVjdGlvbnMgPSBUYW5nZW50RGlyZWN0aW9ucztcblxuZnVuY3Rpb24gZ2V0SG9yaXpvbnRhbFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcuc291cmNlVmlldykge1xuICAgICAgICBpZiAoc291cmNlQkJveC54ID4gcm91dGVbMV0ueClcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSAncmlnaHQnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gJ2xlZnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcuc291cmNlVmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy5zb3VyY2VWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnNvdXJjZVZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9pbnQgPSByb3V0ZVswXS5jbG9uZSgpO1xuICAgICAgICAgICAgc291cmNlUG9pbnQucm90YXRlKHNvdXJjZUJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0SG9yaXpvbnRhbFRhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRhcmdldEJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHRhcmdldFNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcudGFyZ2V0Vmlldykge1xuICAgICAgICBpZiAodGFyZ2V0QkJveC54ID4gcm91dGVbcm91dGUubGVuZ3RoIC0gMl0ueClcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSAnbGVmdCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcudGFyZ2V0Vmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy50YXJnZXRWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnRhcmdldFZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9pbnQgPSByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXS5jbG9uZSgpO1xuICAgICAgICAgICAgdGFyZ2V0UG9pbnQucm90YXRlKHRhcmdldEJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludCh0YXJnZXRQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gdGFyZ2V0QkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbcm91dGUubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHRhcmdldFNpZGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0VmVydGljYWxTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzb3VyY2VCQm94IH0gPSBsaW5rVmlldztcblxuICAgIGxldCBzb3VyY2VTaWRlO1xuICAgIGxldCByb3RhdGlvbjtcbiAgICBpZiAoIWxpbmtWaWV3LnNvdXJjZVZpZXcpIHtcbiAgICAgICAgaWYgKHNvdXJjZUJCb3gueSA+IHJvdXRlWzFdLnkpXG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gJ2JvdHRvbSc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSAndG9wJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGlvbiA9IGxpbmtWaWV3LnNvdXJjZVZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB1bnJvdGF0ZWRCQm94ID0gbGlua1ZpZXcuc291cmNlVmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChsaW5rVmlldy5zb3VyY2VWaWV3LmVsKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvaW50ID0gcm91dGVbMF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHNvdXJjZVBvaW50LnJvdGF0ZShzb3VyY2VCQm94LmNlbnRlcigpLCByb3RhdGlvbik7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gdW5yb3RhdGVkQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQoc291cmNlUG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlU2lkZSA9IHNvdXJjZUJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHJvdXRlWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkaXJlY3Rpb247XG4gICAgc3dpdGNoIChzb3VyY2VTaWRlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMCwgLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMCwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgZGlyZWN0aW9uLnJvdGF0ZShudWxsLCAtcm90YXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldFZlcnRpY2FsVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGFyZ2V0QkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgdGFyZ2V0U2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy50YXJnZXRWaWV3KSB7XG4gICAgICAgIGlmICh0YXJnZXRCQm94LnkgPiByb3V0ZVtyb3V0ZS5sZW5ndGggLSAyXS55KVxuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9ICd0b3AnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy50YXJnZXRWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnRhcmdldFZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcudGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb2ludCA9IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLmNsb25lKCk7XG4gICAgICAgICAgICB0YXJnZXRQb2ludC5yb3RhdGUodGFyZ2V0QkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGxldCBkaXJlY3Rpb247XG4gICAgc3dpdGNoICh0YXJnZXRTaWRlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMCwgLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMCwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgZGlyZWN0aW9uLnJvdGF0ZShudWxsLCAtcm90YXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldEF1dG9Tb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzb3VyY2VCQm94IH0gPSBsaW5rVmlldztcblxuICAgIGxldCBzb3VyY2VTaWRlO1xuICAgIGxldCByb3RhdGlvbjtcbiAgICBpZiAoIWxpbmtWaWV3LnNvdXJjZVZpZXcpIHtcbiAgICAgICAgc291cmNlU2lkZSA9IHNvdXJjZUJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHJvdXRlWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGlvbiA9IGxpbmtWaWV3LnNvdXJjZVZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB1bnJvdGF0ZWRCQm94ID0gbGlua1ZpZXcuc291cmNlVmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChsaW5rVmlldy5zb3VyY2VWaWV3LmVsKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvaW50ID0gcm91dGVbMF0uY2xvbmUoKTtcbiAgICAgICAgICAgIHNvdXJjZVBvaW50LnJvdGF0ZShzb3VyY2VCQm94LmNlbnRlcigpLCByb3RhdGlvbik7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gdW5yb3RhdGVkQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQoc291cmNlUG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlU2lkZSA9IHNvdXJjZUJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHJvdXRlWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkaXJlY3Rpb247XG4gICAgc3dpdGNoIChzb3VyY2VTaWRlKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMCwgLTEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMCwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KC0xLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b1RhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRhcmdldEJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHRhcmdldFNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcudGFyZ2V0Vmlldykge1xuICAgICAgICB0YXJnZXRTaWRlID0gdGFyZ2V0QkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbcm91dGUubGVuZ3RoIC0gMl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcudGFyZ2V0Vmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy50YXJnZXRWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnRhcmdldFZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9pbnQgPSByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXS5jbG9uZSgpO1xuICAgICAgICAgICAgdGFyZ2V0UG9pbnQucm90YXRlKHRhcmdldEJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludCh0YXJnZXRQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gdGFyZ2V0QkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbcm91dGUubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHRhcmdldFNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0UG9pbnRTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvdXRlWzFdLmRpZmZlcmVuY2Uocm91dGVbMF0pLm5vcm1hbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0UG9pbnRUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFzdCA9IHJvdXRlLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHJvdXRlW2xhc3QgLSAxXS5kaWZmZXJlbmNlKHJvdXRlW2xhc3RdKS5ub3JtYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0d2FyZHNTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBzb3VyY2VCQm94IH0gPSBsaW5rVmlldztcbiAgICBjb25zdCBzb3VyY2VDZW50ZXIgPSBzb3VyY2VCQm94LmNlbnRlcigpO1xuICAgIHJldHVybiByb3V0ZVswXS5kaWZmZXJlbmNlKHNvdXJjZUNlbnRlcikubm9ybWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIGdldE91dHdhcmRzVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGFyZ2V0QkJveCB9ID0gbGlua1ZpZXc7XG4gICAgY29uc3QgdGFyZ2V0Q2VudGVyID0gdGFyZ2V0QkJveC5jZW50ZXIoKTtcbiAgICByZXR1cm4gcm91dGVbcm91dGUubGVuZ3RoIC0gMV0uZGlmZmVyZW5jZSh0YXJnZXRDZW50ZXIpLm5vcm1hbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VUYW5nZW50RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuc291cmNlRGlyZWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5zb3VyY2VEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuVVA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkRPV046XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuTEVGVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KC0xLCAwKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuUklHSFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuQVVUTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXV0b1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5DTE9TRVNUX1BPSU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDbG9zZXN0UG9pbnRTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuT1VUV0FSRFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE91dHdhcmRzU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnNvdXJjZURpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5IT1JJWk9OVEFMOlxuICAgICAgICAgICAgcmV0dXJuIGdldEhvcml6b250YWxTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlZFUlRJQ0FMOlxuICAgICAgICAgICAgcmV0dXJuIGdldFZlcnRpY2FsU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5DTE9TRVNUX1BPSU5UOlxuICAgICAgICAgICAgcmV0dXJuIGdldENsb3Nlc3RQb2ludFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuT1VUV0FSRFM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0d2FyZHNTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkFVVE86XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXV0b1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0VGFuZ2VudERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnRhcmdldERpcmVjdGlvbikge1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbnMudGFyZ2V0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLlVQOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoMCwgLTEpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5ET1dOOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoMCwgMSk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkxFRlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLlJJR0hUOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoMSwgMCk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkFVVE86XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEF1dG9UYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuQ0xPU0VTVF9QT0lOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2xvc2VzdFBvaW50VGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLk9VVFdBUkRTOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRPdXR3YXJkc1RhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy50YXJnZXREaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuSE9SSVpPTlRBTDpcbiAgICAgICAgICAgIHJldHVybiBnZXRIb3Jpem9udGFsVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5WRVJUSUNBTDpcbiAgICAgICAgICAgIHJldHVybiBnZXRWZXJ0aWNhbFRhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuQ0xPU0VTVF9QT0lOVDpcbiAgICAgICAgICAgIHJldHVybiBnZXRDbG9zZXN0UG9pbnRUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLk9VVFdBUkRTOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHdhcmRzVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5BVVRPOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdldEF1dG9UYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJvdGF0ZVZlY3Rvcih2ZWN0b3IsIGFuZ2xlKSB7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB4ID0gY29zICogdmVjdG9yLnggLSBzaW4gKiB2ZWN0b3IueTtcbiAgICBjb25zdCB5ID0gc2luICogdmVjdG9yLnggKyBjb3MgKiB2ZWN0b3IueTtcbiAgICB2ZWN0b3IueCA9IHg7XG4gICAgdmVjdG9yLnkgPSB5O1xufVxuXG5mdW5jdGlvbiBhbmdsZUJldHdlZW5WZWN0b3JzKHYxLCB2Mikge1xuICAgIGxldCBjb3MgPSB2MS5kb3QodjIpIC8gKHYxLm1hZ25pdHVkZSgpICogdjIubWFnbml0dWRlKCkpO1xuICAgIGlmIChjb3MgPCAtMSkgY29zID0gLTE7XG4gICAgaWYgKGNvcyA+IDEpIGNvcyA9IDE7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3MpO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudCh2MSwgdjIpIHtcbiAgICByZXR1cm4gdjEueCAqIHYyLnkgLSB2MS55ICogdjIueDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2F0bXVsbFJvbUN1cnZlcyhwb2ludHMsIHNvdXJjZVRhbmdlbnQsIHRhcmdldFRhbmdlbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRhdSwgY29lZmYgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZGlzdGFuY2VzID0gW107XG4gICAgY29uc3QgdGFuZ2VudHMgPSBbXTtcbiAgICBjb25zdCBjYXRtdWxsUm9tQ3VydmVzID0gW107XG4gICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZGlzdGFuY2VzW2ldID0gcG9pbnRzW2ldLmRpc3RhbmNlKHBvaW50c1tpICsgMV0pO1xuICAgIH1cblxuICAgIHRhbmdlbnRzWzBdID0gc291cmNlVGFuZ2VudDtcbiAgICB0YW5nZW50c1tuXSA9IHRhcmdldFRhbmdlbnQ7XG5cbiAgICAvLyBUaGUgY2FsY3VsYXRpb24gb2YgdGFuZ2VudHMgb2YgdmVydGljZXNcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgdHBQcmV2O1xuICAgICAgICBsZXQgdHBOZXh0O1xuICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgdHBQcmV2ID0gcG9pbnRzW2kgLSAxXS5jbG9uZSgpLm9mZnNldCh0YW5nZW50c1tpIC0gMV0ueCwgdGFuZ2VudHNbaSAtIDFdLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHBQcmV2ID0gcG9pbnRzW2kgLSAxXS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBuIC0gMSkge1xuICAgICAgICAgICAgdHBOZXh0ID0gcG9pbnRzW2kgKyAxXS5jbG9uZSgpLm9mZnNldCh0YW5nZW50c1tpICsgMV0ueCwgdGFuZ2VudHNbaSArIDFdLnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHBOZXh0ID0gcG9pbnRzW2kgKyAxXS5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHYxID0gdHBQcmV2LmRpZmZlcmVuY2UocG9pbnRzW2ldKS5ub3JtYWxpemUoKTtcbiAgICAgICAgY29uc3QgdjIgPSB0cE5leHQuZGlmZmVyZW5jZShwb2ludHNbaV0pLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCB2QW5nbGUgPSBhbmdsZUJldHdlZW5WZWN0b3JzKHYxLCB2Mik7XG5cbiAgICAgICAgbGV0IHJvdCA9IChNYXRoLlBJIC0gdkFuZ2xlKSAvIDI7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBjb25zdCB2ZWN0b3JEZXRlcm1pbmFudCA9IGRldGVybWluYW50KHYxLCB2Mik7XG4gICAgICAgIGxldCBwb2ludHNEZXRlcm1pbmFudDtcbiAgICAgICAgcG9pbnRzRGV0ZXJtaW5hbnQgPSBkZXRlcm1pbmFudChwb2ludHNbaV0uZGlmZmVyZW5jZShwb2ludHNbaSArIDFdKSwgcG9pbnRzW2ldLmRpZmZlcmVuY2UocG9pbnRzW2kgLSAxXSkpO1xuICAgICAgICBpZiAodmVjdG9yRGV0ZXJtaW5hbnQgPCAwKSB7XG4gICAgICAgICAgICByb3QgPSAtcm90O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodkFuZ2xlIDwgTWF0aC5QSSAvIDIpICYmICgocm90IDwgMCAmJiBwb2ludHNEZXRlcm1pbmFudCA8IDApIHx8IChyb3QgPiAwICYmIHBvaW50c0RldGVybWluYW50ID4gMCkpKSB7XG4gICAgICAgICAgICByb3QgPSByb3QgLSBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIHQgPSB2Mi5jbG9uZSgpO1xuICAgICAgICByb3RhdGVWZWN0b3IodCwgcm90KTtcblxuICAgICAgICBjb25zdCB0MSA9IHQuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgdDIgPSB0LmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHNjYWxlRmFjdG9yMSA9IGRpc3RhbmNlc1tpIC0gMV0gKiBjb2VmZjtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IyID0gZGlzdGFuY2VzW2ldICogY29lZmY7XG4gICAgICAgIHQxLnNjYWxlKHNjYWxlRmFjdG9yMSwgc2NhbGVGYWN0b3IxKTtcbiAgICAgICAgdDIuc2NhbGUoc2NhbGVGYWN0b3IyLCBzY2FsZUZhY3RvcjIpO1xuXG4gICAgICAgIHRhbmdlbnRzW2ldID0gW3QxLCB0Ml07XG4gICAgfVxuXG4gICAgLy8gVGhlIGJ1aWxkaW5nIG9mIGEgQ2F0bXVsbC1Sb20gY3VydmUgYmFzZWQgb2YgdGFuZ2VudHMgb2YgcG9pbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGV0IHAwO1xuICAgICAgICBsZXQgcDM7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBwMCA9IHBvaW50c1tpICsgMV0uZGlmZmVyZW5jZSh0YW5nZW50c1tpXS54IC8gdGF1LCB0YW5nZW50c1tpXS55IC8gdGF1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAwID0gcG9pbnRzW2kgKyAxXS5kaWZmZXJlbmNlKHRhbmdlbnRzW2ldWzFdLnggLyB0YXUsIHRhbmdlbnRzW2ldWzFdLnkgLyB0YXUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSBuIC0gMSkge1xuICAgICAgICAgICAgcDMgPSBwb2ludHNbaV0uY2xvbmUoKS5vZmZzZXQodGFuZ2VudHNbaSArIDFdLnggLyB0YXUsIHRhbmdlbnRzW2kgKyAxXS55IC8gdGF1KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAzID0gcG9pbnRzW2ldLmRpZmZlcmVuY2UodGFuZ2VudHNbaSArIDFdWzBdLnggLyB0YXUsIHRhbmdlbnRzW2kgKyAxXVswXS55IC8gdGF1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhdG11bGxSb21DdXJ2ZXNbaV0gPSBbcDAsIHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgcDNdO1xuICAgIH1cbiAgICByZXR1cm4gY2F0bXVsbFJvbUN1cnZlcztcbn1cblxuLy8gVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQgQ2F0bXVsbC1Sb20gY3VydmUgdG8gQmV6aWVyIGN1cnZlIHVzaW5nIHRoZSB0ZW5zaW9uICh0YXUpXG5mdW5jdGlvbiBjYXRtdWxsUm9tVG9CZXppZXIocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0YXUgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiY3AxID0gbmV3IFBvaW50KCk7XG4gICAgYmNwMS54ID0gcG9pbnRzWzFdLnggKyAocG9pbnRzWzJdLnggLSBwb2ludHNbMF0ueCkgLyAoNiAqIHRhdSk7XG4gICAgYmNwMS55ID0gcG9pbnRzWzFdLnkgKyAocG9pbnRzWzJdLnkgLSBwb2ludHNbMF0ueSkgLyAoNiAqIHRhdSk7XG5cbiAgICBjb25zdCBiY3AyID0gbmV3IFBvaW50KCk7XG4gICAgYmNwMi54ID0gcG9pbnRzWzJdLnggKyAocG9pbnRzWzNdLnggLSBwb2ludHNbMV0ueCkgLyAoNiAqIHRhdSk7XG4gICAgYmNwMi55ID0gcG9pbnRzWzJdLnkgKyAocG9pbnRzWzNdLnkgLSBwb2ludHNbMV0ueSkgLyAoNiAqIHRhdSk7XG4gICAgcmV0dXJuIG5ldyBDdXJ2ZShcbiAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICBiY3AxLFxuICAgICAgICBiY3AyLFxuICAgICAgICBwb2ludHNbMl1cbiAgICApO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/curve.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curve: () => (/* reexport safe */ _curve_mjs__WEBPACK_IMPORTED_MODULE_5__.curve),\n/* harmony export */   jumpover: () => (/* reexport safe */ _jumpover_mjs__WEBPACK_IMPORTED_MODULE_1__.jumpover),\n/* harmony export */   normal: () => (/* reexport safe */ _normal_mjs__WEBPACK_IMPORTED_MODULE_2__.normal),\n/* harmony export */   rounded: () => (/* reexport safe */ _rounded_mjs__WEBPACK_IMPORTED_MODULE_3__.rounded),\n/* harmony export */   smooth: () => (/* reexport safe */ _smooth_mjs__WEBPACK_IMPORTED_MODULE_4__.smooth),\n/* harmony export */   straight: () => (/* reexport safe */ _straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/straight.mjs\");\n/* harmony import */ var _jumpover_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jumpover.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/jumpover.mjs\");\n/* harmony import */ var _normal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normal.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/normal.mjs\");\n/* harmony import */ var _rounded_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rounded.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/rounded.mjs\");\n/* harmony import */ var _smooth_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./smooth.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/smooth.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/curve.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNBO0FBQ0Y7QUFDQztBQUNEO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0b3JzL2luZGV4Lm1qcz9jODlhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vc3RyYWlnaHQubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vanVtcG92ZXIubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vbm9ybWFsLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL3JvdW5kZWQubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vc21vb3RoLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2N1cnZlLm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/jumpover.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/jumpover.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jumpover: () => (/* binding */ jumpover)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n\n\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\nfunction sortPointsAscending(p1, p2) {\n\n    let { x: x1, y: y1 } = p1;\n    let { x: x2, y: y2 } = p2;\n\n    if (x1 > x2) {\n\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    if (y1 > y2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    return [new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1), new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2)];\n}\n\nfunction overlapExists(line1, line2) {\n\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);\n\n    const xMatch = x1 <= x4 && x3 <= x2;\n    const yMatch = y1 <= y4 && y3 <= y2;\n\n    return xMatch && yMatch;\n}\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(lastLine.start, jumpStart),\n            jumpLine,\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nconst jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                const linkLinesToTest = linkLines[i].slice();\n                const overlapIndex = linkLinesToTest.findIndex((line) => overlapExists(thisLine, line));\n\n                // Overlap occurs and the end point of one segment lies on thisLine\n                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n                    // Remove the next segment because there will never be a jump\n                    linkLinesToTest.splice(overlapIndex + 1, 1);\n                }\n                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvanVtcG92ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTBDO0FBQ047O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxlQUFlOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLCtDQUFPLGNBQWMsK0NBQU87QUFDNUM7O0FBRUE7O0FBRUEsYUFBYSxjQUFjLElBQUksY0FBYztBQUM3QyxhQUFhLGNBQWMsSUFBSSxjQUFjOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhDQUFNO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0b3JzL2p1bXBvdmVyLm1qcz82NWVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbi8vIGRlZmF1bHQgc2l6ZSBvZiBqdW1wIGlmIG5vdCBzcGVjaWZpZWQgaW4gb3B0aW9uc1xudmFyIEpVTVBfU0laRSA9IDU7XG5cbi8vIGF2YWlsYWJsZSBqdW1wIHR5cGVzXG4vLyBmaXJzdCBvbmUgdGFrZW4gYXMgZGVmYXVsdFxudmFyIEpVTVBfVFlQRVMgPSBbJ2FyYycsICdnYXAnLCAnY3ViaWMnXTtcblxuLy8gZGVmYXVsdCByYWRpdXNcbnZhciBSQURJVVMgPSAwO1xuXG4vLyB0YWtlcyBjYXJlIG9mIG1hdGguIGVycm9yIGZvciBjYXNlIHdoZW4ganVtcCBpcyB0b28gY2xvc2UgdG8gZW5kIG9mIGxpbmVcbnZhciBDTE9TRV9QUk9YSU1JVFlfUEFERElORyA9IDE7XG5cbi8vIGxpc3Qgb2YgY29ubmVjdG9yIHR5cGVzIG5vdCB0byBqdW1wIG92ZXIuXG52YXIgSUdOT1JFRF9DT05ORUNUT1JTID0gWydzbW9vdGgnXTtcblxuLy8gaW50ZXJuYWwgY29uc3RhbnRzIGZvciByb3VuZCBzZWdtZW50XG52YXIgXzEzID0gMSAvIDM7XG52YXIgXzIzID0gMiAvIDM7XG5cbmZ1bmN0aW9uIHNvcnRQb2ludHNBc2NlbmRpbmcocDEsIHAyKSB7XG5cbiAgICBsZXQgeyB4OiB4MSwgeTogeTEgfSA9IHAxO1xuICAgIGxldCB7IHg6IHgyLCB5OiB5MiB9ID0gcDI7XG5cbiAgICBpZiAoeDEgPiB4Mikge1xuXG4gICAgICAgIGxldCBzd2FwID0geDE7XG4gICAgICAgIHgxID0geDI7XG4gICAgICAgIHgyID0gc3dhcDtcblxuICAgICAgICBzd2FwID0geTE7XG4gICAgICAgIHkxID0geTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICB9XG5cbiAgICBpZiAoeTEgPiB5Mikge1xuICAgICAgICBsZXQgc3dhcCA9IHgxO1xuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB4MiA9IHN3YXA7XG5cbiAgICAgICAgc3dhcCA9IHkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuZXcgZy5Qb2ludCh4MSwgeTEpLCBuZXcgZy5Qb2ludCh4MiwgeTIpXTtcbn1cblxuZnVuY3Rpb24gb3ZlcmxhcEV4aXN0cyhsaW5lMSwgbGluZTIpIHtcblxuICAgIGNvbnN0IFt7IHg6IHgxLCB5OiB5MSB9LCB7IHg6IHgyLCB5OiB5MiB9XSA9IHNvcnRQb2ludHNBc2NlbmRpbmcobGluZTEuc3RhcnQsIGxpbmUxLmVuZCk7XG4gICAgY29uc3QgW3sgeDogeDMsIHk6IHkzIH0sIHsgeDogeDQsIHk6IHk0IH1dID0gc29ydFBvaW50c0FzY2VuZGluZyhsaW5lMi5zdGFydCwgbGluZTIuZW5kKTtcblxuICAgIGNvbnN0IHhNYXRjaCA9IHgxIDw9IHg0ICYmIHgzIDw9IHgyO1xuICAgIGNvbnN0IHlNYXRjaCA9IHkxIDw9IHk0ICYmIHkzIDw9IHkyO1xuXG4gICAgcmV0dXJuIHhNYXRjaCAmJiB5TWF0Y2g7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHN0YXJ0L2VuZCBhbmQgcm91dGUgaW50byBzZXJpZXMgb2YgbGluZXNcbiAqIEBwYXJhbSB7Zy5wb2ludH0gc291cmNlUG9pbnQgc3RhcnQgcG9pbnRcbiAqIEBwYXJhbSB7Zy5wb2ludH0gdGFyZ2V0UG9pbnQgZW5kIHBvaW50XG4gKiBAcGFyYW0ge2cucG9pbnRbXX0gcm91dGUgb3B0aW9uYWwgbGlzdCBvZiByb3V0ZVxuICogQHJldHVybiB7Zy5saW5lW119IFtkZXNjcmlwdGlvbl1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGluZXMoc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZSkge1xuICAgIC8vIG1ha2UgYSBmbGF0dGVuZWQgYXJyYXkgb2YgYWxsIHBvaW50c1xuICAgIHZhciBwb2ludHMgPSBbXS5jb25jYXQoc291cmNlUG9pbnQsIHJvdXRlLCB0YXJnZXRQb2ludCk7XG4gICAgcmV0dXJuIHBvaW50cy5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0TGluZXMsIHBvaW50LCBpZHgpIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBuZXh0IHBvaW50LCBtYWtlIGEgbGluZSB3aXRoIGl0XG4gICAgICAgIHZhciBuZXh0UG9pbnQgPSBwb2ludHNbaWR4ICsgMV07XG4gICAgICAgIGlmIChuZXh0UG9pbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0TGluZXNbaWR4XSA9IGcubGluZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBzZXR1cFVwZGF0aW5nKGp1bXBPdmVyTGlua1ZpZXcpIHtcbiAgICB2YXIgcGFwZXIgPSBqdW1wT3ZlckxpbmtWaWV3LnBhcGVyO1xuICAgIHZhciB1cGRhdGVMaXN0ID0gcGFwZXIuX2p1bXBPdmVyVXBkYXRlTGlzdDtcblxuICAgIC8vIGZpcnN0IHRpbWUgc2V0dXAgZm9yIHRoaXMgcGFwZXJcbiAgICBpZiAodXBkYXRlTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUxpc3QgPSBwYXBlci5fanVtcE92ZXJVcGRhdGVMaXN0ID0gW107XG4gICAgICAgIHZhciBncmFwaCA9IHBhcGVyLm1vZGVsO1xuICAgICAgICBncmFwaC5vbignYmF0Y2g6c3RvcCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQWN0aXZlQmF0Y2goKSkgcmV0dXJuO1xuICAgICAgICAgICAgdXBkYXRlSnVtcE92ZXIocGFwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JhcGgub24oJ3Jlc2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1cGRhdGVMaXN0ID0gcGFwZXIuX2p1bXBPdmVyVXBkYXRlTGlzdCA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdGhpcyBsaW5rIHRvIGEgbGlzdCBzbyBpdCBjYW4gYmUgdXBkYXRlZCB3aGVuIHNvbWUgb3RoZXIgbGluayBpcyB1cGRhdGVkXG4gICAgaWYgKHVwZGF0ZUxpc3QuaW5kZXhPZihqdW1wT3ZlckxpbmtWaWV3KSA8IDApIHtcbiAgICAgICAgdXBkYXRlTGlzdC5wdXNoKGp1bXBPdmVyTGlua1ZpZXcpO1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2Ugb2YgY29ubmVjdG9yIHR5cGUgb3IgcmVtb3ZhbCBvZiBsaW5rIGl0c2VsZlxuICAgICAgICAvLyB0byByZW1vdmUgdGhlIGxpbmsgZnJvbSBhIGxpc3Qgb2YganVtcCBvdmVyIGNvbm5lY3RvcnNcbiAgICAgICAganVtcE92ZXJMaW5rVmlldy5saXN0ZW5Ub09uY2UoanVtcE92ZXJMaW5rVmlldy5tb2RlbCwgJ2NoYW5nZTpjb25uZWN0b3IgcmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1cGRhdGVMaXN0LnNwbGljZSh1cGRhdGVMaXN0LmluZGV4T2YoanVtcE92ZXJMaW5rVmlldyksIDEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogSGFuZGxlciBmb3IgYSBiYXRjaDpzdG9wIGV2ZW50IHRvIGZvcmNlXG4gKiB1cGRhdGUgb2YgYWxsIHJlZ2lzdGVyZWQgbGlua3Mgd2l0aCBqdW1wIG92ZXIgY29ubmVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gYmF0Y2hFdmVudCBvcHRpb25hbCBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGJhdGNoXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUp1bXBPdmVyKHBhcGVyKSB7XG4gICAgdmFyIHVwZGF0ZUxpc3QgPSBwYXBlci5fanVtcE92ZXJVcGRhdGVMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5rVmlldyA9IHVwZGF0ZUxpc3RbaV07XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZsYWcgPSBsaW5rVmlldy5nZXRGbGFnKGxpbmtWaWV3LmNvbnN0cnVjdG9yLkZsYWdzLkNPTk5FQ1RPUik7XG4gICAgICAgIGxpbmtWaWV3LnJlcXVlc3RVcGRhdGUodXBkYXRlRmxhZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY29sbGVjdCBhbGwgaW50ZXJzZWN0aW9uIHBvaW50cyBvZiBhIHNpbmdsZVxuICogbGluZSBhZ2FpbnN0IGdyb3VwIG9mIG90aGVyIGxpbmVzLlxuICogQHBhcmFtIHtnLmxpbmV9IGxpbmUgd2hlcmUgdG8gZmluZCBwb2ludHNcbiAqIEBwYXJhbSB7Zy5saW5lW119IGNyb3NzQ2hlY2tMaW5lcyBsaW5lcyB0byBjcm9zc1xuICogQHJldHVybiB7Zy5wb2ludFtdfSBsaXN0IG9mIGludGVyc2VjdGlvbiBwb2ludHNcbiAqL1xuZnVuY3Rpb24gZmluZExpbmVJbnRlcnNlY3Rpb25zKGxpbmUsIGNyb3NzQ2hlY2tMaW5lcykge1xuICAgIHJldHVybiB1dGlsLnRvQXJyYXkoY3Jvc3NDaGVja0xpbmVzKS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBjcm9zc0NoZWNrTGluZSkge1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbGluZS5pbnRlcnNlY3Rpb24oY3Jvc3NDaGVja0xpbmUpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICByZXMucHVzaChpbnRlcnNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xufVxuXG4vKipcbiAqIFNvcnRpbmcgZnVuY3Rpb24gZm9yIGxpc3Qgb2YgcG9pbnRzIGJ5IHRoZWlyIGRpc3RhbmNlLlxuICogQHBhcmFtIHtnLnBvaW50fSBwMSBmaXJzdCBwb2ludFxuICogQHBhcmFtIHtnLnBvaW50fSBwMiBzZWNvbmQgcG9pbnRcbiAqIEByZXR1cm4ge251bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICovXG5mdW5jdGlvbiBzb3J0UG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBnLmxpbmUocDEsIHAyKS5zcXVhcmVkTGVuZ3RoKCk7XG59XG5cbi8qKlxuICogU3BsaXQgaW5wdXQgbGluZSBpbnRvIG11bHRpcGxlIGJhc2VkIG9uIGludGVyc2VjdGlvbiBwb2ludHMuXG4gKiBAcGFyYW0ge2cubGluZX0gbGluZSBpbnB1dCBsaW5lIHRvIHNwbGl0XG4gKiBAcGFyYW0ge2cucG9pbnRbXX0gaW50ZXJzZWN0aW9ucyBwb2ludHMgd2hlcmUgdG8gc3BsaXQgdGhlIGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBqdW1wU2l6ZSB0aGUgc2l6ZSBvZiBqdW1wIGFyYyAobGVuZ3RoIGVtcHR5IHNwb3Qgb24gYSBsaW5lKVxuICogQHJldHVybiB7Zy5saW5lW119IGxpc3Qgb2YgbGluZXMgYmVpbmcgc3BsaXRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSnVtcHMobGluZSwgaW50ZXJzZWN0aW9ucywganVtcFNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0TGluZXMsIHBvaW50LCBpZHgpIHtcbiAgICAgICAgLy8gc2tpcHBpbmcgcG9pbnRzIHRoYXQgd2VyZSBtZXJnZWQgd2l0aCB0aGUgcHJldmlvdXMgbGluZVxuICAgICAgICAvLyB0byBtYWtlIGJpZ2dlciBhcmMgb3ZlciBtdWx0aXBsZSBsaW5lcyB0aGF0IGFyZSBjbG9zZSB0byBlYWNoIG90aGVyXG4gICAgICAgIGlmIChwb2ludC5za2lwID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHdheXMgZ3JhYiB0aGUgbGFzdCBsaW5lIGZyb20gYnVmZmVyIGFuZCBtb2RpZnkgaXRcbiAgICAgICAgdmFyIGxhc3RMaW5lID0gcmVzdWx0TGluZXMucG9wKCkgfHwgbGluZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgc3RhcnQgYW5kIGVuZCBvZiBqdW1wIGJ5IG1vdmluZyBieSBhIGdpdmVuIHNpemUgb2YganVtcFxuICAgICAgICB2YXIganVtcFN0YXJ0ID0gZy5wb2ludChwb2ludCkubW92ZShsYXN0TGluZS5zdGFydCwgLShqdW1wU2l6ZSkpO1xuICAgICAgICB2YXIganVtcEVuZCA9IGcucG9pbnQocG9pbnQpLm1vdmUobGFzdExpbmUuc3RhcnQsICsoanVtcFNpemUpKTtcblxuICAgICAgICAvLyBub3cgdHJ5IHRvIGxvb2sgYXQgdGhlIG5leHQgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIHZhciBuZXh0UG9pbnQgPSBpbnRlcnNlY3Rpb25zW2lkeCArIDFdO1xuICAgICAgICBpZiAobmV4dFBvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGp1bXBFbmQuZGlzdGFuY2UobmV4dFBvaW50KTtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8PSBqdW1wU2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgcG9pbnQgaXMgY2xvc2UgZW5vdWdoLCBtb3ZlIHRoZSBqdW1wIGVuZCBieSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBhbmQgbWFyayB0aGUgbmV4dCBwb2ludCB0byBiZSBza2lwcGVkXG4gICAgICAgICAgICAgICAganVtcEVuZCA9IG5leHRQb2ludC5tb3ZlKGxhc3RMaW5lLnN0YXJ0LCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50LnNraXAgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBibG9jayBpcyBpbnNpZGUgb2YgYGVsc2VgIGFzIGFuIG9wdGltaXphdGlvbiBzbyB0aGUgZGlzdGFuY2UgaXNcbiAgICAgICAgICAgIC8vIG5vdCBjYWxjdWxhdGVkIHdoZW4gd2Uga25vdyB0aGVyZSBhcmUgbm8gb3RoZXIgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgICAgICAgICAgdmFyIGVuZERpc3RhbmNlID0ganVtcFN0YXJ0LmRpc3RhbmNlKGxhc3RMaW5lLmVuZCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZW5kIGlzIHRvbyBjbG9zZSB0byBwb3NzaWJsZSBqdW1wLCBkcmF3IHJlbWFpbmluZyBsaW5lIGluc3RlYWQgb2YgYSBqdW1wXG4gICAgICAgICAgICBpZiAoZW5kRGlzdGFuY2UgPCBqdW1wU2l6ZSAqIDIgKyBDTE9TRV9QUk9YSU1JVFlfUEFERElORykge1xuICAgICAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2gobGFzdExpbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMaW5lcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydERpc3RhbmNlID0ganVtcEVuZC5kaXN0YW5jZShsYXN0TGluZS5zdGFydCk7XG4gICAgICAgIGlmIChzdGFydERpc3RhbmNlIDwganVtcFNpemUgKiAyICsgQ0xPU0VfUFJPWElNSVRZX1BBRERJTkcpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGFydCBvZiBsaW5lIGlzIHRvbyBjbG9zZSB0byBqdW1wLCBkcmF3IHRoYXQgbGluZSBpbnN0ZWFkIG9mIGEganVtcFxuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaChsYXN0TGluZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IGNyZWF0ZSBhIGp1bXAgbGluZVxuICAgICAgICB2YXIganVtcExpbmUgPSBnLmxpbmUoanVtcFN0YXJ0LCBqdW1wRW5kKTtcbiAgICAgICAgLy8gaXQncyBqdXN0IHNpbXBsZSBsaW5lIGJ1dCB3aXRoIGEgYGlzSnVtcGAgcHJvcGVydHlcbiAgICAgICAganVtcExpbmUuaXNKdW1wID0gdHJ1ZTtcblxuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKFxuICAgICAgICAgICAgZy5saW5lKGxhc3RMaW5lLnN0YXJ0LCBqdW1wU3RhcnQpLFxuICAgICAgICAgICAganVtcExpbmUsXG4gICAgICAgICAgICBnLmxpbmUoanVtcEVuZCwgbGFzdExpbmUuZW5kKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgfSwgW10pO1xufVxuXG4vKipcbiAqIEFzc2VtYmxlIGBEYCBhdHRyaWJ1dGUgb2YgYSBTVkcgcGF0aCBieSBpdGVyYXRpbmcgZ2l2ZW4gbGluZXMuXG4gKiBAcGFyYW0ge2cubGluZVtdfSBsaW5lcyBzb3VyY2UgbGluZXMgdG8gdXNlXG4gKiBAcGFyYW0ge251bWJlcn0ganVtcFNpemUgdGhlIHNpemUgb2YganVtcCBhcmMgKGxlbmd0aCBlbXB0eSBzcG90IG9uIGEgbGluZSlcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgdGhlIHJhZGl1c1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBidWlsZFBhdGgobGluZXMsIGp1bXBTaXplLCBqdW1wVHlwZSwgcmFkaXVzKSB7XG5cbiAgICB2YXIgcGF0aCA9IG5ldyBnLlBhdGgoKTtcbiAgICB2YXIgc2VnbWVudDtcblxuICAgIC8vIGZpcnN0IG1vdmUgdG8gdGhlIHN0YXJ0IG9mIGEgZmlyc3QgbGluZVxuICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnTScsIGxpbmVzWzBdLnN0YXJ0KTtcbiAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAvLyBtYWtlIGEgcGF0aHMgZnJvbSBsaW5lc1xuICAgIHV0aWwudG9BcnJheShsaW5lcykuZm9yRWFjaChmdW5jdGlvbihsaW5lLCBpbmRleCkge1xuXG4gICAgICAgIGlmIChsaW5lLmlzSnVtcCkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlLCBkaWZmO1xuXG4gICAgICAgICAgICB2YXIgY29udHJvbDEsIGNvbnRyb2wyO1xuXG4gICAgICAgICAgICBpZiAoanVtcFR5cGUgPT09ICdhcmMnKSB7IC8vIGFwcHJveGltYXRlcyBzZW1pY2lyY2xlIHdpdGggMiBjdXJ2ZXNcbiAgICAgICAgICAgICAgICBhbmdsZSA9IC05MDtcbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgcm90YXRpb24gb2YgYXJjIGJhc2VkIG9uIGRpZmZlcmVuY2UgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgICAgICBkaWZmID0gbGluZS5zdGFydC5kaWZmZXJlbmNlKGxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGFyYyBhbHdheXMgcG9pbnRzIHVwIChvciByaWdodClcbiAgICAgICAgICAgICAgICB2YXIgeEF4aXNSb3RhdGUgPSBOdW1iZXIoKGRpZmYueCA8IDApIHx8IChkaWZmLnggPT09IDAgJiYgZGlmZi55IDwgMCkpO1xuICAgICAgICAgICAgICAgIGlmICh4QXhpc1JvdGF0ZSkgYW5nbGUgKz0gMTgwO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1pZHBvaW50ID0gbGluZS5taWRwb2ludCgpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJMaW5lID0gbmV3IGcuTGluZShtaWRwb2ludCwgbGluZS5lbmQpLnJvdGF0ZShtaWRwb2ludCwgYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZMaW5lO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgaGFsZlxuICAgICAgICAgICAgICAgIGhhbGZMaW5lID0gbmV3IGcuTGluZShsaW5lLnN0YXJ0LCBtaWRwb2ludCk7XG5cbiAgICAgICAgICAgICAgICBjb250cm9sMSA9IGhhbGZMaW5lLnBvaW50QXQoMiAvIDMpLnJvdGF0ZShsaW5lLnN0YXJ0LCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgY29udHJvbDIgPSBjZW50ZXJMaW5lLnBvaW50QXQoMSAvIDMpLnJvdGF0ZShjZW50ZXJMaW5lLmVuZCwgLWFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2wxLCBjb250cm9sMiwgY2VudGVyTGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIHNlY29uZCBoYWxmXG4gICAgICAgICAgICAgICAgaGFsZkxpbmUgPSBuZXcgZy5MaW5lKG1pZHBvaW50LCBsaW5lLmVuZCk7XG5cbiAgICAgICAgICAgICAgICBjb250cm9sMSA9IGNlbnRlckxpbmUucG9pbnRBdCgxIC8gMykucm90YXRlKGNlbnRlckxpbmUuZW5kLCBhbmdsZSk7XG4gICAgICAgICAgICAgICAgY29udHJvbDIgPSBoYWxmTGluZS5wb2ludEF0KDEgLyAzKS5yb3RhdGUobGluZS5lbmQsIC1hbmdsZSk7XG5cbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBjb250cm9sMSwgY29udHJvbDIsIGxpbmUuZW5kKTtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoanVtcFR5cGUgPT09ICdnYXAnKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgbGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChqdW1wVHlwZSA9PT0gJ2N1YmljJykgeyAvLyBhcHByb3hpbWF0ZXMgc2VtaWNpcmNsZSB3aXRoIDEgY3VydmVcbiAgICAgICAgICAgICAgICBhbmdsZSA9IGxpbmUuc3RhcnQudGhldGEobGluZS5lbmQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHhPZmZzZXQgPSBqdW1wU2l6ZSAqIDAuNjtcbiAgICAgICAgICAgICAgICB2YXIgeU9mZnNldCA9IGp1bXBTaXplICogMS4zNTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSByb3RhdGlvbiBvZiBhcmMgYmFzZWQgb24gZGlmZmVyZW5jZSBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgICAgICAgIGRpZmYgPSBsaW5lLnN0YXJ0LmRpZmZlcmVuY2UobGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYXJjIGFsd2F5cyBwb2ludHMgdXAgKG9yIHJpZ2h0KVxuICAgICAgICAgICAgICAgIHhBeGlzUm90YXRlID0gTnVtYmVyKChkaWZmLnggPCAwKSB8fCAoZGlmZi54ID09PSAwICYmIGRpZmYueSA8IDApKTtcbiAgICAgICAgICAgICAgICBpZiAoeEF4aXNSb3RhdGUpIHlPZmZzZXQgKj0gLTE7XG5cbiAgICAgICAgICAgICAgICBjb250cm9sMSA9IGcuUG9pbnQobGluZS5zdGFydC54ICsgeE9mZnNldCwgbGluZS5zdGFydC55ICsgeU9mZnNldCkucm90YXRlKGxpbmUuc3RhcnQsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb250cm9sMiA9IGcuUG9pbnQobGluZS5lbmQueCAtIHhPZmZzZXQsIGxpbmUuZW5kLnkgKyB5T2Zmc2V0KS5yb3RhdGUobGluZS5lbmQsIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2wxLCBjb250cm9sMiwgbGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHRMaW5lID0gbGluZXNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIGlmIChyYWRpdXMgPT0gMCB8fCAhbmV4dExpbmUgfHwgbmV4dExpbmUuaXNKdW1wKSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdMJywgbGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVpbGRSb3VuZGVkU2VnbWVudChyYWRpdXMsIHBhdGgsIGxpbmUuZW5kLCBsaW5lLnN0YXJ0LCBuZXh0TGluZS5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gYnVpbGRSb3VuZGVkU2VnbWVudChvZmZzZXQsIHBhdGgsIGN1cnIsIHByZXYsIG5leHQpIHtcbiAgICB2YXIgcHJldkRpc3RhbmNlID0gY3Vyci5kaXN0YW5jZShwcmV2KSAvIDI7XG4gICAgdmFyIG5leHREaXN0YW5jZSA9IGN1cnIuZGlzdGFuY2UobmV4dCkgLyAyO1xuXG4gICAgdmFyIHN0YXJ0TW92ZSA9IC1NYXRoLm1pbihvZmZzZXQsIHByZXZEaXN0YW5jZSk7XG4gICAgdmFyIGVuZE1vdmUgPSAtTWF0aC5taW4ob2Zmc2V0LCBuZXh0RGlzdGFuY2UpO1xuXG4gICAgdmFyIHJvdW5kZWRTdGFydCA9IGN1cnIuY2xvbmUoKS5tb3ZlKHByZXYsIHN0YXJ0TW92ZSkucm91bmQoKTtcbiAgICB2YXIgcm91bmRlZEVuZCA9IGN1cnIuY2xvbmUoKS5tb3ZlKG5leHQsIGVuZE1vdmUpLnJvdW5kKCk7XG5cbiAgICB2YXIgY29udHJvbDEgPSBuZXcgZy5Qb2ludCgoXzEzICogcm91bmRlZFN0YXJ0LngpICsgKF8yMyAqIGN1cnIueCksIChfMjMgKiBjdXJyLnkpICsgKF8xMyAqIHJvdW5kZWRTdGFydC55KSk7XG4gICAgdmFyIGNvbnRyb2wyID0gbmV3IGcuUG9pbnQoKF8xMyAqIHJvdW5kZWRFbmQueCkgKyAoXzIzICogY3Vyci54KSwgKF8yMyAqIGN1cnIueSkgKyAoXzEzICogcm91bmRlZEVuZC55KSk7XG5cbiAgICB2YXIgc2VnbWVudDtcbiAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCByb3VuZGVkU3RhcnQpO1xuICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2wxLCBjb250cm9sMiwgcm91bmRlZEVuZCk7XG4gICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xufVxuXG4vKipcbiAqIEFjdHVhbCBjb25uZWN0b3IgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJ1biBvbiBldmVyeSB1cGRhdGUuXG4gKiBAcGFyYW0ge2cucG9pbnR9IHNvdXJjZVBvaW50IHN0YXJ0IHBvaW50IG9mIHRoaXMgbGlua1xuICogQHBhcmFtIHtnLnBvaW50fSB0YXJnZXRQb2ludCBlbmQgcG9pbnQgb2YgdGhpcyBsaW5rXG4gKiBAcGFyYW0ge2cucG9pbnRbXX0gcm91dGUgb2YgdGhpcyBsaW5rXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0IG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaXplIG9wdGlvbmFsIHNpemUgb2YgYSBqdW1wIGFyY1xuICogQHJldHVybiB7c3RyaW5nfSBjcmVhdGVkIGBEYCBhdHRyaWJ1dGUgb2YgU1ZHIHBhdGhcbiAqL1xuZXhwb3J0IGNvbnN0IGp1bXBvdmVyID0gZnVuY3Rpb24oc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZSwgb3B0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LXBhcmFtc1xuXG4gICAgc2V0dXBVcGRhdGluZyh0aGlzKTtcblxuICAgIHZhciByYXcgPSBvcHQucmF3O1xuICAgIHZhciBqdW1wU2l6ZSA9IG9wdC5zaXplIHx8IEpVTVBfU0laRTtcbiAgICB2YXIganVtcFR5cGUgPSBvcHQuanVtcCAmJiAoJycgKyBvcHQuanVtcCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgcmFkaXVzID0gb3B0LnJhZGl1cyB8fCBSQURJVVM7XG4gICAgdmFyIGlnbm9yZUNvbm5lY3RvcnMgPSBvcHQuaWdub3JlQ29ubmVjdG9ycyB8fCBJR05PUkVEX0NPTk5FQ1RPUlM7XG5cbiAgICAvLyBncmFiIHRoZSBmaXJzdCBqdW1wIHR5cGUgYXMgYSBkZWZhdWx0IGlmIHNwZWNpZmllZCBvbmUgaXMgaW52YWxpZFxuICAgIGlmIChKVU1QX1RZUEVTLmluZGV4T2YoanVtcFR5cGUpID09PSAtMSkge1xuICAgICAgICBqdW1wVHlwZSA9IEpVTVBfVFlQRVNbMF07XG4gICAgfVxuXG4gICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICB2YXIgZ3JhcGggPSBwYXBlci5tb2RlbDtcbiAgICB2YXIgYWxsTGlua3MgPSBncmFwaC5nZXRMaW5rcygpO1xuXG4gICAgLy8gdGhlcmUgaXMganVzdCBvbmUgbGluaywgZHJhdyBpdCBkaXJlY3RseVxuICAgIGlmIChhbGxMaW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkUGF0aChcbiAgICAgICAgICAgIGNyZWF0ZUxpbmVzKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUpLFxuICAgICAgICAgICAganVtcFNpemUsIGp1bXBUeXBlLCByYWRpdXNcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICB2YXIgdGhpc0luZGV4ID0gYWxsTGlua3MuaW5kZXhPZih0aGlzTW9kZWwpO1xuICAgIHZhciBkZWZhdWx0Q29ubmVjdG9yID0gcGFwZXIub3B0aW9ucy5kZWZhdWx0Q29ubmVjdG9yIHx8IHt9O1xuXG4gICAgLy8gbm90IGFsbCBsaW5rcyBhcmUgbWVhbnQgdG8gYmUganVtcGVkIG92ZXIuXG4gICAgdmFyIGxpbmtzID0gYWxsTGlua3MuZmlsdGVyKGZ1bmN0aW9uKGxpbmssIGlkeCkge1xuXG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBsaW5rLmdldCgnY29ubmVjdG9yJykgfHwgZGVmYXVsdENvbm5lY3RvcjtcblxuICAgICAgICAvLyBhdm9pZCBqdW1waW5nIG92ZXIgbGlua3Mgd2l0aCBjb25uZWN0b3IgdHlwZSBsaXN0ZWQgaW4gYGlnbm9yZWQgY29ubmVjdG9yc2AuXG4gICAgICAgIGlmICh1dGlsLnRvQXJyYXkoaWdub3JlQ29ubmVjdG9ycykuaW5jbHVkZXMoY29ubmVjdG9yLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCBsaW5rcyB0aGF0IGFyZSBhYm92ZSB0aGlzIG9uZSBhbmQgIGhhdmUgdGhlIHNhbWUgY29ubmVjdG9yIHR5cGVcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZXJlIHdvdWxkIGRvdWJsZSBob29wcyBmb3IgZWFjaCBpbnRlcnNlY3Rpb25cbiAgICAgICAgaWYgKGlkeCA+IHRoaXNJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rvci5uYW1lICE9PSAnanVtcG92ZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gZmluZCB2aWV3cyBmb3IgYWxsIGxpbmtzXG4gICAgdmFyIGxpbmtWaWV3cyA9IGxpbmtzLm1hcChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgIHJldHVybiBwYXBlci5maW5kVmlld0J5TW9kZWwobGluayk7XG4gICAgfSk7XG5cbiAgICAvLyBjcmVhdGUgbGluZXMgZm9yIHRoaXMgbGlua1xuICAgIHZhciB0aGlzTGluZXMgPSBjcmVhdGVMaW5lcyhcbiAgICAgICAgc291cmNlUG9pbnQsXG4gICAgICAgIHRhcmdldFBvaW50LFxuICAgICAgICByb3V0ZVxuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgbGluZXMgZm9yIGFsbCBvdGhlciBsaW5rc1xuICAgIHZhciBsaW5rTGluZXMgPSBsaW5rVmlld3MubWFwKGZ1bmN0aW9uKGxpbmtWaWV3KSB7XG4gICAgICAgIGlmIChsaW5rVmlldyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmtWaWV3ID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc0xpbmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVMaW5lcyhcbiAgICAgICAgICAgIGxpbmtWaWV3LnNvdXJjZVBvaW50LFxuICAgICAgICAgICAgbGlua1ZpZXcudGFyZ2V0UG9pbnQsXG4gICAgICAgICAgICBsaW5rVmlldy5yb3V0ZVxuICAgICAgICApO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gdHJhbnNmb3JtIGxpbmVzIGZvciB0aGlzIGxpbmsgYnkgc3BsaXR0aW5nIHdpdGgganVtcCBsaW5lcyBhdFxuICAgIC8vIHBvaW50cyBvZiBpbnRlcnNlY3Rpb24gd2l0aCBvdGhlciBsaW5rc1xuICAgIHZhciBqdW1waW5nTGluZXMgPSB0aGlzTGluZXMucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdExpbmVzLCB0aGlzTGluZSkge1xuICAgICAgICAvLyBpdGVyYXRlIGFsbCBsaW5rcyBhbmQgZ3JhYiB0aGUgaW50ZXJzZWN0aW9ucyB3aXRoIHRoaXMgbGluZVxuICAgICAgICAvLyB0aGVzZSBhcmUgdGhlbiBzb3J0ZWQgYnkgZGlzdGFuY2Ugc28gdGhlIGxpbmUgY2FuIGJlIHNwbGl0IG1vcmUgZWFzaWx5XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gbGlua3MucmVkdWNlKGZ1bmN0aW9uKHJlcywgbGluaywgaSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgaW50ZXJzZWN0aW9uIHdpdGggaXRzZWxmXG4gICAgICAgICAgICBpZiAobGluayAhPT0gdGhpc01vZGVsKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGluZXNUb1Rlc3QgPSBsaW5rTGluZXNbaV0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwSW5kZXggPSBsaW5rTGluZXNUb1Rlc3QuZmluZEluZGV4KChsaW5lKSA9PiBvdmVybGFwRXhpc3RzKHRoaXNMaW5lLCBsaW5lKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBPdmVybGFwIG9jY3VycyBhbmQgdGhlIGVuZCBwb2ludCBvZiBvbmUgc2VnbWVudCBsaWVzIG9uIHRoaXNMaW5lXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBJbmRleCA+IC0xICYmIHRoaXNMaW5lLmNvbnRhaW5zUG9pbnQobGlua0xpbmVzVG9UZXN0W292ZXJsYXBJbmRleF0uZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG5leHQgc2VnbWVudCBiZWNhdXNlIHRoZXJlIHdpbGwgbmV2ZXIgYmUgYSBqdW1wXG4gICAgICAgICAgICAgICAgICAgIGxpbmtMaW5lc1RvVGVzdC5zcGxpY2Uob3ZlcmxhcEluZGV4ICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVJbnRlcnNlY3Rpb25zID0gZmluZExpbmVJbnRlcnNlY3Rpb25zKHRoaXNMaW5lLCBsaW5rTGluZXNUb1Rlc3QpO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbGluZUludGVyc2VjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwgW10pLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRQb2ludHModGhpc0xpbmUuc3RhcnQsIGEpIC0gc29ydFBvaW50cyh0aGlzTGluZS5zdGFydCwgYik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBsaW5lIGJhc2VkIG9uIGZvdW5kIGludGVyc2VjdGlvbiBwb2ludHNcbiAgICAgICAgICAgIHJlc3VsdExpbmVzLnB1c2guYXBwbHkocmVzdWx0TGluZXMsIGNyZWF0ZUp1bXBzKHRoaXNMaW5lLCBpbnRlcnNlY3Rpb25zLCBqdW1wU2l6ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gd2l0aG91dCBhbnkgaW50ZXJzZWN0aW9uIHRoZSBsaW5lIGdvZXMgdW5pbnRlcnJ1cHRlZFxuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzO1xuICAgIH0sIFtdKTtcblxuICAgIHZhciBwYXRoID0gYnVpbGRQYXRoKGp1bXBpbmdMaW5lcywganVtcFNpemUsIGp1bXBUeXBlLCByYWRpdXMpO1xuICAgIHJldHVybiAocmF3KSA/IHBhdGggOiBwYXRoLnNlcmlhbGl6ZSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/jumpover.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/normal.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/normal.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: () => (/* binding */ normal)\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/straight.mjs\");\n\n\nconst normal = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { raw } = opt;\n    const localOpt = {\n        cornerType: 'point',\n        raw\n    };\n\n    return (0,_straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)(sourcePoint, targetPoint, route, localOpt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvbm9ybWFsLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFbkMsc0VBQXNFOztBQUU3RSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyx1REFBUTtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvbm9ybWFsLm1qcz81NjJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmFpZ2h0IH0gZnJvbSAnLi9zdHJhaWdodC5tanMnO1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsID0gZnVuY3Rpb24oc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZSA9IFtdLCBvcHQgPSB7fSkge1xuXG4gICAgY29uc3QgeyByYXcgfSA9IG9wdDtcbiAgICBjb25zdCBsb2NhbE9wdCA9IHtcbiAgICAgICAgY29ybmVyVHlwZTogJ3BvaW50JyxcbiAgICAgICAgcmF3XG4gICAgfTtcblxuICAgIHJldHVybiBzdHJhaWdodChzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlLCBsb2NhbE9wdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/normal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/rounded.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/rounded.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rounded: () => (/* binding */ rounded)\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/straight.mjs\");\n\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 0;\n\nconst rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { radius = CORNER_RADIUS, raw } = opt;\n    const localOpt = {\n        cornerType: 'cubic',\n        cornerRadius: radius,\n        precision: PRECISION,\n        raw\n    };\n\n    return (0,_straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)(sourcePoint, targetPoint, route, localOpt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvcm91bmRlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7O0FBRU8sdUVBQXVFOztBQUU5RSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyx1REFBUTtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvcm91bmRlZC5tanM/ODc5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdHJhaWdodCB9IGZyb20gJy4vc3RyYWlnaHQubWpzJztcblxuY29uc3QgQ09STkVSX1JBRElVUyA9IDEwO1xuY29uc3QgUFJFQ0lTSU9OID0gMDtcblxuZXhwb3J0IGNvbnN0IHJvdW5kZWQgPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlID0gW10sIG9wdCA9IHt9KSB7XG5cbiAgICBjb25zdCB7IHJhZGl1cyA9IENPUk5FUl9SQURJVVMsIHJhdyB9ID0gb3B0O1xuICAgIGNvbnN0IGxvY2FsT3B0ID0ge1xuICAgICAgICBjb3JuZXJUeXBlOiAnY3ViaWMnLFxuICAgICAgICBjb3JuZXJSYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgcHJlY2lzaW9uOiBQUkVDSVNJT04sXG4gICAgICAgIHJhd1xuICAgIH07XG5cbiAgICByZXR1cm4gc3RyYWlnaHQoc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZSwgbG9jYWxPcHQpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/rounded.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/smooth.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/smooth.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   smooth: () => (/* binding */ smooth)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n\n\nconst smooth = function(sourcePoint, targetPoint, route, opt) {\n\n    var raw = opt && opt.raw;\n    var path;\n\n    if (route && route.length !== 0) {\n\n        var points = [sourcePoint].concat(route).concat([targetPoint]);\n        var curves = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Curve.throughPoints(points);\n\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(curves);\n\n    } else {\n        // if we have no route, use a default cubic bezier curve\n        // cubic bezier requires two control points\n        // the control points have `x` midway between source and target\n        // this produces an S-like curve\n\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path();\n\n        var segment;\n\n        segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('M', sourcePoint);\n        path.appendSegment(segment);\n\n        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n            segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        } else {\n            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n            segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        }\n    }\n\n    return (raw) ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvc21vb3RoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7O0FBRTdCOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsK0NBQU87O0FBRTVCLG1CQUFtQiw4Q0FBTTs7QUFFekIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw4Q0FBTTs7QUFFekI7O0FBRUEsa0JBQWtCLDhDQUFNO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLDhDQUFNO0FBQzVCOztBQUVBLFVBQVU7QUFDVjs7QUFFQSxzQkFBc0IsOENBQU07QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9zbW9vdGgubWpzPzRmM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBzbW9vdGggPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlLCBvcHQpIHtcblxuICAgIHZhciByYXcgPSBvcHQgJiYgb3B0LnJhdztcbiAgICB2YXIgcGF0aDtcblxuICAgIGlmIChyb3V0ZSAmJiByb3V0ZS5sZW5ndGggIT09IDApIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW3NvdXJjZVBvaW50XS5jb25jYXQocm91dGUpLmNvbmNhdChbdGFyZ2V0UG9pbnRdKTtcbiAgICAgICAgdmFyIGN1cnZlcyA9IGcuQ3VydmUudGhyb3VnaFBvaW50cyhwb2ludHMpO1xuXG4gICAgICAgIHBhdGggPSBuZXcgZy5QYXRoKGN1cnZlcyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vIHJvdXRlLCB1c2UgYSBkZWZhdWx0IGN1YmljIGJlemllciBjdXJ2ZVxuICAgICAgICAvLyBjdWJpYyBiZXppZXIgcmVxdWlyZXMgdHdvIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIC8vIHRoZSBjb250cm9sIHBvaW50cyBoYXZlIGB4YCBtaWR3YXkgYmV0d2VlbiBzb3VyY2UgYW5kIHRhcmdldFxuICAgICAgICAvLyB0aGlzIHByb2R1Y2VzIGFuIFMtbGlrZSBjdXJ2ZVxuXG4gICAgICAgIHBhdGggPSBuZXcgZy5QYXRoKCk7XG5cbiAgICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgc291cmNlUG9pbnQpO1xuICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAgICAgaWYgKChNYXRoLmFicyhzb3VyY2VQb2ludC54IC0gdGFyZ2V0UG9pbnQueCkpID49IChNYXRoLmFicyhzb3VyY2VQb2ludC55IC0gdGFyZ2V0UG9pbnQueSkpKSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFBvaW50WCA9IChzb3VyY2VQb2ludC54ICsgdGFyZ2V0UG9pbnQueCkgLyAyO1xuXG4gICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBjb250cm9sUG9pbnRYLCBzb3VyY2VQb2ludC55LCBjb250cm9sUG9pbnRYLCB0YXJnZXRQb2ludC55LCB0YXJnZXRQb2ludC54LCB0YXJnZXRQb2ludC55KTtcbiAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludFkgPSAoc291cmNlUG9pbnQueSArIHRhcmdldFBvaW50LnkpIC8gMjtcblxuICAgICAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgc291cmNlUG9pbnQueCwgY29udHJvbFBvaW50WSwgdGFyZ2V0UG9pbnQueCwgY29udHJvbFBvaW50WSwgdGFyZ2V0UG9pbnQueCwgdGFyZ2V0UG9pbnQueSk7XG4gICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAocmF3KSA/IHBhdGggOiBwYXRoLnNlcmlhbGl6ZSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/smooth.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/connectors/straight.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/straight.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   straight: () => (/* binding */ straight)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\nconst CornerTypes = {\n    POINT: 'point',\n    CUBIC: 'cubic',\n    LINE: 'line',\n    GAP: 'gap'\n};\n\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\n\nconst straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\n    const {\n        cornerType = CornerTypes.POINT,\n        cornerRadius = CORNER_RADIUS,\n        cornerPreserveAspectRatio = false,\n        precision = PRECISION,\n        raw = false\n    } = opt;\n\n    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n        // unknown `cornerType` provided => error\n        throw new Error('Invalid `cornerType` provided to `straight` connector.');\n    }\n\n    let path;\n\n    if ((cornerType === CornerTypes.POINT) || !cornerRadius) {\n        // default option => normal connector\n        // simply connect all points with straight lines\n        const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(polyline);\n\n    } else {\n        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path();\n\n        // add initial gap segment = to source point\n        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('M', sourcePoint));\n\n        let nextDistance;\n        const routePointsLength = routePoints.length;\n        for (let i = 0; i < routePointsLength; i++) {\n\n            const curr = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(routePoints[i]);\n            const prev = (routePoints[i - 1] || sourcePoint);\n            const next = (routePoints[i + 1] || targetPoint);\n            const prevDistance = (nextDistance || (curr.distance(prev) / 2)); // try to re-use previously-computed `nextDistance`\n            nextDistance = (curr.distance(next) / 2);\n\n            let startMove, endMove;\n            if (!cornerPreserveAspectRatio) {\n                // `startMove` and `endMove` may be different\n                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                startMove = -Math.min(cornerRadius, prevDistance);\n                endMove = -Math.min(cornerRadius, nextDistance);\n            } else {\n                // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n            }\n\n            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n            // - find a point lying on the line `prev - startMove` such that...\n            // - ...the point lies `abs(startMove)` distance away from `curr`...\n            // - ...and its coordinates are rounded to whole numbers\n            const cornerStart = curr.clone().move(prev, startMove).round(precision);\n            const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n            // add in-between straight segment = from previous route point to corner start point\n            // (may have zero length)\n            path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('L', cornerStart));\n\n            // add corner segment = from corner start point to corner end point\n            switch (cornerType) {\n                case CornerTypes.CUBIC: {\n                    // corner is rounded\n                    const _13 = (1 / 3);\n                    const _23 = (2 / 3);\n                    const control1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point((_13 * cornerStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerStart.y));\n                    const control2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point((_13 * cornerEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerEnd.y));\n                    path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('C', control1, control2, cornerEnd));\n                    break;\n                }\n                case CornerTypes.LINE: {\n                    // corner has bevel\n                    path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('L', cornerEnd));\n                    break;\n                }\n                case CornerTypes.GAP: {\n                    // corner has empty space\n                    path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('M', cornerEnd));\n                    break;\n                }\n                // default: no segment is created\n            }\n        }\n\n        // add final straight segment = from last corner end point to target point\n        // (= or from start point to end point, if there are no route points)\n        // (may have zero length)\n        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('L', targetPoint));\n    }\n\n    return ((raw) ? path : path.serialize());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvc3RyYWlnaHQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVPLDhFQUE4RTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBVTtBQUN2QyxtQkFBbUIsOENBQU07O0FBRXpCLE1BQU07QUFDTjtBQUNBLG1CQUFtQiw4Q0FBTTs7QUFFekI7QUFDQSwyQkFBMkIsOENBQU07O0FBRWpDO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCOztBQUUvQyw2QkFBNkIsK0NBQU87QUFDcEM7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDhDQUFNOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0NBQU87QUFDaEQseUNBQXlDLCtDQUFPO0FBQ2hELHVDQUF1Qyw4Q0FBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4Q0FBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4Q0FBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBTTtBQUNqQzs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9zdHJhaWdodC5tanM/YTE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgQ29ybmVyVHlwZXMgPSB7XG4gICAgUE9JTlQ6ICdwb2ludCcsXG4gICAgQ1VCSUM6ICdjdWJpYycsXG4gICAgTElORTogJ2xpbmUnLFxuICAgIEdBUDogJ2dhcCdcbn07XG5cbmNvbnN0IERFRklORURfQ09STkVSX1RZUEVTID0gT2JqZWN0LnZhbHVlcyhDb3JuZXJUeXBlcyk7XG5cbmNvbnN0IENPUk5FUl9SQURJVVMgPSAxMDtcbmNvbnN0IFBSRUNJU0lPTiA9IDE7XG5cbmV4cG9ydCBjb25zdCBzdHJhaWdodCA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGVQb2ludHMgPSBbXSwgb3B0ID0ge30pIHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY29ybmVyVHlwZSA9IENvcm5lclR5cGVzLlBPSU5ULFxuICAgICAgICBjb3JuZXJSYWRpdXMgPSBDT1JORVJfUkFESVVTLFxuICAgICAgICBjb3JuZXJQcmVzZXJ2ZUFzcGVjdFJhdGlvID0gZmFsc2UsXG4gICAgICAgIHByZWNpc2lvbiA9IFBSRUNJU0lPTixcbiAgICAgICAgcmF3ID0gZmFsc2VcbiAgICB9ID0gb3B0O1xuXG4gICAgaWYgKERFRklORURfQ09STkVSX1RZUEVTLmluZGV4T2YoY29ybmVyVHlwZSkgPT09IC0xKSB7XG4gICAgICAgIC8vIHVua25vd24gYGNvcm5lclR5cGVgIHByb3ZpZGVkID0+IGVycm9yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBgY29ybmVyVHlwZWAgcHJvdmlkZWQgdG8gYHN0cmFpZ2h0YCBjb25uZWN0b3IuJyk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGg7XG5cbiAgICBpZiAoKGNvcm5lclR5cGUgPT09IENvcm5lclR5cGVzLlBPSU5UKSB8fCAhY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uID0+IG5vcm1hbCBjb25uZWN0b3JcbiAgICAgICAgLy8gc2ltcGx5IGNvbm5lY3QgYWxsIHBvaW50cyB3aXRoIHN0cmFpZ2h0IGxpbmVzXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtzb3VyY2VQb2ludF0uY29uY2F0KHJvdXRlUG9pbnRzKS5jb25jYXQoW3RhcmdldFBvaW50XSk7XG4gICAgICAgIGNvbnN0IHBvbHlsaW5lID0gbmV3IGcuUG9seWxpbmUocG9pbnRzKTtcbiAgICAgICAgcGF0aCA9IG5ldyBnLlBhdGgocG9seWxpbmUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYGNvcm5lclR5cGVgIGlzIG5vdCB1bmtub3duIGFuZCBub3QgJ3BvaW50JyAoZGVmYXVsdCkgPT4gbXVzdCBiZSBvbmUgb2Ygb3RoZXIgdmFsaWQgdHlwZXNcbiAgICAgICAgcGF0aCA9IG5ldyBnLlBhdGgoKTtcblxuICAgICAgICAvLyBhZGQgaW5pdGlhbCBnYXAgc2VnbWVudCA9IHRvIHNvdXJjZSBwb2ludFxuICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBzb3VyY2VQb2ludCkpO1xuXG4gICAgICAgIGxldCBuZXh0RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHJvdXRlUG9pbnRzTGVuZ3RoID0gcm91dGVQb2ludHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlUG9pbnRzTGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3QgY3VyciA9IG5ldyBnLlBvaW50KHJvdXRlUG9pbnRzW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSAocm91dGVQb2ludHNbaSAtIDFdIHx8IHNvdXJjZVBvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSAocm91dGVQb2ludHNbaSArIDFdIHx8IHRhcmdldFBvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZEaXN0YW5jZSA9IChuZXh0RGlzdGFuY2UgfHwgKGN1cnIuZGlzdGFuY2UocHJldikgLyAyKSk7IC8vIHRyeSB0byByZS11c2UgcHJldmlvdXNseS1jb21wdXRlZCBgbmV4dERpc3RhbmNlYFxuICAgICAgICAgICAgbmV4dERpc3RhbmNlID0gKGN1cnIuZGlzdGFuY2UobmV4dCkgLyAyKTtcblxuICAgICAgICAgICAgbGV0IHN0YXJ0TW92ZSwgZW5kTW92ZTtcbiAgICAgICAgICAgIGlmICghY29ybmVyUHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIC8vIGBzdGFydE1vdmVgIGFuZCBgZW5kTW92ZWAgbWF5IGJlIGRpZmZlcmVudFxuICAgICAgICAgICAgICAgIC8vICh0aGlzIGhhcHBlbnMgd2hlbiBuZXh0IG9yIHByZXZpb3VzIHBhdGggcG9pbnQgaXMgY2xvc2VyIHRoYW4gYDIgKiBjb3JuZXJSYWRpdXNgKVxuICAgICAgICAgICAgICAgIHN0YXJ0TW92ZSA9IC1NYXRoLm1pbihjb3JuZXJSYWRpdXMsIHByZXZEaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgZW5kTW92ZSA9IC1NYXRoLm1pbihjb3JuZXJSYWRpdXMsIG5leHREaXN0YW5jZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIGBzdGFydE1vdmVgIGFuZCBgZW5kTW92ZWAgdG8gYmUgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBzdGFydE1vdmUgPSBlbmRNb3ZlID0gLU1hdGgubWluKGNvcm5lclJhZGl1cywgcHJldkRpc3RhbmNlLCBuZXh0RGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0byBmaW5kIGBjb3JuZXJTdGFydGAgYW5kIGBjb3JuZXJFbmRgLCB0aGUgbG9naWMgaXMgYXMgZm9sbG93cyAodXNpbmcgYGNvcm5lclN0YXJ0YCBhcyBleGFtcGxlKTpcbiAgICAgICAgICAgIC8vIC0gZmluZCBhIHBvaW50IGx5aW5nIG9uIHRoZSBsaW5lIGBwcmV2IC0gc3RhcnRNb3ZlYCBzdWNoIHRoYXQuLi5cbiAgICAgICAgICAgIC8vIC0gLi4udGhlIHBvaW50IGxpZXMgYGFicyhzdGFydE1vdmUpYCBkaXN0YW5jZSBhd2F5IGZyb20gYGN1cnJgLi4uXG4gICAgICAgICAgICAvLyAtIC4uLmFuZCBpdHMgY29vcmRpbmF0ZXMgYXJlIHJvdW5kZWQgdG8gd2hvbGUgbnVtYmVyc1xuICAgICAgICAgICAgY29uc3QgY29ybmVyU3RhcnQgPSBjdXJyLmNsb25lKCkubW92ZShwcmV2LCBzdGFydE1vdmUpLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgICAgICBjb25zdCBjb3JuZXJFbmQgPSBjdXJyLmNsb25lKCkubW92ZShuZXh0LCBlbmRNb3ZlKS5yb3VuZChwcmVjaXNpb24pO1xuXG4gICAgICAgICAgICAvLyBhZGQgaW4tYmV0d2VlbiBzdHJhaWdodCBzZWdtZW50ID0gZnJvbSBwcmV2aW91cyByb3V0ZSBwb2ludCB0byBjb3JuZXIgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgIC8vIChtYXkgaGF2ZSB6ZXJvIGxlbmd0aClcbiAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChnLlBhdGguY3JlYXRlU2VnbWVudCgnTCcsIGNvcm5lclN0YXJ0KSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBjb3JuZXIgc2VnbWVudCA9IGZyb20gY29ybmVyIHN0YXJ0IHBvaW50IHRvIGNvcm5lciBlbmQgcG9pbnRcbiAgICAgICAgICAgIHN3aXRjaCAoY29ybmVyVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29ybmVyVHlwZXMuQ1VCSUM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ybmVyIGlzIHJvdW5kZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgXzEzID0gKDEgLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgXzIzID0gKDIgLyAzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJvbDEgPSBuZXcgZy5Qb2ludCgoXzEzICogY29ybmVyU3RhcnQueCkgKyAoXzIzICogY3Vyci54KSwgKF8yMyAqIGN1cnIueSkgKyAoXzEzICogY29ybmVyU3RhcnQueSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sMiA9IG5ldyBnLlBvaW50KChfMTMgKiBjb3JuZXJFbmQueCkgKyAoXzIzICogY3Vyci54KSwgKF8yMyAqIGN1cnIueSkgKyAoXzEzICogY29ybmVyRW5kLnkpKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KGcuUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgY29udHJvbDEsIGNvbnRyb2wyLCBjb3JuZXJFbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQ29ybmVyVHlwZXMuTElORToge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3JuZXIgaGFzIGJldmVsXG4gICAgICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChnLlBhdGguY3JlYXRlU2VnbWVudCgnTCcsIGNvcm5lckVuZCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb3JuZXJUeXBlcy5HQVA6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ybmVyIGhhcyBlbXB0eSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBjb3JuZXJFbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQ6IG5vIHNlZ21lbnQgaXMgY3JlYXRlZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGZpbmFsIHN0cmFpZ2h0IHNlZ21lbnQgPSBmcm9tIGxhc3QgY29ybmVyIGVuZCBwb2ludCB0byB0YXJnZXQgcG9pbnRcbiAgICAgICAgLy8gKD0gb3IgZnJvbSBzdGFydCBwb2ludCB0byBlbmQgcG9pbnQsIGlmIHRoZXJlIGFyZSBubyByb3V0ZSBwb2ludHMpXG4gICAgICAgIC8vIChtYXkgaGF2ZSB6ZXJvIGxlbmd0aClcbiAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KGcuUGF0aC5jcmVhdGVTZWdtZW50KCdMJywgdGFyZ2V0UG9pbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/connectors/straight.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/core.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@joint/core/src/core.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: () => (/* reexport safe */ _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   Vectorizer: () => (/* binding */ Vectorizer),\n/* harmony export */   anchors: () => (/* reexport module object */ _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_6__),\n/* harmony export */   config: () => (/* reexport safe */ _config_index_mjs__WEBPACK_IMPORTED_MODULE_5__.config),\n/* harmony export */   connectionPoints: () => (/* reexport module object */ _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   connectionStrategies: () => (/* reexport module object */ _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_9__),\n/* harmony export */   connectors: () => (/* reexport module object */ _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   dia: () => (/* reexport module object */ _dia_index_mjs__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   elementTools: () => (/* reexport module object */ _elementTools_index_mjs__WEBPACK_IMPORTED_MODULE_17__),\n/* harmony export */   env: () => (/* reexport safe */ _env_index_mjs__WEBPACK_IMPORTED_MODULE_4__.env),\n/* harmony export */   g: () => (/* reexport module object */ _g_index_mjs__WEBPACK_IMPORTED_MODULE_18__),\n/* harmony export */   highlighters: () => (/* reexport module object */ _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_12__),\n/* harmony export */   layout: () => (/* binding */ layout),\n/* harmony export */   linkAnchors: () => (/* reexport module object */ _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__),\n/* harmony export */   linkTools: () => (/* reexport module object */ _linkTools_index_mjs__WEBPACK_IMPORTED_MODULE_16__),\n/* harmony export */   mvc: () => (/* reexport module object */ _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_13__),\n/* harmony export */   routers: () => (/* reexport module object */ _routers_index_mjs__WEBPACK_IMPORTED_MODULE_14__),\n/* harmony export */   setTheme: () => (/* binding */ setTheme),\n/* harmony export */   util: () => (/* reexport module object */ _util_index_mjs__WEBPACK_IMPORTED_MODULE_15__),\n/* harmony export */   version: () => (/* reexport safe */ _dist_version_mjs__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./connectors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/index.mjs\");\n/* harmony import */ var _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./highlighters/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/index.mjs\");\n/* harmony import */ var _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./connectionPoints/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectionPoints/index.mjs\");\n/* harmony import */ var _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./connectionStrategies/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\");\n/* harmony import */ var _routers_index_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./routers/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/index.mjs\");\n/* harmony import */ var _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./anchors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/anchors/index.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./linkAnchors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n/* harmony import */ var _dia_index_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dia/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/index.mjs\");\n/* harmony import */ var _linkTools_index_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./linkTools/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/index.mjs\");\n/* harmony import */ var _elementTools_index_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./elementTools/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/elementTools/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/index.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/index.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layout/ports/port.mjs */ \"(ssr)/./node_modules/@joint/core/src/layout/ports/port.mjs\");\n/* harmony import */ var _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layout/ports/portLabel.mjs */ \"(ssr)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs\");\n/* harmony import */ var _dist_version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/version.mjs */ \"(ssr)/./node_modules/@joint/core/dist/version.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/env/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Vectorizer = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\nconst layout = { PortLabel: _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__, Port: _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_3__ };\n\n\nconst setTheme = function(theme, opt) {\n\n    opt = opt || {};\n\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_19__.invoke(_mvc_index_mjs__WEBPACK_IMPORTED_MODULE_20__.views, 'setTheme', theme, opt);\n\n    // Update the default theme on the view prototype.\n    _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_20__.View.prototype.defaultTheme = theme;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NvcmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ0k7QUFDUTtBQUNRO0FBQzFCO0FBQ0E7QUFDUTtBQUNoQjtBQUNZO0FBQ007QUFDaEI7QUFDRjtBQUNKO0FBQ1M7QUFDZDtBQUNrQjtBQUNVOztBQUV0QjtBQUM3QixtQkFBbUIsb0RBQUM7QUFDcEIsaUJBQWlCLFNBQVMsZ0VBQU07QUFDRDtBQWlCcEM7QUFDSzs7QUFFUDs7QUFFQSxJQUFJLG9EQUFXLENBQUMsa0RBQVM7O0FBRXpCO0FBQ0EsSUFBSSxpREFBUTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29yZS5tanM/MzIwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjb25uZWN0b3JzIGZyb20gJy4vY29ubmVjdG9ycy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgaGlnaGxpZ2h0ZXJzIGZyb20gJy4vaGlnaGxpZ2h0ZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBjb25uZWN0aW9uUG9pbnRzIGZyb20gJy4vY29ubmVjdGlvblBvaW50cy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgY29ubmVjdGlvblN0cmF0ZWdpZXMgZnJvbSAnLi9jb25uZWN0aW9uU3RyYXRlZ2llcy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgcm91dGVycyBmcm9tICcuL3JvdXRlcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGFuY2hvcnMgZnJvbSAnLi9hbmNob3JzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBsaW5rQW5jaG9ycyBmcm9tICcuL2xpbmtBbmNob3JzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBkaWEgZnJvbSAnLi9kaWEvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGxpbmtUb29scyBmcm9tICcuL2xpbmtUb29scy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudFRvb2xzIGZyb20gJy4vZWxlbWVudFRvb2xzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgbXZjIGZyb20gJy4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9jb25maWcvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4vVi9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgUG9ydCBmcm9tICcuL2xheW91dC9wb3J0cy9wb3J0Lm1qcyc7XG5pbXBvcnQgKiBhcyBQb3J0TGFiZWwgZnJvbSAnLi9sYXlvdXQvcG9ydHMvcG9ydExhYmVsLm1qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4uL2Rpc3QvdmVyc2lvbi5tanMnO1xuZXhwb3J0IGNvbnN0IFZlY3Rvcml6ZXIgPSBWO1xuZXhwb3J0IGNvbnN0IGxheW91dCA9IHsgUG9ydExhYmVsLCBQb3J0IH07XG5leHBvcnQgeyBlbnYgfSBmcm9tICcuL2Vudi9pbmRleC5tanMnO1xuZXhwb3J0IHtcbiAgICBjb25maWcsXG4gICAgYW5jaG9ycyxcbiAgICBsaW5rQW5jaG9ycyxcbiAgICBjb25uZWN0aW9uUG9pbnRzLFxuICAgIGNvbm5lY3Rpb25TdHJhdGVnaWVzLFxuICAgIGNvbm5lY3RvcnMsXG4gICAgZGlhLFxuICAgIGhpZ2hsaWdodGVycyxcbiAgICBtdmMsXG4gICAgcm91dGVycyxcbiAgICB1dGlsLFxuICAgIGxpbmtUb29scyxcbiAgICBlbGVtZW50VG9vbHMsXG4gICAgVixcbiAgICBnXG59O1xuZXhwb3J0IGNvbnN0IHNldFRoZW1lID0gZnVuY3Rpb24odGhlbWUsIG9wdCkge1xuXG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgdXRpbC5pbnZva2UobXZjLnZpZXdzLCAnc2V0VGhlbWUnLCB0aGVtZSwgb3B0KTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgZGVmYXVsdCB0aGVtZSBvbiB0aGUgdmlldyBwcm90b3R5cGUuXG4gICAgbXZjLlZpZXcucHJvdG90eXBlLmRlZmF1bHRUaGVtZSA9IHRoZW1lO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Cell.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* binding */ Cell)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mvc/Model.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _util_cloneCells_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/cloneCells.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/cloneCells.mjs\");\n/* harmony import */ var _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attributes/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n\n\n\n\n\n\n\n// Cell base model.\n// --------------------------\n\nconst attributesMerger = function(a, b) {\n    if (Array.isArray(a)) {\n        return b;\n    }\n};\n\nfunction removeEmptyAttributes(obj) {\n\n    // Remove toplevel empty attributes\n    for (const key in obj) {\n\n        const objValue = obj[key];\n        const isRealObject = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(objValue) && !Array.isArray(objValue);\n\n        if (!isRealObject) continue;\n\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(objValue)) {\n            delete obj[key];\n        }\n    }\n}\n\nconst Cell = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_1__.Model.extend({\n\n    // This is the same as mvc.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n\n        var defaults;\n        var attrs = attributes || {};\n        if (typeof this.preinitialize === 'function') {\n            // Check to support an older version\n            this.preinitialize.apply(this, arguments);\n        }\n        this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if ((defaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'defaults'))) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            const customizer = (options && options.mergeArrays === true) ? false : attributesMerger;\n            attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)({}, defaults, attrs, customizer);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        throw new Error('Must define a translate() method.');\n    },\n\n    toJSON: function(opt) {\n\n        const { ignoreDefaults, ignoreEmptyAttributes = false } = opt || {};\n        const defaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this.constructor.prototype, 'defaults');\n\n        if (ignoreDefaults === false) {\n            // Return all attributes without omitting the defaults\n            const finalAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(this.attributes);\n\n            if (!ignoreEmptyAttributes) return finalAttributes;\n\n            removeEmptyAttributes(finalAttributes);\n\n            return finalAttributes;\n        }\n\n        let defaultAttributes = {};\n        let attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(this.attributes);\n\n        if (ignoreDefaults === true) {\n            // Compare all attributes with the defaults\n            defaultAttributes = defaults;\n        } else {\n            // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified\n            const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ['attrs'];\n\n            differentiateKeys.forEach((key) => {\n                defaultAttributes[key] = defaults[key] || {};\n            });\n        }\n\n        // Omit `id` and `type` attribute from the defaults since it should be always present\n        const finalAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.objectDifference)(attributes, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.omit)(defaultAttributes, 'id', 'type'), { maxDepth: 4 });\n\n        if (ignoreEmptyAttributes) {\n            removeEmptyAttributes(finalAttributes);\n        }\n\n        return finalAttributes;\n    },\n\n    initialize: function(options) {\n\n        const idAttribute = this.getIdAttribute();\n        if (!options || options[idAttribute] === undefined) {\n            this.set(idAttribute, this.generateId(), { silent: true });\n        }\n\n        this._transitionIds = {};\n        this._scheduledTransitionIds = {};\n\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on('change:attrs', this.processPorts, this);\n    },\n\n    getIdAttribute: function() {\n        return this.idAttribute || 'id';\n    },\n\n    generateId: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.uuid)();\n    },\n\n    /**\n     * @deprecated\n     */\n    processPorts: function() {\n\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n\n        var previousPorts = this.ports;\n\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.forIn)(this.get('attrs'), function(attrs, selector) {\n\n            if (attrs && attrs.port) {\n\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = { id: attrs.port };\n                }\n            }\n        });\n\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.forIn)(previousPorts, function(port, id) {\n\n            if (!ports[id]) removedPorts[id] = true;\n        });\n\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(removedPorts)) {\n\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('source').port]) link.remove();\n            });\n        }\n\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n\n    remove: function(opt = {}) {\n\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common mvc collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n\n        graph.startBatch('remove');\n\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for (let i = 0, n = embeddedCells.length; i < n; i++) {\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n\n        this.trigger('remove', this, graph.attributes.cells, opt);\n\n        graph.stopBatch('remove');\n\n        return this;\n    },\n\n    toFront: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults)(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy)(cells, cell => cell.z());\n\n            const maxZ = graph.maxZIndex();\n            let z = maxZ - cells.length + 1;\n\n            const collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== (collection.length - cells.length));\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-front');\n\n                z = z + cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-front');\n            }\n        }\n\n        return this;\n    },\n\n    toBack: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults)(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy)(cells, cell => cell.z());\n\n            let z = graph.minZIndex();\n\n            var collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== 0);\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-back');\n\n                z -= cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-back');\n            }\n        }\n\n        return this;\n    },\n\n    parent: function(parent, opt) {\n\n        // getter\n        if (parent === undefined) return this.get('parent');\n        // setter\n        return this.set('parent', parent, opt);\n    },\n\n    embed: function(cell, opt = {}) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        if (!this.canEmbed(cells)) {\n            throw new Error('Recursive embedding not allowed.');\n        }\n        if (opt.reparent) {\n            const parents = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(cells.map(c => c.getParentCell()));\n\n            // Unembed cells from their current parents.\n            parents.forEach((parent) => {\n                // Cell doesn't have to be embedded.\n                if (!parent) return;\n\n                // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases\n                // where not all elements of `cells` are embedded in the same parent.\n                parent._unembedCells(cells, opt);\n            });\n\n        } else if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n            throw new Error('Embedding of already embedded cells is not allowed.');\n        }\n        this._embedCells(cells, opt);\n        return this;\n    },\n\n    unembed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        this._unembedCells(cells, opt);\n        return this;\n    },\n\n    canEmbed: function(cell) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n    },\n\n    _embedCells: function(cells, opt) {\n        const batchName = 'embed';\n        this.startBatch(batchName);\n        const embeds = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)([], this.get('embeds'));\n        cells.forEach(cell => {\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n            cell.parent(this.id, opt);\n        });\n        this.set('embeds', (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(embeds), opt);\n        this.stopBatch(batchName);\n    },\n\n    _unembedCells: function(cells, opt) {\n        const batchName = 'unembed';\n        this.startBatch(batchName);\n        cells.forEach(cell => cell.unset('parent', opt));\n        this.set('embeds', (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.without)(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n        this.stopBatch(batchName);\n    },\n\n    getParentCell: function() {\n\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n\n        return (parentId && graph && graph.getCell(parentId)) || null;\n    },\n\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n\n        var ancestors = [];\n\n        if (!this.graph) {\n            return ancestors;\n        }\n\n        var parentCell = this.getParentCell();\n        while (parentCell) {\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n\n        return ancestors;\n    },\n\n    getEmbeddedCells: function(opt) {\n\n        opt = opt || {};\n\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (!this.graph) {\n            return [];\n        }\n\n        if (opt.deep) {\n            if (opt.breadthFirst) {\n                return this._getEmbeddedCellsBfs(opt.sortSiblings);\n            } else {\n                return this._getEmbeddedCellsDfs(opt.sortSiblings);\n            }\n        }\n\n        const embeddedIds = this.get('embeds');\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(embeddedIds)) {\n            return [];\n        }\n\n        let cells = embeddedIds.map(this.graph.getCell, this.graph);\n        if (opt.sortSiblings) {\n            cells = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy)(cells, cell => cell.z());\n        }\n\n        return cells;\n    },\n\n    _getEmbeddedCellsBfs: function(sortSiblings) {\n        const cells = [];\n\n        const queue = [];\n        queue.push(this);\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            queue.push(...embeddedCells);\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    _getEmbeddedCellsDfs: function(sortSiblings) {\n        const cells = [];\n\n        const stack = [];\n        stack.push(this);\n\n        while (stack.length > 0) {\n            const current = stack.pop();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            // When using the stack, cells that are embedded last are processed first.\n            // To maintain the original order, we need to push the cells in reverse order\n            for (let i = embeddedCells.length - 1; i >= 0; --i) {\n                stack.push(embeddedCells[i]);\n            }\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    isEmbeddedIn: function(cell, opt) {\n\n        var cellId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(cell) ? cell : cell.id;\n        var parentId = this.parent();\n\n        opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ deep: true }, opt);\n\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n\n            while (parentId) {\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n\n            return false;\n\n        } else {\n\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n\n        return !!this.parent();\n    },\n\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n\n        opt = opt || {};\n\n        if (!opt.deep) {\n            // Shallow cloning.\n\n            var clone = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_1__.Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set(this.getIdAttribute(), this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset('embeds');\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset('parent');\n\n            return clone;\n\n        } else {\n            // Deep cloning.\n\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)((0,_util_cloneCells_mjs__WEBPACK_IMPORTED_MODULE_3__.cloneCells)([this].concat(this.getEmbeddedCells({ deep: true }))));\n        }\n    },\n\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n\n        var delim = '/';\n        var _isString = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(props);\n\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (arguments.length > 1) {\n\n                var path;\n                var pathArray;\n\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split('/');\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n\n                const options = opt || {};\n                options.propertyPath = path;\n                options.propertyValue = value;\n                options.propertyPathArray = pathArray;\n                if (!('rewrite' in options)) {\n                    options.rewrite = false;\n                }\n\n                var update = {};\n                // Initialize the nested object. Sub-objects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n\n                for (var i = 1; i < pathArrayLength; i++) {\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n\n                // Fill update with the `value` on `path`.\n                update = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.setByPath)(update, pathArray, value, '/');\n\n                var baseAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                options.rewrite && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.unsetByPath)(baseAttributes, path, '/');\n\n                // Merge update with the model attributes.\n                var attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], options);\n\n            } else {\n\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath)(this.attributes, props, delim);\n            }\n        }\n\n        const options = value || {};\n        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n        options.propertyPath = null;\n        options.propertyValue = props;\n        options.propertyPathArray = [];\n        if (!('rewrite' in options)) {\n            options.rewrite = false;\n        }\n\n        // Create a new object containing only the changed attributes.\n        const changedAttributes = {};\n        for (const key in props) {\n            // Merging the values of changed attributes with the current ones.\n            const { changedValue } = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)({}, { changedValue: this.attributes[key] }, { changedValue: props[key] });\n            changedAttributes[key] = changedValue;\n        }\n\n        return this.set(changedAttributes, options);\n    },\n\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n\n        opt = opt || {};\n\n        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === 'attrs') opt.dirty = true;\n\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = this.get(property);\n        if (propertyValue === undefined || propertyValue === null) return this;\n        propertyValue = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(propertyValue);\n\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.unsetByPath)(propertyValue, nestedPath, '/');\n\n        return this.set(property, propertyValue, opt);\n    },\n\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get('attrs');\n        }\n\n        if (Array.isArray(attrs)) {\n            args[0] = ['attrs'].concat(attrs);\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = 'attrs/' + attrs;\n\n        } else {\n\n            args[0] = { 'attrs' : attrs };\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n\n        if (Array.isArray(path)) {\n\n            return this.removeProp(['attrs'].concat(path));\n        }\n\n        return this.removeProp('attrs/' + path, opt);\n    },\n\n    transition: function(path, value, opt, delim) {\n\n        delim = delim || '/';\n\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.timing.linear,\n            valueFunction: _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.interpolate.number\n        };\n\n        opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(defaults, opt);\n\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n\n        var setter = function(runtime) {\n\n            var id, progress, propertyValue;\n\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n\n            if (progress < 1) {\n                this._transitionIds[path] = id = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n            opt.transitionId = id;\n\n            this.prop(path, propertyValue, opt);\n\n            if (!id) this.trigger('transition:end', this, path);\n\n        }.bind(this);\n\n        const { _scheduledTransitionIds } = this;\n        let initialId;\n\n        var initiator = (callback) => {\n\n            if (_scheduledTransitionIds[path]) {\n                _scheduledTransitionIds[path] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.without)(_scheduledTransitionIds[path], initialId);\n                if (_scheduledTransitionIds[path].length === 0) {\n                    delete _scheduledTransitionIds[path];\n                }\n            }\n\n            this.stopPendingTransitions(path, delim);\n\n            interpolatingFunction = opt.valueFunction((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath)(this.attributes, path, delim), value);\n\n            this._transitionIds[path] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(callback);\n\n            this.trigger('transition:start', this, path);\n\n        };\n\n        initialId = setTimeout(initiator, opt.delay, setter);\n\n        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n        _scheduledTransitionIds[path].push(initialId);\n\n        return initialId;\n    },\n\n    getTransitions: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.union)(\n            Object.keys(this._transitionIds),\n            Object.keys(this._scheduledTransitionIds)\n        );\n    },\n\n    stopScheduledTransitions: function(path, delim = '/') {\n        const { _scheduledTransitionIds = {}} = this;\n        let transitions = Object.keys(_scheduledTransitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionIds = _scheduledTransitionIds[key];\n            // stop the initiator\n            transitionIds.forEach(transitionId => clearTimeout(transitionId));\n            delete _scheduledTransitionIds[key];\n            // Note: we could trigger transition:cancel` event here\n        });\n        return this;\n    },\n\n    stopPendingTransitions(path, delim = '/') {\n        const { _transitionIds = {}} = this;\n        let transitions = Object.keys(_transitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionId = _transitionIds[key];\n            // stop the setter\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.cancelFrame)(transitionId);\n            delete _transitionIds[key];\n            this.trigger('transition:end', this, key);\n        });\n    },\n\n    stopTransitions: function(path, delim = '/') {\n        this.stopScheduledTransitions(path, delim);\n        this.stopPendingTransitions(path, delim);\n        return this;\n    },\n\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n    addTo: function(graph, opt) {\n\n        graph.addCell(this, opt);\n        return this;\n    },\n\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n\n        return paper.findViewByModel(this);\n    },\n\n    isElement: function() {\n\n        return false;\n    },\n\n    isLink: function() {\n\n        return false;\n    },\n\n    startBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.startBatch(name, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, opt, { cell: this })); }\n        return this;\n    },\n\n    stopBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.stopBatch(name, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, opt, { cell: this })); }\n        return this;\n    },\n\n    getChangeFlag: function(attributes) {\n\n        var flag = 0;\n        if (!attributes) return flag;\n        for (var key in attributes) {\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n\n    angle: function() {\n\n        // To be overridden.\n        return 0;\n    },\n\n    position: function() {\n\n        // To be overridden.\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);\n    },\n\n    z: function() {\n        return this.get('z') || 0;\n    },\n\n    getPointFromConnectedLink: function() {\n\n        // To be overridden\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point();\n    },\n\n    getBBox: function() {\n\n        // To be overridden\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(0, 0, 0, 0);\n    },\n\n    getPointRotatedAroundCenter(angle, x, y) {\n        const point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point(x, y);\n        if (angle) point.rotate(this.getBBox().center(), angle);\n        return point;\n    },\n\n    getAbsolutePointFromRelative(x, y) {\n        // Rotate the position to take the model angle into account\n        return this.getPointRotatedAroundCenter(\n            -this.angle(),\n            // Transform the relative position to absolute\n            this.position().offset(x, y)\n        );\n    },\n\n    getRelativePointFromAbsolute(x, y) {\n        return this\n            // Rotate the coordinates to mitigate the element's rotation.\n            .getPointRotatedAroundCenter(this.angle(), x, y)\n            // Transform the absolute position into relative\n            .difference(this.position());\n    }\n\n}, {\n\n    getAttributeDefinition: function(attrName) {\n\n        var defNS = this.attributes;\n        var globalDefNS = _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_6__.attributes;\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n    },\n\n    define: function(type, defaults, protoProps, staticProps) {\n\n        protoProps = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({\n            defaults: (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep)({ type: type }, defaults, this.prototype.defaults)\n        }, protoProps);\n\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* eslint-disable no-undef */\n        if (typeof joint !== 'undefined' && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.has)(joint, 'shapes')) {\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.setByPath)(joint.shapes, type, Cell, '.');\n        }\n        /* eslint-enable no-undef */\n        return Cell;\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9DZWxsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQTZCMEI7QUFDZTtBQUNXO0FBQ0E7QUFDaEI7OztBQUdwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qix3REFBUTs7QUFFckM7O0FBRUEsWUFBWSx1REFBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxhQUFhLGlEQUFLOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdEQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQUssR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZ0JBQWdCLGdEQUFnRDtBQUNoRSx5QkFBeUIsc0RBQU07O0FBRS9CO0FBQ0E7QUFDQSxvQ0FBb0MseURBQVM7O0FBRTdDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIseURBQVM7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0VBQWdCLGFBQWEsb0RBQUkscUNBQXFDLGFBQWE7O0FBRW5IO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsb0RBQUk7QUFDbkIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EsMEJBQTBCLDZEQUFVO0FBQ3BDO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxxQkFBcUIsc0RBQU07QUFDM0Isc0JBQXNCLDREQUFZLEdBQUcsWUFBWTtBQUNqRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtREFBRztBQUMvQyxZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9DZWxsLm1qcz9mODgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgdW5pcXVlSWQsXG4gICAgdW5pb24sXG4gICAgcmVzdWx0LFxuICAgIG1lcmdlLFxuICAgIGZvckluLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzRXF1YWwsXG4gICAgaXNTdHJpbmcsXG4gICAgY2xvbmVEZWVwLFxuICAgIG9taXQsXG4gICAgdXVpZCxcbiAgICBpc0VtcHR5LFxuICAgIGFzc2lnbixcbiAgICB1bmlxLFxuICAgIHRvQXJyYXksXG4gICAgc2V0QnlQYXRoLFxuICAgIHVuc2V0QnlQYXRoLFxuICAgIGdldEJ5UGF0aCxcbiAgICB0aW1pbmcsXG4gICAgaW50ZXJwb2xhdGUsXG4gICAgbmV4dEZyYW1lLFxuICAgIHdpdGhvdXQsXG4gICAgY2FuY2VsRnJhbWUsXG4gICAgZGVmYXVsdHNEZWVwLFxuICAgIGhhcyxcbiAgICBzb3J0QnksXG4gICAgZGVmYXVsdHMsXG4gICAgb2JqZWN0RGlmZmVyZW5jZVxufSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcbmltcG9ydCB7IE1vZGVsIH0gZnJvbSAnLi4vbXZjL01vZGVsLm1qcyc7XG5pbXBvcnQgeyBjbG9uZUNlbGxzIH0gZnJvbSAnLi4vdXRpbC9jbG9uZUNlbGxzLm1qcyc7XG5pbXBvcnQgeyBhdHRyaWJ1dGVzIH0gZnJvbSAnLi9hdHRyaWJ1dGVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuXG4vLyBDZWxsIGJhc2UgbW9kZWwuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBhdHRyaWJ1dGVzTWVyZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5QXR0cmlidXRlcyhvYmopIHtcblxuICAgIC8vIFJlbW92ZSB0b3BsZXZlbCBlbXB0eSBhdHRyaWJ1dGVzXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgY29uc3QgaXNSZWFsT2JqZWN0ID0gaXNPYmplY3Qob2JqVmFsdWUpICYmICFBcnJheS5pc0FycmF5KG9ialZhbHVlKTtcblxuICAgICAgICBpZiAoIWlzUmVhbE9iamVjdCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKGlzRW1wdHkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBDZWxsID0gTW9kZWwuZXh0ZW5kKHtcblxuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgYXMgbXZjLk1vZGVsIHdpdGggdGhlIG9ubHkgZGlmZmVyZW5jZSB0aGF0IGlzIHVzZXMgdXRpbC5tZXJnZVxuICAgIC8vIGluc3RlYWQgb2YganVzdCBfLmV4dGVuZC4gVGhlIHJlYXNvbiBpcyB0aGF0IHdlIHdhbnQgdG8gbWl4aW4gYXR0cmlidXRlcyBzZXQgaW4gdXBwZXIgY2xhc3Nlcy5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuXG4gICAgICAgIHZhciBkZWZhdWx0cztcbiAgICAgICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZWluaXRpYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHN1cHBvcnQgYW4gb2xkZXIgdmVyc2lvblxuICAgICAgICAgICAgdGhpcy5wcmVpbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaWQgPSB1bmlxdWVJZCgnYycpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb2xsZWN0aW9uKSB0aGlzLmNvbGxlY3Rpb24gPSBvcHRpb25zLmNvbGxlY3Rpb247XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGFyc2UpIGF0dHJzID0gdGhpcy5wYXJzZShhdHRycywgb3B0aW9ucykgfHwge307XG4gICAgICAgIGlmICgoZGVmYXVsdHMgPSByZXN1bHQodGhpcywgJ2RlZmF1bHRzJykpKSB7XG4gICAgICAgICAgICAvLzxjdXN0b20gY29kZT5cbiAgICAgICAgICAgIC8vIFJlcGxhY2VkIHRoZSBjYWxsIHRvIF8uZGVmYXVsdHMgd2l0aCB1dGlsLm1lcmdlLlxuICAgICAgICAgICAgY29uc3QgY3VzdG9taXplciA9IChvcHRpb25zICYmIG9wdGlvbnMubWVyZ2VBcnJheXMgPT09IHRydWUpID8gZmFsc2UgOiBhdHRyaWJ1dGVzTWVyZ2VyO1xuICAgICAgICAgICAgYXR0cnMgPSBtZXJnZSh7fSwgZGVmYXVsdHMsIGF0dHJzLCBjdXN0b21pemVyKTtcbiAgICAgICAgICAgIC8vPC9jdXN0b20gY29kZT5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbihkeCwgZHksIG9wdCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBkZWZpbmUgYSB0cmFuc2xhdGUoKSBtZXRob2QuJyk7XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgY29uc3QgeyBpZ25vcmVEZWZhdWx0cywgaWdub3JlRW1wdHlBdHRyaWJ1dGVzID0gZmFsc2UgfSA9IG9wdCB8fCB7fTtcbiAgICAgICAgY29uc3QgZGVmYXVsdHMgPSByZXN1bHQodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsICdkZWZhdWx0cycpO1xuXG4gICAgICAgIGlmIChpZ25vcmVEZWZhdWx0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhbGwgYXR0cmlidXRlcyB3aXRob3V0IG9taXR0aW5nIHRoZSBkZWZhdWx0c1xuICAgICAgICAgICAgY29uc3QgZmluYWxBdHRyaWJ1dGVzID0gY2xvbmVEZWVwKHRoaXMuYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIGlmICghaWdub3JlRW1wdHlBdHRyaWJ1dGVzKSByZXR1cm4gZmluYWxBdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICByZW1vdmVFbXB0eUF0dHJpYnV0ZXMoZmluYWxBdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmFsQXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkZWZhdWx0QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBsZXQgYXR0cmlidXRlcyA9IGNsb25lRGVlcCh0aGlzLmF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIGlmIChpZ25vcmVEZWZhdWx0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gQ29tcGFyZSBhbGwgYXR0cmlidXRlcyB3aXRoIHRoZSBkZWZhdWx0c1xuICAgICAgICAgICAgZGVmYXVsdEF0dHJpYnV0ZXMgPSBkZWZhdWx0cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbXBhcmUgb25seSB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMgd2l0aCB0aGUgZGVmYXVsdHMsIHVzZSBgYXR0cnNgIGFzIGEgZGVmYXVsdCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICBjb25zdCBkaWZmZXJlbnRpYXRlS2V5cyA9IEFycmF5LmlzQXJyYXkoaWdub3JlRGVmYXVsdHMpID8gaWdub3JlRGVmYXVsdHMgOiBbJ2F0dHJzJ107XG5cbiAgICAgICAgICAgIGRpZmZlcmVudGlhdGVLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBdHRyaWJ1dGVzW2tleV0gPSBkZWZhdWx0c1trZXldIHx8IHt9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbWl0IGBpZGAgYW5kIGB0eXBlYCBhdHRyaWJ1dGUgZnJvbSB0aGUgZGVmYXVsdHMgc2luY2UgaXQgc2hvdWxkIGJlIGFsd2F5cyBwcmVzZW50XG4gICAgICAgIGNvbnN0IGZpbmFsQXR0cmlidXRlcyA9IG9iamVjdERpZmZlcmVuY2UoYXR0cmlidXRlcywgb21pdChkZWZhdWx0QXR0cmlidXRlcywgJ2lkJywgJ3R5cGUnKSwgeyBtYXhEZXB0aDogNCB9KTtcblxuICAgICAgICBpZiAoaWdub3JlRW1wdHlBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZW1vdmVFbXB0eUF0dHJpYnV0ZXMoZmluYWxBdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5hbEF0dHJpYnV0ZXM7XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBpZEF0dHJpYnV0ZSA9IHRoaXMuZ2V0SWRBdHRyaWJ1dGUoKTtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnNbaWRBdHRyaWJ1dGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGlkQXR0cmlidXRlLCB0aGlzLmdlbmVyYXRlSWQoKSwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uSWRzID0ge307XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZFRyYW5zaXRpb25JZHMgPSB7fTtcblxuICAgICAgICAvLyBDb2xsZWN0IHBvcnRzIGRlZmluZWQgaW4gYGF0dHJzYCBhbmQga2VlcCBjb2xsZWN0aW5nIHdoZW5ldmVyIGBhdHRyc2Agb2JqZWN0IGNoYW5nZXMuXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcnRzKCk7XG4gICAgICAgIHRoaXMub24oJ2NoYW5nZTphdHRycycsIHRoaXMucHJvY2Vzc1BvcnRzLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0SWRBdHRyaWJ1dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZEF0dHJpYnV0ZSB8fCAnaWQnO1xuICAgIH0sXG5cbiAgICBnZW5lcmF0ZUlkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHV1aWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBwcm9jZXNzUG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFdoZW5ldmVyIGBhdHRyc2AgY2hhbmdlcywgd2UgZXh0cmFjdCBwb3J0cyBmcm9tIHRoZSBgYXR0cnNgIG9iamVjdCBhbmQgc3RvcmUgaXRcbiAgICAgICAgLy8gaW4gYSBtb3JlIGFjY2Vzc2libGUgd2F5LiBBbHNvLCBpZiBhbnkgcG9ydCBnb3QgcmVtb3ZlZCBhbmQgdGhlcmUgd2VyZSBsaW5rcyB0aGF0IGhhZCBgdGFyZ2V0YC9gc291cmNlYFxuICAgICAgICAvLyBzZXQgdG8gdGhhdCBwb3J0LCB3ZSByZW1vdmUgdGhvc2UgbGlua3MgYXMgd2VsbCAodG8gZm9sbG93IHRoZSBzYW1lIGJlaGF2aW91ciBhc1xuICAgICAgICAvLyB3aXRoIGEgcmVtb3ZlZCBlbGVtZW50KS5cblxuICAgICAgICB2YXIgcHJldmlvdXNQb3J0cyA9IHRoaXMucG9ydHM7XG5cbiAgICAgICAgLy8gQ29sbGVjdCBwb3J0cyBmcm9tIHRoZSBgYXR0cnNgIG9iamVjdC5cbiAgICAgICAgdmFyIHBvcnRzID0ge307XG4gICAgICAgIGZvckluKHRoaXMuZ2V0KCdhdHRycycpLCBmdW5jdGlvbihhdHRycywgc2VsZWN0b3IpIHtcblxuICAgICAgICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnBvcnQpIHtcblxuICAgICAgICAgICAgICAgIC8vIGBwb3J0YCBjYW4gZWl0aGVyIGJlIGRpcmVjdGx5IGFuIGBpZGAgb3IgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYGlkYCAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGRhdGEpLlxuICAgICAgICAgICAgICAgIGlmIChhdHRycy5wb3J0LmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydHNbYXR0cnMucG9ydC5pZF0gPSBhdHRycy5wb3J0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRzW2F0dHJzLnBvcnRdID0geyBpZDogYXR0cnMucG9ydCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29sbGVjdCBwb3J0cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIChjb21wYXJlZCB0byB0aGUgcHJldmlvdXMgcG9ydHMpIC0gaWYgYW55LlxuICAgICAgICAvLyBVc2UgaGFzaCB0YWJsZSBmb3IgcXVpY2sgbG9va3VwLlxuICAgICAgICB2YXIgcmVtb3ZlZFBvcnRzID0ge307XG4gICAgICAgIGZvckluKHByZXZpb3VzUG9ydHMsIGZ1bmN0aW9uKHBvcnQsIGlkKSB7XG5cbiAgICAgICAgICAgIGlmICghcG9ydHNbaWRdKSByZW1vdmVkUG9ydHNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCB0aGUgaW5jb21pbmcvb3V0Z29pbmcgbGlua3MgdGhhdCBoYXZlIHNvdXJjZS90YXJnZXQgcG9ydCBzZXQgdG8gYW55IG9mIHRoZSByZW1vdmVkIHBvcnRzLlxuICAgICAgICBpZiAodGhpcy5ncmFwaCAmJiAhaXNFbXB0eShyZW1vdmVkUG9ydHMpKSB7XG5cbiAgICAgICAgICAgIHZhciBpbmJvdW5kTGlua3MgPSB0aGlzLmdyYXBoLmdldENvbm5lY3RlZExpbmtzKHRoaXMsIHsgaW5ib3VuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGluYm91bmRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUG9ydHNbbGluay5nZXQoJ3RhcmdldCcpLnBvcnRdKSBsaW5rLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBvdXRib3VuZExpbmtzID0gdGhpcy5ncmFwaC5nZXRDb25uZWN0ZWRMaW5rcyh0aGlzLCB7IG91dGJvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgb3V0Ym91bmRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUG9ydHNbbGluay5nZXQoJ3NvdXJjZScpLnBvcnRdKSBsaW5rLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGBwb3J0c2Agb2JqZWN0LlxuICAgICAgICB0aGlzLnBvcnRzID0gcG9ydHM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICAvLyBTdG9yZSB0aGUgZ3JhcGggaW4gYSB2YXJpYWJsZSBiZWNhdXNlIGB0aGlzLmdyYXBoYCB3b24ndCBiZSBhY2Nlc3NpYmxlXG4gICAgICAgIC8vIGFmdGVyIGB0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIC4uLilgIGRvd24gYmVsb3cuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGgsIGNvbGxlY3Rpb24gfSA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjb2xsZWN0aW9uIGlzIGEgY29tbW9uIG12YyBjb2xsZWN0aW9uIChub3QgdGhlIGdyYXBoIGNvbGxlY3Rpb24pLlxuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24pIGNvbGxlY3Rpb24ucmVtb3ZlKHRoaXMsIG9wdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGdyYXBoLnN0YXJ0QmF0Y2goJ3JlbW92ZScpO1xuXG4gICAgICAgIC8vIEZpcnN0LCB1bmVtYmVkIHRoaXMgY2VsbCBmcm9tIGl0cyBwYXJlbnQgY2VsbCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgICAgIGNvbnN0IHBhcmVudENlbGwgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgaWYgKHBhcmVudENlbGwpIHtcbiAgICAgICAgICAgIHBhcmVudENlbGwudW5lbWJlZCh0aGlzLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFsc28gYWxsIHRoZSBjZWxscywgd2hpY2ggd2VyZSBlbWJlZGRlZCBpbnRvIHRoaXMgY2VsbFxuICAgICAgICBjb25zdCBlbWJlZGRlZENlbGxzID0gdGhpcy5nZXRFbWJlZGRlZENlbGxzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZW1iZWRkZWRDZWxscy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkID0gZW1iZWRkZWRDZWxsc1tpXTtcbiAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgIGVtYmVkLnJlbW92ZShvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCB0aGlzLCBncmFwaC5hdHRyaWJ1dGVzLmNlbGxzLCBvcHQpO1xuXG4gICAgICAgIGdyYXBoLnN0b3BCYXRjaCgncmVtb3ZlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvRnJvbnQ6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIG9wdCA9IGRlZmF1bHRzKG9wdCB8fCB7fSwgeyBmb3JlZ3JvdW5kRW1iZWRzOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBsZXQgY2VsbHM7XG4gICAgICAgICAgICBpZiAob3B0LmRlZXApIHtcbiAgICAgICAgICAgICAgICBjZWxscyA9IHRoaXMuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUsIGJyZWFkdGhGaXJzdDogb3B0LmJyZWFkdGhGaXJzdCAhPT0gZmFsc2UsIHNvcnRTaWJsaW5nczogb3B0LmZvcmVncm91bmRFbWJlZHMgfSk7XG4gICAgICAgICAgICAgICAgY2VsbHMudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbHMgPSBbdGhpc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZENlbGxzID0gb3B0LmZvcmVncm91bmRFbWJlZHMgPyBjZWxscyA6IHNvcnRCeShjZWxscywgY2VsbCA9PiBjZWxsLnooKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1heFogPSBncmFwaC5tYXhaSW5kZXgoKTtcbiAgICAgICAgICAgIGxldCB6ID0gbWF4WiAtIGNlbGxzLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBncmFwaC5nZXQoJ2NlbGxzJyk7XG5cbiAgICAgICAgICAgIGxldCBzaG91bGRVcGRhdGUgPSAoY29sbGVjdGlvbi50b0FycmF5KCkuaW5kZXhPZihzb3J0ZWRDZWxsc1swXSkgIT09IChjb2xsZWN0aW9uLmxlbmd0aCAtIGNlbGxzLmxlbmd0aCkpO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGUgPSBzb3J0ZWRDZWxscy5zb21lKGZ1bmN0aW9uKGNlbGwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsLnooKSAhPT0geiArIGluZGV4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhdGNoKCd0by1mcm9udCcpO1xuXG4gICAgICAgICAgICAgICAgeiA9IHogKyBjZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzb3J0ZWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgeiArIGluZGV4LCBvcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3RvLWZyb250Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CYWNrOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICBvcHQgPSBkZWZhdWx0cyhvcHQgfHwge30sIHsgZm9yZWdyb3VuZEVtYmVkczogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgbGV0IGNlbGxzO1xuICAgICAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICAgICAgY2VsbHMgPSB0aGlzLmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlLCBicmVhZHRoRmlyc3Q6IG9wdC5icmVhZHRoRmlyc3QgIT09IGZhbHNlLCBzb3J0U2libGluZ3M6IG9wdC5mb3JlZ3JvdW5kRW1iZWRzIH0pO1xuICAgICAgICAgICAgICAgIGNlbGxzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNlbGxzID0gW3RoaXNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRDZWxscyA9IG9wdC5mb3JlZ3JvdW5kRW1iZWRzID8gY2VsbHMgOiBzb3J0QnkoY2VsbHMsIGNlbGwgPT4gY2VsbC56KCkpO1xuXG4gICAgICAgICAgICBsZXQgeiA9IGdyYXBoLm1pblpJbmRleCgpO1xuXG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGdyYXBoLmdldCgnY2VsbHMnKTtcblxuICAgICAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IChjb2xsZWN0aW9uLnRvQXJyYXkoKS5pbmRleE9mKHNvcnRlZENlbGxzWzBdKSAhPT0gMCk7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IHNvcnRlZENlbGxzLnNvbWUoZnVuY3Rpb24oY2VsbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwueigpICE9PSB6ICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3RvLWJhY2snKTtcblxuICAgICAgICAgICAgICAgIHogLT0gY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgc29ydGVkQ2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLnNldCgneicsIHogKyBpbmRleCwgb3B0KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEJhdGNoKCd0by1iYWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcGFyZW50OiBmdW5jdGlvbihwYXJlbnQsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmdldCgncGFyZW50Jyk7XG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3BhcmVudCcsIHBhcmVudCwgb3B0KTtcbiAgICB9LFxuXG4gICAgZW1iZWQ6IGZ1bmN0aW9uKGNlbGwsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuaXNBcnJheShjZWxsKSA/IGNlbGwgOiBbY2VsbF07XG4gICAgICAgIGlmICghdGhpcy5jYW5FbWJlZChjZWxscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVjdXJzaXZlIGVtYmVkZGluZyBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnJlcGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRzID0gdW5pcShjZWxscy5tYXAoYyA9PiBjLmdldFBhcmVudENlbGwoKSkpO1xuXG4gICAgICAgICAgICAvLyBVbmVtYmVkIGNlbGxzIGZyb20gdGhlaXIgY3VycmVudCBwYXJlbnRzLlxuICAgICAgICAgICAgcGFyZW50cy5mb3JFYWNoKChwYXJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDZWxsIGRvZXNuJ3QgaGF2ZSB0byBiZSBlbWJlZGRlZC5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gUGFzcyBhbGwgdGhlIGBjZWxsc2Agc2luY2UgdGhlIGBkaWEuQ2VsbC5fdW5lbWJlZENlbGxzYCBtZXRob2QgY2FuIGhhbmRsZSBjYXNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIG5vdCBhbGwgZWxlbWVudHMgb2YgYGNlbGxzYCBhcmUgZW1iZWRkZWQgaW4gdGhlIHNhbWUgcGFyZW50LlxuICAgICAgICAgICAgICAgIHBhcmVudC5fdW5lbWJlZENlbGxzKGNlbGxzLCBvcHQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjZWxscy5zb21lKGMgPT4gYy5pc0VtYmVkZGVkKCkgJiYgdGhpcy5pZCAhPT0gYy5wYXJlbnQoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW1iZWRkaW5nIG9mIGFscmVhZHkgZW1iZWRkZWQgY2VsbHMgaXMgbm90IGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1iZWRDZWxscyhjZWxscywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuZW1iZWQ6IGZ1bmN0aW9uKGNlbGwsIG9wdCkge1xuICAgICAgICBjb25zdCBjZWxscyA9IEFycmF5LmlzQXJyYXkoY2VsbCkgPyBjZWxsIDogW2NlbGxdO1xuICAgICAgICB0aGlzLl91bmVtYmVkQ2VsbHMoY2VsbHMsIG9wdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjYW5FbWJlZDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICBjb25zdCBjZWxscyA9IEFycmF5LmlzQXJyYXkoY2VsbCkgPyBjZWxsIDogW2NlbGxdO1xuICAgICAgICByZXR1cm4gY2VsbHMuZXZlcnkoYyA9PiB0aGlzICE9PSBjICYmICF0aGlzLmlzRW1iZWRkZWRJbihjKSk7XG4gICAgfSxcblxuICAgIF9lbWJlZENlbGxzOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG4gICAgICAgIGNvbnN0IGJhdGNoTmFtZSA9ICdlbWJlZCc7XG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaChiYXRjaE5hbWUpO1xuICAgICAgICBjb25zdCBlbWJlZHMgPSBhc3NpZ24oW10sIHRoaXMuZ2V0KCdlbWJlZHMnKSk7XG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICAvLyBXZSBrZWVwIGFsbCBlbGVtZW50IGlkcyBhZnRlciBsaW5rIGlkcy5cbiAgICAgICAgICAgIGVtYmVkc1tjZWxsLmlzTGluaygpID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXShjZWxsLmlkKTtcbiAgICAgICAgICAgIGNlbGwucGFyZW50KHRoaXMuaWQsIG9wdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldCgnZW1iZWRzJywgdW5pcShlbWJlZHMpLCBvcHQpO1xuICAgICAgICB0aGlzLnN0b3BCYXRjaChiYXRjaE5hbWUpO1xuICAgIH0sXG5cbiAgICBfdW5lbWJlZENlbGxzOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG4gICAgICAgIGNvbnN0IGJhdGNoTmFtZSA9ICd1bmVtYmVkJztcbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKGJhdGNoTmFtZSk7XG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiBjZWxsLnVuc2V0KCdwYXJlbnQnLCBvcHQpKTtcbiAgICAgICAgdGhpcy5zZXQoJ2VtYmVkcycsIHdpdGhvdXQodGhpcy5nZXQoJ2VtYmVkcycpLCAuLi5jZWxscy5tYXAoY2VsbCA9PiBjZWxsLmlkKSksIG9wdCk7XG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKGJhdGNoTmFtZSk7XG4gICAgfSxcblxuICAgIGdldFBhcmVudENlbGw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIHVubGlrZSBsaW5rLnNvdXJjZS90YXJnZXQsIGNlbGwucGFyZW50IHN0b3JlcyBpZCBkaXJlY3RseSBhcyBhIHN0cmluZ1xuICAgICAgICB2YXIgcGFyZW50SWQgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuXG4gICAgICAgIHJldHVybiAocGFyZW50SWQgJiYgZ3JhcGggJiYgZ3JhcGguZ2V0Q2VsbChwYXJlbnRJZCkpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBhbmNlc3RvciBjZWxscy5cbiAgICAvLyBUaGUgYXJyYXkgaXMgb3JkZXJlZCBmcm9tIHRoZSBwYXJlbnQgb2YgdGhlIGNlbGxcbiAgICAvLyB0byB0aGUgbW9zdCBkaXN0YW50IGFuY2VzdG9yLlxuICAgIGdldEFuY2VzdG9yczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuXG4gICAgICAgIGlmICghdGhpcy5ncmFwaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRDZWxsID0gdGhpcy5nZXRQYXJlbnRDZWxsKCk7XG4gICAgICAgIHdoaWxlIChwYXJlbnRDZWxsKSB7XG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnRDZWxsKTtcbiAgICAgICAgICAgIHBhcmVudENlbGwgPSBwYXJlbnRDZWxsLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfSxcblxuICAgIGdldEVtYmVkZGVkQ2VsbHM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICAvLyBDZWxsIG1vZGVscyBjYW4gb25seSBiZSByZXRyaWV2ZWQgd2hlbiB0aGlzIGVsZW1lbnQgaXMgcGFydCBvZiBhIGNvbGxlY3Rpb24uXG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHdheSB0aGlzIGVsZW1lbnQga25vd3MgYWJvdXQgb3RoZXIgY2VsbHMgb3RoZXJ3aXNlLlxuICAgICAgICAvLyBUaGlzIGFsc28gbWVhbnMgdGhhdCBjYWxsaW5nIGUuZy4gYHRyYW5zbGF0ZSgpYCBvbiBhbiBlbGVtZW50IHdpdGggZW1iZWRzIGJlZm9yZVxuICAgICAgICAvLyBhZGRpbmcgaXQgdG8gYSBncmFwaCBkb2VzIG5vdCB0cmFuc2xhdGUgaXRzIGVtYmVkcy5cbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0LmRlZXApIHtcbiAgICAgICAgICAgIGlmIChvcHQuYnJlYWR0aEZpcnN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEVtYmVkZGVkQ2VsbHNCZnMob3B0LnNvcnRTaWJsaW5ncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRFbWJlZGRlZENlbGxzRGZzKG9wdC5zb3J0U2libGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW1iZWRkZWRJZHMgPSB0aGlzLmdldCgnZW1iZWRzJyk7XG4gICAgICAgIGlmIChpc0VtcHR5KGVtYmVkZGVkSWRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNlbGxzID0gZW1iZWRkZWRJZHMubWFwKHRoaXMuZ3JhcGguZ2V0Q2VsbCwgdGhpcy5ncmFwaCk7XG4gICAgICAgIGlmIChvcHQuc29ydFNpYmxpbmdzKSB7XG4gICAgICAgICAgICBjZWxscyA9IHNvcnRCeShjZWxscywgY2VsbCA9PiBjZWxsLnooKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSxcblxuICAgIF9nZXRFbWJlZGRlZENlbGxzQmZzOiBmdW5jdGlvbihzb3J0U2libGluZ3MpIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBbXTtcblxuICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgICAgICBxdWV1ZS5wdXNoKHRoaXMpO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goY3VycmVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkQ2VsbHMgPSBjdXJyZW50LmdldEVtYmVkZGVkQ2VsbHMoeyBzb3J0U2libGluZ3M6IHNvcnRTaWJsaW5ncyB9KTtcblxuICAgICAgICAgICAgcXVldWUucHVzaCguLi5lbWJlZGRlZENlbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBjZWxscy5zaGlmdCgpO1xuXG4gICAgICAgIHJldHVybiBjZWxscztcbiAgICB9LFxuXG4gICAgX2dldEVtYmVkZGVkQ2VsbHNEZnM6IGZ1bmN0aW9uKHNvcnRTaWJsaW5ncykge1xuICAgICAgICBjb25zdCBjZWxscyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgICAgIHN0YWNrLnB1c2godGhpcyk7XG5cbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNlbGxzLnB1c2goY3VycmVudCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkQ2VsbHMgPSBjdXJyZW50LmdldEVtYmVkZGVkQ2VsbHMoeyBzb3J0U2libGluZ3M6IHNvcnRTaWJsaW5ncyB9KTtcblxuICAgICAgICAgICAgLy8gV2hlbiB1c2luZyB0aGUgc3RhY2ssIGNlbGxzIHRoYXQgYXJlIGVtYmVkZGVkIGxhc3QgYXJlIHByb2Nlc3NlZCBmaXJzdC5cbiAgICAgICAgICAgIC8vIFRvIG1haW50YWluIHRoZSBvcmlnaW5hbCBvcmRlciwgd2UgbmVlZCB0byBwdXNoIHRoZSBjZWxscyBpbiByZXZlcnNlIG9yZGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZW1iZWRkZWRDZWxscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZW1iZWRkZWRDZWxsc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2VsbHMuc2hpZnQoKTtcblxuICAgICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSxcblxuICAgIGlzRW1iZWRkZWRJbjogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGNlbGxJZCA9IGlzU3RyaW5nKGNlbGwpID8gY2VsbCA6IGNlbGwuaWQ7XG4gICAgICAgIHZhciBwYXJlbnRJZCA9IHRoaXMucGFyZW50KCk7XG5cbiAgICAgICAgb3B0ID0gYXNzaWduKHsgZGVlcDogdHJ1ZSB9LCBvcHQpO1xuXG4gICAgICAgIC8vIFNlZSBnZXRFbWJlZGRlZENlbGxzKCkuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoICYmIG9wdC5kZWVwKSB7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCA9PT0gY2VsbElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IHRoaXMuZ3JhcGguZ2V0Q2VsbChwYXJlbnRJZCkucGFyZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMgY2VsbCBpcyBub3QgcGFydCBvZiBhIGNvbGxlY3Rpb24gY2hlY2tcbiAgICAgICAgICAgIC8vIGF0IGxlYXN0IHdoZXRoZXIgaXQncyBhIGRpcmVjdCBjaGlsZCBvZiBnaXZlbiBjZWxsLlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudElkID09PSBjZWxsSWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2hldGhlciBvciBub3QgdGhlIGNlbGwgaXMgZW1iZWRkZWQgaW4gYW55IG90aGVyIGNlbGwuXG4gICAgaXNFbWJlZGRlZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5wYXJlbnQoKTtcbiAgICB9LFxuXG4gICAgLy8gSXNvbGF0ZWQgY2xvbmluZy4gSXNvbGF0ZWQgY2xvbmluZyBoYXMgdHdvIHZlcnNpb25zOiBzaGFsbG93IGFuZCBkZWVwIChwYXNzIGB7IGRlZXA6IHRydWUgfWAgaW4gYG9wdGApLlxuICAgIC8vIFNoYWxsb3cgY2xvbmluZyBzaW1wbHkgY2xvbmVzIHRoZSBjZWxsIGFuZCByZXR1cm5zIGEgbmV3IGNlbGwgd2l0aCBkaWZmZXJlbnQgSUQuXG4gICAgLy8gRGVlcCBjbG9uaW5nIGNsb25lcyB0aGUgY2VsbCBhbmQgYWxsIGl0cyBlbWJlZGRlZCBjZWxscyByZWN1cnNpdmVseS5cbiAgICBjbG9uZTogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIGlmICghb3B0LmRlZXApIHtcbiAgICAgICAgICAgIC8vIFNoYWxsb3cgY2xvbmluZy5cblxuICAgICAgICAgICAgdmFyIGNsb25lID0gTW9kZWwucHJvdG90eXBlLmNsb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRoZSBjbG9uZSB0byBoYXZlIHRoZSBzYW1lIElEIGFzIHRoZSBvcmlnaW5hbC5cbiAgICAgICAgICAgIGNsb25lLnNldCh0aGlzLmdldElkQXR0cmlidXRlKCksIHRoaXMuZ2VuZXJhdGVJZCgpKTtcbiAgICAgICAgICAgIC8vIEEgc2hhbGxvdyBjbG9uZWQgZWxlbWVudCBkb2VzIG5vdCBjYXJyeSBvdmVyIHRoZSBvcmlnaW5hbCBlbWJlZHMuXG4gICAgICAgICAgICBjbG9uZS51bnNldCgnZW1iZWRzJyk7XG4gICAgICAgICAgICAvLyBBbmQgY2FuIG5vdCBiZSBlbWJlZGRlZCBpbiBhbnkgY2VsbFxuICAgICAgICAgICAgLy8gYXMgdGhlIGNsb25lIGlzIG5vdCBwYXJ0IG9mIHRoZSBncmFwaC5cbiAgICAgICAgICAgIGNsb25lLnVuc2V0KCdwYXJlbnQnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWVwIGNsb25pbmcuXG5cbiAgICAgICAgICAgIC8vIEZvciBhIGRlZXAgY2xvbmUsIHNpbXBseSBjYWxsIGBncmFwaC5jbG9uZUNlbGxzKClgIHdpdGggdGhlIGNlbGwgYW5kIGFsbCBpdHMgZW1iZWRkZWQgY2VsbHMuXG4gICAgICAgICAgICByZXR1cm4gdG9BcnJheShjbG9uZUNlbGxzKFt0aGlzXS5jb25jYXQodGhpcy5nZXRFbWJlZGRlZENlbGxzKHsgZGVlcDogdHJ1ZSB9KSkpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBIGNvbnZlbmllbnQgd2F5IHRvIHNldCBuZXN0ZWQgcHJvcGVydGllcy5cbiAgICAvLyBUaGlzIG1ldGhvZCBtZXJnZXMgdGhlIHByb3BlcnRpZXMgeW91J2QgbGlrZSB0byBzZXQgd2l0aCB0aGUgb25lc1xuICAgIC8vIHN0b3JlZCBpbiB0aGUgY2VsbCBhbmQgbWFrZXMgc3VyZSBjaGFuZ2UgZXZlbnRzIGFyZSBwcm9wZXJseSB0cmlnZ2VyZWQuXG4gICAgLy8gWW91IGNhbiBlaXRoZXIgc2V0IGEgbmVzdGVkIHByb3BlcnR5IHdpdGggb25lIG9iamVjdFxuICAgIC8vIG9yIHVzZSBhIHByb3BlcnR5IHBhdGguXG4gICAgLy8gVGhlIG1vc3Qgc2ltcGxlIHVzZSBjYXNlIGlzOlxuICAgIC8vIGBjZWxsLnByb3AoJ25hbWUvZmlyc3QnLCAnSm9obicpYCBvclxuICAgIC8vIGBjZWxsLnByb3AoeyBuYW1lOiB7IGZpcnN0OiAnSm9obicgfSB9KWAuXG4gICAgLy8gTmVzdGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkIHRvbzpcbiAgICAvLyBgY2VsbC5wcm9wKCdzZXJpZXMvMC9kYXRhLzAvZGVncmVlJywgNTApYCBvclxuICAgIC8vIGBjZWxsLnByb3AoeyBzZXJpZXM6IFsgeyBkYXRhOiBbIHsgZGVncmVlOiA1MCB9IF0gfSBdIH0pYC5cbiAgICBwcm9wOiBmdW5jdGlvbihwcm9wcywgdmFsdWUsIG9wdCkge1xuXG4gICAgICAgIHZhciBkZWxpbSA9ICcvJztcbiAgICAgICAgdmFyIF9pc1N0cmluZyA9IGlzU3RyaW5nKHByb3BzKTtcblxuICAgICAgICBpZiAoX2lzU3RyaW5nIHx8IEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICAgICAgICAvLyBHZXQvc2V0IGFuIGF0dHJpYnV0ZSBieSBhIHNwZWNpYWwgcGF0aCBzeW50YXggdGhhdCBkZWxpbWl0c1xuICAgICAgICAgICAgLy8gbmVzdGVkIG9iamVjdHMgYnkgdGhlIGNvbG9uIGNoYXJhY3Rlci5cblxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aEFycmF5O1xuXG4gICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheSA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcHJvcHMuam9pbihkZWxpbSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhBcnJheSA9IHByb3BzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcGF0aEFycmF5WzBdO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoQXJyYXlMZW5ndGggPSBwYXRoQXJyYXkubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG9wdCB8fCB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb3BlcnR5UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eVBhdGhBcnJheSA9IHBhdGhBcnJheTtcbiAgICAgICAgICAgICAgICBpZiAoISgncmV3cml0ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXdyaXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG5lc3RlZCBvYmplY3QuIFN1Yi1vYmplY3RzIGFyZSBlaXRoZXIgYXJyYXlzIG9yIG9iamVjdHMuXG4gICAgICAgICAgICAgICAgLy8gQW4gZW1wdHkgYXJyYXkgaXMgY3JlYXRlZCBpZiB0aGUgc3ViLWtleSBpcyBhbiBpbnRlZ2VyLiBPdGhlcndpc2UsIGFuIGVtcHR5IG9iamVjdCBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGltcG9zZXMgYSBsaW1pdGF0aW9uIG9uIG9iamVjdCBrZXlzIG9uZSBjYW4gdXNlIHdpdGggSW5zcGVjdG9yLlxuICAgICAgICAgICAgICAgIC8vIFB1cmUgaW50ZWdlciBrZXlzIHdpbGwgY2F1c2UgaXNzdWVzIGFuZCBhcmUgdGhlcmVmb3JlIG5vdCBhbGxvd2VkLlxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBhdGhBcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoSXRlbSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQXJyYXlJbmRleCA9IE51bWJlci5pc0Zpbml0ZShfaXNTdHJpbmcgPyBOdW1iZXIocGF0aEl0ZW0pIDogcGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplciA9IGluaXRpYWxpemVyW3ByZXZQcm9wZXJ0eV0gPSBpc0FycmF5SW5kZXggPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcGVydHkgPSBwYXRoSXRlbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBGaWxsIHVwZGF0ZSB3aXRoIHRoZSBgdmFsdWVgIG9uIGBwYXRoYC5cbiAgICAgICAgICAgICAgICB1cGRhdGUgPSBzZXRCeVBhdGgodXBkYXRlLCBwYXRoQXJyYXksIHZhbHVlLCAnLycpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VBdHRyaWJ1dGVzID0gbWVyZ2Uoe30sIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgcmV3cml0ZSBtb2RlIGVuYWJsZWQsIHdlIHJlcGxhY2UgdmFsdWUgcmVmZXJlbmNlZCBieSBwYXRoIHdpdGhcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3IG9uZSAod2UgZG9uJ3QgbWVyZ2UpLlxuICAgICAgICAgICAgICAgIG9wdGlvbnMucmV3cml0ZSAmJiB1bnNldEJ5UGF0aChiYXNlQXR0cmlidXRlcywgcGF0aCwgJy8nKTtcblxuICAgICAgICAgICAgICAgIC8vIE1lcmdlIHVwZGF0ZSB3aXRoIHRoZSBtb2RlbCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbWVyZ2UoYmFzZUF0dHJpYnV0ZXMsIHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gRmluYWxseSwgc2V0IHRoZSBwcm9wZXJ0eSB0byB0aGUgdXBkYXRlZCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChwcm9wZXJ0eSwgYXR0cmlidXRlc1twcm9wZXJ0eV0sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEJ5UGF0aCh0aGlzLmF0dHJpYnV0ZXMsIHByb3BzLCBkZWxpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zID0gdmFsdWUgfHwge307XG4gICAgICAgIC8vIE5vdGU6ICcnIGlzIG5vdCB0aGUgcGF0aCB0byB0aGUgcm9vdC4gSXQncyBhIHBhdGggd2l0aCBhbiBlbXB0eSBzdHJpbmcgaS5lLiB7ICcnOiB7fX0uXG4gICAgICAgIG9wdGlvbnMucHJvcGVydHlQYXRoID0gbnVsbDtcbiAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eVZhbHVlID0gcHJvcHM7XG4gICAgICAgIG9wdGlvbnMucHJvcGVydHlQYXRoQXJyYXkgPSBbXTtcbiAgICAgICAgaWYgKCEoJ3Jld3JpdGUnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnJld3JpdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgY29udGFpbmluZyBvbmx5IHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICAgIGNvbnN0IGNoYW5nZWRBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICAvLyBNZXJnaW5nIHRoZSB2YWx1ZXMgb2YgY2hhbmdlZCBhdHRyaWJ1dGVzIHdpdGggdGhlIGN1cnJlbnQgb25lcy5cbiAgICAgICAgICAgIGNvbnN0IHsgY2hhbmdlZFZhbHVlIH0gPSBtZXJnZSh7fSwgeyBjaGFuZ2VkVmFsdWU6IHRoaXMuYXR0cmlidXRlc1trZXldIH0sIHsgY2hhbmdlZFZhbHVlOiBwcm9wc1trZXldIH0pO1xuICAgICAgICAgICAgY2hhbmdlZEF0dHJpYnV0ZXNba2V5XSA9IGNoYW5nZWRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNldChjaGFuZ2VkQXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIEEgY29udmVuaWVudCB3YXkgdG8gdW5zZXQgbmVzdGVkIHByb3BlcnRpZXNcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihwYXRoLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIHBhdGhBcnJheSA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLycpO1xuXG4gICAgICAgIC8vIE9uY2UgYSBwcm9wZXJ0eSBpcyByZW1vdmVkIGZyb20gdGhlIGBhdHRyc2AgYXR0cmlidXRlXG4gICAgICAgIC8vIHRoZSBjZWxsVmlldyB3aWxsIHJlY29nbml6ZSBhIGBkaXJ0eWAgZmxhZyBhbmQgcmUtcmVuZGVyIGl0c2VsZlxuICAgICAgICAvLyBpbiBvcmRlciB0byByZW1vdmUgdGhlIGF0dHJpYnV0ZSBmcm9tIFNWRyBlbGVtZW50LlxuICAgICAgICB2YXIgcHJvcGVydHkgPSBwYXRoQXJyYXlbMF07XG4gICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2F0dHJzJykgb3B0LmRpcnR5ID0gdHJ1ZTtcblxuICAgICAgICBpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gQSB0b3AgbGV2ZWwgcHJvcGVydHlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2V0KHBhdGgsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIG5lc3RlZCBwcm9wZXJ0eVxuICAgICAgICB2YXIgbmVzdGVkUGF0aCA9IHBhdGhBcnJheS5zbGljZSgxKTtcbiAgICAgICAgdmFyIHByb3BlcnR5VmFsdWUgPSB0aGlzLmdldChwcm9wZXJ0eSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcGVydHlWYWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHByb3BlcnR5VmFsdWUgPSBjbG9uZURlZXAocHJvcGVydHlWYWx1ZSk7XG5cbiAgICAgICAgdW5zZXRCeVBhdGgocHJvcGVydHlWYWx1ZSwgbmVzdGVkUGF0aCwgJy8nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQocHJvcGVydHksIHByb3BlcnR5VmFsdWUsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIEEgY29udmVuaWVudCB3YXkgdG8gc2V0IG5lc3RlZCBhdHRyaWJ1dGVzLlxuICAgIGF0dHI6IGZ1bmN0aW9uKGF0dHJzLCB2YWx1ZSwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdhdHRycycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICAgICAgICBhcmdzWzBdID0gWydhdHRycyddLmNvbmNhdChhdHRycyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoYXR0cnMpKSB7XG4gICAgICAgICAgICAvLyBHZXQvc2V0IGFuIGF0dHJpYnV0ZSBieSBhIHNwZWNpYWwgcGF0aCBzeW50YXggdGhhdCBkZWxpbWl0c1xuICAgICAgICAgICAgLy8gbmVzdGVkIG9iamVjdHMgYnkgdGhlIGNvbG9uIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGFyZ3NbMF0gPSAnYXR0cnMvJyArIGF0dHJzO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGFyZ3NbMF0gPSB7ICdhdHRycycgOiBhdHRycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gQSBjb252ZW5pZW50IHdheSB0byB1bnNldCBuZXN0ZWQgYXR0cmlidXRlc1xuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKHBhdGgsIG9wdCkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVByb3AoWydhdHRycyddLmNvbmNhdChwYXRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVQcm9wKCdhdHRycy8nICsgcGF0aCwgb3B0KTtcbiAgICB9LFxuXG4gICAgdHJhbnNpdGlvbjogZnVuY3Rpb24ocGF0aCwgdmFsdWUsIG9wdCwgZGVsaW0pIHtcblxuICAgICAgICBkZWxpbSA9IGRlbGltIHx8ICcvJztcblxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICAgICAgZGVsYXk6IDEwLFxuICAgICAgICAgICAgdGltaW5nRnVuY3Rpb246IHRpbWluZy5saW5lYXIsXG4gICAgICAgICAgICB2YWx1ZUZ1bmN0aW9uOiBpbnRlcnBvbGF0ZS5udW1iZXJcbiAgICAgICAgfTtcblxuICAgICAgICBvcHQgPSBhc3NpZ24oZGVmYXVsdHMsIG9wdCk7XG5cbiAgICAgICAgdmFyIGZpcnN0RnJhbWVUaW1lID0gMDtcbiAgICAgICAgdmFyIGludGVycG9sYXRpbmdGdW5jdGlvbjtcblxuICAgICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24ocnVudGltZSkge1xuXG4gICAgICAgICAgICB2YXIgaWQsIHByb2dyZXNzLCBwcm9wZXJ0eVZhbHVlO1xuXG4gICAgICAgICAgICBmaXJzdEZyYW1lVGltZSA9IGZpcnN0RnJhbWVUaW1lIHx8IHJ1bnRpbWU7XG4gICAgICAgICAgICBydW50aW1lIC09IGZpcnN0RnJhbWVUaW1lO1xuICAgICAgICAgICAgcHJvZ3Jlc3MgPSBydW50aW1lIC8gb3B0LmR1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbklkc1twYXRoXSA9IGlkID0gbmV4dEZyYW1lKHNldHRlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzID0gMTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fdHJhbnNpdGlvbklkc1twYXRoXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IGludGVycG9sYXRpbmdGdW5jdGlvbihvcHQudGltaW5nRnVuY3Rpb24ocHJvZ3Jlc3MpKTtcblxuICAgICAgICAgICAgb3B0LnRyYW5zaXRpb25JZCA9IGlkO1xuXG4gICAgICAgICAgICB0aGlzLnByb3AocGF0aCwgcHJvcGVydHlWYWx1ZSwgb3B0KTtcblxuICAgICAgICAgICAgaWYgKCFpZCkgdGhpcy50cmlnZ2VyKCd0cmFuc2l0aW9uOmVuZCcsIHRoaXMsIHBhdGgpO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICBjb25zdCB7IF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaW5pdGlhbElkO1xuXG4gICAgICAgIHZhciBpbml0aWF0b3IgPSAoY2FsbGJhY2spID0+IHtcblxuICAgICAgICAgICAgaWYgKF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdKSB7XG4gICAgICAgICAgICAgICAgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0gPSB3aXRob3V0KF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdLCBpbml0aWFsSWQpO1xuICAgICAgICAgICAgICAgIGlmIChfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9wUGVuZGluZ1RyYW5zaXRpb25zKHBhdGgsIGRlbGltKTtcblxuICAgICAgICAgICAgaW50ZXJwb2xhdGluZ0Z1bmN0aW9uID0gb3B0LnZhbHVlRnVuY3Rpb24oZ2V0QnlQYXRoKHRoaXMuYXR0cmlidXRlcywgcGF0aCwgZGVsaW0pLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25JZHNbcGF0aF0gPSBuZXh0RnJhbWUoY2FsbGJhY2spO1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RyYW5zaXRpb246c3RhcnQnLCB0aGlzLCBwYXRoKTtcblxuICAgICAgICB9O1xuXG4gICAgICAgIGluaXRpYWxJZCA9IHNldFRpbWVvdXQoaW5pdGlhdG9yLCBvcHQuZGVsYXksIHNldHRlcik7XG5cbiAgICAgICAgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0gfHwgKF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdID0gW10pO1xuICAgICAgICBfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXS5wdXNoKGluaXRpYWxJZCk7XG5cbiAgICAgICAgcmV0dXJuIGluaXRpYWxJZDtcbiAgICB9LFxuXG4gICAgZ2V0VHJhbnNpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5pb24oXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl90cmFuc2l0aW9uSWRzKSxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NjaGVkdWxlZFRyYW5zaXRpb25JZHMpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHN0b3BTY2hlZHVsZWRUcmFuc2l0aW9uczogZnVuY3Rpb24ocGF0aCwgZGVsaW0gPSAnLycpIHtcbiAgICAgICAgY29uc3QgeyBfc2NoZWR1bGVkVHJhbnNpdGlvbklkcyA9IHt9fSA9IHRoaXM7XG4gICAgICAgIGxldCB0cmFuc2l0aW9ucyA9IE9iamVjdC5rZXlzKF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzKTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhBcnJheSA9IHBhdGguc3BsaXQoZGVsaW0pO1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKHBhdGhBcnJheSwga2V5LnNwbGl0KGRlbGltKS5zbGljZSgwLCBwYXRoQXJyYXkubGVuZ3RoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9ucy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25JZHMgPSBfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1trZXldO1xuICAgICAgICAgICAgLy8gc3RvcCB0aGUgaW5pdGlhdG9yXG4gICAgICAgICAgICB0cmFuc2l0aW9uSWRzLmZvckVhY2godHJhbnNpdGlvbklkID0+IGNsZWFyVGltZW91dCh0cmFuc2l0aW9uSWQpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1trZXldO1xuICAgICAgICAgICAgLy8gTm90ZTogd2UgY291bGQgdHJpZ2dlciB0cmFuc2l0aW9uOmNhbmNlbGAgZXZlbnQgaGVyZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0b3BQZW5kaW5nVHJhbnNpdGlvbnMocGF0aCwgZGVsaW0gPSAnLycpIHtcbiAgICAgICAgY29uc3QgeyBfdHJhbnNpdGlvbklkcyA9IHt9fSA9IHRoaXM7XG4gICAgICAgIGxldCB0cmFuc2l0aW9ucyA9IE9iamVjdC5rZXlzKF90cmFuc2l0aW9uSWRzKTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhBcnJheSA9IHBhdGguc3BsaXQoZGVsaW0pO1xuICAgICAgICAgICAgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKHBhdGhBcnJheSwga2V5LnNwbGl0KGRlbGltKS5zbGljZSgwLCBwYXRoQXJyYXkubGVuZ3RoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2l0aW9ucy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25JZCA9IF90cmFuc2l0aW9uSWRzW2tleV07XG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBzZXR0ZXJcbiAgICAgICAgICAgIGNhbmNlbEZyYW1lKHRyYW5zaXRpb25JZCk7XG4gICAgICAgICAgICBkZWxldGUgX3RyYW5zaXRpb25JZHNba2V5XTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndHJhbnNpdGlvbjplbmQnLCB0aGlzLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgc3RvcFRyYW5zaXRpb25zOiBmdW5jdGlvbihwYXRoLCBkZWxpbSA9ICcvJykge1xuICAgICAgICB0aGlzLnN0b3BTY2hlZHVsZWRUcmFuc2l0aW9ucyhwYXRoLCBkZWxpbSk7XG4gICAgICAgIHRoaXMuc3RvcFBlbmRpbmdUcmFuc2l0aW9ucyhwYXRoLCBkZWxpbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBIHNob3JjdXQgbWFraW5nIGl0IGVhc3kgdG8gY3JlYXRlIGNvbnN0cnVjdHMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICAgIC8vIGB2YXIgZWwgPSAobmV3IGpvaW50LnNoYXBlcy5zdGFuZGFyZC5SZWN0YW5nbGUoKSkuYWRkVG8oZ3JhcGgpYC5cbiAgICBhZGRUbzogZnVuY3Rpb24oZ3JhcGgsIG9wdCkge1xuXG4gICAgICAgIGdyYXBoLmFkZENlbGwodGhpcywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgc2hvcnRjdXQgZm9yIGFuIGVxdWl2YWxlbnQgY2FsbDogYHBhcGVyLmZpbmRWaWV3QnlNb2RlbChjZWxsKWBcbiAgICAvLyBtYWtpbmcgaXQgZWFzeSB0byBjcmVhdGUgY29uc3RydWN0cyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gYGNlbGwuZmluZFZpZXcocGFwZXIpLmhpZ2hsaWdodCgpYFxuICAgIGZpbmRWaWV3OiBmdW5jdGlvbihwYXBlcikge1xuXG4gICAgICAgIHJldHVybiBwYXBlci5maW5kVmlld0J5TW9kZWwodGhpcyk7XG4gICAgfSxcblxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBpc0xpbms6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgc3RhcnRCYXRjaDogZnVuY3Rpb24obmFtZSwgb3B0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHsgdGhpcy5ncmFwaC5zdGFydEJhdGNoKG5hbWUsIGFzc2lnbih7fSwgb3B0LCB7IGNlbGw6IHRoaXMgfSkpOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzdG9wQmF0Y2g6IGZ1bmN0aW9uKG5hbWUsIG9wdCkge1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7IHRoaXMuZ3JhcGguc3RvcEJhdGNoKG5hbWUsIGFzc2lnbih7fSwgb3B0LCB7IGNlbGw6IHRoaXMgfSkpOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDaGFuZ2VGbGFnOiBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG5cbiAgICAgICAgdmFyIGZsYWcgPSAwO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHJldHVybiBmbGFnO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkgfHwgIXRoaXMuaGFzQ2hhbmdlZChrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZsYWcgfD0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gVG8gYmUgb3ZlcnJpZGRlbi5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuLlxuICAgICAgICByZXR1cm4gbmV3IGcuUG9pbnQoMCwgMCk7XG4gICAgfSxcblxuICAgIHo6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ3onKSB8fCAwO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuXG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2ludCgpO1xuICAgIH0sXG5cbiAgICBnZXRCQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuXG4gICAgICAgIHJldHVybiBuZXcgZy5SZWN0KDAsIDAsIDAsIDApO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludFJvdGF0ZWRBcm91bmRDZW50ZXIoYW5nbGUsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBuZXcgZy5Qb2ludCh4LCB5KTtcbiAgICAgICAgaWYgKGFuZ2xlKSBwb2ludC5yb3RhdGUodGhpcy5nZXRCQm94KCkuY2VudGVyKCksIGFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0sXG5cbiAgICBnZXRBYnNvbHV0ZVBvaW50RnJvbVJlbGF0aXZlKHgsIHkpIHtcbiAgICAgICAgLy8gUm90YXRlIHRoZSBwb3NpdGlvbiB0byB0YWtlIHRoZSBtb2RlbCBhbmdsZSBpbnRvIGFjY291bnRcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRSb3RhdGVkQXJvdW5kQ2VudGVyKFxuICAgICAgICAgICAgLXRoaXMuYW5nbGUoKSxcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gYWJzb2x1dGVcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKS5vZmZzZXQoeCwgeSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVsYXRpdmVQb2ludEZyb21BYnNvbHV0ZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGNvb3JkaW5hdGVzIHRvIG1pdGlnYXRlIHRoZSBlbGVtZW50J3Mgcm90YXRpb24uXG4gICAgICAgICAgICAuZ2V0UG9pbnRSb3RhdGVkQXJvdW5kQ2VudGVyKHRoaXMuYW5nbGUoKSwgeCwgeSlcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgYWJzb2x1dGUgcG9zaXRpb24gaW50byByZWxhdGl2ZVxuICAgICAgICAgICAgLmRpZmZlcmVuY2UodGhpcy5wb3NpdGlvbigpKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIGdldEF0dHJpYnV0ZURlZmluaXRpb246IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG5cbiAgICAgICAgdmFyIGRlZk5TID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgZ2xvYmFsRGVmTlMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gKGRlZk5TICYmIGRlZk5TW2F0dHJOYW1lXSkgfHwgZ2xvYmFsRGVmTlNbYXR0ck5hbWVdO1xuICAgIH0sXG5cbiAgICBkZWZpbmU6IGZ1bmN0aW9uKHR5cGUsIGRlZmF1bHRzLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuXG4gICAgICAgIHByb3RvUHJvcHMgPSBhc3NpZ24oe1xuICAgICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzRGVlcCh7IHR5cGU6IHR5cGUgfSwgZGVmYXVsdHMsIHRoaXMucHJvdG90eXBlLmRlZmF1bHRzKVxuICAgICAgICB9LCBwcm90b1Byb3BzKTtcblxuICAgICAgICB2YXIgQ2VsbCA9IHRoaXMuZXh0ZW5kKHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgLy8gZXM1IGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzKGpvaW50LCAnc2hhcGVzJykpIHtcbiAgICAgICAgICAgIHNldEJ5UGF0aChqb2ludC5zaGFwZXMsIHR5cGUsIENlbGwsICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICByZXR1cm4gQ2VsbDtcbiAgICB9XG59KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/CellView.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellView: () => (/* binding */ CellView)\n/* harmony export */ });\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n/* harmony import */ var _attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attributes/eval.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/eval.mjs\");\n\n\n\n\n\n\n\n\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\nconst Flags = {\n    TOOLS: 'TOOLS',\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nconst CellView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'presentationAttributes');\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'initFlag');\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.guid)(this);\n\n        _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        this.startListening();\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.parseDOMJSON)(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(interactive) && interactive[feature] !== false) ||\n            ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (this.useCSSSelectors) return (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(root).find(selector).toArray();\n\n        return [];\n    },\n\n    findNodes: function(selector) {\n        return this.findBySelector(selector, this.el, this.selectors);\n    },\n\n    findNode: function(selector) {\n        const [node = null] = this.findNodes(selector);\n        return node;\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        const rect = this.getNodeBoundingRect(magnet);\n        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n        const magnetMatrix = this.getNodeMatrix(magnet);\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformRect(rect, transformMatrix.multiply(magnetMatrix));\n    },\n\n    getNodeRotateMatrix(node) {\n        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n            // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n        }\n        // Nodes outside the rotatable group\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix();\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            node = this.findNode(el) || rootNode;\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const proxyNode = this.findNode(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        const model = this.model;\n        const id = model.id;\n        // Find a node with the `port` attribute set on it.\n        const portNode = this.findAttributeNode('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        const selector = magnet.getAttribute('joint-selector');\n\n        const end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (portNode != null) {\n            let port = portNode.getAttribute('port');\n            if (portNode.getAttribute('port-id-type') === 'number') {\n                port = parseInt(port, 10);\n            }\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || this.el;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findNode(selector);\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch('add-link');\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView });\n    },\n\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(attrs)) {\n            if (node instanceof SVGElement) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(node).attr(attrs);\n            } else {\n                (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        const rawAttrs = {};\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            rawAttrs[_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].attributeNames[attrName]] = attrs[attrName];\n        }\n        // divide the attributes between normal and special\n        for (attrName in rawAttrs) {\n            if (!rawAttrs.hasOwnProperty(attrName)) continue;\n            attrVal = rawAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def) {\n                if (attrVal === null) {\n                    // Assign the unset attribute name.\n                    let unsetAttrName;\n                    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.unset)) {\n                        unsetAttrName = def.unset.call(this, node, rawAttrs, this);\n                    } else {\n                        unsetAttrName = def.unset;\n                    }\n                    if (!unsetAttrName && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(def.set)) {\n                        // We unset an alias attribute.\n                        unsetAttrName = def.set;\n                    }\n                    if (!unsetAttrName) {\n                        // There is no alias for the attribute. We unset the attribute itself.\n                        unsetAttrName = attrName;\n                    }\n                    // Unset the attribute.\n                    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(unsetAttrName) && unsetAttrName) {\n                        // Unset a single attribute.\n                        normalAttrs || (normalAttrs = {});\n                        // values takes precedence over unset values\n                        if (unsetAttrName in normalAttrs) continue;\n                        normalAttrs[unsetAttrName] = attrVal;\n                    } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {\n                        // Unset multiple attributes.\n                        normalAttrs || (normalAttrs = {});\n                        for (i = 0, n = unsetAttrName.length; i < n; i++) {\n                            const attrName = unsetAttrName[i];\n                            // values takes precedence over unset values\n                            if (attrName in normalAttrs) continue;\n                            normalAttrs[attrName] = attrVal;\n                        }\n                    }\n                    // The unset value is neither a string nor an array.\n                    // The attribute is not unset.\n                } else {\n                    if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {\n                        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(def.set)) {\n                            // An alias e.g 'xlink:href' -> 'href'\n                            normalAttrs || (normalAttrs = {});\n                            normalAttrs[def.set] = attrVal;\n                        }\n                        relatives.push(attrName, def);\n                    } else {\n                        normalAttrs || (normalAttrs = {});\n                        normalAttrs[attrName] = attrVal;\n                    }\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[attrName] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: rawAttrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var evalAttrs = (0,_attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__.evalAttributes)(attrs.raw || {}, refBBox);\n        var nodeAttrs = attrs.normal || {};\n        for (const nodeAttrName in nodeAttrs) {\n            nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n        }\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(setResult)) {\n                (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformStringToMatrix(nodeTransform);\n        var nodePosition = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point)(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit)(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if (translation) {\n                nodePosition.offset((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point)(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = evalAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n                    if (translation) {\n                        nodePosition.offset((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point)(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    cleanNodeCache: function(node) {\n        const id = node.id;\n        if (!id) return;\n        delete this.metrics[id];\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(magnet).getBBox();\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        const metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            const { rotatableNode, el } = this;\n            let target;\n            if (rotatableNode && rotatableNode.contains(magnet)) {\n                target = rotatableNode;\n            } else {\n                target = el;\n            }\n            metrics.magnetMatrix = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(magnet).getTransformToElement(target);\n        }\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.sortedIndex)(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (\n            // Explicitly defined `fromPoint` option\n            opt.fromPoint ||\n            // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n            // It holds the element when a touchstart triggered.\n            type === 'touchmove' || type === 'touchend' ||\n            // Pointermove/Pointerup event with the pointer captured\n            ('pointerId' in evt && target.hasPointerCapture(evt.pointerId))\n        ) {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Rect)());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, (0,_attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__.evalAttributes)(processedAttrs.normal, opt.rootBBox));\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        for (let i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            const refNodeId = refNode ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ensureId(refNode) : '';\n            let refBBox = bboxCache[refNodeId];\n            if (!refBBox) {\n                // Get the bounding box of the reference element using to the common ancestor\n                // transformation space.\n                //\n                // @example 1\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                //     <rect @selector=\"a\"/>\n                // </g>\n                //\n                // In this case, the reference bounding box can not be affected\n                // by the `transform` attribute of the `<g>` element,\n                // because the exact transformation will be applied to the `a` element\n                // as well as to the `b` element.\n                //\n                // @example 2\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                // </g>\n                // <rect @selector=\"a\"/>\n                //\n                // In this case, the reference bounding box have to be affected by the\n                // `transform` attribute of the `<g>` element, because the `a` element\n                // is not descendant of the `<g>` element and will not be affected\n                // by the transformation.\n                refBBox = bboxCache[refNodeId] = (refNode)\n                    ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(refNode).getBBox({ target: getCommonAncestorNode(node, refNode) })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(processedAttrs.set, roProcessedAttrs.set);\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(processedAttrs.position, roProcessedAttrs.position);\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    // Lifecycle methods\n\n    // Called when the view is attached to the DOM,\n    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n    onMount(isInitialMount) {\n        if (isInitialMount) return;\n        this.mountTools();\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.mount(this);\n    },\n\n    // Called when the view is detached from the DOM,\n    // as result of `paper.options.viewport` returning `false`.\n    onDetach() {\n        this.unmountTools();\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.unmount(this);\n    },\n\n    // Called when the view is removed from the DOM\n    // as result of `cell.remove()`.\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    unmountTools() {\n        const toolsView = this._toolsView;\n        if (toolsView) toolsView.unmount();\n        return this;\n    },\n\n    mountTools() {\n        const toolsView = this._toolsView;\n        // Prevent unnecessary re-appending of the tools.\n        if (toolsView && !toolsView.isMounted()) toolsView.mount();\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    preventDefaultInteraction(evt) {\n        this.eventData(evt, { defaultInteractionPrevented: true  });\n    },\n\n    isDefaultInteractionPrevented(evt) {\n        const { defaultInteractionPrevented = false } = this.eventData(evt);\n        return defaultInteractionPrevented;\n    },\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper, model } = this;\n        if (paper.isAsync()) {\n            // Make sure the source/target views are updated before this view.\n            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n            // The connected cells could be links as well. In that case, we would\n            // need to recursively go through all the connected links and update\n            // their source/target views as well.\n            if (model.isLink()) {\n                // The `this.sourceView` and `this.targetView` might not be updated yet.\n                // We need to find the view by the model.\n                const sourceElement = model.getSourceElement();\n                if (sourceElement) {\n                    const sourceView = paper.findViewByModel(sourceElement);\n                    if (sourceView) {\n                        paper.dumpView(sourceView);\n                        paper.checkViewVisibility(sourceView);\n                    }\n                }\n                const targetElement = model.getTargetElement();\n                if (targetElement) {\n                    const targetView = paper.findViewByModel(targetElement);\n                    if (targetView) {\n                        paper.dumpView(targetView);\n                        paper.checkViewVisibility(targetView);\n                    }\n                }\n            }\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n            paper.checkViewVisibility(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    },\n\n    isIntersecting: function(geometryShape, geometryData) {\n        return _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__.intersection.exists(geometryShape, this.getNodeBBox(this.el), geometryData);\n    },\n\n    isEnclosedIn: function(geometryRect) {\n        return geometryRect.containsRect(this.getNodeBBox(this.el));\n    },\n\n    isInArea: function(geometryRect, options = {}) {\n        if (options.strict) {\n            return this.isEnclosedIn(geometryRect);\n        }\n        return this.isIntersecting(geometryRect);\n    },\n\n    isAtPoint: function(point, options) {\n        return this.getNodeBBox(this.el).containsPoint(point, options);\n    }\n\n}, {\n\n    Flags,\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq)(a.concat(b));\n        });\n    },\n\n    evalAttribute: _attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__.evalAttribute,\n\n});\n\n\nObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n    get() {\n        const localUse = this.model.useCSSSelectors;\n        if (localUse !== undefined) return localUse;\n        return _config_index_mjs__WEBPACK_IMPORTED_MODULE_10__.config.useCSSSelectors;\n    }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n    let parent = node1;\n    do {\n        if (parent.contains(node2)) return parent;\n        parent = parent.parentNode;\n    } while (parent);\n    return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9DZWxsVmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0w7QUFnQmI7QUFDZ0M7QUFDNUI7QUFDTTtBQUNtQjtBQUNjOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNPLGlCQUFpQixnREFBSTs7QUFFNUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdURBQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFNO0FBQzdCO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBSTs7QUFFdkMsUUFBUSxnREFBSTtBQUNaLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUEsUUFBUSxnREFBSTs7QUFFWjs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFNO0FBQ3JCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9DZWxsVmlldy5tanM/YjAyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcvaW5kZXgubWpzJztcbmltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCB7XG4gICAgYXNzaWduLFxuICAgIGd1aWQsXG4gICAgb21pdCxcbiAgICBwYXJzZURPTUpTT04sXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc09iamVjdCxcbiAgICBpc1BsYWluT2JqZWN0LFxuICAgIGlzQm9vbGVhbixcbiAgICBpc0VtcHR5LFxuICAgIGlzU3RyaW5nLFxuICAgIHJlc3VsdCxcbiAgICBzb3J0ZWRJbmRleCxcbiAgICBtZXJnZSxcbiAgICB1bmlxXG59IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFBvaW50LCBSZWN0LCBpbnRlcnNlY3Rpb24gfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgJCBmcm9tICcuLi9tdmMvRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuL0hpZ2hsaWdodGVyVmlldy5tanMnO1xuaW1wb3J0IHsgZXZhbEF0dHJpYnV0ZXMsIGV2YWxBdHRyaWJ1dGUgfSBmcm9tICcuL2F0dHJpYnV0ZXMvZXZhbC5tanMnO1xuXG5jb25zdCBIaWdobGlnaHRpbmdUeXBlcyA9IHtcbiAgICBERUZBVUxUOiAnZGVmYXVsdCcsXG4gICAgRU1CRURESU5HOiAnZW1iZWRkaW5nJyxcbiAgICBDT05ORUNUSU5HOiAnY29ubmVjdGluZycsXG4gICAgTUFHTkVUX0FWQUlMQUJJTElUWTogJ21hZ25ldEF2YWlsYWJpbGl0eScsXG4gICAgRUxFTUVOVF9BVkFJTEFCSUxJVFk6ICdlbGVtZW50QXZhaWxhYmlsaXR5J1xufTtcblxuY29uc3QgRmxhZ3MgPSB7XG4gICAgVE9PTFM6ICdUT09MUycsXG59O1xuXG4vLyBDZWxsVmlldyBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBUaGlzIGlzIHRoZSBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIgZm9yIGBFbGVtZW50Vmlld2AgYW5kIGBMaW5rVmlld2AuXG5leHBvcnQgY29uc3QgQ2VsbFZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAnZycsXG5cbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuXG4gICAgc2VsZWN0b3I6ICdyb290JyxcblxuICAgIG1ldHJpY3M6IG51bGwsXG5cbiAgICBjbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gWydjZWxsJ107XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5tb2RlbC5nZXQoJ3R5cGUnKTtcblxuICAgICAgICBpZiAodHlwZSkge1xuXG4gICAgICAgICAgICB0eXBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy4nKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgndHlwZS0nICsgbGlzdC5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgX3ByZXNlbnRhdGlvbkF0dHJpYnV0ZXM6IG51bGwsXG4gICAgX2ZsYWdzOiBudWxsLFxuXG4gICAgc2V0RmxhZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSB7fTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgdmFyIHNoaWZ0ID0gMDtcbiAgICAgICAgdmFyIGksIG4sIGxhYmVsO1xuICAgICAgICB2YXIgcHJlc2VudGF0aW9uQXR0cmlidXRlcyA9IHJlc3VsdCh0aGlzLCAncHJlc2VudGF0aW9uQXR0cmlidXRlcycpO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gcHJlc2VudGF0aW9uQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFwcmVzZW50YXRpb25BdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGxhYmVscyA9IHByZXNlbnRhdGlvbkF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSBsYWJlbHMgPSBbbGFiZWxzXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGZsYWcgPSBmbGFnc1tsYWJlbF07XG4gICAgICAgICAgICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tsYWJlbF0gPSAxPDwoc2hpZnQrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXSB8PSBmbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbml0RmxhZyA9IHJlc3VsdCh0aGlzLCAnaW5pdEZsYWcnKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluaXRGbGFnKSkgaW5pdEZsYWcgPSBbaW5pdEZsYWddO1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gaW5pdEZsYWcubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGluaXRGbGFnW2ldO1xuICAgICAgICAgICAgaWYgKCFmbGFnc1tsYWJlbF0pIGZsYWdzW2xhYmVsXSA9IDE8PChzaGlmdCsrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDI2IC0gMzAgYXJlIHJlc2VydmVkIGZvciBwYXBlciBmbGFnc1xuICAgICAgICAvLyAzMSsgb3ZlcmZsb3dzIG1heGltYWwgbnVtYmVyXG4gICAgICAgIGlmIChzaGlmdCA+IDI1KSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5DZWxsVmlldzogTWF4aW11bSBudW1iZXIgb2YgZmxhZ3MgZXhjZWVkZWQuJyk7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5fcHJlc2VudGF0aW9uQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgfSxcblxuICAgIGhhc0ZsYWc6IGZ1bmN0aW9uKGZsYWcsIGxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFnICYgdGhpcy5nZXRGbGFnKGxhYmVsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRmxhZzogZnVuY3Rpb24oZmxhZywgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcgXiAoZmxhZyAmIHRoaXMuZ2V0RmxhZyhsYWJlbCkpO1xuICAgIH0sXG5cbiAgICBnZXRGbGFnOiBmdW5jdGlvbihsYWJlbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSB0aGlzLl9mbGFncztcbiAgICAgICAgaWYgKCFmbGFncykgcmV0dXJuIDA7XG4gICAgICAgIHZhciBmbGFnID0gMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxhYmVsLmxlbmd0aDsgaSA8IG47IGkrKykgZmxhZyB8PSBmbGFnc1tsYWJlbFtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGFnIHw9IGZsYWdzW2xhYmVsXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9LFxuXG4gICAgYXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdtb2RlbC1pZCc6IGNlbGwuaWQsXG4gICAgICAgICAgICAnZGF0YS10eXBlJzogY2VsbC5hdHRyaWJ1dGVzLnR5cGVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYSBnbG9iYWwgdW5pcXVlIGlkIGlzIGFzc2lnbmVkIHRvIHRoaXMgdmlldy4gU3RvcmUgdGhpcyBpZCBhbHNvIHRvIHRoZSBwcm9wZXJ0aWVzIG9iamVjdC5cbiAgICAgICAgLy8gVGhlIGdsb2JhbCB1bmlxdWUgaWQgbWFrZXMgc3VyZSB0aGF0IHRoZSBzYW1lIHZpZXcgY2FuIGJlIHJlbmRlcmVkIG9uIGUuZy4gZGlmZmVyZW50IG1hY2hpbmVzIGFuZFxuICAgICAgICAvLyBzdGlsbCBiZSBhc3NvY2lhdGVkIHRvIHRoZSBzYW1lIG9iamVjdCBhbW9uZyBhbGwgdGhvc2UgY2xpZW50cy4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIHJlYWwtdGltZVxuICAgICAgICAvLyBjb2xsYWJvcmF0aW9uIG1lY2hhbmlzbS5cbiAgICAgICAgb3B0aW9ucy5pZCA9IG9wdGlvbnMuaWQgfHwgZ3VpZCh0aGlzKTtcblxuICAgICAgICBWaWV3LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuc2V0RmxhZ3MoKTtcblxuICAgICAgICBWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5jbGVhbk5vZGVzQ2FjaGUoKTtcblxuICAgICAgICB0aGlzLnN0YXJ0TGlzdGVuaW5nKCk7XG4gICAgfSxcblxuICAgIHN0YXJ0TGlzdGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCAnY2hhbmdlJywgdGhpcy5vbkF0dHJpYnV0ZXNDaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBvbkF0dHJpYnV0ZXNDaGFuZ2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcbiAgICAgICAgdmFyIGZsYWcgPSBtb2RlbC5nZXRDaGFuZ2VGbGFnKHRoaXMuX3ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAob3B0LnVwZGF0ZUhhbmRsZWQgfHwgIWZsYWcpIHJldHVybjtcbiAgICAgICAgaWYgKG9wdC5kaXJ0eSAmJiB0aGlzLmhhc0ZsYWcoZmxhZywgJ1VQREFURScpKSBmbGFnIHw9IHRoaXMuZ2V0RmxhZygnUkVOREVSJyk7XG4gICAgICAgIC8vIFRPRE86IHRvb2wgY2hhbmdlcyBkb2VzIG5vdCBuZWVkIHRvIGJlIHN5bmNcbiAgICAgICAgLy8gRml4IFNlZ21lbnRzIHRvb2xzXG4gICAgICAgIGlmIChvcHQudG9vbCkgb3B0LmFzeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxdWVzdFVwZGF0ZShmbGFnLCBvcHQpO1xuICAgIH0sXG5cbiAgICByZXF1ZXN0VXBkYXRlOiBmdW5jdGlvbihmbGFncywgb3B0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwYXBlciAmJiBmbGFncyA+IDApIHtcbiAgICAgICAgICAgIHBhcGVyLnJlcXVlc3RWaWV3VXBkYXRlKHRoaXMsIGZsYWdzLCB0aGlzLlVQREFURV9QUklPUklUWSwgb3B0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXJzZURPTUpTT046IGZ1bmN0aW9uKG1hcmt1cCwgcm9vdCkge1xuXG4gICAgICAgIHZhciBkb2MgPSBwYXJzZURPTUpTT04obWFya3VwKTtcbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IGRvYy5zZWxlY3RvcnM7XG4gICAgICAgIHZhciBncm91cHMgPSBkb2MuZ3JvdXBTZWxlY3RvcnM7XG4gICAgICAgIGZvciAodmFyIGdyb3VwIGluIGdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc1tncm91cF0pIHRocm93IG5ldyBFcnJvcignZGlhLkNlbGxWaWV3OiBhbWJpZ3VvdXMgZ3JvdXAgc2VsZWN0b3InKTtcbiAgICAgICAgICAgIHNlbGVjdG9yc1tncm91cF0gPSBncm91cHNbZ3JvdXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICB2YXIgcm9vdFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RvcnNbcm9vdFNlbGVjdG9yXSkgdGhyb3cgbmV3IEVycm9yKCdkaWEuQ2VsbFZpZXc6IGFtYmlndW91cyByb290IHNlbGVjdG9yLicpO1xuICAgICAgICAgICAgc2VsZWN0b3JzW3Jvb3RTZWxlY3Rvcl0gPSByb290O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyYWdtZW50OiBkb2MuZnJhZ21lbnQsIHNlbGVjdG9yczogc2VsZWN0b3JzIH07XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaWYgY2VsbCBsaW5rIGlzIGFsbG93ZWQgdG8gcGVyZm9ybSBhIGNlcnRhaW4gVUkgYGZlYXR1cmVgLlxuICAgIC8vIEV4YW1wbGU6IGBjYW4oJ2xhYmVsTW92ZScpYC5cbiAgICBjYW46IGZ1bmN0aW9uKGZlYXR1cmUpIHtcblxuICAgICAgICB2YXIgaW50ZXJhY3RpdmUgPSBpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSlcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmludGVyYWN0aXZlKHRoaXMpXG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZTtcblxuICAgICAgICByZXR1cm4gKGlzT2JqZWN0KGludGVyYWN0aXZlKSAmJiBpbnRlcmFjdGl2ZVtmZWF0dXJlXSAhPT0gZmFsc2UpIHx8XG4gICAgICAgICAgICAoaXNCb29sZWFuKGludGVyYWN0aXZlKSAmJiBpbnRlcmFjdGl2ZSAhPT0gZmFsc2UpO1xuICAgIH0sXG5cbiAgICBmaW5kQnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QsIHNlbGVjdG9ycykge1xuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBlaXRoZXIgZGVzY2VuZGFudHMgb2YgYHRoaXMuJGVsYCBvZiBgdGhpcy4kZWxgIGl0c2VsZi5cbiAgICAgICAgLy8gYC5gIGlzIGEgc3BlY2lhbCBzZWxlY3RvciB1c2VkIHRvIHNlbGVjdCB0aGUgd3JhcHBpbmcgYDxnPmAgZWxlbWVudC5cbiAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJy4nKSByZXR1cm4gW3Jvb3RdO1xuICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBzZWxlY3RvcnNbc2VsZWN0b3JdO1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtub2Rlc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWludGFpbmluZyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyBlLmcuIGBjaXJjbGU6Zmlyc3RgIHdvdWxkIGZhaWwgd2l0aCBxdWVyeVNlbGVjdG9yKCkgY2FsbFxuICAgICAgICBpZiAodGhpcy51c2VDU1NTZWxlY3RvcnMpIHJldHVybiAkKHJvb3QpLmZpbmQoc2VsZWN0b3IpLnRvQXJyYXkoKTtcblxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGZpbmROb2RlczogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3IsIHRoaXMuZWwsIHRoaXMuc2VsZWN0b3JzKTtcbiAgICB9LFxuXG4gICAgZmluZE5vZGU6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IFtub2RlID0gbnVsbF0gPSB0aGlzLmZpbmROb2RlcyhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBub3RpZnk6IGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuXG4gICAgICAgIGlmICh0aGlzLnBhcGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgLy8gVHJpZ2dlciB0aGUgZXZlbnQgb24gYm90aCB0aGUgZWxlbWVudCBpdHNlbGYgYW5kIGFsc28gb24gdGhlIHBhcGVyLlxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIFtldmVudE5hbWVdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgICAgICAgIC8vIFBhcGVyIGV2ZW50IGhhbmRsZXJzIHJlY2VpdmUgdGhlIHZpZXcgb2JqZWN0IGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICAgICAgICAgIHRoaXMucGFwZXIudHJpZ2dlci5hcHBseSh0aGlzLnBhcGVyLCBbZXZlbnROYW1lLCB0aGlzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBiYm94O1xuICAgICAgICBpZiAob3B0ICYmIG9wdC51c2VNb2RlbEdlb21ldHJ5KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgYmJveCA9IG1vZGVsLmdldEJCb3goKS5iYm94KG1vZGVsLmFuZ2xlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmJveCA9IHRoaXMuZ2V0Tm9kZUJCb3godGhpcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wYXBlci5sb2NhbFRvUGFwZXJSZWN0KGJib3gpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlQkJveDogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0Tm9kZUJvdW5kaW5nUmVjdChtYWduZXQpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLmdldFJvb3RUcmFuc2xhdGVNYXRyaXgoKS5tdWx0aXBseSh0aGlzLmdldE5vZGVSb3RhdGVNYXRyaXgobWFnbmV0KSk7XG4gICAgICAgIGNvbnN0IG1hZ25ldE1hdHJpeCA9IHRoaXMuZ2V0Tm9kZU1hdHJpeChtYWduZXQpO1xuICAgICAgICByZXR1cm4gVi50cmFuc2Zvcm1SZWN0KHJlY3QsIHRyYW5zZm9ybU1hdHJpeC5tdWx0aXBseShtYWduZXRNYXRyaXgpKTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZVJvdGF0ZU1hdHJpeChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5yb3RhdGFibGVOb2RlIHx8IHRoaXMucm90YXRhYmxlTm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgLy8gUm90YXRlIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHdoZW4gbm8gcm90YXRhYmxlR3JvdXBcbiAgICAgICAgICAgIC8vIGlzIHByZXNlbnQgb3IgdG8gbm9kZXMgaW5zaWRlIHRoZSByb3RhdGFibGVHcm91cCBvbmx5LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Um9vdFJvdGF0ZU1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGVzIG91dHNpZGUgdGhlIHJvdGF0YWJsZSBncm91cFxuICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZVVucm90YXRlZEJCb3g6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5nZXROb2RlQm91bmRpbmdSZWN0KG1hZ25ldCk7XG4gICAgICAgIHZhciBtYWduZXRNYXRyaXggPSB0aGlzLmdldE5vZGVNYXRyaXgobWFnbmV0KTtcbiAgICAgICAgdmFyIHRyYW5zbGF0ZU1hdHJpeCA9IHRoaXMuZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCgpO1xuICAgICAgICByZXR1cm4gVi50cmFuc2Zvcm1SZWN0KHJlY3QsIHRyYW5zbGF0ZU1hdHJpeC5tdWx0aXBseShtYWduZXRNYXRyaXgpKTtcbiAgICB9LFxuXG4gICAgZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbW9kZWwucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG10ID0gVi5jcmVhdGVTVkdNYXRyaXgoKS50cmFuc2xhdGUocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIHJldHVybiBtdDtcbiAgICB9LFxuXG4gICAgZ2V0Um9vdFJvdGF0ZU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG1yID0gVi5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGFuZ2xlID0gbW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IG1vZGVsLmdldEJCb3goKTtcbiAgICAgICAgICAgIHZhciBjeCA9IGJib3gud2lkdGggLyAyO1xuICAgICAgICAgICAgdmFyIGN5ID0gYmJveC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgbXIgPSBtci50cmFuc2xhdGUoY3gsIGN5KS5yb3RhdGUoYW5nbGUpLnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1yO1xuICAgIH0sXG5cbiAgICBfbm90aWZ5SGlnaGxpZ2h0OiBmdW5jdGlvbihldmVudE5hbWUsIGVsLCBvcHQgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGVsOiByb290Tm9kZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5maW5kTm9kZShlbCkgfHwgcm9vdE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBbbm9kZSA9IHJvb3ROb2RlXSA9IHRoaXMuJChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHBhcnRpYWwgZmxhZyBpZiB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudCBpcyBub3QgdGhlIGVudGlyZSB2aWV3LlxuICAgICAgICBvcHQucGFydGlhbCA9IChub2RlICE9PSByb290Tm9kZSk7XG4gICAgICAgIC8vIHRyYW5zbGF0ZSB0eXBlIGZsYWcgaW50byBhIHR5cGUgc3RyaW5nXG4gICAgICAgIGlmIChvcHQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2Ugb3B0LmVtYmVkZGluZzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkVNQkVERElORztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvcHQuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkNPTk5FQ1RJTkc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugb3B0Lm1hZ25ldEF2YWlsYWJpbGl0eTpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLk1BR05FVF9BVkFJTEFCSUxJVFk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugb3B0LmVsZW1lbnRBdmFpbGFiaWxpdHk6XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBIaWdobGlnaHRpbmdUeXBlcy5FTEVNRU5UX0FWQUlMQUJJTElUWTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkRFRkFVTFQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0LnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5KGV2ZW50TmFtZSwgbm9kZSwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZWwsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm90aWZ5SGlnaGxpZ2h0KCdjZWxsOmhpZ2hsaWdodCcsIGVsLCBvcHQpO1xuICAgIH0sXG5cbiAgICB1bmhpZ2hsaWdodDogZnVuY3Rpb24oZWwsIG9wdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3RpZnlIaWdobGlnaHQoJ2NlbGw6dW5oaWdobGlnaHQnLCBlbCwgb3B0KTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBlbGVtZW50IHRoYXQgaGFzIHRoZSBgbWFnbmV0YCBhdHRyaWJ1dGUgc2V0IHRvIGB0cnVlYC4gSWYgdGhlcmUgd2FzIG5vdCBzdWNoXG4gICAgLy8gYW4gZWxlbWVudCBmb3VuZCwgcmV0dXJuIHRoZSByb290IGVsZW1lbnQgb2YgdGhlIGNlbGwgdmlldy5cbiAgICBmaW5kTWFnbmV0OiBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmVsO1xuICAgICAgICBsZXQgbWFnbmV0ID0gdGhpcy4kKGVsKVswXTtcbiAgICAgICAgaWYgKCFtYWduZXQpIHtcbiAgICAgICAgICAgIG1hZ25ldCA9IHJvb3Q7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBtYWduZXRBdHRyaWJ1dGUgPSBtYWduZXQuZ2V0QXR0cmlidXRlKCdtYWduZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzTWFnbmV0Um9vdCA9IChtYWduZXQgPT09IHJvb3QpO1xuICAgICAgICAgICAgaWYgKChtYWduZXRBdHRyaWJ1dGUgfHwgaXNNYWduZXRSb290KSAmJiBtYWduZXRBdHRyaWJ1dGUgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFnbmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTWFnbmV0Um9vdCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvdmVyYWxsIGNlbGwgaGFzIHNldCBgbWFnbmV0ID09PSBmYWxzZWAsIHRoZW4gcmV0dXJuIGB1bmRlZmluZWRgIHRvXG4gICAgICAgICAgICAgICAgLy8gYW5ub3VuY2UgdGhlcmUgaXMgbm8gbWFnbmV0IGZvdW5kIGZvciB0aGlzIGNlbGwuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB0byBzZXQgb24gY2VsbHMgdGhhdCBoYXZlICdwb3J0cycuIEluIHRoaXMgY2FzZSxcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZSBwb3J0cyBoYXZlIHNldCBgbWFnbmV0ID09PSB0cnVlYCBhbmQgdGhlIG92ZXJhbGwgZWxlbWVudCBoYXMgYG1hZ25ldCA9PT0gZmFsc2VgLlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWduZXQgPSBtYWduZXQucGFyZW50Tm9kZTtcbiAgICAgICAgfSB3aGlsZSAobWFnbmV0KTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICBmaW5kUHJveHlOb2RlOiBmdW5jdGlvbihlbCwgdHlwZSkge1xuICAgICAgICBlbCB8fCAoZWwgPSB0aGlzLmVsKTtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdG9yID0gZWwuZ2V0QXR0cmlidXRlKGAke3R5cGV9LXNlbGVjdG9yYCk7XG4gICAgICAgIGlmIChub2RlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3h5Tm9kZSA9IHRoaXMuZmluZE5vZGUobm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChwcm94eU5vZGUpIHJldHVybiBwcm94eU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvLyBDb25zdHJ1Y3QgYSB1bmlxdWUgc2VsZWN0b3IgZm9yIHRoZSBgZWxgIGVsZW1lbnQgd2l0aGluIHRoaXMgdmlldy5cbiAgICAvLyBgcHJldlNlbGVjdG9yYCBpcyBiZWluZyBjb2xsZWN0ZWQgdGhyb3VnaCB0aGUgcmVjdXJzaXZlIGNhbGwuXG4gICAgLy8gTm8gdmFsdWUgZm9yIGBwcmV2U2VsZWN0b3JgIGlzIGV4cGVjdGVkIHdoZW4gdXNpbmcgdGhpcyBtZXRob2QuXG4gICAgZ2V0U2VsZWN0b3I6IGZ1bmN0aW9uKGVsLCBwcmV2U2VsZWN0b3IpIHtcblxuICAgICAgICB2YXIgc2VsZWN0b3I7XG5cbiAgICAgICAgaWYgKGVsID09PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZXZTZWxlY3RvciA9PT0gJ3N0cmluZycpIHNlbGVjdG9yID0gJzpzY29wZSA+ICcgKyBwcmV2U2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWwpIHtcblxuICAgICAgICAgICAgdmFyIG50aENoaWxkID0gVihlbCkuaW5kZXgoKSArIDE7XG4gICAgICAgICAgICBzZWxlY3RvciA9IGVsLnRhZ05hbWUgKyAnOm50aC1jaGlsZCgnICsgbnRoQ2hpbGQgKyAnKSc7XG5cbiAgICAgICAgICAgIGlmIChwcmV2U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciArPSAnID4gJyArIHByZXZTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yKGVsLnBhcmVudE5vZGUsIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9LFxuXG4gICAgYWRkTGlua0Zyb21NYWduZXQ6IGZ1bmN0aW9uKG1hZ25ldCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBncmFwaCA9IHBhcGVyLm1vZGVsO1xuXG4gICAgICAgIHZhciBsaW5rID0gcGFwZXIuZ2V0RGVmYXVsdExpbmsodGhpcywgbWFnbmV0KTtcbiAgICAgICAgbGluay5zZXQoe1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLmdldExpbmtFbmQobWFnbmV0LCB4LCB5LCBsaW5rLCAnc291cmNlJyksXG4gICAgICAgICAgICB0YXJnZXQ6IHsgeDogeCwgeTogeSB9XG4gICAgICAgIH0pLmFkZFRvKGdyYXBoLCB7XG4gICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICB1aTogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGluay5maW5kVmlldyhwYXBlcik7XG4gICAgfSxcblxuICAgIGdldExpbmtFbmQ6IGZ1bmN0aW9uKG1hZ25ldCwgLi4uYXJncykge1xuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgaWQgPSBtb2RlbC5pZDtcbiAgICAgICAgLy8gRmluZCBhIG5vZGUgd2l0aCB0aGUgYHBvcnRgIGF0dHJpYnV0ZSBzZXQgb24gaXQuXG4gICAgICAgIGNvbnN0IHBvcnROb2RlID0gdGhpcy5maW5kQXR0cmlidXRlTm9kZSgncG9ydCcsIG1hZ25ldCk7XG4gICAgICAgIC8vIEZpbmQgYSB1bmlxdWUgYHNlbGVjdG9yYCBvZiB0aGUgZWxlbWVudCB1bmRlciBwb2ludGVyIHRoYXQgaXMgYSBtYWduZXQuXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbWFnbmV0LmdldEF0dHJpYnV0ZSgnam9pbnQtc2VsZWN0b3InKTtcblxuICAgICAgICBjb25zdCBlbmQgPSB7IGlkOiBpZCB9O1xuICAgICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkgZW5kLm1hZ25ldCA9IHNlbGVjdG9yO1xuICAgICAgICBpZiAocG9ydE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHBvcnQgPSBwb3J0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3BvcnQnKTtcbiAgICAgICAgICAgIGlmIChwb3J0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3BvcnQtaWQtdHlwZScpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChwb3J0LCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmQucG9ydCA9IHBvcnQ7XG4gICAgICAgICAgICBpZiAoIW1vZGVsLmhhc1BvcnQocG9ydCkgJiYgIXNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgLy8gcG9ydCBjcmVhdGVkIHZpYSB0aGUgYHBvcnRgIGF0dHJpYnV0ZSAobm90IEFQSSlcbiAgICAgICAgICAgICAgICBlbmQuc2VsZWN0b3IgPSB0aGlzLmdldFNlbGVjdG9yKG1hZ25ldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IgPT0gbnVsbCAmJiB0aGlzLmVsICE9PSBtYWduZXQpIHtcbiAgICAgICAgICAgIGVuZC5zZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3IobWFnbmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbWl6ZUxpbmtFbmQoZW5kLCBtYWduZXQsIC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBjdXN0b21pemVMaW5rRW5kOiBmdW5jdGlvbihlbmQsIG1hZ25ldCwgeCwgeSwgbGluaywgZW5kVHlwZSkge1xuICAgICAgICBjb25zdCB7IHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb25TdHJhdGVneSB9ID0gcGFwZXIub3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uU3RyYXRlZ3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBzdHJhdGVneSA9IGNvbm5lY3Rpb25TdHJhdGVneS5jYWxsKHBhcGVyLCBlbmQsIHRoaXMsIG1hZ25ldCwgbmV3IFBvaW50KHgsIHkpLCBsaW5rLCBlbmRUeXBlLCBwYXBlcik7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kpIHJldHVybiBzdHJhdGVneTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH0sXG5cbiAgICBnZXRNYWduZXRGcm9tTGlua0VuZDogZnVuY3Rpb24oZW5kKSB7XG5cbiAgICAgICAgdmFyIHBvcnQgPSBlbmQucG9ydDtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gZW5kLm1hZ25ldDtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG1hZ25ldDtcbiAgICAgICAgaWYgKHBvcnQgIT0gbnVsbCAmJiBtb2RlbC5pc0VsZW1lbnQoKSAmJiBtb2RlbC5oYXNQb3J0KHBvcnQpKSB7XG4gICAgICAgICAgICBtYWduZXQgPSB0aGlzLmZpbmRQb3J0Tm9kZShwb3J0LCBzZWxlY3RvcikgfHwgdGhpcy5lbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHNlbGVjdG9yID0gZW5kLnNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RvciAmJiBwb3J0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsaW5rIGVuZCBoYXMgb25seSBgaWRgIGFuZCBgcG9ydGAgcHJvcGVydHkgcmVmZXJlbmNpbmdcbiAgICAgICAgICAgICAgICAvLyBhIHBvcnQgY3JlYXRlZCB2aWEgdGhlIGBwb3J0YCBhdHRyaWJ1dGUgKG5vdCBBUEkpLlxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJ1twb3J0PVwiJyArIHBvcnQgKyAnXCJdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hZ25ldCA9IHRoaXMuZmluZE5vZGUoc2VsZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFByb3h5Tm9kZShtYWduZXQsICdtYWduZXQnKTtcbiAgICB9LFxuXG4gICAgZHJhZ0xpbmtTdGFydDogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5tb2RlbC5zdGFydEJhdGNoKCdhZGQtbGluaycpO1xuICAgICAgICBjb25zdCBsaW5rVmlldyA9IHRoaXMuYWRkTGlua0Zyb21NYWduZXQobWFnbmV0LCB4LCB5KTtcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZXZlbnRzXG4gICAgICAgIGxpbmtWaWV3Lm5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSk7XG4gICAgICAgIGxpbmtWaWV3LmV2ZW50RGF0YShldnQsIGxpbmtWaWV3LnN0YXJ0QXJyb3doZWFkTW92ZSgndGFyZ2V0JywgeyB3aGVuTm90QWxsb3dlZDogJ3JlbW92ZScgfSkpO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgbGlua1ZpZXcgfSk7XG4gICAgfSxcblxuICAgIGRyYWdMaW5rOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgbGlua1ZpZXcgPSBkYXRhLmxpbmtWaWV3O1xuICAgICAgICBpZiAobGlua1ZpZXcpIHtcbiAgICAgICAgICAgIGxpbmtWaWV3LnBvaW50ZXJtb3ZlKGV2dCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICAgICAgdmFyIG1hZ25ldFRocmVzaG9sZCA9IHBhcGVyLm9wdGlvbnMubWFnbmV0VGhyZXNob2xkO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSB0aGlzLmdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TWFnbmV0ID0gZGF0YS50YXJnZXRNYWduZXQ7XG4gICAgICAgICAgICBpZiAobWFnbmV0VGhyZXNob2xkID09PSAnb25sZWF2ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWduZXRUaHJlc2hvbGQgd2hlbiB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIG1hZ25ldFxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRNYWduZXQgPT09IGN1cnJlbnRUYXJnZXQgfHwgVih0YXJnZXRNYWduZXQpLmNvbnRhaW5zKGN1cnJlbnRUYXJnZXQpKSByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1hZ25ldFRocmVzaG9sZCBkZWZpbmVkIGFzIGEgbnVtYmVyIG9mIG1vdmVtZW50c1xuICAgICAgICAgICAgICAgIGlmIChwYXBlci5ldmVudERhdGEoZXZ0KS5tb3VzZW1vdmVkIDw9IG1hZ25ldFRocmVzaG9sZCkgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFnTGlua1N0YXJ0KGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkcmFnTGlua0VuZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdmFyIGxpbmtWaWV3ID0gZGF0YS5saW5rVmlldztcbiAgICAgICAgaWYgKCFsaW5rVmlldykgcmV0dXJuO1xuICAgICAgICBsaW5rVmlldy5wb2ludGVydXAoZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5tb2RlbC5zdG9wQmF0Y2goJ2FkZC1saW5rJyk7XG4gICAgfSxcblxuICAgIGdldEF0dHJpYnV0ZURlZmluaXRpb246IGZ1bmN0aW9uKGF0dHJOYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29uc3RydWN0b3IuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgfSxcblxuICAgIHNldE5vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbihub2RlLCBhdHRycykge1xuXG4gICAgICAgIGlmICghaXNFbXB0eShhdHRycykpIHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIFYobm9kZSkuYXR0cihhdHRycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQobm9kZSkuYXR0cihhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvY2Vzc05vZGVBdHRyaWJ1dGVzOiBmdW5jdGlvbihub2RlLCBhdHRycykge1xuXG4gICAgICAgIHZhciBhdHRyTmFtZSwgYXR0clZhbCwgZGVmLCBpLCBuO1xuICAgICAgICB2YXIgbm9ybWFsQXR0cnMsIHNldEF0dHJzLCBwb3NpdGlvbkF0dHJzLCBvZmZzZXRBdHRycztcbiAgICAgICAgdmFyIHJlbGF0aXZlcyA9IFtdO1xuICAgICAgICBjb25zdCByYXdBdHRycyA9IHt9O1xuICAgICAgICBmb3IgKGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICByYXdBdHRyc1tWLmF0dHJpYnV0ZU5hbWVzW2F0dHJOYW1lXV0gPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGl2aWRlIHRoZSBhdHRyaWJ1dGVzIGJldHdlZW4gbm9ybWFsIGFuZCBzcGVjaWFsXG4gICAgICAgIGZvciAoYXR0ck5hbWUgaW4gcmF3QXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghcmF3QXR0cnMuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGF0dHJWYWwgPSByYXdBdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICBkZWYgPSB0aGlzLmdldEF0dHJpYnV0ZURlZmluaXRpb24oYXR0ck5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyVmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgdW5zZXQgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgIGxldCB1bnNldEF0dHJOYW1lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkZWYudW5zZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNldEF0dHJOYW1lID0gZGVmLnVuc2V0LmNhbGwodGhpcywgbm9kZSwgcmF3QXR0cnMsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5zZXRBdHRyTmFtZSA9IGRlZi51bnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXVuc2V0QXR0ck5hbWUgJiYgaXNTdHJpbmcoZGVmLnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHVuc2V0IGFuIGFsaWFzIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc2V0QXR0ck5hbWUgPSBkZWYuc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdW5zZXRBdHRyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gYWxpYXMgZm9yIHRoZSBhdHRyaWJ1dGUuIFdlIHVuc2V0IHRoZSBhdHRyaWJ1dGUgaXRzZWxmLlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zZXRBdHRyTmFtZSA9IGF0dHJOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuc2V0IHRoZSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh1bnNldEF0dHJOYW1lKSAmJiB1bnNldEF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnNldCBhIHNpbmdsZSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRycyB8fCAobm9ybWFsQXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHVuc2V0IHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuc2V0QXR0ck5hbWUgaW4gbm9ybWFsQXR0cnMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsQXR0cnNbdW5zZXRBdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodW5zZXRBdHRyTmFtZSkgJiYgdW5zZXRBdHRyTmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnNldCBtdWx0aXBsZSBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsQXR0cnMgfHwgKG5vcm1hbEF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHVuc2V0QXR0ck5hbWUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB1bnNldEF0dHJOYW1lW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdW5zZXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lIGluIG5vcm1hbEF0dHJzKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1bnNldCB2YWx1ZSBpcyBuZWl0aGVyIGEgc3RyaW5nIG5vciBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJpYnV0ZSBpcyBub3QgdW5zZXQuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGRlZi5xdWFsaWZ5KSB8fCBkZWYucXVhbGlmeS5jYWxsKHRoaXMsIGF0dHJWYWwsIG5vZGUsIHJhd0F0dHJzLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRlZi5zZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQW4gYWxpYXMgZS5nICd4bGluazpocmVmJyAtPiAnaHJlZidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRycyB8fCAobm9ybWFsQXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsQXR0cnNbZGVmLnNldF0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVzLnB1c2goYXR0ck5hbWUsIGRlZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRycyB8fCAobm9ybWFsQXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWxBdHRycyB8fCAobm9ybWFsQXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgbm9ybWFsQXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSB0aGUgcmVzdCBvZiBhdHRyaWJ1dGVzIHZpYSByZWxhdGVkIG1ldGhvZFxuICAgICAgICAvLyBmcm9tIHRoZSBzcGVjaWFsIGF0dHJpYnV0ZXMgbmFtZXNwYWNlLlxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gcmVsYXRpdmVzLmxlbmd0aDsgaSA8IG47IGkrPTIpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gcmVsYXRpdmVzW2ldO1xuICAgICAgICAgICAgZGVmID0gcmVsYXRpdmVzW2krMV07XG4gICAgICAgICAgICBhdHRyVmFsID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGVmLnNldCkpIHtcbiAgICAgICAgICAgICAgICBzZXRBdHRycyB8fCAoc2V0QXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZi5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkF0dHJzIHx8IChwb3NpdGlvbkF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZi5vZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QXR0cnMgfHwgKG9mZnNldEF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgIG9mZnNldEF0dHJzW2F0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3OiByYXdBdHRycyxcbiAgICAgICAgICAgIG5vcm1hbDogbm9ybWFsQXR0cnMsXG4gICAgICAgICAgICBzZXQ6IHNldEF0dHJzLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uQXR0cnMsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldEF0dHJzXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlbGF0aXZlQXR0cmlidXRlczogZnVuY3Rpb24obm9kZSwgYXR0cnMsIHJlZkJCb3gsIG9wdCkge1xuXG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuXG4gICAgICAgIHZhciBhdHRyTmFtZSwgYXR0clZhbCwgZGVmO1xuICAgICAgICB2YXIgZXZhbEF0dHJzID0gZXZhbEF0dHJpYnV0ZXMoYXR0cnMucmF3IHx8IHt9LCByZWZCQm94KTtcbiAgICAgICAgdmFyIG5vZGVBdHRycyA9IGF0dHJzLm5vcm1hbCB8fCB7fTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlQXR0ck5hbWUgaW4gbm9kZUF0dHJzKSB7XG4gICAgICAgICAgICBub2RlQXR0cnNbbm9kZUF0dHJOYW1lXSA9IGV2YWxBdHRyc1tub2RlQXR0ck5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXRBdHRycyA9IGF0dHJzLnNldDtcbiAgICAgICAgdmFyIHBvc2l0aW9uQXR0cnMgPSBhdHRycy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIG9mZnNldEF0dHJzID0gYXR0cnMub2Zmc2V0O1xuXG4gICAgICAgIGZvciAoYXR0ck5hbWUgaW4gc2V0QXR0cnMpIHtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBldmFsQXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgZGVmID0gdGhpcy5nZXRBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIC8vIFNFVCAtIHNldCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IG9uIHRoZSBub2RlLFxuICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBhZmZlY3QgdGhlIG5vZGUgZGltZW5zaW9ucyBiYXNlZCBvbiB0aGUgcmVmZXJlbmNlIGJvdW5kaW5nXG4gICAgICAgICAgICAvLyBib3guIGUuZy4gYHdpZHRoYCwgYGhlaWdodGAsIGBkYCwgYHJ4YCwgYHJ5YCwgYHBvaW50c1xuICAgICAgICAgICAgdmFyIHNldFJlc3VsdCA9IGRlZi5zZXQuY2FsbCh0aGlzLCBhdHRyVmFsLCByZWZCQm94LmNsb25lKCksIG5vZGUsIGV2YWxBdHRycywgdGhpcyk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc2V0UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGFzc2lnbihub2RlQXR0cnMsIHNldFJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZUF0dHJzW2F0dHJOYW1lXSA9IHNldFJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHNldHRpbmcgdGhlIGB0cmFuc2Zvcm1gIGF0dHJpYnV0ZSBvbiBIVE1MRWxlbWVudHNcbiAgICAgICAgICAgIC8vIHZpYSBgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSAnbWF0cml4KC4uLiknO2Agd291bGQgaW50cm9kdWNlXG4gICAgICAgICAgICAvLyBhIGJyZWFraW5nIGNoYW5nZSAoZS5nLiBiYXNpYy5UZXh0QmxvY2spLlxuICAgICAgICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlcyhub2RlLCBub2RlQXR0cnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZpbmFsIHRyYW5zbGF0aW9uIG9mIHRoZSBzdWJlbGVtZW50LlxuICAgICAgICB2YXIgbm9kZVRyYW5zZm9ybSA9IG5vZGVBdHRycy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBub2RlTWF0cml4ID0gVi50cmFuc2Zvcm1TdHJpbmdUb01hdHJpeChub2RlVHJhbnNmb3JtKTtcbiAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IFBvaW50KG5vZGVNYXRyaXguZSwgbm9kZU1hdHJpeC5mKTtcbiAgICAgICAgaWYgKG5vZGVUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIG5vZGVBdHRycyA9IG9taXQobm9kZUF0dHJzLCAndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICBub2RlTWF0cml4LmUgPSBub2RlTWF0cml4LmYgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5vZGUgc2NhbGUgZGV0ZXJtaW5lZCBieSB0aGUgc2NhbGFibGUgZ3JvdXBcbiAgICAgICAgLy8gb25seSBpZiBsYXRlciBuZWVkZWQuXG4gICAgICAgIHZhciBzeCwgc3ksIHRyYW5zbGF0aW9uO1xuICAgICAgICBpZiAocG9zaXRpb25BdHRycyB8fCBvZmZzZXRBdHRycykge1xuICAgICAgICAgICAgdmFyIG5vZGVTY2FsZSA9IHRoaXMuZ2V0Tm9kZVNjYWxlKG5vZGUsIG9wdC5zY2FsYWJsZU5vZGUpO1xuICAgICAgICAgICAgc3ggPSBub2RlU2NhbGUuc3g7XG4gICAgICAgICAgICBzeSA9IG5vZGVTY2FsZS5zeTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoYXR0ck5hbWUgaW4gcG9zaXRpb25BdHRycykge1xuICAgICAgICAgICAgYXR0clZhbCA9IGV2YWxBdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICBkZWYgPSB0aGlzLmdldEF0dHJpYnV0ZURlZmluaXRpb24oYXR0ck5hbWUpO1xuICAgICAgICAgICAgLy8gUE9TSVRJT04gLSBwb3NpdGlvbiBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgcG9pbnQgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBib3VuZGluZyBib3guIFRoZSBkZWZhdWx0IHBvc2l0aW9uIG9mIHRoZSBub2RlIGlzIHg6MCwgeTowIG9mXG4gICAgICAgICAgICAvLyB0aGUgcmVmZXJlbmNlIGJvdW5kaW5nIGJveCBvciBjb3VsZCBiZSBmdXJ0aGVyIHNwZWNpZnkgYnkgc29tZVxuICAgICAgICAgICAgLy8gU1ZHIGF0dHJpYnV0ZXMgZS5nLiBgeGAsIGB5YFxuICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBkZWYucG9zaXRpb24uY2FsbCh0aGlzLCBhdHRyVmFsLCByZWZCQm94LmNsb25lKCksIG5vZGUsIGV2YWxBdHRycywgdGhpcyk7XG4gICAgICAgICAgICBpZiAodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICBub2RlUG9zaXRpb24ub2Zmc2V0KFBvaW50KHRyYW5zbGF0aW9uKS5zY2FsZShzeCwgc3kpKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbmVkIHx8IChwb3NpdGlvbmVkID0gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbm9kZSBib3VuZGluZyBib3ggY291bGQgZGVwZW5kIG9uIHRoZSBgc2l6ZWAgc2V0IGZyb20gdGhlIHByZXZpb3VzIGxvb3AuXG4gICAgICAgIC8vIEhlcmUgd2Uga25vdywgdGhhdCBhbGwgdGhlIHNpemUgYXR0cmlidXRlcyBoYXZlIGJlZW4gYWxyZWFkeSBzZXQuXG4gICAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZXMobm9kZSwgbm9kZUF0dHJzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9mZnNldEF0dHJzKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBpcyB2aXNpYmxlXG4gICAgICAgICAgICB2YXIgbm9kZUJvdW5kaW5nUmVjdCA9IHRoaXMuZ2V0Tm9kZUJvdW5kaW5nUmVjdChub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlQm91bmRpbmdSZWN0LndpZHRoID4gMCAmJiBub2RlQm91bmRpbmdSZWN0LmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUJCb3ggPSBWLnRyYW5zZm9ybVJlY3Qobm9kZUJvdW5kaW5nUmVjdCwgbm9kZU1hdHJpeCkuc2NhbGUoMSAvIHN4LCAxIC8gc3kpO1xuICAgICAgICAgICAgICAgIGZvciAoYXR0ck5hbWUgaW4gb2Zmc2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0clZhbCA9IGV2YWxBdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IHRoaXMuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9GRlNFVCAtIG9mZnNldCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgcG9pbnQgZnJvbSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBib3VuZGluZyBib3guIFRoZSBkZWZhdWx0IG9mZnNldCBwb2ludCBpcyB4OjAsIHk6MCAob3JpZ2luKSBvciBjb3VsZCBiZSBmdXJ0aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZnkgd2l0aCBzb21lIFNWRyBhdHRyaWJ1dGVzIGUuZy4gYHRleHQtYW5jaG9yYCwgYGN4YCwgYGN5YFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IGRlZi5vZmZzZXQuY2FsbCh0aGlzLCBhdHRyVmFsLCBub2RlQkJveCwgbm9kZSwgZXZhbEF0dHJzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlUG9zaXRpb24ub2Zmc2V0KFBvaW50KHRyYW5zbGF0aW9uKS5zY2FsZShzeCwgc3kpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldGVkIHx8IChvZmZzZXRlZCA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG8gbm90IHRvdWNoIG5vZGUncyB0cmFuc2Zvcm0gYXR0cmlidXRlIGlmIHRoZXJlIGlzIG5vIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAgICAgIGlmIChub2RlVHJhbnNmb3JtICE9PSB1bmRlZmluZWQgfHwgcG9zaXRpb25lZCB8fCBvZmZzZXRlZCkge1xuICAgICAgICAgICAgLy8gUm91bmQgdGhlIGNvb3JkaW5hdGVzIHRvIDEgZGVjaW1hbCBwb2ludC5cbiAgICAgICAgICAgIG5vZGVQb3NpdGlvbi5yb3VuZCgxKTtcbiAgICAgICAgICAgIG5vZGVNYXRyaXguZSA9IG5vZGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgbm9kZU1hdHJpeC5mID0gbm9kZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyhub2RlTWF0cml4KSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBzdG9yZSBub2RlTWF0cml4IG1ldHJpY3M/XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Tm9kZVNjYWxlOiBmdW5jdGlvbihub2RlLCBzY2FsYWJsZU5vZGUpIHtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIHNjYWxhYmxlIGdyb3VwLlxuICAgICAgICB2YXIgc3gsIHN5O1xuICAgICAgICBpZiAoc2NhbGFibGVOb2RlICYmIHNjYWxhYmxlTm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gc2NhbGFibGVOb2RlLnNjYWxlKCk7XG4gICAgICAgICAgICBzeCA9IDEgLyBzY2FsZS5zeDtcbiAgICAgICAgICAgIHN5ID0gMSAvIHNjYWxlLnN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ggPSAxO1xuICAgICAgICAgICAgc3kgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3g6IHN4LCBzeTogc3kgfTtcbiAgICB9LFxuXG4gICAgY2xlYW5Ob2Rlc0NhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5tZXRyaWNzID0ge307XG4gICAgfSxcblxuICAgIGNsZWFuTm9kZUNhY2hlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGNvbnN0IGlkID0gbm9kZS5pZDtcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuO1xuICAgICAgICBkZWxldGUgdGhpcy5tZXRyaWNzW2lkXTtcbiAgICB9LFxuXG4gICAgbm9kZUNhY2hlOiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgLy8gRG9uJ3QgdXNlIGNhY2hlPyBJdCBtb3N0IGxpa2VseSBhIGN1c3RvbSB2aWV3IHdpdGggb3ZlcnJpZGRlbiB1cGRhdGUuXG4gICAgICAgIGlmICghbWV0cmljcykgcmV0dXJuIHt9O1xuICAgICAgICB2YXIgaWQgPSBWLmVuc3VyZUlkKG1hZ25ldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1ldHJpY3NbaWRdO1xuICAgICAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IG1ldHJpY3NbaWRdID0ge307XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZURhdGE6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5ub2RlQ2FjaGUobWFnbmV0KTtcbiAgICAgICAgaWYgKCFtZXRyaWNzLmRhdGEpIG1ldHJpY3MuZGF0YSA9IHt9O1xuICAgICAgICByZXR1cm4gbWV0cmljcy5kYXRhO1xuICAgIH0sXG5cbiAgICBnZXROb2RlQm91bmRpbmdSZWN0OiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubm9kZUNhY2hlKG1hZ25ldCk7XG4gICAgICAgIGlmIChtZXRyaWNzLmJvdW5kaW5nUmVjdCA9PT0gdW5kZWZpbmVkKSBtZXRyaWNzLmJvdW5kaW5nUmVjdCA9IFYobWFnbmV0KS5nZXRCQm94KCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdChtZXRyaWNzLmJvdW5kaW5nUmVjdCk7XG4gICAgfSxcblxuICAgIGdldE5vZGVNYXRyaXg6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLm5vZGVDYWNoZShtYWduZXQpO1xuICAgICAgICBpZiAobWV0cmljcy5tYWduZXRNYXRyaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyByb3RhdGFibGVOb2RlLCBlbCB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgICAgICBpZiAocm90YXRhYmxlTm9kZSAmJiByb3RhdGFibGVOb2RlLmNvbnRhaW5zKG1hZ25ldCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSByb3RhdGFibGVOb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldHJpY3MubWFnbmV0TWF0cml4ID0gVihtYWduZXQpLmdldFRyYW5zZm9ybVRvRWxlbWVudCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeChtZXRyaWNzLm1hZ25ldE1hdHJpeCk7XG4gICAgfSxcblxuICAgIGdldE5vZGVTaGFwZTogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLm5vZGVDYWNoZShtYWduZXQpO1xuICAgICAgICBpZiAobWV0cmljcy5nZW9tZXRyeVNoYXBlID09PSB1bmRlZmluZWQpIG1ldHJpY3MuZ2VvbWV0cnlTaGFwZSA9IFYobWFnbmV0KS50b0dlb21ldHJ5U2hhcGUoKTtcbiAgICAgICAgcmV0dXJuIG1ldHJpY3MuZ2VvbWV0cnlTaGFwZS5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICBpc05vZGVDb25uZWN0aW9uOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmlzTGluaygpICYmICghbm9kZSB8fCBub2RlID09PSB0aGlzLmVsKTtcbiAgICB9LFxuXG4gICAgZmluZE5vZGVzQXR0cmlidXRlczogZnVuY3Rpb24oYXR0cnMsIHJvb3QsIHNlbGVjdG9yQ2FjaGUsIHNlbGVjdG9ycykge1xuXG4gICAgICAgIHZhciBpLCBuLCBub2RlQXR0cnMsIG5vZGVJZDtcbiAgICAgICAgdmFyIG5vZGVzQXR0cnMgPSB7fTtcbiAgICAgICAgdmFyIG1lcmdlSWRzID0gW107XG4gICAgICAgIGZvciAodmFyIHNlbGVjdG9yIGluIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KHNlbGVjdG9yKSkgY29udGludWU7XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBhdHRyc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3Qobm9kZUF0dHJzKSkgY29udGludWU7IC8vIE5vdCBhIHZhbGlkIHNlbGVjdG9yLWF0dHJpYnV0ZXMgcGFpclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0b3JDYWNoZVtzZWxlY3Rvcl0gPSB0aGlzLmZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCByb290LCBzZWxlY3RvcnMpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IHNlbGVjdGVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZWN0ZWRbaV07XG4gICAgICAgICAgICAgICAgbm9kZUlkID0gVi5lbnN1cmVJZChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBcInVuaXF1ZVwiIHNlbGVjdG9ycyBhcmUgc2VsZWN0b3JzIHRoYXQgcmVmZXJlbmNpbmcgYSBzaW5nbGUgbm9kZSAoZGVmaW5lZCBieSBgc2VsZWN0b3JgKVxuICAgICAgICAgICAgICAgIC8vIGdyb3VwU2VsZWN0b3IgcmVmZXJlbmNpbmcgYSBzaW5nbGUgbm9kZSBpcyBub3QgXCJ1bmlxdWVcIlxuICAgICAgICAgICAgICAgIHZhciB1bmlxdWUgPSAoc2VsZWN0b3JzICYmIHNlbGVjdG9yc1tzZWxlY3Rvcl0gPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Tm9kZUF0dHJzID0gbm9kZXNBdHRyc1tub2RlSWRdO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2Tm9kZUF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUsIHRoYXQgbm9kZXMgcmVmZXJlbmNlZCBieSBkZXByZWNhdGVkIGBDU1Mgc2VsZWN0b3JzYCBhcmUgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBjc3M6YC5jaXJjbGVgIGFuZCBzZWxlY3RvcjpgY2lyY2xlYCBjYW4gYmUgYXBwbGllZCBpbiBhIHJhbmRvbSBvcmRlclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZOb2RlQXR0cnMuYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZOb2RlQXR0cnMuYXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGVBdHRycy5hdHRyaWJ1dGVzID0gW3ByZXZOb2RlQXR0cnMuYXR0cmlidXRlc107XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZUF0dHJzLnNlbGVjdGVkTGVuZ3RoID0gW3ByZXZOb2RlQXR0cnMuc2VsZWN0ZWRMZW5ndGhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcHJldk5vZGVBdHRycy5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBwcmV2Tm9kZUF0dHJzLnNlbGVjdGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlIHJlZmVyZW5jZWQgYnkgYHNlbGVjdG9yYFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy51bnNoaWZ0KG5vZGVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZExlbmd0aC51bnNoaWZ0KC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgcmVmZXJlbmNlZCBieSBgZ3JvdXBTZWxlY3RvcmBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0SW5kZXggPSBzb3J0ZWRJbmRleChzZWxlY3RlZExlbmd0aCwgbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnNwbGljZShzb3J0SW5kZXgsIDAsIG5vZGVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZExlbmd0aC5zcGxpY2Uoc29ydEluZGV4LCAwLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzQXR0cnNbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IG5vZGVBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTGVuZ3RoOiB1bmlxdWUgPyAtMSA6IG4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbiA9IG1lcmdlSWRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbm9kZUlkID0gbWVyZ2VJZHNbaV07XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBub2Rlc0F0dHJzW25vZGVJZF07XG4gICAgICAgICAgICBub2RlQXR0cnMuYXR0cmlidXRlcyA9IG1lcmdlKHt9LCAuLi5ub2RlQXR0cnMuYXR0cmlidXRlcy5yZXZlcnNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGVzQXR0cnM7XG4gICAgfSxcblxuICAgIGdldEV2ZW50VGFyZ2V0OiBmdW5jdGlvbihldnQsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0LCB0eXBlLCBjbGllbnRYID0gMCwgY2xpZW50WSA9IDAgfSA9IGV2dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gRXhwbGljaXRseSBkZWZpbmVkIGBmcm9tUG9pbnRgIG9wdGlvblxuICAgICAgICAgICAgb3B0LmZyb21Qb2ludCB8fFxuICAgICAgICAgICAgLy8gVG91Y2htb3ZlL1RvdWNoZW5kIGV2ZW50J3MgdGFyZ2V0IGlzIG5vdCByZWZsZWN0aW5nIHRoZSBlbGVtZW50IHVuZGVyIHRoZSBjb29yZGluYXRlcyBhcyBtb3VzZW1vdmUgZG9lcy5cbiAgICAgICAgICAgIC8vIEl0IGhvbGRzIHRoZSBlbGVtZW50IHdoZW4gYSB0b3VjaHN0YXJ0IHRyaWdnZXJlZC5cbiAgICAgICAgICAgIHR5cGUgPT09ICd0b3VjaG1vdmUnIHx8IHR5cGUgPT09ICd0b3VjaGVuZCcgfHxcbiAgICAgICAgICAgIC8vIFBvaW50ZXJtb3ZlL1BvaW50ZXJ1cCBldmVudCB3aXRoIHRoZSBwb2ludGVyIGNhcHR1cmVkXG4gICAgICAgICAgICAoJ3BvaW50ZXJJZCcgaW4gZXZ0ICYmIHRhcmdldC5oYXNQb2ludGVyQ2FwdHVyZShldnQucG9pbnRlcklkKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgaXMgdG8gcHJvY2VzcyB0aGUgYG1vZGVsLmF0dHJpYnV0ZXMuYXR0cnNgIG9iamVjdCBhbmQgc2V0IGF0dHJpYnV0ZXMgb24gc3ViZWxlbWVudHMgYmFzZWQgb24gdGhlIHNlbGVjdG9ycyxcbiAgICAvLyB1bmxlc3MgYGF0dHJzYCBwYXJhbWV0ZXIgd2FzIHBhc3NlZC5cbiAgICB1cGRhdGVET01TdWJ0cmVlQXR0cmlidXRlczogZnVuY3Rpb24ocm9vdE5vZGUsIGF0dHJzLCBvcHQpIHtcblxuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgb3B0LnJvb3RCQm94IHx8IChvcHQucm9vdEJCb3ggPSBSZWN0KCkpO1xuICAgICAgICBvcHQuc2VsZWN0b3JzIHx8IChvcHQuc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvcnMpOyAvLyBzZWxlY3RvciBjb2xsZWN0aW9uIHRvIHVzZVxuXG4gICAgICAgIC8vIENhY2hlIHRhYmxlIGZvciBxdWVyeSByZXN1bHRzIGFuZCBib3VuZGluZyBib3ggY2FsY3VsYXRpb24uXG4gICAgICAgIC8vIE5vdGUgdGhhdCBgc2VsZWN0b3JDYWNoZWAgbmVlZHMgdG8gYmUgaW52YWxpZGF0ZWQgZm9yIGFsbFxuICAgICAgICAvLyBgdXBkYXRlQXR0cmlidXRlc2AgY2FsbHMsIGFzIHRoZSBzZWxlY3RvcnMgbWlnaHQgcG9pbnRpbmdcbiAgICAgICAgLy8gdG8gbm9kZXMgZGVzaWduYXRlZCBieSBhbiBhdHRyaWJ1dGUgb3IgZWxlbWVudHMgZHluYW1pY2FsbHlcbiAgICAgICAgLy8gY3JlYXRlZC5cbiAgICAgICAgdmFyIHNlbGVjdG9yQ2FjaGUgPSB7fTtcbiAgICAgICAgdmFyIGJib3hDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgcmVsYXRpdmVJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgcmVsYXRpdmVSZWZJdGVtcyA9IFtdO1xuICAgICAgICB2YXIgaXRlbSwgbm9kZSwgbm9kZUF0dHJzLCBub2RlRGF0YSwgcHJvY2Vzc2VkQXR0cnM7XG5cbiAgICAgICAgdmFyIHJvQXR0cnMgPSBvcHQucm9BdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgbm9kZXNBdHRycyA9IHRoaXMuZmluZE5vZGVzQXR0cmlidXRlcyhyb0F0dHJzIHx8IGF0dHJzLCByb290Tm9kZSwgc2VsZWN0b3JDYWNoZSwgb3B0LnNlbGVjdG9ycyk7XG4gICAgICAgIC8vIGBub2Rlc0F0dHJzYCBhcmUgZGlmZmVyZW50IGZyb20gYWxsIGF0dHJpYnV0ZXMsIHdoZW5cbiAgICAgICAgLy8gcmVuZGVyaW5nIG9ubHkgIGF0dHJpYnV0ZXMgc2VudCB0byB0aGlzIG1ldGhvZC5cbiAgICAgICAgdmFyIG5vZGVzQWxsQXR0cnMgPSAocm9BdHRycylcbiAgICAgICAgICAgID8gdGhpcy5maW5kTm9kZXNBdHRyaWJ1dGVzKGF0dHJzLCByb290Tm9kZSwgc2VsZWN0b3JDYWNoZSwgb3B0LnNlbGVjdG9ycylcbiAgICAgICAgICAgIDogbm9kZXNBdHRycztcblxuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXNBdHRycykge1xuICAgICAgICAgICAgbm9kZURhdGEgPSBub2Rlc0F0dHJzW25vZGVJZF07XG4gICAgICAgICAgICBub2RlQXR0cnMgPSBub2RlRGF0YS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVEYXRhLm5vZGU7XG4gICAgICAgICAgICBwcm9jZXNzZWRBdHRycyA9IHRoaXMucHJvY2Vzc05vZGVBdHRyaWJ1dGVzKG5vZGUsIG5vZGVBdHRycyk7XG5cbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkQXR0cnMuc2V0ICYmICFwcm9jZXNzZWRBdHRycy5wb3NpdGlvbiAmJiAhcHJvY2Vzc2VkQXR0cnMub2Zmc2V0ICYmICFwcm9jZXNzZWRBdHRycy5yYXcucmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGFsbCB0aGUgbm9ybWFsIGF0dHJpYnV0ZXMgcmlnaHQgb24gdGhlIFNWRy9IVE1MIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlcyhub2RlLCBldmFsQXR0cmlidXRlcyhwcm9jZXNzZWRBdHRycy5ub3JtYWwsIG9wdC5yb290QkJveCkpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVBbGxBdHRycyA9IG5vZGVzQWxsQXR0cnNbbm9kZUlkXSAmJiBub2Rlc0FsbEF0dHJzW25vZGVJZF0uYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICB2YXIgcmVmU2VsZWN0b3IgPSAobm9kZUFsbEF0dHJzICYmIChub2RlQXR0cnMucmVmID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgICAgICAgICA/IG5vZGVBbGxBdHRycy5yZWZcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlQXR0cnMucmVmO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlZk5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKHJlZlNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZk5vZGUgPSAoc2VsZWN0b3JDYWNoZVtyZWZTZWxlY3Rvcl0gfHwgdGhpcy5maW5kQnlTZWxlY3RvcihyZWZTZWxlY3Rvciwgcm9vdE5vZGUsIG9wdC5zZWxlY3RvcnMpKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5DZWxsVmlldzogXCInICsgcmVmU2VsZWN0b3IgKyAnXCIgcmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmTm9kZTogcmVmTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkQXR0cmlidXRlczogcHJvY2Vzc2VkQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIGFsbEF0dHJpYnV0ZXM6IG5vZGVBbGxBdHRyc1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbiBlbGVtZW50IGluIHRoZSBsaXN0IGlzIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhpcyBvbmUsIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBpbnNlcnQgdGhpcyBvbmUgYmVmb3JlIGl0IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbUluZGV4ID0gcmVsYXRpdmVSZWZJdGVtcy5maW5kSW5kZXgoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ucmVmTm9kZSA9PT0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVJlZkl0ZW1zLnNwbGljZShpdGVtSW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVSZWZJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBub2RlIHdpdGggbm8gcmVmIGF0dHJpYnV0ZS4gVG8gYmUgdXBkYXRlZCBiZWZvcmUgdGhlIG5vZGVzIHJlZmVyZW5jaW5nIG90aGVyIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2Ygbm8tcmVmLWl0ZW1zIGlzIG5vdCBzcGVjaWZpZWQvaW1wb3J0YW50LlxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVsYXRpdmVJdGVtcy5wdXNoKC4uLnJlbGF0aXZlUmVmSXRlbXMpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVsYXRpdmVJdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW0gPSByZWxhdGl2ZUl0ZW1zW2ldO1xuICAgICAgICAgICAgbm9kZSA9IGl0ZW0ubm9kZTtcbiAgICAgICAgICAgIHJlZk5vZGUgPSBpdGVtLnJlZk5vZGU7XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGJvdW5kaW5nIGJveC4gSWYgbm8gcmVmZXJlbmNlIHdhcyBwcm92aWRlZCwgd2VcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgb3B0aW9uYWwgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgY29uc3QgcmVmTm9kZUlkID0gcmVmTm9kZSA/IFYuZW5zdXJlSWQocmVmTm9kZSkgOiAnJztcbiAgICAgICAgICAgIGxldCByZWZCQm94ID0gYmJveENhY2hlW3JlZk5vZGVJZF07XG4gICAgICAgICAgICBpZiAoIXJlZkJCb3gpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNpbmcgdG8gdGhlIGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uIHNwYWNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQGV4YW1wbGUgMVxuICAgICAgICAgICAgICAgIC8vIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMSwgMTMpXCI+XG4gICAgICAgICAgICAgICAgLy8gICAgIDxyZWN0IEBzZWxlY3Rvcj1cImJcIiB4PVwiMVwiIHk9XCIyXCIgd2lkdGg9XCIzXCIgaGVpZ2h0PVwiNFwiLz5cbiAgICAgICAgICAgICAgICAvLyAgICAgPHJlY3QgQHNlbGVjdG9yPVwiYVwiLz5cbiAgICAgICAgICAgICAgICAvLyA8L2c+XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZWZlcmVuY2UgYm91bmRpbmcgYm94IGNhbiBub3QgYmUgYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBieSB0aGUgYHRyYW5zZm9ybWAgYXR0cmlidXRlIG9mIHRoZSBgPGc+YCBlbGVtZW50LFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGV4YWN0IHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgYGFgIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBhcyB3ZWxsIGFzIHRvIHRoZSBgYmAgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEBleGFtcGxlIDJcbiAgICAgICAgICAgICAgICAvLyA8ZyB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTEsIDEzKVwiPlxuICAgICAgICAgICAgICAgIC8vICAgICA8cmVjdCBAc2VsZWN0b3I9XCJiXCIgeD1cIjFcIiB5PVwiMlwiIHdpZHRoPVwiM1wiIGhlaWdodD1cIjRcIi8+XG4gICAgICAgICAgICAgICAgLy8gPC9nPlxuICAgICAgICAgICAgICAgIC8vIDxyZWN0IEBzZWxlY3Rvcj1cImFcIi8+XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZWZlcmVuY2UgYm91bmRpbmcgYm94IGhhdmUgdG8gYmUgYWZmZWN0ZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gYHRyYW5zZm9ybWAgYXR0cmlidXRlIG9mIHRoZSBgPGc+YCBlbGVtZW50LCBiZWNhdXNlIHRoZSBgYWAgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBkZXNjZW5kYW50IG9mIHRoZSBgPGc+YCBlbGVtZW50IGFuZCB3aWxsIG5vdCBiZSBhZmZlY3RlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAgICAgICByZWZCQm94ID0gYmJveENhY2hlW3JlZk5vZGVJZF0gPSAocmVmTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgPyBWKHJlZk5vZGUpLmdldEJCb3goeyB0YXJnZXQ6IGdldENvbW1vbkFuY2VzdG9yTm9kZShub2RlLCByZWZOb2RlKSB9KVxuICAgICAgICAgICAgICAgICAgICA6IG9wdC5yb290QkJveDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJvQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBzcGVjaWFsIGF0dHJpYnV0ZSBhZmZlY3RpbmcgdGhlIHBvc2l0aW9uIGFtb25nc3QgcGFzc2VkLWluIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIG1lcmdlIGl0IHdpdGggdGhlIHJlc3Qgb2YgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVzIGFzIHRoZXkgYXJlIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIC8vIHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24gcmVsYXRpdmVseSAoaS5lIGByZWYteGAgJiYgJ3JlZi1keCcpXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkQXR0cnMgPSB0aGlzLnByb2Nlc3NOb2RlQXR0cmlidXRlcyhub2RlLCBpdGVtLmFsbEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VQcm9jZXNzZWRBdHRyaWJ1dGVzKHByb2Nlc3NlZEF0dHJzLCBpdGVtLnByb2Nlc3NlZEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZEF0dHJzID0gaXRlbS5wcm9jZXNzZWRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlbGF0aXZlQXR0cmlidXRlcyhub2RlLCBwcm9jZXNzZWRBdHRycywgcmVmQkJveCwgb3B0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXJnZVByb2Nlc3NlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHByb2Nlc3NlZEF0dHJzLCByb1Byb2Nlc3NlZEF0dHJzKSB7XG5cbiAgICAgICAgcHJvY2Vzc2VkQXR0cnMuc2V0IHx8IChwcm9jZXNzZWRBdHRycy5zZXQgPSB7fSk7XG4gICAgICAgIHByb2Nlc3NlZEF0dHJzLnBvc2l0aW9uIHx8IChwcm9jZXNzZWRBdHRycy5wb3NpdGlvbiA9IHt9KTtcbiAgICAgICAgcHJvY2Vzc2VkQXR0cnMub2Zmc2V0IHx8IChwcm9jZXNzZWRBdHRycy5vZmZzZXQgPSB7fSk7XG5cbiAgICAgICAgYXNzaWduKHByb2Nlc3NlZEF0dHJzLnNldCwgcm9Qcm9jZXNzZWRBdHRycy5zZXQpO1xuICAgICAgICBhc3NpZ24ocHJvY2Vzc2VkQXR0cnMucG9zaXRpb24sIHJvUHJvY2Vzc2VkQXR0cnMucG9zaXRpb24pO1xuICAgICAgICBhc3NpZ24ocHJvY2Vzc2VkQXR0cnMub2Zmc2V0LCByb1Byb2Nlc3NlZEF0dHJzLm9mZnNldCk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGFsc28gdGhlIHNwZWNpYWwgdHJhbnNmb3JtIHByb3BlcnR5LlxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gcHJvY2Vzc2VkQXR0cnMubm9ybWFsICYmIHByb2Nlc3NlZEF0dHJzLm5vcm1hbC50cmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCAmJiByb1Byb2Nlc3NlZEF0dHJzLm5vcm1hbCkge1xuICAgICAgICAgICAgcm9Qcm9jZXNzZWRBdHRycy5ub3JtYWwudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NlZEF0dHJzLm5vcm1hbCA9IHJvUHJvY2Vzc2VkQXR0cnMubm9ybWFsO1xuICAgIH0sXG5cbiAgICAvLyBMaWZlY3ljbGUgbWV0aG9kc1xuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSxcbiAgICAvLyBhcyByZXN1bHQgb2YgYGNlbGwuYWRkVG8oZ3JhcGgpYCBiZWluZyBjYWxsZWQgKGlzSW5pdGlhbE1vdW50ID09PSB0cnVlKVxuICAgIC8vIG9yIGBwYXBlci5vcHRpb25zLnZpZXdwb3J0YCByZXR1cm5pbmcgYHRydWVgIChpc0luaXRpYWxNb3VudCA9PT0gZmFsc2UpLlxuICAgIG9uTW91bnQoaXNJbml0aWFsTW91bnQpIHtcbiAgICAgICAgaWYgKGlzSW5pdGlhbE1vdW50KSByZXR1cm47XG4gICAgICAgIHRoaXMubW91bnRUb29scygpO1xuICAgICAgICBIaWdobGlnaHRlclZpZXcubW91bnQodGhpcyk7XG4gICAgfSxcblxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSB2aWV3IGlzIGRldGFjaGVkIGZyb20gdGhlIERPTSxcbiAgICAvLyBhcyByZXN1bHQgb2YgYHBhcGVyLm9wdGlvbnMudmlld3BvcnRgIHJldHVybmluZyBgZmFsc2VgLlxuICAgIG9uRGV0YWNoKCkge1xuICAgICAgICB0aGlzLnVubW91bnRUb29scygpO1xuICAgICAgICBIaWdobGlnaHRlclZpZXcudW5tb3VudCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAvLyBhcyByZXN1bHQgb2YgYGNlbGwucmVtb3ZlKClgLlxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUb29scygpO1xuICAgICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodGVycygpO1xuICAgIH0sXG5cbiAgICBfdG9vbHNWaWV3OiBudWxsLFxuXG4gICAgaGFzVG9vbHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIHRvb2xzVmlldyA9IHRoaXMuX3Rvb2xzVmlldztcbiAgICAgICAgaWYgKCF0b29sc1ZpZXcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0b29sc1ZpZXcuZ2V0TmFtZSgpID09PSBuYW1lKTtcbiAgICB9LFxuXG4gICAgYWRkVG9vbHM6IGZ1bmN0aW9uKHRvb2xzVmlldykge1xuXG4gICAgICAgIHRoaXMucmVtb3ZlVG9vbHMoKTtcblxuICAgICAgICBpZiAodG9vbHNWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl90b29sc1ZpZXcgPSB0b29sc1ZpZXc7XG4gICAgICAgICAgICB0b29sc1ZpZXcuY29uZmlndXJlKHsgcmVsYXRlZFZpZXc6IHRoaXMgfSk7XG4gICAgICAgICAgICB0b29sc1ZpZXcubGlzdGVuVG8odGhpcy5wYXBlciwgJ3Rvb2xzOmV2ZW50JywgdGhpcy5vblRvb2xFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5tb3VudFRvb2xzKCkge1xuICAgICAgICBjb25zdCB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIGlmICh0b29sc1ZpZXcpIHRvb2xzVmlldy51bm1vdW50KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtb3VudFRvb2xzKCkge1xuICAgICAgICBjb25zdCB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIC8vIFByZXZlbnQgdW5uZWNlc3NhcnkgcmUtYXBwZW5kaW5nIG9mIHRoZSB0b29scy5cbiAgICAgICAgaWYgKHRvb2xzVmlldyAmJiAhdG9vbHNWaWV3LmlzTW91bnRlZCgpKSB0b29sc1ZpZXcubW91bnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVwZGF0ZVRvb2xzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB0b29sc1ZpZXcudXBkYXRlKG9wdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVUb29sczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRvb2xzVmlldyA9IHRoaXMuX3Rvb2xzVmlldztcbiAgICAgICAgaWYgKHRvb2xzVmlldykge1xuICAgICAgICAgICAgdG9vbHNWaWV3LnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHNWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlkZVRvb2xzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB0b29sc1ZpZXcuaGlkZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2hvd1Rvb2xzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB0b29sc1ZpZXcuc2hvdygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25Ub29sRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVUb29scygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGlkZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlVG9vbHMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Nob3cnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlSGlnaGxpZ2h0ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGlnaGxpZ2h0ZXJWaWV3LnJlbW92ZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlSGlnaGxpZ2h0ZXJzOiBmdW5jdGlvbihkaXJ0eSA9IGZhbHNlKSB7XG4gICAgICAgIEhpZ2hsaWdodGVyVmlldy51cGRhdGUodGhpcywgbnVsbCwgZGlydHkpO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1IaWdobGlnaHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIaWdobGlnaHRlclZpZXcudHJhbnNmb3JtKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcmFjdGlvbi4gVGhlIGNvbnRyb2xsZXIgcGFydC5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHByZXZlbnREZWZhdWx0SW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBkZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQ6IHRydWUgIH0pO1xuICAgIH0sXG5cbiAgICBpc0RlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZChldnQpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQgPSBmYWxzZSB9ID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJhY3Rpb24gaXMgaGFuZGxlZCBieSB0aGUgcGFwZXIgYW5kIGRlbGVnYXRlZCB0byB0aGUgdmlldyBpbiBpbnRlcmVzdC5cbiAgICAvLyBgeGAgJiBgeWAgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlc2UgZnVuY3Rpb25zIHJlcHJlc2VudCB0aGUgY29vcmRpbmF0ZXMgYWxyZWFkeSBzbmFwcGVkIHRvIHRoZSBwYXBlciBncmlkLlxuICAgIC8vIElmIG5lY2Vzc2FyeSwgcmVhbCBjb29yZGluYXRlcyBjYW4gYmUgb2J0YWluZWQgZnJvbSB0aGUgYGV2dGAgZXZlbnQgb2JqZWN0LlxuXG4gICAgLy8gVGhlc2UgZnVuY3Rpb25zIGFyZSBzdXBwb3NlZCB0byBiZSBvdmVycmlkZGVuIGJ5IHRoZSB2aWV3cyB0aGF0IGluaGVyaXQgZnJvbSBgam9pbnQuZGlhLkNlbGxgLFxuICAgIC8vIGkuZS4gYGpvaW50LmRpYS5FbGVtZW50YCBhbmQgYGpvaW50LmRpYS5MaW5rYC5cblxuICAgIHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpwb2ludGVyY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6Y29udGV4dG1lbnUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBncmFwaCB9ID0gbW9kZWw7XG4gICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgbW9kZWwuc3RhcnRCYXRjaCgncG9pbnRlcicpO1xuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IGdyYXBoIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcmRvd24nLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcm1vdmUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVydXA6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGggfSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6cG9pbnRlcnVwJywgZXZ0LCB4LCB5KTtcblxuICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBldmVudCBvbiBtb2RlbCBhcyBtb2RlbCBkb2Vzbid0XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGJlIG1lbWJlciBvZiBjb2xsZWN0aW9uIGFueW1vcmUgKHJlbW92ZSlcbiAgICAgICAgICAgIGdyYXBoLnN0b3BCYXRjaCgncG9pbnRlcicsIHsgY2VsbDogdGhpcy5tb2RlbCB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNlb3ZlcicsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDptb3VzZW91dCcsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNlZW50ZXInLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDptb3VzZWxlYXZlJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0LCB4LCB5LCBkZWx0YSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNld2hlZWwnLCBldnQsIHgsIHksIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgb25ldmVudDogZnVuY3Rpb24oZXZ0LCBldmVudE5hbWUsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeShldmVudE5hbWUsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG9ubWFnbmV0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBtYWduZXRjb250ZXh0bWVudTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbm9vcFxuICAgIH0sXG5cbiAgICBjaGVja01vdXNlbGVhdmUoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIG1vZGVsIH0gPSB0aGlzO1xuICAgICAgICBpZiAocGFwZXIuaXNBc3luYygpKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNvdXJjZS90YXJnZXQgdmlld3MgYXJlIHVwZGF0ZWQgYmVmb3JlIHRoaXMgdmlldy5cbiAgICAgICAgICAgIC8vIEl0J3Mgbm90IDEwMCUgYnVsbGV0cHJvb2YgKHNlZSBiZWxvdykgYnV0IGl0J3MgYSBnb29kIGVub3VnaCBzb2x1dGlvbiBmb3Igbm93LlxuICAgICAgICAgICAgLy8gVGhlIGNvbm5lY3RlZCBjZWxscyBjb3VsZCBiZSBsaW5rcyBhcyB3ZWxsLiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGdvIHRocm91Z2ggYWxsIHRoZSBjb25uZWN0ZWQgbGlua3MgYW5kIHVwZGF0ZVxuICAgICAgICAgICAgLy8gdGhlaXIgc291cmNlL3RhcmdldCB2aWV3cyBhcyB3ZWxsLlxuICAgICAgICAgICAgaWYgKG1vZGVsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGB0aGlzLnNvdXJjZVZpZXdgIGFuZCBgdGhpcy50YXJnZXRWaWV3YCBtaWdodCBub3QgYmUgdXBkYXRlZCB5ZXQuXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBmaW5kIHRoZSB2aWV3IGJ5IHRoZSBtb2RlbC5cbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VFbGVtZW50ID0gbW9kZWwuZ2V0U291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZpZXcgPSBwYXBlci5maW5kVmlld0J5TW9kZWwoc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlci5kdW1wVmlldyhzb3VyY2VWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcGVyLmNoZWNrVmlld1Zpc2liaWxpdHkoc291cmNlVmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IG1vZGVsLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRWaWV3ID0gcGFwZXIuZmluZFZpZXdCeU1vZGVsKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Vmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFwZXIuZHVtcFZpZXcodGFyZ2V0Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlci5jaGVja1ZpZXdWaXNpYmlsaXR5KHRhcmdldFZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gdGhlIHVwZGF0ZXMgb2YgdGhlIGN1cnJlbnQgdmlldyBzeW5jaHJvbm91c2x5IG5vd1xuICAgICAgICAgICAgcGFwZXIuZHVtcFZpZXcodGhpcyk7XG4gICAgICAgICAgICBwYXBlci5jaGVja1ZpZXdWaXNpYmlsaXR5KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0RXZlbnRUYXJnZXQoZXZ0LCB7IGZyb21Qb2ludDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgdmlldyA9IHBhcGVyLmZpbmRWaWV3KHRhcmdldCk7XG4gICAgICAgIGlmICh2aWV3ID09PSB0aGlzKSByZXR1cm47XG4gICAgICAgIC8vIExlYXZpbmcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICB0aGlzLm1vdXNlbGVhdmUoZXZ0KTtcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm47XG4gICAgICAgIC8vIEVudGVyaW5nIGFub3RoZXIgdmlld1xuICAgICAgICB2aWV3Lm1vdXNlZW50ZXIoZXZ0KTtcbiAgICB9LFxuXG4gICAgc2V0SW50ZXJhY3Rpdml0eTogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgaXNJbnRlcnNlY3Rpbmc6IGZ1bmN0aW9uKGdlb21ldHJ5U2hhcGUsIGdlb21ldHJ5RGF0YSkge1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLmV4aXN0cyhnZW9tZXRyeVNoYXBlLCB0aGlzLmdldE5vZGVCQm94KHRoaXMuZWwpLCBnZW9tZXRyeURhdGEpO1xuICAgIH0sXG5cbiAgICBpc0VuY2xvc2VkSW46IGZ1bmN0aW9uKGdlb21ldHJ5UmVjdCkge1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnlSZWN0LmNvbnRhaW5zUmVjdCh0aGlzLmdldE5vZGVCQm94KHRoaXMuZWwpKTtcbiAgICB9LFxuXG4gICAgaXNJbkFyZWE6IGZ1bmN0aW9uKGdlb21ldHJ5UmVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFbmNsb3NlZEluKGdlb21ldHJ5UmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbnRlcnNlY3RpbmcoZ2VvbWV0cnlSZWN0KTtcbiAgICB9LFxuXG4gICAgaXNBdFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROb2RlQkJveCh0aGlzLmVsKS5jb250YWluc1BvaW50KHBvaW50LCBvcHRpb25zKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIEZsYWdzLFxuXG4gICAgSGlnaGxpZ2h0aW5nOiBIaWdobGlnaHRpbmdUeXBlcyxcblxuICAgIGFkZFByZXNlbnRhdGlvbkF0dHJpYnV0ZXM6IGZ1bmN0aW9uKHByZXNlbnRhdGlvbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCByZXN1bHQodGhpcy5wcm90b3R5cGUsICdwcmVzZW50YXRpb25BdHRyaWJ1dGVzJyksIHByZXNlbnRhdGlvbkF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykgYSA9IFthXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ3N0cmluZycpIGIgPSBbYl07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSByZXR1cm4gdW5pcShhLmNvbmNhdChiKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBldmFsQXR0cmlidXRlLFxuXG59KTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2VsbFZpZXcucHJvdG90eXBlLCAndXNlQ1NTU2VsZWN0b3JzJywge1xuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgbG9jYWxVc2UgPSB0aGlzLm1vZGVsLnVzZUNTU1NlbGVjdG9ycztcbiAgICAgICAgaWYgKGxvY2FsVXNlICE9PSB1bmRlZmluZWQpIHJldHVybiBsb2NhbFVzZTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy51c2VDU1NTZWxlY3RvcnM7XG4gICAgfVxufSk7XG5cbi8vIFRPRE86IE1vdmUgdG8gVmVjdG9yaXplciBsaWJyYXJ5LlxuZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3JOb2RlKG5vZGUxLCBub2RlMikge1xuICAgIGxldCBwYXJlbnQgPSBub2RlMTtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwYXJlbnQuY29udGFpbnMobm9kZTIpKSByZXR1cm4gcGFyZW50O1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChwYXJlbnQpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/Element.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Element.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Element: () => (/* binding */ Element)\n/* harmony export */ });\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _ports_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ports.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ports.mjs\");\n\n\n\n\n\n// Element base model.\n// -----------------------------\n\nconst Element = _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.extend({\n\n    defaults: {\n        position: { x: 0, y: 0 },\n        size: { width: 1, height: 1 },\n        angle: 0\n    },\n\n    initialize: function() {\n\n        this._initializePorts();\n        _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.prototype.initialize.apply(this, arguments);\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    _refreshPorts: function() {\n        // implemented in ports.js\n    },\n\n    isElement: function() {\n\n        return true;\n    },\n\n    position: function(x, y, opt) {\n\n        const isSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(y);\n        opt = (isSetter ? opt : x) || {};\n        const { parentRelative, deep, restrictedArea } = opt;\n\n\n        // option `parentRelative` for setting the position relative to the element's parent.\n        let parentPosition;\n        if (parentRelative) {\n\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error('Element must be part of a graph.');\n\n            const parent = this.getParentCell();\n            if (parent && !parent.isLink()) {\n                parentPosition = parent.get('position');\n            }\n        }\n\n        if (isSetter) {\n\n            if (parentPosition) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n\n            if (deep || restrictedArea) {\n                const { x: x0, y: y0 } = this.get('position');\n                this.translate(x - x0, y - y0, opt);\n            } else {\n                this.set('position', { x, y }, opt);\n            }\n\n            return this;\n\n        } else { // Getter returns a geometry point.\n\n            const elementPosition = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(this.get('position'));\n            return parentRelative\n                ? elementPosition.difference(parentPosition)\n                : elementPosition;\n        }\n    },\n\n    translate: function(tx, ty, opt) {\n\n        tx = tx || 0;\n        ty = ty || 0;\n\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n\n        var position = this.get('position') || { x: 0, y: 0 };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n\n            if (typeof ra === 'function') {\n\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n\n            } else  {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({ deep: true });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                   |\n                //         \n                //                 |\n                //   \n                //                  |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |    translated element\n                //   <- - bbox.width - ->        embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n\n        if (opt.transition) {\n\n            if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt.transition)) opt.transition = {};\n\n            this.transition('position', translatedPosition, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, opt.transition, {\n                valueFunction: _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.interpolate.object\n            }));\n\n            // Recursively call `translate()` on all the embeds cells.\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n        } else {\n\n            this.startBatch('translate', opt);\n            this.set('position', translatedPosition, opt);\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n            this.stopBatch('translate', opt);\n        }\n\n        return this;\n    },\n\n    size: function(width, height, opt) {\n\n        var currentSize = this.get('size');\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(width)) {\n            opt = height;\n            height = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(width.height) ? width.height : currentSize.height;\n            width = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(width.width) ? width.width : currentSize.width;\n        }\n\n        return this.resize(width, height, opt);\n    },\n\n    resize: function(width, height, opt) {\n\n        opt = opt || {};\n\n        this.startBatch('resize', opt);\n\n        if (opt.direction) {\n\n            var currentSize = this.get('size');\n\n            switch (opt.direction) {\n\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle)(this.get('angle') || 0);\n\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n\n            var origin;\n\n            if (angle) {\n\n                var quadrant = {\n                    'top-right': 0,\n                    'right': 0,\n                    'top-left': 1,\n                    'top': 1,\n                    'bottom-left': 2,\n                    'left': 2,\n                    'bottom-right': 3,\n                    'bottom': 3\n                }[opt.direction];\n\n                if (opt.absolute) {\n\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(fixedPoint).rotate(bbox.center(), -angle);\n\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.toRad)(angle);\n\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point.fromPolar(radius, alpha, imageFixedPoint);\n\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(center).offset(width / -2, height / -2);\n\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n\n                switch (opt.direction) {\n                    case 'top':\n                    case 'top-right':\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case 'left':\n                    case 'bottom-left':\n                        origin.offset(bbox.width -width, 0);\n                        break;\n                    case 'top-left':\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n\n            // Resize the element (before re-positioning it).\n            this.set('size', { width: width, height: height }, opt);\n\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n\n        } else {\n\n            // Resize the element.\n            this.set('size', { width: width, height: height }, opt);\n        }\n\n        this.stopBatch('resize', opt);\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch('scale', opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch('scale');\n        return this;\n    },\n\n    fitEmbeds: function(opt) {\n\n        return this.fitToChildren(opt);\n    },\n\n    fitToChildren: function(opt = {}) {\n\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') holds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        const childElements = this.getEmbeddedCells().filter(cell => cell.isElement());\n        if (childElements.length === 0) return this;\n\n        this.startBatch('fit-embeds', opt);\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit to all descendants\".\n            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(childElements, 'fitToChildren', opt);\n        }\n\n        // Set new size and position of this element, based on:\n        // - union of bboxes of all children\n        // - inflated by given `opt.padding`\n        this._fitToElements(Object.assign({ elements: childElements }, opt));\n\n        this.stopBatch('fit-embeds');\n\n        return this;\n    },\n\n    fitParent: function(opt = {}) {\n\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n        if (opt.deep && opt.terminator && ((opt.terminator === this) || (opt.terminator === this.id))) return this;\n\n        const parentElement = this.getParentCell();\n        if (!parentElement || !parentElement.isElement()) return this;\n\n        // Get all children of parent element (i.e. this element + any sibling elements).\n        const siblingElements = parentElement.getEmbeddedCells().filter(cell => cell.isElement());\n        if (siblingElements.length === 0) return this;\n\n        this.startBatch('fit-parent', opt);\n\n        // Set new size and position of parent element, based on:\n        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n        // - inflated by given `opt.padding`\n        parentElement._fitToElements(Object.assign({ elements: siblingElements }, opt));\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit all ancestors to their respective children\".\n            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n            parentElement.fitParent(opt);\n        }\n\n        this.stopBatch('fit-parent');\n\n        return this;\n    },\n\n    // Assumption: This element is part of a graph.\n    _fitToElements: function(opt = {}) {\n\n        const elementsBBox = this.graph.getCellsBBox(opt.elements);\n        // If no `opt.elements` were provided, do nothing.\n        if (!elementsBBox) return;\n\n        const { expandOnly, shrinkOnly } = opt;\n        // This combination is meaningless, do nothing.\n        if (expandOnly && shrinkOnly) return;\n\n        // Calculate new size and position of this element based on:\n        // - union of bboxes of `opt.elements`\n        // - inflated by `opt.padding` (if not provided, all four properties = 0)\n        let { x, y, width, height } = elementsBBox;\n        const { left, right, top, bottom } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeSides)(opt.padding);\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n        let resultBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(x, y, width, height);\n\n        if (expandOnly) {\n            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n            resultBBox = this.getBBox().union(resultBBox);\n\n        } else if (shrinkOnly) {\n            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n            const intersectionBBox = this.getBBox().intersect(resultBBox);\n            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n            if (!intersectionBBox) return;\n\n            resultBBox =  intersectionBBox;\n        }\n\n        // Set the new size and position of this element.\n        this.set({\n            position: { x: resultBBox.x, y: resultBBox.y },\n            size: { width: resultBBox.width, height: resultBBox.height }\n        }, opt);\n    },\n\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n\n        if (origin) {\n\n            var center = this.getBBox().center();\n            var size = this.get('size');\n            var position = this.get('position');\n            center.rotate(origin, this.get('angle') - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch('rotate');\n\n        } else {\n\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n        }\n\n        return this;\n    },\n\n    angle: function() {\n        return (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle)(this.get('angle') || 0);\n    },\n\n    getBBox: function(opt = {}) {\n\n        const { graph, attributes } = this;\n        const { deep, rotate } = opt;\n\n        if (deep && graph) {\n            // Get all the embedded elements using breadth first algorithm.\n            const elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n            // Add the model itself.\n            elements.push(this);\n            // Note: the default of getCellsBBox() is rotate=true and can't be\n            // changed without a breaking change\n            return graph.getCellsBBox(elements, opt);\n        }\n\n        const { angle = 0, position: { x, y }, size: { width, height }} = attributes;\n        const bbox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(x, y, width, height);\n        if (rotate) {\n            bbox.rotateAroundCenter(angle);\n        }\n        return bbox;\n    },\n\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, ['group']);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n\n(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(Element.prototype, _ports_mjs__WEBPACK_IMPORTED_MODULE_6__.elementPortPrototype);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9FbGVtZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFrQztBQUNrQztBQUNnQztBQUNqRDs7QUFFbkQ7QUFDQTs7QUFFTyxnQkFBZ0IsMkNBQUk7O0FBRTNCO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxRQUFRLDJDQUFJO0FBQ1osS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEseUJBQXlCLHlEQUFRO0FBQ2pDO0FBQ0EsZ0JBQWdCLHVDQUF1Qzs7O0FBR3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0EsY0FBYztBQUNkLHVDQUF1QyxNQUFNO0FBQzdDOztBQUVBOztBQUVBLFVBQVUsT0FBTzs7QUFFakIsb0NBQW9DLG1EQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLDREQUFjO0FBQzdCLEtBQUs7O0FBRUwsOEJBQThCOztBQUU5QixnQkFBZ0Isb0JBQW9CO0FBQ3BDLGdCQUFnQixlQUFlOztBQUUvQjtBQUNBO0FBQ0EscURBQXFELGdDQUFnQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHVCQUF1QixNQUFNLFVBQVUsaUJBQWlCO0FBQ3hFLHlCQUF5Qiw4Q0FBSTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQ0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsdURBQU0sb0JBQW9CLDREQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9FbGVtZW50Lm1qcz9iMzNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENlbGwgfSBmcm9tICcuL0NlbGwubWpzJztcbmltcG9ydCB7IFBvaW50LCB0b1JhZCwgbm9ybWFsaXplQW5nbGUsIFJlY3QgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc051bWJlciwgaXNPYmplY3QsIGludGVycG9sYXRlLCBhc3NpZ24sIGludm9rZSwgbm9ybWFsaXplU2lkZXMgfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBlbGVtZW50UG9ydFByb3RvdHlwZSB9IGZyb20gJy4vcG9ydHMubWpzJztcblxuLy8gRWxlbWVudCBiYXNlIG1vZGVsLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IEVsZW1lbnQgPSBDZWxsLmV4dGVuZCh7XG5cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHNpemU6IHsgd2lkdGg6IDEsIGhlaWdodDogMSB9LFxuICAgICAgICBhbmdsZTogMFxuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplUG9ydHMoKTtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgaW4gcG9ydHMuanNcbiAgICB9LFxuXG4gICAgX3JlZnJlc2hQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGluIHBvcnRzLmpzXG4gICAgfSxcblxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbih4LCB5LCBvcHQpIHtcblxuICAgICAgICBjb25zdCBpc1NldHRlciA9IGlzTnVtYmVyKHkpO1xuICAgICAgICBvcHQgPSAoaXNTZXR0ZXIgPyBvcHQgOiB4KSB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBwYXJlbnRSZWxhdGl2ZSwgZGVlcCwgcmVzdHJpY3RlZEFyZWEgfSA9IG9wdDtcblxuXG4gICAgICAgIC8vIG9wdGlvbiBgcGFyZW50UmVsYXRpdmVgIGZvciBzZXR0aW5nIHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIHBhcmVudC5cbiAgICAgICAgbGV0IHBhcmVudFBvc2l0aW9uO1xuICAgICAgICBpZiAocGFyZW50UmVsYXRpdmUpIHtcblxuICAgICAgICAgICAgLy8gR2V0dGluZyB0aGUgcGFyZW50J3MgcG9zaXRpb24gcmVxdWlyZXMgdGhlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAvLyBDZWxsLnBhcmVudCgpIGhvbGRzIGNlbGwgaWQgb25seS5cbiAgICAgICAgICAgIGlmICghdGhpcy5ncmFwaCkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG11c3QgYmUgcGFydCBvZiBhIGdyYXBoLicpO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHBhcmVudFBvc2l0aW9uID0gcGFyZW50LmdldCgncG9zaXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NldHRlcikge1xuXG4gICAgICAgICAgICBpZiAocGFyZW50UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB4ICs9IHBhcmVudFBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgeSArPSBwYXJlbnRQb3NpdGlvbi55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVlcCB8fCByZXN0cmljdGVkQXJlYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogeDAsIHk6IHkwIH0gPSB0aGlzLmdldCgncG9zaXRpb24nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSh4IC0geDAsIHkgLSB5MCwgb3B0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoJ3Bvc2l0aW9uJywgeyB4LCB5IH0sIG9wdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIEdldHRlciByZXR1cm5zIGEgZ2VvbWV0cnkgcG9pbnQuXG5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRQb3NpdGlvbiA9IFBvaW50KHRoaXMuZ2V0KCdwb3NpdGlvbicpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRSZWxhdGl2ZVxuICAgICAgICAgICAgICAgID8gZWxlbWVudFBvc2l0aW9uLmRpZmZlcmVuY2UocGFyZW50UG9zaXRpb24pXG4gICAgICAgICAgICAgICAgOiBlbGVtZW50UG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHksIG9wdCkge1xuXG4gICAgICAgIHR4ID0gdHggfHwgMDtcbiAgICAgICAgdHkgPSB0eSB8fCAwO1xuXG4gICAgICAgIGlmICh0eCA9PT0gMCAmJiB0eSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTGlrZSBub3RoaW5nIGhhcyBoYXBwZW5lZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICAvLyBQYXNzIHRoZSBpbml0aWF0b3Igb2YgdGhlIHRyYW5zbGF0aW9uLlxuICAgICAgICBvcHQudHJhbnNsYXRlQnkgPSBvcHQudHJhbnNsYXRlQnkgfHwgdGhpcy5pZDtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldCgncG9zaXRpb24nKSB8fCB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgdmFyIHJhID0gb3B0LnJlc3RyaWN0ZWRBcmVhO1xuICAgICAgICBpZiAocmEgJiYgb3B0LnRyYW5zbGF0ZUJ5ID09PSB0aGlzLmlkKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmEgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHJhLmNhbGwodGhpcywgcG9zaXRpb24ueCArIHR4LCBwb3NpdGlvbi55ICsgdHksIG9wdCk7XG5cbiAgICAgICAgICAgICAgICB0eCA9IG5ld1Bvc2l0aW9uLnggLSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHR5ID0gbmV3UG9zaXRpb24ueSAtIHBvc2l0aW9uLnk7XG5cbiAgICAgICAgICAgIH0gZWxzZSAge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSByZXN0cmljdGluZyB0aGUgdHJhbnNsYXRpb24gZm9yIHRoZSBlbGVtZW50IGl0c2VsZiBvbmx5LiBXZSBnZXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50IGluY2x1ZGluZyBhbGwgaXRzIGVtYmVkcy5cbiAgICAgICAgICAgICAgICAvLyBBbGwgZW1iZWRzIGhhdmUgdG8gYmUgdHJhbnNsYXRlZCB0aGUgZXhhY3Qgc2FtZSB3YXkgYXMgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIC8vLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLT4gcmEueCArIHJhLndpZHRoXG4gICAgICAgICAgICAgICAgLy8gLSAtIC0gLT4gcG9zaXRpb24ueCAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAtPiBiYm94LnhcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICDilpPilpPilpPilpPilpPilpPilpMgICB8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICDilpHilpHilpHilpHilpHilpHilpHilpPilpPilpPilpPilpPilpPilpNcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIOKWkeKWkeKWkeKWkeKWkeKWkeKWkeKWkeKWkSAgICAgICAgfFxuICAgICAgICAgICAgICAgIC8vICAg4paT4paT4paT4paT4paT4paT4paT4paT4paR4paR4paR4paR4paR4paR4paRXG4gICAgICAgICAgICAgICAgLy8gICDilpPilpPilpPilpPilpPilpPilpPilpMgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgLy8gICA8LWR4LT4gICAgICAgICAgICAgICAgICAgICB8IHJlc3RyaWN0ZWQgYXJlYSByaWdodCBib3JkZXJcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIDwtd2lkdGgtPiAgICAgICAgfCAgIOKWkSB0cmFuc2xhdGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyAgIDwtIC0gYmJveC53aWR0aCAtIC0+ICAgICAgIOKWkyBlbWJlZGRlZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gcG9zaXRpb24ueCAtIGJib3gueDtcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSBwb3NpdGlvbi55IC0gYmJveC55O1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1heGltYWwvbWluaW1hbCBjb29yZGluYXRlcyB0aGF0IHRoZSBlbGVtZW50IGNhbiBiZSB0cmFuc2xhdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgY29tcGxpZXMgdGhlIHJlc3RyaWN0aW9ucy5cbiAgICAgICAgICAgICAgICB2YXIgeCA9IE1hdGgubWF4KHJhLnggKyBkeCwgTWF0aC5taW4ocmEueCArIHJhLndpZHRoICsgZHggLSBiYm94LndpZHRoLCBwb3NpdGlvbi54ICsgdHgpKTtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IE1hdGgubWF4KHJhLnkgKyBkeSwgTWF0aC5taW4ocmEueSArIHJhLmhlaWdodCArIGR5IC0gYmJveC5oZWlnaHQsIHBvc2l0aW9uLnkgKyB0eSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSB0cmFuc2xhdGlvbiB0YWtpbmcgdGhlIHJlc3RyaWN0aW9ucyBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgICAgdHggPSB4IC0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICB0eSA9IHkgLSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zbGF0ZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc2l0aW9uLnggKyB0eCxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uLnkgKyB0eVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvIGZpbmQgb3V0IGJ5IGhvdyBtdWNoIGFuIGVsZW1lbnQgd2FzIHRyYW5zbGF0ZWQgaW4gZXZlbnQgJ2NoYW5nZTpwb3NpdGlvbicgaGFuZGxlcnMuXG4gICAgICAgIG9wdC50eCA9IHR4O1xuICAgICAgICBvcHQudHkgPSB0eTtcblxuICAgICAgICBpZiAob3B0LnRyYW5zaXRpb24pIHtcblxuICAgICAgICAgICAgaWYgKCFpc09iamVjdChvcHQudHJhbnNpdGlvbikpIG9wdC50cmFuc2l0aW9uID0ge307XG5cbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbigncG9zaXRpb24nLCB0cmFuc2xhdGVkUG9zaXRpb24sIGFzc2lnbih7fSwgb3B0LnRyYW5zaXRpb24sIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUZ1bmN0aW9uOiBpbnRlcnBvbGF0ZS5vYmplY3RcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY2FsbCBgdHJhbnNsYXRlKClgIG9uIGFsbCB0aGUgZW1iZWRzIGNlbGxzLlxuICAgICAgICAgICAgaW52b2tlKHRoaXMuZ2V0RW1iZWRkZWRDZWxscygpLCAndHJhbnNsYXRlJywgdHgsIHR5LCBvcHQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgndHJhbnNsYXRlJywgb3B0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0KCdwb3NpdGlvbicsIHRyYW5zbGF0ZWRQb3NpdGlvbiwgb3B0KTtcbiAgICAgICAgICAgIGludm9rZSh0aGlzLmdldEVtYmVkZGVkQ2VsbHMoKSwgJ3RyYW5zbGF0ZScsIHR4LCB0eSwgb3B0KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEJhdGNoKCd0cmFuc2xhdGUnLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdCkge1xuXG4gICAgICAgIHZhciBjdXJyZW50U2l6ZSA9IHRoaXMuZ2V0KCdzaXplJyk7XG4gICAgICAgIC8vIEdldHRlclxuICAgICAgICAvLyAoKSBzaWduYXR1cmVcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY3VycmVudFNpemUuaGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHRlclxuICAgICAgICAvLyAoc2l6ZSwgb3B0KSBzaWduYXR1cmVcbiAgICAgICAgaWYgKGlzT2JqZWN0KHdpZHRoKSkge1xuICAgICAgICAgICAgb3B0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gaXNOdW1iZXIod2lkdGguaGVpZ2h0KSA/IHdpZHRoLmhlaWdodCA6IGN1cnJlbnRTaXplLmhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gaXNOdW1iZXIod2lkdGgud2lkdGgpID8gd2lkdGgud2lkdGggOiBjdXJyZW50U2l6ZS53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcHQpO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3Jlc2l6ZScsIG9wdCk7XG5cbiAgICAgICAgaWYgKG9wdC5kaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gdGhpcy5nZXQoJ3NpemUnKTtcblxuICAgICAgICAgICAgc3dpdGNoIChvcHQuZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoYW5nZSBoZWlnaHQgd2hlbiByZXNpemluZyBob3Jpem9udGFsbHkuXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGN1cnJlbnRTaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNoYW5nZSB3aWR0aCB3aGVuIHJlc2l6aW5nIHZlcnRpY2FsbHkuXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gY3VycmVudFNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGFuZ2xlIGFuZCBjbGFtcCBpdHMgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlcy5cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlKHRoaXMuZ2V0KCdhbmdsZScpIHx8IDApO1xuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVjdGFuZ2xlIGluIHNpemUgb2YgdGhlIHVuLXJvdGF0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW47XG5cbiAgICAgICAgICAgIGlmIChhbmdsZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHF1YWRyYW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAndG9wLXJpZ2h0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RvcC1sZWZ0JzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICdib3R0b20tbGVmdCc6IDIsXG4gICAgICAgICAgICAgICAgICAgICdsZWZ0JzogMixcbiAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbS1yaWdodCc6IDMsXG4gICAgICAgICAgICAgICAgICAgICdib3R0b20nOiAzXG4gICAgICAgICAgICAgICAgfVtvcHQuZGlyZWN0aW9uXTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHQuYWJzb2x1dGUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgdGFraW5nIHRoZSBlbGVtZW50J3Mgcm90YXRpb24gaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYW50ICs9IE1hdGguZmxvb3IoKGFuZ2xlICsgNDUpIC8gOTApO1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmFudCAlPSA0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFBpY2sgdGhlIGNvcm5lciBwb2ludCBvbiB0aGUgZWxlbWVudCwgd2hpY2ggbWVhbnQgdG8gc3RheSBvbiBpdHMgcGxhY2UgYmVmb3JlIGFuZFxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSByb3RhdGlvbi5cbiAgICAgICAgICAgICAgICB2YXIgZml4ZWRQb2ludCA9IGJib3hbWydib3R0b21MZWZ0JywgJ2Nvcm5lcicsICd0b3BSaWdodCcsICdvcmlnaW4nXVtxdWFkcmFudF1dKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kICBhbiBpbWFnZSBvZiB0aGUgcHJldmlvdXMgaW5kZW50IHBvaW50LiBUaGlzIGlzIHRoZSBwb3NpdGlvbiwgd2hlcmUgaXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gcG9pbnQgYWN0dWFsbHkgbG9jYXRlZCBvbiB0aGUgc2NyZWVuLlxuICAgICAgICAgICAgICAgIHZhciBpbWFnZUZpeGVkUG9pbnQgPSBQb2ludChmaXhlZFBvaW50KS5yb3RhdGUoYmJveC5jZW50ZXIoKSwgLWFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIEV2ZXJ5IHBvaW50IG9uIHRoZSBlbGVtZW50IHJvdGF0ZXMgYXJvdW5kIGEgY2lyY2xlIHdpdGggdGhlIGNlbnRyZSBvZiByb3RhdGlvblxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgdGhlIGVsZW1lbnQgd2hpbGUgdGhlIHdob2xlIGVsZW1lbnQgaXMgYmVpbmcgcm90YXRlZC4gVGhhdCBtZWFuc1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlIGRpc3RhbmNlIGZyb20gYSBwb2ludCBpbiB0aGUgY29ybmVyIG9mIHRoZSBlbGVtZW50IChzdXBwb3NlZCBpdHMgYWx3YXlzIHJlY3QpIHRvXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCBkb2Vzbid0IGNoYW5nZSBkdXJpbmcgdGhlIHJvdGF0aW9uIGFuZCB0aGVyZWZvcmUgaXQgZXF1YWxzXG4gICAgICAgICAgICAgICAgLy8gdG8gYSBkaXN0YW5jZSBvbiB1bi1yb3RhdGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGZpbmQgdGhlIGRpc3RhbmNlIGFzIERJU1RBTkNFID0gKEVMRU1FTlRXSURUSC8yKV4yICsgKEVMRU1FTlRIRUlHSFQvMileMileMC41LlxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoKHdpZHRoICogd2lkdGgpICsgKGhlaWdodCAqIGhlaWdodCkpIC8gMjtcblxuICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBhcmUgbG9va2luZyBmb3IgYW4gYW5nbGUgYmV0d2VlbiB4LWF4aXMgYW5kIHRoZSBsaW5lIHN0YXJ0aW5nIGF0IGltYWdlIG9mIGZpeGVkIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIGVuZGluZyBhdCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LiBXZSBjYWxsIHRoaXMgYW5nbGUgYGFscGhhYC5cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBpbWFnZSBvZiBhIGZpeGVkIHBvaW50IGlzIGxvY2F0ZWQgaW4gbi10aCBxdWFkcmFudC4gRm9yIGVhY2ggcXVhZHJhbnQgcGFzc2VkXG4gICAgICAgICAgICAgICAgLy8gZ29pbmcgYW50aS1jbG9ja3dpc2Ugd2UgaGF2ZSB0byBhZGQgOTAgZGVncmVlcy4gTm90ZSB0aGF0IHRoZSBmaXJzdCBxdWFkcmFudCBoYXMgaW5kZXggMC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIDMgfCAyXG4gICAgICAgICAgICAgICAgLy8gLS1jLS0gUXVhZHJhbnQgcG9zaXRpb25zIGFyb3VuZCB0aGUgZWxlbWVudCdzIGNlbnRlciBgY2BcbiAgICAgICAgICAgICAgICAvLyAwIHwgMVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gcXVhZHJhbnQgKiBNYXRoLlBJIC8gMjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbiBhbmdsZSBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgcXVhZHJhbnQgKGxpbmUgcGFyYWxsZWwgd2l0aCB4LWF4aXMgb3IgeS1heGlzXG4gICAgICAgICAgICAgICAgLy8gZ29pbmcgdGhyb3VnaCB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50KSBhbmQgbGluZSBjcm9zc2luZyB0aGUgaW5kZW50IG9mIHRoZSBmaXhlZCBwb2ludCBhbmQgdGhlIGNlbnRlclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBlbGVtZW50LiBUaGlzIGlzIHRoZSBhbmdsZSB3ZSBuZWVkIGJ1dCBvbiB0aGUgdW4tcm90YXRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGFscGhhICs9IE1hdGguYXRhbihxdWFkcmFudCAlIDIgPT0gMCA/IGhlaWdodCAvIHdpZHRoIDogd2lkdGggLyBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gTGFzdGx5IHdlIGhhdmUgdG8gZGVkdWN0IHRoZSBvcmlnaW5hbCBhbmdsZSB0aGUgZWxlbWVudCB3YXMgcm90YXRlZCBieSBhbmQgdGhhdCdzIGl0LlxuICAgICAgICAgICAgICAgIGFscGhhIC09IHRvUmFkKGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIFdpdGggdGhpcyBhbmdsZSBhbmQgZGlzdGFuY2Ugd2UgY2FuIGVhc2lseSBjYWxjdWxhdGUgdGhlIGNlbnRyZSBvZiB0aGUgdW4tcm90YXRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBmcm9tUG9sYXIgY29uc3RydWN0b3IgYWNjZXB0cyBhbiBhbmdsZSBpbiByYWRpYW5zLlxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBQb2ludC5mcm9tUG9sYXIocmFkaXVzLCBhbHBoYSwgaW1hZ2VGaXhlZFBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSB0b3AgbGVmdCBjb3JuZXIgb24gdGhlIHVuLXJvdGF0ZWQgZWxlbWVudCBoYXMgdG8gYmUgaGFsZiBhIHdpZHRoIG9uIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgLy8gYW5kIGhhbGYgYSBoZWlnaHQgdG8gdGhlIHRvcCBmcm9tIHRoZSBjZW50ZXIuIFRoaXMgd2lsbCBiZSB0aGUgb3JpZ2luIG9mIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIC8vIHdlIHdlcmUgbG9va2luZyBmb3IuXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gUG9pbnQoY2VudGVyKS5vZmZzZXQod2lkdGggLyAtMiwgaGVpZ2h0IC8gLTIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0aW9uIGZvciB0aGUgb3JpZ2luIFBvaW50IHdoZW4gdGhlcmUgaXMgbm8gcm90YXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBiYm94LnRvcExlZnQoKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3B0LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm9mZnNldCgwLCBiYm94LmhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5vZmZzZXQoYmJveC53aWR0aCAtd2lkdGgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5vZmZzZXQoYmJveC53aWR0aCAtIHdpZHRoLCBiYm94LmhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2l6ZSB0aGUgZWxlbWVudCAoYmVmb3JlIHJlLXBvc2l0aW9uaW5nIGl0KS5cbiAgICAgICAgICAgIHRoaXMuc2V0KCdzaXplJywgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIG9wdCk7XG5cbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHJlLXBvc2l0aW9uIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbihvcmlnaW4ueCwgb3JpZ2luLnksIG9wdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gUmVzaXplIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5zZXQoJ3NpemUnLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdyZXNpemUnLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4sIG9wdCkge1xuXG4gICAgICAgIHZhciBzY2FsZWRCQm94ID0gdGhpcy5nZXRCQm94KCkuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3NjYWxlJywgb3B0KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihzY2FsZWRCQm94LngsIHNjYWxlZEJCb3gueSwgb3B0KTtcbiAgICAgICAgdGhpcy5yZXNpemUoc2NhbGVkQkJveC53aWR0aCwgc2NhbGVkQkJveC5oZWlnaHQsIG9wdCk7XG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdzY2FsZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZml0RW1iZWRzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5maXRUb0NoaWxkcmVuKG9wdCk7XG4gICAgfSxcblxuICAgIGZpdFRvQ2hpbGRyZW46IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgLy8gR2V0dGluZyB0aGUgY2hpbGRyZW4ncyBzaXplIGFuZCBwb3NpdGlvbiByZXF1aXJlcyB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgLy8gQ2VsbC5nZXQoJ2VtYmVkcycpIGhvbGRzIGFuIGFycmF5IG9mIGNlbGwgaWRzIG9ubHkuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGggfSA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGgpIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBtdXN0IGJlIHBhcnQgb2YgYSBncmFwaC4nKTtcblxuICAgICAgICBjb25zdCBjaGlsZEVsZW1lbnRzID0gdGhpcy5nZXRFbWJlZGRlZENlbGxzKCkuZmlsdGVyKGNlbGwgPT4gY2VsbC5pc0VsZW1lbnQoKSk7XG4gICAgICAgIGlmIChjaGlsZEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdmaXQtZW1iZWRzJywgb3B0KTtcblxuICAgICAgICBpZiAob3B0LmRlZXApIHtcbiAgICAgICAgICAgIC8vIGBvcHQuZGVlcCA9IHRydWVgIG1lYW5zIFwiZml0IHRvIGFsbCBkZXNjZW5kYW50c1wiLlxuICAgICAgICAgICAgLy8gQXMgdGhlIGZpcnN0IGFjdGlvbiBvZiB0aGUgZml0dGluZyBhbGdvcml0aG0sIHJlY3Vyc2l2ZWx5IGFwcGx5IGBmaXRUb0NoaWxkcmVuKClgIG9uIGFsbCBkZXNjZW5kYW50cy5cbiAgICAgICAgICAgIC8vIC0gaS5lLiB0aGUgYWxnb3JpdGhtIGlzIGFwcGxpZWQgaW4gcmV2ZXJzZS1kZXB0aCBvcmRlciAtIHN0YXJ0IGZyb20gZGVlcGVzdCBkZXNjZW5kYW50LCB0aGVuIGdvIHVwICg9IHRoaXMgZWxlbWVudCkuXG4gICAgICAgICAgICBpbnZva2UoY2hpbGRFbGVtZW50cywgJ2ZpdFRvQ2hpbGRyZW4nLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IG5ldyBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQsIGJhc2VkIG9uOlxuICAgICAgICAvLyAtIHVuaW9uIG9mIGJib3hlcyBvZiBhbGwgY2hpbGRyZW5cbiAgICAgICAgLy8gLSBpbmZsYXRlZCBieSBnaXZlbiBgb3B0LnBhZGRpbmdgXG4gICAgICAgIHRoaXMuX2ZpdFRvRWxlbWVudHMoT2JqZWN0LmFzc2lnbih7IGVsZW1lbnRzOiBjaGlsZEVsZW1lbnRzIH0sIG9wdCkpO1xuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdmaXQtZW1iZWRzJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpdFBhcmVudDogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB7IGdyYXBoIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWdyYXBoKSB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbXVzdCBiZSBwYXJ0IG9mIGEgZ3JhcGguJyk7XG5cbiAgICAgICAgLy8gV2hlbiBgb3B0LmRlZXAgPSB0cnVlYCwgd2Ugd2FudCBgb3B0LnRlcm1pbmF0b3JgIHRvIGJlIHRoZSBsYXN0IGFuY2VzdG9yIHByb2Nlc3NlZC5cbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBgb3B0LnRlcm1pbmF0b3JgLCBpdCBtZWFucyB0aGF0IHRoaXMgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCBhcyBwYXJlbnQgc28gd2UgY2FuIGV4aXQgbm93LlxuICAgICAgICBpZiAob3B0LmRlZXAgJiYgb3B0LnRlcm1pbmF0b3IgJiYgKChvcHQudGVybWluYXRvciA9PT0gdGhpcykgfHwgKG9wdC50ZXJtaW5hdG9yID09PSB0aGlzLmlkKSkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgaWYgKCFwYXJlbnRFbGVtZW50IHx8ICFwYXJlbnRFbGVtZW50LmlzRWxlbWVudCgpKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBHZXQgYWxsIGNoaWxkcmVuIG9mIHBhcmVudCBlbGVtZW50IChpLmUuIHRoaXMgZWxlbWVudCArIGFueSBzaWJsaW5nIGVsZW1lbnRzKS5cbiAgICAgICAgY29uc3Qgc2libGluZ0VsZW1lbnRzID0gcGFyZW50RWxlbWVudC5nZXRFbWJlZGRlZENlbGxzKCkuZmlsdGVyKGNlbGwgPT4gY2VsbC5pc0VsZW1lbnQoKSk7XG4gICAgICAgIGlmIChzaWJsaW5nRWxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ2ZpdC1wYXJlbnQnLCBvcHQpO1xuXG4gICAgICAgIC8vIFNldCBuZXcgc2l6ZSBhbmQgcG9zaXRpb24gb2YgcGFyZW50IGVsZW1lbnQsIGJhc2VkIG9uOlxuICAgICAgICAvLyAtIHVuaW9uIG9mIGJib3hlcyBvZiBhbGwgY2hpbGRyZW4gb2YgcGFyZW50IGVsZW1lbnQgKGkuZS4gdGhpcyBlbGVtZW50ICsgYW55IHNpYmxpbmcgZWxlbWVudHMpXG4gICAgICAgIC8vIC0gaW5mbGF0ZWQgYnkgZ2l2ZW4gYG9wdC5wYWRkaW5nYFxuICAgICAgICBwYXJlbnRFbGVtZW50Ll9maXRUb0VsZW1lbnRzKE9iamVjdC5hc3NpZ24oeyBlbGVtZW50czogc2libGluZ0VsZW1lbnRzIH0sIG9wdCkpO1xuXG4gICAgICAgIGlmIChvcHQuZGVlcCkge1xuICAgICAgICAgICAgLy8gYG9wdC5kZWVwID0gdHJ1ZWAgbWVhbnMgXCJmaXQgYWxsIGFuY2VzdG9ycyB0byB0aGVpciByZXNwZWN0aXZlIGNoaWxkcmVuXCIuXG4gICAgICAgICAgICAvLyBBcyB0aGUgbGFzdCBhY3Rpb24gb2YgdGhlIGZpdHRpbmcgYWxnb3JpdGhtLCByZWN1cnNpdmVseSBhcHBseSBgZml0UGFyZW50KClgIG9uIGFsbCBhbmNlc3RvcnMuXG4gICAgICAgICAgICAvLyAtIGkuZS4gdGhlIGFsZ29yaXRobSBpcyBhcHBsaWVkIGluIHJldmVyc2UtZGVwdGggb3JkZXIgLSBzdGFydCBmcm9tIGRlZXBlc3QgZGVzY2VuZGFudCAoPSB0aGlzIGVsZW1lbnQpLCB0aGVuIGdvIHVwLlxuICAgICAgICAgICAgcGFyZW50RWxlbWVudC5maXRQYXJlbnQob3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdmaXQtcGFyZW50Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFzc3VtcHRpb246IFRoaXMgZWxlbWVudCBpcyBwYXJ0IG9mIGEgZ3JhcGguXG4gICAgX2ZpdFRvRWxlbWVudHM6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgZWxlbWVudHNCQm94ID0gdGhpcy5ncmFwaC5nZXRDZWxsc0JCb3gob3B0LmVsZW1lbnRzKTtcbiAgICAgICAgLy8gSWYgbm8gYG9wdC5lbGVtZW50c2Agd2VyZSBwcm92aWRlZCwgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKCFlbGVtZW50c0JCb3gpIHJldHVybjtcblxuICAgICAgICBjb25zdCB7IGV4cGFuZE9ubHksIHNocmlua09ubHkgfSA9IG9wdDtcbiAgICAgICAgLy8gVGhpcyBjb21iaW5hdGlvbiBpcyBtZWFuaW5nbGVzcywgZG8gbm90aGluZy5cbiAgICAgICAgaWYgKGV4cGFuZE9ubHkgJiYgc2hyaW5rT25seSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50IGJhc2VkIG9uOlxuICAgICAgICAvLyAtIHVuaW9uIG9mIGJib3hlcyBvZiBgb3B0LmVsZW1lbnRzYFxuICAgICAgICAvLyAtIGluZmxhdGVkIGJ5IGBvcHQucGFkZGluZ2AgKGlmIG5vdCBwcm92aWRlZCwgYWxsIGZvdXIgcHJvcGVydGllcyA9IDApXG4gICAgICAgIGxldCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGVsZW1lbnRzQkJveDtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IG5vcm1hbGl6ZVNpZGVzKG9wdC5wYWRkaW5nKTtcbiAgICAgICAgeCAtPSBsZWZ0O1xuICAgICAgICB5IC09IHRvcDtcbiAgICAgICAgd2lkdGggKz0gbGVmdCArIHJpZ2h0O1xuICAgICAgICBoZWlnaHQgKz0gYm90dG9tICsgdG9wO1xuICAgICAgICBsZXQgcmVzdWx0QkJveCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmIChleHBhbmRPbmx5KSB7XG4gICAgICAgICAgICAvLyBOb24tc2hyaW5raW5nIGlzIGVuZm9yY2VkIGJ5IHRha2luZyB1bmlvbiBvZiB0aGlzIGVsZW1lbnQncyBjdXJyZW50IGJib3ggd2l0aCBiYm94IGNhbGN1bGF0ZWQgZnJvbSBgb3B0LmVsZW1lbnRzYC5cbiAgICAgICAgICAgIHJlc3VsdEJCb3ggPSB0aGlzLmdldEJCb3goKS51bmlvbihyZXN1bHRCQm94KTtcblxuICAgICAgICB9IGVsc2UgaWYgKHNocmlua09ubHkpIHtcbiAgICAgICAgICAgIC8vIE5vbi1leHBhbnNpb24gaXMgZW5mb3JjZWQgYnkgdGFraW5nIGludGVyc2VjdGlvbiBvZiB0aGlzIGVsZW1lbnQncyBjdXJyZW50IGJib3ggd2l0aCBiYm94IGNhbGN1bGF0ZWQgZnJvbSBgb3B0LmVsZW1lbnRzYC5cbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbkJCb3ggPSB0aGlzLmdldEJCb3goKS5pbnRlcnNlY3QocmVzdWx0QkJveCk7XG4gICAgICAgICAgICAvLyBJZiBhbGwgY2hpbGRyZW4gYXJlIG91dHNpZGUgdGhpcyBlbGVtZW50J3MgY3VycmVudCBiYm94LCB0aGVuIGBpbnRlcnNlY3Rpb25CQm94YCBpcyBgbnVsbGAgLSBkb2VzIG5vdCBtYWtlIHNlbnNlLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb25CQm94KSByZXR1cm47XG5cbiAgICAgICAgICAgIHJlc3VsdEJCb3ggPSAgaW50ZXJzZWN0aW9uQkJveDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgbmV3IHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgICAgcG9zaXRpb246IHsgeDogcmVzdWx0QkJveC54LCB5OiByZXN1bHRCQm94LnkgfSxcbiAgICAgICAgICAgIHNpemU6IHsgd2lkdGg6IHJlc3VsdEJCb3gud2lkdGgsIGhlaWdodDogcmVzdWx0QkJveC5oZWlnaHQgfVxuICAgICAgICB9LCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSb3RhdGUgZWxlbWVudCBieSBgYW5nbGVgIGRlZ3JlZXMsIG9wdGlvbmFsbHkgYXJvdW5kIGBvcmlnaW5gIHBvaW50LlxuICAgIC8vIElmIGBvcmlnaW5gIGlzIG5vdCBwcm92aWRlZCwgaXQgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50LlxuICAgIC8vIElmIGBhYnNvbHV0ZWAgaXMgYHRydWVgLCB0aGUgYGFuZ2xlYCBpcyBjb25zaWRlcmVkIGlzIGFic29sdXRlLCBpLmUuIGl0IGlzIG5vdFxuICAgIC8vIHRoZSBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzIGFuZ2xlLlxuICAgIHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGFic29sdXRlLCBvcmlnaW4sIG9wdCkge1xuXG4gICAgICAgIGlmIChvcmlnaW4pIHtcblxuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuZ2V0QkJveCgpLmNlbnRlcigpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldCgnc2l6ZScpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgICAgICAgICBjZW50ZXIucm90YXRlKG9yaWdpbiwgdGhpcy5nZXQoJ2FuZ2xlJykgLSBhbmdsZSk7XG4gICAgICAgICAgICB2YXIgZHggPSBjZW50ZXIueCAtIHNpemUud2lkdGggLyAyIC0gcG9zaXRpb24ueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbnRlci55IC0gc2l6ZS5oZWlnaHQgLyAyIC0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncm90YXRlJywgeyBhbmdsZTogYW5nbGUsIGFic29sdXRlOiBhYnNvbHV0ZSwgb3JpZ2luOiBvcmlnaW4gfSk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKHBvc2l0aW9uLnggKyBkeCwgcG9zaXRpb24ueSArIGR5LCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoYW5nbGUsIGFic29sdXRlLCBudWxsLCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3JvdGF0ZScpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0KCdhbmdsZScsIGFic29sdXRlID8gYW5nbGUgOiAodGhpcy5nZXQoJ2FuZ2xlJykgKyBhbmdsZSkgJSAzNjAsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUodGhpcy5nZXQoJ2FuZ2xlJykgfHwgMCk7XG4gICAgfSxcblxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgeyBncmFwaCwgYXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWVwLCByb3RhdGUgfSA9IG9wdDtcblxuICAgICAgICBpZiAoZGVlcCAmJiBncmFwaCkge1xuICAgICAgICAgICAgLy8gR2V0IGFsbCB0aGUgZW1iZWRkZWQgZWxlbWVudHMgdXNpbmcgYnJlYWR0aCBmaXJzdCBhbGdvcml0aG0uXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUsIGJyZWFkdGhGaXJzdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbW9kZWwgaXRzZWxmLlxuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBkZWZhdWx0IG9mIGdldENlbGxzQkJveCgpIGlzIHJvdGF0ZT10cnVlIGFuZCBjYW4ndCBiZVxuICAgICAgICAgICAgLy8gY2hhbmdlZCB3aXRob3V0IGEgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgICAgICByZXR1cm4gZ3JhcGguZ2V0Q2VsbHNCQm94KGVsZW1lbnRzLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBhbmdsZSA9IDAsIHBvc2l0aW9uOiB7IHgsIHkgfSwgc2l6ZTogeyB3aWR0aCwgaGVpZ2h0IH19ID0gYXR0cmlidXRlcztcbiAgICAgICAgY29uc3QgYmJveCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICBiYm94LnJvdGF0ZUFyb3VuZENlbnRlcihhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcblxuICAgIGdldFBvaW50RnJvbUNvbm5lY3RlZExpbms6IGZ1bmN0aW9uKGxpbmssIGVuZFR5cGUpIHtcbiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSBtb2RlbFxuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgICB2YXIgY2VudGVyID0gYmJveC5jZW50ZXIoKTtcbiAgICAgICAgLy8gQ2VudGVyIG9mIGEgcG9ydFxuICAgICAgICB2YXIgZW5kRGVmID0gbGluay5nZXQoZW5kVHlwZSk7XG4gICAgICAgIGlmICghZW5kRGVmKSByZXR1cm4gY2VudGVyO1xuICAgICAgICB2YXIgcG9ydElkID0gZW5kRGVmLnBvcnQ7XG4gICAgICAgIGlmICghcG9ydElkIHx8ICF0aGlzLmhhc1BvcnQocG9ydElkKSkgcmV0dXJuIGNlbnRlcjtcbiAgICAgICAgdmFyIHBvcnRHcm91cCA9IHRoaXMucG9ydFByb3AocG9ydElkLCBbJ2dyb3VwJ10pO1xuICAgICAgICB2YXIgcG9ydHNQb3NpdGlvbnMgPSB0aGlzLmdldFBvcnRzUG9zaXRpb25zKHBvcnRHcm91cCk7XG4gICAgICAgIHZhciBwb3J0Q2VudGVyID0gbmV3IFBvaW50KHBvcnRzUG9zaXRpb25zW3BvcnRJZF0pLm9mZnNldChiYm94Lm9yaWdpbigpKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZSgpO1xuICAgICAgICBpZiAoYW5nbGUpIHBvcnRDZW50ZXIucm90YXRlKGNlbnRlciwgLWFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHBvcnRDZW50ZXI7XG4gICAgfVxufSk7XG5cbmFzc2lnbihFbGVtZW50LnByb3RvdHlwZSwgZWxlbWVudFBvcnRQcm90b3R5cGUpO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/Element.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/ElementView.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ElementView.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ElementView: () => (/* binding */ ElementView)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _ports_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ports.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ports.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n\n\n\n\n\n\n\nconst Flags = {\n    TOOLS: _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Flags.TOOLS,\n    UPDATE: 'UPDATE',\n    TRANSLATE: 'TRANSLATE',\n    RESIZE: 'RESIZE',\n    PORTS: 'PORTS',\n    ROTATE: 'ROTATE',\n    RENDER: 'RENDER'\n};\n\nconst DragActions = {\n    MOVE: 'move',\n    MAGNET: 'magnet',\n};\n// Element base view and controller.\n// -------------------------------------------\n\nconst ElementView = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.extend({\n\n    /**\n     * @abstract\n     */\n    _removePorts: function() {\n        // implemented in ports.js\n    },\n\n    /**\n     *\n     * @abstract\n     */\n    _renderPorts: function() {\n        // implemented in ports.js\n    },\n\n    className: function() {\n\n        var classNames = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('element');\n\n        return classNames.join(' ');\n    },\n\n    initialize: function() {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.initialize.apply(this, arguments);\n\n        this._initializePorts();\n    },\n\n    presentationAttributes: {\n        'attrs': [Flags.UPDATE],\n        'position': [Flags.TRANSLATE, Flags.TOOLS],\n        'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n        'angle': [Flags.ROTATE, Flags.TOOLS],\n        'markup': [Flags.RENDER],\n        'ports': [Flags.PORTS],\n    },\n\n    initFlag: [Flags.RENDER],\n\n    UPDATE_PRIORITY: 0,\n\n    confirmUpdate: function(flag, opt) {\n\n        const { useCSSSelectors } = this;\n        if (this.hasFlag(flag, Flags.PORTS)) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, Flags.RENDER)) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n        } else {\n            let updateHighlighters = false;\n\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, Flags.RESIZE)) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n                if (useCSSSelectors) {\n                    // `resize()` rendered the ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.UPDATE)) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, Flags.UPDATE);\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.TRANSLATE)) {\n                this.translate();\n                flag = this.removeFlag(flag, Flags.TRANSLATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.ROTATE)) {\n                this.rotate();\n                flag = this.removeFlag(flag, Flags.ROTATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.PORTS)) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, Flags.PORTS);\n            }\n\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n\n        if (this.hasFlag(flag, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, Flags.TOOLS);\n        }\n\n        return flag;\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    update: function(_, renderingOnlyAttrs) {\n\n        this.cleanNodesCache();\n\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = this;\n        if (useCSSSelectors) this._removePorts();\n\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n        });\n\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n\n    rotatableSelector: 'rotatable',\n    scalableSelector: 'scalable',\n    scalableNode: null,\n    rotatableNode: null,\n\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n\n        var element = this.model;\n        var markup = element.get('markup') || element.markup;\n        if (!markup) throw new Error('dia.ElementView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.ElementView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        var vel = this.vel;\n        vel.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne('.rotatable');\n        this.scalableNode = vel.findOne('.scalable');\n\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n\n    render: function() {\n\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!this.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n\n    resize: function(opt) {\n\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n\n    translate: function() {\n\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n\n    rotate: function() {\n\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n\n    updateTransformation: function() {\n\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += ' ' + rotateString;\n        this.vel.attr('transform', transformation);\n    },\n\n    getTranslateString: function() {\n\n        const { x, y } = this.model.position();\n        return `translate(${x},${y})`;\n    },\n\n    getRotateString: function() {\n\n        const angle = this.model.angle();\n        if (!angle) return null;\n        const { width, height } = this.model.size();\n        return `rotate(${angle},${width / 2},${height / 2})`;\n    },\n\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n\n    rgRotate: function() {\n\n        this.rotatableNode.attr('transform', this.getRotateString());\n    },\n\n    rgTranslate: function() {\n\n        this.vel.attr('transform', this.getTranslateString());\n    },\n\n    sgResize: function(opt) {\n\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = (size.width / (scalableBBox.width || 1));\n        var sy = (size.height / (scalableBBox.height || 1));\n        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr('transform');\n        if (rotation) {\n\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign)({ updateHandled: true }, opt));\n            this.translate();\n            this.rotate();\n        }\n\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n\n    // Embedding mode methods.\n    // -----------------------\n\n    prepareEmbedding: function(data = {}) {\n\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n\n        const initialZIndices = data.initialZIndices = {};\n        const embeddedCells = element.getEmbeddedCells({ deep: true });\n        const connectedLinks = graph.getConnectedLinks(element, { deep: true, includeEnclosed: true });\n\n        // Note: an embedded cell can be a connect link, but it's fine\n        // to iterate over the cell twice.\n        [\n            element,\n            ...embeddedCells,\n            ...connectedLinks\n        ].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\n        element.startBatch('to-front');\n\n        // Bring the model to the front with all his embeds.\n        element.toFront({ deep: true, ui: true });\n\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        connectedLinks.forEach((link) => {\n            if (link.attributes.z <= maxZ) {\n                link.set('z', maxZ + 1, { ui: true });\n            }\n        });\n\n        element.stopBatch('to-front');\n\n        // Before we start looking for suitable parent we remove the current one.\n        const parentId = element.parent();\n        if (parentId) {\n            const parent = graph.getCell(parentId);\n            parent.unembed(element, { ui: true });\n            data.initialParentId = parentId;\n        } else {\n            data.initialParentId = null;\n        }\n    },\n\n    processEmbedding: function(data = {}, evt, x, y) {\n\n        const model = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;\n\n        let candidates;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(findParentBy)) {\n            candidates = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray)(findParentBy.call(graph, this, evt, x, y));\n        } else if (findParentBy === 'pointer') {\n            candidates = graph.findElementsAtPoint({ x, y });\n        } else {\n            candidates = graph.findElementsUnderElement(model, { searchBy: findParentBy });\n        }\n\n        candidates = candidates.filter((el) => {\n            return (el instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_4__.Cell) && (model.id !== el.id) && !el.isEmbeddedIn(model);\n        });\n\n        if (frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for (let i = candidates.length - 1; i >= 0; i--) {\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            } else {\n                const view = candidate.findView(paper);\n                if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(\n                newCandidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n        }\n\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n\n    clearEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n            data.candidateEmbedView = null;\n        }\n    },\n\n    finalizeEmbedding: function(data = {}) {\n\n        const candidateView = data.candidateEmbedView;\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n\n        if (candidateView) {\n\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(element, { ui: true });\n            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), { embedding: true });\n\n            data.candidateEmbedView = null;\n\n        } else {\n\n            const { validateUnembedding } = paper.options;\n            const { initialParentId } = data;\n            // The element was originally embedded into another element.\n            // The interaction would unembed the element. Let's validate\n            // if the element can be unembedded.\n            if (\n                initialParentId &&\n                typeof validateUnembedding === 'function' &&\n                !validateUnembedding.call(paper, this)\n            ) {\n                this._disallowUnembed(data);\n                return;\n            }\n        }\n\n        paper.model.getConnectedLinks(element, { deep: true }).forEach(link => {\n            link.reparent({ ui: true });\n        });\n    },\n\n    _disallowUnembed: function(data) {\n        const { model, whenNotAllowed = 'revert' } = data;\n        const element = model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        switch (whenNotAllowed) {\n            case 'remove': {\n                element.remove({ ui: true });\n                break;\n            }\n            case 'revert': {\n                const { initialParentId, initialPosition, initialZIndices } = data;\n                // Revert the element's position (and the position of its embedded cells if any)\n                if (initialPosition) {\n                    const { x, y } = initialPosition;\n                    element.position(x, y, { deep: true, ui: true });\n                }\n                // Revert all the z-indices changed during the embedding\n                if (initialZIndices) {\n                    Object.keys(initialZIndices).forEach(id => {\n                        const cell = graph.getCell(id);\n                        if (cell) {\n                            cell.set('z', initialZIndices[id], { ui: true });\n                        }\n                    });\n                }\n                // Revert the original parent\n                const parent = graph.getCell(initialParentId);\n                if (parent) {\n                    parent.embed(element, { ui: true });\n                }\n                break;\n            }\n        }\n    },\n\n    getTargetParentView: function(evt) {\n        const { candidateEmbedView = null } = this.eventData(evt);\n        return candidateEmbedView;\n    },\n\n    getDelegatedView: function() {\n\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n\n        while (view) {\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n\n        return null;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute('port', el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const proxyNode = this.findNode(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('element:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('element:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('element:pointerup', evt, x, y);\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('element:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('element:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('element:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointermove(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnet(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointerup(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointerup(evt, x, y);\n        }\n\n        if (targetMagnet) {\n            this.magnetpointerclick(evt, targetMagnet, x, y);\n        }\n\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('element:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('element:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('element:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('element:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('element:mousewheel', evt, x, y, delta);\n    },\n\n    onmagnet: function(evt, x, y) {\n\n        const { currentTarget: targetMagnet } = evt;\n        this.magnetpointerdown(evt, targetMagnet, x, y);\n        this.eventData(evt, { targetMagnet });\n        this.dragMagnetStart(evt, x, y);\n    },\n\n    magnetpointerdown: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n    },\n\n    magnetpointermove: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointermove', evt, magnet, x, y);\n    },\n\n    magnetpointerup: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerup', evt, magnet, x, y);\n    },\n\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n    },\n\n    magnetcontextmenu: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n    },\n\n    // Drag Start Handlers\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        var view = this.getDelegatedView();\n        if (!view || !view.can('elementMove')) return;\n\n        this.eventData(evt, {\n            action: DragActions.MOVE,\n            delegatedView: view\n        });\n\n        const position = view.model.position();\n        view.eventData(evt, {\n            initialPosition: position,\n            pointerOffset: position.difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n\n    dragMagnetStart: function(evt, x, y) {\n\n        const { paper } = this;\n        const isPropagationAlreadyStopped = evt.isPropagationStopped();\n        if (isPropagationAlreadyStopped) {\n            // Special case when the propagation was already stopped\n            // on the `element:magnet:pointerdown` event.\n            // Do not trigger any `element:pointer*` events\n            // but still start the magnet dragging.\n            this.eventData(evt, { preventPointerEvents: true });\n        }\n\n        if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n            // Stop the default action, which is to start dragging a link.\n            return;\n        }\n\n        const { targetMagnet = evt.currentTarget } = this.eventData(evt);\n        evt.stopPropagation();\n\n        // Invalid (Passive) magnet. Start dragging the element.\n        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n            if (isPropagationAlreadyStopped) {\n                // Do not trigger `element:pointerdown` and start element dragging\n                // if the propagation was stopped.\n                this.dragStart(evt, x, y);\n                // The `element:pointerdown` event is not triggered because\n                // of `preventPointerEvents` flag.\n            } else {\n                // We need to reset the action\n                // to `MOVE` so that the element is dragged.\n                this.pointerdown(evt, x, y);\n            }\n            return;\n        }\n\n        // Valid magnet. Start dragging a link.\n        if (paper.options.magnetThreshold <= 0) {\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n        this.eventData(evt, { action: DragActions.MAGNET });\n    },\n\n    // Drag Handlers\n\n    snapToGrid: function(evt, x, y) {\n        const grid = this.paper.options.gridSize;\n        return {\n            x: (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.snapToGrid)(x, grid),\n            y: (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.snapToGrid)(y, grid)\n        };\n    },\n\n    drag: function(evt, x, y) {\n\n        var paper = this.paper;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n\n        // Make sure the new element's position always snaps to the current grid\n        const { x: elX, y: elY } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);\n\n        element.position(elX, elY, { restrictedArea, deep: true, ui: true });\n\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data, evt, x, y);\n        }\n\n        this.eventData(evt, {\n            embedding\n        });\n    },\n\n    dragMagnet: function(evt, x, y) {\n        this.dragLink(evt, x, y);\n    },\n\n    // Drag End Handlers\n\n    dragEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n\n    dragMagnetEnd: function(evt, x, y) {\n        this.dragLinkEnd(evt, x, y);\n    },\n\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\n(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign)(ElementView.prototype, _ports_mjs__WEBPACK_IMPORTED_MODULE_6__.elementViewPortPrototype);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9FbGVtZW50Vmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBZ0U7QUFDdEI7QUFDUjtBQUNIO0FBQ3dCO0FBQ0w7O0FBRWxEO0FBQ0EsV0FBVyxtREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sb0JBQW9CLG1EQUFROztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLHlCQUF5QixtREFBUTs7QUFFakM7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBLFFBQVEsbURBQVE7O0FBRWhCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7O0FBRUE7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Q2hCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsUUFBUSxtREFBUTtBQUNoQixLQUFLOztBQUVMOztBQUVBLFFBQVEsbURBQVE7QUFDaEI7QUFDQSxLQUFLOztBQUVMOztBQUVBLFFBQVEsbURBQVE7QUFDaEI7QUFDQSxLQUFLOztBQUVMOztBQUVBLFFBQVEsbURBQVE7QUFDaEI7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsZ0JBQWdCLHNDQUFzQzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsZ0JBQWdCLHNDQUFzQzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxRQUFRLG1EQUFRO0FBQ2hCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxRQUFRLG1EQUFRO0FBQ2hCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxRQUFRLG1EQUFRO0FBQ2hCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxRQUFRLG1EQUFRO0FBQ2hCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxRQUFRLG1EQUFRO0FBQ2hCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBVTtBQUN6QixlQUFlLHdEQUFVO0FBQ3pCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQzs7QUFFekQ7QUFDQSxnQkFBZ0IsaUJBQWlCOztBQUVqQyxxQ0FBcUMsc0NBQXNDOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQzs7QUFFRCx1REFBTSx3QkFBd0IsZ0VBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0VsZW1lbnRWaWV3Lm1qcz8wMTc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2lnbiwgaXNGdW5jdGlvbiwgdG9BcnJheSB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IENlbGxWaWV3IH0gZnJvbSAnLi9DZWxsVmlldy5tanMnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgZWxlbWVudFZpZXdQb3J0UHJvdG90eXBlIH0gZnJvbSAnLi9wb3J0cy5tanMnO1xuaW1wb3J0IHsgUmVjdCwgc25hcFRvR3JpZCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgRmxhZ3MgPSB7XG4gICAgVE9PTFM6IENlbGxWaWV3LkZsYWdzLlRPT0xTLFxuICAgIFVQREFURTogJ1VQREFURScsXG4gICAgVFJBTlNMQVRFOiAnVFJBTlNMQVRFJyxcbiAgICBSRVNJWkU6ICdSRVNJWkUnLFxuICAgIFBPUlRTOiAnUE9SVFMnLFxuICAgIFJPVEFURTogJ1JPVEFURScsXG4gICAgUkVOREVSOiAnUkVOREVSJ1xufTtcblxuY29uc3QgRHJhZ0FjdGlvbnMgPSB7XG4gICAgTU9WRTogJ21vdmUnLFxuICAgIE1BR05FVDogJ21hZ25ldCcsXG59O1xuLy8gRWxlbWVudCBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBFbGVtZW50VmlldyA9IENlbGxWaWV3LmV4dGVuZCh7XG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfcmVtb3ZlUG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpbXBsZW1lbnRlZCBpbiBwb3J0cy5qc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9yZW5kZXJQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGluIHBvcnRzLmpzXG4gICAgfSxcblxuICAgIGNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBDZWxsVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lLmFwcGx5KHRoaXMpLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdlbGVtZW50Jyk7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQb3J0cygpO1xuICAgIH0sXG5cbiAgICBwcmVzZW50YXRpb25BdHRyaWJ1dGVzOiB7XG4gICAgICAgICdhdHRycyc6IFtGbGFncy5VUERBVEVdLFxuICAgICAgICAncG9zaXRpb24nOiBbRmxhZ3MuVFJBTlNMQVRFLCBGbGFncy5UT09MU10sXG4gICAgICAgICdzaXplJzogW0ZsYWdzLlJFU0laRSwgRmxhZ3MuUE9SVFMsIEZsYWdzLlRPT0xTXSxcbiAgICAgICAgJ2FuZ2xlJzogW0ZsYWdzLlJPVEFURSwgRmxhZ3MuVE9PTFNdLFxuICAgICAgICAnbWFya3VwJzogW0ZsYWdzLlJFTkRFUl0sXG4gICAgICAgICdwb3J0cyc6IFtGbGFncy5QT1JUU10sXG4gICAgfSxcblxuICAgIGluaXRGbGFnOiBbRmxhZ3MuUkVOREVSXSxcblxuICAgIFVQREFURV9QUklPUklUWTogMCxcblxuICAgIGNvbmZpcm1VcGRhdGU6IGZ1bmN0aW9uKGZsYWcsIG9wdCkge1xuXG4gICAgICAgIGNvbnN0IHsgdXNlQ1NTU2VsZWN0b3JzIH0gPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUG9ydHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFuUG9ydHNDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFuc2Zvcm1IaWdobGlnaHRlcnMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFnLCBGbGFncy5SRU5ERVIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29scyhvcHQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHRlcnModHJ1ZSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1IaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgZmxhZyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFnLCBbRmxhZ3MuUkVOREVSLCBGbGFncy5VUERBVEUsIEZsYWdzLlJFU0laRSwgRmxhZ3MuVFJBTlNMQVRFLCBGbGFncy5ST1RBVEUsIEZsYWdzLlBPUlRTLCBGbGFncy5UT09MU10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHVwZGF0ZUhpZ2hsaWdodGVycyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBTa2lwIHRoaXMgYnJhbmNoIGlmIHJlbmRlciBpcyByZXF1aXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFnLCBGbGFncy5SRVNJWkUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUob3B0KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFJlc2l6ZSBtZXRob2QgaXMgY2FsbGluZyBgdXBkYXRlKClgIGludGVybmFsbHlcbiAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIFtGbGFncy5SRVNJWkUsIEZsYWdzLlVQREFURV0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VDU1NTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHJlc2l6ZSgpYCByZW5kZXJlZCB0aGUgcG9ydHMgd2hlbiB1c2VDU1NTZWxlY3RvcnMgYXJlIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFnLCBGbGFncy5QT1JUUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFnLCBGbGFncy5VUERBVEUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5tb2RlbCwgbnVsbCwgb3B0KTtcbiAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlVQREFURSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodXNlQ1NTU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGB1cGRhdGUoKWAgd2lsbCByZW5kZXIgcG9ydHMgd2hlbiB1c2VDU1NTZWxlY3RvcnMgYXJlIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFnLCBGbGFncy5QT1JUUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFnLCBGbGFncy5UUkFOU0xBVEUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlRSQU5TTEFURSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuUk9UQVRFKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlKCk7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFnLCBGbGFncy5ST1RBVEUpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUhpZ2hsaWdodGVycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclBvcnRzKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVwZGF0ZUhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0ZXJzKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1IaWdobGlnaHRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtSGlnaGxpZ2h0ZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlRPT0xTKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29scyhvcHQpO1xuICAgICAgICAgICAgZmxhZyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFnLCBGbGFncy5UT09MUyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX2luaXRpYWxpemVQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGluIHBvcnRzLmpzXG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oXywgcmVuZGVyaW5nT25seUF0dHJzKSB7XG5cbiAgICAgICAgdGhpcy5jbGVhbk5vZGVzQ2FjaGUoKTtcblxuICAgICAgICAvLyBXaGVuIENTUyBzZWxlY3RvciBzdHJpbmdzIGFyZSB1c2VkLCBtYWtlIHN1cmUgbm8gcnVsZSBtYXRjaGVzIHBvcnQgbm9kZXMuXG4gICAgICAgIGNvbnN0IHsgdXNlQ1NTU2VsZWN0b3JzIH0gPSB0aGlzO1xuICAgICAgICBpZiAodXNlQ1NTU2VsZWN0b3JzKSB0aGlzLl9yZW1vdmVQb3J0cygpO1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBtb2RlbEF0dHJzID0gbW9kZWwuYXR0cigpO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKHRoaXMuZWwsIG1vZGVsQXR0cnMsIHtcbiAgICAgICAgICAgIHJvb3RCQm94OiBuZXcgUmVjdChtb2RlbC5zaXplKCkpLFxuICAgICAgICAgICAgc2VsZWN0b3JzOiB0aGlzLnNlbGVjdG9ycyxcbiAgICAgICAgICAgIHNjYWxhYmxlTm9kZTogdGhpcy5zY2FsYWJsZU5vZGUsXG4gICAgICAgICAgICByb3RhdGFibGVOb2RlOiB0aGlzLnJvdGF0YWJsZU5vZGUsXG4gICAgICAgICAgICAvLyBVc2UgcmVuZGVyaW5nIG9ubHkgYXR0cmlidXRlcyBpZiB0aGV5IGRpZmZlcnMgZnJvbSB0aGUgbW9kZWwgYXR0cmlidXRlc1xuICAgICAgICAgICAgcm9BdHRyaWJ1dGVzOiAocmVuZGVyaW5nT25seUF0dHJzID09PSBtb2RlbEF0dHJzKSA/IG51bGwgOiByZW5kZXJpbmdPbmx5QXR0cnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHVzZUNTU1NlbGVjdG9ycykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUG9ydHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByb3RhdGFibGVTZWxlY3RvcjogJ3JvdGF0YWJsZScsXG4gICAgc2NhbGFibGVTZWxlY3RvcjogJ3NjYWxhYmxlJyxcbiAgICBzY2FsYWJsZU5vZGU6IG51bGwsXG4gICAgcm90YXRhYmxlTm9kZTogbnVsbCxcblxuICAgIC8vIGBwcm90b3R5cGUubWFya3VwYCBpcyByZW5kZXJlZCBieSBkZWZhdWx0LiBTZXQgdGhlIGBtYXJrdXBgIGF0dHJpYnV0ZSBvbiB0aGUgbW9kZWwgaWYgdGhlXG4gICAgLy8gZGVmYXVsdCBtYXJrdXAgaXMgbm90IGRlc2lyYWJsZS5cbiAgICByZW5kZXJNYXJrdXA6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG1hcmt1cCA9IGVsZW1lbnQuZ2V0KCdtYXJrdXAnKSB8fCBlbGVtZW50Lm1hcmt1cDtcbiAgICAgICAgaWYgKCFtYXJrdXApIHRocm93IG5ldyBFcnJvcignZGlhLkVsZW1lbnRWaWV3OiBtYXJrdXAgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFya3VwKSkgcmV0dXJuIHRoaXMucmVuZGVySlNPTk1hcmt1cChtYXJrdXApO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLnJlbmRlclN0cmluZ01hcmt1cChtYXJrdXApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5FbGVtZW50VmlldzogaW52YWxpZCBtYXJrdXAnKTtcbiAgICB9LFxuXG4gICAgcmVuZGVySlNPTk1hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMucGFyc2VET01KU09OKG1hcmt1cCwgdGhpcy5lbCk7XG4gICAgICAgIHZhciBzZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9ycyA9IGRvYy5zZWxlY3RvcnM7XG4gICAgICAgIHRoaXMucm90YXRhYmxlTm9kZSA9IFYoc2VsZWN0b3JzW3RoaXMucm90YXRhYmxlU2VsZWN0b3JdKSB8fCBudWxsO1xuICAgICAgICB0aGlzLnNjYWxhYmxlTm9kZSA9IFYoc2VsZWN0b3JzW3RoaXMuc2NhbGFibGVTZWxlY3Rvcl0pIHx8IG51bGw7XG4gICAgICAgIC8vIEZyYWdtZW50XG4gICAgICAgIHRoaXMudmVsLmFwcGVuZChkb2MuZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICByZW5kZXJTdHJpbmdNYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIHZhciB2ZWwgPSB0aGlzLnZlbDtcbiAgICAgICAgdmVsLmFwcGVuZChWKG1hcmt1cCkpO1xuICAgICAgICAvLyBDYWNoZSB0cmFuc2Zvcm1hdGlvbiBncm91cHNcbiAgICAgICAgdGhpcy5yb3RhdGFibGVOb2RlID0gdmVsLmZpbmRPbmUoJy5yb3RhdGFibGUnKTtcbiAgICAgICAgdGhpcy5zY2FsYWJsZU5vZGUgPSB2ZWwuZmluZE9uZSgnLnNjYWxhYmxlJyk7XG5cbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IHRoaXMuc2VsZWN0b3JzID0ge307XG4gICAgICAgIHNlbGVjdG9yc1t0aGlzLnNlbGVjdG9yXSA9IHRoaXMuZWw7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy52ZWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXJrdXAoKTtcbiAgICAgICAgaWYgKHRoaXMuc2NhbGFibGVOb2RlKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgdXBkYXRlIGlzIG5lY2Vzc2FyeSBmb3IgZWxlbWVudHMgd2l0aCB0aGUgc2NhbGFibGUgZ3JvdXAgb25seVxuICAgICAgICAgICAgLy8gTm90ZSB0aGUgcmVzaXplKCkgdHJpZ2dlcnMgdGhlIG90aGVyIGB1cGRhdGVgLlxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5yb3RhdGFibGVOb2RlKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCBvbiBgdGhpcy5lbGAgd2hpbGUgdGhlIHJvdGF0aW9uIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBvbiBgdGhpcy5yb3RhdGFibGVOb2RlYFxuICAgICAgICAgICAgdGhpcy5yb3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnVzZUNTU1NlbGVjdG9ycykgdGhpcy5fcmVuZGVyUG9ydHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2NhbGFibGVOb2RlKSByZXR1cm4gdGhpcy5zZ1Jlc2l6ZShvcHQpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5hdHRyaWJ1dGVzLmFuZ2xlKSB0aGlzLnJvdGF0ZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnJvdGF0YWJsZU5vZGUpIHJldHVybiB0aGlzLnJnVHJhbnNsYXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtYXRpb24oKTtcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5yb3RhdGFibGVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJnUm90YXRlKCk7XG4gICAgICAgICAgICAvLyBJdCdzIG5lY2Vzc2FyeSB0byBjYWxsIHRoZSB1cGRhdGUgZm9yIHRoZSBub2RlcyBvdXRzaWRlXG4gICAgICAgICAgICAvLyB0aGUgcm90YXRhYmxlIGdyb3VwIHJlZmVyZW5jaW5nIG5vZGVzIGluc2lkZSB0aGUgZ3JvdXBcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1hdGlvbigpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVUcmFuc2Zvcm1hdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uID0gdGhpcy5nZXRUcmFuc2xhdGVTdHJpbmcoKTtcbiAgICAgICAgdmFyIHJvdGF0ZVN0cmluZyA9IHRoaXMuZ2V0Um90YXRlU3RyaW5nKCk7XG4gICAgICAgIGlmIChyb3RhdGVTdHJpbmcpIHRyYW5zZm9ybWF0aW9uICs9ICcgJyArIHJvdGF0ZVN0cmluZztcbiAgICAgICAgdGhpcy52ZWwuYXR0cigndHJhbnNmb3JtJywgdHJhbnNmb3JtYXRpb24pO1xuICAgIH0sXG5cbiAgICBnZXRUcmFuc2xhdGVTdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5tb2RlbC5wb3NpdGlvbigpO1xuICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYDtcbiAgICB9LFxuXG4gICAgZ2V0Um90YXRlU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCBhbmdsZSA9IHRoaXMubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKCFhbmdsZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5tb2RlbC5zaXplKCk7XG4gICAgICAgIHJldHVybiBgcm90YXRlKCR7YW5nbGV9LCR7d2lkdGggLyAyfSwke2hlaWdodCAvIDJ9KWA7XG4gICAgfSxcblxuICAgIC8vIFJvdGF0YWJsZSAmIFNjYWxhYmxlIEdyb3VwXG4gICAgLy8gYWx3YXlzIHNsb3dlciwga2VwdCBtYWlubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgICByZ1JvdGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5yb3RhdGFibGVOb2RlLmF0dHIoJ3RyYW5zZm9ybScsIHRoaXMuZ2V0Um90YXRlU3RyaW5nKCkpO1xuICAgIH0sXG5cbiAgICByZ1RyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy52ZWwuYXR0cigndHJhbnNmb3JtJywgdGhpcy5nZXRUcmFuc2xhdGVTdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIHNnUmVzaXplOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgYW5nbGUgPSBtb2RlbC5hbmdsZSgpO1xuICAgICAgICB2YXIgc2l6ZSA9IG1vZGVsLnNpemUoKTtcbiAgICAgICAgdmFyIHNjYWxhYmxlID0gdGhpcy5zY2FsYWJsZU5vZGU7XG5cbiAgICAgICAgLy8gR2V0dGluZyBzY2FsYWJsZSBncm91cCdzIGJib3guXG4gICAgICAgIC8vIER1ZSB0byBhIGJ1ZyBpbiB3ZWJraXQncyBuYXRpdmUgU1ZHIC5nZXRCQm94IGltcGxlbWVudGF0aW9uLCB0aGUgYmJveCBvZiBncm91cHMgd2l0aCBwYXRoIGNoaWxkcmVuIGluY2x1ZGVzIHRoZSBwYXRocycgY29udHJvbCBwb2ludHMuXG4gICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZSwgd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcGF0aCBlbGVtZW50cyBpbnNpZGUgdGhlIHNjYWxhYmxlIGdyb3VwLlxuICAgICAgICB2YXIgcmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChzY2FsYWJsZS5ub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXRoJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSWYgc2NhbGFibGUgaGFzIGF0IGxlYXN0IG9uZSBkZXNjZW5kYW50IHRoYXQgaXMgYSBwYXRoLCB3ZSBuZWVkIHRvIHN3aXRjaCB0byByZWN1cnNpdmUgYmJveCBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXRoIGRlc2NlbmRhbnRzLCBncm91cCBiYm94IGNhbGN1bGF0aW9uIHdvcmtzIGFuZCBzbyB3ZSBjYW4gdXNlIHRoZSAoZmFzdGVyKSBuYXRpdmUgZnVuY3Rpb24gZGlyZWN0bHkuXG4gICAgICAgICAgICByZWN1cnNpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2FsYWJsZUJCb3ggPSBzY2FsYWJsZS5nZXRCQm94KHsgcmVjdXJzaXZlOiByZWN1cnNpdmUgfSk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIGBzY2FsYWJsZUJib3gud2lkdGhgIGFuZCBgc2NhbGFibGVCYm94LmhlaWdodGAgYXJlIG5vdCB6ZXJvIHdoaWNoIGNhbiBoYXBwZW4gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbnkgY29udGVudC4gQnkgbWFraW5nXG4gICAgICAgIC8vIHRoZSB3aWR0aC9oZWlnaHQgMSwgd2UgcHJldmVudCBIVE1MIGVycm9ycyBvZiB0aGUgdHlwZSBgc2NhbGUoSW5maW5pdHksIEluZmluaXR5KWAuXG4gICAgICAgIHZhciBzeCA9IChzaXplLndpZHRoIC8gKHNjYWxhYmxlQkJveC53aWR0aCB8fCAxKSk7XG4gICAgICAgIHZhciBzeSA9IChzaXplLmhlaWdodCAvIChzY2FsYWJsZUJCb3guaGVpZ2h0IHx8IDEpKTtcbiAgICAgICAgc2NhbGFibGUuYXR0cigndHJhbnNmb3JtJywgJ3NjYWxlKCcgKyBzeCArICcsJyArIHN5ICsgJyknKTtcblxuICAgICAgICAvLyBOb3cgdGhlIGludGVyZXN0aW5nIHBhcnQuIFRoZSBnb2FsIGlzIHRvIGJlIGFibGUgdG8gc3RvcmUgdGhlIG9iamVjdCBnZW9tZXRyeSB2aWEganVzdCBgeGAsIGB5YCwgYGFuZ2xlYCwgYHdpZHRoYCBhbmQgYGhlaWdodGBcbiAgICAgICAgLy8gT3JkZXIgb2YgdHJhbnNmb3JtYXRpb25zIGlzIHNpZ25pZmljYW50IGJ1dCB3ZSB3YW50IHRvIHJlY29uc3RydWN0IHRoZSBvYmplY3QgYWx3YXlzIGluIHRoZSBvcmRlcjpcbiAgICAgICAgLy8gcmVzaXplKCksIHJvdGF0ZSgpLCB0cmFuc2xhdGUoKSBubyBtYXR0ZXIgb2YgaG93IHRoZSBvYmplY3Qgd2FzIHRyYW5zZm9ybWVkLiBGb3IgdGhhdCB0byB3b3JrLFxuICAgICAgICAvLyB3ZSBtdXN0IGFkanVzdCB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgb2YgdGhlIG9iamVjdCB3aGVuZXZlciB3ZSByZXNpemUgaXQgKGJlY2F1c2UgdGhlIG9yaWdpbiBvZiB0aGVcbiAgICAgICAgLy8gcm90YXRpb24gY2hhbmdlcykuIFRoZSBuZXcgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgYXJlIGNvbXB1dGVkIGJ5IGNhbmNlbGluZyB0aGUgcHJldmlvdXMgcm90YXRpb25cbiAgICAgICAgLy8gYXJvdW5kIHRoZSBjZW50ZXIgb2YgdGhlIHJlc2l6ZWQgb2JqZWN0ICh3aGljaCBpcyBhIGRpZmZlcmVudCBvcmlnaW4gdGhlbiB0aGUgb3JpZ2luIG9mIHRoZSBwcmV2aW91cyByb3RhdGlvbilcbiAgICAgICAgLy8gYW5kIGdldHRpbmcgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC4gVGhlbiB3ZSBjbGVhbiB1cCB0aGUgcm90YXRpb24gYmFjayB0byB3aGF0IGl0IG9yaWdpbmFsbHkgd2FzLlxuXG4gICAgICAgIC8vIENhbmNlbCB0aGUgcm90YXRpb24gYnV0IG5vdyBhcm91bmQgYSBkaWZmZXJlbnQgb3JpZ2luLCB3aGljaCBpcyB0aGUgY2VudGVyIG9mIHRoZSBzY2FsZWQgb2JqZWN0LlxuICAgICAgICB2YXIgcm90YXRhYmxlID0gdGhpcy5yb3RhdGFibGVOb2RlO1xuICAgICAgICB2YXIgcm90YXRpb24gPSByb3RhdGFibGUgJiYgcm90YXRhYmxlLmF0dHIoJ3RyYW5zZm9ybScpO1xuICAgICAgICBpZiAocm90YXRpb24pIHtcblxuICAgICAgICAgICAgcm90YXRhYmxlLmF0dHIoJ3RyYW5zZm9ybScsIHJvdGF0aW9uICsgJyByb3RhdGUoJyArICgtYW5nbGUpICsgJywnICsgKHNpemUud2lkdGggLyAyKSArICcsJyArIChzaXplLmhlaWdodCAvIDIpICsgJyknKTtcbiAgICAgICAgICAgIHZhciByb3RhdGFibGVCQm94ID0gc2NhbGFibGUuZ2V0QkJveCh7IHRhcmdldDogdGhpcy5wYXBlci5jZWxscyB9KTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgbmV3IHgsIHkgYW5kIHBlcmZvcm0gcm90YXRlKCkgYWdhaW4gYWdhaW5zdCB0aGUgbmV3IHJvdGF0aW9uIG9yaWdpbi5cbiAgICAgICAgICAgIG1vZGVsLnNldCgncG9zaXRpb24nLCB7IHg6IHJvdGF0YWJsZUJCb3gueCwgeTogcm90YXRhYmxlQkJveC55IH0sIGFzc2lnbih7IHVwZGF0ZUhhbmRsZWQ6IHRydWUgfSwgb3B0KSk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yb3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBtdXN0IGFsd2F5cyBiZSBjYWxsZWQgb24gbm9uLXJvdGF0ZWQgZWxlbWVudC4gT3RoZXJ3aXNlLCByZWxhdGl2ZSBwb3NpdGlvbmluZ1xuICAgICAgICAvLyB3b3VsZCB3b3JrIHdpdGggd3JvbmcgKHJvdGF0ZWQpIGJvdW5kaW5nIGJveGVzLlxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBFbWJlZGRpbmcgbW9kZSBtZXRob2RzLlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBwcmVwYXJlRW1iZWRkaW5nOiBmdW5jdGlvbihkYXRhID0ge30pIHtcblxuICAgICAgICBjb25zdCBlbGVtZW50ID0gZGF0YS5tb2RlbCB8fCB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCBwYXBlciA9IGRhdGEucGFwZXIgfHwgdGhpcy5wYXBlcjtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBwYXBlci5tb2RlbDtcblxuICAgICAgICBjb25zdCBpbml0aWFsWkluZGljZXMgPSBkYXRhLmluaXRpYWxaSW5kaWNlcyA9IHt9O1xuICAgICAgICBjb25zdCBlbWJlZGRlZENlbGxzID0gZWxlbWVudC5nZXRFbWJlZGRlZENlbGxzKHsgZGVlcDogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgY29ubmVjdGVkTGlua3MgPSBncmFwaC5nZXRDb25uZWN0ZWRMaW5rcyhlbGVtZW50LCB7IGRlZXA6IHRydWUsIGluY2x1ZGVFbmNsb3NlZDogdHJ1ZSB9KTtcblxuICAgICAgICAvLyBOb3RlOiBhbiBlbWJlZGRlZCBjZWxsIGNhbiBiZSBhIGNvbm5lY3QgbGluaywgYnV0IGl0J3MgZmluZVxuICAgICAgICAvLyB0byBpdGVyYXRlIG92ZXIgdGhlIGNlbGwgdHdpY2UuXG4gICAgICAgIFtcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAuLi5lbWJlZGRlZENlbGxzLFxuICAgICAgICAgICAgLi4uY29ubmVjdGVkTGlua3NcbiAgICAgICAgXS5mb3JFYWNoKGNlbGwgPT4gaW5pdGlhbFpJbmRpY2VzW2NlbGwuaWRdID0gY2VsbC5hdHRyaWJ1dGVzLnopO1xuXG4gICAgICAgIGVsZW1lbnQuc3RhcnRCYXRjaCgndG8tZnJvbnQnKTtcblxuICAgICAgICAvLyBCcmluZyB0aGUgbW9kZWwgdG8gdGhlIGZyb250IHdpdGggYWxsIGhpcyBlbWJlZHMuXG4gICAgICAgIGVsZW1lbnQudG9Gcm9udCh7IGRlZXA6IHRydWUsIHVpOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBhdCB0aGlzIHBvaW50IGNlbGxzIGluIHRoZSBjb2xsZWN0aW9uIGFyZSBub3Qgc29ydGVkIGJ5IHogaW5kZXggKGl0J3MgcnVubmluZyBpbiB0aGUgYmF0Y2gsIHNlZVxuICAgICAgICAvLyB0aGUgZGlhLkdyYXBoLl9zb3J0T25DaGFuZ2VaKSwgc28gd2UgY2FuJ3QgYXNzdW1lIHRoYXQgdGhlIGxhc3QgY2VsbCBpbiB0aGUgY29sbGVjdGlvbiBoYXMgdGhlIGhpZ2hlc3Qgei5cbiAgICAgICAgY29uc3QgbWF4WiA9IGdyYXBoLmdldEVsZW1lbnRzKCkucmVkdWNlKChtYXgsIGNlbGwpID0+IE1hdGgubWF4KG1heCwgY2VsbC5hdHRyaWJ1dGVzLnogfHwgMCksIDApO1xuXG4gICAgICAgIC8vIE1vdmUgdG8gZnJvbnQgYWxzbyBhbGwgdGhlIGluYm91bmQgYW5kIG91dGJvdW5kIGxpbmtzIHRoYXQgYXJlIGNvbm5lY3RlZFxuICAgICAgICAvLyB0byBhbnkgb2YgdGhlIGVsZW1lbnQgZGVzY2VuZGFudC4gSWYgd2UgYnJpbmcgdG8gZnJvbnQgb25seSBlbWJlZGRlZCBlbGVtZW50cyxcbiAgICAgICAgLy8gbGlua3MgY29ubmVjdGVkIHRvIHRoZW0gd291bGQgc3RheSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICAgICAgY29ubmVjdGVkTGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgaWYgKGxpbmsuYXR0cmlidXRlcy56IDw9IG1heFopIHtcbiAgICAgICAgICAgICAgICBsaW5rLnNldCgneicsIG1heFogKyAxLCB7IHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBlbGVtZW50LnN0b3BCYXRjaCgndG8tZnJvbnQnKTtcblxuICAgICAgICAvLyBCZWZvcmUgd2Ugc3RhcnQgbG9va2luZyBmb3Igc3VpdGFibGUgcGFyZW50IHdlIHJlbW92ZSB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgIGNvbnN0IHBhcmVudElkID0gZWxlbWVudC5wYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudElkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBncmFwaC5nZXRDZWxsKHBhcmVudElkKTtcbiAgICAgICAgICAgIHBhcmVudC51bmVtYmVkKGVsZW1lbnQsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICBkYXRhLmluaXRpYWxQYXJlbnRJZCA9IHBhcmVudElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5pbml0aWFsUGFyZW50SWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHByb2Nlc3NFbWJlZGRpbmc6IGZ1bmN0aW9uKGRhdGEgPSB7fSwgZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSBkYXRhLm1vZGVsIHx8IHRoaXMubW9kZWw7XG4gICAgICAgIGNvbnN0IHBhcGVyID0gZGF0YS5wYXBlciB8fCB0aGlzLnBhcGVyO1xuICAgICAgICBjb25zdCBncmFwaCA9IHBhcGVyLm1vZGVsO1xuICAgICAgICBjb25zdCB7IGZpbmRQYXJlbnRCeSwgZnJvbnRQYXJlbnRPbmx5LCB2YWxpZGF0ZUVtYmVkZGluZyB9ID0gcGFwZXIub3B0aW9ucztcblxuICAgICAgICBsZXQgY2FuZGlkYXRlcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZmluZFBhcmVudEJ5KSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRvQXJyYXkoZmluZFBhcmVudEJ5LmNhbGwoZ3JhcGgsIHRoaXMsIGV2dCwgeCwgeSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbmRQYXJlbnRCeSA9PT0gJ3BvaW50ZXInKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gZ3JhcGguZmluZEVsZW1lbnRzQXRQb2ludCh7IHgsIHkgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gZ3JhcGguZmluZEVsZW1lbnRzVW5kZXJFbGVtZW50KG1vZGVsLCB7IHNlYXJjaEJ5OiBmaW5kUGFyZW50QnkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoKGVsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGVsIGluc3RhbmNlb2YgQ2VsbCkgJiYgKG1vZGVsLmlkICE9PSBlbC5pZCkgJiYgIWVsLmlzRW1iZWRkZWRJbihtb2RlbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmcm9udFBhcmVudE9ubHkpIHtcbiAgICAgICAgICAgIC8vIHBpY2sgdGhlIGVsZW1lbnQgd2l0aCB0aGUgaGlnaGVzdCBgemAgaW5kZXhcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLnNsaWNlKC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuZXdDYW5kaWRhdGVWaWV3ID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJldkNhbmRpZGF0ZVZpZXcgPSBkYXRhLmNhbmRpZGF0ZUVtYmVkVmlldztcblxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIGNhbmRpZGF0ZXMgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBvbmUgKGhhcyB0aGUgaGlnaGVzdCB6LWluZGV4KS5cbiAgICAgICAgZm9yIChsZXQgaSA9IGNhbmRpZGF0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgICBpZiAocHJldkNhbmRpZGF0ZVZpZXcgJiYgcHJldkNhbmRpZGF0ZVZpZXcubW9kZWwuaWQgPT0gY2FuZGlkYXRlLmlkKSB7XG4gICAgICAgICAgICAgICAgLy8gY2FuZGlkYXRlIHJlbWFpbnMgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBuZXdDYW5kaWRhdGVWaWV3ID0gcHJldkNhbmRpZGF0ZVZpZXc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjYW5kaWRhdGUuZmluZFZpZXcocGFwZXIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih2YWxpZGF0ZUVtYmVkZGluZykgfHwgdmFsaWRhdGVFbWJlZGRpbmcuY2FsbChwYXBlciwgdGhpcywgdmlldykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmxpcCB0byB0aGUgbmV3IGNhbmRpZGF0ZVxuICAgICAgICAgICAgICAgICAgICBuZXdDYW5kaWRhdGVWaWV3ID0gdmlldztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NhbmRpZGF0ZVZpZXcgJiYgbmV3Q2FuZGlkYXRlVmlldyAhPSBwcmV2Q2FuZGlkYXRlVmlldykge1xuICAgICAgICAgICAgLy8gQSBuZXcgY2FuZGlkYXRlIHZpZXcgZm91bmQuIEhpZ2hsaWdodCB0aGUgbmV3IG9uZS5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJFbWJlZGRpbmcoZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmNhbmRpZGF0ZUVtYmVkVmlldyA9IG5ld0NhbmRpZGF0ZVZpZXcuaGlnaGxpZ2h0KFxuICAgICAgICAgICAgICAgIG5ld0NhbmRpZGF0ZVZpZXcuZmluZFByb3h5Tm9kZShudWxsLCAnY29udGFpbmVyJyksXG4gICAgICAgICAgICAgICAgeyBlbWJlZGRpbmc6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3Q2FuZGlkYXRlVmlldyAmJiBwcmV2Q2FuZGlkYXRlVmlldykge1xuICAgICAgICAgICAgLy8gTm8gY2FuZGlkYXRlIHZpZXcgZm91bmQuIFVuaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyBjYW5kaWRhdGUuXG4gICAgICAgICAgICB0aGlzLmNsZWFyRW1iZWRkaW5nKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsZWFyRW1iZWRkaW5nOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9IHt9KTtcblxuICAgICAgICB2YXIgY2FuZGlkYXRlVmlldyA9IGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3O1xuICAgICAgICBpZiAoY2FuZGlkYXRlVmlldykge1xuICAgICAgICAgICAgLy8gTm8gY2FuZGlkYXRlIHZpZXcgZm91bmQuIFVuaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyBjYW5kaWRhdGUuXG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3LnVuaGlnaGxpZ2h0KFxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVZpZXcuZmluZFByb3h5Tm9kZShudWxsLCAnY29udGFpbmVyJyksXG4gICAgICAgICAgICAgICAgeyBlbWJlZGRpbmc6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5hbGl6ZUVtYmVkZGluZzogZnVuY3Rpb24oZGF0YSA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlVmlldyA9IGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZGF0YS5tb2RlbCB8fCB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCBwYXBlciA9IGRhdGEucGFwZXIgfHwgdGhpcy5wYXBlcjtcblxuICAgICAgICBpZiAoY2FuZGlkYXRlVmlldykge1xuXG4gICAgICAgICAgICAvLyBXZSBmaW5pc2hlZCBlbWJlZGRpbmcuIENhbmRpZGF0ZSB2aWV3IGlzIGNob3NlbiB0byBiZWNvbWUgdGhlIHBhcmVudCBvZiB0aGUgbW9kZWwuXG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3Lm1vZGVsLmVtYmVkKGVsZW1lbnQsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICBjYW5kaWRhdGVWaWV3LnVuaGlnaGxpZ2h0KGNhbmRpZGF0ZVZpZXcuZmluZFByb3h5Tm9kZShudWxsLCAnY29udGFpbmVyJyksIHsgZW1iZWRkaW5nOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBkYXRhLmNhbmRpZGF0ZUVtYmVkVmlldyA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc3QgeyB2YWxpZGF0ZVVuZW1iZWRkaW5nIH0gPSBwYXBlci5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgeyBpbml0aWFsUGFyZW50SWQgfSA9IGRhdGE7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCB3YXMgb3JpZ2luYWxseSBlbWJlZGRlZCBpbnRvIGFub3RoZXIgZWxlbWVudC5cbiAgICAgICAgICAgIC8vIFRoZSBpbnRlcmFjdGlvbiB3b3VsZCB1bmVtYmVkIHRoZSBlbGVtZW50LiBMZXQncyB2YWxpZGF0ZVxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgY2FuIGJlIHVuZW1iZWRkZWQuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaW5pdGlhbFBhcmVudElkICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbGlkYXRlVW5lbWJlZGRpbmcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgICAhdmFsaWRhdGVVbmVtYmVkZGluZy5jYWxsKHBhcGVyLCB0aGlzKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWxsb3dVbmVtYmVkKGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcGVyLm1vZGVsLmdldENvbm5lY3RlZExpbmtzKGVsZW1lbnQsIHsgZGVlcDogdHJ1ZSB9KS5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgbGluay5yZXBhcmVudCh7IHVpOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2Rpc2FsbG93VW5lbWJlZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjb25zdCB7IG1vZGVsLCB3aGVuTm90QWxsb3dlZCA9ICdyZXZlcnQnIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbW9kZWwgfHwgdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgcGFwZXIgPSBkYXRhLnBhcGVyIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gcGFwZXIubW9kZWw7XG4gICAgICAgIHN3aXRjaCAod2hlbk5vdEFsbG93ZWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZSh7IHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmV2ZXJ0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5pdGlhbFBhcmVudElkLCBpbml0aWFsUG9zaXRpb24sIGluaXRpYWxaSW5kaWNlcyB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGVsZW1lbnQncyBwb3NpdGlvbiAoYW5kIHRoZSBwb3NpdGlvbiBvZiBpdHMgZW1iZWRkZWQgY2VsbHMgaWYgYW55KVxuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb24oeCwgeSwgeyBkZWVwOiB0cnVlLCB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IGFsbCB0aGUgei1pbmRpY2VzIGNoYW5nZWQgZHVyaW5nIHRoZSBlbWJlZGRpbmdcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFpJbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluaXRpYWxaSW5kaWNlcykuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZ3JhcGguZ2V0Q2VsbChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgaW5pdGlhbFpJbmRpY2VzW2lkXSwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgb3JpZ2luYWwgcGFyZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZ3JhcGguZ2V0Q2VsbChpbml0aWFsUGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmVtYmVkKGVsZW1lbnQsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFRhcmdldFBhcmVudFZpZXc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBjb25zdCB7IGNhbmRpZGF0ZUVtYmVkVmlldyA9IG51bGwgfSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVFbWJlZFZpZXc7XG4gICAgfSxcblxuICAgIGdldERlbGVnYXRlZFZpZXc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcztcbiAgICAgICAgdmFyIG1vZGVsID0gdmlldy5tb2RlbDtcbiAgICAgICAgdmFyIHBhcGVyID0gdmlldy5wYXBlcjtcblxuICAgICAgICB3aGlsZSAodmlldykge1xuICAgICAgICAgICAgaWYgKG1vZGVsLmlzTGluaygpKSBicmVhaztcbiAgICAgICAgICAgIGlmICghbW9kZWwuaXNFbWJlZGRlZCgpIHx8IHZpZXcuY2FuKCdzdG9wRGVsZWdhdGlvbicpKSByZXR1cm4gdmlldztcbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWwuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICAgICAgdmlldyA9IHBhcGVyLmZpbmRWaWV3QnlNb2RlbChtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgZmluZFByb3h5Tm9kZTogZnVuY3Rpb24oZWwsIHR5cGUpIHtcbiAgICAgICAgZWwgfHwgKGVsID0gdGhpcy5lbCk7XG4gICAgICAgIGNvbnN0IG5vZGVTZWxlY3RvciA9IGVsLmdldEF0dHJpYnV0ZShgJHt0eXBlfS1zZWxlY3RvcmApO1xuICAgICAgICBpZiAobm9kZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5maW5kQXR0cmlidXRlKCdwb3J0JywgZWwpO1xuICAgICAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eVBvcnROb2RlID0gdGhpcy5maW5kUG9ydE5vZGUocG9ydCwgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlQb3J0Tm9kZSkgcmV0dXJuIHByb3h5UG9ydE5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5Tm9kZSA9IHRoaXMuZmluZE5vZGUobm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlOb2RlKSByZXR1cm4gcHJveHlOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJhY3Rpb24uIFRoZSBjb250cm9sbGVyIHBhcnQuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBub3RpZnlQb2ludGVyZG93bihldnQsIHgsIHkpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJkb3duLmNhbGwodGhpcywgZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcmRvd24nLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBub3RpZnlQb2ludGVybW92ZShldnQsIHgsIHkpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJtb3ZlLmNhbGwodGhpcywgZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcm1vdmUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBub3RpZnlQb2ludGVydXAoZXZ0LCB4LCB5KSB7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50OnBvaW50ZXJ1cCcsIGV2dCwgeCwgeSk7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVydXAuY2FsbCh0aGlzLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVyZGJsY2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcmNsaWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50OnBvaW50ZXJjbGljaycsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUuY29udGV4dG1lbnUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6Y29udGV4dG1lbnUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVyZG93bihldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLmRyYWdTdGFydChldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0TWFnbmV0LCBhY3Rpb24sIGRlbGVnYXRlZFZpZXcgfSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKHRhcmdldE1hZ25ldCkge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRwb2ludGVybW92ZShldnQsIHRhcmdldE1hZ25ldCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBEcmFnQWN0aW9ucy5NQUdORVQ6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnTWFnbmV0KGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERyYWdBY3Rpb25zLk1PVkU6XG4gICAgICAgICAgICAgICAgKGRlbGVnYXRlZFZpZXcgfHwgdGhpcykuZHJhZyhldnQsIHgsIHkpO1xuICAgICAgICAgICAgLy8gZXNsaW50OiBuby1mYWxsdGhyb3VnaD1mYWxzZVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wcmV2ZW50UG9pbnRlckV2ZW50cykgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVybW92ZShldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IHZpZXcgZGF0YSBpcyBwYXNzZWQgYWxvbmcuXG4gICAgICAgIC8vIEl0IGNvdWxkIGhhdmUgYmVlbiB3aXBlZCBvdXQgaW4gdGhlIGhhbmRsZXJzIGFib3ZlLlxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBwb2ludGVydXA6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBjb25zdCB7IHRhcmdldE1hZ25ldCwgYWN0aW9uLCBkZWxlZ2F0ZWRWaWV3IH0gPSBkYXRhO1xuXG4gICAgICAgIGlmICh0YXJnZXRNYWduZXQpIHtcbiAgICAgICAgICAgIHRoaXMubWFnbmV0cG9pbnRlcnVwKGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIERyYWdBY3Rpb25zLk1BR05FVDpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdNYWduZXRFbmQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0FjdGlvbnMuTU9WRTpcbiAgICAgICAgICAgICAgICAoZGVsZWdhdGVkVmlldyB8fCB0aGlzKS5kcmFnRW5kKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQ6IG5vLWZhbGx0aHJvdWdoPWZhbHNlXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnByZXZlbnRQb2ludGVyRXZlbnRzKSBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJ1cChldnQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldE1hZ25ldCkge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRwb2ludGVyY2xpY2soZXZ0LCB0YXJnZXRNYWduZXQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja01vdXNlbGVhdmUoZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VvdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1vdXNlb3ZlcicsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bW91c2VvdXQnLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWVudGVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptb3VzZWVudGVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VsZWF2ZTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm1vdXNlbGVhdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bW91c2VsZWF2ZScsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uKGV2dCwgeCwgeSwgZGVsdGEpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2V3aGVlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptb3VzZXdoZWVsJywgZXZ0LCB4LCB5LCBkZWx0YSk7XG4gICAgfSxcblxuICAgIG9ubWFnbmV0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCB7IGN1cnJlbnRUYXJnZXQ6IHRhcmdldE1hZ25ldCB9ID0gZXZ0O1xuICAgICAgICB0aGlzLm1hZ25ldHBvaW50ZXJkb3duKGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IHRhcmdldE1hZ25ldCB9KTtcbiAgICAgICAgdGhpcy5kcmFnTWFnbmV0U3RhcnQoZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0cG9pbnRlcmRvd246IGZ1bmN0aW9uKGV2dCwgbWFnbmV0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bWFnbmV0OnBvaW50ZXJkb3duJywgZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcm1vdmUnLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcnVwJywgZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCwgbWFnbmV0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bWFnbmV0OnBvaW50ZXJkYmxjbGljaycsIGV2dCwgbWFnbmV0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0Y29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2dCwgbWFnbmV0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bWFnbmV0OmNvbnRleHRtZW51JywgZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvLyBEcmFnIFN0YXJ0IEhhbmRsZXJzXG5cbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkKGV2dCkpIHJldHVybjtcblxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuZ2V0RGVsZWdhdGVkVmlldygpO1xuICAgICAgICBpZiAoIXZpZXcgfHwgIXZpZXcuY2FuKCdlbGVtZW50TW92ZScpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBhY3Rpb246IERyYWdBY3Rpb25zLk1PVkUsXG4gICAgICAgICAgICBkZWxlZ2F0ZWRWaWV3OiB2aWV3XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdmlldy5tb2RlbC5wb3NpdGlvbigpO1xuICAgICAgICB2aWV3LmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBwb2ludGVyT2Zmc2V0OiBwb3NpdGlvbi5kaWZmZXJlbmNlKHgsIHkpLFxuICAgICAgICAgICAgcmVzdHJpY3RlZEFyZWE6IHRoaXMucGFwZXIuZ2V0UmVzdHJpY3RlZEFyZWEodmlldywgeCwgeSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRyYWdNYWduZXRTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBwYXBlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNQcm9wYWdhdGlvbkFscmVhZHlTdG9wcGVkID0gZXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XG4gICAgICAgIGlmIChpc1Byb3BhZ2F0aW9uQWxyZWFkeVN0b3BwZWQpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIHRoZSBwcm9wYWdhdGlvbiB3YXMgYWxyZWFkeSBzdG9wcGVkXG4gICAgICAgICAgICAvLyBvbiB0aGUgYGVsZW1lbnQ6bWFnbmV0OnBvaW50ZXJkb3duYCBldmVudC5cbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGFueSBgZWxlbWVudDpwb2ludGVyKmAgZXZlbnRzXG4gICAgICAgICAgICAvLyBidXQgc3RpbGwgc3RhcnQgdGhlIG1hZ25ldCBkcmFnZ2luZy5cbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBwcmV2ZW50UG9pbnRlckV2ZW50czogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkKGV2dCkgfHwgIXRoaXMuY2FuKCdhZGRMaW5rRnJvbU1hZ25ldCcpKSB7XG4gICAgICAgICAgICAvLyBTdG9wIHRoZSBkZWZhdWx0IGFjdGlvbiwgd2hpY2ggaXMgdG8gc3RhcnQgZHJhZ2dpbmcgYSBsaW5rLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB0YXJnZXRNYWduZXQgPSBldnQuY3VycmVudFRhcmdldCB9ID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIC8vIEludmFsaWQgKFBhc3NpdmUpIG1hZ25ldC4gU3RhcnQgZHJhZ2dpbmcgdGhlIGVsZW1lbnQuXG4gICAgICAgIGlmICghcGFwZXIub3B0aW9ucy52YWxpZGF0ZU1hZ25ldC5jYWxsKHBhcGVyLCB0aGlzLCB0YXJnZXRNYWduZXQsIGV2dCkpIHtcbiAgICAgICAgICAgIGlmIChpc1Byb3BhZ2F0aW9uQWxyZWFkeVN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJpZ2dlciBgZWxlbWVudDpwb2ludGVyZG93bmAgYW5kIHN0YXJ0IGVsZW1lbnQgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcGFnYXRpb24gd2FzIHN0b3BwZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYGVsZW1lbnQ6cG9pbnRlcmRvd25gIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIG9mIGBwcmV2ZW50UG9pbnRlckV2ZW50c2AgZmxhZy5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByZXNldCB0aGUgYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gdG8gYE1PVkVgIHNvIHRoYXQgdGhlIGVsZW1lbnQgaXMgZHJhZ2dlZC5cbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50ZXJkb3duKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZCBtYWduZXQuIFN0YXJ0IGRyYWdnaW5nIGEgbGluay5cbiAgICAgICAgaWYgKHBhcGVyLm9wdGlvbnMubWFnbmV0VGhyZXNob2xkIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0xpbmtTdGFydChldnQsIHRhcmdldE1hZ25ldCwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IGFjdGlvbjogRHJhZ0FjdGlvbnMuTUFHTkVUIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEcmFnIEhhbmRsZXJzXG5cbiAgICBzbmFwVG9HcmlkOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcbiAgICAgICAgY29uc3QgZ3JpZCA9IHRoaXMucGFwZXIub3B0aW9ucy5ncmlkU2l6ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHNuYXBUb0dyaWQoeCwgZ3JpZCksXG4gICAgICAgICAgICB5OiBzbmFwVG9HcmlkKHksIGdyaWQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGRyYWc6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgeyBwb2ludGVyT2Zmc2V0LCByZXN0cmljdGVkQXJlYSwgZW1iZWRkaW5nIH0gPSBkYXRhO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmV3IGVsZW1lbnQncyBwb3NpdGlvbiBhbHdheXMgc25hcHMgdG8gdGhlIGN1cnJlbnQgZ3JpZFxuICAgICAgICBjb25zdCB7IHg6IGVsWCwgeTogZWxZIH0gPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LCB4ICsgcG9pbnRlck9mZnNldC54LCB5ICsgcG9pbnRlck9mZnNldC55KTtcblxuICAgICAgICBlbGVtZW50LnBvc2l0aW9uKGVsWCwgZWxZLCB7IHJlc3RyaWN0ZWRBcmVhLCBkZWVwOiB0cnVlLCB1aTogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAocGFwZXIub3B0aW9ucy5lbWJlZGRpbmdNb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWVtYmVkZGluZykge1xuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIGVsZW1lbnQgZm9yIGVtYmVkZGluZyBvbmx5IGlmIHRoZSBwb2ludGVyIG1vdmVzLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gZG8gdW5uZWNlc3NhcnkgYWN0aW9uIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBpZiBhbiB1c2VyIG9ubHkgY2xpY2tzL2RibGNsaWNrcyBvbiBpdC5cbiAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVFbWJlZGRpbmcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VtYmVkZGluZyhkYXRhLCBldnQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBlbWJlZGRpbmdcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGRyYWdNYWduZXQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuICAgICAgICB0aGlzLmRyYWdMaW5rKGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgRW5kIEhhbmRsZXJzXG5cbiAgICBkcmFnRW5kOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGlmIChkYXRhLmVtYmVkZGluZykgdGhpcy5maW5hbGl6ZUVtYmVkZGluZyhkYXRhKTtcbiAgICB9LFxuXG4gICAgZHJhZ01hZ25ldEVuZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuZHJhZ0xpbmtFbmQoZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0cG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICBpZiAocGFwZXIuZXZlbnREYXRhKGV2dCkubW91c2Vtb3ZlZCA+IHBhcGVyLm9wdGlvbnMuY2xpY2tUaHJlc2hvbGQpIHJldHVybjtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bWFnbmV0OnBvaW50ZXJjbGljaycsIGV2dCwgbWFnbmV0LCB4LCB5KTtcbiAgICB9XG5cbn0sIHtcblxuICAgIEZsYWdzOiBGbGFncyxcbn0pO1xuXG5hc3NpZ24oRWxlbWVudFZpZXcucHJvdG90eXBlLCBlbGVtZW50Vmlld1BvcnRQcm90b3R5cGUpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/ElementView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/Graph.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Graph.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/getRectPoint.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mvc/Model.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/Collection.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Collection.mjs\");\n/* harmony import */ var _util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/wrappers.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/wrappers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/cloneCells.mjs\");\n\n\n\n\n\n\n\n\nconst GraphCells = _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__.Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */\n            this.cellNamespace = typeof joint !== 'undefined' && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        const collection = opt.collection;\n        const namespace = collection.cellNamespace;\n        const { type } = attrs;\n\n        // Find the model class based on the `type` attribute in the cell namespace\n        const ModelClass = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath(namespace, type, '.');\n        if (!ModelClass) {\n            throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n        }\n\n        return new ModelClass(attrs, opt);\n    },\n\n    _addReference: function(model, options) {\n        _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__.Collection.prototype._addReference.apply(this, arguments);\n        // If not in `dry` mode and the model does not have a graph reference yet,\n        // set the reference.\n        if (!options.dry && !model.graph) {\n            model.graph = this.graph;\n        }\n    },\n\n    _removeReference: function(model, options) {\n        _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__.Collection.prototype._removeReference.apply(this, arguments);\n        // If not in `dry` mode and the model has a reference to this exact graph,\n        // remove the reference.\n        if (!options.dry && model.graph === this.graph) {\n            model.graph = null;\n        }\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nconst Graph = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // JointJS automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells mvc collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function(opt = {}) {\n\n        // JointJS does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON(opt.cellAttributes);\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell) {\n\n        let attrs;\n        if (cell instanceof _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model) {\n            attrs = cell.attributes;\n        } else {\n            attrs = cell;\n        }\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n    },\n\n    transferCellEmbeds: function(sourceCell, targetCell, opt = {}) {\n\n        const batchName = 'transfer-embeds';\n        this.startBatch(batchName);\n\n        // Embed children of the source cell in the target cell.\n        const children = sourceCell.getEmbeddedCells();\n        targetCell.embed(children, { ...opt, reparent: true });\n\n        this.stopBatch(batchName);\n    },\n\n    transferCellConnectedLinks: function(sourceCell, targetCell, opt = {}) {\n\n        const batchName = 'transfer-connected-links';\n        this.startBatch(batchName);\n\n        // Reconnect all the links connected to the old cell to the new cell.\n        const connectedLinks = this.getConnectedLinks(sourceCell, opt);\n        connectedLinks.forEach((link) => {\n\n            if (link.getSourceCell() === sourceCell) {\n                link.prop(['source', 'id'], targetCell.id, opt);\n            }\n\n            if (link.getTargetCell() === sourceCell) {\n                link.prop(['target', 'id'], targetCell.id, opt);\n            }\n        });\n\n        this.stopBatch(batchName);\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isElement());\n    },\n\n    getLinks: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isLink());\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all cells at given point\n\n    findElementsAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getElements(), point, opt);\n    },\n\n    findLinksAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getLinks(), point, opt);\n    },\n\n    findCellsAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getCells(), point, opt);\n    },\n\n    _filterAtPoint: function(cells, point, opt = {}) {\n        return cells.filter(el => el.getBBox({ rotate: true }).containsPoint(point, opt));\n    },\n\n    // Find all cells in given area\n\n    findElementsInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getElements(), area, opt);\n    },\n\n    findLinksInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getLinks(), area, opt);\n    },\n\n    findCellsInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getCells(), area, opt);\n    },\n\n    _filterInArea: function(cells, area, opt = {}) {\n        const r = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(area);\n        const { strict = false } = opt;\n        const method = strict ? 'containsRect' : 'intersect';\n        return cells.filter(el => r[method](el.getBBox({ rotate: true })));\n    },\n\n    // Find all cells under the given element.\n\n    findElementsUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getElements(), element, opt);\n    },\n\n    findLinksUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getLinks(), element, opt);\n    },\n\n    findCellsUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getCells(), element, opt);\n    },\n\n    _isValidElementUnderElement: function(el1, el2) {\n        return el1.id !== el2.id && !el1.isEmbeddedIn(el2);\n    },\n\n    _isValidLinkUnderElement: function(link, el) {\n        return (\n            link.source().id !== el.id &&\n            link.target().id !== el.id &&\n            !link.isEmbeddedIn(el)\n        );\n    },\n\n    _validateCellsUnderElement: function(cells, element) {\n        return cells.filter(cell => {\n            return cell.isLink()\n                ? this._isValidLinkUnderElement(cell, element)\n                : this._isValidElementUnderElement(cell, element);\n        });\n    },\n\n    _getFindUnderElementGeometry: function(element, searchBy = 'bbox') {\n        const bbox = element.getBBox({ rotate: true });\n        return (searchBy !== 'bbox') ? _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.getRectPoint(bbox, searchBy) : bbox;\n    },\n\n    _filterCellsUnderElement: function(cells, element, opt = {}) {\n        const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);\n        const filteredCells = (geometry.type === _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.types.Point)\n            ? this._filterAtPoint(cells, geometry)\n            : this._filterInArea(cells, geometry, opt);\n        return this._validateCellsUnderElement(filteredCells, element);\n    },\n\n    // @deprecated use `findElementsInArea` instead\n    findModelsInArea: function(area, opt) {\n        return this.findElementsInArea(area, opt);\n    },\n\n    // @deprecated use `findElementsAtPoint` instead\n    findModelsFromPoint: function(point) {\n        return this.findElementsAtPoint(point);\n    },\n\n    // @deprecated use `findModelsUnderElement` instead\n    findModelsUnderElement: function(element, opt) {\n        return this.findElementsUnderElement(element, opt);\n    },\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({ rotate });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\n(0,_util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__.wrapWith)(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], _util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__.wrappers.cells);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9HcmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNOOztBQUVLO0FBQ1U7QUFDTztBQUNYOztBQUUvQyxtQkFBbUIsMkRBQVU7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlFQUFpRSxnREFBUTtBQUN6RTtBQUNBOzs7QUFHQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBLDJCQUEyQixzREFBYztBQUN6QztBQUNBLHFGQUFxRixLQUFLO0FBQzFGOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFFBQVEsMkRBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxRQUFRLDJEQUFVO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdNLGNBQWMsaURBQUs7O0FBRTFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsaURBQUs7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVM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QUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDBDQUEwQztBQUMxQyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGVBQWUsb0RBQVk7QUFDM0Isd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsUUFBUSxtREFBVzs7QUFFbkI7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFXO0FBQ3ZCOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxtREFBVyxHQUFHLFVBQVUsaUJBQWlCO0FBQ3BGLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsbURBQVcsR0FBRyxVQUFVLGlCQUFpQjtBQUNuRixLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUEsZ0ZBQWdGLGdCQUFnQjtBQUNoRzs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVELDREQUFRLDZEQUE2RCx3REFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9HcmFwaC5tanM/MDE3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5pbXBvcnQgeyBNb2RlbCB9IGZyb20gJy4uL212Yy9Nb2RlbC5tanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4uL212Yy9Db2xsZWN0aW9uLm1qcyc7XG5pbXBvcnQgeyB3cmFwcGVycywgd3JhcFdpdGggfSBmcm9tICcuLi91dGlsL3dyYXBwZXJzLm1qcyc7XG5pbXBvcnQgeyBjbG9uZUNlbGxzIH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG5jb25zdCBHcmFwaENlbGxzID0gQ29sbGVjdGlvbi5leHRlbmQoe1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHQpIHtcblxuICAgICAgICAvLyBTZXQgdGhlIG9wdGlvbmFsIG5hbWVzcGFjZSB3aGVyZSBhbGwgbW9kZWwgY2xhc3NlcyBhcmUgZGVmaW5lZC5cbiAgICAgICAgaWYgKG9wdC5jZWxsTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxOYW1lc3BhY2UgPSBvcHQuY2VsbE5hbWVzcGFjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgICAgICB0aGlzLmNlbGxOYW1lc3BhY2UgPSB0eXBlb2Ygam9pbnQgIT09ICd1bmRlZmluZWQnICYmIHV0aWwuaGFzKGpvaW50LCAnc2hhcGVzJykgPyBqb2ludC5zaGFwZXMgOiBudWxsO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLmdyYXBoID0gb3B0LmdyYXBoO1xuICAgIH0sXG5cbiAgICBtb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdCkge1xuXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBvcHQuY29sbGVjdGlvbjtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gY29sbGVjdGlvbi5jZWxsTmFtZXNwYWNlO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGF0dHJzO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIG1vZGVsIGNsYXNzIGJhc2VkIG9uIHRoZSBgdHlwZWAgYXR0cmlidXRlIGluIHRoZSBjZWxsIG5hbWVzcGFjZVxuICAgICAgICBjb25zdCBNb2RlbENsYXNzID0gdXRpbC5nZXRCeVBhdGgobmFtZXNwYWNlLCB0eXBlLCAnLicpO1xuICAgICAgICBpZiAoIU1vZGVsQ2xhc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlhLkdyYXBoOiBDb3VsZCBub3QgZmluZCBjZWxsIGNvbnN0cnVjdG9yIGZvciB0eXBlOiAnJHt0eXBlfScuIE1ha2Ugc3VyZSB0byBhZGQgdGhlIGNvbnN0cnVjdG9yIHRvICdjZWxsTmFtZXNwYWNlJy5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTW9kZWxDbGFzcyhhdHRycywgb3B0KTtcbiAgICB9LFxuXG4gICAgX2FkZFJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgQ29sbGVjdGlvbi5wcm90b3R5cGUuX2FkZFJlZmVyZW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyBJZiBub3QgaW4gYGRyeWAgbW9kZSBhbmQgdGhlIG1vZGVsIGRvZXMgbm90IGhhdmUgYSBncmFwaCByZWZlcmVuY2UgeWV0LFxuICAgICAgICAvLyBzZXQgdGhlIHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFvcHRpb25zLmRyeSAmJiAhbW9kZWwuZ3JhcGgpIHtcbiAgICAgICAgICAgIG1vZGVsLmdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fcmVtb3ZlUmVmZXJlbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vIElmIG5vdCBpbiBgZHJ5YCBtb2RlIGFuZCB0aGUgbW9kZWwgaGFzIGEgcmVmZXJlbmNlIHRvIHRoaXMgZXhhY3QgZ3JhcGgsXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW9wdGlvbnMuZHJ5ICYmIG1vZGVsLmdyYXBoID09PSB0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICBtb2RlbC5ncmFwaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gYGNvbXBhcmF0b3JgIG1ha2VzIGl0IGVhc3kgdG8gc29ydCBjZWxscyBiYXNlZCBvbiB0aGVpciBgemAgaW5kZXguXG4gICAgY29tcGFyYXRvcjogZnVuY3Rpb24obW9kZWwpIHtcblxuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KCd6JykgfHwgMDtcbiAgICB9XG59KTtcblxuXG5leHBvcnQgY29uc3QgR3JhcGggPSBNb2RlbC5leHRlbmQoe1xuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cnMsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICAvLyBQYXNzaW5nIGBjZWxsTW9kZWxgIGZ1bmN0aW9uIGluIHRoZSBvcHRpb25zIG9iamVjdCB0byBncmFwaCBhbGxvd3MgZm9yXG4gICAgICAgIC8vIHNldHRpbmcgbW9kZWxzIGJhc2VkIG9uIGF0dHJpYnV0ZSBvYmplY3RzLiBUaGlzIGlzIGVzcGVjaWFsbHkgaGFuZHlcbiAgICAgICAgLy8gd2hlbiBwcm9jZXNzaW5nIEpTT04gZ3JhcGhzIHRoYXQgYXJlIGluIGEgZGlmZmVyZW50IHRoYW4gSm9pbnRKUyBmb3JtYXQuXG4gICAgICAgIHZhciBjZWxscyA9IG5ldyBHcmFwaENlbGxzKFtdLCB7XG4gICAgICAgICAgICBtb2RlbDogb3B0LmNlbGxNb2RlbCxcbiAgICAgICAgICAgIGNlbGxOYW1lc3BhY2U6IG9wdC5jZWxsTmFtZXNwYWNlLFxuICAgICAgICAgICAgZ3JhcGg6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIE1vZGVsLnByb3RvdHlwZS5zZXQuY2FsbCh0aGlzLCAnY2VsbHMnLCBjZWxscyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgdGhlIGV2ZW50cyBmaXJlZCBpbiB0aGUgYGNlbGxzYCBjb2xsZWN0aW9uIGF2YWlsYWJsZS5cbiAgICAgICAgLy8gdG8gdGhlIG91dHNpZGUgd29ybGQuXG4gICAgICAgIGNlbGxzLm9uKCdhbGwnLCB0aGlzLnRyaWdnZXIsIHRoaXMpO1xuXG4gICAgICAgIC8vIEpvaW50SlMgYXV0b21hdGljYWxseSBkb2Vzbid0IHRyaWdnZXIgcmUtc29ydCBpZiBtb2RlbHMgYXR0cmlidXRlcyBhcmUgY2hhbmdlZCBsYXRlciB3aGVuXG4gICAgICAgIC8vIHRoZXkncmUgYWxyZWFkeSBpbiB0aGUgY29sbGVjdGlvbi4gVGhlcmVmb3JlLCB3ZSdyZSB0cmlnZ2VyaW5nIHNvcnQgbWFudWFsbHkgaGVyZS5cbiAgICAgICAgdGhpcy5vbignY2hhbmdlOnonLCB0aGlzLl9zb3J0T25DaGFuZ2VaLCB0aGlzKTtcblxuICAgICAgICAvLyBgam9pbnQuZGlhLkdyYXBoYCBrZWVwcyBhbiBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSAoYW4gYWRqYWNlbmN5IGxpc3QpXG4gICAgICAgIC8vIGZvciBmYXN0IGdyYXBoIHF1ZXJpZXMuIEFsbCBjaGFuZ2VzIHRoYXQgYWZmZWN0IHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyYXBoXG4gICAgICAgIC8vIG11c3QgYmUgcmVmbGVjdGVkIGluIHRoZSBgYWxgIG9iamVjdC4gVGhpcyBvYmplY3QgcHJvdmlkZXMgZmFzdCBhbnN3ZXJzIHRvXG4gICAgICAgIC8vIHF1ZXN0aW9ucyBzdWNoIGFzIFwid2hhdCBhcmUgdGhlIG5laWdoYm91cnMgb2YgdGhpcyBub2RlXCIgb3IgXCJ3aGF0XG4gICAgICAgIC8vIGFyZSB0aGUgc2libGluZyBsaW5rcyBvZiB0aGlzIGxpbmtcIi5cblxuICAgICAgICAvLyBPdXRnb2luZyBlZGdlcyBwZXIgbm9kZS4gTm90ZSB0aGF0IHdlIHVzZSBhIGhhc2gtdGFibGUgZm9yIHRoZSBsaXN0XG4gICAgICAgIC8vIG9mIG91dGdvaW5nIGVkZ2VzIGZvciBhIGZhc3RlciBsb29rdXAuXG4gICAgICAgIC8vIFtub2RlSWRdIC0+IE9iamVjdCBbZWRnZUlkXSAtPiB0cnVlXG4gICAgICAgIHRoaXMuX291dCA9IHt9O1xuICAgICAgICAvLyBJbmdvaW5nIGVkZ2VzIHBlciBub2RlLlxuICAgICAgICAvLyBbbm9kZUlkXSAtPiBPYmplY3QgW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgICAgICB0aGlzLl9pbiA9IHt9O1xuICAgICAgICAvLyBgX25vZGVzYCBpcyB1c2VmdWwgZm9yIHF1aWNrIGxvb2t1cCBvZiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBncmFwaCwgd2l0aG91dFxuICAgICAgICAvLyBoYXZpbmcgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgY2VsbHMgYXJyYXkuXG4gICAgICAgIC8vIFtub2RlIElEXSAtPiB0cnVlXG4gICAgICAgIHRoaXMuX25vZGVzID0ge307XG4gICAgICAgIC8vIGBfZWRnZXNgIGlzIHVzZWZ1bCBmb3IgcXVpY2sgbG9va3VwIG9mIGFsbCB0aGUgbGlua3MgaW4gdGhlIGdyYXBoLCB3aXRob3V0XG4gICAgICAgIC8vIGhhdmluZyB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSBjZWxscyBhcnJheS5cbiAgICAgICAgLy8gW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgICAgICB0aGlzLl9lZGdlcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2JhdGNoZXMgPSB7fTtcblxuICAgICAgICBjZWxscy5vbignYWRkJywgdGhpcy5fcmVzdHJ1Y3R1cmVPbkFkZCwgdGhpcyk7XG4gICAgICAgIGNlbGxzLm9uKCdyZW1vdmUnLCB0aGlzLl9yZXN0cnVjdHVyZU9uUmVtb3ZlLCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ3Jlc2V0JywgdGhpcy5fcmVzdHJ1Y3R1cmVPblJlc2V0LCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ2NoYW5nZTpzb3VyY2UnLCB0aGlzLl9yZXN0cnVjdHVyZU9uQ2hhbmdlU291cmNlLCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ2NoYW5nZTp0YXJnZXQnLCB0aGlzLl9yZXN0cnVjdHVyZU9uQ2hhbmdlVGFyZ2V0LCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ3JlbW92ZScsIHRoaXMuX3JlbW92ZUNlbGwsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfc29ydE9uQ2hhbmdlWjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5nZXQoJ2NlbGxzJykuc29ydCgpO1xuICAgIH0sXG5cbiAgICBfcmVzdHJ1Y3R1cmVPbkFkZDogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIGlmIChjZWxsLmlzTGluaygpKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGdlc1tjZWxsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gY2VsbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCkge1xuICAgICAgICAgICAgICAgICh0aGlzLl9vdXRbc291cmNlLmlkXSB8fCAodGhpcy5fb3V0W3NvdXJjZS5pZF0gPSB7fSkpW2NlbGwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICAgICAodGhpcy5faW5bdGFyZ2V0LmlkXSB8fCAodGhpcy5faW5bdGFyZ2V0LmlkXSA9IHt9KSlbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uUmVtb3ZlOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgaWYgKGNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lZGdlc1tjZWxsLmlkXTtcbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBjZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBpZiAoc291cmNlLmlkICYmIHRoaXMuX291dFtzb3VyY2UuaWRdICYmIHRoaXMuX291dFtzb3VyY2UuaWRdW2NlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX291dFtzb3VyY2UuaWRdW2NlbGwuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5pZCAmJiB0aGlzLl9pblt0YXJnZXQuaWRdICYmIHRoaXMuX2luW3RhcmdldC5pZF1bY2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faW5bdGFyZ2V0LmlkXVtjZWxsLmlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ub2Rlc1tjZWxsLmlkXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcmVzdHJ1Y3R1cmVPblJlc2V0OiBmdW5jdGlvbihjZWxscykge1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBpbnRvIGFuIGFycmF5IG9mIGNlbGxzLiBUaGUgb3JpZ2luYWwgYGNlbGxzYCBpcyBHcmFwaENlbGxzIG12YyBjb2xsZWN0aW9uLlxuICAgICAgICBjZWxscyA9IGNlbGxzLm1vZGVscztcblxuICAgICAgICB0aGlzLl9vdXQgPSB7fTtcbiAgICAgICAgdGhpcy5faW4gPSB7fTtcbiAgICAgICAgdGhpcy5fbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fZWRnZXMgPSB7fTtcblxuICAgICAgICBjZWxscy5mb3JFYWNoKHRoaXMuX3Jlc3RydWN0dXJlT25BZGQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBfcmVzdHJ1Y3R1cmVPbkNoYW5nZVNvdXJjZTogZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgIHZhciBwcmV2U291cmNlID0gbGluay5wcmV2aW91cygnc291cmNlJyk7XG4gICAgICAgIGlmIChwcmV2U291cmNlLmlkICYmIHRoaXMuX291dFtwcmV2U291cmNlLmlkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX291dFtwcmV2U291cmNlLmlkXVtsaW5rLmlkXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gbGluay5hdHRyaWJ1dGVzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZS5pZCkge1xuICAgICAgICAgICAgKHRoaXMuX291dFtzb3VyY2UuaWRdIHx8ICh0aGlzLl9vdXRbc291cmNlLmlkXSA9IHt9KSlbbGluay5pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uQ2hhbmdlVGFyZ2V0OiBmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgdmFyIHByZXZUYXJnZXQgPSBsaW5rLnByZXZpb3VzKCd0YXJnZXQnKTtcbiAgICAgICAgaWYgKHByZXZUYXJnZXQuaWQgJiYgdGhpcy5faW5bcHJldlRhcmdldC5pZF0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbltwcmV2VGFyZ2V0LmlkXVtsaW5rLmlkXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0ID0gbGluay5nZXQoJ3RhcmdldCcpO1xuICAgICAgICBpZiAodGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICAodGhpcy5faW5bdGFyZ2V0LmlkXSB8fCAodGhpcy5faW5bdGFyZ2V0LmlkXSA9IHt9KSlbbGluay5pZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhbGwgb3V0Ym91bmQgZWRnZXMgZm9yIHRoZSBub2RlLiBSZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgLy8gb2YgdGhlIGZvcm06IFtlZGdlSWRdIC0+IHRydWVcbiAgICBnZXRPdXRib3VuZEVkZ2VzOiBmdW5jdGlvbihub2RlKSB7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLl9vdXQgJiYgdGhpcy5fb3V0W25vZGVdKSB8fCB7fTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFsbCBpbmJvdW5kIGVkZ2VzIGZvciB0aGUgbm9kZS4gUmV0dXJuIHZhbHVlIGlzIGFuIG9iamVjdFxuICAgIC8vIG9mIHRoZSBmb3JtOiBbZWRnZUlkXSAtPiB0cnVlXG4gICAgZ2V0SW5ib3VuZEVkZ2VzOiBmdW5jdGlvbihub2RlKSB7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLl9pbiAmJiB0aGlzLl9pbltub2RlXSkgfHwge307XG4gICAgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICAvLyBKb2ludEpTIGRvZXMgbm90IHJlY3Vyc2l2ZWx5IGNhbGwgYHRvSlNPTigpYCBvbiBhdHRyaWJ1dGVzIHRoYXQgYXJlIHRoZW1zZWx2ZXMgbW9kZWxzL2NvbGxlY3Rpb25zLlxuICAgICAgICAvLyBJdCBqdXN0IGNsb25lcyB0aGUgYXR0cmlidXRlcy4gVGhlcmVmb3JlLCB3ZSBtdXN0IGNhbGwgYHRvSlNPTigpYCBvbiB0aGUgY2VsbHMgY29sbGVjdGlvbiBleHBsaWNpdGx5LlxuICAgICAgICB2YXIganNvbiA9IE1vZGVsLnByb3RvdHlwZS50b0pTT04uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAganNvbi5jZWxscyA9IHRoaXMuZ2V0KCdjZWxscycpLnRvSlNPTihvcHQuY2VsbEF0dHJpYnV0ZXMpO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uKGpzb24sIG9wdCkge1xuXG4gICAgICAgIGlmICghanNvbi5jZWxscykge1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dyYXBoIEpTT04gbXVzdCBjb250YWluIGNlbGxzIGFycmF5LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGpzb24sIG9wdCk7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdCkge1xuXG4gICAgICAgIHZhciBhdHRycztcblxuICAgICAgICAvLyBIYW5kbGUgYm90aCBga2V5YCwgdmFsdWUgYW5kIHtrZXk6IHZhbHVlfSBzdHlsZSBhcmd1bWVudHMuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICBvcHQgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGBjZWxsc2AgYXR0cmlidXRlIGlzIGhhbmRsZWQgc2VwYXJhdGVseSB2aWEgcmVzZXRDZWxscygpLlxuICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoJ2NlbGxzJykpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRDZWxscyhhdHRycy5jZWxscywgb3B0KTtcbiAgICAgICAgICAgIGF0dHJzID0gdXRpbC5vbWl0KGF0dHJzLCAnY2VsbHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXN0IG9mIHRoZSBhdHRyaWJ1dGVzIGFyZSBhcHBsaWVkIHZpYSBvcmlnaW5hbCBzZXQgbWV0aG9kLlxuICAgICAgICByZXR1cm4gTW9kZWwucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsIGF0dHJzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gdXRpbC5hc3NpZ24oe30sIG9wdCwgeyBjbGVhcjogdHJ1ZSB9KTtcblxuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuZ2V0KCdjZWxscycpO1xuXG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdjbGVhcicsIG9wdCk7XG5cbiAgICAgICAgLy8gVGhlIGVsZW1lbnRzIGNvbWUgYWZ0ZXIgdGhlIGxpbmtzLlxuICAgICAgICB2YXIgY2VsbHMgPSBjb2xsZWN0aW9uLnNvcnRCeShmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5pc0xpbmsoKSA/IDEgOiAyO1xuICAgICAgICB9KTtcblxuICAgICAgICBkbyB7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIGNlbGxzIG9uZSBieSBvbmUuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYWxsIHRoZSBsaW5rcyBhcmUgcmVtb3ZlZCBmaXJzdCwgc28gaXQnc1xuICAgICAgICAgICAgLy8gc2FmZSB0byByZW1vdmUgdGhlIGVsZW1lbnRzIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGNvbm5lY3RlZFxuICAgICAgICAgICAgLy8gbGlua3MgZmlyc3QuXG4gICAgICAgICAgICBjZWxscy5zaGlmdCgpLnJlbW92ZShvcHQpO1xuXG4gICAgICAgIH0gd2hpbGUgKGNlbGxzLmxlbmd0aCA+IDApO1xuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdjbGVhcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfcHJlcGFyZUNlbGw6IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICBsZXQgYXR0cnM7XG4gICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIGF0dHJzID0gY2VsbC5hdHRyaWJ1dGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0cnMgPSBjZWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKGF0dHJzLnR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuR3JhcGg6IGNlbGwgdHlwZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIG1pblpJbmRleDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGZpcnN0Q2VsbCA9IHRoaXMuZ2V0KCdjZWxscycpLmZpcnN0KCk7XG4gICAgICAgIHJldHVybiBmaXJzdENlbGwgPyAoZmlyc3RDZWxsLmdldCgneicpIHx8IDApIDogMDtcbiAgICB9LFxuXG4gICAgbWF4WkluZGV4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbGFzdENlbGwgPSB0aGlzLmdldCgnY2VsbHMnKS5sYXN0KCk7XG4gICAgICAgIHJldHVybiBsYXN0Q2VsbCA/IChsYXN0Q2VsbC5nZXQoJ3onKSB8fCAwKSA6IDA7XG4gICAgfSxcblxuICAgIGFkZENlbGw6IGZ1bmN0aW9uKGNlbGwsIG9wdCkge1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNlbGwpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZENlbGxzKGNlbGwsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2VsbCBpbnN0YW5jZW9mIE1vZGVsKSB7XG5cbiAgICAgICAgICAgIGlmICghY2VsbC5oYXMoJ3onKSkge1xuICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgdGhpcy5tYXhaSW5kZXgoKSArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoY2VsbC56ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgY2VsbC56ID0gdGhpcy5tYXhaSW5kZXgoKSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldCgnY2VsbHMnKS5hZGQodGhpcy5fcHJlcGFyZUNlbGwoY2VsbCwgb3B0KSwgb3B0IHx8IHt9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkQ2VsbHM6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgICAgICBjZWxscyA9IHV0aWwuZmxhdHRlbkRlZXAoY2VsbHMpO1xuICAgICAgICBvcHQubWF4UG9zaXRpb24gPSBvcHQucG9zaXRpb24gPSBjZWxscy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgnYWRkJywgb3B0KTtcbiAgICAgICAgY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZENlbGwoY2VsbCwgb3B0KTtcbiAgICAgICAgICAgIG9wdC5wb3NpdGlvbi0tO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ2FkZCcsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFdoZW4gYWRkaW5nIGEgbG90IG9mIGNlbGxzLCBpdCBpcyBtdWNoIG1vcmUgZWZmaWNpZW50IHRvXG4gICAgLy8gcmVzZXQgdGhlIGVudGlyZSBjZWxscyBjb2xsZWN0aW9uIGluIG9uZSBnby5cbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cbiAgICByZXNldENlbGxzOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG5cbiAgICAgICAgdmFyIHByZXBhcmVkQ2VsbHMgPSB1dGlsLnRvQXJyYXkoY2VsbHMpLm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlcGFyZUNlbGwoY2VsbCwgb3B0KTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0KCdjZWxscycpLnJlc2V0KHByZXBhcmVkQ2VsbHMsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZUNlbGxzOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG5cbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3JlbW92ZScpO1xuICAgICAgICAgICAgdXRpbC5pbnZva2UoY2VsbHMsICdyZW1vdmUnLCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3JlbW92ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9yZW1vdmVDZWxsOiBmdW5jdGlvbihjZWxsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAvLyBBcHBsaWNhdGlvbnMgbWlnaHQgcHJvdmlkZSBhIGBkaXNjb25uZWN0TGlua3NgIG9wdGlvbiBzZXQgdG8gYHRydWVgIGluIG9yZGVyIHRvXG4gICAgICAgICAgICAvLyBkaXNjb25uZWN0IGxpbmtzIHdoZW4gYSBjZWxsIGlzIHJlbW92ZWQgcmF0aGVyIHRoZW4gcmVtb3ZpbmcgdGhlbS4gVGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGlzIHRvIHJlbW92ZSBhbGwgdGhlIGFzc29jaWF0ZWQgbGlua3MuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXNjb25uZWN0TGlua3MpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdExpbmtzKGNlbGwsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaW5rcyhjZWxsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTaWxlbnRseSByZW1vdmUgdGhlIGNlbGwgZnJvbSB0aGUgY2VsbHMgY29sbGVjdGlvbi4gU2lsZW50bHksIGJlY2F1c2VcbiAgICAgICAgLy8gYGpvaW50LmRpYS5DZWxsLnByb3RvdHlwZS5yZW1vdmVgIGFscmVhZHkgdHJpZ2dlcnMgdGhlIGByZW1vdmVgIGV2ZW50IHdoaWNoIGlzXG4gICAgICAgIC8vIHRoZW4gcHJvcGFnYXRlZCB0byB0aGUgZ3JhcGggbW9kZWwuIElmIHdlIGRpZG4ndCByZW1vdmUgdGhlIGNlbGwgc2lsZW50bHksIHR3byBgcmVtb3ZlYCBldmVudHNcbiAgICAgICAgLy8gd291bGQgYmUgdHJpZ2dlcmVkIG9uIHRoZSBncmFwaCBtb2RlbC5cbiAgICAgICAgdGhpcy5nZXQoJ2NlbGxzJykucmVtb3ZlKGNlbGwsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2ZlckNlbGxFbWJlZHM6IGZ1bmN0aW9uKHNvdXJjZUNlbGwsIHRhcmdldENlbGwsIG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgYmF0Y2hOYW1lID0gJ3RyYW5zZmVyLWVtYmVkcyc7XG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaChiYXRjaE5hbWUpO1xuXG4gICAgICAgIC8vIEVtYmVkIGNoaWxkcmVuIG9mIHRoZSBzb3VyY2UgY2VsbCBpbiB0aGUgdGFyZ2V0IGNlbGwuXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc291cmNlQ2VsbC5nZXRFbWJlZGRlZENlbGxzKCk7XG4gICAgICAgIHRhcmdldENlbGwuZW1iZWQoY2hpbGRyZW4sIHsgLi4ub3B0LCByZXBhcmVudDogdHJ1ZSB9KTtcblxuICAgICAgICB0aGlzLnN0b3BCYXRjaChiYXRjaE5hbWUpO1xuICAgIH0sXG5cbiAgICB0cmFuc2ZlckNlbGxDb25uZWN0ZWRMaW5rczogZnVuY3Rpb24oc291cmNlQ2VsbCwgdGFyZ2V0Q2VsbCwgb3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCBiYXRjaE5hbWUgPSAndHJhbnNmZXItY29ubmVjdGVkLWxpbmtzJztcbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKGJhdGNoTmFtZSk7XG5cbiAgICAgICAgLy8gUmVjb25uZWN0IGFsbCB0aGUgbGlua3MgY29ubmVjdGVkIHRvIHRoZSBvbGQgY2VsbCB0byB0aGUgbmV3IGNlbGwuXG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZExpbmtzID0gdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhzb3VyY2VDZWxsLCBvcHQpO1xuICAgICAgICBjb25uZWN0ZWRMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChsaW5rLmdldFNvdXJjZUNlbGwoKSA9PT0gc291cmNlQ2VsbCkge1xuICAgICAgICAgICAgICAgIGxpbmsucHJvcChbJ3NvdXJjZScsICdpZCddLCB0YXJnZXRDZWxsLmlkLCBvcHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGluay5nZXRUYXJnZXRDZWxsKCkgPT09IHNvdXJjZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBsaW5rLnByb3AoWyd0YXJnZXQnLCAnaWQnXSwgdGFyZ2V0Q2VsbC5pZCwgb3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goYmF0Y2hOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGEgY2VsbCBieSBgaWRgLlxuICAgIGdldENlbGw6IGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdjZWxscycpLmdldChpZCk7XG4gICAgfSxcblxuICAgIGdldENlbGxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NlbGxzJykudG9BcnJheSgpO1xuICAgIH0sXG5cbiAgICBnZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdjZWxscycpLnRvQXJyYXkoKS5maWx0ZXIoY2VsbCA9PiBjZWxsLmlzRWxlbWVudCgpKTtcbiAgICB9LFxuXG4gICAgZ2V0TGlua3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS50b0FycmF5KCkuZmlsdGVyKGNlbGwgPT4gY2VsbC5pc0xpbmsoKSk7XG4gICAgfSxcblxuICAgIGdldEZpcnN0Q2VsbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdjZWxscycpLmZpcnN0KCk7XG4gICAgfSxcblxuICAgIGdldExhc3RDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NlbGxzJykubGFzdCgpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIGluYm91bmQgYW5kIG91dGJvdW5kIGxpbmtzIGNvbm5lY3RlZCB0byB0aGUgY2VsbCBgbW9kZWxgLlxuICAgIGdldENvbm5lY3RlZExpbmtzOiBmdW5jdGlvbihtb2RlbCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBpbmRpcmVjdCA9IG9wdC5pbmRpcmVjdDtcbiAgICAgICAgdmFyIGluYm91bmQgPSBvcHQuaW5ib3VuZDtcbiAgICAgICAgdmFyIG91dGJvdW5kID0gb3B0Lm91dGJvdW5kO1xuICAgICAgICBpZiAoKGluYm91bmQgPT09IHVuZGVmaW5lZCkgJiYgKG91dGJvdW5kID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpbmJvdW5kID0gb3V0Ym91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGZpbmFsIGFycmF5IG9mIGNvbm5lY3RlZCBsaW5rIG1vZGVsc1xuICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgLy8gYSBoYXNoIHRhYmxlIG9mIGNvbm5lY3RlZCBlZGdlcyBvZiB0aGUgZm9ybTogW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgICAgICAvLyB1c2VkIGZvciBxdWljayBsb29rdXBzIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgYWRkZWQgYSBsaW5rXG4gICAgICAgIHZhciBlZGdlcyA9IHt9O1xuXG4gICAgICAgIGlmIChvdXRib3VuZCkge1xuICAgICAgICAgICAgYWRkT3V0Ym91bmRzKHRoaXMsIG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5ib3VuZCkge1xuICAgICAgICAgICAgYWRkSW5ib3VuZHModGhpcywgbW9kZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkT3V0Ym91bmRzKGdyYXBoLCBtb2RlbCkge1xuICAgICAgICAgICAgdXRpbC5mb3JJbihncmFwaC5nZXRPdXRib3VuZEVkZ2VzKG1vZGVsLmlkKSwgZnVuY3Rpb24oXywgZWRnZSkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgbGlua3MgdGhhdCB3ZXJlIGFscmVhZHkgYWRkZWRcbiAgICAgICAgICAgICAgICAvLyAodGhvc2UgbXVzdCBiZSBzZWxmLWxvb3AgbGlua3MpXG4gICAgICAgICAgICAgICAgLy8gKGJlY2F1c2UgdGhleSBhcmUgaW5ib3VuZCBhbmQgb3V0Ym91bmQgZWRnZXMgb2YgdGhlIHNhbWUgdHdvIGVsZW1lbnRzKVxuICAgICAgICAgICAgICAgIGlmIChlZGdlc1tlZGdlXSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gZ3JhcGguZ2V0Q2VsbChlZGdlKTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgICAgIGVkZ2VzW2VkZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYm91bmQpIGFkZEluYm91bmRzKGdyYXBoLCBsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKSBhZGRPdXRib3VuZHMoZ3JhcGgsIGxpbmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZChncmFwaCkpO1xuICAgICAgICAgICAgaWYgKGluZGlyZWN0ICYmIG1vZGVsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dENlbGwgPSBtb2RlbC5nZXRUYXJnZXRDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKG91dENlbGwgJiYgb3V0Q2VsbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVkZ2VzW291dENlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKG91dENlbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3V0Ym91bmRzKGdyYXBoLCBvdXRDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZEluYm91bmRzKGdyYXBoLCBtb2RlbCkge1xuICAgICAgICAgICAgdXRpbC5mb3JJbihncmFwaC5nZXRJbmJvdW5kRWRnZXMobW9kZWwuaWQpLCBmdW5jdGlvbihfLCBlZGdlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBsaW5rcyB0aGF0IHdlcmUgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgIC8vICh0aG9zZSBtdXN0IGJlIHNlbGYtbG9vcCBsaW5rcylcbiAgICAgICAgICAgICAgICAvLyAoYmVjYXVzZSB0aGV5IGFyZSBpbmJvdW5kIGFuZCBvdXRib3VuZCBlZGdlcyBvZiB0aGUgc2FtZSB0d28gZWxlbWVudHMpXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VdKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSBncmFwaC5nZXRDZWxsKGVkZ2UpO1xuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgZWRnZXNbZWRnZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5ib3VuZCkgYWRkSW5ib3VuZHMoZ3JhcGgsIGxpbmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpIGFkZE91dGJvdW5kcyhncmFwaCwgbGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKGdyYXBoKSk7XG4gICAgICAgICAgICBpZiAoaW5kaXJlY3QgJiYgbW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5DZWxsID0gbW9kZWwuZ2V0U291cmNlQ2VsbCgpO1xuICAgICAgICAgICAgICAgIGlmIChpbkNlbGwgJiYgaW5DZWxsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWRnZXNbaW5DZWxsLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChpbkNlbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5ib3VuZHMoZ3JhcGgsIGluQ2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBgZGVlcGAgb3B0aW9uIGlzIGB0cnVlYCwgY2hlY2sgYWxzbyBhbGwgdGhlIGxpbmtzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byBhbnkgb2YgdGhlIGRlc2NlbmRhbnQgY2VsbHNcbiAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG5cbiAgICAgICAgICAgIHZhciBlbWJlZGRlZENlbGxzID0gbW9kZWwuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIC8vIGluIHRoZSBmaXJzdCByb3VuZCwgd2UgY29sbGVjdCBhbGwgdGhlIGVtYmVkZGVkIGVsZW1lbnRzXG4gICAgICAgICAgICB2YXIgZW1iZWRkZWRFbGVtZW50cyA9IHt9O1xuICAgICAgICAgICAgZW1iZWRkZWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5pc0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBlbWJlZGRlZEVsZW1lbnRzW2NlbGwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZW1iZWRkZWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbC5pc0xpbmsoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmZvckluKHRoaXMuZ2V0T3V0Ym91bmRFZGdlcyhjZWxsLmlkKSwgZnVuY3Rpb24oZXhpc3RzLCBlZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVkZ2VzW2VkZ2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VDZWxsID0gdGhpcy5nZXRDZWxsKGVkZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBlZGdlQ2VsbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VJZCA9IHNvdXJjZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SWQgPSB0YXJnZXQuaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBgaW5jbHVkZUVuY2xvc2VkYCBvcHRpb24gaXMgZmFsc3ksIHNraXAgZW5jbG9zZWQgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdC5pbmNsdWRlRW5jbG9zZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHNvdXJjZUlkICYmIGVtYmVkZGVkRWxlbWVudHNbc291cmNlSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAodGFyZ2V0SWQgJiYgZW1iZWRkZWRFbGVtZW50c1t0YXJnZXRJZF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHRoaXMuZ2V0Q2VsbChlZGdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbZWRnZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmZvckluKHRoaXMuZ2V0SW5ib3VuZEVkZ2VzKGNlbGwuaWQpLCBmdW5jdGlvbihleGlzdHMsIGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWRnZXNbZWRnZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZUNlbGwgPSB0aGlzLmdldENlbGwoZWRnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGVkZ2VDZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gc291cmNlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJZCA9IHRhcmdldC5pZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGBpbmNsdWRlRW5jbG9zZWRgIG9wdGlvbiBpcyBmYWxzeSwgc2tpcCBlbmNsb3NlZCBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0LmluY2x1ZGVFbmNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc291cmNlSWQgJiYgZW1iZWRkZWRFbGVtZW50c1tzb3VyY2VJZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0YXJnZXRJZCAmJiBlbWJlZGRlZEVsZW1lbnRzW3RhcmdldElkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2godGhpcy5nZXRDZWxsKGVkZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1tlZGdlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgfSxcblxuICAgIGdldE5laWdoYm9yczogZnVuY3Rpb24obW9kZWwsIG9wdCkge1xuXG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuXG4gICAgICAgIHZhciBpbmJvdW5kID0gb3B0LmluYm91bmQ7XG4gICAgICAgIHZhciBvdXRib3VuZCA9IG9wdC5vdXRib3VuZDtcbiAgICAgICAgaWYgKGluYm91bmQgPT09IHVuZGVmaW5lZCAmJiBvdXRib3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmJvdW5kID0gb3V0Ym91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuZ2V0Q29ubmVjdGVkTGlua3MobW9kZWwsIG9wdCkucmVkdWNlKGZ1bmN0aW9uKHJlcywgbGluaykge1xuXG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdmFyIGxvb3AgPSBsaW5rLmhhc0xvb3Aob3B0KTtcblxuICAgICAgICAgICAgLy8gRGlzY2FyZCBpZiBpdCBpcyBhIHBvaW50LCBvciBpZiB0aGUgbmVpZ2hib3Igd2FzIGFscmVhZHkgYWRkZWQuXG4gICAgICAgICAgICBpZiAoaW5ib3VuZCAmJiB1dGlsLmhhcyhzb3VyY2UsICdpZCcpICYmICFyZXNbc291cmNlLmlkXSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUVsZW1lbnQgPSB0aGlzLmdldENlbGwoc291cmNlLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5pc0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcCB8fCAoc291cmNlRWxlbWVudCAmJiBzb3VyY2VFbGVtZW50ICE9PSBtb2RlbCAmJiAoIW9wdC5kZWVwIHx8ICFzb3VyY2VFbGVtZW50LmlzRW1iZWRkZWRJbihtb2RlbCkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW3NvdXJjZS5pZF0gPSBzb3VyY2VFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIGlmIGl0IGlzIGEgcG9pbnQsIG9yIGlmIHRoZSBuZWlnaGJvciB3YXMgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgICAgIGlmIChvdXRib3VuZCAmJiB1dGlsLmhhcyh0YXJnZXQsICdpZCcpICYmICFyZXNbdGFyZ2V0LmlkXSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldENlbGwodGFyZ2V0LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC5pc0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcCB8fCAodGFyZ2V0RWxlbWVudCAmJiB0YXJnZXRFbGVtZW50ICE9PSBtb2RlbCAmJiAoIW9wdC5kZWVwIHx8ICF0YXJnZXRFbGVtZW50LmlzRW1iZWRkZWRJbihtb2RlbCkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW3RhcmdldC5pZF0gPSB0YXJnZXRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LmJpbmQodGhpcyksIHt9KTtcblxuICAgICAgICBpZiAobW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgIGlmIChpbmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNlbGwgPSBtb2RlbC5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUNlbGwgJiYgc291cmNlQ2VsbC5pc0VsZW1lbnQoKSAmJiAhbmVpZ2hib3JzW3NvdXJjZUNlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yc1tzb3VyY2VDZWxsLmlkXSA9IHNvdXJjZUNlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldENlbGwgPSBtb2RlbC5nZXRUYXJnZXRDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldENlbGwgJiYgdGFyZ2V0Q2VsbC5pc0VsZW1lbnQoKSAmJiAhbmVpZ2hib3JzW3RhcmdldENlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG5laWdoYm9yc1t0YXJnZXRDZWxsLmlkXSA9IHRhcmdldENlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwudG9BcnJheShuZWlnaGJvcnMpO1xuICAgIH0sXG5cbiAgICBnZXRDb21tb25BbmNlc3RvcjogZnVuY3Rpb24oLyogY2VsbHMgKi8pIHtcblxuICAgICAgICB2YXIgY2VsbHNBbmNlc3RvcnMgPSBBcnJheS5mcm9tKGFyZ3VtZW50cykubWFwKGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBhcmVudElkID0gY2VsbC5nZXQoJ3BhcmVudCcpO1xuXG4gICAgICAgICAgICB3aGlsZSAocGFyZW50SWQpIHtcblxuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRJZCA9IHRoaXMuZ2V0Q2VsbChwYXJlbnRJZCkuZ2V0KCdwYXJlbnQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFuY2VzdG9ycztcblxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBjZWxsc0FuY2VzdG9ycyA9IGNlbGxzQW5jZXN0b3JzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBjb21tb25BbmNlc3RvciA9IHV0aWwudG9BcnJheShjZWxsc0FuY2VzdG9ycy5zaGlmdCgpKS5maW5kKGZ1bmN0aW9uKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbHNBbmNlc3RvcnMuZXZlcnkoZnVuY3Rpb24oY2VsbEFuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsQW5jZXN0b3JzLmluY2x1ZGVzKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsKGNvbW1vbkFuY2VzdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgd2hvbGUgYnJhbmNoIHN0YXJ0aW5nIGF0IGBlbGVtZW50YC5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgdG9vLlxuICAgIC8vIElmIGBvcHQuYnJlYWR0aEZpcnN0YCBpcyBgdHJ1ZWAsIHVzZSB0aGUgQnJlYWR0aC1maXJzdCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2UgdXNlIERlcHRoLWZpcnN0IHNlYXJjaC5cbiAgICBnZXRTdWNjZXNzb3JzOiBmdW5jdGlvbihlbGVtZW50LCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgLy8gTW9kaWZ5IHRoZSBvcHRpb25zIHNvIHRoYXQgaXQgaW5jbHVkZXMgdGhlIGBvdXRib3VuZGAgbmVpZ2hib3JzIG9ubHkuIEluIG90aGVyIHdvcmRzLCBzZWFyY2ggZm9yd2FyZHMuXG4gICAgICAgIHRoaXMuc2VhcmNoKGVsZW1lbnQsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHV0aWwuYXNzaWduKHt9LCBvcHQsIHsgb3V0Ym91bmQ6IHRydWUgfSkpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICBjbG9uZUNlbGxzOiBjbG9uZUNlbGxzLFxuICAgIC8vIENsb25lIHRoZSB3aG9sZSBzdWJncmFwaCAoaW5jbHVkaW5nIGFsbCB0aGUgY29ubmVjdGVkIGxpbmtzIHdob3NlIHNvdXJjZS90YXJnZXQgaXMgaW4gdGhlIHN1YmdyYXBoKS5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgYWxzbyB0YWtlIGludG8gYWNjb3VudCBhbGwgdGhlIGVtYmVkZGVkIGNlbGxzIG9mIGFsbCB0aGUgc3ViZ3JhcGggY2VsbHMuXG4gICAgLy8gUmV0dXJuIGEgbWFwIG9mIHRoZSBmb3JtOiBbb3JpZ2luYWwgY2VsbCBJRF0gLT4gW2Nsb25lXS5cbiAgICBjbG9uZVN1YmdyYXBoOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG5cbiAgICAgICAgdmFyIHN1YmdyYXBoID0gdGhpcy5nZXRTdWJncmFwaChjZWxscywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVDZWxscyhzdWJncmFwaCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgY2VsbHNgIGFuZCBhbGwgdGhlIGNvbm5lY3RlZCBsaW5rcyB0aGF0IGNvbm5lY3QgY2VsbHMgaW4gdGhlIGBjZWxsc2AgYXJyYXkuXG4gICAgLy8gSWYgYG9wdC5kZWVwYCBpcyBgdHJ1ZWAsIHJldHVybiBhbGwgdGhlIGNlbGxzIGluY2x1ZGluZyBhbGwgdGhlaXIgZW1iZWRkZWQgY2VsbHNcbiAgICAvLyBhbmQgYWxsIHRoZSBsaW5rcyB0aGF0IGNvbm5lY3QgYW55IG9mIHRoZSByZXR1cm5lZCBjZWxscy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgZm9yIGEgc2luZ2xlIHNoYWxsb3cgZWxlbWVudCwgdGhlIHJlc3VsdCBpcyB0aGF0IHZlcnkgc2FtZSBlbGVtZW50LlxuICAgIC8vIEZvciB0d28gZWxlbWVudHMgY29ubmVjdGVkIHdpdGggYSBsaW5rOiBgQSAtLS0gTCAtLS0+IEJgLCB0aGUgcmVzdWx0IGZvclxuICAgIC8vIGBnZXRTdWJncmFwaChbQSwgQl0pYCBpcyBgW0EsIEwsIEJdYC4gVGhlIHNhbWUgZ29lcyBmb3IgYGdldFN1YmdyYXBoKFtMXSlgLCB0aGUgcmVzdWx0IGlzIGFnYWluIGBbQSwgTCwgQl1gLlxuICAgIGdldFN1YmdyYXBoOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBzdWJncmFwaCA9IFtdO1xuICAgICAgICAvLyBgY2VsbE1hcGAgaXMgdXNlZCBmb3IgYSBxdWljayBsb29rdXAgb2YgZXhpc3RlbmNlIG9mIGEgY2VsbCBpbiB0aGUgYGNlbGxzYCBhcnJheS5cbiAgICAgICAgdmFyIGNlbGxNYXAgPSB7fTtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuXG4gICAgICAgIHV0aWwudG9BcnJheShjZWxscykuZm9yRWFjaChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICBpZiAoIWNlbGxNYXBbY2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgICAgIGNlbGxNYXBbY2VsbC5pZF0gPSBjZWxsO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHQuZGVlcCkge1xuICAgICAgICAgICAgICAgIHZhciBlbWJlZHMgPSBjZWxsLmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGVtYmVkcy5mb3JFYWNoKGZ1bmN0aW9uKGVtYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2VsbE1hcFtlbWJlZC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLnB1c2goZW1iZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE1hcFtlbWJlZC5pZF0gPSBlbWJlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbWJlZC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2goZW1iZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVtYmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgIC8vIEZvciBsaW5rcywgcmV0dXJuIHRoZWlyIHNvdXJjZSAmIHRhcmdldCAoaWYgdGhleSBhcmUgZWxlbWVudHMgLSBub3QgcG9pbnRzKS5cbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBpZiAoc291cmNlLmlkICYmICFjZWxsTWFwW3NvdXJjZS5pZF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRWxlbWVudCA9IHRoaXMuZ2V0Q2VsbChzb3VyY2UuaWQpO1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY2VsbE1hcFtzb3VyY2VFbGVtZW50LmlkXSA9IHNvdXJjZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXQuaWQgJiYgIWNlbGxNYXBbdGFyZ2V0LmlkXSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gdGhpcy5nZXRDZWxsKHRhcmdldC5pZCk7XG4gICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaCh0aGlzLmdldENlbGwodGFyZ2V0LmlkKSk7XG4gICAgICAgICAgICAgICAgY2VsbE1hcFt0YXJnZXRFbGVtZW50LmlkXSA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBGb3IgZWxlbWVudHMsIGluY2x1ZGUgdGhlaXIgY29ubmVjdGVkIGxpbmtzIGlmIHRoZWlyIHNvdXJjZS90YXJnZXQgaXMgaW4gdGhlIHN1YmdyYXBoO1xuICAgICAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhlbGVtZW50LCBvcHQpO1xuICAgICAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGxNYXBbbGluay5pZF0gJiYgc291cmNlLmlkICYmIGNlbGxNYXBbc291cmNlLmlkXSAmJiB0YXJnZXQuaWQgJiYgY2VsbE1hcFt0YXJnZXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxNYXBbbGluay5pZF0gPSBsaW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gc3ViZ3JhcGg7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIHRoZSBwcmVkZWNlc3NvcnMgb2YgYGVsZW1lbnRgLiBUaGlzIGlzIGEgcmV2ZXJzZSBvcGVyYXRpb24gb2YgYGdldFN1Y2Nlc3NvcnMoKWAuXG4gICAgLy8gSWYgYG9wdC5kZWVwYCBpcyBgdHJ1ZWAsIHRha2UgaW50byBhY2NvdW50IGVtYmVkZGVkIGVsZW1lbnRzIHRvby5cbiAgICAvLyBJZiBgb3B0LmJyZWFkdGhGaXJzdGAgaXMgYHRydWVgLCB1c2UgdGhlIEJyZWFkdGgtZmlyc3Qgc2VhcmNoIGFsZ29yaXRobSwgb3RoZXJ3aXNlIHVzZSBEZXB0aC1maXJzdCBzZWFyY2guXG4gICAgZ2V0UHJlZGVjZXNzb3JzOiBmdW5jdGlvbihlbGVtZW50LCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgLy8gTW9kaWZ5IHRoZSBvcHRpb25zIHNvIHRoYXQgaXQgaW5jbHVkZXMgdGhlIGBpbmJvdW5kYCBuZWlnaGJvcnMgb25seS4gSW4gb3RoZXIgd29yZHMsIHNlYXJjaCBiYWNrd2FyZHMuXG4gICAgICAgIHRoaXMuc2VhcmNoKGVsZW1lbnQsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHV0aWwuYXNzaWduKHt9LCBvcHQsIHsgaW5ib3VuZDogdHJ1ZSB9KSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIC8vIFBlcmZvcm0gc2VhcmNoIG9uIHRoZSBncmFwaC5cbiAgICAvLyBJZiBgb3B0LmJyZWFkdGhGaXJzdGAgaXMgYHRydWVgLCB1c2UgdGhlIEJyZWFkdGgtZmlyc3QgU2VhcmNoIGFsZ29yaXRobSwgb3RoZXJ3aXNlIHVzZSBEZXB0aC1maXJzdCBzZWFyY2guXG4gICAgLy8gQnkgc2V0dGluZyBgb3B0LmluYm91bmRgIHRvIGB0cnVlYCwgeW91IGNhbiByZXZlcnNlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlYXJjaC5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgdG9vLlxuICAgIC8vIGBpdGVyYXRlZWAgaXMgYSBmdW5jdGlvbiBvZiB0aGUgZm9ybSBgZnVuY3Rpb24oZWxlbWVudCkge31gLlxuICAgIC8vIElmIGBpdGVyYXRlZWAgZXhwbGljaXRseSByZXR1cm5zIGBmYWxzZWAsIHRoZSBzZWFyY2hpbmcgc3RvcHMuXG4gICAgc2VhcmNoOiBmdW5jdGlvbihlbGVtZW50LCBpdGVyYXRlZSwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICBpZiAob3B0LmJyZWFkdGhGaXJzdCkge1xuICAgICAgICAgICAgdGhpcy5iZnMoZWxlbWVudCwgaXRlcmF0ZWUsIG9wdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRmcyhlbGVtZW50LCBpdGVyYXRlZSwgb3B0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBCcmVhZHRoLWZpcnN0IHNlYXJjaC5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgdG9vLlxuICAgIC8vIElmIGBvcHQuaW5ib3VuZGAgaXMgYHRydWVgLCByZXZlcnNlIHRoZSBzZWFyY2ggZGlyZWN0aW9uIChpdCdzIGxpa2UgcmV2ZXJzaW5nIGFsbCB0aGUgbGluayBkaXJlY3Rpb25zKS5cbiAgICAvLyBgaXRlcmF0ZWVgIGlzIGEgZnVuY3Rpb24gb2YgdGhlIGZvcm0gYGZ1bmN0aW9uKGVsZW1lbnQsIGRpc3RhbmNlKSB7fWAuXG4gICAgLy8gd2hlcmUgYGVsZW1lbnRgIGlzIHRoZSBjdXJyZW50bHkgdmlzaXRlZCBlbGVtZW50IGFuZCBgZGlzdGFuY2VgIGlzIHRoZSBkaXN0YW5jZSBvZiB0aGF0IGVsZW1lbnRcbiAgICAvLyBmcm9tIHRoZSByb290IGBlbGVtZW50YCBwYXNzZWQgdGhlIGBiZnMoKWAsIGkuZS4gdGhlIGVsZW1lbnQgd2Ugc3RhcnRlZCB0aGUgc2VhcmNoIGZyb20uXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBgZGlzdGFuY2VgIGlzIG5vdCB0aGUgc2hvcnRlc3Qgb3IgbG9uZ2VzdCBkaXN0YW5jZSwgaXQgaXMgc2ltcGx5IHRoZSBudW1iZXIgb2YgbGV2ZWxzXG4gICAgLy8gY3Jvc3NlZCB0aWxsIHdlIHZpc2l0ZWQgdGhlIGBlbGVtZW50YCBmb3IgdGhlIGZpcnN0IHRpbWUuIEl0IGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciB0cmVlIGdyYXBocy5cbiAgICAvLyBJZiBgaXRlcmF0ZWVgIGV4cGxpY2l0bHkgcmV0dXJucyBgZmFsc2VgLCB0aGUgc2VhcmNoaW5nIHN0b3BzLlxuICAgIGJmczogZnVuY3Rpb24oZWxlbWVudCwgaXRlcmF0ZWUsIG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHt9O1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuXG4gICAgICAgIHF1ZXVlLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGRpc3RhbmNlW2VsZW1lbnQuaWRdID0gMDtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbbmV4dC5pZF0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmlzaXRlZFtuZXh0LmlkXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUuY2FsbCh0aGlzLCBuZXh0LCBkaXN0YW5jZVtuZXh0LmlkXSkgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IHRoaXMuZ2V0TmVpZ2hib3JzKG5leHQsIG9wdCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVtuZWlnaGJvci5pZF0gPSBkaXN0YW5jZVtuZXh0LmlkXSArIDE7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRGVwdGgtZmlyc3Qgc2VhcmNoLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gSWYgYG9wdC5pbmJvdW5kYCBpcyBgdHJ1ZWAsIHJldmVyc2UgdGhlIHNlYXJjaCBkaXJlY3Rpb24gKGl0J3MgbGlrZSByZXZlcnNpbmcgYWxsIHRoZSBsaW5rIGRpcmVjdGlvbnMpLlxuICAgIC8vIGBpdGVyYXRlZWAgaXMgYSBmdW5jdGlvbiBvZiB0aGUgZm9ybSBgZnVuY3Rpb24oZWxlbWVudCwgZGlzdGFuY2UpIHt9YC5cbiAgICAvLyBJZiBgaXRlcmF0ZWVgIGV4cGxpY2l0bHkgcmV0dXJucyBgZmFsc2VgLCB0aGUgc2VhcmNoIHN0b3BzLlxuICAgIGRmczogZnVuY3Rpb24oZWxlbWVudCwgaXRlcmF0ZWUsIG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHt9O1xuICAgICAgICBjb25zdCBxdWV1ZSA9IFtdO1xuXG4gICAgICAgIHF1ZXVlLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGRpc3RhbmNlW2VsZW1lbnQuaWRdID0gMDtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHZpc2l0ZWRbbmV4dC5pZF0pIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmlzaXRlZFtuZXh0LmlkXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUuY2FsbCh0aGlzLCBuZXh0LCBkaXN0YW5jZVtuZXh0LmlkXSkgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IHRoaXMuZ2V0TmVpZ2hib3JzKG5leHQsIG9wdCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBxdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVtuZWlnaGJvci5pZF0gPSBkaXN0YW5jZVtuZXh0LmlkXSArIDE7XG4gICAgICAgICAgICAgICAgcXVldWUuc3BsaWNlKGxhc3RJbmRleCwgMCwgbmVpZ2hib3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgdGhlIHJvb3RzIG9mIHRoZSBncmFwaC4gVGltZSBjb21wbGV4aXR5OiBPKHxWfCkuXG4gICAgZ2V0U291cmNlczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdXRpbC5mb3JJbih0aGlzLl9ub2RlcywgZnVuY3Rpb24oZXhpc3RzLCBub2RlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luW25vZGVdIHx8IHV0aWwuaXNFbXB0eSh0aGlzLl9pbltub2RlXSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5nZXRDZWxsKG5vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZXM7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgdGhlIGxlYWZzIG9mIHRoZSBncmFwaC4gVGltZSBjb21wbGV4aXR5OiBPKHxWfCkuXG4gICAgZ2V0U2lua3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzaW5rcyA9IFtdO1xuICAgICAgICB1dGlsLmZvckluKHRoaXMuX25vZGVzLCBmdW5jdGlvbihleGlzdHMsIG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3V0W25vZGVdIHx8IHV0aWwuaXNFbXB0eSh0aGlzLl9vdXRbbm9kZV0pKSB7XG4gICAgICAgICAgICAgICAgc2lua3MucHVzaCh0aGlzLmdldENlbGwobm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gc2lua3M7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaWYgYGVsZW1lbnRgIGlzIGEgcm9vdC4gVGltZSBjb21wbGV4aXR5OiBPKDEpLlxuICAgIGlzU291cmNlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cbiAgICAgICAgcmV0dXJuICF0aGlzLl9pbltlbGVtZW50LmlkXSB8fCB1dGlsLmlzRW1wdHkodGhpcy5faW5bZWxlbWVudC5pZF0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYHRydWVgIGlmIGBlbGVtZW50YCBpcyBhIGxlYWYuIFRpbWUgY29tcGxleGl0eTogTygxKS5cbiAgICBpc1Npbms6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgICByZXR1cm4gIXRoaXMuX291dFtlbGVtZW50LmlkXSB8fCB1dGlsLmlzRW1wdHkodGhpcy5fb3V0W2VsZW1lbnQuaWRdKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpcyBgZWxlbWVudEJgIGlzIGEgc3VjY2Vzc29yIG9mIGBlbGVtZW50QWAuIFJldHVybiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICBpc1N1Y2Nlc3NvcjogZnVuY3Rpb24oZWxlbWVudEEsIGVsZW1lbnRCKSB7XG5cbiAgICAgICAgdmFyIGlzU3VjY2Vzc29yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VhcmNoKGVsZW1lbnRBLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gZWxlbWVudEIgJiYgZWxlbWVudCAhPT0gZWxlbWVudEEpIHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3NvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IG91dGJvdW5kOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gaXNTdWNjZXNzb3I7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaXMgYGVsZW1lbnRCYCBpcyBhIHByZWRlY2Vzc29yIG9mIGBlbGVtZW50QWAuIFJldHVybiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICBpc1ByZWRlY2Vzc29yOiBmdW5jdGlvbihlbGVtZW50QSwgZWxlbWVudEIpIHtcblxuICAgICAgICB2YXIgaXNQcmVkZWNlc3NvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlYXJjaChlbGVtZW50QSwgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGVsZW1lbnRCICYmIGVsZW1lbnQgIT09IGVsZW1lbnRBKSB7XG4gICAgICAgICAgICAgICAgaXNQcmVkZWNlc3NvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IGluYm91bmQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBpc1ByZWRlY2Vzc29yO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYHRydWVgIGlzIGBlbGVtZW50QmAgaXMgYSBuZWlnaGJvciBvZiBgZWxlbWVudEFgLiBSZXR1cm4gYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgLy8gYG9wdC5kZWVwYCBjb250cm9scyB3aGV0aGVyIHRvIHRha2UgaW50byBhY2NvdW50IGVtYmVkZGVkIGVsZW1lbnRzIGFzIHdlbGwuIFNlZSBgZ2V0TmVpZ2hib3JzKClgXG4gICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBJZiBgb3B0Lm91dGJvdW5kYCBpcyBzZXQgdG8gYHRydWVgLCByZXR1cm4gYHRydWVgIG9ubHkgaWYgYGVsZW1lbnRCYCBpcyBhIHN1Y2Nlc3NvciBuZWlnaGJvci5cbiAgICAvLyBTaW1pbGFybHksIGlmIGBvcHQuaW5ib3VuZGAgaXMgc2V0IHRvIGB0cnVlYCwgcmV0dXJuIGB0cnVlYCBvbmx5IGlmIGBlbGVtZW50QmAgaXMgYSBwcmVkZWNlc3NvciBuZWlnaGJvci5cbiAgICBpc05laWdoYm9yOiBmdW5jdGlvbihlbGVtZW50QSwgZWxlbWVudEIsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgaW5ib3VuZCA9IG9wdC5pbmJvdW5kO1xuICAgICAgICB2YXIgb3V0Ym91bmQgPSBvcHQub3V0Ym91bmQ7XG4gICAgICAgIGlmICgoaW5ib3VuZCA9PT0gdW5kZWZpbmVkKSAmJiAob3V0Ym91bmQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGluYm91bmQgPSBvdXRib3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNOZWlnaGJvciA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZ2V0Q29ubmVjdGVkTGlua3MoZWxlbWVudEEsIG9wdCkuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgaXQgaXMgYSBwb2ludC5cbiAgICAgICAgICAgIGlmIChpbmJvdW5kICYmIHV0aWwuaGFzKHNvdXJjZSwgJ2lkJykgJiYgKHNvdXJjZS5pZCA9PT0gZWxlbWVudEIuaWQpKSB7XG4gICAgICAgICAgICAgICAgaXNOZWlnaGJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIGlmIGl0IGlzIGEgcG9pbnQsIG9yIGlmIHRoZSBuZWlnaGJvciB3YXMgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgICAgIGlmIChvdXRib3VuZCAmJiB1dGlsLmhhcyh0YXJnZXQsICdpZCcpICYmICh0YXJnZXQuaWQgPT09IGVsZW1lbnRCLmlkKSkge1xuICAgICAgICAgICAgICAgIGlzTmVpZ2hib3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlzTmVpZ2hib3I7XG4gICAgfSxcblxuICAgIC8vIERpc2Nvbm5lY3QgbGlua3MgY29ubmVjdGVkIHRvIHRoZSBjZWxsIGBtb2RlbGAuXG4gICAgZGlzY29ubmVjdExpbmtzOiBmdW5jdGlvbihtb2RlbCwgb3B0KSB7XG5cbiAgICAgICAgdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhtb2RlbCkuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgICAgIGxpbmsuc2V0KChsaW5rLmF0dHJpYnV0ZXMuc291cmNlLmlkID09PSBtb2RlbC5pZCA/ICdzb3VyY2UnIDogJ3RhcmdldCcpLCB7IHg6IDAsIHk6IDAgfSwgb3B0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBsaW5rcyBjb25uZWN0ZWQgdG8gdGhlIGNlbGwgYG1vZGVsYCBjb21wbGV0ZWx5LlxuICAgIHJlbW92ZUxpbmtzOiBmdW5jdGlvbihtb2RlbCwgb3B0KSB7XG5cbiAgICAgICAgdXRpbC5pbnZva2UodGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhtb2RlbCksICdyZW1vdmUnLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCBjZWxscyBhdCBnaXZlbiBwb2ludFxuXG4gICAgZmluZEVsZW1lbnRzQXRQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyQXRQb2ludCh0aGlzLmdldEVsZW1lbnRzKCksIHBvaW50LCBvcHQpO1xuICAgIH0sXG5cbiAgICBmaW5kTGlua3NBdFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJBdFBvaW50KHRoaXMuZ2V0TGlua3MoKSwgcG9pbnQsIG9wdCk7XG4gICAgfSxcblxuICAgIGZpbmRDZWxsc0F0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckF0UG9pbnQodGhpcy5nZXRDZWxscygpLCBwb2ludCwgb3B0KTtcbiAgICB9LFxuXG4gICAgX2ZpbHRlckF0UG9pbnQ6IGZ1bmN0aW9uKGNlbGxzLCBwb2ludCwgb3B0ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIGNlbGxzLmZpbHRlcihlbCA9PiBlbC5nZXRCQm94KHsgcm90YXRlOiB0cnVlIH0pLmNvbnRhaW5zUG9pbnQocG9pbnQsIG9wdCkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCBjZWxscyBpbiBnaXZlbiBhcmVhXG5cbiAgICBmaW5kRWxlbWVudHNJbkFyZWE6IGZ1bmN0aW9uKGFyZWEsIG9wdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJJbkFyZWEodGhpcy5nZXRFbGVtZW50cygpLCBhcmVhLCBvcHQpO1xuICAgIH0sXG5cbiAgICBmaW5kTGlua3NJbkFyZWE6IGZ1bmN0aW9uKGFyZWEsIG9wdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJJbkFyZWEodGhpcy5nZXRMaW5rcygpLCBhcmVhLCBvcHQpO1xuICAgIH0sXG5cbiAgICBmaW5kQ2VsbHNJbkFyZWE6IGZ1bmN0aW9uKGFyZWEsIG9wdCA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJJbkFyZWEodGhpcy5nZXRDZWxscygpLCBhcmVhLCBvcHQpO1xuICAgIH0sXG5cbiAgICBfZmlsdGVySW5BcmVhOiBmdW5jdGlvbihjZWxscywgYXJlYSwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgciA9IG5ldyBnLlJlY3QoYXJlYSk7XG4gICAgICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdDtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gc3RyaWN0ID8gJ2NvbnRhaW5zUmVjdCcgOiAnaW50ZXJzZWN0JztcbiAgICAgICAgcmV0dXJuIGNlbGxzLmZpbHRlcihlbCA9PiByW21ldGhvZF0oZWwuZ2V0QkJveCh7IHJvdGF0ZTogdHJ1ZSB9KSkpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFsbCBjZWxscyB1bmRlciB0aGUgZ2l2ZW4gZWxlbWVudC5cblxuICAgIGZpbmRFbGVtZW50c1VuZGVyRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDZWxsc1VuZGVyRWxlbWVudCh0aGlzLmdldEVsZW1lbnRzKCksIGVsZW1lbnQsIG9wdCk7XG4gICAgfSxcblxuICAgIGZpbmRMaW5rc1VuZGVyRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDZWxsc1VuZGVyRWxlbWVudCh0aGlzLmdldExpbmtzKCksIGVsZW1lbnQsIG9wdCk7XG4gICAgfSxcblxuICAgIGZpbmRDZWxsc1VuZGVyRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDZWxsc1VuZGVyRWxlbWVudCh0aGlzLmdldENlbGxzKCksIGVsZW1lbnQsIG9wdCk7XG4gICAgfSxcblxuICAgIF9pc1ZhbGlkRWxlbWVudFVuZGVyRWxlbWVudDogZnVuY3Rpb24oZWwxLCBlbDIpIHtcbiAgICAgICAgcmV0dXJuIGVsMS5pZCAhPT0gZWwyLmlkICYmICFlbDEuaXNFbWJlZGRlZEluKGVsMik7XG4gICAgfSxcblxuICAgIF9pc1ZhbGlkTGlua1VuZGVyRWxlbWVudDogZnVuY3Rpb24obGluaywgZWwpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGxpbmsuc291cmNlKCkuaWQgIT09IGVsLmlkICYmXG4gICAgICAgICAgICBsaW5rLnRhcmdldCgpLmlkICE9PSBlbC5pZCAmJlxuICAgICAgICAgICAgIWxpbmsuaXNFbWJlZGRlZEluKGVsKVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfdmFsaWRhdGVDZWxsc1VuZGVyRWxlbWVudDogZnVuY3Rpb24oY2VsbHMsIGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNlbGxzLmZpbHRlcihjZWxsID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmlzTGluaygpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9pc1ZhbGlkTGlua1VuZGVyRWxlbWVudChjZWxsLCBlbGVtZW50KVxuICAgICAgICAgICAgICAgIDogdGhpcy5faXNWYWxpZEVsZW1lbnRVbmRlckVsZW1lbnQoY2VsbCwgZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0RmluZFVuZGVyRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihlbGVtZW50LCBzZWFyY2hCeSA9ICdiYm94Jykge1xuICAgICAgICBjb25zdCBiYm94ID0gZWxlbWVudC5nZXRCQm94KHsgcm90YXRlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gKHNlYXJjaEJ5ICE9PSAnYmJveCcpID8gdXRpbC5nZXRSZWN0UG9pbnQoYmJveCwgc2VhcmNoQnkpIDogYmJveDtcbiAgICB9LFxuXG4gICAgX2ZpbHRlckNlbGxzVW5kZXJFbGVtZW50OiBmdW5jdGlvbihjZWxscywgZWxlbWVudCwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSB0aGlzLl9nZXRGaW5kVW5kZXJFbGVtZW50R2VvbWV0cnkoZWxlbWVudCwgb3B0LnNlYXJjaEJ5KTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRDZWxscyA9IChnZW9tZXRyeS50eXBlID09PSBnLnR5cGVzLlBvaW50KVxuICAgICAgICAgICAgPyB0aGlzLl9maWx0ZXJBdFBvaW50KGNlbGxzLCBnZW9tZXRyeSlcbiAgICAgICAgICAgIDogdGhpcy5fZmlsdGVySW5BcmVhKGNlbGxzLCBnZW9tZXRyeSwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlQ2VsbHNVbmRlckVsZW1lbnQoZmlsdGVyZWRDZWxscywgZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8vIEBkZXByZWNhdGVkIHVzZSBgZmluZEVsZW1lbnRzSW5BcmVhYCBpbnN0ZWFkXG4gICAgZmluZE1vZGVsc0luQXJlYTogZnVuY3Rpb24oYXJlYSwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50c0luQXJlYShhcmVhLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBAZGVwcmVjYXRlZCB1c2UgYGZpbmRFbGVtZW50c0F0UG9pbnRgIGluc3RlYWRcbiAgICBmaW5kTW9kZWxzRnJvbVBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kRWxlbWVudHNBdFBvaW50KHBvaW50KTtcbiAgICB9LFxuXG4gICAgLy8gQGRlcHJlY2F0ZWQgdXNlIGBmaW5kTW9kZWxzVW5kZXJFbGVtZW50YCBpbnN0ZWFkXG4gICAgZmluZE1vZGVsc1VuZGVyRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50c1VuZGVyRWxlbWVudChlbGVtZW50LCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYm91bmRpbmcgYm94IG9mIGFsbCBlbGVtZW50cy5cbiAgICBnZXRCQm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZWxsc0JCb3godGhpcy5nZXRDZWxscygpKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBib3VuZGluZyBib3ggb2YgYWxsIGNlbGxzIGluIGFycmF5IHByb3ZpZGVkLlxuICAgIGdldENlbGxzQkJveDogZnVuY3Rpb24oY2VsbHMsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcm90YXRlID0gdHJ1ZSB9ID0gb3B0O1xuICAgICAgICByZXR1cm4gdXRpbC50b0FycmF5KGNlbGxzKS5yZWR1Y2UoZnVuY3Rpb24obWVtbywgY2VsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IGNlbGwuZ2V0QkJveCh7IHJvdGF0ZSB9KTtcbiAgICAgICAgICAgIGlmICghcmVjdCkgcmV0dXJuIG1lbW87XG4gICAgICAgICAgICBpZiAobWVtbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZW1vLnVuaW9uKHJlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sIG51bGwpO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGR4LCBkeSwgb3B0KSB7XG5cbiAgICAgICAgLy8gRG9uJ3QgdHJhbnNsYXRlIGNlbGxzIHRoYXQgYXJlIGVtYmVkZGVkIGluIGFueSBvdGhlciBjZWxsLlxuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLmdldENlbGxzKCkuZmlsdGVyKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiAhY2VsbC5pc0VtYmVkZGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHV0aWwuaW52b2tlKGNlbGxzLCAndHJhbnNsYXRlJywgZHgsIGR5LCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc2l6ZUNlbGxzKHdpZHRoLCBoZWlnaHQsIHRoaXMuZ2V0Q2VsbHMoKSwgb3B0KTtcbiAgICB9LFxuXG4gICAgcmVzaXplQ2VsbHM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGNlbGxzLCBvcHQpIHtcblxuICAgICAgICAvLyBgZ2V0QkJveGAgbWV0aG9kIHJldHVybnMgYG51bGxgIGlmIG5vIGVsZW1lbnRzIHByb3ZpZGVkLlxuICAgICAgICAvLyBpLmUuIGNlbGxzIGNhbiBiZSBhbiBhcnJheSBvZiBsaW5rc1xuICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0Q2VsbHNCQm94KGNlbGxzKTtcbiAgICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgICAgIHZhciBzeCA9IE1hdGgubWF4KHdpZHRoIC8gYmJveC53aWR0aCwgMCk7XG4gICAgICAgICAgICB2YXIgc3kgPSBNYXRoLm1heChoZWlnaHQgLyBiYm94LmhlaWdodCwgMCk7XG4gICAgICAgICAgICB1dGlsLmludm9rZShjZWxscywgJ3NjYWxlJywgc3gsIHN5LCBiYm94Lm9yaWdpbigpLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHtcblxuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgdGhpcy5fYmF0Y2hlc1tuYW1lXSA9ICh0aGlzLl9iYXRjaGVzW25hbWVdIHx8IDApICsgMTtcblxuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdiYXRjaDpzdGFydCcsIHV0aWwuYXNzaWduKHt9LCBkYXRhLCB7IGJhdGNoTmFtZTogbmFtZSB9KSk7XG4gICAgfSxcblxuICAgIHN0b3BCYXRjaDogZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLl9iYXRjaGVzW25hbWVdID0gKHRoaXMuX2JhdGNoZXNbbmFtZV0gfHwgMCkgLSAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2JhdGNoOnN0b3AnLCB1dGlsLmFzc2lnbih7fSwgZGF0YSwgeyBiYXRjaE5hbWU6IG5hbWUgfSkpO1xuICAgIH0sXG5cbiAgICBoYXNBY3RpdmVCYXRjaDogZnVuY3Rpb24obmFtZSkge1xuXG4gICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0aGlzLl9iYXRjaGVzO1xuICAgICAgICBsZXQgbmFtZXM7XG5cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5hbWVzID0gT2JqZWN0LmtleXMoYmF0Y2hlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgbmFtZXMgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZXMgPSBbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZXMuc29tZSgoYmF0Y2gpID0+IGJhdGNoZXNbYmF0Y2hdID4gMCk7XG4gICAgfVxuXG59LCB7XG5cbiAgICB2YWxpZGF0aW9uczoge1xuXG4gICAgICAgIG11bHRpTGlua3M6IGZ1bmN0aW9uKGdyYXBoLCBsaW5rKSB7XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBtdWx0aXBsZSBsaW5rcyB0byBoYXZlIHRoZSBzYW1lIHNvdXJjZSBhbmQgdGFyZ2V0LlxuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgaWYgKHNvdXJjZS5pZCAmJiB0YXJnZXQuaWQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNb2RlbCA9IGxpbmsuZ2V0U291cmNlQ2VsbCgpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VNb2RlbCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0ZWRMaW5rcyA9IGdyYXBoLmdldENvbm5lY3RlZExpbmtzKHNvdXJjZU1vZGVsLCB7IG91dGJvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZUxpbmtzID0gY29ubmVjdGVkTGlua3MuZmlsdGVyKGZ1bmN0aW9uKF9saW5rKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IHNvdXJjZTogX3NvdXJjZSwgdGFyZ2V0OiBfdGFyZ2V0IH0gPSBfbGluay5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zb3VyY2UgJiYgX3NvdXJjZS5pZCA9PT0gc291cmNlLmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFfc291cmNlLnBvcnQgfHwgKF9zb3VyY2UucG9ydCA9PT0gc291cmNlLnBvcnQpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXQgJiYgX3RhcmdldC5pZCA9PT0gdGFyZ2V0LmlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFfdGFyZ2V0LnBvcnQgfHwgKF90YXJnZXQucG9ydCA9PT0gdGFyZ2V0LnBvcnQpKTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZUxpbmtzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGlua1Bpbm5pbmc6IGZ1bmN0aW9uKF9ncmFwaCwgbGluaykge1xuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UuaWQgJiYgdGFyZ2V0LmlkO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxud3JhcFdpdGgoR3JhcGgucHJvdG90eXBlLCBbJ3Jlc2V0Q2VsbHMnLCAnYWRkQ2VsbHMnLCAncmVtb3ZlQ2VsbHMnXSwgd3JhcHBlcnMuY2VsbHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/Graph.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/HighlighterView.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HighlighterView: () => (/* binding */ HighlighterView)\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\nfunction toArray(obj) {\n    if (!obj) return [];\n    if (Array.isArray(obj)) return obj;\n    return [obj];\n}\n\nconst HighlighterView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n\n    tagName: 'g',\n    svgElement: true,\n    className: 'highlight',\n\n    HIGHLIGHT_FLAG: 1,\n    UPDATE_PRIORITY: 3,\n    DETACHABLE: false,\n    UPDATABLE: true,\n    MOUNTABLE: true,\n\n    cellView: null,\n    nodeSelector: null,\n    node: null,\n    updateRequested: false,\n    postponedUpdate: false,\n    transformGroup: null,\n    detachedTransformGroup: null,\n\n    requestUpdate(cellView, nodeSelector) {\n        const { paper } = cellView;\n        this.cellView = cellView;\n        this.nodeSelector = nodeSelector;\n        if (paper) {\n            this.updateRequested = true;\n            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n        }\n    },\n\n    confirmUpdate() {\n        // The cellView is now rendered/updated since it has a higher update priority.\n        this.updateRequested = false;\n        const { cellView, nodeSelector } = this;\n        if (cellView.isMounted()) {\n            this.update(cellView, nodeSelector);\n            this.mount();\n            this.transform();\n        } else {\n            this.postponedUpdate = true;\n        }\n        return 0;\n    },\n\n    findNode(cellView, nodeSelector = null) {\n        let el;\n        if (typeof nodeSelector === 'string') {\n            el = cellView.findNode(nodeSelector);\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(nodeSelector)) {\n            const isLink = cellView.model.isLink();\n            const { label = null, port, selector } = nodeSelector;\n            if (isLink && label !== null) {\n                // Link Label Selector\n                el = cellView.findLabelNode(label, selector);\n            } else if (!isLink && port) {\n                // Element Port Selector\n                el = cellView.findPortNode(port, selector);\n            } else {\n                // Cell Selector\n                el = cellView.findNode(selector);\n            }\n        } else if (nodeSelector) {\n            el = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].toNode(nodeSelector);\n            if (!(el instanceof SVGElement)) el = null;\n        }\n        return el ? el : null;\n    },\n\n    getNodeMatrix(cellView, node) {\n        const { options } = this;\n        const { layer } = options;\n        const { rotatableNode } = cellView;\n        const nodeMatrix = cellView.getNodeMatrix(node);\n        if (rotatableNode) {\n            if (layer) {\n                if (rotatableNode.contains(node)) {\n                    return nodeMatrix;\n                }\n                // The node is outside of the rotatable group.\n                // Compensate the rotation set by transformGroup.\n                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n            } else {\n                return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n            }\n        }\n        return nodeMatrix;\n    },\n\n    mount() {\n        const { MOUNTABLE, cellView, el, options, transformGroup, detachedTransformGroup, postponedUpdate, nodeSelector } = this;\n        if (!MOUNTABLE || transformGroup) return;\n        if (postponedUpdate) {\n            // The cellView was not mounted when the update was requested.\n            // The update was postponed until the cellView is mounted.\n            this.update(cellView, nodeSelector);\n            this.transform();\n            return;\n        }\n        const { vel: cellViewRoot, paper } = cellView;\n        const { layer: layerName } = options;\n        if (layerName) {\n            let vGroup;\n            if (detachedTransformGroup) {\n                vGroup = detachedTransformGroup;\n                this.detachedTransformGroup = null;\n            } else {\n                vGroup = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('g').addClass('highlight-transform').append(el);\n            }\n            this.transformGroup = vGroup;\n            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);\n        } else {\n            // TODO: prepend vs append\n            if (!el.parentNode || el.nextSibling) {\n                // Not appended yet or not the last child\n                cellViewRoot.append(el);\n            }\n        }\n    },\n\n    unmount() {\n        const { MOUNTABLE, transformGroup, vel } = this;\n        if (!MOUNTABLE) return;\n        if (transformGroup) {\n            this.transformGroup = null;\n            this.detachedTransformGroup = transformGroup;\n            transformGroup.remove();\n        } else {\n            vel.remove();\n        }\n    },\n\n    transform() {\n        const { transformGroup, cellView, updateRequested } = this;\n        if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n        const translateMatrix = cellView.getRootTranslateMatrix();\n        const rotateMatrix = cellView.getRootRotateMatrix();\n        const transformMatrix = translateMatrix.multiply(rotateMatrix);\n        transformGroup.attr('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].matrixToTransformString(transformMatrix));\n    },\n\n    update() {\n        const { node: prevNode, cellView, nodeSelector, updateRequested, id } = this;\n        if (updateRequested) return;\n        this.postponedUpdate = false;\n        const node = this.node = this.findNode(cellView, nodeSelector);\n        if (prevNode) {\n            this.unhighlight(cellView, prevNode);\n        }\n        if (node) {\n            this.highlight(cellView, node);\n            this.mount();\n        } else {\n            this.unmount();\n            cellView.notify('cell:highlight:invalid', id, this);\n        }\n    },\n\n    onRemove() {\n        const { node, cellView, id, constructor } = this;\n        if (node) {\n            this.unhighlight(cellView, node);\n        }\n        this.unmount();\n        constructor._removeRef(cellView, id);\n    },\n\n    highlight(_cellView, _node) {\n        // to be overridden\n    },\n\n    unhighlight(_cellView, _node) {\n        // to be overridden\n    },\n\n    // Update Attributes\n\n    listenToUpdateAttributes(cellView) {\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'UPDATE_ATTRIBUTES');\n        if (!Array.isArray(attributes) || attributes.length === 0) return;\n        this.listenTo(cellView.model, 'change', this.onCellAttributeChange);\n    },\n\n    onCellAttributeChange() {\n        const { cellView } = this;\n        if (!cellView) return;\n        const { model, paper } = cellView;\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'UPDATE_ATTRIBUTES');\n        if (!attributes.some(attribute => model.hasChanged(attribute))) return;\n        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n    }\n\n}, {\n\n    _views: {},\n\n    // Used internally by CellView highlight()\n    highlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.add(cellView, node, id, opt);\n    },\n\n    // Used internally by CellView unhighlight()\n    unhighlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.remove(cellView, id);\n    },\n\n    get(cellView, id = null) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (id === null) {\n            // all highlighters\n            const views = [];\n            if (!refs) return views;\n            for (let hid in refs) {\n                const ref = refs[hid];\n                if (ref instanceof this) {\n                    views.push(ref);\n                }\n            }\n            return views;\n        } else {\n            // single highlighter\n            if (!refs) return null;\n            if (id in refs) {\n                const ref = refs[id];\n                if (ref instanceof this) return ref;\n            }\n            return null;\n        }\n    },\n\n    add(cellView, nodeSelector, id, opt = {}) {\n        if (!id) throw new Error('dia.HighlighterView: An ID required.');\n        // Search the existing view amongst all the highlighters\n        const previousView = HighlighterView.get(cellView, id);\n        if (previousView) previousView.remove();\n        const view = new this(opt);\n        view.id = id;\n        this._addRef(cellView, id, view);\n        view.requestUpdate(cellView, nodeSelector);\n        view.listenToUpdateAttributes(cellView);\n        return view;\n    },\n\n    _addRef(cellView, id, view) {\n        const { cid } = cellView;\n        const { _views } = this;\n        let refs = _views[cid];\n        if (!refs) refs = _views[cid] = {};\n        refs[id] = view;\n    },\n\n    _removeRef(cellView, id) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (!refs) return;\n        if (id) delete refs[id];\n        for (let _ in refs) return;\n        delete _views[cid];\n    },\n\n    remove(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            view.remove();\n        });\n    },\n\n    getAll(paper, id = null) {\n        const views = [];\n        const { _views } = this;\n        for (let cid in _views) {\n            for (let hid in _views[cid]) {\n                const view = _views[cid][hid];\n                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n                    views.push(view);\n                }\n            }\n        }\n        return views;\n    },\n\n    removeAll(paper, id = null) {\n        this.getAll(paper, id).forEach(view => view.remove());\n    },\n\n    update(cellView, id = null, dirty = false) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            if (dirty || view.UPDATABLE) view.update();\n        });\n    },\n\n    transform(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            if (view.UPDATABLE) view.transform();\n        });\n    },\n\n    unmount(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => view.unmount());\n    },\n\n    mount(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => view.mount());\n    },\n\n    uniqueId(node, opt = '') {\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ensureId(node) + JSON.stringify(opt);\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9IaWdobGlnaHRlclZpZXcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDVDtBQUMwQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyx3QkFBd0IsZ0RBQVE7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsNkRBQWE7QUFDaEM7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpQkFBaUIsb0RBQUM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQiwwR0FBMEc7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0MsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLHlCQUF5Qix3REFBQztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0RBQUM7QUFDMUMsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQiw4REFBOEQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsMkJBQTJCLHNEQUFNO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQiwyQkFBMkIsc0RBQU07QUFDakM7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLG9EQUFDO0FBQ2hCOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcz85MWFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG12YyBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QsIHJlc3VsdCB9IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gW29ial07XG59XG5cbmV4cG9ydCBjb25zdCBIaWdobGlnaHRlclZpZXcgPSBtdmMuVmlldy5leHRlbmQoe1xuXG4gICAgdGFnTmFtZTogJ2cnLFxuICAgIHN2Z0VsZW1lbnQ6IHRydWUsXG4gICAgY2xhc3NOYW1lOiAnaGlnaGxpZ2h0JyxcblxuICAgIEhJR0hMSUdIVF9GTEFHOiAxLFxuICAgIFVQREFURV9QUklPUklUWTogMyxcbiAgICBERVRBQ0hBQkxFOiBmYWxzZSxcbiAgICBVUERBVEFCTEU6IHRydWUsXG4gICAgTU9VTlRBQkxFOiB0cnVlLFxuXG4gICAgY2VsbFZpZXc6IG51bGwsXG4gICAgbm9kZVNlbGVjdG9yOiBudWxsLFxuICAgIG5vZGU6IG51bGwsXG4gICAgdXBkYXRlUmVxdWVzdGVkOiBmYWxzZSxcbiAgICBwb3N0cG9uZWRVcGRhdGU6IGZhbHNlLFxuICAgIHRyYW5zZm9ybUdyb3VwOiBudWxsLFxuICAgIGRldGFjaGVkVHJhbnNmb3JtR3JvdXA6IG51bGwsXG5cbiAgICByZXF1ZXN0VXBkYXRlKGNlbGxWaWV3LCBub2RlU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciB9ID0gY2VsbFZpZXc7XG4gICAgICAgIHRoaXMuY2VsbFZpZXcgPSBjZWxsVmlldztcbiAgICAgICAgdGhpcy5ub2RlU2VsZWN0b3IgPSBub2RlU2VsZWN0b3I7XG4gICAgICAgIGlmIChwYXBlcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcGFwZXIucmVxdWVzdFZpZXdVcGRhdGUodGhpcywgdGhpcy5ISUdITElHSFRfRkxBRywgdGhpcy5VUERBVEVfUFJJT1JJVFkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbmZpcm1VcGRhdGUoKSB7XG4gICAgICAgIC8vIFRoZSBjZWxsVmlldyBpcyBub3cgcmVuZGVyZWQvdXBkYXRlZCBzaW5jZSBpdCBoYXMgYSBoaWdoZXIgdXBkYXRlIHByaW9yaXR5LlxuICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IGNlbGxWaWV3LCBub2RlU2VsZWN0b3IgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjZWxsVmlldy5pc01vdW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoY2VsbFZpZXcsIG5vZGVTZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3N0cG9uZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBmaW5kTm9kZShjZWxsVmlldywgbm9kZVNlbGVjdG9yID0gbnVsbCkge1xuICAgICAgICBsZXQgZWw7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZVNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZWwgPSBjZWxsVmlldy5maW5kTm9kZShub2RlU2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qobm9kZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY29uc3QgaXNMaW5rID0gY2VsbFZpZXcubW9kZWwuaXNMaW5rKCk7XG4gICAgICAgICAgICBjb25zdCB7IGxhYmVsID0gbnVsbCwgcG9ydCwgc2VsZWN0b3IgfSA9IG5vZGVTZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChpc0xpbmsgJiYgbGFiZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5rIExhYmVsIFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWwgPSBjZWxsVmlldy5maW5kTGFiZWxOb2RlKGxhYmVsLCBzZWxlY3Rvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0xpbmsgJiYgcG9ydCkge1xuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgUG9ydCBTZWxlY3RvclxuICAgICAgICAgICAgICAgIGVsID0gY2VsbFZpZXcuZmluZFBvcnROb2RlKHBvcnQsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2VsbCBTZWxlY3RvclxuICAgICAgICAgICAgICAgIGVsID0gY2VsbFZpZXcuZmluZE5vZGUoc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgZWwgPSBWLnRvTm9kZShub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKCEoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkgZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbCA/IGVsIDogbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZU1hdHJpeChjZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbGF5ZXIgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgcm90YXRhYmxlTm9kZSB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IG5vZGVNYXRyaXggPSBjZWxsVmlldy5nZXROb2RlTWF0cml4KG5vZGUpO1xuICAgICAgICBpZiAocm90YXRhYmxlTm9kZSkge1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0YWJsZU5vZGUuY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVNYXRyaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlIGlzIG91dHNpZGUgb2YgdGhlIHJvdGF0YWJsZSBncm91cC5cbiAgICAgICAgICAgICAgICAvLyBDb21wZW5zYXRlIHRoZSByb3RhdGlvbiBzZXQgYnkgdHJhbnNmb3JtR3JvdXAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxWaWV3LmdldFJvb3RSb3RhdGVNYXRyaXgoKS5pbnZlcnNlKCkubXVsdGlwbHkobm9kZU1hdHJpeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsVmlldy5nZXROb2RlUm90YXRlTWF0cml4KG5vZGUpLm11bHRpcGx5KG5vZGVNYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlTWF0cml4O1xuICAgIH0sXG5cbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBNT1VOVEFCTEUsIGNlbGxWaWV3LCBlbCwgb3B0aW9ucywgdHJhbnNmb3JtR3JvdXAsIGRldGFjaGVkVHJhbnNmb3JtR3JvdXAsIHBvc3Rwb25lZFVwZGF0ZSwgbm9kZVNlbGVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIU1PVU5UQUJMRSB8fCB0cmFuc2Zvcm1Hcm91cCkgcmV0dXJuO1xuICAgICAgICBpZiAocG9zdHBvbmVkVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBUaGUgY2VsbFZpZXcgd2FzIG5vdCBtb3VudGVkIHdoZW4gdGhlIHVwZGF0ZSB3YXMgcmVxdWVzdGVkLlxuICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSB3YXMgcG9zdHBvbmVkIHVudGlsIHRoZSBjZWxsVmlldyBpcyBtb3VudGVkLlxuICAgICAgICAgICAgdGhpcy51cGRhdGUoY2VsbFZpZXcsIG5vZGVTZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmVsOiBjZWxsVmlld1Jvb3QsIHBhcGVyIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3QgeyBsYXllcjogbGF5ZXJOYW1lIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAobGF5ZXJOYW1lKSB7XG4gICAgICAgICAgICBsZXQgdkdyb3VwO1xuICAgICAgICAgICAgaWYgKGRldGFjaGVkVHJhbnNmb3JtR3JvdXApIHtcbiAgICAgICAgICAgICAgICB2R3JvdXAgPSBkZXRhY2hlZFRyYW5zZm9ybUdyb3VwO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoZWRUcmFuc2Zvcm1Hcm91cCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZHcm91cCA9IFYoJ2cnKS5hZGRDbGFzcygnaGlnaGxpZ2h0LXRyYW5zZm9ybScpLmFwcGVuZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUdyb3VwID0gdkdyb3VwO1xuICAgICAgICAgICAgcGFwZXIuZ2V0TGF5ZXJWaWV3KGxheWVyTmFtZSkuaW5zZXJ0U29ydGVkTm9kZSh2R3JvdXAubm9kZSwgb3B0aW9ucy56KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHByZXBlbmQgdnMgYXBwZW5kXG4gICAgICAgICAgICBpZiAoIWVsLnBhcmVudE5vZGUgfHwgZWwubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgYXBwZW5kZWQgeWV0IG9yIG5vdCB0aGUgbGFzdCBjaGlsZFxuICAgICAgICAgICAgICAgIGNlbGxWaWV3Um9vdC5hcHBlbmQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgTU9VTlRBQkxFLCB0cmFuc2Zvcm1Hcm91cCwgdmVsIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIU1PVU5UQUJMRSkgcmV0dXJuO1xuICAgICAgICBpZiAodHJhbnNmb3JtR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtR3JvdXAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hlZFRyYW5zZm9ybUdyb3VwID0gdHJhbnNmb3JtR3JvdXA7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Hcm91cC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm0oKSB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtR3JvdXAsIGNlbGxWaWV3LCB1cGRhdGVSZXF1ZXN0ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghdHJhbnNmb3JtR3JvdXAgfHwgY2VsbFZpZXcubW9kZWwuaXNMaW5rKCkgfHwgdXBkYXRlUmVxdWVzdGVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZU1hdHJpeCA9IGNlbGxWaWV3LmdldFJvb3RUcmFuc2xhdGVNYXRyaXgoKTtcbiAgICAgICAgY29uc3Qgcm90YXRlTWF0cml4ID0gY2VsbFZpZXcuZ2V0Um9vdFJvdGF0ZU1hdHJpeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1NYXRyaXggPSB0cmFuc2xhdGVNYXRyaXgubXVsdGlwbHkocm90YXRlTWF0cml4KTtcbiAgICAgICAgdHJhbnNmb3JtR3JvdXAuYXR0cigndHJhbnNmb3JtJywgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm1NYXRyaXgpKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IG5vZGU6IHByZXZOb2RlLCBjZWxsVmlldywgbm9kZVNlbGVjdG9yLCB1cGRhdGVSZXF1ZXN0ZWQsIGlkIH0gPSB0aGlzO1xuICAgICAgICBpZiAodXBkYXRlUmVxdWVzdGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMucG9zdHBvbmVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGUgPSB0aGlzLmZpbmROb2RlKGNlbGxWaWV3LCBub2RlU2VsZWN0b3IpO1xuICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudW5oaWdobGlnaHQoY2VsbFZpZXcsIHByZXZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQoY2VsbFZpZXcsIG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5tb3VudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bm1vdW50KCk7XG4gICAgICAgICAgICBjZWxsVmlldy5ub3RpZnkoJ2NlbGw6aGlnaGxpZ2h0OmludmFsaWQnLCBpZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25SZW1vdmUoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZSwgY2VsbFZpZXcsIGlkLCBjb25zdHJ1Y3RvciB9ID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudW5oaWdobGlnaHQoY2VsbFZpZXcsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5tb3VudCgpO1xuICAgICAgICBjb25zdHJ1Y3Rvci5fcmVtb3ZlUmVmKGNlbGxWaWV3LCBpZCk7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodChfY2VsbFZpZXcsIF9ub2RlKSB7XG4gICAgICAgIC8vIHRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQoX2NlbGxWaWV3LCBfbm9kZSkge1xuICAgICAgICAvLyB0byBiZSBvdmVycmlkZGVuXG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBBdHRyaWJ1dGVzXG5cbiAgICBsaXN0ZW5Ub1VwZGF0ZUF0dHJpYnV0ZXMoY2VsbFZpZXcpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc3VsdCh0aGlzLCAnVVBEQVRFX0FUVFJJQlVURVMnKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpIHx8IGF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHRoaXMubGlzdGVuVG8oY2VsbFZpZXcubW9kZWwsICdjaGFuZ2UnLCB0aGlzLm9uQ2VsbEF0dHJpYnV0ZUNoYW5nZSk7XG4gICAgfSxcblxuICAgIG9uQ2VsbEF0dHJpYnV0ZUNoYW5nZSgpIHtcbiAgICAgICAgY29uc3QgeyBjZWxsVmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFjZWxsVmlldykgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IG1vZGVsLCBwYXBlciB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSByZXN1bHQodGhpcywgJ1VQREFURV9BVFRSSUJVVEVTJyk7XG4gICAgICAgIGlmICghYXR0cmlidXRlcy5zb21lKGF0dHJpYnV0ZSA9PiBtb2RlbC5oYXNDaGFuZ2VkKGF0dHJpYnV0ZSkpKSByZXR1cm47XG4gICAgICAgIHBhcGVyLnJlcXVlc3RWaWV3VXBkYXRlKHRoaXMsIHRoaXMuSElHSExJR0hUX0ZMQUcsIHRoaXMuVVBEQVRFX1BSSU9SSVRZKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIF92aWV3czoge30sXG5cbiAgICAvLyBVc2VkIGludGVybmFsbHkgYnkgQ2VsbFZpZXcgaGlnaGxpZ2h0KClcbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGNlbGxWaWV3LCBub2RlLCBvcHQpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLnVuaXF1ZUlkKG5vZGUsIG9wdCk7XG4gICAgICAgIHRoaXMuYWRkKGNlbGxWaWV3LCBub2RlLCBpZCwgb3B0KTtcbiAgICB9LFxuXG4gICAgLy8gVXNlZCBpbnRlcm5hbGx5IGJ5IENlbGxWaWV3IHVuaGlnaGxpZ2h0KClcbiAgICB1bmhpZ2hsaWdodDogZnVuY3Rpb24oY2VsbFZpZXcsIG5vZGUsIG9wdCkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMudW5pcXVlSWQobm9kZSwgb3B0KTtcbiAgICAgICAgdGhpcy5yZW1vdmUoY2VsbFZpZXcsIGlkKTtcbiAgICB9LFxuXG4gICAgZ2V0KGNlbGxWaWV3LCBpZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBjaWQgfSA9IGNlbGxWaWV3O1xuICAgICAgICBjb25zdCB7IF92aWV3cyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVmcyA9IF92aWV3c1tjaWRdO1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGFsbCBoaWdobGlnaHRlcnNcbiAgICAgICAgICAgIGNvbnN0IHZpZXdzID0gW107XG4gICAgICAgICAgICBpZiAoIXJlZnMpIHJldHVybiB2aWV3cztcbiAgICAgICAgICAgIGZvciAobGV0IGhpZCBpbiByZWZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1toaWRdO1xuICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzLnB1c2gocmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmlld3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaW5nbGUgaGlnaGxpZ2h0ZXJcbiAgICAgICAgICAgIGlmICghcmVmcykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoaWQgaW4gcmVmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHJlZnNbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiB0aGlzKSByZXR1cm4gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkKGNlbGxWaWV3LCBub2RlU2VsZWN0b3IsIGlkLCBvcHQgPSB7fSkge1xuICAgICAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5IaWdobGlnaHRlclZpZXc6IEFuIElEIHJlcXVpcmVkLicpO1xuICAgICAgICAvLyBTZWFyY2ggdGhlIGV4aXN0aW5nIHZpZXcgYW1vbmdzdCBhbGwgdGhlIGhpZ2hsaWdodGVyc1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZpZXcgPSBIaWdobGlnaHRlclZpZXcuZ2V0KGNlbGxWaWV3LCBpZCk7XG4gICAgICAgIGlmIChwcmV2aW91c1ZpZXcpIHByZXZpb3VzVmlldy5yZW1vdmUoKTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyB0aGlzKG9wdCk7XG4gICAgICAgIHZpZXcuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5fYWRkUmVmKGNlbGxWaWV3LCBpZCwgdmlldyk7XG4gICAgICAgIHZpZXcucmVxdWVzdFVwZGF0ZShjZWxsVmlldywgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgdmlldy5saXN0ZW5Ub1VwZGF0ZUF0dHJpYnV0ZXMoY2VsbFZpZXcpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuXG4gICAgX2FkZFJlZihjZWxsVmlldywgaWQsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgeyBjaWQgfSA9IGNlbGxWaWV3O1xuICAgICAgICBjb25zdCB7IF92aWV3cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlZnMgPSBfdmlld3NbY2lkXTtcbiAgICAgICAgaWYgKCFyZWZzKSByZWZzID0gX3ZpZXdzW2NpZF0gPSB7fTtcbiAgICAgICAgcmVmc1tpZF0gPSB2aWV3O1xuICAgIH0sXG5cbiAgICBfcmVtb3ZlUmVmKGNlbGxWaWV3LCBpZCkge1xuICAgICAgICBjb25zdCB7IGNpZCB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByZWZzID0gX3ZpZXdzW2NpZF07XG4gICAgICAgIGlmICghcmVmcykgcmV0dXJuO1xuICAgICAgICBpZiAoaWQpIGRlbGV0ZSByZWZzW2lkXTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiByZWZzKSByZXR1cm47XG4gICAgICAgIGRlbGV0ZSBfdmlld3NbY2lkXTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlKGNlbGxWaWV3LCBpZCA9IG51bGwpIHtcbiAgICAgICAgdG9BcnJheSh0aGlzLmdldChjZWxsVmlldywgaWQpKS5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgdmlldy5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGdldEFsbChwYXBlciwgaWQgPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHZpZXdzID0gW107XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBjaWQgaW4gX3ZpZXdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBoaWQgaW4gX3ZpZXdzW2NpZF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gX3ZpZXdzW2NpZF1baGlkXTtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5jZWxsVmlldy5wYXBlciA9PT0gcGFwZXIgJiYgdmlldyBpbnN0YW5jZW9mIHRoaXMgJiYgKGlkID09PSBudWxsIHx8IGhpZCA9PT0gaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzLnB1c2godmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3cztcbiAgICB9LFxuXG4gICAgcmVtb3ZlQWxsKHBhcGVyLCBpZCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5nZXRBbGwocGFwZXIsIGlkKS5mb3JFYWNoKHZpZXcgPT4gdmlldy5yZW1vdmUoKSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZShjZWxsVmlldywgaWQgPSBudWxsLCBkaXJ0eSA9IGZhbHNlKSB7XG4gICAgICAgIHRvQXJyYXkodGhpcy5nZXQoY2VsbFZpZXcsIGlkKSkuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGlmIChkaXJ0eSB8fCB2aWV3LlVQREFUQUJMRSkgdmlldy51cGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybShjZWxsVmlldywgaWQgPSBudWxsKSB7XG4gICAgICAgIHRvQXJyYXkodGhpcy5nZXQoY2VsbFZpZXcsIGlkKSkuZm9yRWFjaCh2aWV3ID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LlVQREFUQUJMRSkgdmlldy50cmFuc2Zvcm0oKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVubW91bnQoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICB0b0FycmF5KHRoaXMuZ2V0KGNlbGxWaWV3LCBpZCkpLmZvckVhY2godmlldyA9PiB2aWV3LnVubW91bnQoKSk7XG4gICAgfSxcblxuICAgIG1vdW50KGNlbGxWaWV3LCBpZCA9IG51bGwpIHtcbiAgICAgICAgdG9BcnJheSh0aGlzLmdldChjZWxsVmlldywgaWQpKS5mb3JFYWNoKHZpZXcgPT4gdmlldy5tb3VudCgpKTtcbiAgICB9LFxuXG4gICAgdW5pcXVlSWQobm9kZSwgb3B0ID0gJycpIHtcbiAgICAgICAgcmV0dXJuIFYuZW5zdXJlSWQobm9kZSkgKyBKU09OLnN0cmluZ2lmeShvcHQpO1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/Link.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Link.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: () => (/* binding */ Link)\n/* harmony export */ });\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n\n\n\n\n// Link base model.\n// --------------------------\n\nconst Link = _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.extend({\n\n    // may be overwritten by user to change default label (its markup, size, attrs, position)\n    defaultLabel: undefined,\n\n    // deprecated\n    // may be overwritten by user to change default label markup\n    // lower priority than defaultLabel.markup\n    labelMarkup: undefined,\n\n    // private\n    _builtins: {\n        defaultLabel: {\n            // builtin default markup:\n            // used if neither defaultLabel.markup\n            // nor label.markup is set\n            markup: [\n                {\n                    tagName: 'rect',\n                    selector: 'rect' // faster than tagName CSS selector\n                }, {\n                    tagName: 'text',\n                    selector: 'text' // faster than tagName CSS selector\n                }\n            ],\n            // builtin default attributes:\n            // applied only if builtin default markup is used\n            attrs: {\n                text: {\n                    fill: '#000000',\n                    fontSize: 14,\n                    textAnchor: 'middle',\n                    textVerticalAnchor: 'middle',\n                    pointerEvents: 'none'\n                },\n                rect: {\n                    ref: 'text',\n                    fill: '#ffffff',\n                    rx: 3,\n                    ry: 3,\n                    x: 'calc(x)',\n                    y: 'calc(y)',\n                    width: 'calc(w)',\n                    height: 'calc(h)'\n                }\n            },\n            // builtin default position:\n            // used if neither defaultLabel.position\n            // nor label.position is set\n            position: {\n                distance: 0.5\n            }\n        }\n    },\n\n    defaults: {\n        source: {},\n        target: {}\n    },\n\n    isLink: function() {\n\n        return true;\n    },\n\n    disconnect: function(opt) {\n\n        return this.set({\n            source: { x: 0, y: 0 },\n            target: { x: 0, y: 0 }\n        }, opt);\n    },\n\n    source: function(source, args, opt) {\n\n        // getter\n        if (source === undefined) {\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(this.get('source'));\n        }\n\n        // setter\n        var setSource;\n        var setOpt;\n\n        // `source` is a cell\n        // take only its `id` and combine with `args`\n        var isCellProvided = source instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell;\n        if (isCellProvided) { // three arguments\n            setSource = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setSource.id = source.id;\n            setOpt = opt;\n            return this.set('source', setSource, setOpt);\n        }\n\n        // `source` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(source);\n        if (isPointProvided) { // three arguments\n            setSource = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setSource.x = source.x;\n            setSource.y = source.y;\n            setOpt = opt;\n            return this.set('source', setSource, setOpt);\n        }\n\n        // `source` is an object\n        // no checking\n        // two arguments\n        setSource = source;\n        setOpt = args;\n        return this.set('source', setSource, setOpt);\n    },\n\n    target: function(target, args, opt) {\n\n        // getter\n        if (target === undefined) {\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(this.get('target'));\n        }\n\n        // setter\n        var setTarget;\n        var setOpt;\n\n        // `target` is a cell\n        // take only its `id` argument and combine with `args`\n        var isCellProvided = target instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell;\n        if (isCellProvided) { // three arguments\n            setTarget = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setTarget.id = target.id;\n            setOpt = opt;\n            return this.set('target', setTarget, setOpt);\n        }\n\n        // `target` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(target);\n        if (isPointProvided) { // three arguments\n            setTarget = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setTarget.x = target.x;\n            setTarget.y = target.y;\n            setOpt = opt;\n            return this.set('target', setTarget, setOpt);\n        }\n\n        // `target` is an object\n        // no checking\n        // two arguments\n        setTarget = target;\n        setOpt = args;\n        return this.set('target', setTarget, setOpt);\n    },\n\n    router: function(name, args, opt) {\n\n        // getter\n        if (name === undefined) {\n            var router = this.get('router');\n            if (!router) {\n                return null;\n            }\n            if (typeof router === 'object') return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(router);\n            return router; // e.g. a function\n        }\n\n        // setter\n        var isRouterProvided = ((typeof name === 'object') || (typeof name === 'function'));\n        var localRouter = isRouterProvided ? name : { name: name, args: args };\n        var localOpt = isRouterProvided ? args : opt;\n\n        return this.set('router', localRouter, localOpt);\n    },\n\n    connector: function(name, args, opt) {\n\n        // getter\n        if (name === undefined) {\n            var connector = this.get('connector');\n            if (!connector) {\n                return null;\n            }\n            if (typeof connector === 'object') return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(connector);\n            return connector; // e.g. a function\n        }\n\n        // setter\n        var isConnectorProvided = ((typeof name === 'object' || typeof name === 'function'));\n        var localConnector = isConnectorProvided ? name : { name: name, args: args };\n        var localOpt = isConnectorProvided ? args : opt;\n\n        return this.set('connector', localConnector, localOpt);\n    },\n\n    // Labels API\n\n    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n    label: function(idx, label, opt) {\n\n        var labels = this.labels();\n\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n        if (idx < 0) idx = labels.length + idx;\n\n        // getter\n        if (arguments.length <= 1) return this.prop(['labels', idx]);\n        // setter\n        return this.prop(['labels', idx], label, opt);\n    },\n\n    labels: function(labels, opt) {\n\n        // getter\n        if (arguments.length === 0) {\n            labels = this.get('labels');\n            if (!Array.isArray(labels)) return [];\n            return labels.slice();\n        }\n        // setter\n        if (!Array.isArray(labels)) labels = [];\n        return this.set('labels', labels, opt);\n    },\n\n    hasLabels: function() {\n        const { labels } = this.attributes;\n        return Array.isArray(labels) && labels.length > 0;\n    },\n\n    insertLabel: function(idx, label, opt) {\n\n        if (!label) throw new Error('dia.Link: no label provided');\n\n        var labels = this.labels();\n        var n = labels.length;\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n        if (idx < 0) idx = n + idx + 1;\n\n        labels.splice(idx, 0, label);\n        return this.labels(labels, opt);\n    },\n\n    // convenience function\n    // add label to end of labels array\n    appendLabel: function(label, opt) {\n\n        return this.insertLabel(-1, label, opt);\n    },\n\n    removeLabel: function(idx, opt) {\n\n        var labels = this.labels();\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n        labels.splice(idx, 1);\n        return this.labels(labels, opt);\n    },\n\n    // Vertices API\n\n    vertex: function(idx, vertex, opt) {\n\n        var vertices = this.vertices();\n\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n        if (idx < 0) idx = vertices.length + idx;\n\n        // getter\n        if (arguments.length <= 1) return this.prop(['vertices', idx]);\n\n        // setter\n        var setVertex = this._normalizeVertex(vertex);\n        return this.prop(['vertices', idx], setVertex, opt);\n    },\n\n    vertices: function(vertices, opt) {\n\n        // getter\n        if (arguments.length === 0) {\n            vertices = this.get('vertices');\n            if (!Array.isArray(vertices)) return [];\n            return vertices.slice();\n        }\n\n        // setter\n        if (!Array.isArray(vertices)) vertices = [];\n        var setVertices = [];\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            var setVertex = this._normalizeVertex(vertex);\n            setVertices.push(setVertex);\n        }\n        return this.set('vertices', setVertices, opt);\n    },\n\n    insertVertex: function(idx, vertex, opt) {\n\n        if (!vertex) throw new Error('dia.Link: no vertex provided');\n\n        var vertices = this.vertices();\n        var n = vertices.length;\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n        if (idx < 0) idx = n + idx + 1;\n\n        var setVertex = this._normalizeVertex(vertex);\n        vertices.splice(idx, 0, setVertex);\n        return this.vertices(vertices, opt);\n    },\n\n    removeVertex: function(idx, opt) {\n\n        var vertices = this.vertices();\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n        vertices.splice(idx, 1);\n        return this.vertices(vertices, opt);\n    },\n\n    _normalizeVertex: function(vertex) {\n\n        // is vertex a point-like object?\n        // for example, a g.Point\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(vertex);\n        if (isPointProvided) return { x: vertex.x, y: vertex.y };\n\n        // else: return vertex unchanged\n        return vertex;\n    },\n\n    // Transformations\n\n    translate: function(tx, ty, opt) {\n\n        // enrich the option object\n        opt = opt || {};\n        opt.translateBy = opt.translateBy || this.id;\n        opt.tx = tx;\n        opt.ty = ty;\n\n        return this.applyToPoints(function(p) {\n            return { x: (p.x || 0) + tx, y: (p.y || 0) + ty };\n        }, opt);\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        return this.applyToPoints(function(p) {\n            return (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(p).scale(sx, sy, origin).toJSON();\n        }, opt);\n    },\n\n    applyToPoints: function(fn, opt) {\n\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\n            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n        }\n\n        var attrs = {};\n\n        var { source, target } = this.attributes;\n        if (!source.id) {\n            attrs.source = fn(source);\n        }\n        if (!target.id) {\n            attrs.target = fn(target);\n        }\n\n        var vertices = this.vertices();\n        if (vertices.length > 0) {\n            attrs.vertices = vertices.map(fn);\n        }\n\n        return this.set(attrs, opt);\n    },\n\n    getSourcePoint: function() {\n        var sourceCell = this.getSourceCell();\n        if (!sourceCell) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(this.source());\n        return sourceCell.getPointFromConnectedLink(this, 'source');\n    },\n\n    getTargetPoint: function() {\n        var targetCell = this.getTargetCell();\n        if (!targetCell) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(this.target());\n        return targetCell.getPointFromConnectedLink(this, 'target');\n    },\n\n    getPointFromConnectedLink: function(/* link, endType */) {\n        return this.getPolyline().pointAt(0.5);\n    },\n\n    getPolyline: function() {\n        const points = [\n            this.getSourcePoint(),\n            ...this.vertices().map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point),\n            this.getTargetPoint()\n        ];\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n    },\n\n    getBBox: function() {\n        return this.getPolyline().bbox();\n    },\n\n    reparent: function(opt) {\n\n        var newParent;\n\n        if (this.graph) {\n\n            var source = this.getSourceElement();\n            var target = this.getTargetElement();\n            var prevParent = this.getParentCell();\n\n            if (source && target) {\n                if (source === target || source.isEmbeddedIn(target)) {\n                    newParent = target;\n                } else if (target.isEmbeddedIn(source)) {\n                    newParent = source;\n                } else {\n                    newParent = this.graph.getCommonAncestor(source, target);\n                }\n            }\n\n            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n                // Unembed the link if source and target has no common ancestor\n                // or common ancestor changed\n                prevParent.unembed(this, opt);\n            }\n\n            if (newParent) {\n                newParent.embed(this, opt);\n            }\n        }\n\n        return newParent;\n    },\n\n    hasLoop: function(opt) {\n\n        opt = opt || {};\n\n        var { source, target } = this.attributes;\n        var sourceId = source.id;\n        var targetId = target.id;\n\n        if (!sourceId || !targetId) {\n            // Link \"pinned\" to the paper does not have a loop.\n            return false;\n        }\n\n        var loop = sourceId === targetId;\n\n        // Note that there in the deep mode a link can have a loop,\n        // even if it connects only a parent and its embed.\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\n        if (!loop && opt.deep && this.graph) {\n\n            var sourceElement = this.getSourceCell();\n            var targetElement = this.getTargetCell();\n\n            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n        }\n\n        return loop;\n    },\n\n    // unlike source(), this method returns null if source is a point\n    getSourceCell: function() {\n\n        const { graph, attributes } = this;\n        var source = attributes.source;\n        return (source && source.id && graph && graph.getCell(source.id)) || null;\n    },\n\n    getSourceElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getSourceCell();\n        } while (cell && cell.isLink());\n        return cell;\n    },\n\n    // unlike target(), this method returns null if target is a point\n    getTargetCell: function() {\n\n        const { graph, attributes } = this;\n        var target = attributes.target;\n        return (target && target.id && graph && graph.getCell(target.id)) || null;\n    },\n\n    getTargetElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getTargetCell();\n        } while (cell && cell.isLink());\n        return cell;\n    },\n\n    // Returns the common ancestor for the source element,\n    // target element and the link itself.\n    getRelationshipAncestor: function() {\n\n        var connectionAncestor;\n\n        if (this.graph) {\n\n            var cells = [\n                this,\n                this.getSourceElement(), // null if source is a point\n                this.getTargetElement() // null if target is a point\n            ].filter(function(item) {\n                return !!item;\n            });\n\n            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n        }\n\n        return connectionAncestor || null;\n    },\n\n    // Is source, target and the link itself embedded in a given cell?\n    isRelationshipEmbeddedIn: function(cell) {\n\n        var cellId = ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(cell) || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(cell)) ? cell : cell.id;\n        var ancestor = this.getRelationshipAncestor();\n\n        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n    },\n\n    // Get resolved default label.\n    _getDefaultLabel: function() {\n\n        var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\n        var label = {};\n        label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n        label.position = defaultLabel.position;\n        label.attrs = defaultLabel.attrs;\n        label.size = defaultLabel.size;\n\n        return label;\n    }\n}, {\n\n    endsEqual: function(a, b) {\n\n        var portsEqual = a.port === b.port || !a.port && !b.port;\n        return a.id === b.id && portsEqual;\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9MaW5rLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUN1RDtBQUN4Qzs7QUFFakQ7QUFDQTs7QUFFTyxhQUFhLDJDQUFJOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsc0JBQXNCO0FBQ3RCLFNBQVM7QUFDVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0RBQUs7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsMkNBQUk7QUFDbkQsOEJBQThCO0FBQzlCLHdCQUF3QixzREFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOERBQWE7QUFDNUMsK0JBQStCO0FBQy9CLHdCQUF3QixzREFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzREFBSztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQywyQ0FBSTtBQUNu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RUw7QUFDQTs7QUFFQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsc0JBQXNCLHlEQUFRLFVBQVUseURBQVE7QUFDaEQ7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0xpbmsubWpzPzkxYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbC5tanMnO1xuaW1wb3J0IHsgY2xvbmUsIGlzUGxhaW5PYmplY3QsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFBvaW50LCBQb2x5bGluZSB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuLy8gTGluayBiYXNlIG1vZGVsLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IExpbmsgPSBDZWxsLmV4dGVuZCh7XG5cbiAgICAvLyBtYXkgYmUgb3ZlcndyaXR0ZW4gYnkgdXNlciB0byBjaGFuZ2UgZGVmYXVsdCBsYWJlbCAoaXRzIG1hcmt1cCwgc2l6ZSwgYXR0cnMsIHBvc2l0aW9uKVxuICAgIGRlZmF1bHRMYWJlbDogdW5kZWZpbmVkLFxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIC8vIG1heSBiZSBvdmVyd3JpdHRlbiBieSB1c2VyIHRvIGNoYW5nZSBkZWZhdWx0IGxhYmVsIG1hcmt1cFxuICAgIC8vIGxvd2VyIHByaW9yaXR5IHRoYW4gZGVmYXVsdExhYmVsLm1hcmt1cFxuICAgIGxhYmVsTWFya3VwOiB1bmRlZmluZWQsXG5cbiAgICAvLyBwcml2YXRlXG4gICAgX2J1aWx0aW5zOiB7XG4gICAgICAgIGRlZmF1bHRMYWJlbDoge1xuICAgICAgICAgICAgLy8gYnVpbHRpbiBkZWZhdWx0IG1hcmt1cDpcbiAgICAgICAgICAgIC8vIHVzZWQgaWYgbmVpdGhlciBkZWZhdWx0TGFiZWwubWFya3VwXG4gICAgICAgICAgICAvLyBub3IgbGFiZWwubWFya3VwIGlzIHNldFxuICAgICAgICAgICAgbWFya3VwOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAncmVjdCcgLy8gZmFzdGVyIHRoYW4gdGFnTmFtZSBDU1Mgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICd0ZXh0JyAvLyBmYXN0ZXIgdGhhbiB0YWdOYW1lIENTUyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBidWlsdGluIGRlZmF1bHQgYXR0cmlidXRlczpcbiAgICAgICAgICAgIC8vIGFwcGxpZWQgb25seSBpZiBidWlsdGluIGRlZmF1bHQgbWFya3VwIGlzIHVzZWRcbiAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICByZWY6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICByeDogMyxcbiAgICAgICAgICAgICAgICAgICAgcnk6IDMsXG4gICAgICAgICAgICAgICAgICAgIHg6ICdjYWxjKHgpJyxcbiAgICAgICAgICAgICAgICAgICAgeTogJ2NhbGMoeSknLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJ2NhbGModyknLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgpJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBidWlsdGluIGRlZmF1bHQgcG9zaXRpb246XG4gICAgICAgICAgICAvLyB1c2VkIGlmIG5laXRoZXIgZGVmYXVsdExhYmVsLnBvc2l0aW9uXG4gICAgICAgICAgICAvLyBub3IgbGFiZWwucG9zaXRpb24gaXMgc2V0XG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiAwLjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWZhdWx0czoge1xuICAgICAgICBzb3VyY2U6IHt9LFxuICAgICAgICB0YXJnZXQ6IHt9XG4gICAgfSxcblxuICAgIGlzTGluazogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldCh7XG4gICAgICAgICAgICBzb3VyY2U6IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgdGFyZ2V0OiB7IHg6IDAsIHk6IDAgfVxuICAgICAgICB9LCBvcHQpO1xuICAgIH0sXG5cbiAgICBzb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSwgYXJncywgb3B0KSB7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lKHRoaXMuZ2V0KCdzb3VyY2UnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgdmFyIHNldFNvdXJjZTtcbiAgICAgICAgdmFyIHNldE9wdDtcblxuICAgICAgICAvLyBgc291cmNlYCBpcyBhIGNlbGxcbiAgICAgICAgLy8gdGFrZSBvbmx5IGl0cyBgaWRgIGFuZCBjb21iaW5lIHdpdGggYGFyZ3NgXG4gICAgICAgIHZhciBpc0NlbGxQcm92aWRlZCA9IHNvdXJjZSBpbnN0YW5jZW9mIENlbGw7XG4gICAgICAgIGlmIChpc0NlbGxQcm92aWRlZCkgeyAvLyB0aHJlZSBhcmd1bWVudHNcbiAgICAgICAgICAgIHNldFNvdXJjZSA9IGNsb25lKGFyZ3MpIHx8IHt9O1xuICAgICAgICAgICAgc2V0U291cmNlLmlkID0gc291cmNlLmlkO1xuICAgICAgICAgICAgc2V0T3B0ID0gb3B0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdzb3VyY2UnLCBzZXRTb3VyY2UsIHNldE9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBgc291cmNlYCBpcyBhIHBvaW50LWxpa2Ugb2JqZWN0XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCBhIGcuUG9pbnRcbiAgICAgICAgLy8gdGFrZSBvbmx5IGl0cyBgeGAgYW5kIGB5YCBhbmQgY29tYmluZSB3aXRoIGBhcmdzYFxuICAgICAgICB2YXIgaXNQb2ludFByb3ZpZGVkID0gIWlzUGxhaW5PYmplY3Qoc291cmNlKTtcbiAgICAgICAgaWYgKGlzUG9pbnRQcm92aWRlZCkgeyAvLyB0aHJlZSBhcmd1bWVudHNcbiAgICAgICAgICAgIHNldFNvdXJjZSA9IGNsb25lKGFyZ3MpIHx8IHt9O1xuICAgICAgICAgICAgc2V0U291cmNlLnggPSBzb3VyY2UueDtcbiAgICAgICAgICAgIHNldFNvdXJjZS55ID0gc291cmNlLnk7XG4gICAgICAgICAgICBzZXRPcHQgPSBvcHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3NvdXJjZScsIHNldFNvdXJjZSwgc2V0T3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBzb3VyY2VgIGlzIGFuIG9iamVjdFxuICAgICAgICAvLyBubyBjaGVja2luZ1xuICAgICAgICAvLyB0d28gYXJndW1lbnRzXG4gICAgICAgIHNldFNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgc2V0T3B0ID0gYXJncztcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdzb3VyY2UnLCBzZXRTb3VyY2UsIHNldE9wdCk7XG4gICAgfSxcblxuICAgIHRhcmdldDogZnVuY3Rpb24odGFyZ2V0LCBhcmdzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUodGhpcy5nZXQoJ3RhcmdldCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgc2V0VGFyZ2V0O1xuICAgICAgICB2YXIgc2V0T3B0O1xuXG4gICAgICAgIC8vIGB0YXJnZXRgIGlzIGEgY2VsbFxuICAgICAgICAvLyB0YWtlIG9ubHkgaXRzIGBpZGAgYXJndW1lbnQgYW5kIGNvbWJpbmUgd2l0aCBgYXJnc2BcbiAgICAgICAgdmFyIGlzQ2VsbFByb3ZpZGVkID0gdGFyZ2V0IGluc3RhbmNlb2YgQ2VsbDtcbiAgICAgICAgaWYgKGlzQ2VsbFByb3ZpZGVkKSB7IC8vIHRocmVlIGFyZ3VtZW50c1xuICAgICAgICAgICAgc2V0VGFyZ2V0ID0gY2xvbmUoYXJncykgfHwge307XG4gICAgICAgICAgICBzZXRUYXJnZXQuaWQgPSB0YXJnZXQuaWQ7XG4gICAgICAgICAgICBzZXRPcHQgPSBvcHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3RhcmdldCcsIHNldFRhcmdldCwgc2V0T3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGB0YXJnZXRgIGlzIGEgcG9pbnQtbGlrZSBvYmplY3RcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgZy5Qb2ludFxuICAgICAgICAvLyB0YWtlIG9ubHkgaXRzIGB4YCBhbmQgYHlgIGFuZCBjb21iaW5lIHdpdGggYGFyZ3NgXG4gICAgICAgIHZhciBpc1BvaW50UHJvdmlkZWQgPSAhaXNQbGFpbk9iamVjdCh0YXJnZXQpO1xuICAgICAgICBpZiAoaXNQb2ludFByb3ZpZGVkKSB7IC8vIHRocmVlIGFyZ3VtZW50c1xuICAgICAgICAgICAgc2V0VGFyZ2V0ID0gY2xvbmUoYXJncykgfHwge307XG4gICAgICAgICAgICBzZXRUYXJnZXQueCA9IHRhcmdldC54O1xuICAgICAgICAgICAgc2V0VGFyZ2V0LnkgPSB0YXJnZXQueTtcbiAgICAgICAgICAgIHNldE9wdCA9IG9wdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCgndGFyZ2V0Jywgc2V0VGFyZ2V0LCBzZXRPcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHRhcmdldGAgaXMgYW4gb2JqZWN0XG4gICAgICAgIC8vIG5vIGNoZWNraW5nXG4gICAgICAgIC8vIHR3byBhcmd1bWVudHNcbiAgICAgICAgc2V0VGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBzZXRPcHQgPSBhcmdzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3RhcmdldCcsIHNldFRhcmdldCwgc2V0T3B0KTtcbiAgICB9LFxuXG4gICAgcm91dGVyOiBmdW5jdGlvbihuYW1lLCBhcmdzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMuZ2V0KCdyb3V0ZXInKTtcbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJvdXRlciA9PT0gJ29iamVjdCcpIHJldHVybiBjbG9uZShyb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlcjsgLy8gZS5nLiBhIGZ1bmN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgdmFyIGlzUm91dGVyUHJvdmlkZWQgPSAoKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgfHwgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSk7XG4gICAgICAgIHZhciBsb2NhbFJvdXRlciA9IGlzUm91dGVyUHJvdmlkZWQgPyBuYW1lIDogeyBuYW1lOiBuYW1lLCBhcmdzOiBhcmdzIH07XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IGlzUm91dGVyUHJvdmlkZWQgPyBhcmdzIDogb3B0O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgncm91dGVyJywgbG9jYWxSb3V0ZXIsIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgY29ubmVjdG9yOiBmdW5jdGlvbihuYW1lLCBhcmdzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMuZ2V0KCdjb25uZWN0b3InKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3RvciA9PT0gJ29iamVjdCcpIHJldHVybiBjbG9uZShjb25uZWN0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjsgLy8gZS5nLiBhIGZ1bmN0aW9uXG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgdmFyIGlzQ29ubmVjdG9yUHJvdmlkZWQgPSAoKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykpO1xuICAgICAgICB2YXIgbG9jYWxDb25uZWN0b3IgPSBpc0Nvbm5lY3RvclByb3ZpZGVkID8gbmFtZSA6IHsgbmFtZTogbmFtZSwgYXJnczogYXJncyB9O1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSBpc0Nvbm5lY3RvclByb3ZpZGVkID8gYXJncyA6IG9wdDtcblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ2Nvbm5lY3RvcicsIGxvY2FsQ29ubmVjdG9yLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIC8vIExhYmVscyBBUElcblxuICAgIC8vIEEgY29udmVuaWVudCB3YXkgdG8gc2V0IGxhYmVscy4gQ3VycmVudGx5IHNldCB2YWx1ZXMgd2lsbCBiZSBtaXhpbmVkIHdpdGggYHZhbHVlYCBpZiB1c2VkIGFzIGEgc2V0dGVyLlxuICAgIGxhYmVsOiBmdW5jdGlvbihpZHgsIGxhYmVsLCBvcHQpIHtcblxuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHMoKTtcblxuICAgICAgICBpZHggPSAoaXNGaW5pdGUoaWR4KSAmJiBpZHggIT09IG51bGwpID8gKGlkeCB8IDApIDogMDtcbiAgICAgICAgaWYgKGlkeCA8IDApIGlkeCA9IGxhYmVscy5sZW5ndGggKyBpZHg7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHJldHVybiB0aGlzLnByb3AoWydsYWJlbHMnLCBpZHhdKTtcbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3AoWydsYWJlbHMnLCBpZHhdLCBsYWJlbCwgb3B0KTtcbiAgICB9LFxuXG4gICAgbGFiZWxzOiBmdW5jdGlvbihsYWJlbHMsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbGFiZWxzID0gdGhpcy5nZXQoJ2xhYmVscycpO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHMuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIGxhYmVscyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ2xhYmVscycsIGxhYmVscywgb3B0KTtcbiAgICB9LFxuXG4gICAgaGFzTGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBsYWJlbHMgfSA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobGFiZWxzKSAmJiBsYWJlbHMubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgaW5zZXJ0TGFiZWw6IGZ1bmN0aW9uKGlkeCwgbGFiZWwsIG9wdCkge1xuXG4gICAgICAgIGlmICghbGFiZWwpIHRocm93IG5ldyBFcnJvcignZGlhLkxpbms6IG5vIGxhYmVsIHByb3ZpZGVkJyk7XG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzKCk7XG4gICAgICAgIHZhciBuID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgaWR4ID0gKGlzRmluaXRlKGlkeCkgJiYgaWR4ICE9PSBudWxsKSA/IChpZHggfCAwKSA6IG47XG4gICAgICAgIGlmIChpZHggPCAwKSBpZHggPSBuICsgaWR4ICsgMTtcblxuICAgICAgICBsYWJlbHMuc3BsaWNlKGlkeCwgMCwgbGFiZWwpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHMobGFiZWxzLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvblxuICAgIC8vIGFkZCBsYWJlbCB0byBlbmQgb2YgbGFiZWxzIGFycmF5XG4gICAgYXBwZW5kTGFiZWw6IGZ1bmN0aW9uKGxhYmVsLCBvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRMYWJlbCgtMSwgbGFiZWwsIG9wdCk7XG4gICAgfSxcblxuICAgIHJlbW92ZUxhYmVsOiBmdW5jdGlvbihpZHgsIG9wdCkge1xuXG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscygpO1xuICAgICAgICBpZHggPSAoaXNGaW5pdGUoaWR4KSAmJiBpZHggIT09IG51bGwpID8gKGlkeCB8IDApIDogLTE7XG5cbiAgICAgICAgbGFiZWxzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHMobGFiZWxzLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBWZXJ0aWNlcyBBUElcblxuICAgIHZlcnRleDogZnVuY3Rpb24oaWR4LCB2ZXJ0ZXgsIG9wdCkge1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMoKTtcblxuICAgICAgICBpZHggPSAoaXNGaW5pdGUoaWR4KSAmJiBpZHggIT09IG51bGwpID8gKGlkeCB8IDApIDogMDtcbiAgICAgICAgaWYgKGlkeCA8IDApIGlkeCA9IHZlcnRpY2VzLmxlbmd0aCArIGlkeDtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkgcmV0dXJuIHRoaXMucHJvcChbJ3ZlcnRpY2VzJywgaWR4XSk7XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHZhciBzZXRWZXJ0ZXggPSB0aGlzLl9ub3JtYWxpemVWZXJ0ZXgodmVydGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcChbJ3ZlcnRpY2VzJywgaWR4XSwgc2V0VmVydGV4LCBvcHQpO1xuICAgIH0sXG5cbiAgICB2ZXJ0aWNlczogZnVuY3Rpb24odmVydGljZXMsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmVydGljZXMgPSB0aGlzLmdldCgndmVydGljZXMnKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJ0aWNlcykpIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcy5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2ZXJ0aWNlcykpIHZlcnRpY2VzID0gW107XG4gICAgICAgIHZhciBzZXRWZXJ0aWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgc2V0VmVydGV4ID0gdGhpcy5fbm9ybWFsaXplVmVydGV4KHZlcnRleCk7XG4gICAgICAgICAgICBzZXRWZXJ0aWNlcy5wdXNoKHNldFZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCd2ZXJ0aWNlcycsIHNldFZlcnRpY2VzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBpbnNlcnRWZXJ0ZXg6IGZ1bmN0aW9uKGlkeCwgdmVydGV4LCBvcHQpIHtcblxuICAgICAgICBpZiAoIXZlcnRleCkgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGluazogbm8gdmVydGV4IHByb3ZpZGVkJyk7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcygpO1xuICAgICAgICB2YXIgbiA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICAgICAgaWR4ID0gKGlzRmluaXRlKGlkeCkgJiYgaWR4ICE9PSBudWxsKSA/IChpZHggfCAwKSA6IG47XG4gICAgICAgIGlmIChpZHggPCAwKSBpZHggPSBuICsgaWR4ICsgMTtcblxuICAgICAgICB2YXIgc2V0VmVydGV4ID0gdGhpcy5fbm9ybWFsaXplVmVydGV4KHZlcnRleCk7XG4gICAgICAgIHZlcnRpY2VzLnNwbGljZShpZHgsIDAsIHNldFZlcnRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKHZlcnRpY2VzLCBvcHQpO1xuICAgIH0sXG5cbiAgICByZW1vdmVWZXJ0ZXg6IGZ1bmN0aW9uKGlkeCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcygpO1xuICAgICAgICBpZHggPSAoaXNGaW5pdGUoaWR4KSAmJiBpZHggIT09IG51bGwpID8gKGlkeCB8IDApIDogLTE7XG5cbiAgICAgICAgdmVydGljZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKHZlcnRpY2VzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBfbm9ybWFsaXplVmVydGV4OiBmdW5jdGlvbih2ZXJ0ZXgpIHtcblxuICAgICAgICAvLyBpcyB2ZXJ0ZXggYSBwb2ludC1saWtlIG9iamVjdD9cbiAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgZy5Qb2ludFxuICAgICAgICB2YXIgaXNQb2ludFByb3ZpZGVkID0gIWlzUGxhaW5PYmplY3QodmVydGV4KTtcbiAgICAgICAgaWYgKGlzUG9pbnRQcm92aWRlZCkgcmV0dXJuIHsgeDogdmVydGV4LngsIHk6IHZlcnRleC55IH07XG5cbiAgICAgICAgLy8gZWxzZTogcmV0dXJuIHZlcnRleCB1bmNoYW5nZWRcbiAgICAgICAgcmV0dXJuIHZlcnRleDtcbiAgICB9LFxuXG4gICAgLy8gVHJhbnNmb3JtYXRpb25zXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSwgb3B0KSB7XG5cbiAgICAgICAgLy8gZW5yaWNoIHRoZSBvcHRpb24gb2JqZWN0XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgb3B0LnRyYW5zbGF0ZUJ5ID0gb3B0LnRyYW5zbGF0ZUJ5IHx8IHRoaXMuaWQ7XG4gICAgICAgIG9wdC50eCA9IHR4O1xuICAgICAgICBvcHQudHkgPSB0eTtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRvUG9pbnRzKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IChwLnggfHwgMCkgKyB0eCwgeTogKHAueSB8fCAwKSArIHR5IH07XG4gICAgICAgIH0sIG9wdCk7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbiwgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUb1BvaW50cyhmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQocCkuc2NhbGUoc3gsIHN5LCBvcmlnaW4pLnRvSlNPTigpO1xuICAgICAgICB9LCBvcHQpO1xuICAgIH0sXG5cbiAgICBhcHBseVRvUG9pbnRzOiBmdW5jdGlvbihmbiwgb3B0KSB7XG5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlhLkxpbms6IGFwcGx5VG9Qb2ludHMgZXhwZWN0cyBpdHMgZmlyc3QgcGFyYW1ldGVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcblxuICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICBpZiAoIXNvdXJjZS5pZCkge1xuICAgICAgICAgICAgYXR0cnMuc291cmNlID0gZm4oc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldC5pZCkge1xuICAgICAgICAgICAgYXR0cnMudGFyZ2V0ID0gZm4odGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMoKTtcbiAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF0dHJzLnZlcnRpY2VzID0gdmVydGljZXMubWFwKGZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnNldChhdHRycywgb3B0KTtcbiAgICB9LFxuXG4gICAgZ2V0U291cmNlUG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc291cmNlQ2VsbCA9IHRoaXMuZ2V0U291cmNlQ2VsbCgpO1xuICAgICAgICBpZiAoIXNvdXJjZUNlbGwpIHJldHVybiBuZXcgUG9pbnQodGhpcy5zb3VyY2UoKSk7XG4gICAgICAgIHJldHVybiBzb3VyY2VDZWxsLmdldFBvaW50RnJvbUNvbm5lY3RlZExpbmsodGhpcywgJ3NvdXJjZScpO1xuICAgIH0sXG5cbiAgICBnZXRUYXJnZXRQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YXJnZXRDZWxsID0gdGhpcy5nZXRUYXJnZXRDZWxsKCk7XG4gICAgICAgIGlmICghdGFyZ2V0Q2VsbCkgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnRhcmdldCgpKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldENlbGwuZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluayh0aGlzLCAndGFyZ2V0Jyk7XG4gICAgfSxcblxuICAgIGdldFBvaW50RnJvbUNvbm5lY3RlZExpbms6IGZ1bmN0aW9uKC8qIGxpbmssIGVuZFR5cGUgKi8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9seWxpbmUoKS5wb2ludEF0KDAuNSk7XG4gICAgfSxcblxuICAgIGdldFBvbHlsaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW1xuICAgICAgICAgICAgdGhpcy5nZXRTb3VyY2VQb2ludCgpLFxuICAgICAgICAgICAgLi4udGhpcy52ZXJ0aWNlcygpLm1hcChQb2ludCksXG4gICAgICAgICAgICB0aGlzLmdldFRhcmdldFBvaW50KClcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZShwb2ludHMpO1xuICAgIH0sXG5cbiAgICBnZXRCQm94OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9seWxpbmUoKS5iYm94KCk7XG4gICAgfSxcblxuICAgIHJlcGFyZW50OiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgbmV3UGFyZW50O1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoKSB7XG5cbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIHZhciBwcmV2UGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDZWxsKCk7XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UgJiYgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0IHx8IHNvdXJjZS5pc0VtYmVkZGVkSW4odGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuaXNFbWJlZGRlZEluKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50ID0gc291cmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IHRoaXMuZ3JhcGguZ2V0Q29tbW9uQW5jZXN0b3Ioc291cmNlLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZQYXJlbnQgJiYgKCFuZXdQYXJlbnQgfHwgbmV3UGFyZW50LmlkICE9PSBwcmV2UGFyZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIC8vIFVuZW1iZWQgdGhlIGxpbmsgaWYgc291cmNlIGFuZCB0YXJnZXQgaGFzIG5vIGNvbW1vbiBhbmNlc3RvclxuICAgICAgICAgICAgICAgIC8vIG9yIGNvbW1vbiBhbmNlc3RvciBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgcHJldlBhcmVudC51bmVtYmVkKHRoaXMsIG9wdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBuZXdQYXJlbnQuZW1iZWQodGhpcywgb3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdQYXJlbnQ7XG4gICAgfSxcblxuICAgIGhhc0xvb3A6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgc291cmNlSWQgPSBzb3VyY2UuaWQ7XG4gICAgICAgIHZhciB0YXJnZXRJZCA9IHRhcmdldC5pZDtcblxuICAgICAgICBpZiAoIXNvdXJjZUlkIHx8ICF0YXJnZXRJZCkge1xuICAgICAgICAgICAgLy8gTGluayBcInBpbm5lZFwiIHRvIHRoZSBwYXBlciBkb2VzIG5vdCBoYXZlIGEgbG9vcC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb29wID0gc291cmNlSWQgPT09IHRhcmdldElkO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGVyZSBpbiB0aGUgZGVlcCBtb2RlIGEgbGluayBjYW4gaGF2ZSBhIGxvb3AsXG4gICAgICAgIC8vIGV2ZW4gaWYgaXQgY29ubmVjdHMgb25seSBhIHBhcmVudCBhbmQgaXRzIGVtYmVkLlxuICAgICAgICAvLyBBIGxvb3AgXCJ0YXJnZXQgZXF1YWxzIHNvdXJjZVwiIGlzIHZhbGlkIGluIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBtb2RlLlxuICAgICAgICBpZiAoIWxvb3AgJiYgb3B0LmRlZXAgJiYgdGhpcy5ncmFwaCkge1xuXG4gICAgICAgICAgICB2YXIgc291cmNlRWxlbWVudCA9IHRoaXMuZ2V0U291cmNlQ2VsbCgpO1xuICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldENlbGwoKTtcblxuICAgICAgICAgICAgbG9vcCA9IHNvdXJjZUVsZW1lbnQuaXNFbWJlZGRlZEluKHRhcmdldEVsZW1lbnQpIHx8IHRhcmdldEVsZW1lbnQuaXNFbWJlZGRlZEluKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvb3A7XG4gICAgfSxcblxuICAgIC8vIHVubGlrZSBzb3VyY2UoKSwgdGhpcyBtZXRob2QgcmV0dXJucyBudWxsIGlmIHNvdXJjZSBpcyBhIHBvaW50XG4gICAgZ2V0U291cmNlQ2VsbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc3QgeyBncmFwaCwgYXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICAgICAgdmFyIHNvdXJjZSA9IGF0dHJpYnV0ZXMuc291cmNlO1xuICAgICAgICByZXR1cm4gKHNvdXJjZSAmJiBzb3VyY2UuaWQgJiYgZ3JhcGggJiYgZ3JhcGguZ2V0Q2VsbChzb3VyY2UuaWQpKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRTb3VyY2VFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzO1xuICAgICAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtjZWxsLmlkXSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2aXNpdGVkW2NlbGwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLmdldFNvdXJjZUNlbGwoKTtcbiAgICAgICAgfSB3aGlsZSAoY2VsbCAmJiBjZWxsLmlzTGluaygpKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8vIHVubGlrZSB0YXJnZXQoKSwgdGhpcyBtZXRob2QgcmV0dXJucyBudWxsIGlmIHRhcmdldCBpcyBhIHBvaW50XG4gICAgZ2V0VGFyZ2V0Q2VsbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc3QgeyBncmFwaCwgYXR0cmlidXRlcyB9ID0gdGhpcztcbiAgICAgICAgdmFyIHRhcmdldCA9IGF0dHJpYnV0ZXMudGFyZ2V0O1xuICAgICAgICByZXR1cm4gKHRhcmdldCAmJiB0YXJnZXQuaWQgJiYgZ3JhcGggJiYgZ3JhcGguZ2V0Q2VsbCh0YXJnZXQuaWQpKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRUYXJnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzO1xuICAgICAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtjZWxsLmlkXSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2aXNpdGVkW2NlbGwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNlbGwgPSBjZWxsLmdldFRhcmdldENlbGwoKTtcbiAgICAgICAgfSB3aGlsZSAoY2VsbCAmJiBjZWxsLmlzTGluaygpKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGNvbW1vbiBhbmNlc3RvciBmb3IgdGhlIHNvdXJjZSBlbGVtZW50LFxuICAgIC8vIHRhcmdldCBlbGVtZW50IGFuZCB0aGUgbGluayBpdHNlbGYuXG4gICAgZ2V0UmVsYXRpb25zaGlwQW5jZXN0b3I6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjb25uZWN0aW9uQW5jZXN0b3I7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcblxuICAgICAgICAgICAgdmFyIGNlbGxzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTb3VyY2VFbGVtZW50KCksIC8vIG51bGwgaWYgc291cmNlIGlzIGEgcG9pbnRcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRhcmdldEVsZW1lbnQoKSAvLyBudWxsIGlmIHRhcmdldCBpcyBhIHBvaW50XG4gICAgICAgICAgICBdLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhaXRlbTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25uZWN0aW9uQW5jZXN0b3IgPSB0aGlzLmdyYXBoLmdldENvbW1vbkFuY2VzdG9yLmFwcGx5KHRoaXMuZ3JhcGgsIGNlbGxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uQW5jZXN0b3IgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gSXMgc291cmNlLCB0YXJnZXQgYW5kIHRoZSBsaW5rIGl0c2VsZiBlbWJlZGRlZCBpbiBhIGdpdmVuIGNlbGw/XG4gICAgaXNSZWxhdGlvbnNoaXBFbWJlZGRlZEluOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgdmFyIGNlbGxJZCA9IChpc1N0cmluZyhjZWxsKSB8fCBpc051bWJlcihjZWxsKSkgPyBjZWxsIDogY2VsbC5pZDtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gdGhpcy5nZXRSZWxhdGlvbnNoaXBBbmNlc3RvcigpO1xuXG4gICAgICAgIHJldHVybiAhIWFuY2VzdG9yICYmIChhbmNlc3Rvci5pZCA9PT0gY2VsbElkIHx8IGFuY2VzdG9yLmlzRW1iZWRkZWRJbihjZWxsSWQpKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHJlc29sdmVkIGRlZmF1bHQgbGFiZWwuXG4gICAgX2dldERlZmF1bHRMYWJlbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbCA9IHRoaXMuZ2V0KCdkZWZhdWx0TGFiZWwnKSB8fCB0aGlzLmRlZmF1bHRMYWJlbCB8fCB7fTtcblxuICAgICAgICB2YXIgbGFiZWwgPSB7fTtcbiAgICAgICAgbGFiZWwubWFya3VwID0gZGVmYXVsdExhYmVsLm1hcmt1cCB8fCB0aGlzLmdldCgnbGFiZWxNYXJrdXAnKSB8fCB0aGlzLmxhYmVsTWFya3VwO1xuICAgICAgICBsYWJlbC5wb3NpdGlvbiA9IGRlZmF1bHRMYWJlbC5wb3NpdGlvbjtcbiAgICAgICAgbGFiZWwuYXR0cnMgPSBkZWZhdWx0TGFiZWwuYXR0cnM7XG4gICAgICAgIGxhYmVsLnNpemUgPSBkZWZhdWx0TGFiZWwuc2l6ZTtcblxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxufSwge1xuXG4gICAgZW5kc0VxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgICAgdmFyIHBvcnRzRXF1YWwgPSBhLnBvcnQgPT09IGIucG9ydCB8fCAhYS5wb3J0ICYmICFiLnBvcnQ7XG4gICAgICAgIHJldHVybiBhLmlkID09PSBiLmlkICYmIHBvcnRzRXF1YWw7XG4gICAgfVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/Link.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/LinkView.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/LinkView.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinkView: () => (/* binding */ LinkView)\n/* harmony export */ });\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Link.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Link.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _routers_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../routers/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/index.mjs\");\n/* harmony import */ var _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../connectors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectors/index.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/env/index.mjs\");\n\n\n\n\n\n\n\n\n\nconst Flags = {\n    TOOLS: _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Flags.TOOLS,\n    RENDER: 'RENDER',\n    UPDATE: 'UPDATE',\n    LABELS: 'LABELS',\n    SOURCE: 'SOURCE',\n    TARGET: 'TARGET',\n    CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nconst LinkView = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.extend({\n\n    className: function() {\n\n        var classNames = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n\n    presentationAttributes: {\n        markup: [Flags.RENDER],\n        attrs: [Flags.UPDATE],\n        router: [Flags.UPDATE],\n        connector: [Flags.CONNECTOR],\n        labels: [Flags.LABELS, Flags.TOOLS],\n        labelMarkup: [Flags.LABELS],\n        vertices: [Flags.UPDATE],\n        source: [Flags.SOURCE, Flags.UPDATE],\n        target: [Flags.TARGET, Flags.UPDATE]\n    },\n\n    initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\n    UPDATE_PRIORITY: 1,\n    EPSILON: 1e-6,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n\n            if (_env_index_mjs__WEBPACK_IMPORTED_MODULE_1__.env.test('isSafari')) {\n                this.__fixSafariBug268376();\n            }\n\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n            updateLabels = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n\n        return flags;\n    },\n\n    __fixSafariBug268376: function() {\n        // Safari has a bug where any change after the first render is not reflected in the DOM.\n        // https://bugs.webkit.org/show_bug.cgi?id=268376\n        const { el } = this;\n        const childNodes = Array.from(el.childNodes);\n        const fragment = document.createDocumentFragment();\n        for (let i = 0, n = childNodes.length; i < n; i++) {\n            el.removeChild(childNodes[i]);\n            fragment.appendChild(childNodes[i]);\n        }\n        el.appendChild(fragment);\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('g').append(fragment);\n        } else {\n            vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('g').addClass('labels');\n            if (this.options.labelsLayer) {\n                vLabels.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.addClassNamePrefix)((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result)(this, 'className')));\n                vLabels.attr('model-id', model.id);\n            }\n        }\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n\n    findLabelNodes: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return [];\n        const labelSelectors = this._labelSelectors[labelIndex];\n        return this.findBySelector(selector, labelRoot, labelSelectors);\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const [node = null] = this.findLabelNodes(labelIndex, selector);\n        return node;\n    },\n\n    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelAttrs, labelAttrs);\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    // merge default label size into label size (no built-in default)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n\n        if (labelSize === null) return null;\n        if (labelSize === undefined) {\n\n            if (defaultLabelSize === null) return null;\n            if (defaultLabelSize === undefined) return undefined;\n\n            return defaultLabelSize;\n        }\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelSize, labelSize);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        if (!this.paper.options.labelLayer) {\n            // If there is no label layer, the cache needs to be cleared\n            // of the root node because the labels are attached\n            // to it and could affect the bounding box.\n            this.cleanNodeCache(this.el);\n        }\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n        var defaultLabelSize = defaultLabel.size;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n            var labelSize = label.size;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            var size = this._mergeLabelSize(\n                labelSize,\n                defaultLabelSize\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.sourceAnchor);\n            case 'target':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.sourcePoint);\n            case 'target':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n\n    // Updating.\n    // ---------\n\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and anchor points.\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n\n    updateDOM() {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors });\n        // update the label position etc.\n        this.updateLabelPositions();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 4. Find Connection\n        const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n        this.path = path;\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (this.options.perpendicular) {\n                    // Backwards compatibility\n                    // See `manhattan` router for more details\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    isIntersecting: function(geometryShape, geometryData) {\n        const connection = this.getConnection();\n        if (!connection) return false;\n        return _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__.intersection.exists(\n            geometryShape,\n            connection,\n            geometryData,\n            { segmentSubdivisions: this.getConnectionSubdivisions() },\n        );\n    },\n\n    isEnclosedIn: function(geometryRect) {\n        const connection = this.getConnection();\n        if (!connection) return false;\n        const bbox = connection.bbox();\n        if (!bbox) return false;\n        return geometryRect.containsRect(bbox);\n    },\n\n    isAtPoint: function(point /*, options */) {\n        // Note: `strict` option is not applicable for links.\n        // There is currently no method to determine if a path contains a point.\n        const area = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(point);\n        // Intersection with a zero-size area is not possible.\n        area.inflate(this.EPSILON);\n        return this.isIntersecting(area);\n    },\n\n    // combine default label position with built-in default label position\n    _getDefaultLabelPositionProperty: function() {\n\n        var model = this.model;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelPosition, defaultLabelPosition);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    // expects normalized position properties\n    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\n        if (normalizedLabelPosition === null) return null;\n        if (normalizedLabelPosition === undefined) {\n\n            if (normalizedDefaultLabelPosition === null) return null;\n            return normalizedDefaultLabelPosition;\n        }\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _getLabelPositionProperty: function(idx) {\n\n        return (this.model.label(idx).position || {});\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isObject)(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findNode(selector);\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = this.paper.options.routerNamespace || _routers_index_mjs__WEBPACK_IMPORTED_MODULE_10__;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point); // no router specified\n        }\n\n        var routerFn = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(router) ? router : namespace[router.name];\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = this.paper.options.connectorNamespace || _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_11__;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(connector) ? connector : namespace[connector.name];\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.clone)(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_12__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start.clone();\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_13__.normalizeAngle)(((angle + 90) % 180) - 90);\n                }\n            }\n\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start.clone();\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragLabelStart: function(evt, x, y) {\n\n        if (this.can('labelMove')) {\n\n            if (this.isDefaultInteractionPrevented(evt)) return;\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\n            var coords = this.getLabelCoordinates(position);\n            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                dx: dx,\n                dy: dy,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition((x + data.dx), (y + data.dy), data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        // The `touchmove' events are not fired\n        // when the original event target is removed from the DOM.\n        // The labels are currently re-rendered completely when only\n        // the position changes. This is why we need to make sure that\n        // the label is updated synchronously.\n        // TODO: replace `touchmove` with `pointermove` (breaking change).\n        const setOptions = { ui: true };\n        if (this.paper.isAsync() && evt.type === 'touchmove') {\n            setOptions.async = false;\n        }\n        this.model.label(data.labelIdx, label, setOptions);\n    },\n\n    dragArrowhead: function(evt, x, y) {\n        if (this.paper.options.snapLinks) {\n            const isSnapped = this._snapArrowhead(evt, x, y);\n            if (!isSnapped && this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            }\n        } else {\n            if (this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            } else {\n                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n            }\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !_Link_mjs__WEBPACK_IMPORTED_MODULE_14__.Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapToPoints: function(snapPoint, points, radius) {\n        let closestPointX = null;\n        let closestDistanceX = Infinity;\n\n        let closestPointY = null;\n        let closestDistanceY = Infinity;\n\n        let x = snapPoint.x;\n        let y = snapPoint.y;\n\n        for (let i = 0; i < points.length; i++) {\n            const distX = Math.abs(points[i].x - snapPoint.x);\n            if (distX < closestDistanceX) {\n                closestDistanceX = distX;\n                closestPointX = points[i];\n            }\n\n            const distY = Math.abs(points[i].y - snapPoint.y);\n            if (distY < closestDistanceY) {\n                closestDistanceY = distY;\n                closestPointY = points[i];\n            }\n        }\n\n        if (closestDistanceX < radius) {\n            x = closestPointX.x;\n        }\n        if (closestDistanceY < radius) {\n            y = closestPointY.y;\n        }\n\n        return { x, y };\n    },\n\n    _snapArrowheadSelf: function(evt, x, y) {\n\n        const { paper, model } = this;\n        const { snapLinksSelf } = paper.options;\n        const data = this.eventData(evt);\n        const radius = snapLinksSelf.radius || 20;\n\n        const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n        const vertices = model.vertices();\n        const points = [anchor, ...vertices];\n\n        const snapPoint = this._snapToPoints({ x: x, y: y }, points, radius);\n\n        const point = paper.localToClientPoint(snapPoint);\n        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        let isSnapped = false;\n        // checking view in close area of the pointer\n\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findElementViewsInArea(\n            { x: x - r, y: y - r, width: 2 * r, height: 2 * r },\n            snapLinks.findInAreaOptions\n        );\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y);\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n            isSnapped = true;\n\n            if (!newClosestMagnet)  {\n                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n            }\n\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isEqual)(prevEnd, end)) {\n                // the source/target json has not changed\n                return isSnapped;\n            }\n\n            data.prevEnd = end;\n\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n\n        return isSnapped;\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.clone)(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    },\n\n    // Lifecycle methods\n\n    onMount: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.onMount.apply(this, arguments);\n        this.mountLabels();\n    },\n\n    onDetach: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.onDetach.apply(this, arguments);\n        this.unmountLabels();\n    },\n\n    onRemove: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9MaW5rVmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwQztBQUNSO0FBQ0g7QUFDbUc7QUFDakM7QUFDakQ7QUFDTTtBQUNmOztBQUV2QztBQUNBLFdBQVcsbURBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTyxpQkFBaUIsbURBQVE7O0FBRWhDOztBQUVBLHlCQUF5QixtREFBUTs7QUFFakM7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxtREFBUTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiwrQ0FBRztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGFBQWE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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aEI7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUk7QUFDM0I7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvTGlua1ZpZXcubWpzP2E2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2VsbFZpZXcgfSBmcm9tICcuL0NlbGxWaWV3Lm1qcyc7XG5pbXBvcnQgeyBMaW5rIH0gZnJvbSAnLi9MaW5rLm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBhZGRDbGFzc05hbWVQcmVmaXgsIG1lcmdlLCBhc3NpZ24sIGlzT2JqZWN0LCBpc0Z1bmN0aW9uLCBjbG9uZSwgaXNQZXJjZW50YWdlLCByZXN1bHQsIGlzRXF1YWwgfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCwgTGluZSwgUGF0aCwgbm9ybWFsaXplQW5nbGUsIFJlY3QsIFBvbHlsaW5lLCBpbnRlcnNlY3Rpb24gfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyByb3V0ZXJzIGZyb20gJy4uL3JvdXRlcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGNvbm5lY3RvcnMgZnJvbSAnLi4vY29ubmVjdG9ycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vZW52L2luZGV4Lm1qcyc7XG5cbmNvbnN0IEZsYWdzID0ge1xuICAgIFRPT0xTOiBDZWxsVmlldy5GbGFncy5UT09MUyxcbiAgICBSRU5ERVI6ICdSRU5ERVInLFxuICAgIFVQREFURTogJ1VQREFURScsXG4gICAgTEFCRUxTOiAnTEFCRUxTJyxcbiAgICBTT1VSQ0U6ICdTT1VSQ0UnLFxuICAgIFRBUkdFVDogJ1RBUkdFVCcsXG4gICAgQ09OTkVDVE9SOiAnQ09OTkVDVE9SJ1xufTtcblxuLy8gTGluayBiYXNlIHZpZXcgYW5kIGNvbnRyb2xsZXIuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBMaW5rVmlldyA9IENlbGxWaWV3LmV4dGVuZCh7XG5cbiAgICBjbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gQ2VsbFZpZXcucHJvdG90eXBlLmNsYXNzTmFtZS5hcHBseSh0aGlzKS5zcGxpdCgnICcpO1xuXG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnbGluaycpO1xuXG4gICAgICAgIHJldHVybiBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgX2xhYmVsQ2FjaGU6IG51bGwsXG4gICAgX2xhYmVsU2VsZWN0b3JzOiBudWxsLFxuICAgIF9WOiBudWxsLFxuICAgIF9kcmFnRGF0YTogbnVsbCwgLy8gZGVwcmVjYXRlZFxuXG4gICAgbWV0cmljczogbnVsbCxcbiAgICBkZWNpbWFsc1JvdW5kaW5nOiAyLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBgXy5sYWJlbENhY2hlYCBpcyBhIG1hcHBpbmcgb2YgaW5kZXhlcyBvZiBsYWJlbHMgaW4gdGhlIGB0aGlzLmdldCgnbGFiZWxzJylgIGFycmF5IHRvXG4gICAgICAgIC8vIGA8ZyBjbGFzcz1cImxhYmVsXCI+YCBub2RlcyB3cmFwcGVkIGJ5IFZlY3Rvcml6ZXIuIFRoaXMgYWxsb3dzIGZvciBxdWljayBhY2Nlc3MgdG8gdGhlXG4gICAgICAgIC8vIG5vZGVzIGluIGB1cGRhdGVMYWJlbFBvc2l0aW9uKClgIGluIG9yZGVyIHRvIHVwZGF0ZSB0aGUgbGFiZWwgcG9zaXRpb25zLlxuICAgICAgICB0aGlzLl9sYWJlbENhY2hlID0ge307XG5cbiAgICAgICAgLy8gYSBjYWNoZSBvZiBsYWJlbCBzZWxlY3RvcnNcbiAgICAgICAgdGhpcy5fbGFiZWxTZWxlY3RvcnMgPSB7fTtcblxuICAgICAgICAvLyBjYWNoZSBvZiBkZWZhdWx0IG1hcmt1cCBub2Rlc1xuICAgICAgICB0aGlzLl9WID0ge307XG5cbiAgICAgICAgLy8gY29ubmVjdGlvbiBwYXRoIG1ldHJpY3NcbiAgICAgICAgdGhpcy5jbGVhbk5vZGVzQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgcHJlc2VudGF0aW9uQXR0cmlidXRlczoge1xuICAgICAgICBtYXJrdXA6IFtGbGFncy5SRU5ERVJdLFxuICAgICAgICBhdHRyczogW0ZsYWdzLlVQREFURV0sXG4gICAgICAgIHJvdXRlcjogW0ZsYWdzLlVQREFURV0sXG4gICAgICAgIGNvbm5lY3RvcjogW0ZsYWdzLkNPTk5FQ1RPUl0sXG4gICAgICAgIGxhYmVsczogW0ZsYWdzLkxBQkVMUywgRmxhZ3MuVE9PTFNdLFxuICAgICAgICBsYWJlbE1hcmt1cDogW0ZsYWdzLkxBQkVMU10sXG4gICAgICAgIHZlcnRpY2VzOiBbRmxhZ3MuVVBEQVRFXSxcbiAgICAgICAgc291cmNlOiBbRmxhZ3MuU09VUkNFLCBGbGFncy5VUERBVEVdLFxuICAgICAgICB0YXJnZXQ6IFtGbGFncy5UQVJHRVQsIEZsYWdzLlVQREFURV1cbiAgICB9LFxuXG4gICAgaW5pdEZsYWc6IFtGbGFncy5SRU5ERVIsIEZsYWdzLlNPVVJDRSwgRmxhZ3MuVEFSR0VULCBGbGFncy5UT09MU10sXG5cbiAgICBVUERBVEVfUFJJT1JJVFk6IDEsXG4gICAgRVBTSUxPTjogMWUtNixcblxuICAgIGNvbmZpcm1VcGRhdGU6IGZ1bmN0aW9uKGZsYWdzLCBvcHQpIHtcblxuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcblxuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5TT1VSQ0UpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlRW5kUHJvcGVydGllcygnc291cmNlJykpIHJldHVybiBmbGFncztcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBGbGFncy5TT1VSQ0UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFncywgRmxhZ3MuVEFSR0VUKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZUVuZFByb3BlcnRpZXMoJ3RhcmdldCcpKSByZXR1cm4gZmxhZ3M7XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFncywgRmxhZ3MuVEFSR0VUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIHNvdXJjZVZpZXcsIHRhcmdldFZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwYXBlciAmJiAoKHNvdXJjZVZpZXcgJiYgIXBhcGVyLmlzVmlld01vdW50ZWQoc291cmNlVmlldykpIHx8ICh0YXJnZXRWaWV3ICYmICFwYXBlci5pc1ZpZXdNb3VudGVkKHRhcmdldFZpZXcpKSkpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBzb3VyY2VWaWV3IGFuZCB0YXJnZXRWaWV3IHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5SRU5ERVIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHRlcnModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2xzKG9wdCk7XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFncywgW0ZsYWdzLlJFTkRFUiwgRmxhZ3MuVVBEQVRFLCBGbGFncy5MQUJFTFMsIEZsYWdzLlRPT0xTLCBGbGFncy5DT05ORUNUT1JdKTtcblxuICAgICAgICAgICAgaWYgKGVudi50ZXN0KCdpc1NhZmFyaScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ZpeFNhZmFyaUJ1ZzI2ODM3NigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBtb2RlbDtcbiAgICAgICAgbGV0IHVwZGF0ZUxhYmVscyA9IHRoaXMuaGFzRmxhZyhmbGFncywgRmxhZ3MuTEFCRUxTKTtcblxuICAgICAgICBpZiAodXBkYXRlTGFiZWxzKSB7XG4gICAgICAgICAgICB0aGlzLm9uTGFiZWxzQ2hhbmdlKG1vZGVsLCBhdHRyaWJ1dGVzLmxhYmVscywgb3B0KTtcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBGbGFncy5MQUJFTFMpO1xuICAgICAgICAgICAgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwZGF0ZUFsbCA9IHRoaXMuaGFzRmxhZyhmbGFncywgRmxhZ3MuVVBEQVRFKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29ubmVjdG9yID0gdGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5DT05ORUNUT1IpO1xuICAgICAgICBpZiAodXBkYXRlQWxsIHx8IHVwZGF0ZUNvbm5lY3Rvcikge1xuICAgICAgICAgICAgaWYgKCF1cGRhdGVBbGwpIHtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IHJvdXRlIGFuZCB1cGRhdGUgdGhlIGdlb21ldHJ5XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0LnRyYW5zbGF0ZUJ5ICYmIG1vZGVsLmlzUmVsYXRpb25zaGlwRW1iZWRkZWRJbihvcHQudHJhbnNsYXRlQnkpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxpbmsgaXMgYmVpbmcgdHJhbnNsYXRlZCBieSBhbiBhbmNlc3RvciB0aGF0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyBzaGlmdCBzb3VyY2UgcG9pbnQsIHRhcmdldCBwb2ludCBhbmQgYWxsIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgLy8gYnkgYW4gZXF1YWwgZGlzdGFuY2UuXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUob3B0LnR4LCBvcHQudHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29scyhvcHQpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIFtGbGFncy5VUERBVEUsIEZsYWdzLlRPT0xTLCBGbGFncy5DT05ORUNUT1JdKTtcbiAgICAgICAgICAgIHVwZGF0ZUxhYmVscyA9IGZhbHNlO1xuICAgICAgICAgICAgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cGRhdGVIaWdobGlnaHRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0ZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5UT09MUykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHMob3B0KTtcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBGbGFncy5UT09MUyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfSxcblxuICAgIF9fZml4U2FmYXJpQnVnMjY4Mzc2OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gU2FmYXJpIGhhcyBhIGJ1ZyB3aGVyZSBhbnkgY2hhbmdlIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgaXMgbm90IHJlZmxlY3RlZCBpbiB0aGUgRE9NLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjY4Mzc2XG4gICAgICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjaGlsZE5vZGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3RDb25uZWN0aW9uVXBkYXRlOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKHRoaXMuZ2V0RmxhZyhGbGFncy5VUERBVEUpLCBvcHQpO1xuICAgIH0sXG5cbiAgICBpc0xhYmVsc1JlbmRlclJlcXVpcmVkOiBmdW5jdGlvbihvcHQgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzTGFiZWxzID0gdGhpcy5tb2RlbC5wcmV2aW91cygnbGFiZWxzJyk7XG4gICAgICAgIGlmICghcHJldmlvdXNMYWJlbHMpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIC8vIEhlcmUgaXMgYW4gb3B0aW1pemF0aW9uIGZvciBjYXNlcyB3aGVuIHdlIGtub3csIHRoYXQgY2hhbmdlIGRvZXNcbiAgICAgICAgLy8gbm90IHJlcXVpcmUgcmUtcmVuZGVyaW5nIG9mIGFsbCBsYWJlbHMuXG4gICAgICAgIGlmICgoJ3Byb3BlcnR5UGF0aEFycmF5JyBpbiBvcHQpICYmICgncHJvcGVydHlWYWx1ZScgaW4gb3B0KSkge1xuICAgICAgICAgICAgLy8gVGhlIGxhYmVsIGlzIHNldHRpbmcgYnkgYHByb3AoKWAgbWV0aG9kXG4gICAgICAgICAgICB2YXIgcGF0aEFycmF5ID0gb3B0LnByb3BlcnR5UGF0aEFycmF5IHx8IFtdO1xuICAgICAgICAgICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBhdGhMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGNoYW5naW5nIGEgc2luZ2xlIGxhYmVsIGhlcmUgZS5nLiAnbGFiZWxzLzAvcG9zaXRpb24nXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRXhpc3RzID0gISFwcmV2aW91c0xhYmVsc1twYXRoQXJyYXlbMV1dO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbEV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aExlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIGNoYW5naW5nIHRoZSBlbnRpcmUgbGFiZWwuIE5lZWQgdG8gY2hlY2sgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXJrdXAgaXMgYWxzbyBiZWluZyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnbWFya3VwJyBpbiBPYmplY3Qob3B0LnByb3BlcnR5VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXRoQXJyYXlbMl0gIT09ICdtYXJrdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hhbmdpbmcgYSBsYWJlbCBwcm9wZXJ0eSBidXQgbm90IHRoZSBtYXJrdXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBvbkxhYmVsc0NoYW5nZTogZnVuY3Rpb24oX2xpbmssIF9sYWJlbHMsIG9wdCkge1xuXG4gICAgICAgIC8vIE5vdGU6IHRoaXMgb3B0aW1pemF0aW9uIHdvcmtzIGluIGFzeW5jPWZhbHNlIG1vZGUgb25seVxuICAgICAgICBpZiAodGhpcy5pc0xhYmVsc1JlbmRlclJlcXVpcmVkKG9wdCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbmRlcmluZy5cbiAgICAvLyAtLS0tLS0tLS0tXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMudmVsLmVtcHR5KCk7XG4gICAgICAgIHRoaXMudW5tb3VudExhYmVscygpO1xuICAgICAgICB0aGlzLl9WID0ge307XG4gICAgICAgIHRoaXMucmVuZGVyTWFya3VwKCk7XG4gICAgICAgIC8vIHJlbmRlcmluZyBsYWJlbHMgaGFzIHRvIGJlIHJ1biBhZnRlciB0aGUgbGluayBpcyBhcHBlbmRlZCB0byBET00gdHJlZS4gKG90aGVyd2lzZSA8VGV4dD4gYmJveFxuICAgICAgICAvLyByZXR1cm5zIHplcm8gdmFsdWVzKVxuICAgICAgICB0aGlzLnJlbmRlckxhYmVscygpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXJNYXJrdXA6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG1hcmt1cCA9IGxpbmsuZ2V0KCdtYXJrdXAnKSB8fCBsaW5rLm1hcmt1cDtcbiAgICAgICAgaWYgKCFtYXJrdXApIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiBtYXJrdXAgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFya3VwKSkgcmV0dXJuIHRoaXMucmVuZGVySlNPTk1hcmt1cChtYXJrdXApO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLnJlbmRlclN0cmluZ01hcmt1cChtYXJrdXApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogaW52YWxpZCBtYXJrdXAnKTtcbiAgICB9LFxuXG4gICAgcmVuZGVySlNPTk1hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdmFyIGRvYyA9IHRoaXMucGFyc2VET01KU09OKG1hcmt1cCwgdGhpcy5lbCk7XG4gICAgICAgIC8vIFNlbGVjdG9yc1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IGRvYy5zZWxlY3RvcnM7XG4gICAgICAgIC8vIEZyYWdtZW50XG4gICAgICAgIHRoaXMudmVsLmFwcGVuZChkb2MuZnJhZ21lbnQpO1xuICAgIH0sXG5cbiAgICByZW5kZXJTdHJpbmdNYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCkge1xuXG4gICAgICAgIC8vIEEgc3BlY2lhbCBtYXJrdXAgY2FuIGJlIGdpdmVuIGluIHRoZSBgcHJvcGVydGllcy5tYXJrdXBgIHByb3BlcnR5LiBUaGlzIG1pZ2h0IGJlIGhhbmR5XG4gICAgICAgIC8vIGlmIGUuZy4gYXJyb3doZWFkIG1hcmtlcnMgc2hvdWxkIGJlIGA8aW1hZ2U+YCBlbGVtZW50cyBvciBhbnkgb3RoZXIgZWxlbWVudCB0aGFuIGA8cGF0aD5gcy5cbiAgICAgICAgLy8gYC5jb25uZWN0aW9uYCwgYC5jb25uZWN0aW9uLXdyYXBgLCBgLm1hcmtlci1zb3VyY2VgIGFuZCBgLm1hcmtlci10YXJnZXRgIHNlbGVjdG9yc1xuICAgICAgICAvLyBvZiBlbGVtZW50cyB3aXRoIHNwZWNpYWwgbWVhbmluZyB0aG91Z2guIFRoZXJlZm9yZSwgdGhvc2UgY2xhc3NlcyBzaG91bGQgYmUgcHJlc2VydmVkIGluIGFueVxuICAgICAgICAvLyBzcGVjaWFsIG1hcmt1cCBwYXNzZWQgaW4gYHByb3BlcnRpZXMubWFya3VwYC5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gVihtYXJrdXApO1xuICAgICAgICAvLyBjdXN0b20gbWFya3VwIG1heSBjb250YWluIG9ubHkgb25lIGNoaWxkcmVuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcblxuICAgICAgICB0aGlzLnZlbC5hcHBlbmQoY2hpbGRyZW4pO1xuICAgIH0sXG5cbiAgICBfZ2V0TGFiZWxNYXJrdXA6IGZ1bmN0aW9uKGxhYmVsTWFya3VwKSB7XG5cbiAgICAgICAgaWYgKCFsYWJlbE1hcmt1cCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYWJlbE1hcmt1cCkpIHJldHVybiB0aGlzLnBhcnNlRE9NSlNPTihsYWJlbE1hcmt1cCwgbnVsbCk7XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxNYXJrdXAgPT09ICdzdHJpbmcnKSByZXR1cm4gdGhpcy5fZ2V0TGFiZWxTdHJpbmdNYXJrdXAobGFiZWxNYXJrdXApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5saW5rVmlldzogaW52YWxpZCBsYWJlbCBtYXJrdXAnKTtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsU3RyaW5nTWFya3VwOiBmdW5jdGlvbihsYWJlbE1hcmt1cCkge1xuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFYobGFiZWxNYXJrdXApO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGRyZW4ubm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDaGlsZCA9IGNoaWxkcmVuW2ldLm5vZGU7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY3VycmVudENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGZyYWdtZW50OiBmcmFnbWVudCwgc2VsZWN0b3JzOiB7fX07IC8vIG5vIHNlbGVjdG9yc1xuICAgIH0sXG5cbiAgICAvLyBMYWJlbCBtYXJrdXAgZnJhZ21lbnQgbWF5IGNvbWUgd3JhcHBlZCBpbiA8ZyBjbGFzcz1cImxhYmVsXCIgLz4sIG9yIG5vdC5cbiAgICAvLyBJZiBpdCBkb2Vzbid0LCBhZGQgdGhlIDxnIC8+IGNvbnRhaW5lciBoZXJlLlxuICAgIF9ub3JtYWxpemVMYWJlbE1hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgaWYgKCFtYXJrdXApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGZyYWdtZW50ID0gbWFya3VwLmZyYWdtZW50O1xuICAgICAgICBpZiAoIShtYXJrdXAuZnJhZ21lbnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB8fCAhbWFya3VwLmZyYWdtZW50Lmhhc0NoaWxkTm9kZXMoKSkgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IGludmFsaWQgbGFiZWwgbWFya3VwLicpO1xuXG4gICAgICAgIHZhciB2Tm9kZTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBmcmFnbWVudC5jaGlsZE5vZGVzO1xuXG4gICAgICAgIGlmICgoY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB8fCBjaGlsZE5vZGVzWzBdLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdHJykge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCBtYXJrdXAgZnJhZ21lbnQgaXMgbm90IHdyYXBwZWQgaW4gPGcgLz5cbiAgICAgICAgICAgIC8vIGFkZCBhIDxnIC8+IGNvbnRhaW5lclxuICAgICAgICAgICAgdk5vZGUgPSBWKCdnJykuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZOb2RlID0gVihjaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZOb2RlLmFkZENsYXNzKCdsYWJlbCcpO1xuXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHZOb2RlLm5vZGUsIHNlbGVjdG9yczogbWFya3VwLnNlbGVjdG9ycyB9O1xuICAgIH0sXG5cbiAgICByZW5kZXJMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMuX1Y7XG4gICAgICAgIHZhciB2TGFiZWxzID0gY2FjaGUubGFiZWxzO1xuICAgICAgICB2YXIgbGFiZWxDYWNoZSA9IHRoaXMuX2xhYmVsQ2FjaGUgPSB7fTtcbiAgICAgICAgdmFyIGxhYmVsU2VsZWN0b3JzID0gdGhpcy5fbGFiZWxTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGxhYmVscyA9IG1vZGVsLmF0dHJpYnV0ZXMubGFiZWxzIHx8IFtdO1xuICAgICAgICB2YXIgbGFiZWxzQ291bnQgPSBsYWJlbHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsYWJlbHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHZMYWJlbHMpIHZMYWJlbHMucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2TGFiZWxzKSB7XG4gICAgICAgICAgICB2TGFiZWxzLmVtcHR5KCk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gbGFiZWwgY29udGFpbmVyIGluIHRoZSBtYXJrdXAgYnV0IHNvbWUgbGFiZWxzIGFyZSBkZWZpbmVkXG4gICAgICAgICAgICAvLyBhZGQgYSA8ZyBjbGFzcz1cImxhYmVsc1wiIC8+IGNvbnRhaW5lclxuICAgICAgICAgICAgdkxhYmVscyA9IGNhY2hlLmxhYmVscyA9IFYoJ2cnKS5hZGRDbGFzcygnbGFiZWxzJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsc0xheWVyKSB7XG4gICAgICAgICAgICAgICAgdkxhYmVscy5hZGRDbGFzcyhhZGRDbGFzc05hbWVQcmVmaXgocmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKSkpO1xuICAgICAgICAgICAgICAgIHZMYWJlbHMuYXR0cignbW9kZWwtaWQnLCBtb2RlbC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsc0NvdW50OyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxhYmVsTWFya3VwID0gdGhpcy5fbm9ybWFsaXplTGFiZWxNYXJrdXAodGhpcy5fZ2V0TGFiZWxNYXJrdXAobGFiZWwubWFya3VwKSk7XG4gICAgICAgICAgICB2YXIgbGFiZWxOb2RlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdG9ycztcbiAgICAgICAgICAgIGlmIChsYWJlbE1hcmt1cCkge1xuXG4gICAgICAgICAgICAgICAgbGFiZWxOb2RlID0gbGFiZWxNYXJrdXAubm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBsYWJlbE1hcmt1cC5zZWxlY3RvcnM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYnVpbHRpbkRlZmF1bHRMYWJlbCA9ICBtb2RlbC5fYnVpbHRpbnMuZGVmYXVsdExhYmVsO1xuICAgICAgICAgICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsTWFya3VwID0gdGhpcy5fbm9ybWFsaXplTGFiZWxNYXJrdXAodGhpcy5fZ2V0TGFiZWxNYXJrdXAoYnVpbHRpbkRlZmF1bHRMYWJlbC5tYXJrdXApKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdExhYmVsID0gbW9kZWwuX2dldERlZmF1bHRMYWJlbCgpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0TGFiZWxNYXJrdXAgPSB0aGlzLl9ub3JtYWxpemVMYWJlbE1hcmt1cCh0aGlzLl9nZXRMYWJlbE1hcmt1cChkZWZhdWx0TGFiZWwubWFya3VwKSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRNYXJrdXAgPSBkZWZhdWx0TGFiZWxNYXJrdXAgfHwgYnVpbHRpbkRlZmF1bHRMYWJlbE1hcmt1cDtcblxuICAgICAgICAgICAgICAgIGxhYmVsTm9kZSA9IGRlZmF1bHRNYXJrdXAubm9kZTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBkZWZhdWx0TWFya3VwLnNlbGVjdG9ycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFiZWxOb2RlLnNldEF0dHJpYnV0ZSgnbGFiZWwtaWR4JywgaSk7IC8vIGFzc2lnbiBsYWJlbC1pZHhcbiAgICAgICAgICAgIHZMYWJlbHMuYXBwZW5kKGxhYmVsTm9kZSk7XG4gICAgICAgICAgICBsYWJlbENhY2hlW2ldID0gbGFiZWxOb2RlOyAvLyBjYWNoZSBub2RlIGZvciBgdXBkYXRlTGFiZWxzKClgIHNvIGl0IGNhbiBqdXN0IHVwZGF0ZSBsYWJlbCBub2RlIHBvc2l0aW9uc1xuXG4gICAgICAgICAgICB2YXIgcm9vdFNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RvcnNbcm9vdFNlbGVjdG9yXSkgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IGFtYmlndW91cyBsYWJlbCByb290IHNlbGVjdG9yLicpO1xuICAgICAgICAgICAgc2VsZWN0b3JzW3Jvb3RTZWxlY3Rvcl0gPSBsYWJlbE5vZGU7XG5cbiAgICAgICAgICAgIGxhYmVsU2VsZWN0b3JzW2ldID0gc2VsZWN0b3JzOyAvLyBjYWNoZSBsYWJlbCBzZWxlY3RvcnMgZm9yIGB1cGRhdGVMYWJlbHMoKWBcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZMYWJlbHMucGFyZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMubW91bnRMYWJlbHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG1vdW50TGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBlbCwgcGFwZXIsIG1vZGVsLCBfViwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYWJlbHM6IHZMYWJlbHMgfSA9IF9WO1xuICAgICAgICBpZiAoIXZMYWJlbHMgfHwgIW1vZGVsLmhhc0xhYmVscygpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbm9kZSB9ID0gdkxhYmVscztcbiAgICAgICAgaWYgKG9wdGlvbnMubGFiZWxzTGF5ZXIpIHtcbiAgICAgICAgICAgIHBhcGVyLmdldExheWVyVmlldyhvcHRpb25zLmxhYmVsc0xheWVyKS5pbnNlcnRTb3J0ZWROb2RlKG5vZGUsIG1vZGVsLmdldCgneicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5tb3VudExhYmVsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgX1YgfSA9IHRoaXM7XG4gICAgICAgIGlmICghX1YpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBsYWJlbHM6IHZMYWJlbHMgfSA9IF9WO1xuICAgICAgICBpZiAodkxhYmVscyAmJiBvcHRpb25zLmxhYmVsc0xheWVyKSB7XG4gICAgICAgICAgICB2TGFiZWxzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmRMYWJlbE5vZGVzOiBmdW5jdGlvbihsYWJlbEluZGV4LCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBsYWJlbFJvb3QgPSB0aGlzLl9sYWJlbENhY2hlW2xhYmVsSW5kZXhdO1xuICAgICAgICBpZiAoIWxhYmVsUm9vdCkgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBsYWJlbFNlbGVjdG9ycyA9IHRoaXMuX2xhYmVsU2VsZWN0b3JzW2xhYmVsSW5kZXhdO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlTZWxlY3RvcihzZWxlY3RvciwgbGFiZWxSb290LCBsYWJlbFNlbGVjdG9ycyk7XG4gICAgfSxcblxuICAgIGZpbmRMYWJlbE5vZGU6IGZ1bmN0aW9uKGxhYmVsSW5kZXgsIHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IFtub2RlID0gbnVsbF0gPSB0aGlzLmZpbmRMYWJlbE5vZGVzKGxhYmVsSW5kZXgsIHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIC8vIG1lcmdlIGRlZmF1bHQgbGFiZWwgYXR0cnMgaW50byBsYWJlbCBhdHRycyAob3IgdXNlIGJ1aWx0LWluIGRlZmF1bHQgbGFiZWwgYXR0cnMgaWYgbmVpdGhlciBpcyBwcm92aWRlZClcbiAgICAvLyBrZWVwIGB1bmRlZmluZWRgIG9yIGBudWxsYCBiZWNhdXNlIGB7fWAgbWVhbnMgc29tZXRoaW5nIGVsc2VcbiAgICBfbWVyZ2VMYWJlbEF0dHJzOiBmdW5jdGlvbihoYXNDdXN0b21NYXJrdXAsIGxhYmVsQXR0cnMsIGRlZmF1bHRMYWJlbEF0dHJzLCBidWlsdGluRGVmYXVsdExhYmVsQXR0cnMpIHtcblxuICAgICAgICBpZiAobGFiZWxBdHRycyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChsYWJlbEF0dHJzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbEF0dHJzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0TGFiZWxBdHRycyA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzQ3VzdG9tTWFya3VwKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsdGluRGVmYXVsdExhYmVsQXR0cnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNDdXN0b21NYXJrdXApIHJldHVybiBkZWZhdWx0TGFiZWxBdHRycztcbiAgICAgICAgICAgIHJldHVybiBtZXJnZSh7fSwgYnVpbHRpbkRlZmF1bHRMYWJlbEF0dHJzLCBkZWZhdWx0TGFiZWxBdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzQ3VzdG9tTWFya3VwKSByZXR1cm4gbWVyZ2Uoe30sIGRlZmF1bHRMYWJlbEF0dHJzLCBsYWJlbEF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBidWlsdGluRGVmYXVsdExhYmVsQXR0cnMsIGRlZmF1bHRMYWJlbEF0dHJzLCBsYWJlbEF0dHJzKTtcbiAgICB9LFxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBsYWJlbCBzaXplIGludG8gbGFiZWwgc2l6ZSAobm8gYnVpbHQtaW4gZGVmYXVsdClcbiAgICAvLyBrZWVwIGB1bmRlZmluZWRgIG9yIGBudWxsYCBiZWNhdXNlIGB7fWAgbWVhbnMgc29tZXRoaW5nIGVsc2VcbiAgICBfbWVyZ2VMYWJlbFNpemU6IGZ1bmN0aW9uKGxhYmVsU2l6ZSwgZGVmYXVsdExhYmVsU2l6ZSkge1xuXG4gICAgICAgIGlmIChsYWJlbFNpemUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobGFiZWxTaXplID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbFNpemUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbFNpemUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRMYWJlbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIGRlZmF1bHRMYWJlbFNpemUsIGxhYmVsU2l6ZSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUxhYmVsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9WLmxhYmVscykgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLnBhcGVyLm9wdGlvbnMubGFiZWxMYXllcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbGFiZWwgbGF5ZXIsIHRoZSBjYWNoZSBuZWVkcyB0byBiZSBjbGVhcmVkXG4gICAgICAgICAgICAvLyBvZiB0aGUgcm9vdCBub2RlIGJlY2F1c2UgdGhlIGxhYmVscyBhcmUgYXR0YWNoZWRcbiAgICAgICAgICAgIC8vIHRvIGl0IGFuZCBjb3VsZCBhZmZlY3QgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgIHRoaXMuY2xlYW5Ob2RlQ2FjaGUodGhpcy5lbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbGFiZWxzID0gbW9kZWwuZ2V0KCdsYWJlbHMnKSB8fCBbXTtcbiAgICAgICAgdmFyIGNhbkxhYmVsTW92ZSA9IHRoaXMuY2FuKCdsYWJlbE1vdmUnKTtcblxuICAgICAgICB2YXIgYnVpbHRpbkRlZmF1bHRMYWJlbCA9IG1vZGVsLl9idWlsdGlucy5kZWZhdWx0TGFiZWw7XG4gICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsQXR0cnMgPSBidWlsdGluRGVmYXVsdExhYmVsLmF0dHJzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSBtb2RlbC5fZ2V0RGVmYXVsdExhYmVsKCk7XG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxNYXJrdXAgPSBkZWZhdWx0TGFiZWwubWFya3VwO1xuICAgICAgICB2YXIgZGVmYXVsdExhYmVsQXR0cnMgPSBkZWZhdWx0TGFiZWwuYXR0cnM7XG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxTaXplID0gZGVmYXVsdExhYmVsLnNpemU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbE5vZGUgPSB0aGlzLl9sYWJlbENhY2hlW2ldO1xuICAgICAgICAgICAgbGFiZWxOb2RlLnNldEF0dHJpYnV0ZSgnY3Vyc29yJywgKGNhbkxhYmVsTW92ZSA/ICdtb3ZlJyA6ICdkZWZhdWx0JykpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzID0gdGhpcy5fbGFiZWxTZWxlY3RvcnNbaV07XG5cbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgIHZhciBsYWJlbE1hcmt1cCA9IGxhYmVsLm1hcmt1cDtcbiAgICAgICAgICAgIHZhciBsYWJlbEF0dHJzID0gbGFiZWwuYXR0cnM7XG4gICAgICAgICAgICB2YXIgbGFiZWxTaXplID0gbGFiZWwuc2l6ZTtcblxuICAgICAgICAgICAgdmFyIGF0dHJzID0gdGhpcy5fbWVyZ2VMYWJlbEF0dHJzKFxuICAgICAgICAgICAgICAgIChsYWJlbE1hcmt1cCB8fCBkZWZhdWx0TGFiZWxNYXJrdXApLFxuICAgICAgICAgICAgICAgIGxhYmVsQXR0cnMsXG4gICAgICAgICAgICAgICAgZGVmYXVsdExhYmVsQXR0cnMsXG4gICAgICAgICAgICAgICAgYnVpbHRpbkRlZmF1bHRMYWJlbEF0dHJzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX21lcmdlTGFiZWxTaXplKFxuICAgICAgICAgICAgICAgIGxhYmVsU2l6ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGFiZWxTaXplXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKGxhYmVsTm9kZSwgYXR0cnMsIHtcbiAgICAgICAgICAgICAgICByb290QkJveDogbmV3IFJlY3Qoc2l6ZSksXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSB2ZXJ0aWNlcyB0aGF0IGxpZSBvbiAob3IgbmVhcmx5IG9uKSBzdHJhaWdodCBsaW5lcyB3aXRoaW4gdGhlIGxpbmtcbiAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiByZW1vdmVkIHBvaW50c1xuICAgIHJlbW92ZVJlZHVuZGFudExpbmVhclZlcnRpY2VzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBjb25zdCBTSU1QTElGWV9USFJFU0hPTEQgPSAwLjAwMTtcblxuICAgICAgICBjb25zdCBsaW5rID0gdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBsaW5rLnZlcnRpY2VzKCk7XG4gICAgICAgIGNvbnN0IHJvdXRlUG9pbnRzID0gW3RoaXMuc291cmNlQW5jaG9yLCAuLi52ZXJ0aWNlcywgdGhpcy50YXJnZXRBbmNob3JdO1xuICAgICAgICBjb25zdCBudW1Sb3V0ZVBvaW50cyA9IHJvdXRlUG9pbnRzLmxlbmd0aDtcblxuICAgICAgICAvLyBwdXQgcm91dGVQb2ludHMgaW50byBhIHBvbHlsaW5lIGFuZCB0cnkgdG8gc2ltcGxpZnlcbiAgICAgICAgY29uc3QgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUocm91dGVQb2ludHMpO1xuICAgICAgICBwb2x5bGluZS5zaW1wbGlmeSh7IHRocmVzaG9sZDogU0lNUExJRllfVEhSRVNIT0xEIH0pO1xuICAgICAgICBjb25zdCBwb2x5bGluZVBvaW50cyA9IHBvbHlsaW5lLnBvaW50cy5tYXAoKHBvaW50KSA9PiAocG9pbnQudG9KU09OKCkpKTsgLy8gSlNPTiBvZiBwb2ludHMgYWZ0ZXIgc2ltcGxpZmljYXRpb25cbiAgICAgICAgY29uc3QgbnVtUG9seWxpbmVQb2ludHMgPSBwb2x5bGluZVBvaW50cy5sZW5ndGg7IC8vIG51bWJlciBvZiBwb2ludHMgYWZ0ZXIgc2ltcGxpZmljYXRpb25cblxuICAgICAgICAvLyBzaG9ydGN1dCBpZiBzaW1wbGlmaWNhdGlvbiBkaWQgbm90IHJlbW92ZSBhbnkgcmVkdW5kYW50IHZlcnRpY2VzOlxuICAgICAgICBpZiAobnVtUm91dGVQb2ludHMgPT09IG51bVBvbHlsaW5lUG9pbnRzKSByZXR1cm4gMDtcblxuICAgICAgICAvLyBlbHNlOiBzZXQgc2ltcGxpZmllZCBwb2x5bGluZSBwb2ludHMgYXMgbGluayB2ZXJ0aWNlc1xuICAgICAgICAvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgcG9seWxpbmUgcG9pbnRzIGFnYWluICg9IHNvdXJjZS90YXJnZXQgYW5jaG9ycylcbiAgICAgICAgbGluay52ZXJ0aWNlcyhwb2x5bGluZVBvaW50cy5zbGljZSgxLCBudW1Qb2x5bGluZVBvaW50cyAtIDEpLCBvcHQpO1xuICAgICAgICByZXR1cm4gKG51bVJvdXRlUG9pbnRzIC0gbnVtUG9seWxpbmVQb2ludHMpO1xuICAgIH0sXG5cbiAgICBnZXRFbmRWaWV3OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VWaWV3IHx8IG51bGw7XG4gICAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFZpZXcgfHwgbnVsbDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHR5cGUgcGFyYW1ldGVyIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEVuZEFuY2hvcjogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnNvdXJjZUFuY2hvcik7XG4gICAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdHlwZSBwYXJhbWV0ZXIgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RW5kQ29ubmVjdGlvblBvaW50OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuc291cmNlUG9pbnQpO1xuICAgICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMudGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdHlwZSBwYXJhbWV0ZXIgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RW5kTWFnbmV0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlVmlldyA9IHRoaXMuc291cmNlVmlldztcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZVZpZXcpIGJyZWFrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZU1hZ25ldCB8fCBzb3VyY2VWaWV3LmVsO1xuICAgICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VmlldyA9IHRoaXMudGFyZ2V0VmlldztcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFZpZXcpIGJyZWFrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldE1hZ25ldCB8fCB0YXJnZXRWaWV3LmVsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdHlwZSBwYXJhbWV0ZXIgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuXG4gICAgLy8gVXBkYXRpbmcuXG4gICAgLy8gLS0tLS0tLS0tXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJvdXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCA9IDAsIHR5ID0gMCkge1xuICAgICAgICBjb25zdCB7IHJvdXRlLCBwYXRoIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJvdXRlIHx8ICFwYXRoKSByZXR1cm47XG4gICAgICAgIC8vIHRyYW5zbGF0ZSB0aGUgcm91dGVcbiAgICAgICAgY29uc3QgcG9seWxpbmUgPSBuZXcgUG9seWxpbmUocm91dGUpO1xuICAgICAgICBwb2x5bGluZS50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHBvbHlsaW5lLnBvaW50cztcbiAgICAgICAgLy8gdHJhbnNsYXRlIHNvdXJjZSBhbmQgdGFyZ2V0IGNvbm5lY3Rpb24gYW5kIGFuY2hvciBwb2ludHMuXG4gICAgICAgIHRoaXMuc291cmNlUG9pbnQub2Zmc2V0KHR4LCB0eSk7XG4gICAgICAgIHRoaXMudGFyZ2V0UG9pbnQub2Zmc2V0KHR4LCB0eSk7XG4gICAgICAgIHRoaXMuc291cmNlQW5jaG9yLm9mZnNldCh0eCwgdHkpO1xuICAgICAgICB0aGlzLnRhcmdldEFuY2hvci5vZmZzZXQodHgsIHR5KTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSBnZW9tZXRyeSBwYXRoXG4gICAgICAgIHBhdGgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZURPTSgpIHtcbiAgICAgICAgY29uc3QgeyBlbCwgbW9kZWwsIHNlbGVjdG9ycyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhbk5vZGVzQ2FjaGUoKTtcbiAgICAgICAgLy8gdXBkYXRlIFNWRyBhdHRyaWJ1dGVzIGRlZmluZWQgYnkgJ2F0dHJzLycuXG4gICAgICAgIHRoaXMudXBkYXRlRE9NU3VidHJlZUF0dHJpYnV0ZXMoZWwsIG1vZGVsLmF0dHIoKSwgeyBzZWxlY3RvcnMgfSk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbGFiZWwgcG9zaXRpb24gZXRjLlxuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsUG9zaXRpb25zKCk7XG4gICAgICAgIC8vICpEZXByZWNhdGVkKlxuICAgICAgICAvLyBMb2NhbCBwZXJwZW5kaWN1bGFyIGZsYWcgKGFzIG9wcG9zZWQgdG8gb25lIGRlZmluZWQgb24gcGFwZXIpLlxuICAgICAgICAvLyBDb3VsZCBiZSBlbmFibGVkIGluc2lkZSBhIGNvbm5lY3Rvci9yb3V0ZXIuIEl0J3MgdmFsaWQgb25seVxuICAgICAgICAvLyBkdXJpbmcgdGhlIHVwZGF0ZSBleGVjdXRpb24uXG4gICAgICAgIHRoaXMub3B0aW9ucy5wZXJwZW5kaWN1bGFyID0gbnVsbDtcbiAgICB9LFxuXG4gICAgdXBkYXRlUm91dGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IG1vZGVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IG1vZGVsLnZlcnRpY2VzKCk7XG4gICAgICAgIC8vIDEuIEZpbmQgQW5jaG9yc1xuICAgICAgICBjb25zdCBhbmNob3JzID0gdGhpcy5maW5kQW5jaG9ycyh2ZXJ0aWNlcyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUFuY2hvciA9IHRoaXMuc291cmNlQW5jaG9yID0gYW5jaG9ycy5zb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IHRoaXMudGFyZ2V0QW5jaG9yID0gYW5jaG9ycy50YXJnZXQ7XG4gICAgICAgIC8vIDIuIEZpbmQgUm91dGVcbiAgICAgICAgY29uc3Qgcm91dGUgPSB0aGlzLmZpbmRSb3V0ZSh2ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgLy8gMy4gRmluZCBDb25uZWN0aW9uIFBvaW50c1xuICAgICAgICB2YXIgY29ubmVjdGlvblBvaW50cyA9IHRoaXMuZmluZENvbm5lY3Rpb25Qb2ludHMocm91dGUsIHNvdXJjZUFuY2hvciwgdGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgdGhpcy5zb3VyY2VQb2ludCA9IGNvbm5lY3Rpb25Qb2ludHMuc291cmNlO1xuICAgICAgICB0aGlzLnRhcmdldFBvaW50ID0gY29ubmVjdGlvblBvaW50cy50YXJnZXQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHJvdXRlLCBzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQgfSA9IHRoaXM7XG4gICAgICAgIC8vIDQuIEZpbmQgQ29ubmVjdGlvblxuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5maW5kUGF0aChyb3V0ZSwgc291cmNlUG9pbnQuY2xvbmUoKSwgdGFyZ2V0UG9pbnQuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgfSxcblxuICAgIGZpbmRBbmNob3JzT3JkZXJlZDogZnVuY3Rpb24oZmlyc3RFbmRUeXBlLCBmaXJzdFJlZiwgc2Vjb25kRW5kVHlwZSwgc2Vjb25kUmVmKSB7XG5cbiAgICAgICAgdmFyIGZpcnN0QW5jaG9yLCBzZWNvbmRBbmNob3I7XG4gICAgICAgIHZhciBmaXJzdEFuY2hvclJlZiwgc2Vjb25kQW5jaG9yUmVmO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgZmlyc3REZWYgPSBtb2RlbC5nZXQoZmlyc3RFbmRUeXBlKTtcbiAgICAgICAgdmFyIHNlY29uZERlZiA9IG1vZGVsLmdldChzZWNvbmRFbmRUeXBlKTtcbiAgICAgICAgdmFyIGZpcnN0VmlldyA9IHRoaXMuZ2V0RW5kVmlldyhmaXJzdEVuZFR5cGUpO1xuICAgICAgICB2YXIgc2Vjb25kVmlldyA9IHRoaXMuZ2V0RW5kVmlldyhzZWNvbmRFbmRUeXBlKTtcbiAgICAgICAgdmFyIGZpcnN0TWFnbmV0ID0gdGhpcy5nZXRFbmRNYWduZXQoZmlyc3RFbmRUeXBlKTtcbiAgICAgICAgdmFyIHNlY29uZE1hZ25ldCA9IHRoaXMuZ2V0RW5kTWFnbmV0KHNlY29uZEVuZFR5cGUpO1xuXG4gICAgICAgIC8vIEFuY2hvciBmaXJzdFxuICAgICAgICBpZiAoZmlyc3RWaWV3KSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RSZWYpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEFuY2hvclJlZiA9IG5ldyBQb2ludChmaXJzdFJlZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlY29uZFZpZXcpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEFuY2hvclJlZiA9IHNlY29uZE1hZ25ldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RBbmNob3JSZWYgPSBuZXcgUG9pbnQoc2Vjb25kRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0QW5jaG9yID0gdGhpcy5nZXRBbmNob3IoZmlyc3REZWYuYW5jaG9yLCBmaXJzdFZpZXcsIGZpcnN0TWFnbmV0LCBmaXJzdEFuY2hvclJlZiwgZmlyc3RFbmRUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0QW5jaG9yID0gbmV3IFBvaW50KGZpcnN0RGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuY2hvciBzZWNvbmRcbiAgICAgICAgaWYgKHNlY29uZFZpZXcpIHtcbiAgICAgICAgICAgIHNlY29uZEFuY2hvclJlZiA9IG5ldyBQb2ludChzZWNvbmRSZWYgfHwgZmlyc3RBbmNob3IpO1xuICAgICAgICAgICAgc2Vjb25kQW5jaG9yID0gdGhpcy5nZXRBbmNob3Ioc2Vjb25kRGVmLmFuY2hvciwgc2Vjb25kVmlldywgc2Vjb25kTWFnbmV0LCBzZWNvbmRBbmNob3JSZWYsIHNlY29uZEVuZFR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Vjb25kQW5jaG9yID0gbmV3IFBvaW50KHNlY29uZERlZik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzID0ge307XG4gICAgICAgIHJlc1tmaXJzdEVuZFR5cGVdID0gZmlyc3RBbmNob3I7XG4gICAgICAgIHJlc1tzZWNvbmRFbmRUeXBlXSA9IHNlY29uZEFuY2hvcjtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgZmluZEFuY2hvcnM6IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIGZpcnN0VmVydGV4ID0gdmVydGljZXNbMF07XG4gICAgICAgIHZhciBsYXN0VmVydGV4ID0gdmVydGljZXNbdmVydGljZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKG1vZGVsLnRhcmdldCgpLnByaW9yaXR5ICYmICFtb2RlbC5zb3VyY2UoKS5wcmlvcml0eSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJzZWQgb3JkZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRBbmNob3JzT3JkZXJlZCgndGFyZ2V0JywgbGFzdFZlcnRleCwgJ3NvdXJjZScsIGZpcnN0VmVydGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzdWFsIG9yZGVyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRBbmNob3JzT3JkZXJlZCgnc291cmNlJywgZmlyc3RWZXJ0ZXgsICd0YXJnZXQnLCBsYXN0VmVydGV4KTtcbiAgICB9LFxuXG4gICAgZmluZENvbm5lY3Rpb25Qb2ludHM6IGZ1bmN0aW9uKHJvdXRlLCBzb3VyY2VBbmNob3IsIHRhcmdldEFuY2hvcikge1xuXG4gICAgICAgIHZhciBmaXJzdFdheXBvaW50ID0gcm91dGVbMF07XG4gICAgICAgIHZhciBsYXN0V2F5cG9pbnQgPSByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIHNvdXJjZURlZiA9IG1vZGVsLmdldCgnc291cmNlJyk7XG4gICAgICAgIHZhciB0YXJnZXREZWYgPSBtb2RlbC5nZXQoJ3RhcmdldCcpO1xuICAgICAgICB2YXIgc291cmNlVmlldyA9IHRoaXMuc291cmNlVmlldztcbiAgICAgICAgdmFyIHRhcmdldFZpZXcgPSB0aGlzLnRhcmdldFZpZXc7XG4gICAgICAgIHZhciBwYXBlck9wdGlvbnMgPSB0aGlzLnBhcGVyLm9wdGlvbnM7XG4gICAgICAgIHZhciBzb3VyY2VNYWduZXQsIHRhcmdldE1hZ25ldDtcblxuICAgICAgICAvLyBDb25uZWN0aW9uIFBvaW50IFNvdXJjZVxuICAgICAgICB2YXIgc291cmNlUG9pbnQ7XG4gICAgICAgIGlmIChzb3VyY2VWaWV3ICYmICFzb3VyY2VWaWV3LmlzTm9kZUNvbm5lY3Rpb24odGhpcy5zb3VyY2VNYWduZXQpKSB7XG4gICAgICAgICAgICBzb3VyY2VNYWduZXQgPSAodGhpcy5zb3VyY2VNYWduZXQgfHwgc291cmNlVmlldy5lbCk7XG4gICAgICAgICAgICB2YXIgc291cmNlQ29ubmVjdGlvblBvaW50RGVmID0gc291cmNlRGVmLmNvbm5lY3Rpb25Qb2ludCB8fCBwYXBlck9wdGlvbnMuZGVmYXVsdENvbm5lY3Rpb25Qb2ludDtcbiAgICAgICAgICAgIHZhciBzb3VyY2VQb2ludFJlZiA9IGZpcnN0V2F5cG9pbnQgfHwgdGFyZ2V0QW5jaG9yO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUxpbmUgPSBuZXcgTGluZShzb3VyY2VQb2ludFJlZiwgc291cmNlQW5jaG9yKTtcbiAgICAgICAgICAgIHNvdXJjZVBvaW50ID0gdGhpcy5nZXRDb25uZWN0aW9uUG9pbnQoXG4gICAgICAgICAgICAgICAgc291cmNlQ29ubmVjdGlvblBvaW50RGVmLFxuICAgICAgICAgICAgICAgIHNvdXJjZVZpZXcsXG4gICAgICAgICAgICAgICAgc291cmNlTWFnbmV0LFxuICAgICAgICAgICAgICAgIHNvdXJjZUxpbmUsXG4gICAgICAgICAgICAgICAgJ3NvdXJjZSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VQb2ludCA9IHNvdXJjZUFuY2hvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25uZWN0aW9uIFBvaW50IFRhcmdldFxuICAgICAgICB2YXIgdGFyZ2V0UG9pbnQ7XG4gICAgICAgIGlmICh0YXJnZXRWaWV3ICYmICF0YXJnZXRWaWV3LmlzTm9kZUNvbm5lY3Rpb24odGhpcy50YXJnZXRNYWduZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXRNYWduZXQgPSAodGhpcy50YXJnZXRNYWduZXQgfHwgdGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Q29ubmVjdGlvblBvaW50RGVmID0gdGFyZ2V0RGVmLmNvbm5lY3Rpb25Qb2ludCB8fCBwYXBlck9wdGlvbnMuZGVmYXVsdENvbm5lY3Rpb25Qb2ludDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRQb2ludFJlZiA9IGxhc3RXYXlwb2ludCB8fCBzb3VyY2VBbmNob3I7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0TGluZSA9IG5ldyBMaW5lKHRhcmdldFBvaW50UmVmLCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0aGlzLmdldENvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICB0YXJnZXRDb25uZWN0aW9uUG9pbnREZWYsXG4gICAgICAgICAgICAgICAgdGFyZ2V0VmlldyxcbiAgICAgICAgICAgICAgICB0YXJnZXRNYWduZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGluZSxcbiAgICAgICAgICAgICAgICAndGFyZ2V0J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFBvaW50ID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlUG9pbnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFBvaW50XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEFuY2hvcjogZnVuY3Rpb24oYW5jaG9yRGVmLCBjZWxsVmlldywgbWFnbmV0LCByZWYsIGVuZFR5cGUpIHtcblxuICAgICAgICB2YXIgaXNDb25uZWN0aW9uID0gY2VsbFZpZXcuaXNOb2RlQ29ubmVjdGlvbihtYWduZXQpO1xuICAgICAgICB2YXIgcGFwZXJPcHRpb25zID0gdGhpcy5wYXBlci5vcHRpb25zO1xuICAgICAgICBpZiAoIWFuY2hvckRlZikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGFuY2hvckRlZiA9IHBhcGVyT3B0aW9ucy5kZWZhdWx0TGlua0FuY2hvcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZXJwZW5kaWN1bGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBgbWFuaGF0dGFuYCByb3V0ZXIgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAgICAgICAgICAgICAgICBhbmNob3JEZWYgPSB7IG5hbWU6ICdwZXJwZW5kaWN1bGFyJyB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckRlZiA9IHBhcGVyT3B0aW9ucy5kZWZhdWx0QW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYW5jaG9yRGVmKSB0aHJvdyBuZXcgRXJyb3IoJ0FuY2hvciByZXF1aXJlZC4nKTtcbiAgICAgICAgdmFyIGFuY2hvckZuO1xuICAgICAgICBpZiAodHlwZW9mIGFuY2hvckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYW5jaG9yRm4gPSBhbmNob3JEZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yTmFtZSA9IGFuY2hvckRlZi5uYW1lO1xuICAgICAgICAgICAgdmFyIGFuY2hvck5hbWVzcGFjZSA9IGlzQ29ubmVjdGlvbiA/ICdsaW5rQW5jaG9yTmFtZXNwYWNlJyA6ICdhbmNob3JOYW1lc3BhY2UnO1xuICAgICAgICAgICAgYW5jaG9yRm4gPSBwYXBlck9wdGlvbnNbYW5jaG9yTmFtZXNwYWNlXVthbmNob3JOYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYW5jaG9yRm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhbmNob3I6ICcgKyBhbmNob3JOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5jaG9yID0gYW5jaG9yRm4uY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBjZWxsVmlldyxcbiAgICAgICAgICAgIG1hZ25ldCxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgICAgIGFuY2hvckRlZi5hcmdzIHx8IHt9LFxuICAgICAgICAgICAgZW5kVHlwZSxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFhbmNob3IpIHJldHVybiBuZXcgUG9pbnQoKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvci5yb3VuZCh0aGlzLmRlY2ltYWxzUm91bmRpbmcpO1xuICAgIH0sXG5cblxuICAgIGdldENvbm5lY3Rpb25Qb2ludDogZnVuY3Rpb24oY29ubmVjdGlvblBvaW50RGVmLCB2aWV3LCBtYWduZXQsIGxpbmUsIGVuZFR5cGUpIHtcblxuICAgICAgICB2YXIgY29ubmVjdGlvblBvaW50O1xuICAgICAgICB2YXIgYW5jaG9yID0gbGluZS5lbmQ7XG4gICAgICAgIHZhciBwYXBlck9wdGlvbnMgPSB0aGlzLnBhcGVyLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKCFjb25uZWN0aW9uUG9pbnREZWYpIHJldHVybiBhbmNob3I7XG4gICAgICAgIHZhciBjb25uZWN0aW9uUG9pbnRGbjtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uUG9pbnREZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludEZuID0gY29ubmVjdGlvblBvaW50RGVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25Qb2ludE5hbWUgPSBjb25uZWN0aW9uUG9pbnREZWYubmFtZTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb2ludEZuID0gcGFwZXJPcHRpb25zLmNvbm5lY3Rpb25Qb2ludE5hbWVzcGFjZVtjb25uZWN0aW9uUG9pbnROYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvblBvaW50Rm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25uZWN0aW9uIHBvaW50OiAnICsgY29ubmVjdGlvblBvaW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvblBvaW50ID0gY29ubmVjdGlvblBvaW50Rm4uY2FsbCh0aGlzLCBsaW5lLCB2aWV3LCBtYWduZXQsIGNvbm5lY3Rpb25Qb2ludERlZi5hcmdzIHx8IHt9LCBlbmRUeXBlLCB0aGlzKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uUG9pbnQpIHJldHVybiBhbmNob3I7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uUG9pbnQucm91bmQodGhpcy5kZWNpbWFsc1JvdW5kaW5nKTtcbiAgICB9LFxuXG4gICAgaXNJbnRlcnNlY3Rpbmc6IGZ1bmN0aW9uKGdlb21ldHJ5U2hhcGUsIGdlb21ldHJ5RGF0YSkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIGlmICghY29ubmVjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uLmV4aXN0cyhcbiAgICAgICAgICAgIGdlb21ldHJ5U2hhcGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICAgICAgZ2VvbWV0cnlEYXRhLFxuICAgICAgICAgICAgeyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9LFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBpc0VuY2xvc2VkSW46IGZ1bmN0aW9uKGdlb21ldHJ5UmVjdCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgIGlmICghY29ubmVjdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBiYm94ID0gY29ubmVjdGlvbi5iYm94KCk7XG4gICAgICAgIGlmICghYmJveCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnlSZWN0LmNvbnRhaW5zUmVjdChiYm94KTtcbiAgICB9LFxuXG4gICAgaXNBdFBvaW50OiBmdW5jdGlvbihwb2ludCAvKiwgb3B0aW9ucyAqLykge1xuICAgICAgICAvLyBOb3RlOiBgc3RyaWN0YCBvcHRpb24gaXMgbm90IGFwcGxpY2FibGUgZm9yIGxpbmtzLlxuICAgICAgICAvLyBUaGVyZSBpcyBjdXJyZW50bHkgbm8gbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIHBhdGggY29udGFpbnMgYSBwb2ludC5cbiAgICAgICAgY29uc3QgYXJlYSA9IG5ldyBSZWN0KHBvaW50KTtcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggYSB6ZXJvLXNpemUgYXJlYSBpcyBub3QgcG9zc2libGUuXG4gICAgICAgIGFyZWEuaW5mbGF0ZSh0aGlzLkVQU0lMT04pO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ludGVyc2VjdGluZyhhcmVhKTtcbiAgICB9LFxuXG4gICAgLy8gY29tYmluZSBkZWZhdWx0IGxhYmVsIHBvc2l0aW9uIHdpdGggYnVpbHQtaW4gZGVmYXVsdCBsYWJlbCBwb3NpdGlvblxuICAgIF9nZXREZWZhdWx0TGFiZWxQb3NpdGlvblByb3BlcnR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuXG4gICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsID0gbW9kZWwuX2J1aWx0aW5zLmRlZmF1bHRMYWJlbDtcbiAgICAgICAgdmFyIGJ1aWx0aW5EZWZhdWx0TGFiZWxQb3NpdGlvbiA9IGJ1aWx0aW5EZWZhdWx0TGFiZWwucG9zaXRpb247XG5cbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbCA9IG1vZGVsLl9nZXREZWZhdWx0TGFiZWwoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uID0gdGhpcy5fbm9ybWFsaXplTGFiZWxQb3NpdGlvbihkZWZhdWx0TGFiZWwucG9zaXRpb24pO1xuXG4gICAgICAgIHJldHVybiBtZXJnZSh7fSwgYnVpbHRpbkRlZmF1bHRMYWJlbFBvc2l0aW9uLCBkZWZhdWx0TGFiZWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8vIGlmIGxhYmVsIHBvc2l0aW9uIGlzIGEgbnVtYmVyLCBub3JtYWxpemUgaXQgdG8gYSBwb3NpdGlvbiBvYmplY3RcbiAgICAvLyB0aGlzIG1ha2VzIHN1cmUgdGhhdCBsYWJlbCBwb3NpdGlvbnMgY2FuIGJlIG1lcmdlZCBwcm9wZXJseVxuICAgIF9ub3JtYWxpemVMYWJlbFBvc2l0aW9uOiBmdW5jdGlvbihsYWJlbFBvc2l0aW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbFBvc2l0aW9uID09PSAnbnVtYmVyJykgcmV0dXJuIHsgZGlzdGFuY2U6IGxhYmVsUG9zaXRpb24sIG9mZnNldDogbnVsbCwgYW5nbGU6IDAsIGFyZ3M6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIGxhYmVsUG9zaXRpb247XG4gICAgfSxcblxuICAgIC8vIGV4cGVjdHMgbm9ybWFsaXplZCBwb3NpdGlvbiBwcm9wZXJ0aWVzXG4gICAgLy8gZS5nLiBgdGhpcy5fbm9ybWFsaXplTGFiZWxQb3NpdGlvbihsYWJlbFBvc2l0aW9uKWAgYW5kIGB0aGlzLl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvblByb3BlcnR5KClgXG4gICAgX21lcmdlTGFiZWxQb3NpdGlvblByb3BlcnR5OiBmdW5jdGlvbihub3JtYWxpemVkTGFiZWxQb3NpdGlvbiwgbm9ybWFsaXplZERlZmF1bHRMYWJlbFBvc2l0aW9uKSB7XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMYWJlbFBvc2l0aW9uID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMYWJlbFBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWREZWZhdWx0TGFiZWxQb3NpdGlvbiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZERlZmF1bHRMYWJlbFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBub3JtYWxpemVkRGVmYXVsdExhYmVsUG9zaXRpb24sIG5vcm1hbGl6ZWRMYWJlbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlTGFiZWxQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fVi5sYWJlbHMpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGFzc3VtZXMgYWxsIHRoZSBsYWJlbCBub2RlcyBhcmUgc3RvcmVkIGluIHRoZSBgdGhpcy5fbGFiZWxDYWNoZWAgaGFzaCB0YWJsZVxuICAgICAgICAvLyBieSB0aGVpciBpbmRpY2VzIGluIHRoZSBgdGhpcy5nZXQoJ2xhYmVscycpYCBhcnJheS4gVGhpcyBpcyBkb25lIGluIHRoZSBgcmVuZGVyTGFiZWxzKClgIG1ldGhvZC5cblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbGFiZWxzID0gbW9kZWwuZ2V0KCdsYWJlbHMnKSB8fCBbXTtcbiAgICAgICAgaWYgKCFsYWJlbHMubGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgZGVmYXVsdExhYmVsUG9zaXRpb24gPSB0aGlzLl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvblByb3BlcnR5KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbiA9IGxhYmVscy5sZW5ndGg7IGlkeCA8IG47IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxOb2RlID0gdGhpcy5fbGFiZWxDYWNoZVtpZHhdO1xuICAgICAgICAgICAgaWYgKCFsYWJlbE5vZGUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2lkeF07XG4gICAgICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IHRoaXMuX25vcm1hbGl6ZUxhYmVsUG9zaXRpb24obGFiZWwucG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fbWVyZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHkobGFiZWxQb3NpdGlvbiwgZGVmYXVsdExhYmVsUG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdGhpcy5fZ2V0TGFiZWxUcmFuc2Zvcm1hdGlvbk1hdHJpeChwb3NpdGlvbik7XG4gICAgICAgICAgICBsYWJlbE5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybWF0aW9uTWF0cml4KSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbkxhYmVsTWF0cmljZXMoaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfY2xlYW5MYWJlbE1hdHJpY2VzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAvLyBDbGVhbiBtYWduZXRNYXRyaXggZm9yIGFsbCBub2RlcyBvZiB0aGUgbGFiZWwuXG4gICAgICAgIC8vIENhY2hlZCBCb3VuZGluZ1JlY3QgZG9lcyBub3QgbmVlZCB0byB1cGRhdGVkIHdoZW4gdGhlIHBvc2l0aW9uIGNoYW5nZXNcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkb2Vzbid0IHdvcmsgZm9yIGxhYmVscyB3aXRoIFhNTCBTdHJpbmcgbWFya3Vwcy5cbiAgICAgICAgY29uc3QgeyBtZXRyaWNzLCBfbGFiZWxTZWxlY3RvcnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IF9sYWJlbFNlbGVjdG9yc1tpbmRleF07XG4gICAgICAgIGlmICghc2VsZWN0b3JzKSByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHNlbGVjdG9yIGluIHNlbGVjdG9ycykge1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gc2VsZWN0b3JzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgIGlmIChpZCAmJiAoaWQgaW4gbWV0cmljcykpIGRlbGV0ZSBtZXRyaWNzW2lkXS5tYWduZXRNYXRyaXg7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlRW5kUHJvcGVydGllczogZnVuY3Rpb24oZW5kVHlwZSkge1xuXG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBlbmRWaWV3UHJvcGVydHkgPSBgJHtlbmRUeXBlfVZpZXdgO1xuICAgICAgICBjb25zdCBlbmREZWYgPSBtb2RlbC5nZXQoZW5kVHlwZSk7XG4gICAgICAgIGNvbnN0IGVuZElkID0gZW5kRGVmICYmIGVuZERlZi5pZDtcblxuICAgICAgICBpZiAoIWVuZElkKSB7XG4gICAgICAgICAgICAvLyB0aGUgbGluayBlbmQgaXMgYSBwb2ludCB+IHJlY3QgMHgwXG4gICAgICAgICAgICB0aGlzW2VuZFZpZXdQcm9wZXJ0eV0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNYWduZXQoZW5kVHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVuZE1vZGVsID0gcGFwZXIuZ2V0TW9kZWxCeUlkKGVuZElkKTtcbiAgICAgICAgaWYgKCFlbmRNb2RlbCkgdGhyb3cgbmV3IEVycm9yKCdMaW5rVmlldzogaW52YWxpZCAnICsgZW5kVHlwZSArICcgY2VsbC4nKTtcblxuICAgICAgICBjb25zdCBlbmRWaWV3ID0gZW5kTW9kZWwuZmluZFZpZXcocGFwZXIpO1xuICAgICAgICBpZiAoIWVuZFZpZXcpIHtcbiAgICAgICAgICAgIC8vIEEgdmlldyBmb3IgYSBtb2RlbCBzaG91bGQgYWx3YXlzIGV4aXN0XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW2VuZFZpZXdQcm9wZXJ0eV0gPSBlbmRWaWV3O1xuICAgICAgICB0aGlzLnVwZGF0ZUVuZE1hZ25ldChlbmRUeXBlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHVwZGF0ZUVuZE1hZ25ldDogZnVuY3Rpb24oZW5kVHlwZSkge1xuXG4gICAgICAgIGNvbnN0IGVuZE1hZ25ldFByb3BlcnR5ID0gYCR7ZW5kVHlwZX1NYWduZXRgO1xuICAgICAgICBjb25zdCBlbmRWaWV3ID0gdGhpcy5nZXRFbmRWaWV3KGVuZFR5cGUpO1xuICAgICAgICBpZiAoZW5kVmlldykge1xuICAgICAgICAgICAgbGV0IGNvbm5lY3RlZE1hZ25ldCA9IGVuZFZpZXcuZ2V0TWFnbmV0RnJvbUxpbmtFbmQodGhpcy5tb2RlbC5nZXQoZW5kVHlwZSkpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3RlZE1hZ25ldCA9PT0gZW5kVmlldy5lbCkgY29ubmVjdGVkTWFnbmV0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXNbZW5kTWFnbmV0UHJvcGVydHldID0gY29ubmVjdGVkTWFnbmV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tlbmRNYWduZXRQcm9wZXJ0eV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9nZXRMYWJlbFBvc2l0aW9uUHJvcGVydHk6IGZ1bmN0aW9uKGlkeCkge1xuXG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlbC5sYWJlbChpZHgpLnBvc2l0aW9uIHx8IHt9KTtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsUG9zaXRpb25BbmdsZTogZnVuY3Rpb24oaWR4KSB7XG5cbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uUHJvcGVydHkoaWR4KTtcbiAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uLmFuZ2xlIHx8IDApO1xuICAgIH0sXG5cbiAgICBfZ2V0TGFiZWxQb3NpdGlvbkFyZ3M6IGZ1bmN0aW9uKGlkeCkge1xuXG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gdGhpcy5fZ2V0TGFiZWxQb3NpdGlvblByb3BlcnR5KGlkeCk7XG4gICAgICAgIHJldHVybiBsYWJlbFBvc2l0aW9uLmFyZ3M7XG4gICAgfSxcblxuICAgIF9nZXREZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSB0aGlzLm1vZGVsLl9nZXREZWZhdWx0TGFiZWwoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uID0gZGVmYXVsdExhYmVsLnBvc2l0aW9uIHx8IHt9O1xuICAgICAgICByZXR1cm4gZGVmYXVsdExhYmVsUG9zaXRpb24uYXJncztcbiAgICB9LFxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBsYWJlbCBwb3NpdGlvbiBhcmdzIGludG8gbGFiZWwgcG9zaXRpb24gYXJnc1xuICAgIC8vIGtlZXAgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY2F1c2UgYHt9YCBtZWFucyBzb21ldGhpbmcgZWxzZVxuICAgIF9tZXJnZUxhYmVsUG9zaXRpb25BcmdzOiBmdW5jdGlvbihsYWJlbFBvc2l0aW9uQXJncywgZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzKSB7XG5cbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb25BcmdzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb25BcmdzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MsIGxhYmVsUG9zaXRpb25BcmdzKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGRlZmF1bHQgbGFiZWwgYXQgZ2l2ZW4gcG9zaXRpb24gYXQgZW5kIG9mIGBsYWJlbHNgIGFycmF5LlxuICAgIC8vIEZvdXIgc2lnbmF0dXJlczpcbiAgICAvLyAtIG9iaiwgb2JqID0gcG9pbnQsIG9wdFxuICAgIC8vIC0gb2JqLCBudW0sIG9iaiA9IHBvaW50LCBhbmdsZSwgb3B0XG4gICAgLy8gLSBudW0sIG51bSwgb2JqID0geCwgeSwgb3B0XG4gICAgLy8gLSBudW0sIG51bSwgbnVtLCBvYmogPSB4LCB5LCBhbmdsZSwgb3B0XG4gICAgLy8gQXNzaWducyByZWxhdGl2ZSBjb29yZGluYXRlcyBieSBkZWZhdWx0OlxuICAgIC8vIGBvcHQuYWJzb2x1dGVEaXN0YW5jZWAgZm9yY2VzIGFic29sdXRlIGNvb3JkaW5hdGVzLlxuICAgIC8vIGBvcHQucmV2ZXJzZURpc3RhbmNlYCBmb3JjZXMgcmV2ZXJzZSBhYnNvbHV0ZSBjb29yZGluYXRlcyAoaWYgYWJzb2x1dGVEaXN0YW5jZSA9IHRydWUpLlxuICAgIC8vIGBvcHQuYWJzb2x1dGVPZmZzZXRgIGZvcmNlcyBhYnNvbHV0ZSBjb29yZGluYXRlcyBmb3Igb2Zmc2V0LlxuICAgIC8vIEFkZGl0aW9uYWwgYXJnczpcbiAgICAvLyBgb3B0LmtlZXBHcmFkaWVudGAgYXV0by1hZGp1c3RzIHRoZSBhbmdsZSBvZiB0aGUgbGFiZWwgdG8gbWF0Y2ggcGF0aCBncmFkaWVudCBhdCBwb3NpdGlvbi5cbiAgICAvLyBgb3B0LmVuc3VyZUxlZ2liaWxpdHlgIHJvdGF0ZXMgbGFiZWxzIHNvIHRoZXkgYXJlIG5ldmVyIHVwc2lkZS1kb3duLlxuICAgIGFkZExhYmVsOiBmdW5jdGlvbihwMSwgcDIsIHAzLCBwNCkge1xuXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBkYXRhIGZyb20gdGhlIGZvdXIgcG9zc2libGUgc2lnbmF0dXJlc1xuICAgICAgICB2YXIgbG9jYWxYO1xuICAgICAgICB2YXIgbG9jYWxZO1xuICAgICAgICB2YXIgbG9jYWxBbmdsZSA9IDA7XG4gICAgICAgIHZhciBsb2NhbE9wdDtcbiAgICAgICAgaWYgKHR5cGVvZiBwMSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIHt4LCB5fSBvYmplY3QgcHJvdmlkZWQgYXMgZmlyc3QgcGFyYW1ldGVyXG4gICAgICAgICAgICBsb2NhbFggPSBwMS54O1xuICAgICAgICAgICAgbG9jYWxZID0gcDEueTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcDIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgYW5kIG9wdCBwcm92aWRlZCBhcyBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBsb2NhbEFuZ2xlID0gcDI7XG4gICAgICAgICAgICAgICAgbG9jYWxPcHQgPSBwMztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0IHByb3ZpZGVkIGFzIHNlY29uZCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICBsb2NhbE9wdCA9IHAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8geCBhbmQgeSBwcm92aWRlZCBhcyBmaXJzdCBhbmQgc2Vjb25kIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGxvY2FsWCA9IHAxO1xuICAgICAgICAgICAgbG9jYWxZID0gcDI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHAzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIGFuZ2xlIGFuZCBvcHQgcHJvdmlkZWQgYXMgdGhpcmQgYW5kIGZvdXJ0aCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgbG9jYWxBbmdsZSA9IHAzO1xuICAgICAgICAgICAgICAgIGxvY2FsT3B0ID0gcDQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG9wdCBwcm92aWRlZCBhcyB0aGlyZCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICBsb2NhbE9wdCA9IHAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWVyZ2UgbGFiZWwgcG9zaXRpb24gYXJndW1lbnRzXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MgPSB0aGlzLl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MoKTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb25BcmdzID0gbG9jYWxPcHQ7XG4gICAgICAgIHZhciBwb3NpdGlvbkFyZ3MgPSB0aGlzLl9tZXJnZUxhYmVsUG9zaXRpb25BcmdzKGxhYmVsUG9zaXRpb25BcmdzLCBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MpO1xuXG4gICAgICAgIC8vIGFwcGVuZCBsYWJlbCB0byBsYWJlbHMgYXJyYXlcbiAgICAgICAgdmFyIGxhYmVsID0geyBwb3NpdGlvbjogdGhpcy5nZXRMYWJlbFBvc2l0aW9uKGxvY2FsWCwgbG9jYWxZLCBsb2NhbEFuZ2xlLCBwb3NpdGlvbkFyZ3MpIH07XG4gICAgICAgIHZhciBpZHggPSAtMTtcbiAgICAgICAgdGhpcy5tb2RlbC5pbnNlcnRMYWJlbChpZHgsIGxhYmVsLCBsb2NhbE9wdCk7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG5ldyB2ZXJ0ZXggYXQgY2FsY3VsYXRlZCBpbmRleCB0byB0aGUgYHZlcnRpY2VzYCBhcnJheS5cbiAgICBhZGRWZXJ0ZXg6IGZ1bmN0aW9uKHgsIHksIG9wdCkge1xuXG4gICAgICAgIC8vIGFjY2VwdCBpbnB1dCBpbiBmb3JtIGB7IHgsIHkgfSwgb3B0YCBvciBgeCwgeSwgb3B0YFxuICAgICAgICB2YXIgaXNQb2ludFByb3ZpZGVkID0gKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyk7XG4gICAgICAgIHZhciBsb2NhbFggPSBpc1BvaW50UHJvdmlkZWQgPyB4LnggOiB4O1xuICAgICAgICB2YXIgbG9jYWxZID0gaXNQb2ludFByb3ZpZGVkID8geC55IDogeTtcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0gaXNQb2ludFByb3ZpZGVkID8geSA6IG9wdDtcblxuICAgICAgICB2YXIgdmVydGV4ID0geyB4OiBsb2NhbFgsIHk6IGxvY2FsWSB9O1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRWZXJ0ZXhJbmRleChsb2NhbFgsIGxvY2FsWSk7XG4gICAgICAgIHRoaXMubW9kZWwuaW5zZXJ0VmVydGV4KGlkeCwgdmVydGV4LCBsb2NhbE9wdCk7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSxcblxuICAgIC8vIFNlbmQgYSB0b2tlbiAoYW4gU1ZHIGVsZW1lbnQsIHVzdWFsbHkgYSBjaXJjbGUpIGFsb25nIHRoZSBjb25uZWN0aW9uIHBhdGguXG4gICAgLy8gRXhhbXBsZTogYGxpbmsuZmluZFZpZXcocGFwZXIpLnNlbmRUb2tlbihWKCdjaXJjbGUnLCB7IHI6IDcsIGZpbGw6ICdncmVlbicgfSkubm9kZSlgXG4gICAgLy8gYG9wdC5kdXJhdGlvbmAgaXMgb3B0aW9uYWwgYW5kIGlzIGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgdG9rZW4gdHJhdmVscyBmcm9tIHRoZSBzb3VyY2UgdG8gdGhlIHRhcmdldCBvZiB0aGUgbGluay4gRGVmYXVsdCBpcyBgMTAwMGAuXG4gICAgLy8gYG9wdC5kaXJlY3Rpb25gIGlzIG9wdGlvbmFsIGFuZCBpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRva2VuIGdvZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IG9yIG90aGVyIHdheSByb3VuZCAoYHJldmVyc2VgKVxuICAgIC8vIGBvcHQuY29ubmVjdGlvbmAgaXMgYW4gb3B0aW9uYWwgc2VsZWN0b3IgdG8gdGhlIGNvbm5lY3Rpb24gcGF0aC5cbiAgICAvLyBgY2FsbGJhY2tgIGlzIG9wdGlvbmFsIGFuZCBpcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIHRoZSB0b2tlbiByZWFjaGVzIHRoZSB0YXJnZXQuXG4gICAgc2VuZFRva2VuOiBmdW5jdGlvbih0b2tlbiwgb3B0LCBjYWxsYmFjaykge1xuXG4gICAgICAgIGZ1bmN0aW9uIG9uQW5pbWF0aW9uRW5kKHZUb2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2VG9rZW4ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24sIGlzUmV2ZXJzZWQsIHNlbGVjdG9yO1xuICAgICAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHQuZHVyYXRpb247XG4gICAgICAgICAgICBpc1JldmVyc2VkID0gKG9wdC5kaXJlY3Rpb24gPT09ICdyZXZlcnNlJyk7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG9wdC5jb25uZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGR1cmF0aW9uID0gb3B0O1xuICAgICAgICAgICAgaXNSZXZlcnNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCAxMDAwO1xuXG4gICAgICAgIHZhciBhbmltYXRpb25BdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgZHVyOiBkdXJhdGlvbiArICdtcycsXG4gICAgICAgICAgICByZXBlYXRDb3VudDogMSxcbiAgICAgICAgICAgIGNhbGNNb2RlOiAnbGluZWFyJyxcbiAgICAgICAgICAgIGZpbGw6ICdmcmVlemUnXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzUmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbkF0dHJpYnV0ZXMua2V5UG9pbnRzID0gJzE7MCc7XG4gICAgICAgICAgICBhbmltYXRpb25BdHRyaWJ1dGVzLmtleVRpbWVzID0gJzA7MSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdlRva2VuID0gVih0b2tlbik7XG4gICAgICAgIHZhciBjb25uZWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSBjb25uZWN0aW9uIHBhdGguXG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5maW5kTm9kZShzZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgY29ubmVjdGlvbiBwYXRoIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9WO1xuICAgICAgICAgICAgY29ubmVjdGlvbiA9IChjYWNoZS5jb25uZWN0aW9uKSA/IGNhY2hlLmNvbm5lY3Rpb24ubm9kZSA6IHRoaXMuZWwucXVlcnlTZWxlY3RvcigncGF0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoY29ubmVjdGlvbiBpbnN0YW5jZW9mIFNWR1BhdGhFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHRva2VuIGFuaW1hdGlvbiByZXF1aXJlcyBhIHZhbGlkIGNvbm5lY3Rpb24gcGF0aC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZUb2tlblxuICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMucGFwZXIuY2VsbHMpXG4gICAgICAgICAgICAuYW5pbWF0ZUFsb25nUGF0aChhbmltYXRpb25BdHRyaWJ1dGVzLCBjb25uZWN0aW9uKTtcblxuICAgICAgICBzZXRUaW1lb3V0KG9uQW5pbWF0aW9uRW5kKHZUb2tlbiwgY2FsbGJhY2spLCBkdXJhdGlvbik7XG4gICAgfSxcblxuICAgIGZpbmRSb3V0ZTogZnVuY3Rpb24odmVydGljZXMpIHtcblxuICAgICAgICB2ZXJ0aWNlcyB8fCAodmVydGljZXMgPSBbXSk7XG5cbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMucGFwZXIub3B0aW9ucy5yb3V0ZXJOYW1lc3BhY2UgfHwgcm91dGVycztcbiAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMubW9kZWwucm91dGVyKCk7XG4gICAgICAgIHZhciBkZWZhdWx0Um91dGVyID0gdGhpcy5wYXBlci5vcHRpb25zLmRlZmF1bHRSb3V0ZXI7XG5cbiAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0Um91dGVyKSByb3V0ZXIgPSBkZWZhdWx0Um91dGVyO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gdmVydGljZXMubWFwKFBvaW50KTsgLy8gbm8gcm91dGVyIHNwZWNpZmllZFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdXRlckZuID0gaXNGdW5jdGlvbihyb3V0ZXIpID8gcm91dGVyIDogbmFtZXNwYWNlW3JvdXRlci5uYW1lXTtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJvdXRlckZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHVua25vd24gcm91dGVyOiBcIicgKyByb3V0ZXIubmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLmFyZ3MgfHwge307XG5cbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVyRm4uY2FsbChcbiAgICAgICAgICAgIHRoaXMsIC8vIGNvbnRleHRcbiAgICAgICAgICAgIHZlcnRpY2VzLCAvLyB2ZXJ0aWNlc1xuICAgICAgICAgICAgYXJncywgLy8gb3B0aW9uc1xuICAgICAgICAgICAgdGhpcyAvLyBsaW5rVmlld1xuICAgICAgICApO1xuXG4gICAgICAgIGlmICghcm91dGUpIHJldHVybiB2ZXJ0aWNlcy5tYXAoUG9pbnQpO1xuICAgICAgICByZXR1cm4gcm91dGU7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgYGRgIGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgYDxwYXRoPmAgZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGxpbmtcbiAgICAvLyBiZXR3ZWVuIGBzb3VyY2VgIGFuZCBgdGFyZ2V0YC5cbiAgICBmaW5kUGF0aDogZnVuY3Rpb24ocm91dGUsIHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCkge1xuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLnBhcGVyLm9wdGlvbnMuY29ubmVjdG9yTmFtZXNwYWNlIHx8IGNvbm5lY3RvcnM7XG4gICAgICAgIHZhciBjb25uZWN0b3IgPSB0aGlzLm1vZGVsLmNvbm5lY3RvcigpO1xuICAgICAgICB2YXIgZGVmYXVsdENvbm5lY3RvciA9IHRoaXMucGFwZXIub3B0aW9ucy5kZWZhdWx0Q29ubmVjdG9yO1xuXG4gICAgICAgIGlmICghY29ubmVjdG9yKSB7XG4gICAgICAgICAgICBjb25uZWN0b3IgPSBkZWZhdWx0Q29ubmVjdG9yIHx8IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbm5lY3RvckZuID0gaXNGdW5jdGlvbihjb25uZWN0b3IpID8gY29ubmVjdG9yIDogbmFtZXNwYWNlW2Nvbm5lY3Rvci5uYW1lXTtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbm5lY3RvckZuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IHVua25vd24gY29ubmVjdG9yOiBcIicgKyBjb25uZWN0b3IubmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gY2xvbmUoY29ubmVjdG9yLmFyZ3MgfHwge30pO1xuICAgICAgICBhcmdzLnJhdyA9IHRydWU7IC8vIFJlcXVlc3QgcmF3IGcuUGF0aCBhcyB0aGUgcmVzdWx0LlxuXG4gICAgICAgIHZhciBwYXRoID0gY29ubmVjdG9yRm4uY2FsbChcbiAgICAgICAgICAgIHRoaXMsIC8vIGNvbnRleHRcbiAgICAgICAgICAgIHNvdXJjZVBvaW50LCAvLyBzdGFydCBwb2ludFxuICAgICAgICAgICAgdGFyZ2V0UG9pbnQsIC8vIGVuZCBwb2ludFxuICAgICAgICAgICAgcm91dGUsIC8vIHZlcnRpY2VzXG4gICAgICAgICAgICBhcmdzLCAvLyBvcHRpb25zXG4gICAgICAgICAgICB0aGlzIC8vIGxpbmtWaWV3XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGNvbm5lY3RvcnMgbm90IHN1cHBvcnRpbmcgYHJhd2Agb3B0aW9uLlxuICAgICAgICAgICAgcGF0aCA9IG5ldyBQYXRoKFYubm9ybWFsaXplUGF0aERhdGEocGF0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8vIFB1YmxpYyBBUEkuXG4gICAgLy8gLS0tLS0tLS0tLS1cblxuICAgIGdldENvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBwYXRoLmNsb25lKCk7XG4gICAgfSxcblxuICAgIGdldFNlcmlhbGl6ZWRDb25uZWN0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgaWYgKG1ldHJpY3MuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSkgcmV0dXJuIG1ldHJpY3MuZGF0YTtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXRoLnNlcmlhbGl6ZSgpO1xuICAgICAgICBtZXRyaWNzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLm1ldHJpY3M7XG4gICAgICAgIGlmIChtZXRyaWNzLmhhc093blByb3BlcnR5KCdzZWdtZW50U3ViZGl2aXNpb25zJykpIHJldHVybiBtZXRyaWNzLnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBwYXRoLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoKTtcbiAgICAgICAgbWV0cmljcy5zZWdtZW50U3ViZGl2aXNpb25zID0gc3ViZGl2aXNpb25zO1xuICAgICAgICByZXR1cm4gc3ViZGl2aXNpb25zO1xuICAgIH0sXG5cbiAgICBnZXRDb25uZWN0aW9uTGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gMDtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgaWYgKG1ldHJpY3MuaGFzT3duUHJvcGVydHkoJ2xlbmd0aCcpKSByZXR1cm4gbWV0cmljcy5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aCh7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgICAgICBtZXRyaWNzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucG9pbnRBdExlbmd0aChsZW5ndGgsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldFBvaW50QXRSYXRpbzogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGlzUGVyY2VudGFnZShyYXRpbykpIHJhdGlvID0gcGFyc2VGbG9hdChyYXRpbykgLyAxMDA7XG4gICAgICAgIHJldHVybiBwYXRoLnBvaW50QXQocmF0aW8sIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldFRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGgudGFuZ2VudEF0TGVuZ3RoKGxlbmd0aCwgeyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VGFuZ2VudEF0UmF0aW86IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGgudGFuZ2VudEF0KHJhdGlvLCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGguY2xvc2VzdFBvaW50KHBvaW50LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGguY2xvc2VzdFBvaW50TGVuZ3RoKHBvaW50LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRDbG9zZXN0UG9pbnRSYXRpbzogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKHBvaW50LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgbGFiZWwgcG9zaXRpb24gb2JqZWN0IGJhc2VkIG9uIHR3byBwcm92aWRlZCBjb29yZGluYXRlcywgeCBhbmQgeS5cbiAgICAvLyAoVXNlZCBiZWhpbmQgdGhlIHNjZW5lcyB3aGVuIHVzZXIgbW92ZXMgbGFiZWxzIGFyb3VuZC4pXG4gICAgLy8gVHdvIHNpZ25hdHVyZXM6XG4gICAgLy8gLSBudW0sIG51bSwgb2JqID0geCwgeSwgb3B0aW9uc1xuICAgIC8vIC0gbnVtLCBudW0sIG51bSwgb2JqID0geCwgeSwgYW5nbGUsIG9wdGlvbnNcbiAgICAvLyBBY2NlcHRzIGRpc3RhbmNlL29mZnNldCBvcHRpb25zID0gYGFic29sdXRlRGlzdGFuY2U6IGJvb2xlYW5gLCBgcmV2ZXJzZURpc3RhbmNlOiBib29sZWFuYCwgYGFic29sdXRlT2Zmc2V0OiBib29sZWFuYFxuICAgIC8vIC0gYGFic29sdXRlT2Zmc2V0YCBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gbW92ZSBiZXlvbmQgY29ubmVjdGlvbiBlbmRwb2ludHNcbiAgICAvLyBBZGRpdGlvbmFsIG9wdGlvbnMgPSBga2VlcEdyYWRpZW50OiBib29sZWFuYCwgYGVuc3VyZUxlZ2liaWxpdHk6IGJvb2xlYW5gXG4gICAgZ2V0TGFiZWxQb3NpdGlvbjogZnVuY3Rpb24oeCwgeSwgcDMsIHA0KSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0ge307XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGRhdGEgZnJvbSB0aGUgdHdvIHBvc3NpYmxlIHNpZ25hdHVyZXNcbiAgICAgICAgdmFyIGxvY2FsQW5nbGUgPSAwO1xuICAgICAgICB2YXIgbG9jYWxPcHQ7XG4gICAgICAgIGlmICh0eXBlb2YgcDMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvLyBhbmdsZSBhbmQgb3B0IHByb3ZpZGVkIGFzIHRoaXJkIGFuZCBmb3VydGggYXJndW1lbnRcbiAgICAgICAgICAgIGxvY2FsQW5nbGUgPSBwMztcbiAgICAgICAgICAgIGxvY2FsT3B0ID0gcDQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvcHQgcHJvdmlkZWQgYXMgdGhpcmQgYXJndW1lbnRcbiAgICAgICAgICAgIGxvY2FsT3B0ID0gcDM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIGxvY2FsT3B0IGFzIGBhcmdzYCBvZiB0aGUgcG9zaXRpb24gb2JqZWN0IHRoYXQgaXMgcGFzc2VkIGFsb25nXG4gICAgICAgIGlmIChsb2NhbE9wdCkgcG9zaXRpb24uYXJncyA9IGxvY2FsT3B0O1xuXG4gICAgICAgIC8vIGlkZW50aWZ5IGRpc3RhbmNlL29mZnNldCBzZXR0aW5nc1xuICAgICAgICB2YXIgaXNEaXN0YW5jZVJlbGF0aXZlID0gIShsb2NhbE9wdCAmJiBsb2NhbE9wdC5hYnNvbHV0ZURpc3RhbmNlKTsgLy8gcmVsYXRpdmUgYnkgZGVmYXVsdFxuICAgICAgICB2YXIgaXNEaXN0YW5jZUFic29sdXRlUmV2ZXJzZSA9IChsb2NhbE9wdCAmJiBsb2NhbE9wdC5hYnNvbHV0ZURpc3RhbmNlICYmIGxvY2FsT3B0LnJldmVyc2VEaXN0YW5jZSk7IC8vIG5vbi1yZXZlcnNlIGJ5IGRlZmF1bHRcbiAgICAgICAgdmFyIGlzT2Zmc2V0QWJzb2x1dGUgPSBsb2NhbE9wdCAmJiBsb2NhbE9wdC5hYnNvbHV0ZU9mZnNldDsgLy8gb2Zmc2V0IGlzIG5vbi1hYnNvbHV0ZSBieSBkZWZhdWx0XG5cbiAgICAgICAgLy8gZmluZCBjbG9zZXN0IHBvaW50IHRcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIHZhciBwYXRoT3B0ID0geyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9O1xuICAgICAgICB2YXIgbGFiZWxQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIHQgPSBwYXRoLmNsb3Nlc3RQb2ludFQobGFiZWxQb2ludCwgcGF0aE9wdCk7XG5cbiAgICAgICAgLy8gRElTVEFOQ0U6XG4gICAgICAgIHZhciBsYWJlbERpc3RhbmNlID0gcGF0aC5sZW5ndGhBdFQodCwgcGF0aE9wdCk7XG4gICAgICAgIGlmIChpc0Rpc3RhbmNlUmVsYXRpdmUpIGxhYmVsRGlzdGFuY2UgPSAobGFiZWxEaXN0YW5jZSAvIHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpKSB8fCAwOyAvLyBmaXggdG8gcHJldmVudCBOYU4gZm9yIDAgbGVuZ3RoXG4gICAgICAgIGlmIChpc0Rpc3RhbmNlQWJzb2x1dGVSZXZlcnNlKSBsYWJlbERpc3RhbmNlID0gKC0xICogKHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpIC0gbGFiZWxEaXN0YW5jZSkpIHx8IDE7IC8vIGZpeCBmb3IgZW5kIHBvaW50ICgtMCA9PiAxKVxuICAgICAgICBwb3NpdGlvbi5kaXN0YW5jZSA9IGxhYmVsRGlzdGFuY2U7XG5cbiAgICAgICAgLy8gT0ZGU0VUOlxuICAgICAgICAvLyB1c2UgYWJzb2x1dGUgb2Zmc2V0IGlmOlxuICAgICAgICAvLyAtIG9wdC5hYnNvbHV0ZU9mZnNldCBpcyB0cnVlLFxuICAgICAgICAvLyAtIG9wdC5hYnNvbHV0ZU9mZnNldCBpcyBub3QgdHJ1ZSBidXQgdGhlcmUgaXMgbm8gdGFuZ2VudFxuICAgICAgICB2YXIgdGFuZ2VudDtcbiAgICAgICAgaWYgKCFpc09mZnNldEFic29sdXRlKSB0YW5nZW50ID0gcGF0aC50YW5nZW50QXRUKHQpO1xuICAgICAgICB2YXIgbGFiZWxPZmZzZXQ7XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBsYWJlbE9mZnNldCA9IHRhbmdlbnQucG9pbnRPZmZzZXQobGFiZWxQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFBvaW50ID0gcGF0aC5wb2ludEF0VCh0KTtcbiAgICAgICAgICAgIHZhciBsYWJlbE9mZnNldERpZmYgPSBsYWJlbFBvaW50LmRpZmZlcmVuY2UoY2xvc2VzdFBvaW50KTtcbiAgICAgICAgICAgIGxhYmVsT2Zmc2V0ID0geyB4OiBsYWJlbE9mZnNldERpZmYueCwgeTogbGFiZWxPZmZzZXREaWZmLnkgfTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbi5vZmZzZXQgPSBsYWJlbE9mZnNldDtcblxuICAgICAgICAvLyBBTkdMRTpcbiAgICAgICAgcG9zaXRpb24uYW5nbGUgPSBsb2NhbEFuZ2xlO1xuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsVHJhbnNmb3JtYXRpb25NYXRyaXg6IGZ1bmN0aW9uKGxhYmVsUG9zaXRpb24pIHtcblxuICAgICAgICB2YXIgbGFiZWxEaXN0YW5jZTtcbiAgICAgICAgdmFyIGxhYmVsQW5nbGUgPSAwO1xuICAgICAgICB2YXIgYXJncyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGxhYmVsUG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBsYWJlbERpc3RhbmNlID0gbGFiZWxQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGFiZWxQb3NpdGlvbi5kaXN0YW5jZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBsYWJlbFBvc2l0aW9uLmFyZ3MgfHwge307XG4gICAgICAgICAgICBsYWJlbERpc3RhbmNlID0gbGFiZWxQb3NpdGlvbi5kaXN0YW5jZTtcbiAgICAgICAgICAgIGxhYmVsQW5nbGUgPSBsYWJlbFBvc2l0aW9uLmFuZ2xlIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogaW52YWxpZCBsYWJlbCBwb3NpdGlvbiBkaXN0YW5jZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc0Rpc3RhbmNlUmVsYXRpdmUgPSAoKGxhYmVsRGlzdGFuY2UgPiAwKSAmJiAobGFiZWxEaXN0YW5jZSA8PSAxKSk7XG5cbiAgICAgICAgdmFyIGxhYmVsT2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24ub2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25PZmZzZXQgPSBsYWJlbFBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb25PZmZzZXQgPT09ICdudW1iZXInKSBsYWJlbE9mZnNldCA9IHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uT2Zmc2V0LngpIGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMueCA9IHBvc2l0aW9uT2Zmc2V0Lng7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25PZmZzZXQueSkgbGFiZWxPZmZzZXRDb29yZGluYXRlcy55ID0gcG9zaXRpb25PZmZzZXQueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc09mZnNldEFic29sdXRlID0gKChsYWJlbE9mZnNldENvb3JkaW5hdGVzLnggIT09IDApIHx8IChsYWJlbE9mZnNldENvb3JkaW5hdGVzLnkgIT09IDApIHx8IGxhYmVsT2Zmc2V0ID09PSAwKTtcblxuICAgICAgICB2YXIgaXNLZWVwR3JhZGllbnQgPSBhcmdzLmtlZXBHcmFkaWVudDtcbiAgICAgICAgdmFyIGlzRW5zdXJlTGVnaWJpbGl0eSA9IGFyZ3MuZW5zdXJlTGVnaWJpbGl0eTtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgdmFyIHBhdGhPcHQgPSB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH07XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gaXNEaXN0YW5jZVJlbGF0aXZlID8gKGxhYmVsRGlzdGFuY2UgKiB0aGlzLmdldENvbm5lY3Rpb25MZW5ndGgoKSkgOiBsYWJlbERpc3RhbmNlO1xuICAgICAgICB2YXIgdGFuZ2VudCA9IHBhdGgudGFuZ2VudEF0TGVuZ3RoKGRpc3RhbmNlLCBwYXRoT3B0KTtcblxuICAgICAgICB2YXIgdHJhbnNsYXRpb247XG4gICAgICAgIHZhciBhbmdsZSA9IGxhYmVsQW5nbGU7XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNPZmZzZXRBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gdGFuZ2VudC5zdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uLm9mZnNldChsYWJlbE9mZnNldENvb3JkaW5hdGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHRhbmdlbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub3JtYWwucm90YXRlKHRhbmdlbnQuc3RhcnQsIC05MCk7XG4gICAgICAgICAgICAgICAgbm9ybWFsLnNldExlbmd0aChsYWJlbE9mZnNldCk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBub3JtYWwuZW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNLZWVwR3JhZGllbnQpIHtcbiAgICAgICAgICAgICAgICBhbmdsZSA9ICh0YW5nZW50LmFuZ2xlKCkgKyBsYWJlbEFuZ2xlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbnN1cmVMZWdpYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gbm9ybWFsaXplQW5nbGUoKChhbmdsZSArIDkwKSAlIDE4MCkgLSA5MCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayAtIHRoZSBjb25uZWN0aW9uIGhhcyB6ZXJvIGxlbmd0aFxuICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBwYXRoLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICBpZiAoaXNPZmZzZXRBYnNvbHV0ZSkgdHJhbnNsYXRpb24ub2Zmc2V0KGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFYuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgICAgIC50cmFuc2xhdGUodHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSlcbiAgICAgICAgICAgIC5yb3RhdGUoYW5nbGUpO1xuICAgIH0sXG5cbiAgICBnZXRMYWJlbENvb3JkaW5hdGVzOiBmdW5jdGlvbihsYWJlbFBvc2l0aW9uKSB7XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gdGhpcy5fZ2V0TGFiZWxUcmFuc2Zvcm1hdGlvbk1hdHJpeChsYWJlbFBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0cmFuc2Zvcm1hdGlvbk1hdHJpeC5lLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeC5mKTtcbiAgICB9LFxuXG4gICAgZ2V0VmVydGV4SW5kZXg6IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBtb2RlbC52ZXJ0aWNlcygpO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhMZW5ndGggPSB0aGlzLmdldENsb3Nlc3RQb2ludExlbmd0aChuZXcgUG9pbnQoeCwgeSkpO1xuXG4gICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICBmb3IgKHZhciBuID0gdmVydGljZXMubGVuZ3RoOyBpZHggPCBuOyBpZHgrKykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWZXJ0ZXggPSB2ZXJ0aWNlc1tpZHhdO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRWZXJ0ZXhMZW5ndGggPSB0aGlzLmdldENsb3Nlc3RQb2ludExlbmd0aChjdXJyZW50VmVydGV4KTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhMZW5ndGggPCBjdXJyZW50VmVydGV4TGVuZ3RoKSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfSxcblxuICAgIC8vIEludGVyYWN0aW9uLiBUaGUgY29udHJvbGxlciBwYXJ0LlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgbm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVyZG93bi5jYWxsKHRoaXMsIGV2dCwgeCwgeSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJkb3duJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbm90aWZ5UG9pbnRlcm1vdmUoZXZ0LCB4LCB5KSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVybW92ZS5jYWxsKHRoaXMsIGV2dCwgeCwgeSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJtb3ZlJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbm90aWZ5UG9pbnRlcnVwKGV2dCwgeCwgeSkge1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpwb2ludGVydXAnLCBldnQsIHgsIHkpO1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcnVwLmNhbGwodGhpcywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmRibGNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcmRibGNsaWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJkYmxjbGljaycsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJjbGljazogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJjbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpwb2ludGVyY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLmNvbnRleHRtZW51LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOmNvbnRleHRtZW51JywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQoZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHZhciBkcmFnRGF0YSA9IHRoaXMuX2RyYWdEYXRhO1xuICAgICAgICBpZiAoZHJhZ0RhdGEpIHRoaXMuZXZlbnREYXRhKGV2dCwgZHJhZ0RhdGEpO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgc3dpdGNoIChkYXRhLmFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdsYWJlbC1tb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdMYWJlbChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdhcnJvd2hlYWQtbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQXJyb3doZWFkKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZyhldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgaWYgKGRyYWdEYXRhKSBhc3NpZ24oZHJhZ0RhdGEsIHRoaXMuZXZlbnREYXRhKGV2dCkpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcm1vdmUoZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcnVwOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICB2YXIgZHJhZ0RhdGEgPSB0aGlzLl9kcmFnRGF0YTtcbiAgICAgICAgaWYgKGRyYWdEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIGRyYWdEYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgc3dpdGNoIChkYXRhLmFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdsYWJlbC1tb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdMYWJlbEVuZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdhcnJvd2hlYWQtbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnQXJyb3doZWFkRW5kKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VuZChldnQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVydXAoZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5jaGVja01vdXNlbGVhdmUoZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VvdmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOm1vdXNlb3ZlcicsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6bW91c2VvdXQnLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWVudGVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazptb3VzZWVudGVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VsZWF2ZTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm1vdXNlbGVhdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6bW91c2VsZWF2ZScsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNld2hlZWw6IGZ1bmN0aW9uKGV2dCwgeCwgeSwgZGVsdGEpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2V3aGVlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazptb3VzZXdoZWVsJywgZXZ0LCB4LCB5LCBkZWx0YSk7XG4gICAgfSxcblxuICAgIG9ubGFiZWw6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcblxuICAgICAgICB0aGlzLmRyYWdMYWJlbFN0YXJ0KGV2dCwgeCwgeSk7XG5cbiAgICAgICAgdmFyIHN0b3BQcm9wYWdhdGlvbiA9IHRoaXMuZXZlbnREYXRhKGV2dCkuc3RvcFByb3BhZ2F0aW9uO1xuICAgICAgICBpZiAoc3RvcFByb3BhZ2F0aW9uKSBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgU3RhcnQgSGFuZGxlcnNcblxuICAgIGRyYWdMYWJlbFN0YXJ0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBpZiAodGhpcy5jYW4oJ2xhYmVsTW92ZScpKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkKGV2dCkpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTm9kZSA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgdmFyIGxhYmVsSWR4ID0gcGFyc2VJbnQobGFiZWxOb2RlLmdldEF0dHJpYnV0ZSgnbGFiZWwtaWR4JyksIDEwKTtcblxuICAgICAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uID0gdGhpcy5fZ2V0RGVmYXVsdExhYmVsUG9zaXRpb25Qcm9wZXJ0eSgpO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxMYWJlbFBvc2l0aW9uID0gdGhpcy5fbm9ybWFsaXplTGFiZWxQb3NpdGlvbih0aGlzLl9nZXRMYWJlbFBvc2l0aW9uUHJvcGVydHkobGFiZWxJZHgpKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX21lcmdlTGFiZWxQb3NpdGlvblByb3BlcnR5KGluaXRpYWxMYWJlbFBvc2l0aW9uLCBkZWZhdWx0TGFiZWxQb3NpdGlvbik7XG5cbiAgICAgICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmdldExhYmVsQ29vcmRpbmF0ZXMocG9zaXRpb24pO1xuICAgICAgICAgICAgdmFyIGR4ID0gY29vcmRzLnggLSB4OyAvLyBob3cgbXVjaCBuZWVkcyB0byBiZSBhZGRlZCB0byBjdXJzb3IgeCB0byBnZXQgdG8gbGFiZWwgeFxuICAgICAgICAgICAgdmFyIGR5ID0gY29vcmRzLnkgLSB5OyAvLyBob3cgbXVjaCBuZWVkcyB0byBiZSBhZGRlZCB0byBjdXJzb3IgeSB0byBnZXQgdG8gbGFiZWwgeVxuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbmdsZSA9IHRoaXMuX2dldExhYmVsUG9zaXRpb25BbmdsZShsYWJlbElkeCk7XG4gICAgICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbkFyZ3MgPSB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uQXJncyhsYWJlbElkeCk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzID0gdGhpcy5fZ2V0RGVmYXVsdExhYmVsUG9zaXRpb25BcmdzKCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BcmdzID0gdGhpcy5fbWVyZ2VMYWJlbFBvc2l0aW9uQXJncyhsYWJlbFBvc2l0aW9uQXJncywgZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbGFiZWwtbW92ZScsXG4gICAgICAgICAgICAgICAgbGFiZWxJZHg6IGxhYmVsSWR4LFxuICAgICAgICAgICAgICAgIGR4OiBkeCxcbiAgICAgICAgICAgICAgICBkeTogZHksXG4gICAgICAgICAgICAgICAgcG9zaXRpb25BbmdsZTogcG9zaXRpb25BbmdsZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFyZ3M6IHBvc2l0aW9uQXJncyxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246IHRydWVcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuICAgICAgICAgICAgLy8gSWYgbGFiZWxzIGNhbid0IGJlIGRyYWdnZWQgbm8gZGVmYXVsdCBhY3Rpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IHN0b3BQcm9wYWdhdGlvbjogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFwZXIuZGVsZWdhdGVEcmFnRXZlbnRzKHRoaXMsIGV2dC5kYXRhKTtcbiAgICB9LFxuXG4gICAgZHJhZ0Fycm93aGVhZFN0YXJ0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBpZiAoIXRoaXMuY2FuKCdhcnJvd2hlYWRNb3ZlJykpIHJldHVybjtcblxuICAgICAgICB2YXIgYXJyb3doZWFkTm9kZSA9IGV2dC50YXJnZXQ7XG4gICAgICAgIHZhciBhcnJvd2hlYWRUeXBlID0gYXJyb3doZWFkTm9kZS5nZXRBdHRyaWJ1dGUoJ2VuZCcpO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc3RhcnRBcnJvd2hlYWRNb3ZlKGFycm93aGVhZFR5cGUsIHsgaWdub3JlQmFja3dhcmRzQ29tcGF0aWJpbGl0eTogdHJ1ZSB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkKGV2dCkpIHJldHVybjtcblxuICAgICAgICBpZiAoIXRoaXMuY2FuKCdsaW5rTW92ZScpKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBhY3Rpb246ICdtb3ZlJyxcbiAgICAgICAgICAgIGR4OiB4LFxuICAgICAgICAgICAgZHk6IHlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgSGFuZGxlcnNcbiAgICBkcmFnTGFiZWw6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdmFyIGxhYmVsID0geyBwb3NpdGlvbjogdGhpcy5nZXRMYWJlbFBvc2l0aW9uKCh4ICsgZGF0YS5keCksICh5ICsgZGF0YS5keSksIGRhdGEucG9zaXRpb25BbmdsZSwgZGF0YS5wb3NpdGlvbkFyZ3MpIH07XG4gICAgICAgIGlmICh0aGlzLnBhcGVyLm9wdGlvbnMuc25hcExhYmVscykgZGVsZXRlIGxhYmVsLnBvc2l0aW9uLm9mZnNldDtcbiAgICAgICAgLy8gVGhlIGB0b3VjaG1vdmUnIGV2ZW50cyBhcmUgbm90IGZpcmVkXG4gICAgICAgIC8vIHdoZW4gdGhlIG9yaWdpbmFsIGV2ZW50IHRhcmdldCBpcyByZW1vdmVkIGZyb20gdGhlIERPTS5cbiAgICAgICAgLy8gVGhlIGxhYmVscyBhcmUgY3VycmVudGx5IHJlLXJlbmRlcmVkIGNvbXBsZXRlbHkgd2hlbiBvbmx5XG4gICAgICAgIC8vIHRoZSBwb3NpdGlvbiBjaGFuZ2VzLiBUaGlzIGlzIHdoeSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAgIC8vIHRoZSBsYWJlbCBpcyB1cGRhdGVkIHN5bmNocm9ub3VzbHkuXG4gICAgICAgIC8vIFRPRE86IHJlcGxhY2UgYHRvdWNobW92ZWAgd2l0aCBgcG9pbnRlcm1vdmVgIChicmVha2luZyBjaGFuZ2UpLlxuICAgICAgICBjb25zdCBzZXRPcHRpb25zID0geyB1aTogdHJ1ZSB9O1xuICAgICAgICBpZiAodGhpcy5wYXBlci5pc0FzeW5jKCkgJiYgZXZ0LnR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgICBzZXRPcHRpb25zLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5sYWJlbChkYXRhLmxhYmVsSWR4LCBsYWJlbCwgc2V0T3B0aW9ucyk7XG4gICAgfSxcblxuICAgIGRyYWdBcnJvd2hlYWQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5wYXBlci5vcHRpb25zLnNuYXBMaW5rcykge1xuICAgICAgICAgICAgY29uc3QgaXNTbmFwcGVkID0gdGhpcy5fc25hcEFycm93aGVhZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFpc1NuYXBwZWQgJiYgdGhpcy5wYXBlci5vcHRpb25zLnNuYXBMaW5rc1NlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zbmFwQXJyb3doZWFkU2VsZihldnQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5zbmFwTGlua3NTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc25hcEFycm93aGVhZFNlbGYoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdEFycm93aGVhZCh0aGlzLmdldEV2ZW50VGFyZ2V0KGV2dCksIHgsIHksIHRoaXMuZXZlbnREYXRhKGV2dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRyYWc6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdGhpcy5tb2RlbC50cmFuc2xhdGUoeCAtIGRhdGEuZHgsIHkgLSBkYXRhLmR5LCB7IHVpOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGR4OiB4LFxuICAgICAgICAgICAgZHk6IHlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgRW5kIEhhbmRsZXJzXG5cbiAgICBkcmFnTGFiZWxFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIGRyYWdBcnJvd2hlYWRFbmQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcblxuICAgICAgICBpZiAocGFwZXIub3B0aW9ucy5zbmFwTGlua3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBBcnJvd2hlYWRFbmQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0QXJyb3doZWFkRW5kKGRhdGEsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXBlci5saW5rQWxsb3dlZCh0aGlzKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYW5nZWQgbGluayBpcyBub3QgYWxsb3dlZCwgcmV2ZXJ0IHRvIGl0cyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgICAgICAgIHRoaXMuX2Rpc2FsbG93KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoRW1iZWRkaW5nKGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5Q29ubmVjdEV2ZW50KGRhdGEsIGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hZnRlckFycm93aGVhZE1vdmUoZGF0YSk7XG4gICAgfSxcblxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIF9kaXNhbGxvdzogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIHN3aXRjaCAoZGF0YS53aGVuTm90QWxsb3dlZCkge1xuXG4gICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwucmVtb3ZlKHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JldmVydCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuc2V0KGRhdGEuYXJyb3doZWFkLCBkYXRhLmluaXRpYWxFbmQsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2ZpbmlzaEVtYmVkZGluZzogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIC8vIFJlcGFyZW50IHRoZSBsaW5rIGlmIGVtYmVkZGluZyBpcyBlbmFibGVkXG4gICAgICAgIGlmICh0aGlzLnBhcGVyLm9wdGlvbnMuZW1iZWRkaW5nTW9kZSAmJiB0aGlzLm1vZGVsLnJlcGFyZW50KCkpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZXZlcnNlIHRvIHRoZSBvcmlnaW5hbCAneicgaW5kZXggKHNlZSBhZnRlckFycm93aGVhZE1vdmUoKSkuXG4gICAgICAgICAgICBkYXRhLnogPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9ub3RpZnlDb25uZWN0RXZlbnQ6IGZ1bmN0aW9uKGRhdGEsIGV2dCkge1xuXG4gICAgICAgIHZhciBhcnJvd2hlYWQgPSBkYXRhLmFycm93aGVhZDtcbiAgICAgICAgdmFyIGluaXRpYWxFbmQgPSBkYXRhLmluaXRpYWxFbmQ7XG4gICAgICAgIHZhciBjdXJyZW50RW5kID0gdGhpcy5tb2RlbC5wcm9wKGFycm93aGVhZCk7XG4gICAgICAgIHZhciBlbmRDaGFuZ2VkID0gY3VycmVudEVuZCAmJiAhTGluay5lbmRzRXF1YWwoaW5pdGlhbEVuZCwgY3VycmVudEVuZCk7XG4gICAgICAgIGlmIChlbmRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxFbmQuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpkaXNjb25uZWN0JywgZXZ0LCBwYXBlci5maW5kVmlld0J5TW9kZWwoaW5pdGlhbEVuZC5pZCksIGRhdGEuaW5pdGlhbE1hZ25ldCwgYXJyb3doZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RW5kLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6Y29ubmVjdCcsIGV2dCwgcGFwZXIuZmluZFZpZXdCeU1vZGVsKGN1cnJlbnRFbmQuaWQpLCBkYXRhLm1hZ25ldFVuZGVyUG9pbnRlciwgYXJyb3doZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc25hcFRvUG9pbnRzOiBmdW5jdGlvbihzbmFwUG9pbnQsIHBvaW50cywgcmFkaXVzKSB7XG4gICAgICAgIGxldCBjbG9zZXN0UG9pbnRYID0gbnVsbDtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZVggPSBJbmZpbml0eTtcblxuICAgICAgICBsZXQgY2xvc2VzdFBvaW50WSA9IG51bGw7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2VZID0gSW5maW5pdHk7XG5cbiAgICAgICAgbGV0IHggPSBzbmFwUG9pbnQueDtcbiAgICAgICAgbGV0IHkgPSBzbmFwUG9pbnQueTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlzdFggPSBNYXRoLmFicyhwb2ludHNbaV0ueCAtIHNuYXBQb2ludC54KTtcbiAgICAgICAgICAgIGlmIChkaXN0WCA8IGNsb3Nlc3REaXN0YW5jZVgpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2VYID0gZGlzdFg7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50WCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGlzdFkgPSBNYXRoLmFicyhwb2ludHNbaV0ueSAtIHNuYXBQb2ludC55KTtcbiAgICAgICAgICAgIGlmIChkaXN0WSA8IGNsb3Nlc3REaXN0YW5jZVkpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2VZID0gZGlzdFk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50WSA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2VYIDwgcmFkaXVzKSB7XG4gICAgICAgICAgICB4ID0gY2xvc2VzdFBvaW50WC54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zZXN0RGlzdGFuY2VZIDwgcmFkaXVzKSB7XG4gICAgICAgICAgICB5ID0gY2xvc2VzdFBvaW50WS55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0sXG5cbiAgICBfc25hcEFycm93aGVhZFNlbGY6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIG1vZGVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHNuYXBMaW5rc1NlbGYgfSA9IHBhcGVyLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBjb25zdCByYWRpdXMgPSBzbmFwTGlua3NTZWxmLnJhZGl1cyB8fCAyMDtcblxuICAgICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmdldEVuZEFuY2hvcihkYXRhLmFycm93aGVhZCA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnKTtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBtb2RlbC52ZXJ0aWNlcygpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbYW5jaG9yLCAuLi52ZXJ0aWNlc107XG5cbiAgICAgICAgY29uc3Qgc25hcFBvaW50ID0gdGhpcy5fc25hcFRvUG9pbnRzKHsgeDogeCwgeTogeSB9LCBwb2ludHMsIHJhZGl1cyk7XG5cbiAgICAgICAgY29uc3QgcG9pbnQgPSBwYXBlci5sb2NhbFRvQ2xpZW50UG9pbnQoc25hcFBvaW50KTtcbiAgICAgICAgdGhpcy5fY29ubmVjdEFycm93aGVhZChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHBvaW50LngsIHBvaW50LnkpLCBzbmFwUG9pbnQueCwgc25hcFBvaW50LnksIHRoaXMuZXZlbnREYXRhKGV2dCkpO1xuICAgIH0sXG5cbiAgICBfc25hcEFycm93aGVhZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBwYXBlciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBzbmFwTGlua3MsIGNvbm5lY3Rpb25TdHJhdGVneSB9ID0gcGFwZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGxldCBpc1NuYXBwZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gY2hlY2tpbmcgdmlldyBpbiBjbG9zZSBhcmVhIG9mIHRoZSBwb2ludGVyXG5cbiAgICAgICAgdmFyIHIgPSBzbmFwTGlua3MucmFkaXVzIHx8IDUwO1xuICAgICAgICB2YXIgdmlld3NJbkFyZWEgPSBwYXBlci5maW5kRWxlbWVudFZpZXdzSW5BcmVhKFxuICAgICAgICAgICAgeyB4OiB4IC0gciwgeTogeSAtIHIsIHdpZHRoOiAyICogciwgaGVpZ2h0OiAyICogciB9LFxuICAgICAgICAgICAgc25hcExpbmtzLmZpbmRJbkFyZWFPcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHByZXZDbG9zZXN0VmlldyA9IGRhdGEuY2xvc2VzdFZpZXcgfHwgbnVsbDtcbiAgICAgICAgdmFyIHByZXZDbG9zZXN0TWFnbmV0ID0gZGF0YS5jbG9zZXN0TWFnbmV0IHx8IG51bGw7XG4gICAgICAgIHZhciBwcmV2TWFnbmV0UHJveHkgPSBkYXRhLm1hZ25ldFByb3h5IHx8IG51bGw7XG5cbiAgICAgICAgZGF0YS5jbG9zZXN0VmlldyA9IGRhdGEuY2xvc2VzdE1hZ25ldCA9IGRhdGEubWFnbmV0UHJveHkgPSBudWxsO1xuXG4gICAgICAgIHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIHZhciBwb2ludGVyID0gbmV3IFBvaW50KHgsIHkpO1xuXG4gICAgICAgIHZpZXdzSW5BcmVhLmZvckVhY2goZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICAgICAgLy8gc2tpcCBjb25uZWN0aW5nIHRvIHRoZSBlbGVtZW50IGluIGNhc2UgJy4nOiB7IG1hZ25ldDogZmFsc2UgfSBhdHRyaWJ1dGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHZpZXcuZWwuZ2V0QXR0cmlidXRlKCdtYWduZXQnKSAhPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGJib3g6IHZpZXcubW9kZWwuZ2V0QkJveCgpLFxuICAgICAgICAgICAgICAgICAgICBtYWduZXQ6IHZpZXcuZWxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmlldy4kKCdbbWFnbmV0XScpLnRvQXJyYXkoKS5mb3JFYWNoKG1hZ25ldCA9PiB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYmJveDogdmlldy5nZXROb2RlQkJveChtYWduZXQpLFxuICAgICAgICAgICAgICAgICAgICBtYWduZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1hZ25ldCwgYmJveCB9ID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBtb2RlbCB0byBwb2ludGVyIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBiYm94LmNlbnRlcigpLnNxdWFyZWREaXN0YW5jZShwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29ubmVjdGlvbiBpcyBsb29rZWQgdXAgaW4gYSBjaXJjbGUgYXJlYSBieSBgZGlzdGFuY2UgPCByYFxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQWxyZWFkeVZhbGlkYXRlZCA9IHByZXZDbG9zZXN0TWFnbmV0ID09PSBtYWduZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FscmVhZHlWYWxpZGF0ZWQgfHwgcGFwZXIub3B0aW9ucy52YWxpZGF0ZUNvbm5lY3Rpb24uYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlciwgZGF0YS52YWxpZGF0ZUNvbm5lY3Rpb25BcmdzKHZpZXcsICh2aWV3LmVsID09PSBtYWduZXQpID8gbnVsbCA6IG1hZ25ldClcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2xvc2VzdFZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jbG9zZXN0TWFnbmV0ID0gbWFnbmV0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgdmFyIG1hZ25ldFByb3h5ID0gbnVsbDtcbiAgICAgICAgdmFyIGNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0VmlldztcbiAgICAgICAgdmFyIGNsb3Nlc3RNYWduZXQgPSBkYXRhLmNsb3Nlc3RNYWduZXQ7XG4gICAgICAgIGlmIChjbG9zZXN0TWFnbmV0KSB7XG4gICAgICAgICAgICBtYWduZXRQcm94eSA9IGRhdGEubWFnbmV0UHJveHkgPSBjbG9zZXN0Vmlldy5maW5kUHJveHlOb2RlKGNsb3Nlc3RNYWduZXQsICdoaWdobGlnaHRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmRUeXBlID0gZGF0YS5hcnJvd2hlYWQ7XG4gICAgICAgIHZhciBuZXdDbG9zZXN0TWFnbmV0ID0gKHByZXZDbG9zZXN0TWFnbmV0ICE9PSBjbG9zZXN0TWFnbmV0KTtcbiAgICAgICAgaWYgKHByZXZDbG9zZXN0VmlldyAmJiBuZXdDbG9zZXN0TWFnbmV0KSB7XG4gICAgICAgICAgICBwcmV2Q2xvc2VzdFZpZXcudW5oaWdobGlnaHQocHJldk1hZ25ldFByb3h5LCB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzbmFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvc2VzdFZpZXcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJldkVuZCwgcHJldlgsIHByZXZZIH0gPSBkYXRhO1xuICAgICAgICAgICAgZGF0YS5wcmV2WCA9IHg7XG4gICAgICAgICAgICBkYXRhLnByZXZZID0geTtcbiAgICAgICAgICAgIGlzU25hcHBlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghbmV3Q2xvc2VzdE1hZ25ldCkgIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3Rpb25TdHJhdGVneSAhPT0gJ2Z1bmN0aW9uJyB8fCAocHJldlggPT09IHggJiYgcHJldlkgPT09IHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYWduZXQgaGFzIG5vdCBjaGFuZ2VkIGFuZCB0aGUgbGluaydzIGVuZCBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIHggYW5kIHlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU25hcHBlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVuZCA9IGNsb3Nlc3RWaWV3LmdldExpbmtFbmQoY2xvc2VzdE1hZ25ldCwgeCwgeSwgdGhpcy5tb2RlbCwgZW5kVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW5ld0Nsb3Nlc3RNYWduZXQgJiYgaXNFcXVhbChwcmV2RW5kLCBlbmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHNvdXJjZS90YXJnZXQganNvbiBoYXMgbm90IGNoYW5nZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTbmFwcGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLnByZXZFbmQgPSBlbmQ7XG5cbiAgICAgICAgICAgIGlmIChuZXdDbG9zZXN0TWFnbmV0KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFZpZXcuaGlnaGxpZ2h0KG1hZ25ldFByb3h5LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHNuYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgZW5kID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vZGVsLnNldChlbmRUeXBlLCBlbmQgfHwgeyB4OiB4LCB5OiB5IH0sIHsgdWk6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKHByZXZDbG9zZXN0Vmlldykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6c25hcDpkaXNjb25uZWN0JywgZXZ0LCBwcmV2Q2xvc2VzdFZpZXcsIHByZXZDbG9zZXN0TWFnbmV0LCBlbmRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvc2VzdFZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnNuYXA6Y29ubmVjdCcsIGV2dCwgY2xvc2VzdFZpZXcsIGNsb3Nlc3RNYWduZXQsIGVuZFR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzU25hcHBlZDtcbiAgICB9LFxuXG4gICAgX3NuYXBBcnJvd2hlYWRFbmQ6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAvLyBGaW5pc2ggb2ZmIGxpbmsgc25hcHBpbmcuXG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgZXhjZXB0IHZpZXcgdW5oaWdobGlnaHRpbmcgd2FzIGFscmVhZHkgZG9uZSBvbiBwb2ludGVybW92ZS5cbiAgICAgICAgdmFyIGNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0VmlldztcbiAgICAgICAgdmFyIGNsb3Nlc3RNYWduZXQgPSBkYXRhLmNsb3Nlc3RNYWduZXQ7XG4gICAgICAgIGlmIChjbG9zZXN0VmlldyAmJiBjbG9zZXN0TWFnbmV0KSB7XG5cbiAgICAgICAgICAgIGNsb3Nlc3RWaWV3LnVuaGlnaGxpZ2h0KGRhdGEubWFnbmV0UHJveHksIHsgY29ubmVjdGluZzogdHJ1ZSwgc25hcHBpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICBkYXRhLm1hZ25ldFVuZGVyUG9pbnRlciA9IGNsb3Nlc3RWaWV3LmZpbmRNYWduZXQoY2xvc2VzdE1hZ25ldCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLmNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0TWFnbmV0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgX2Nvbm5lY3RBcnJvd2hlYWQ6IGZ1bmN0aW9uKHRhcmdldCwgeCwgeSwgZGF0YSkge1xuXG4gICAgICAgIC8vIGNoZWNraW5nIHZpZXdzIHJpZ2h0IHVuZGVyIHRoZSBwb2ludGVyXG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIG1vZGVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmV2ZW50VGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIFVuaGlnaGxpZ2h0IHRoZSBwcmV2aW91cyB2aWV3IHVuZGVyIHBvaW50ZXIgaWYgdGhlcmUgd2FzIG9uZS5cbiAgICAgICAgICAgIGlmIChkYXRhLm1hZ25ldFByb3h5KSB7XG4gICAgICAgICAgICAgICAgZGF0YS52aWV3VW5kZXJQb2ludGVyLnVuaGlnaGxpZ2h0KGRhdGEubWFnbmV0UHJveHksIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2aWV3VW5kZXJQb2ludGVyID0gZGF0YS52aWV3VW5kZXJQb2ludGVyID0gcGFwZXIuZmluZFZpZXcodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh2aWV3VW5kZXJQb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYSB2aWV3IHRoYXQgaXMgdW5kZXIgdGhlIHBvaW50ZXIsIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdFxuICAgICAgICAgICAgICAgIC8vIG1hZ25ldCBiYXNlZCBvbiB0aGUgcmVhbCB0YXJnZXQgZWxlbWVudCBvZiB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgbWFnbmV0VW5kZXJQb2ludGVyID0gZGF0YS5tYWduZXRVbmRlclBvaW50ZXIgPSB2aWV3VW5kZXJQb2ludGVyLmZpbmRNYWduZXQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWduZXRQcm94eSA9IGRhdGEubWFnbmV0UHJveHkgPSB2aWV3VW5kZXJQb2ludGVyLmZpbmRQcm94eU5vZGUobWFnbmV0VW5kZXJQb2ludGVyLCAnaGlnaGxpZ2h0ZXInKTtcblxuICAgICAgICAgICAgICAgIGlmIChtYWduZXRVbmRlclBvaW50ZXIgJiYgdGhpcy5wYXBlci5vcHRpb25zLnZhbGlkYXRlQ29ubmVjdGlvbi5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgcGFwZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudmFsaWRhdGVDb25uZWN0aW9uQXJncyh2aWV3VW5kZXJQb2ludGVyLCBtYWduZXRVbmRlclBvaW50ZXIpXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gbWFnbmV0IGZvdW5kLCBkbyBub3QgaGlnaGxpZ2h0IGFueXRoaW5nIGFuZCBhc3N1bWUgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gdmlldyB1bmRlciBwb2ludGVyIHdlJ3JlIGludGVyZXN0ZWQgaW4gcmVjb25uZWN0aW5nIHRvLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgb3ZlcmFsbCBlbGVtZW50IGhhcyB0aGUgYXR0cmlidXRlIGAnLic6IHsgbWFnbmV0OiBmYWxzZSB9YC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hZ25ldFByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VW5kZXJQb2ludGVyLmhpZ2hsaWdodChtYWduZXRQcm94eSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlIG9mIGNvbm5lY3Rpb24gaXMgbm90IHZhbGlkLiBEaXNyZWdhcmQgdGhpcyBtYWduZXQuXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWFnbmV0VW5kZXJQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYWduZXRQcm94eSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UnbGwgdW5zZXQgcHJldmlvdXMgbWFnbmV0LlxuICAgICAgICAgICAgICAgIGRhdGEubWFnbmV0VW5kZXJQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkYXRhLm1hZ25ldFByb3h5ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuZXZlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgbW9kZWwuc2V0KGRhdGEuYXJyb3doZWFkLCB7IHg6IHgsIHk6IHkgfSwgeyB1aTogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgX2Nvbm5lY3RBcnJvd2hlYWRFbmQ6IGZ1bmN0aW9uKGRhdGEgPSB7fSwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlld1VuZGVyUG9pbnRlciwgbWFnbmV0VW5kZXJQb2ludGVyLCBtYWduZXRQcm94eSwgYXJyb3doZWFkIH0gPSBkYXRhO1xuXG4gICAgICAgIGlmICghbWFnbmV0VW5kZXJQb2ludGVyIHx8ICFtYWduZXRQcm94eSB8fCAhdmlld1VuZGVyUG9pbnRlcikgcmV0dXJuO1xuXG4gICAgICAgIHZpZXdVbmRlclBvaW50ZXIudW5oaWdobGlnaHQobWFnbmV0UHJveHksIHsgY29ubmVjdGluZzogdHJ1ZSB9KTtcblxuICAgICAgICAvLyBUaGUgbGluayBlbmQgaXMgdGFrZW4gZnJvbSB0aGUgbWFnbmV0IHVuZGVyIHRoZSBwb2ludGVyLCBub3QgdGhlIHByb3h5LlxuICAgICAgICBjb25zdCBlbmQgPSB2aWV3VW5kZXJQb2ludGVyLmdldExpbmtFbmQobWFnbmV0VW5kZXJQb2ludGVyLCB4LCB5LCBtb2RlbCwgYXJyb3doZWFkKTtcbiAgICAgICAgbW9kZWwuc2V0KGFycm93aGVhZCwgZW5kLCB7IHVpOiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICBfYmVmb3JlQXJyb3doZWFkTW92ZTogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIGRhdGEueiA9IHRoaXMubW9kZWwuZ2V0KCd6Jyk7XG4gICAgICAgIHRoaXMubW9kZWwudG9Gcm9udCgpO1xuXG4gICAgICAgIC8vIExldCB0aGUgcG9pbnRlciBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgbGluayB2aWV3IGVsZW1lbnRzIHNvIHRoYXRcbiAgICAgICAgLy8gdGhlIGBldnQudGFyZ2V0YCBpcyBhbm90aGVyIGVsZW1lbnQgdW5kZXIgdGhlIHBvaW50ZXIsIG5vdCB0aGUgbGluayBpdHNlbGYuXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgICAgIGRhdGEucG9pbnRlckV2ZW50cyA9IHN0eWxlLnBvaW50ZXJFdmVudHM7XG4gICAgICAgIHN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5tYXJrQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrQXZhaWxhYmxlTWFnbmV0cyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfYWZ0ZXJBcnJvd2hlYWRNb3ZlOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgaWYgKGRhdGEueiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoJ3onLCBkYXRhLnosIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICBkYXRhLnogPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHV0IGBwb2ludGVyLWV2ZW50c2AgYmFjayB0byBpdHMgb3JpZ2luYWwgdmFsdWUuIFNlZSBgX2JlZm9yZUFycm93aGVhZE1vdmUoKWAgZm9yIGV4cGxhbmF0aW9uLlxuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBkYXRhLnBvaW50ZXJFdmVudHM7XG5cbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5tYXJrQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hcmtBdmFpbGFibGVNYWduZXRzKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jcmVhdGVWYWxpZGF0ZUNvbm5lY3Rpb25BcmdzOiBmdW5jdGlvbihhcnJvd2hlYWQpIHtcbiAgICAgICAgLy8gSXQgbWFrZXMgc3VyZSB0aGUgYXJndW1lbnRzIGZvciB2YWxpZGF0ZUNvbm5lY3Rpb24gaGF2ZSB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICAgIC8vIChzb3VyY2Ugdmlldywgc291cmNlIG1hZ25ldCwgdGFyZ2V0IHZpZXcsIHRhcmdldCBtYWduZXQgYW5kIGxpbmsgdmlldylcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgICBhcmdzWzRdID0gYXJyb3doZWFkO1xuICAgICAgICBhcmdzWzVdID0gdGhpcztcblxuICAgICAgICB2YXIgb3Bwb3NpdGVBcnJvd2hlYWQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGogPSAwO1xuXG4gICAgICAgIGlmIChhcnJvd2hlYWQgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBpID0gMjtcbiAgICAgICAgICAgIG9wcG9zaXRlQXJyb3doZWFkID0gJ3RhcmdldCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgIG9wcG9zaXRlQXJyb3doZWFkID0gJ3NvdXJjZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tb2RlbC5nZXQob3Bwb3NpdGVBcnJvd2hlYWQpO1xuXG4gICAgICAgIGlmIChlbmQuaWQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gYXJnc1tpXSA9IHRoaXMucGFwZXIuZmluZFZpZXdCeU1vZGVsKGVuZC5pZCk7XG4gICAgICAgICAgICB2YXIgbWFnbmV0ID0gdmlldy5nZXRNYWduZXRGcm9tTGlua0VuZChlbmQpO1xuICAgICAgICAgICAgaWYgKG1hZ25ldCA9PT0gdmlldy5lbCkgbWFnbmV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXJnc1tpICsgMV0gPSBtYWduZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZUNvbm5lY3Rpb25BcmdzKGNlbGxWaWV3LCBtYWduZXQpIHtcbiAgICAgICAgICAgIGFyZ3Nbal0gPSBjZWxsVmlldztcbiAgICAgICAgICAgIGFyZ3NbaiArIDFdID0gY2VsbFZpZXcuZWwgPT09IG1hZ25ldCA/IHVuZGVmaW5lZCA6IG1hZ25ldDtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlQ29ubmVjdGlvbkFyZ3M7XG4gICAgfSxcblxuICAgIF9tYXJrQXZhaWxhYmxlTWFnbmV0czogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzTWFnbmV0QXZhaWxhYmxlKHZpZXcsIG1hZ25ldCkge1xuICAgICAgICAgICAgdmFyIHBhcGVyID0gdmlldy5wYXBlcjtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZSA9IHBhcGVyLm9wdGlvbnMudmFsaWRhdGVDb25uZWN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlLmFwcGx5KHBhcGVyLCB0aGlzLnZhbGlkYXRlQ29ubmVjdGlvbkFyZ3ModmlldywgbWFnbmV0KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBwYXBlci5tb2RlbC5nZXRDZWxscygpO1xuICAgICAgICBkYXRhLm1hcmtlZCA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmlldyA9IGVsZW1lbnRzW2ldLmZpbmRWaWV3KHBhcGVyKTtcblxuICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYWduZXRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmlldy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbbWFnbmV0XScpKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmVsLmdldEF0dHJpYnV0ZSgnbWFnbmV0JykgIT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IHdyYXBwaW5nIGdyb3VwIGlzIGFsc28gYSBtYWduZXRcbiAgICAgICAgICAgICAgICBtYWduZXRzLnB1c2godmlldy5lbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVNYWduZXRzID0gbWFnbmV0cy5maWx0ZXIoaXNNYWduZXRBdmFpbGFibGUuYmluZChkYXRhLCB2aWV3KSk7XG5cbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVNYWduZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHQgYWxsIGF2YWlsYWJsZSBtYWduZXRzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBhdmFpbGFibGVNYWduZXRzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmhpZ2hsaWdodChhdmFpbGFibGVNYWduZXRzW2pdLCB7IG1hZ25ldEF2YWlsYWJpbGl0eTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSBlbnRpcmUgdmlld1xuICAgICAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KG51bGwsIHsgZWxlbWVudEF2YWlsYWJpbGl0eTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgICAgIGRhdGEubWFya2VkW3ZpZXcubW9kZWwuaWRdID0gYXZhaWxhYmxlTWFnbmV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfdW5tYXJrQXZhaWxhYmxlTWFnbmV0czogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIHZhciBtYXJrZWRLZXlzID0gT2JqZWN0LmtleXMoZGF0YS5tYXJrZWQpO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIHZhciBtYXJrZWRNYWduZXRzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbWFya2VkS2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlkID0gbWFya2VkS2V5c1tpXTtcbiAgICAgICAgICAgIG1hcmtlZE1hZ25ldHMgPSBkYXRhLm1hcmtlZFtpZF07XG5cbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5wYXBlci5maW5kVmlld0J5TW9kZWwoaWQpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IG1hcmtlZE1hZ25ldHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQobWFya2VkTWFnbmV0c1tqXSwgeyBtYWduZXRBdmFpbGFiaWxpdHk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpZXcudW5oaWdobGlnaHQobnVsbCwgeyBlbGVtZW50QXZhaWxhYmlsaXR5OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5tYXJrZWQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBzdGFydEFycm93aGVhZE1vdmU6IGZ1bmN0aW9uKGVuZCwgb3B0KSB7XG5cbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgLy8gQWxsb3cgdG8gZGVsZWdhdGUgZXZlbnRzIGZyb20gYW4gYW5vdGhlciB2aWV3IHRvIHRoaXMgbGlua1ZpZXcgaW4gb3JkZXIgdG8gdHJpZ2dlciBhcnJvd2hlYWRcbiAgICAgICAgLy8gbW92ZSB3aXRob3V0IG5lZWQgdG8gY2xpY2sgb24gdGhlIGFjdHVhbCBhcnJvd2hlYWQgZG9tIGVsZW1lbnQuXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgYWN0aW9uOiAnYXJyb3doZWFkLW1vdmUnLFxuICAgICAgICAgICAgYXJyb3doZWFkOiBlbmQsXG4gICAgICAgICAgICB3aGVuTm90QWxsb3dlZDogb3B0LndoZW5Ob3RBbGxvd2VkIHx8ICdyZXZlcnQnLFxuICAgICAgICAgICAgaW5pdGlhbE1hZ25ldDogdGhpc1tlbmQgKyAnTWFnbmV0J10gfHwgKHRoaXNbZW5kICsgJ1ZpZXcnXSA/IHRoaXNbZW5kICsgJ1ZpZXcnXS5lbCA6IG51bGwpLFxuICAgICAgICAgICAgaW5pdGlhbEVuZDogY2xvbmUodGhpcy5tb2RlbC5nZXQoZW5kKSksXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbm5lY3Rpb25BcmdzOiB0aGlzLl9jcmVhdGVWYWxpZGF0ZUNvbm5lY3Rpb25BcmdzKGVuZClcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9iZWZvcmVBcnJvd2hlYWRNb3ZlKGRhdGEpO1xuXG4gICAgICAgIGlmIChvcHQuaWdub3JlQmFja3dhcmRzQ29tcGF0aWJpbGl0eSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0RhdGEgPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIC8vIExpZmVjeWNsZSBtZXRob2RzXG5cbiAgICBvbk1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm9uTW91bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb3VudExhYmVscygpO1xuICAgIH0sXG5cbiAgICBvbkRldGFjaDogZnVuY3Rpb24oKSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5vbkRldGFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVubW91bnRMYWJlbHMoKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUub25SZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51bm1vdW50TGFiZWxzKCk7XG4gICAgfVxuXG59LCB7XG5cbiAgICBGbGFnczogRmxhZ3MsXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtWaWV3LnByb3RvdHlwZSwgJ3NvdXJjZUJCb3gnLCB7XG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNvdXJjZVZpZXcgPSB0aGlzLnNvdXJjZVZpZXc7XG4gICAgICAgIGlmICghc291cmNlVmlldykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZURlZiA9IHRoaXMubW9kZWwuc291cmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3Qoc291cmNlRGVmLngsIHNvdXJjZURlZi55KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlTWFnbmV0ID0gdGhpcy5zb3VyY2VNYWduZXQ7XG4gICAgICAgIGlmIChzb3VyY2VWaWV3LmlzTm9kZUNvbm5lY3Rpb24oc291cmNlTWFnbmV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMuc291cmNlQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlVmlldy5nZXROb2RlQkJveChzb3VyY2VNYWduZXQgfHwgc291cmNlVmlldy5lbCk7XG4gICAgfVxuXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtWaWV3LnByb3RvdHlwZSwgJ3RhcmdldEJCb3gnLCB7XG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhcmdldFZpZXcgPSB0aGlzLnRhcmdldFZpZXc7XG4gICAgICAgIGlmICghdGFyZ2V0Vmlldykge1xuICAgICAgICAgICAgdmFyIHRhcmdldERlZiA9IHRoaXMubW9kZWwudGFyZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QodGFyZ2V0RGVmLngsIHRhcmdldERlZi55KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0TWFnbmV0ID0gdGhpcy50YXJnZXRNYWduZXQ7XG4gICAgICAgIGlmICh0YXJnZXRWaWV3LmlzTm9kZUNvbm5lY3Rpb24odGFyZ2V0TWFnbmV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMudGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0Vmlldy5nZXROb2RlQkJveCh0YXJnZXRNYWduZXQgfHwgdGFyZ2V0Vmlldy5lbCk7XG4gICAgfVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/LinkView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/Paper.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Paper.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paper: () => (/* binding */ Paper)\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_ViewBase_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../mvc/ViewBase.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ElementView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ElementView.mjs\");\n/* harmony import */ var _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinkView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/LinkView.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _Graph_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Graph.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Graph.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../highlighters/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/index.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../linkAnchors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n/* harmony import */ var _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../connectionPoints/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/connectionPoints/index.mjs\");\n/* harmony import */ var _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../anchors/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/anchors/index.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _layers_GridLayer_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./layers/GridLayer.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/layers/GridLayer.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst sortingTypes = {\n    NONE: 'sorting-none',\n    APPROX: 'sorting-approximate',\n    EXACT: 'sorting-exact'\n};\n\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Highlighting;\n\nconst defaultHighlighting = {\n    [HighlightingTypes.DEFAULT]: {\n        name: 'stroke',\n        options: {\n            padding: 3\n        }\n    },\n    [HighlightingTypes.MAGNET_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-magnet'\n        }\n    },\n    [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-cell'\n        }\n    }\n};\n\nconst defaultLayers = [{\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.BACK,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.CELLS,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.LABELS,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.FRONT\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.TOOLS\n}];\n\nconst Paper = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.View.extend({\n\n    className: 'paper',\n\n    options: {\n\n        width: 800,\n        height: 600,\n        gridSize: 1,\n        // Whether or not to draw the grid lines on the paper's DOM element.\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n        drawGrid: false,\n        // If not set, the size of the visual grid is the same as the `gridSize`.\n        drawGridSize: null,\n\n        // Whether or not to draw the background on the paper's DOM element.\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n        background: false,\n\n        elementView: _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__.ElementView,\n        linkView: _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__.LinkView,\n        snapLabels: false, // false, true\n        snapLinks: false, // false, true, { radius: value }\n        snapLinksSelf: false, // false, true, { radius: value }\n\n        // Should the link labels be rendered into its own layer?\n        // `false` - the labels are part of the links\n        // `true` - the labels are appended to LayersName.LABELS\n        // [LayersName] - the labels are appended to the layer specified\n        labelsLayer: false,\n\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n        multiLinks: true,\n\n        // For adding custom guard logic.\n        guard: function(evt, view) {\n\n            // FALSE means the event isn't guarded.\n            return false;\n        },\n\n        highlighting: defaultHighlighting,\n\n        // Prevent the default context menu from being displayed.\n        preventContextMenu: true,\n\n        // Prevent the default action for blank:pointer<action>.\n        preventDefaultBlankAction: true,\n\n        // Prevent the default action for cell:pointer<action>.\n        preventDefaultViewAction: true,\n\n        // Restrict the translation of elements by given bounding box.\n        // Option accepts a boolean:\n        //  true - the translation is restricted to the paper area\n        //  false - no restrictions\n        // A method:\n        // restrictTranslate: function(elementView) {\n        //     var parentId = elementView.model.get('parent');\n        //     return parentId && this.model.getCell(parentId).getBBox();\n        // },\n        // Or a bounding box:\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n        restrictTranslate: false,\n\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n        // when the dragging is stopped.\n        markAvailable: false,\n\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\n        // Value could be the mvc.model or a function returning the mvc.model\n        // defaultLink: (elementView, magnet) => {\n        //   return condition ? new customLink1() : new customLink2()\n        // }\n        defaultLink: function() {\n            // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n            const { cellNamespace } = this.model.get('cells');\n            const ctor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.getByPath)(cellNamespace, ['standard', 'Link']);\n            if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n            return new ctor();\n        },\n\n        // A connector that is used by links with no connector defined on the model.\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n        defaultConnector: { name: 'normal' },\n\n        // A router that is used by links with no router defined on the model.\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n        defaultRouter: { name: 'normal' },\n\n        defaultAnchor: { name: 'center' },\n\n        defaultLinkAnchor: { name: 'connectionRatio' },\n\n        defaultConnectionPoint: { name: 'boundary' },\n\n        /* CONNECTING */\n\n        connectionStrategy: null,\n\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\n        validateMagnet: function(_cellView, magnet, _evt) {\n            return magnet.getAttribute('magnet') !== 'passive';\n        },\n\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n        // being changed.\n        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n            return (end === 'target' ? cellViewT : cellViewS) instanceof _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__.ElementView;\n        },\n\n        /* EMBEDDING */\n\n        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n        // all links and elements are visible taken the level of embedding into account.\n        embeddingMode: false,\n\n        // Check whether to allow or disallow the element embedding while an element being translated.\n        validateEmbedding: function(childView, parentView) {\n            // by default all elements can be in relation child-parent\n            return true;\n        },\n\n        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n        validateUnembedding: function(childView) {\n            // by default all elements can become roots\n            return true;\n        },\n\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n        // The cell with the highest z-index (visually on the top) will be chosen.\n        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n        // If enabled only the element on the very front is taken into account for the embedding.\n        // If disabled the elements under the dragged view are tested one by one\n        // (from front to back) until a valid parent found.\n        frontParentOnly: true,\n\n        // Interactive flags. See online docs for the complete list of interactive flags.\n        interactive: {\n            labelMove: false\n        },\n\n        // When set to true the links can be pinned to the paper.\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n        linkPinning: true,\n\n        // Custom validation after an interaction with a link ends.\n        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n        // (linkView, paper) => boolean\n        allowLink: null,\n\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n        clickThreshold: 0,\n\n        // Number of required mousemove events before the first pointermove event will be triggered.\n        moveThreshold: 0,\n\n        // Number of required mousemove events before a link is created out of the magnet.\n        // Or string `onleave` so the link is created when the pointer leaves the magnet\n        magnetThreshold: 0,\n\n        // Rendering Options\n\n        sorting: sortingTypes.APPROX,\n\n        frozen: false,\n\n        autoFreeze: false,\n\n        // no docs yet\n        onViewUpdate: function(view, flag, priority, opt, paper) {\n            // Do not update connected links when:\n            // 1. the view was just inserted (added to the graph and rendered)\n            // 2. the view was just mounted (added back to the paper by viewport function)\n            // 3. the change was marked as `isolate`.\n            // 4. the view model was just removed from the graph\n            if ((flag & (view.FLAG_INSERT | view.FLAG_REMOVE)) || opt.mounting || opt.isolate) return;\n            paper.requestConnectedLinksUpdate(view, priority, opt);\n        },\n\n        // no docs yet\n        onViewPostponed: function(view, flag, paper) {\n            return paper.forcePostponedViewUpdate(view, flag);\n        },\n\n        beforeRender: null, // function(opt, paper) { },\n\n        afterRender: null, // function(stats, opt, paper) {\n\n        viewport: null,\n\n        // Default namespaces\n\n        cellViewNamespace: null,\n\n        routerNamespace: null,\n\n        connectorNamespace: null,\n\n        highlighterNamespace: _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_6__,\n\n        anchorNamespace: _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__,\n\n        linkAnchorNamespace: _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_8__,\n\n        connectionPointNamespace: _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_9__,\n\n        overflow: false\n    },\n\n    events: {\n        'dblclick': 'pointerdblclick',\n        'dbltap': 'pointerdblclick',\n        'contextmenu': 'contextmenu',\n        'mousedown': 'pointerdown',\n        'touchstart': 'pointerdown',\n        'mouseover': 'mouseover',\n        'mouseout': 'mouseout',\n        'mouseenter': 'mouseenter',\n        'mouseleave': 'mouseleave',\n        'wheel': 'mousewheel',\n        'mouseenter .joint-cell': 'mouseenter',\n        'mouseleave .joint-cell': 'mouseleave',\n        'mouseenter .joint-tools': 'mouseenter',\n        'mouseleave .joint-tools': 'mouseleave',\n        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n        'touchstart .joint-link .label': 'onlabel',\n        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n    },\n\n    documentEvents: {\n        'mousemove': 'pointermove',\n        'touchmove': 'pointermove',\n        'mouseup': 'pointerup',\n        'touchend': 'pointerup',\n        'touchcancel': 'pointerup'\n    },\n\n    /* CSS within the SVG document\n    * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n    *    elements that use the `scalable` group.\n    */\n    stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n\n    svg: null,\n    viewport: null,\n    defs: null,\n    tools: null,\n    layers: null,\n\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\n    _viewportMatrix: null,\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n    // could have been manipulated directly.\n    _viewportTransformString: null,\n    // Updates data (priorities, unmounted views etc.)\n    _updates: null,\n    // Paper Layers\n    _layers: null,\n\n    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n    UPDATE_DELAYING_BATCHES: ['translate'],\n    // If you interact with these elements,\n    // the default interaction such as `element move` is prevented.\n    FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'] ,\n    // If you interact with these elements, the events are not propagated to the paper\n    // i.e. paper events such as `element:pointerdown` are not triggered.\n    GUARDED_TAG_NAMES: [\n        // Guard <select> for consistency. When you click on it:\n        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n        //          on close. However, if you open and then close by clicking elsewhere on the page,\n        //           no other event is triggered.\n        // Safari: when you open it, it triggers `pointerdown`. That's it.\n        'SELECT',\n    ],\n    MIN_SCALE: 1e-6,\n\n    // Default find buffer for the findViewsInArea and findViewsAtPoint methods.\n    // The find buffer is used to extend the area of the search\n    // to mitigate the differences between the model and view geometry.\n    DEFAULT_FIND_BUFFER: 200,\n\n    init: function() {\n\n        const { options } = this;\n        if (!options.cellViewNamespace) {\n            /* eslint-disable no-undef */\n            options.cellViewNamespace = typeof joint !== 'undefined' && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.has)(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n        const model = this.model = options.model || new _Graph_mjs__WEBPACK_IMPORTED_MODULE_11__.Graph;\n\n        // Layers (SVGGroups)\n        this._layers = {};\n\n        this.cloneOptions();\n        this.render();\n        this._setDimensions();\n        this.startListening();\n\n        // Hash of all cell views.\n        this._views = {};\n\n        // Mouse wheel events buffer\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n\n        // Render existing cells in the graph\n        this.resetViews(model.attributes.cells.models);\n        // Start the Rendering Loop\n        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n    },\n\n    _resetUpdates: function() {\n        if (this._updates && this._updates.id) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cancelFrame)(this._updates.id);\n\n        return this._updates = {\n            id: null,\n            priorities: [{}, {}, {}],\n            unmountedCids: [],\n            mountedCids: [],\n            unmounted: {},\n            mounted: {},\n            count: 0,\n            keyFrozen: false,\n            freezeKey: null,\n            sort: false,\n            disabled: false,\n            idle: false\n        };\n    },\n\n    startListening: function() {\n        var model = this.model;\n        this.listenTo(model, 'add', this.onCellAdded)\n            .listenTo(model, 'remove', this.onCellRemoved)\n            .listenTo(model, 'change', this.onCellChange)\n            .listenTo(model, 'reset', this.onGraphReset)\n            .listenTo(model, 'sort', this.onGraphSort)\n            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n        this.on('cell:highlight', this.onCellHighlight)\n            .on('cell:unhighlight', this.onCellUnhighlight)\n            .on('transform', this.update);\n    },\n\n    onCellAdded: function(cell, _, opt) {\n        var position = opt.position;\n        if (this.isAsync() || !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(position)) {\n            this.renderView(cell, opt);\n        } else {\n            if (opt.maxPosition === position) this.freeze({ key: 'addCells' });\n            this.renderView(cell, opt);\n            if (position === 0) this.unfreeze({ key: 'addCells' });\n        }\n    },\n\n    onCellRemoved: function(cell, _, opt) {\n        const view = this.findViewByModel(cell);\n        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n    },\n\n    onCellChange: function(cell, opt) {\n        if (cell === this.model.attributes.cells) return;\n        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n            const view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    onGraphReset: function(collection, opt) {\n        this.resetLayers();\n        this.resetViews(collection.models, opt);\n    },\n\n    onGraphSort: function() {\n        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n        this.sortViews();\n    },\n\n    onGraphBatchStop: function(data) {\n        if (this.isFrozen()) return;\n        var name = data && data.batchName;\n        var graph = this.model;\n        if (!this.isAsync()) {\n            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    },\n\n    cloneOptions: function() {\n\n        const { options } = this;\n        const {\n            defaultConnector,\n            defaultRouter,\n            defaultConnectionPoint,\n            defaultAnchor,\n            defaultLinkAnchor,\n            highlighting,\n            cellViewNamespace,\n            interactive\n        } = options;\n\n        // Default cellView namespace for ES5\n        /* eslint-disable no-undef */\n        if (!cellViewNamespace && typeof joint !== 'undefined' && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.has)(joint, 'shapes')) {\n            options.cellViewNamespace = joint.shapes;\n        }\n        /* eslint-enable no-undef */\n\n        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultConnector)) {\n            options.defaultConnector = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultConnector);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultRouter)) {\n            options.defaultRouter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultRouter);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultConnectionPoint)) {\n            options.defaultConnectionPoint = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultConnectionPoint);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultAnchor)) {\n            options.defaultAnchor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultAnchor);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultLinkAnchor)) {\n            options.defaultLinkAnchor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultLinkAnchor);\n        }\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isPlainObject)(interactive)) {\n            options.interactive = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.assign)({}, interactive);\n        }\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isPlainObject)(highlighting)) {\n            // Return the default highlighting options into the user specified options.\n            options.highlighting = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaultsDeep)({}, highlighting, defaultHighlighting);\n        }\n    },\n\n    children: function() {\n        var ns = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].namespace;\n        return [{\n            namespaceURI: ns.xhtml,\n            tagName: 'div',\n            className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('paper-background'),\n            selector: 'background',\n            style: {\n                position: 'absolute',\n                inset: 0\n            }\n        }, {\n            namespaceURI: ns.svg,\n            tagName: 'svg',\n            attributes: {\n                'width': '100%',\n                'height': '100%',\n                'xmlns:xlink': ns.xlink\n            },\n            selector: 'svg',\n            style: {\n                position: 'absolute',\n                inset: 0\n            },\n            children: [{\n                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                tagName: 'defs',\n                selector: 'defs'\n            }, {\n                tagName: 'g',\n                className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('layers'),\n                selector: 'layers'\n            }]\n        }];\n    },\n\n    hasLayerView(layerName) {\n        return  (layerName in this._layers);\n    },\n\n    getLayerView(layerName) {\n        const { _layers } = this;\n        if (layerName in _layers) return _layers[layerName];\n        throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n    },\n\n    getLayerNode(layerName) {\n        return this.getLayerView(layerName).el;\n    },\n\n    render: function() {\n\n        this.renderChildren();\n        const { el, childNodes, options, stylesheet } = this;\n        const { svg, defs, layers } = childNodes;\n\n        el.style.position = 'relative';\n        svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\n        this.svg = svg;\n        this.defs = defs;\n        this.layers = layers;\n\n        this.renderLayers();\n\n        _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ensureId(svg);\n\n        this.addStylesheet(stylesheet);\n\n        if (options.background) {\n            this.drawBackground(options.background);\n        }\n\n        if (options.drawGrid) {\n            this.setGrid(options.drawGrid);\n        }\n\n        return this;\n    },\n\n    addStylesheet: function(css) {\n        if (!css) return;\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(this.svg).prepend(_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGStyle(css));\n    },\n\n    createLayer(name) {\n        switch (name) {\n            case _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID:\n                return new _layers_GridLayer_mjs__WEBPACK_IMPORTED_MODULE_13__.GridLayer({ name, paper: this, patterns: this.constructor.gridPatterns });\n            default:\n                return new _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.PaperLayer({ name });\n        }\n    },\n\n    renderLayers: function(layers = defaultLayers) {\n        this.removeLayers();\n        // TODO: Layers to be read from the graph `layers` attribute\n        layers.forEach(({ name, sorted }) => {\n            const layerView = this.createLayer(name);\n            this.layers.appendChild(layerView.el);\n            this._layers[name] = layerView;\n        });\n        // Throws an exception if doesn't exist\n        const cellsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.CELLS);\n        const toolsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.TOOLS);\n        const labelsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.LABELS);\n        // backwards compatibility\n        this.tools = toolsLayerView.el;\n        this.cells = this.viewport = cellsLayerView.el;\n        // user-select: none;\n        cellsLayerView.vel.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('viewport'));\n        labelsLayerView.vel.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('viewport'));\n        cellsLayerView.el.style.webkitUserSelect = 'none';\n        cellsLayerView.el.style.userSelect = 'none';\n        labelsLayerView.el.style.webkitUserSelect = 'none';\n        labelsLayerView.el.style.userSelect = 'none';\n    },\n\n    removeLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].remove();\n            delete _layers[name];\n        });\n    },\n\n    resetLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].removePivots();\n        });\n    },\n\n    update: function() {\n\n        if (this._background) {\n            this.updateBackgroundImage(this._background);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, data) {\n        const ctm = this.matrix();\n        // getter\n        if (sx === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToScale(ctm);\n        }\n        // setter\n        if (sy === undefined) {\n            sy = sx;\n        }\n        sx = Math.max(sx || 0, this.MIN_SCALE);\n        sy = Math.max(sy || 0, this.MIN_SCALE);\n        ctm.a = sx;\n        ctm.d = sy;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    scaleUniformAtPoint: function(scale, point, data) {\n        const { a: sx, d: sy, e: tx, f: ty } = this.matrix();\n        scale = Math.max(scale || 0, this.MIN_SCALE);\n        if (scale === sx && scale === sy) {\n            // The scale is the same as the current one.\n            return this;\n        }\n        const matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix()\n            .translate(\n                tx - point.x * (scale - sx),\n                ty - point.y * (scale - sy)\n            )\n            .scale(scale, scale);\n        this.matrix(matrix, data);\n        return this;\n    },\n\n    translate: function(tx, ty, data) {\n        const ctm = this.matrix();\n        // getter\n        if (tx === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToTranslate(ctm);\n        }\n        // setter\n        tx || (tx = 0);\n        ty || (ty = 0);\n        if (ctm.e === tx && ctm.f === ty) return this;\n        ctm.e = tx;\n        ctm.f = ty;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    matrix: function(ctm, data = {}) {\n\n        var viewport = this.layers;\n\n        // Getter:\n        if (ctm === undefined) {\n\n            var transformString = viewport.getAttribute('transform');\n\n            if ((this._viewportTransformString || null) === transformString) {\n                // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n            } else {\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\n                ctm = viewport.getCTM();\n                this._viewportMatrix = ctm;\n                this._viewportTransformString = transformString;\n            }\n\n            // Clone the cached current transformation matrix.\n            // If no matrix previously stored the identity matrix is returned.\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix(ctm);\n        }\n\n        // Setter:\n        const prev = this.matrix();\n        const current = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix(ctm);\n        const currentTransformString = this._viewportTransformString;\n        const ctmString = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToTransformString(current);\n        if (ctmString === currentTransformString) {\n            // The new transform string is the same as the current one.\n            // No need to update the transform attribute.\n            return this;\n        }\n        if (!currentTransformString && _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToTransformString() === ctmString) {\n            // The current transform string is empty and the new one is an identity matrix.\n            // No need to update the transform attribute.\n            return this;\n        }\n\n        const { a, d, e, f } = current;\n\n        viewport.setAttribute('transform', ctmString);\n        this._viewportMatrix = current;\n        this._viewportTransformString = viewport.getAttribute('transform');\n\n        // scale event\n        if (a !== prev.a || d !== prev.d) {\n            this.trigger('scale', a, d, data);\n        }\n\n        // translate event\n        if (e !== prev.e || f !== prev.f) {\n            this.trigger('translate', e, f, data);\n        }\n\n        this.trigger('transform', current, data);\n        return this;\n    },\n\n    clientMatrix: function() {\n\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix(this.cells.getScreenCTM());\n    },\n\n    requestConnectedLinksUpdate: function(view, priority, opt) {\n        if (view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView) {\n            var model = view.model;\n            var links = this.model.getConnectedLinks(model);\n            for (var j = 0, n = links.length; j < n; j++) {\n                var link = links[j];\n                var linkView = this.findViewByModel(link);\n                if (!linkView) continue;\n                var flagLabels = ['UPDATE'];\n                if (link.getTargetCell() === model) flagLabels.push('TARGET');\n                if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n            }\n        }\n    },\n\n    forcePostponedViewUpdate: function(view, flag) {\n        if (!view || !(view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView)) return false;\n        var model = view.model;\n        if (model.isElement()) return false;\n        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n            var dumpOptions = { silent: true };\n            // LinkView is waiting for the target or the source cellView to be rendered\n            // This can happen when the cells are not in the viewport.\n            var sourceFlag = 0;\n            var sourceView = this.findViewByModel(model.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView, dumpOptions);\n                view.updateEndMagnet('source');\n            }\n            var targetFlag = 0;\n            var targetView = this.findViewByModel(model.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView, dumpOptions);\n                view.updateEndMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n        }\n        return false;\n    },\n\n    requestViewUpdate: function(view, flag, priority, opt) {\n        opt || (opt = {});\n        this.scheduleViewUpdate(view, flag, priority, opt);\n        var isAsync = this.isAsync();\n        if (this.isFrozen() || (isAsync && opt.async !== false)) return;\n        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n        var stats = this.updateViews(opt);\n        if (isAsync) this.notifyAfterRender(stats, opt);\n    },\n\n    scheduleViewUpdate: function(view, type, priority, opt) {\n        const { _updates: updates, options } = this;\n        if (updates.idle) {\n            if (options.autoFreeze) {\n                updates.idle = false;\n                this.unfreeze();\n            }\n        }\n        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;\n        let priorityUpdates = updates.priorities[priority];\n        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n        // Move higher priority updates to this priority\n        if (priority > UPDATE_PRIORITY) {\n            // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n                const prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n        }\n        let currentType = priorityUpdates[cid] || 0;\n        // Prevent cycling\n        if ((currentType & type) === type) return;\n        if (!currentType) updates.count++;\n        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n            // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n            // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n        }\n        priorityUpdates[cid] |= type;\n        const viewUpdateFn = options.onViewUpdate;\n        if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n    },\n\n    dumpViewUpdate: function(view) {\n        if (!view) return 0;\n        var updates = this._updates;\n        var cid = view.cid;\n        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n        delete priorityUpdates[cid];\n        return flag;\n    },\n\n    dumpView: function(view, opt = {}) {\n        const flag = this.dumpViewUpdate(view);\n        if (!flag) return 0;\n        const shouldNotify = !opt.silent;\n        if (shouldNotify) this.notifyBeforeRender(opt);\n        const leftover = this.updateView(view, flag, opt);\n        if (shouldNotify) {\n            const stats = { updated: 1, priority: view.UPDATE_PRIORITY };\n            this.notifyAfterRender(stats, opt);\n        }\n        return leftover;\n    },\n\n    updateView: function(view, flag, opt) {\n        if (!view) return 0;\n        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;\n        if (view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView) {\n            if (flag & FLAG_REMOVE) {\n                this.removeView(model);\n                return 0;\n            }\n            if (flag & FLAG_INSERT) {\n                const isInitialInsert = !!(flag & FLAG_INIT);\n                if (isInitialInsert) {\n                    flag ^= FLAG_INIT;\n                }\n                this.insertView(view, isInitialInsert);\n                flag ^= FLAG_INSERT;\n            }\n        }\n        if (!flag) return 0;\n        return view.confirmUpdate(flag, opt || {});\n    },\n\n    requireView: function(model, opt) {\n        var view = this.findViewByModel(model);\n        if (!view) return null;\n        this.dumpView(view, opt);\n        return view;\n    },\n\n    registerUnmountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.unmounted) return 0;\n        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    },\n\n    registerMountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.mounted) return 0;\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        var flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    },\n\n    isViewMounted: function(view) {\n        if (!view) return false;\n        var cid = view.cid;\n        var updates = this._updates;\n        return (cid in updates.mounted);\n    },\n\n    dumpViews: function(opt) {\n        var passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)({}, opt, { viewport: null });\n        this.checkViewport(passingOpt);\n        this.updateViews(passingOpt);\n    },\n\n    // Synchronous views update\n    updateViews: function(opt) {\n        this.notifyBeforeRender(opt);\n        let batchStats;\n        let updateCount = 0;\n        let batchCount = 0;\n        let priority = MIN_PRIORITY;\n        do {\n            batchCount++;\n            batchStats = this.updateViewsBatch(opt);\n            updateCount += batchStats.updated;\n            priority = Math.min(batchStats.priority, priority);\n        } while (!batchStats.empty);\n        const stats = { updated: updateCount, batches: batchCount, priority };\n        this.notifyAfterRender(stats, opt);\n        return stats;\n    },\n\n    hasScheduledUpdates: function() {\n        const priorities = this._updates.priorities;\n        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        let i = priorityIndexes.length;\n        while (i > 0 && i--) {\n            // a faster way how to check if an object is empty\n            for (let _key in priorities[priorityIndexes[i]]) return true;\n        }\n        return false;\n    },\n\n    updateViewsAsync: function(opt, data) {\n        opt || (opt = {});\n        data || (data = { processed: 0, priority: MIN_PRIORITY });\n        const { _updates: updates, options } = this;\n        const id = updates.id;\n        if (id) {\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cancelFrame)(id);\n            if (data.processed === 0 && this.hasScheduledUpdates()) {\n                this.notifyBeforeRender(opt);\n            }\n            const stats = this.updateViewsBatch(opt);\n            const passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)({}, opt, {\n                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n            });\n            const checkStats = this.checkViewport(passingOpt);\n            const unmountCount = checkStats.unmounted;\n            const mountCount = checkStats.mounted;\n            let processed = data.processed;\n            const total = updates.count;\n            if (stats.updated > 0) {\n                // Some updates have been just processed\n                processed += stats.updated + stats.unmounted;\n                stats.processed = processed;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountCount === 0) {\n                    stats.unmounted += unmountCount;\n                    stats.mounted += mountCount;\n                    stats.priority = data.priority;\n                    this.notifyAfterRender(stats, opt);\n                    data.processed = 0;\n                    data.priority = MIN_PRIORITY;\n                    updates.count = 0;\n                } else {\n                    data.processed = processed;\n                }\n            } else {\n                if (!updates.idle) {\n                    if (options.autoFreeze) {\n                        this.freeze();\n                        updates.idle = true;\n                        this.trigger('render:idle', opt);\n                    }\n                }\n            }\n            // Progress callback\n            const progressFn = opt.progress;\n            if (total && typeof progressFn === 'function') {\n                progressFn.call(this, stats.empty, processed, total, stats, this);\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.id !== id) return;\n        }\n        if (updates.disabled) {\n            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n        }\n        updates.id = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.nextFrame)(this.updateViewsAsync, this, opt, data);\n    },\n\n    notifyBeforeRender: function(opt = {}) {\n        let beforeFn = opt.beforeRender;\n        if (typeof beforeFn !== 'function') {\n            beforeFn = this.options.beforeRender;\n            if (typeof beforeFn !== 'function') return;\n        }\n        beforeFn.call(this, opt, this);\n    },\n\n    notifyAfterRender: function(stats, opt = {}) {\n        let afterFn = opt.afterRender;\n        if (typeof afterFn !== 'function') {\n            afterFn = this.options.afterRender;\n        }\n        if (typeof afterFn === 'function') {\n            afterFn.call(this, stats, opt, this);\n        }\n        this.trigger('render:done', stats, opt);\n    },\n\n    updateViewsBatch: function(opt) {\n        opt || (opt = {});\n        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n        var updates = this._updates;\n        var updateCount = 0;\n        var postponeCount = 0;\n        var unmountCount = 0;\n        var mountCount = 0;\n        var maxPriority = MIN_PRIORITY;\n        var empty = true;\n        var options = this.options;\n        var priorities = updates.priorities;\n        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var postponeViewFn = options.onViewPostponed;\n        if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n            var priority = +priorityIndexes[i];\n            var priorityUpdates = priorities[priority];\n            for (var cid in priorityUpdates) {\n                if (updateCount >= batchSize) {\n                    empty = false;\n                    break main;\n                }\n                var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[cid];\n                if (!view) {\n                    // This should not occur\n                    delete priorityUpdates[cid];\n                    continue;\n                }\n                var currentFlag = priorityUpdates[cid];\n                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                    // We should never check a view for viewport if we are about to remove the view\n                    var isDetached = cid in updates.unmounted;\n                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                        // Unmount View\n                        if (!isDetached) {\n                            this.registerUnmountedView(view);\n                            this.detachView(view);\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete priorityUpdates[cid];\n                        unmountCount++;\n                        continue;\n                    }\n                    // Mount View\n                    if (isDetached) {\n                        currentFlag |= view.FLAG_INSERT;\n                        mountCount++;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                var leftoverFlag = this.updateView(view, currentFlag, opt);\n                if (leftoverFlag > 0) {\n                    // View update has not finished completely\n                    priorityUpdates[cid] = leftoverFlag;\n                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                        postponeCount++;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (maxPriority > priority) maxPriority = priority;\n                updateCount++;\n                delete priorityUpdates[cid];\n            }\n        }\n        return {\n            priority: maxPriority,\n            updated: updateCount,\n            postponed: postponeCount,\n            unmounted: unmountCount,\n            mounted: mountCount,\n            empty: empty\n        };\n    },\n\n    getUnmountedViews: function() {\n        const updates = this._updates;\n        const unmountedCids = Object.keys(updates.unmounted);\n        const n = unmountedCids.length;\n        const unmountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            unmountedViews[i] = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[unmountedCids[i]];\n        }\n        return unmountedViews;\n    },\n\n    getMountedViews: function() {\n        const updates = this._updates;\n        const mountedCids = Object.keys(updates.mounted);\n        const n = mountedCids.length;\n        const mountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            mountedViews[i] = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[mountedCids[i]];\n        }\n        return mountedViews;\n    },\n\n    checkUnmountedViews: function(viewportFn, opt) {\n        opt || (opt  = {});\n        var mountCount = 0;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n        var updates = this._updates;\n        var unmountedCids = updates.unmountedCids;\n        var unmounted = updates.unmounted;\n        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n            var cid = unmountedCids[i];\n            if (!(cid in unmounted)) continue;\n            var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[cid];\n            if (!view) continue;\n            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                // Push at the end of all unmounted ids, so this can be check later again\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount++;\n            var flag = this.registerMountedView(view);\n            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true });\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, i);\n        return mountCount;\n    },\n\n    checkMountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var unmountCount = 0;\n        if (typeof viewportFn !== 'function') return unmountCount;\n        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n        var updates = this._updates;\n        var mountedCids = updates.mountedCids;\n        var mounted = updates.mounted;\n        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n            var cid = mountedCids[i];\n            if (!(cid in mounted)) continue;\n            var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[cid];\n            if (!view) continue;\n            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                // Push at the end of all mounted ids, so this can be check later again\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount++;\n            var flag = this.registerUnmountedView(view);\n            if (flag) this.detachView(view);\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, i);\n        return unmountCount;\n    },\n\n    checkViewVisibility: function(cellView, opt = {}) {\n        let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        const updates = this._updates;\n        const { mounted, unmounted } = updates;\n        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n\n        let isUnmounted = false;\n        let isMounted = false;\n\n        if (cellView.cid in mounted && !visible) {\n            const flag = this.registerUnmountedView(cellView);\n            if (flag) this.detachView(cellView);\n            const i = updates.mountedCids.indexOf(cellView.cid);\n            updates.mountedCids.splice(i, 1);\n            isUnmounted = true;\n        }\n\n        if (!isUnmounted && cellView.cid in unmounted && visible) {\n            const i = updates.unmountedCids.indexOf(cellView.cid);\n            updates.unmountedCids.splice(i, 1);\n            var flag = this.registerMountedView(cellView);\n            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, { mounting: true });\n            isMounted = true;\n        }\n\n        return {\n            mounted: isMounted ? 1 : 0,\n            unmounted: isUnmounted ? 1 : 0\n        };\n    },\n\n    checkViewport: function(opt) {\n        var passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)({}, opt, {\n            mountBatchSize: Infinity,\n            unmountBatchSize: Infinity\n        });\n        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n        if (unmountedCount > 0) {\n            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n            var unmountedCids = this._updates.unmountedCids;\n            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n        }\n        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n        return {\n            mounted: mountedCount,\n            unmounted: unmountedCount\n        };\n    },\n\n    freeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var isFrozen = this.options.frozen;\n        var freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey)  {\n            // key passed, but the paper is already freezed with another key\n            if (isFrozen && freezeKey) return;\n            updates.freezeKey = key;\n            updates.keyFrozen = isFrozen;\n        }\n        this.options.frozen = true;\n        var id = updates.id;\n        updates.id = null;\n        if (this.isAsync() && id) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cancelFrame)(id);\n    },\n\n    unfreeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var freezeKey = updates.freezeKey;\n        // key passed, but the paper is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) return;\n        updates.freezeKey = null;\n        // key passed, but the paper is already freezed\n        if (key && key === freezeKey && updates.keyFrozen) return;\n        if (this.isAsync()) {\n            this.freeze();\n            this.updateViewsAsync(opt);\n        } else {\n            this.updateViews(opt);\n        }\n        this.options.frozen = updates.keyFrozen = false;\n        if (updates.sort) {\n            this.sortViews();\n            updates.sort = false;\n        }\n    },\n\n    isAsync: function() {\n        return !!this.options.async;\n    },\n\n    isFrozen: function() {\n        return !!this.options.frozen;\n    },\n\n    isExactSorting: function() {\n        return this.options.sorting === sortingTypes.EXACT;\n    },\n\n    onRemove: function() {\n\n        this.freeze();\n        this._updates.disabled = true;\n        //clean up all DOM elements/views to prevent memory leaks\n        this.removeLayers();\n        this.removeViews();\n    },\n\n    getComputedSize: function() {\n\n        var options = this.options;\n        var w = options.width;\n        var h = options.height;\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(w)) w = this.el.clientWidth;\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(h)) h = this.el.clientHeight;\n        return { width: w, height: h };\n    },\n\n    setDimensions: function(width, height, data = {}) {\n        const { options } = this;\n        const { width: currentWidth, height: currentHeight } = options;\n        let w = (width === undefined) ? currentWidth : width;\n        let h = (height === undefined) ? currentHeight : height;\n        if (currentWidth === w && currentHeight === h) return;\n        options.width = w;\n        options.height = h;\n        this._setDimensions();\n        const computedSize = this.getComputedSize();\n        this.trigger('resize', computedSize.width, computedSize.height, data);\n    },\n\n    _setDimensions: function() {\n        const { options } = this;\n        let w = options.width;\n        let h = options.height;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(w)) w = `${Math.round(w)}px`;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(h)) h = `${Math.round(h)}px`;\n        this.$el.css({\n            width: (w === null) ? '' : w,\n            height: (h === null) ? '' : h\n        });\n    },\n\n    // Expand/shrink the paper to fit the content.\n    // Alternatively signature function(opt)\n    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(gridWidth)) {\n            // first parameter is an option object\n            opt = gridWidth;\n        } else {\n            // Support for a deprecated signature\n            opt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.assign)({ gridWidth, gridHeight, padding }, opt);\n        }\n\n        const { x, y, width, height } = this.getFitToContentArea(opt);\n        const { sx, sy } = this.scale();\n\n        this.translate(-x * sx, -y * sy, opt);\n        this.setDimensions(width * sx, height * sy, opt);\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n    },\n\n    getFitToContentArea: function(opt = {}) {\n\n        // Calculate the paper size to accommodate all the graph's elements.\n\n        const gridWidth = opt.gridWidth || 1;\n        const gridHeight = opt.gridHeight || 1;\n        const padding = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeSides)(opt.padding || 0);\n\n        const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n        const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n        const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n        const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n        const newOrigin = opt.allowNewOrigin;\n\n        const area = ('contentArea' in opt) ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(opt.contentArea) : this.getContentArea(opt);\n        const { sx, sy } = this.scale();\n        area.x *= sx;\n        area.y *= sy;\n        area.width *= sx;\n        area.height *= sy;\n\n        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n        if (!opt.allowNegativeBottomRight) {\n            calcWidth = Math.max(calcWidth, 1);\n            calcHeight = Math.max(calcHeight, 1);\n        }\n        calcWidth *= gridWidth;\n        calcHeight *= gridHeight;\n\n        let tx = 0;\n        if ((newOrigin === 'negative' && area.x < 0) || (newOrigin === 'positive' && area.x >= 0) || newOrigin === 'any') {\n            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n            tx += padding.left;\n            calcWidth += tx;\n        }\n\n        let ty = 0;\n        if ((newOrigin === 'negative' && area.y < 0) || (newOrigin === 'positive' && area.y >= 0) || newOrigin === 'any') {\n            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n            ty += padding.top;\n            calcHeight += ty;\n        }\n\n        calcWidth += padding.right;\n        calcHeight += padding.bottom;\n\n        // Make sure the resulting width and height are greater than minimum.\n        calcWidth = Math.max(calcWidth, minWidth);\n        calcHeight = Math.max(calcHeight, minHeight);\n\n        // Make sure the resulting width and height are lesser than maximum.\n        calcWidth = Math.min(calcWidth, maxWidth);\n        calcHeight = Math.min(calcHeight, maxHeight);\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n    },\n\n    transformToFitContent: function(opt) {\n        opt || (opt = {});\n\n        let contentBBox, contentLocalOrigin;\n        if ('contentArea' in opt) {\n            const contentArea = opt.contentArea;\n            contentBBox = this.localToPaperRect(contentArea);\n            contentLocalOrigin = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(contentArea);\n        } else {\n            contentBBox = this.getContentBBox(opt);\n            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n        }\n\n        if (!contentBBox.width || !contentBBox.height) return;\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)(opt, {\n            padding: 0,\n            preserveAspectRatio: true,\n            scaleGrid: null,\n            minScale: 0,\n            maxScale: Number.MAX_VALUE,\n            verticalAlign: 'top',\n            horizontalAlign: 'left',\n            //minScaleX\n            //minScaleY\n            //maxScaleX\n            //maxScaleY\n            //fittingBBox\n        });\n\n        const padding = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeSides)(opt.padding);\n\n        const minScaleX = opt.minScaleX || opt.minScale;\n        const maxScaleX = opt.maxScaleX || opt.maxScale;\n        const minScaleY = opt.minScaleY || opt.minScale;\n        const maxScaleY = opt.maxScaleY || opt.maxScale;\n\n        let fittingBBox;\n        if (opt.fittingBBox) {\n            fittingBBox = opt.fittingBBox;\n        } else {\n            const currentTranslate = this.translate();\n            const computedSize = this.getComputedSize();\n            fittingBBox = {\n                x: currentTranslate.tx,\n                y: currentTranslate.ty,\n                width: computedSize.width,\n                height: computedSize.height\n            };\n        }\n\n        fittingBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(fittingBBox).moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.left - padding.right,\n            height: -padding.top - padding.bottom\n        });\n\n        const ctm = this.matrix();\n        const { a: sx, d: sy, e: tx, f: ty } = ctm;\n\n        let newSx = fittingBBox.width / contentBBox.width * sx;\n        let newSy = fittingBBox.height / contentBBox.height * sy;\n\n        if (opt.preserveAspectRatio) {\n            newSx = newSy = Math.min(newSx, newSy);\n        }\n\n        // snap scale to a grid\n        if (opt.scaleGrid) {\n\n            const gridSize = opt.scaleGrid;\n\n            newSx = gridSize * Math.floor(newSx / gridSize);\n            newSy = gridSize * Math.floor(newSy / gridSize);\n        }\n\n        // scale min/max boundaries\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n        const scaleDiff = {\n            x: newSx / sx,\n            y: newSy / sy\n        };\n\n        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n\n        switch (opt.verticalAlign) {\n            case 'middle':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                break;\n            case 'bottom':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                break;\n            case 'top':\n            default:\n                break;\n        }\n\n        switch (opt.horizontalAlign) {\n            case 'middle':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                break;\n            case 'right':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                break;\n            case 'left':\n            default:\n                break;\n        }\n\n        ctm.a = newSx;\n        ctm.d = newSy;\n        ctm.e = newOx;\n        ctm.f = newOy;\n        this.matrix(ctm, opt);\n    },\n\n    scaleContentToFit: function(opt) {\n        this.transformToFitContent(opt);\n    },\n\n    // Return the dimensions of the content area in local units (without transformations).\n    getContentArea: function(opt) {\n\n        if (opt && opt.useModelGeometry) {\n            return this.model.getBBox() || new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect();\n        }\n\n        return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(this.cells).getBBox();\n    },\n\n    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n    getContentBBox: function(opt) {\n\n        return this.localToPaperRect(this.getContentArea(opt));\n    },\n\n    // Returns a geometry rectangle representing the entire\n    // paper area (coordinates from the left paper border to the right one\n    // and the top border to the bottom one).\n    getArea: function() {\n\n        return this.paperToLocalRect(this.getComputedSize());\n    },\n\n    getRestrictedArea: function(...args) {\n\n        const { restrictTranslate } = this.options;\n\n        let restrictedArea;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(restrictTranslate)) {\n            // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n        } else if (restrictTranslate === true) {\n            // The paper area\n            restrictedArea = this.getArea();\n        } else if (!restrictTranslate) {\n            // falsy value\n            restrictedArea = null;\n        } else {\n            // any other value\n            restrictedArea = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(restrictTranslate);\n        }\n\n        return restrictedArea;\n    },\n\n    createViewForModel: function(cell) {\n\n        const { options } = this;\n        // A class taken from the paper options.\n        var optionalViewClass;\n\n        // A default basic class (either dia.ElementView or dia.LinkView)\n        var defaultViewClass;\n\n        // A special class defined for this model in the corresponding namespace.\n        // e.g. joint.shapes.standard.Rectangle searches for joint.shapes.standard.RectangleView\n        var namespace = options.cellViewNamespace;\n        var type = cell.get('type') + 'View';\n        var namespaceViewClass = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.getByPath)(namespace, type, '.');\n\n        if (cell.isLink()) {\n            optionalViewClass = options.linkView;\n            defaultViewClass = _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__.LinkView;\n        } else {\n            optionalViewClass = options.elementView;\n            defaultViewClass = _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__.ElementView;\n        }\n\n        // a) the paper options view is a class (deprecated)\n        //  1. search the namespace for a view\n        //  2. if no view was found, use view from the paper options\n        // b) the paper options view is a function\n        //  1. call the function from the paper options\n        //  2. if no view was return, search the namespace for a view\n        //  3. if no view was found, use the default\n        var ViewClass = (optionalViewClass.prototype instanceof _mvc_ViewBase_mjs__WEBPACK_IMPORTED_MODULE_16__.ViewBase)\n            ? namespaceViewClass || optionalViewClass\n            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n        return new ViewClass({\n            model: cell,\n            interactive: options.interactive,\n            labelsLayer: options.labelsLayer === true ? _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.LABELS : options.labelsLayer\n        });\n    },\n\n    removeView: function(cell) {\n\n        const { id } = cell;\n        const { _views, _updates } = this;\n        const view = _views[id];\n        if (view) {\n            var { cid } = view;\n            const { mounted, unmounted } = _updates;\n            view.remove();\n            delete _views[id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    },\n\n    renderView: function(cell, opt) {\n\n        const { id } = cell;\n        const views = this._views;\n        let view, flag;\n        let create = true;\n        if (id in views) {\n            view = views[id];\n            if (view.model === cell) {\n                flag = view.FLAG_INSERT;\n                create = false;\n            } else {\n                // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n        }\n        if (create) {\n            view = views[id] = this.createViewForModel(cell);\n            view.paper = this;\n            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.result)(view, 'initFlag'));\n        }\n        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n        return view;\n    },\n\n    onImageDragStart: function() {\n        // This is the only way to prevent image dragging in Firefox that works.\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n        return false;\n    },\n\n    resetViews: function(cells, opt) {\n        opt || (opt = {});\n        cells || (cells = []);\n        this._resetUpdates();\n        // clearing views removes any event listeners\n        this.removeViews();\n        // Allows to unfreeze normally while in the idle state using autoFreeze option\n        const key = this.options.autoFreeze ? null : 'reset';\n        this.freeze({ key });\n        for (var i = 0, n = cells.length; i < n; i++) {\n            this.renderView(cells[i], opt);\n        }\n        this.unfreeze({ key });\n        this.sortViews();\n    },\n\n    removeViews: function() {\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.invoke)(this._views, 'remove');\n\n        this._views = {};\n    },\n\n    sortViews: function() {\n\n        if (!this.isExactSorting()) {\n            // noop\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this._updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    },\n\n    sortViewsExact: function() {\n\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n        // associated model `z` attribute.\n\n        var cellNodes = Array.from(this.cells.childNodes).filter(node => node.getAttribute('model-id'));\n        var cells = this.model.get('cells');\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.sortElements)(cellNodes, function(a, b) {\n            var cellA = cells.get(a.getAttribute('model-id'));\n            var cellB = cells.get(b.getAttribute('model-id'));\n            var zA = cellA.attributes.z || 0;\n            var zB = cellB.attributes.z || 0;\n            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n        });\n    },\n\n    insertView: function(view, isInitialInsert) {\n        const layerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.CELLS);\n        const { el, model } = view;\n        switch (this.options.sorting) {\n            case sortingTypes.APPROX:\n                layerView.insertSortedNode(el, model.get('z'));\n                break;\n            case sortingTypes.EXACT:\n            default:\n                layerView.insertNode(el);\n                break;\n        }\n        view.onMount(isInitialInsert);\n    },\n\n    detachView(view) {\n        view.unmount();\n        view.onDetach();\n    },\n\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n    // be a selector or a jQuery object.\n    findView: function($el) {\n\n        var el = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isString)($el)\n            ? this.cells.querySelector($el)\n            : $el instanceof _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"] ? $el[0] : $el;\n\n        var id = this.findAttribute('model-id', el);\n        if (id) return this._views[id];\n\n        return undefined;\n    },\n\n    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n    findViewByModel: function(cell) {\n\n        var id = ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isString)(cell) || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(cell)) ? cell : (cell && cell.id);\n\n        return this._views[id];\n    },\n\n    // Find all views at given point\n    findViewsFromPoint: function(p) {\n\n        p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(p);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n\n        return views.filter(function(view) {\n            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n        }, this);\n    },\n\n    // Find all views in given area\n    findViewsInArea: function(rect, opt) {\n\n        opt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)(opt || {}, { strict: false });\n        rect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(rect);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        var method = opt.strict ? 'containsRect' : 'intersect';\n\n        return views.filter(function(view) {\n            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n        }, this);\n    },\n\n    findElementViewsInArea(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findLinkViewsInArea: function(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findCellViewsInArea: function(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findElementViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            (extArea) => this.model.findElementsInArea(extArea),\n            opt\n        );\n    },\n\n    findLinkViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            (extArea) => this.model.findLinksInArea(extArea),\n            opt,\n        );\n    },\n\n    findCellViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            // Note: we do not want to pass `opt` to `findCellsInArea`\n            // because the `strict` option works differently for querying at a point\n            (extArea) => this.model.findCellsInArea(extArea),\n            opt\n        );\n    },\n\n    _findInExtendedArea: function(area, findCellsFn, opt = {}) {\n        const {\n            buffer = this.DEFAULT_FIND_BUFFER,\n        } = opt;\n        const extendedArea = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(area)).inflate(buffer);\n        const cellsInExtendedArea = findCellsFn(extendedArea, opt);\n        return cellsInExtendedArea.map(element => this.findViewByModel(element));\n    },\n\n    _filterViewsInArea: function(plainArea, findCells, opt = {}) {\n        const area = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(plainArea);\n        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n        const viewsInArea = viewsInExtendedArea.filter(view => {\n            if (!view) return false;\n            return view.isInArea(area, opt);\n        });\n        return viewsInArea;\n    },\n\n    _filterViewsAtPoint: function(plainPoint, findCells, opt = {}) {\n        const area = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(plainPoint); // zero-size area\n        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n        const viewsAtPoint = viewsInExtendedArea.filter(view => {\n            if (!view) return false;\n            return view.isAtPoint(plainPoint, opt);\n        });\n        return viewsAtPoint;\n    },\n\n    removeTools: function() {\n        this.dispatchToolsEvent('remove');\n        return this;\n    },\n\n    hideTools: function() {\n        this.dispatchToolsEvent('hide');\n        return this;\n    },\n\n    showTools: function() {\n        this.dispatchToolsEvent('show');\n        return this;\n    },\n\n    dispatchToolsEvent: function(event, ...args) {\n        if (typeof event !== 'string') return;\n        this.trigger('tools:event', event, ...args);\n    },\n\n\n    getModelById: function(id) {\n\n        return this.model.getCell(id);\n    },\n\n    snapToGrid: function(x, y) {\n\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n    },\n\n    localToPaperPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var paperPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(localPoint, this.matrix());\n        return paperPoint;\n    },\n\n    localToPaperRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var localRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var paperRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(localRect, this.matrix());\n        return paperRect;\n    },\n\n    paperToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var paperPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var localPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(paperPoint, this.matrix().inverse());\n        return localPoint;\n    },\n\n    paperToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var paperRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var localRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(paperRect, this.matrix().inverse());\n        return localRect;\n    },\n\n    localToClientPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var clientPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(localPoint, this.clientMatrix());\n        return clientPoint;\n    },\n\n    localToClientRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var localRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var clientRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(localRect, this.clientMatrix());\n        return clientRect;\n    },\n\n    // Transform client coordinates to the paper local coordinates.\n    // Useful when you have a mouse event object and you'd like to get coordinates\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n    clientToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var clientPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var localPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(clientPoint, this.clientMatrix().inverse());\n        return localPoint;\n    },\n\n    clientToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var clientRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var localRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(clientRect, this.clientMatrix().inverse());\n        return localRect;\n    },\n\n    localToPagePoint: function(x, y) {\n\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n    },\n\n    localToPageRect: function(x, y, width, height) {\n\n        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n    },\n\n    pageToLocalPoint: function(x, y) {\n\n        var pagePoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var paperPoint = pagePoint.difference(this.pageOffset());\n        return this.paperToLocalPoint(paperPoint);\n    },\n\n    pageToLocalRect: function(x, y, width, height) {\n\n        var pageOffset = this.pageOffset();\n        var paperRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        paperRect.x -= pageOffset.x;\n        paperRect.y -= pageOffset.y;\n        return this.paperToLocalRect(paperRect);\n    },\n\n    clientOffset: function() {\n\n        var clientRect = this.svg.getBoundingClientRect();\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(clientRect.left, clientRect.top);\n    },\n\n    pageOffset: function() {\n\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n\n    linkAllowed: function(linkView) {\n\n        if (!(linkView instanceof _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__.LinkView)) {\n            throw new Error('Must provide a linkView.');\n        }\n\n        var link = linkView.model;\n        var paperOptions = this.options;\n        var graph = this.model;\n        var ns = graph.constructor.validations;\n\n        if (!paperOptions.multiLinks) {\n            if (!ns.multiLinks.call(this, graph, link)) return false;\n        }\n\n        if (!paperOptions.linkPinning) {\n            // Link pinning is not allowed and the link is not connected to the target.\n            if (!ns.linkPinning.call(this, graph, link)) return false;\n        }\n\n        if (typeof paperOptions.allowLink === 'function') {\n            if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n        }\n\n        return true;\n    },\n\n    getDefaultLink: function(cellView, magnet) {\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(this.options.defaultLink)\n        // default link is a function producing link model\n            ? this.options.defaultLink.call(this, cellView, magnet)\n        // default link is the mvc model\n            : this.options.defaultLink.clone();\n    },\n\n    // Cell highlighting.\n    // ------------------\n\n    resolveHighlighter: function(opt = {}) {\n\n        let { highlighter: highlighterDef, type } = opt;\n        const { highlighting,highlighterNamespace  } = this.options;\n\n        /*\n            Expecting opt.highlighter to have the following structure:\n            {\n                name: 'highlighter-name',\n                options: {\n                    some: 'value'\n                }\n            }\n        */\n        if (highlighterDef === undefined) {\n\n            // Is highlighting disabled?\n            if (!highlighting) return false;\n            // check for built-in types\n            if (type) {\n                highlighterDef = highlighting[type];\n                // Is a specific type highlight disabled?\n                if (highlighterDef === false) return false;\n            }\n            if (!highlighterDef) {\n                // Type not defined use default highlight\n                highlighterDef = highlighting['default'];\n            }\n        }\n\n        // Do nothing if opt.highlighter is falsy.\n        // This allows the case to not highlight cell(s) in certain cases.\n        // For example, if you want to NOT highlight when embedding elements\n        // or use a custom highlighter.\n        if (!highlighterDef) return false;\n\n        // Allow specifying a highlighter by name.\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isString)(highlighterDef)) {\n            highlighterDef = {\n                name: highlighterDef\n            };\n        }\n\n        const name = highlighterDef.name;\n        const highlighter = highlighterNamespace[name];\n\n        // Highlighter validation\n        if (!highlighter) {\n            throw new Error('Unknown highlighter (\"' + name + '\")');\n        }\n        if (typeof highlighter.highlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n        }\n        if (typeof highlighter.unhighlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n        }\n\n        return {\n            highlighter,\n            options: highlighterDef.options || {},\n            name\n        };\n    },\n\n    onCellHighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.highlight(cellView, magnetEl, options);\n    },\n\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.unhighlight(cellView, magnetEl, options);\n    },\n\n    // Interaction.\n    // ------------\n\n    pointerdblclick: function(evt) {\n\n        evt.preventDefault();\n\n        // magnetpointerdblclick can stop propagation\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerclick: function(evt) {\n\n        // magnetpointerclick can stop propagation\n\n        var data = this.eventData(evt);\n        // Trigger event only if mouse has not moved.\n        if (data.mousemoved <= this.options.clickThreshold) {\n\n            evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n            if (view) {\n                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n            } else {\n                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    contextmenu: function(evt) {\n\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.contextMenuFired) {\n            this.contextMenuFired = false;\n            return;\n        }\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        this.contextMenuTrigger(evt);\n    },\n\n    contextMenuTrigger: function(evt) {\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerdown: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const { target, button } = evt;\n        const view = this.findView(target);\n        const isContextMenu = (button === 2);\n\n        if (view) {\n\n            if (!isContextMenu && this.guard(evt, view)) return;\n\n            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\n            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n                // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n            }\n\n            if (isTargetFormNode) {\n                // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n            }\n\n            // Custom event\n            const eventEvt = this.customEventTrigger(evt, view);\n            if (eventEvt) {\n            // `onevent` could have stopped propagation\n                if (eventEvt.isPropagationStopped()) return;\n\n                evt.data = eventEvt.data;\n            }\n\n            // Element magnet\n            const magnetNode = target.closest('[magnet]');\n            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                const magnetEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the magnet element.\n                    currentTarget: magnetNode\n                }));\n                this.onmagnet(magnetEvt);\n                if (magnetEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                if (magnetEvt.isPropagationStopped()) {\n                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                    if (isContextMenu) return;\n                    this.delegateDragEvents(view, magnetEvt.data);\n                    return;\n                }\n                evt.data = magnetEvt.data;\n            }\n        }\n\n        if (isContextMenu) {\n            this.contextMenuFired = true;\n            const contextmenuEvt = new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, { type: 'contextmenu', data: evt.data });\n            this.contextMenuTrigger(contextmenuEvt);\n        } else {\n            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerdown(evt, localPoint.x, localPoint.y);\n            } else {\n                if (this.options.preventDefaultBlankAction) {\n                    evt.preventDefault();\n                }\n                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n            }\n\n            this.delegateDragEvents(view, evt.data);\n        }\n\n    },\n\n    pointermove: function(evt) {\n\n        // mouse moved counter\n        var data = this.eventData(evt);\n        if (!data.mousemoved) {\n            data.mousemoved = 0;\n            // Make sure that events like `mouseenter` and `mouseleave` are\n            // not triggered while the user is dragging a cellView.\n            this.undelegateEvents();\n            // Note: the events are undelegated after the first `pointermove` event.\n            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n        }\n\n        var mousemoved = ++data.mousemoved;\n\n        if (mousemoved <= this.options.moveThreshold) return;\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        var view = data.sourceView;\n        if (view) {\n            view.pointermove(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n        }\n\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt) {\n\n        this.undelegateDocumentEvents();\n\n        var normalizedEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n        var view = this.eventData(evt).sourceView;\n        if (view) {\n            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n        }\n\n        if (!normalizedEvt.isPropagationStopped()) {\n            this.pointerclick(new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, { type: 'click', data: evt.data }));\n        }\n\n        this.delegateEvents();\n    },\n\n    mouseover: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseover(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseover', evt);\n        }\n    },\n\n    mouseout: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseout(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseout', evt);\n        }\n    },\n\n    mouseenter: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const {\n            target, // The EventTarget the pointing device entered to\n            relatedTarget, // The EventTarget the pointing device exited from\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse left a cell tool\n                return;\n            }\n            view.mouseenter(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer remains inside the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            return;\n        }\n        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n        // (mouseenter method would be fired twice)\n        if (currentTarget === this.el) {\n            // `paper` (more descriptive), not `blank`\n            this.trigger('paper:mouseenter', evt);\n        }\n    },\n\n    mouseleave: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const {\n            target, // The EventTarget the pointing device exited from\n            relatedTarget, // The EventTarget the pointing device entered to\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse entered a cell tool\n                return;\n            }\n            view.mouseleave(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            // The pointer has entered a new cellView\n            return;\n        }\n        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n        // (mouseleave method would be fired twice)\n        if (currentTarget === this.el) {\n            // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger('paper:mouseleave', evt);\n        }\n    },\n\n    _processMouseWheelEvtBuf: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.debounce)(function() {\n        const { event, deltas } = this._mw_evt_buffer;\n        const deltaY = deltas.reduce((acc, deltaY) => acc + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cap)(deltaY, WHEEL_CAP), 0);\n\n        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);\n        this.trigger('paper:pinch', event, x, y, scale);\n\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n    }, WHEEL_WAIT_MS, { maxWait: WHEEL_WAIT_MS }),\n\n    mousewheel: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        const originalEvent = evt.originalEvent;\n        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n        const { deltaX, deltaY } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeWheel)(originalEvent);\n\n        const pinchHandlers = this._events['paper:pinch'];\n\n        // Touchpad devices will send a fake CTRL press when a pinch is performed\n        //\n        // We also check if there are any subscribers to paper:pinch event. If there are none,\n        // just skip the entire block of code (we don't want to blindly call\n        // .preventDefault() if we really don't have to).\n        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n            originalEvent.preventDefault();\n            this._mw_evt_buffer.event = evt;\n            this._mw_evt_buffer.deltas.push(deltaY);\n            this._processMouseWheelEvtBuf();\n        } else {\n            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n            if (view) {\n                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n            } else {\n                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n            }\n\n            this.trigger('paper:pan', evt, deltaX, deltaY);\n        }\n    },\n\n    onevent: function(evt) {\n\n        var eventNode = evt.currentTarget;\n        var eventName = eventNode.getAttribute('event');\n        if (eventName) {\n            var view = this.findView(eventNode);\n            if (view) {\n\n                evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n                if (this.guard(evt, view)) return;\n\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    magnetEvent: function(evt, handler) {\n\n        var magnetNode = evt.currentTarget;\n        var magnetValue = magnetNode.getAttribute('magnet');\n        if (magnetValue) {\n            var view = this.findView(magnetNode);\n            if (view) {\n                evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    onmagnet: function(evt) {\n\n        if (evt.button === 2) {\n            this.contextMenuFired = true;\n            this.magnetContextMenuFired = true;\n            const contextmenuEvt = new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, {\n                type: 'contextmenu',\n                data: evt.data,\n                currentTarget: evt.currentTarget,\n            });\n            this.magnetContextMenuTrigger(contextmenuEvt);\n            if (contextmenuEvt.isPropagationStopped()) {\n                evt.stopPropagation();\n            }\n        } else {\n            this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        }\n    },\n\n    magnetpointerdblclick: function(evt) {\n\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetpointerdblclick(evt, magnet, x, y);\n        });\n    },\n\n    magnetcontextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.magnetContextMenuFired) {\n            this.magnetContextMenuFired = false;\n            return;\n        }\n\n        this.magnetContextMenuTrigger(evt);\n    },\n\n    magnetContextMenuTrigger: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetcontextmenu(evt, magnet, x, y);\n        });\n    },\n\n    onlabel: function(evt) {\n\n        var labelNode = evt.currentTarget;\n\n        var view = this.findView(labelNode);\n        if (!view) return;\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n        if (this.guard(evt, view)) return;\n\n        // Custom event\n        const eventEvt = this.customEventTrigger(evt, view, labelNode);\n        if (eventEvt) {\n            // `onevent` could have stopped propagation\n            if (eventEvt.isPropagationStopped()) return;\n\n            evt.data = eventEvt.data;\n        }\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onlabel(evt, localPoint.x, localPoint.y);\n    },\n\n    getPointerArgs(evt) {\n        const normalizedEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        return [normalizedEvt, x, y];\n    },\n\n    delegateDragEvents: function(view, data) {\n\n        data || (data = {});\n        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n        this.delegateDocumentEvents(null, data);\n    },\n\n    // Guard the specified event. If the event should be ignored, guard returns `true`.\n    // Otherwise, it returns `false`.\n    guard: function(evt, view) {\n\n        if (evt.type === 'mousedown' && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n\n        const { target } = evt;\n\n        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n            return true;\n        }\n\n        if (view && view.model && (view.model instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_18__.Cell)) {\n            return false;\n        }\n\n        if (this.el === target || this.svg.contains(target)) {\n            return false;\n        }\n\n        return true;    // Event guarded. Paper should not react on it in any way.\n    },\n\n    setGridSize: function(gridSize) {\n        const { options } = this;\n        options.gridSize = gridSize;\n        if (options.drawGrid && !options.drawGridSize) {\n            // Do not redraw the grid if the `drawGridSize` is set.\n            this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID).renderGrid();\n        }\n        return this;\n    },\n\n    setGrid: function(drawGrid) {\n        this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID).setGrid(drawGrid);\n        return this;\n    },\n\n    updateBackgroundImage: function(opt) {\n\n        opt = opt || {};\n\n        var backgroundPosition = opt.position || 'center';\n        var backgroundSize = opt.size || 'auto auto';\n\n        var currentScale = this.scale();\n        var currentTranslate = this.translate();\n\n        // backgroundPosition\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(backgroundPosition)) {\n            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n            backgroundPosition = x + 'px ' + y + 'px';\n        }\n\n        // backgroundSize\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(backgroundSize)) {\n            backgroundSize = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n        }\n\n        const { background } = this.childNodes;\n        background.style.backgroundSize = backgroundSize;\n        background.style.backgroundPosition = backgroundPosition;\n    },\n\n    drawBackgroundImage: function(img, opt) {\n\n        // Clear the background image if no image provided\n        if (!(img instanceof HTMLImageElement)) {\n            this.childNodes.background.style.backgroundImage = '';\n            return;\n        }\n\n        if (!this._background || this._background.id !== opt.id) {\n            // Draw only the last image requested (see drawBackground())\n            return;\n        }\n\n        opt = opt || {};\n\n        var backgroundImage;\n        var backgroundSize = opt.size;\n        var backgroundRepeat = opt.repeat || 'no-repeat';\n        var backgroundOpacity = opt.opacity || 1;\n        var backgroundQuality = Math.abs(opt.quality) || 1;\n        var backgroundPattern = this.constructor.backgroundPatterns[(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.camelCase)(backgroundRepeat)];\n\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(backgroundPattern)) {\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n            img.width *= backgroundQuality;\n            img.height *= backgroundQuality;\n            var canvas = backgroundPattern(img, opt);\n            if (!(canvas instanceof HTMLCanvasElement)) {\n                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n            }\n\n            backgroundImage = canvas.toDataURL('image/png');\n            backgroundRepeat = 'repeat';\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(backgroundSize)) {\n                // recalculate the tile size if an object passed in\n                backgroundSize.width *= canvas.width / img.width;\n                backgroundSize.height *= canvas.height / img.height;\n            } else if (backgroundSize === undefined) {\n                // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            }\n        } else {\n            // backgroundRepeat:\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n            backgroundImage = img.src;\n            if (backgroundSize === undefined) {\n                // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n        }\n\n        this.childNodes.background.style.opacity = backgroundOpacity;\n        this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n        this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n\n        this.updateBackgroundImage(opt);\n    },\n\n    updateBackgroundColor: function(color) {\n\n        this.$el.css('backgroundColor', color || '');\n    },\n\n    drawBackground: function(opt) {\n\n        opt = opt || {};\n\n        this.updateBackgroundColor(opt.color);\n\n        if (opt.image) {\n            opt = this._background = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(opt);\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.guid)(opt);\n            var img = document.createElement('img');\n            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n            img.src = opt.image;\n        } else {\n            this.drawBackgroundImage(null);\n            this._background = null;\n        }\n\n        return this;\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.invoke)(this._views, 'setInteractivity', value);\n    },\n\n    // Paper definitions.\n    // ------------------\n\n    isDefined: function(defId) {\n\n        return !!this.svg.getElementById(defId);\n    },\n\n    defineFilter: function(filter) {\n\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(filter)) {\n            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n        }\n\n        var filterId = filter.id;\n        var name = filter.name;\n        // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        if (!filterId) {\n            filterId = name + this.svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(filter));\n        }\n        // If the filter already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        // If not, create one.\n        if (!this.isDefined(filterId)) {\n\n            var namespace = _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.filter;\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n            if (!filterSVGString) {\n                throw new Error('Non-existing filter ' + name);\n            }\n\n            // SVG <filter/> attributes\n            var filterAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.assign)({\n                filterUnits: 'userSpaceOnUse',\n            }, filter.attrs, {\n                id: filterId\n            });\n\n            (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(filterSVGString, filterAttrs).appendTo(this.defs);\n        }\n\n        return filterId;\n    },\n\n    defineGradient: function(gradient) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(gradient)) {\n            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            type,\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = type + svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(gradient)),\n            stops,\n            attrs = {}\n        } = gradient;\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const stopVEls = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.toArray)(stops).map(({ offset, color, opacity }) => {\n            return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('stop').attr({\n                'offset': offset,\n                'stop-color': color,\n                'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n            });\n        });\n        const gradientVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(type, attrs, stopVEls);\n        gradientVEl.id = id;\n        gradientVEl.appendTo(defs);\n        return id;\n    },\n\n    definePattern: function(pattern) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(pattern)) {\n            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(pattern)),\n            markup,\n            attrs = {}\n        } = pattern;\n        if (!markup) {\n            throw new TypeError('dia.Paper: definePattern() requires markup.');\n        }\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const patternVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('pattern', {\n            patternUnits: 'userSpaceOnUse'\n        });\n        patternVEl.id = id;\n        patternVEl.attr(attrs);\n        if (typeof markup === 'string') {\n            patternVEl.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(markup));\n        } else {\n            const { fragment } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.parseDOMJSON)(markup);\n            patternVEl.append(fragment);\n        }\n        patternVEl.appendTo(defs);\n        return id;\n    },\n\n    defineMarker: function(marker) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(marker)) {\n            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(marker)),\n            // user-provided markup\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n            markup,\n            // user-provided attributes\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n            // note: `transform` attrs are ignored by browsers\n            attrs = {},\n            // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n            markerUnits = 'userSpaceOnUse'\n        } = marker;\n        // If the marker already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const markerVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('marker', {\n            orient: 'auto',\n            overflow: 'visible',\n            markerUnits: markerUnits\n        });\n        markerVEl.id = id;\n        markerVEl.attr(attrs);\n        let markerContentVEl;\n        if (markup) {\n            let markupVEl;\n            if (typeof markup === 'string') {\n                // Marker object has a `markup` property of type string.\n                // - Construct V from the provided string.\n                markupVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(markup);\n                // `markupVEl` is now either a single VEl, or an array of VEls.\n                // - Coerce it to an array.\n                markupVEl = (Array.isArray(markupVEl) ? markupVEl : [markupVEl]);\n            } else {\n                // Marker object has a `markup` property of type object.\n                // - Construct V from the object by parsing it as DOM JSON.\n                const { fragment } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.parseDOMJSON)(markup);\n                markupVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(fragment).children();\n            }\n            // `markupVEl` is an array with one or more VEls inside.\n            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n            if (markupVEl.length > 1) {\n                markerContentVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('g').append(markupVEl);\n            } else {\n                markerContentVEl = markupVEl[0];\n            }\n        } else {\n            // Marker object is a flat structure.\n            // - Construct a new V of type `marker.type`.\n            const { type = 'path' } = marker;\n            markerContentVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(type);\n        }\n        // `markerContentVEl` is a single VEl.\n        // Assign additional attributes to it (= context attributes + marker attributes):\n        // - Attribute values are taken from non-special properties of `marker`.\n        const markerAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.omit)(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n        const markerAttrsKeys = Object.keys(markerAttrs);\n        markerAttrsKeys.forEach((key) => {\n            const value = markerAttrs[key];\n            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n            if (markupValue == null) {\n                // Default logic:\n                markerContentVEl.attr(key, value);\n            } else {\n                // Properties with special logic should be added as cases to this switch block:\n                switch(key) {\n                    case 'transform':\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, (value + ' ' + markupValue));\n                        break;\n                }\n            }\n        });\n        markerContentVEl.appendTo(markerVEl);\n        markerVEl.appendTo(defs);\n        return id;\n    },\n\n    customEventTrigger: function(evt, view, rootNode = view.el) {\n\n        const eventNode = evt.target.closest('[event]');\n\n        if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n            const eventEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, {\n                data: evt.data,\n                // Originally the event listener was attached to the event element.\n                currentTarget: eventNode\n            }));\n\n            this.onevent(eventEvt);\n\n            if (eventEvt.isDefaultPrevented()) {\n                evt.preventDefault();\n            }\n\n            return eventEvt;\n        }\n\n        return null;\n    }\n\n}, {\n\n    sorting: sortingTypes,\n\n    Layers: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames,\n\n    backgroundPatterns: {\n\n        flipXy: function(img) {\n            // d b\n            // q p\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = 2 * imgWidth;\n            canvas.height = 2 * imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // top-left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // xy-flipped bottom-right image\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // x-flipped top-right image\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // y-flipped bottom-left image\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipX: function(img) {\n            // d b\n            // d b\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth * 2;\n            canvas.height = imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped right image\n            ctx.translate(2 * imgWidth, 0);\n            ctx.scale(-1, 1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipY: function(img) {\n            // d d\n            // q q\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth;\n            canvas.height = imgHeight * 2;\n\n            var ctx = canvas.getContext('2d');\n            // top image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped bottom image\n            ctx.translate(0, 2 * imgHeight);\n            ctx.scale(1, -1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        watermark: function(img, opt) {\n            //   d\n            // d\n\n            opt = opt || {};\n\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            var canvas = document.createElement('canvas');\n            canvas.width = imgWidth * 3;\n            canvas.height = imgHeight * 3;\n\n            var ctx = canvas.getContext('2d');\n            var angle = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n            var radians = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_19__.toRad)(angle);\n            var stepX = canvas.width / 4;\n            var stepY = canvas.height / 4;\n\n            for (var i = 0; i < 4; i++) {\n                for (var j = 0; j < 4; j++) {\n                    if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n            }\n\n            return canvas;\n        }\n    },\n\n    gridPatterns: {\n        dot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({\n                    width: opt.thickness,\n                    height: opt.thickness,\n                    fill: opt.color\n                });\n            }\n        }],\n        fixedDot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ fill: opt.color });\n            },\n            update: function(el, opt, paper) {\n                const { sx, sy } = paper.scale();\n                const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n                const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ width, height });\n            }\n        }],\n        mesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }],\n        doubleMesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }, {\n            color: '#000000',\n            thickness: 3,\n            scaleFactor: 4,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }]\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9QYXBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBK0JKO0FBQ29CO0FBQ0s7QUFDTDtBQUNMO0FBQ007QUFDTjtBQUNSO0FBQ0U7QUFDdUI7QUFDRDtBQUNGO0FBQ1U7QUFDbEI7O0FBRVg7QUFDYzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkMsMEJBQTBCLG1EQUFROztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsd0RBQVc7QUFDckIsQ0FBQztBQUNELFVBQVUsd0RBQVc7QUFDckIsQ0FBQztBQUNELFVBQVUsd0RBQVc7QUFDckIsQ0FBQztBQUNELFVBQVUsd0RBQVc7QUFDckIsQ0FBQztBQUNELFVBQVUsd0RBQVc7QUFDckIsQ0FBQztBQUNELFVBQVUsd0RBQVc7QUFDckIsQ0FBQzs7QUFFTSxjQUFjLGdEQUFJOztBQUV6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUEscUJBQXFCLHlEQUFXO0FBQ2hDLGtCQUFrQixtREFBUTtBQUMxQjtBQUNBLDRDQUE0QztBQUM1QyxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFD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QUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxnQkFBZ0IseURBQUMsWUFBWSwwREFBMEQ7QUFDdkY7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL1BhcGVyLm1qcz81OWMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7XG4gICAgaXNOdW1iZXIsXG4gICAgYXNzaWduLFxuICAgIG5leHRGcmFtZSxcbiAgICBpc09iamVjdCxcbiAgICBjYW5jZWxGcmFtZSxcbiAgICBkZWZhdWx0cyxcbiAgICBkZWZhdWx0c0RlZXAsXG4gICAgYWRkQ2xhc3NOYW1lUHJlZml4LFxuICAgIG5vcm1hbGl6ZVNpZGVzLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNQbGFpbk9iamVjdCxcbiAgICBnZXRCeVBhdGgsXG4gICAgc29ydEVsZW1lbnRzLFxuICAgIGlzU3RyaW5nLFxuICAgIGd1aWQsXG4gICAgbm9ybWFsaXplRXZlbnQsXG4gICAgbm9ybWFsaXplV2hlZWwsXG4gICAgY2FwLFxuICAgIGRlYm91bmNlLFxuICAgIG9taXQsXG4gICAgcmVzdWx0LFxuICAgIGNhbWVsQ2FzZSxcbiAgICBjbG9uZURlZXAsXG4gICAgaW52b2tlLFxuICAgIGhhc2hDb2RlLFxuICAgIGZpbHRlciBhcyBfZmlsdGVyLFxuICAgIHBhcnNlRE9NSlNPTixcbiAgICB0b0FycmF5LFxuICAgIGhhc1xufSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBWaWV3QmFzZSB9IGZyb20gJy4uL212Yy9WaWV3QmFzZS5tanMnO1xuaW1wb3J0IHsgUmVjdCwgUG9pbnQsIHRvUmFkIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgVmlldywgdmlld3MgfSBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCB7IENlbGxWaWV3IH0gZnJvbSAnLi9DZWxsVmlldy5tanMnO1xuaW1wb3J0IHsgRWxlbWVudFZpZXcgfSBmcm9tICcuL0VsZW1lbnRWaWV3Lm1qcyc7XG5pbXBvcnQgeyBMaW5rVmlldyB9IGZyb20gJy4vTGlua1ZpZXcubWpzJztcbmltcG9ydCB7IENlbGwgfSBmcm9tICcuL0NlbGwubWpzJztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi9HcmFwaC5tanMnO1xuaW1wb3J0IHsgTGF5ZXJzTmFtZXMsIFBhcGVyTGF5ZXIgfSBmcm9tICcuL1BhcGVyTGF5ZXIubWpzJztcbmltcG9ydCAqIGFzIGhpZ2hsaWdodGVycyBmcm9tICcuLi9oaWdobGlnaHRlcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGxpbmtBbmNob3JzIGZyb20gJy4uL2xpbmtBbmNob3JzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBjb25uZWN0aW9uUG9pbnRzIGZyb20gJy4uL2Nvbm5lY3Rpb25Qb2ludHMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGFuY2hvcnMgZnJvbSAnLi4vYW5jaG9ycy9pbmRleC5tanMnO1xuXG5pbXBvcnQgJCBmcm9tICcuLi9tdmMvRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBHcmlkTGF5ZXIgfSBmcm9tICcuL2xheWVycy9HcmlkTGF5ZXIubWpzJztcblxuY29uc3Qgc29ydGluZ1R5cGVzID0ge1xuICAgIE5PTkU6ICdzb3J0aW5nLW5vbmUnLFxuICAgIEFQUFJPWDogJ3NvcnRpbmctYXBwcm94aW1hdGUnLFxuICAgIEVYQUNUOiAnc29ydGluZy1leGFjdCdcbn07XG5cbmNvbnN0IFdIRUVMX0NBUCA9IDUwO1xuY29uc3QgV0hFRUxfV0FJVF9NUyA9IDIwO1xuY29uc3QgTU9VTlRfQkFUQ0hfU0laRSA9IDEwMDA7XG5jb25zdCBVUERBVEVfQkFUQ0hfU0laRSA9IEluZmluaXR5O1xuY29uc3QgTUlOX1BSSU9SSVRZID0gOTAwNzE5OTI1NDc0MDk5MTsgLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcblxuY29uc3QgSGlnaGxpZ2h0aW5nVHlwZXMgPSBDZWxsVmlldy5IaWdobGlnaHRpbmc7XG5cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRpbmcgPSB7XG4gICAgW0hpZ2hsaWdodGluZ1R5cGVzLkRFRkFVTFRdOiB7XG4gICAgICAgIG5hbWU6ICdzdHJva2UnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAzXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFtIaWdobGlnaHRpbmdUeXBlcy5NQUdORVRfQVZBSUxBQklMSVRZXToge1xuICAgICAgICBuYW1lOiAnYWRkQ2xhc3MnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhdmFpbGFibGUtbWFnbmV0J1xuICAgICAgICB9XG4gICAgfSxcbiAgICBbSGlnaGxpZ2h0aW5nVHlwZXMuRUxFTUVOVF9BVkFJTEFCSUxJVFldOiB7XG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2F2YWlsYWJsZS1jZWxsJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgZGVmYXVsdExheWVycyA9IFt7XG4gICAgbmFtZTogTGF5ZXJzTmFtZXMuR1JJRCxcbn0sIHtcbiAgICBuYW1lOiBMYXllcnNOYW1lcy5CQUNLLFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLkNFTExTLFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLkxBQkVMUyxcbn0sIHtcbiAgICBuYW1lOiBMYXllcnNOYW1lcy5GUk9OVFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLlRPT0xTXG59XTtcblxuZXhwb3J0IGNvbnN0IFBhcGVyID0gVmlldy5leHRlbmQoe1xuXG4gICAgY2xhc3NOYW1lOiAncGFwZXInLFxuXG4gICAgb3B0aW9uczoge1xuXG4gICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgIGhlaWdodDogNjAwLFxuICAgICAgICBncmlkU2l6ZTogMSxcbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgdG8gZHJhdyB0aGUgZ3JpZCBsaW5lcyBvbiB0aGUgcGFwZXIncyBET00gZWxlbWVudC5cbiAgICAgICAgLy8gZS5nIGRyYXdHcmlkOiB0cnVlLCBkcmF3R3JpZDogeyBjb2xvcjogJ3JlZCcsIHRoaWNrbmVzczogMiB9XG4gICAgICAgIGRyYXdHcmlkOiBmYWxzZSxcbiAgICAgICAgLy8gSWYgbm90IHNldCwgdGhlIHNpemUgb2YgdGhlIHZpc3VhbCBncmlkIGlzIHRoZSBzYW1lIGFzIHRoZSBgZ3JpZFNpemVgLlxuICAgICAgICBkcmF3R3JpZFNpemU6IG51bGwsXG5cbiAgICAgICAgLy8gV2hldGhlciBvciBub3QgdG8gZHJhdyB0aGUgYmFja2dyb3VuZCBvbiB0aGUgcGFwZXIncyBET00gZWxlbWVudC5cbiAgICAgICAgLy8gZS5nLiBiYWNrZ3JvdW5kOiB7IGNvbG9yOiAnbGlnaHRibHVlJywgaW1hZ2U6ICcvcGFwZXItYmFja2dyb3VuZC5wbmcnLCByZXBlYXQ6ICdmbGlwLXh5JyB9XG4gICAgICAgIGJhY2tncm91bmQ6IGZhbHNlLFxuXG4gICAgICAgIGVsZW1lbnRWaWV3OiBFbGVtZW50VmlldyxcbiAgICAgICAgbGlua1ZpZXc6IExpbmtWaWV3LFxuICAgICAgICBzbmFwTGFiZWxzOiBmYWxzZSwgLy8gZmFsc2UsIHRydWVcbiAgICAgICAgc25hcExpbmtzOiBmYWxzZSwgLy8gZmFsc2UsIHRydWUsIHsgcmFkaXVzOiB2YWx1ZSB9XG4gICAgICAgIHNuYXBMaW5rc1NlbGY6IGZhbHNlLCAvLyBmYWxzZSwgdHJ1ZSwgeyByYWRpdXM6IHZhbHVlIH1cblxuICAgICAgICAvLyBTaG91bGQgdGhlIGxpbmsgbGFiZWxzIGJlIHJlbmRlcmVkIGludG8gaXRzIG93biBsYXllcj9cbiAgICAgICAgLy8gYGZhbHNlYCAtIHRoZSBsYWJlbHMgYXJlIHBhcnQgb2YgdGhlIGxpbmtzXG4gICAgICAgIC8vIGB0cnVlYCAtIHRoZSBsYWJlbHMgYXJlIGFwcGVuZGVkIHRvIExheWVyc05hbWUuTEFCRUxTXG4gICAgICAgIC8vIFtMYXllcnNOYW1lXSAtIHRoZSBsYWJlbHMgYXJlIGFwcGVuZGVkIHRvIHRoZSBsYXllciBzcGVjaWZpZWRcbiAgICAgICAgbGFiZWxzTGF5ZXI6IGZhbHNlLFxuXG4gICAgICAgIC8vIFdoZW4gc2V0IHRvIEZBTFNFLCBhbiBlbGVtZW50IG1heSBub3QgaGF2ZSBtb3JlIHRoYW4gMSBsaW5rIHdpdGggdGhlIHNhbWUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgbXVsdGlMaW5rczogdHJ1ZSxcblxuICAgICAgICAvLyBGb3IgYWRkaW5nIGN1c3RvbSBndWFyZCBsb2dpYy5cbiAgICAgICAgZ3VhcmQ6IGZ1bmN0aW9uKGV2dCwgdmlldykge1xuXG4gICAgICAgICAgICAvLyBGQUxTRSBtZWFucyB0aGUgZXZlbnQgaXNuJ3QgZ3VhcmRlZC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBoaWdobGlnaHRpbmc6IGRlZmF1bHRIaWdobGlnaHRpbmcsXG5cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBjb250ZXh0IG1lbnUgZnJvbSBiZWluZyBkaXNwbGF5ZWQuXG4gICAgICAgIHByZXZlbnRDb250ZXh0TWVudTogdHJ1ZSxcblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgYmxhbms6cG9pbnRlcjxhY3Rpb24+LlxuICAgICAgICBwcmV2ZW50RGVmYXVsdEJsYW5rQWN0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBjZWxsOnBvaW50ZXI8YWN0aW9uPi5cbiAgICAgICAgcHJldmVudERlZmF1bHRWaWV3QWN0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8vIFJlc3RyaWN0IHRoZSB0cmFuc2xhdGlvbiBvZiBlbGVtZW50cyBieSBnaXZlbiBib3VuZGluZyBib3guXG4gICAgICAgIC8vIE9wdGlvbiBhY2NlcHRzIGEgYm9vbGVhbjpcbiAgICAgICAgLy8gIHRydWUgLSB0aGUgdHJhbnNsYXRpb24gaXMgcmVzdHJpY3RlZCB0byB0aGUgcGFwZXIgYXJlYVxuICAgICAgICAvLyAgZmFsc2UgLSBubyByZXN0cmljdGlvbnNcbiAgICAgICAgLy8gQSBtZXRob2Q6XG4gICAgICAgIC8vIHJlc3RyaWN0VHJhbnNsYXRlOiBmdW5jdGlvbihlbGVtZW50Vmlldykge1xuICAgICAgICAvLyAgICAgdmFyIHBhcmVudElkID0gZWxlbWVudFZpZXcubW9kZWwuZ2V0KCdwYXJlbnQnKTtcbiAgICAgICAgLy8gICAgIHJldHVybiBwYXJlbnRJZCAmJiB0aGlzLm1vZGVsLmdldENlbGwocGFyZW50SWQpLmdldEJCb3goKTtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gT3IgYSBib3VuZGluZyBib3g6XG4gICAgICAgIC8vIHJlc3RyaWN0VHJhbnNsYXRlOiB7IHg6IDEwLCB5OiAxMCwgd2lkdGg6IDc5MCwgaGVpZ2h0OiA1OTAgfVxuICAgICAgICByZXN0cmljdFRyYW5zbGF0ZTogZmFsc2UsXG5cbiAgICAgICAgLy8gTWFya3MgYWxsIGF2YWlsYWJsZSBtYWduZXRzIHdpdGggJ2F2YWlsYWJsZS1tYWduZXQnIGNsYXNzIG5hbWUgYW5kIGFsbCBhdmFpbGFibGUgY2VsbHMgd2l0aFxuICAgICAgICAvLyAnYXZhaWxhYmxlLWNlbGwnIGNsYXNzIG5hbWUuIE1hcmtzIHRoZW0gd2hlbiBkcmFnZ2luZyBhIGxpbmsgaXMgc3RhcnRlZCBhbmQgdW5tYXJrXG4gICAgICAgIC8vIHdoZW4gdGhlIGRyYWdnaW5nIGlzIHN0b3BwZWQuXG4gICAgICAgIG1hcmtBdmFpbGFibGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIERlZmluZXMgd2hhdCBsaW5rIG1vZGVsIGlzIGFkZGVkIHRvIHRoZSBncmFwaCBhZnRlciBhbiB1c2VyIGNsaWNrcyBvbiBhbiBhY3RpdmUgbWFnbmV0LlxuICAgICAgICAvLyBWYWx1ZSBjb3VsZCBiZSB0aGUgbXZjLm1vZGVsIG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBtdmMubW9kZWxcbiAgICAgICAgLy8gZGVmYXVsdExpbms6IChlbGVtZW50VmlldywgbWFnbmV0KSA9PiB7XG4gICAgICAgIC8vICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5ldyBjdXN0b21MaW5rMSgpIDogbmV3IGN1c3RvbUxpbmsyKClcbiAgICAgICAgLy8gfVxuICAgICAgICBkZWZhdWx0TGluazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgY3JlYXRlIGhhcmQgZGVwZW5kZW5jeSBvbiB0aGUgam9pbnQuc2hhcGVzLnN0YW5kYXJkIG5hbWVzcGFjZSAoYnkgaW1wb3J0aW5nIHRoZSBzdGFuZGFyZC5MaW5rIG1vZGVsIGRpcmVjdGx5KVxuICAgICAgICAgICAgY29uc3QgeyBjZWxsTmFtZXNwYWNlIH0gPSB0aGlzLm1vZGVsLmdldCgnY2VsbHMnKTtcbiAgICAgICAgICAgIGNvbnN0IGN0b3IgPSBnZXRCeVBhdGgoY2VsbE5hbWVzcGFjZSwgWydzdGFuZGFyZCcsICdMaW5rJ10pO1xuICAgICAgICAgICAgaWYgKCFjdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5QYXBlcjogbm8gZGVmYXVsdCBsaW5rIG1vZGVsIGZvdW5kLiBVc2UgYG9wdGlvbnMuZGVmYXVsdExpbmtgIHRvIHNwZWNpZnkgYSBkZWZhdWx0IGxpbmsgbW9kZWwuJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGN0b3IoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBBIGNvbm5lY3RvciB0aGF0IGlzIHVzZWQgYnkgbGlua3Mgd2l0aCBubyBjb25uZWN0b3IgZGVmaW5lZCBvbiB0aGUgbW9kZWwuXG4gICAgICAgIC8vIGUuZy4geyBuYW1lOiAncm91bmRlZCcsIGFyZ3M6IHsgcmFkaXVzOiA1IH19IG9yIGEgZnVuY3Rpb25cbiAgICAgICAgZGVmYXVsdENvbm5lY3RvcjogeyBuYW1lOiAnbm9ybWFsJyB9LFxuXG4gICAgICAgIC8vIEEgcm91dGVyIHRoYXQgaXMgdXNlZCBieSBsaW5rcyB3aXRoIG5vIHJvdXRlciBkZWZpbmVkIG9uIHRoZSBtb2RlbC5cbiAgICAgICAgLy8gZS5nLiB7IG5hbWU6ICdvbmVTaWRlJywgYXJnczogeyBwYWRkaW5nOiAxMCB9fSBvciBhIGZ1bmN0aW9uXG4gICAgICAgIGRlZmF1bHRSb3V0ZXI6IHsgbmFtZTogJ25vcm1hbCcgfSxcblxuICAgICAgICBkZWZhdWx0QW5jaG9yOiB7IG5hbWU6ICdjZW50ZXInIH0sXG5cbiAgICAgICAgZGVmYXVsdExpbmtBbmNob3I6IHsgbmFtZTogJ2Nvbm5lY3Rpb25SYXRpbycgfSxcblxuICAgICAgICBkZWZhdWx0Q29ubmVjdGlvblBvaW50OiB7IG5hbWU6ICdib3VuZGFyeScgfSxcblxuICAgICAgICAvKiBDT05ORUNUSU5HICovXG5cbiAgICAgICAgY29ubmVjdGlvblN0cmF0ZWd5OiBudWxsLFxuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdG8gYWRkIGEgbmV3IGxpbmsgdG8gdGhlIGdyYXBoIHdoZW4gdXNlciBjbGlja3Mgb24gYW4gYSBtYWduZXQuXG4gICAgICAgIHZhbGlkYXRlTWFnbmV0OiBmdW5jdGlvbihfY2VsbFZpZXcsIG1hZ25ldCwgX2V2dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hZ25ldC5nZXRBdHRyaWJ1dGUoJ21hZ25ldCcpICE9PSAncGFzc2l2ZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byBhbGxvdyBvciBkaXNhbGxvdyB0aGUgbGluayBjb25uZWN0aW9uIHdoaWxlIGFuIGFycm93aGVhZCBlbmQgKHNvdXJjZS90YXJnZXQpXG4gICAgICAgIC8vIGJlaW5nIGNoYW5nZWQuXG4gICAgICAgIHZhbGlkYXRlQ29ubmVjdGlvbjogZnVuY3Rpb24oY2VsbFZpZXdTLCBfbWFnbmV0UywgY2VsbFZpZXdULCBfbWFnbmV0VCwgZW5kLCBfbGlua1ZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiAoZW5kID09PSAndGFyZ2V0JyA/IGNlbGxWaWV3VCA6IGNlbGxWaWV3UykgaW5zdGFuY2VvZiBFbGVtZW50VmlldztcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBFTUJFRERJTkcgKi9cblxuICAgICAgICAvLyBFbmFibGVzIGVtYmVkZGluZy4gUmUtcGFyZW50IHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2l0aCBlbGVtZW50cyB1bmRlciBpdCBhbmQgbWFrZXMgc3VyZSB0aGF0XG4gICAgICAgIC8vIGFsbCBsaW5rcyBhbmQgZWxlbWVudHMgYXJlIHZpc2libGUgdGFrZW4gdGhlIGxldmVsIG9mIGVtYmVkZGluZyBpbnRvIGFjY291bnQuXG4gICAgICAgIGVtYmVkZGluZ01vZGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3cgdGhlIGVsZW1lbnQgZW1iZWRkaW5nIHdoaWxlIGFuIGVsZW1lbnQgYmVpbmcgdHJhbnNsYXRlZC5cbiAgICAgICAgdmFsaWRhdGVFbWJlZGRpbmc6IGZ1bmN0aW9uKGNoaWxkVmlldywgcGFyZW50Vmlldykge1xuICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCBhbGwgZWxlbWVudHMgY2FuIGJlIGluIHJlbGF0aW9uIGNoaWxkLXBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byBhbGxvdyBvciBkaXNhbGxvdyBhbiBlbWJlZGRlZCBlbGVtZW50IHRvIGJlIHVuZW1iZWRkZWQgLyB0byBiZWNvbWUgYSByb290LlxuICAgICAgICB2YWxpZGF0ZVVuZW1iZWRkaW5nOiBmdW5jdGlvbihjaGlsZFZpZXcpIHtcbiAgICAgICAgICAgIC8vIGJ5IGRlZmF1bHQgYWxsIGVsZW1lbnRzIGNhbiBiZWNvbWUgcm9vdHNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIERldGVybWluZXMgdGhlIHdheSBob3cgYSBjZWxsIGZpbmRzIGEgc3VpdGFibGUgcGFyZW50IHdoZW4gaXQncyBkcmFnZ2VkIG92ZXIgdGhlIHBhcGVyLlxuICAgICAgICAvLyBUaGUgY2VsbCB3aXRoIHRoZSBoaWdoZXN0IHotaW5kZXggKHZpc3VhbGx5IG9uIHRoZSB0b3ApIHdpbGwgYmUgY2hvc2VuLlxuICAgICAgICBmaW5kUGFyZW50Qnk6ICdiYm94JywgLy8gJ2Jib3gnfCdjZW50ZXInfCdvcmlnaW4nfCdjb3JuZXInfCd0b3BSaWdodCd8J2JvdHRvbUxlZnQnXG5cbiAgICAgICAgLy8gSWYgZW5hYmxlZCBvbmx5IHRoZSBlbGVtZW50IG9uIHRoZSB2ZXJ5IGZyb250IGlzIHRha2VuIGludG8gYWNjb3VudCBmb3IgdGhlIGVtYmVkZGluZy5cbiAgICAgICAgLy8gSWYgZGlzYWJsZWQgdGhlIGVsZW1lbnRzIHVuZGVyIHRoZSBkcmFnZ2VkIHZpZXcgYXJlIHRlc3RlZCBvbmUgYnkgb25lXG4gICAgICAgIC8vIChmcm9tIGZyb250IHRvIGJhY2spIHVudGlsIGEgdmFsaWQgcGFyZW50IGZvdW5kLlxuICAgICAgICBmcm9udFBhcmVudE9ubHk6IHRydWUsXG5cbiAgICAgICAgLy8gSW50ZXJhY3RpdmUgZmxhZ3MuIFNlZSBvbmxpbmUgZG9jcyBmb3IgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgaW50ZXJhY3RpdmUgZmxhZ3MuXG4gICAgICAgIGludGVyYWN0aXZlOiB7XG4gICAgICAgICAgICBsYWJlbE1vdmU6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV2hlbiBzZXQgdG8gdHJ1ZSB0aGUgbGlua3MgY2FuIGJlIHBpbm5lZCB0byB0aGUgcGFwZXIuXG4gICAgICAgIC8vIGkuZS4gbGluayBzb3VyY2UvdGFyZ2V0IGNhbiBiZSBhIHBvaW50IGUuZy4gbGluay5nZXQoJ3NvdXJjZScpID09PiB7IHg6IDEwMCwgeTogMTAwIH07XG4gICAgICAgIGxpbmtQaW5uaW5nOiB0cnVlLFxuXG4gICAgICAgIC8vIEN1c3RvbSB2YWxpZGF0aW9uIGFmdGVyIGFuIGludGVyYWN0aW9uIHdpdGggYSBsaW5rIGVuZHMuXG4gICAgICAgIC8vIFJlY29nbml6ZXMgYSBmdW5jdGlvbi4gSWYgYGZhbHNlYCBpcyByZXR1cm5lZCwgdGhlIGxpbmsgaXMgZGlzYWxsb3dlZCAocmVtb3ZlZCBvciByZXZlcnRlZClcbiAgICAgICAgLy8gKGxpbmtWaWV3LCBwYXBlcikgPT4gYm9vbGVhblxuICAgICAgICBhbGxvd0xpbms6IG51bGwsXG5cbiAgICAgICAgLy8gQWxsb3dlZCBudW1iZXIgb2YgbW91c2Vtb3ZlIGV2ZW50cyBhZnRlciB3aGljaCB0aGUgcG9pbnRlcmNsaWNrIGV2ZW50IHdpbGwgYmUgc3RpbGwgdHJpZ2dlcmVkLlxuICAgICAgICBjbGlja1RocmVzaG9sZDogMCxcblxuICAgICAgICAvLyBOdW1iZXIgb2YgcmVxdWlyZWQgbW91c2Vtb3ZlIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IHBvaW50ZXJtb3ZlIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuICAgICAgICBtb3ZlVGhyZXNob2xkOiAwLFxuXG4gICAgICAgIC8vIE51bWJlciBvZiByZXF1aXJlZCBtb3VzZW1vdmUgZXZlbnRzIGJlZm9yZSBhIGxpbmsgaXMgY3JlYXRlZCBvdXQgb2YgdGhlIG1hZ25ldC5cbiAgICAgICAgLy8gT3Igc3RyaW5nIGBvbmxlYXZlYCBzbyB0aGUgbGluayBpcyBjcmVhdGVkIHdoZW4gdGhlIHBvaW50ZXIgbGVhdmVzIHRoZSBtYWduZXRcbiAgICAgICAgbWFnbmV0VGhyZXNob2xkOiAwLFxuXG4gICAgICAgIC8vIFJlbmRlcmluZyBPcHRpb25zXG5cbiAgICAgICAgc29ydGluZzogc29ydGluZ1R5cGVzLkFQUFJPWCxcblxuICAgICAgICBmcm96ZW46IGZhbHNlLFxuXG4gICAgICAgIGF1dG9GcmVlemU6IGZhbHNlLFxuXG4gICAgICAgIC8vIG5vIGRvY3MgeWV0XG4gICAgICAgIG9uVmlld1VwZGF0ZTogZnVuY3Rpb24odmlldywgZmxhZywgcHJpb3JpdHksIG9wdCwgcGFwZXIpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB1cGRhdGUgY29ubmVjdGVkIGxpbmtzIHdoZW46XG4gICAgICAgICAgICAvLyAxLiB0aGUgdmlldyB3YXMganVzdCBpbnNlcnRlZCAoYWRkZWQgdG8gdGhlIGdyYXBoIGFuZCByZW5kZXJlZClcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2aWV3IHdhcyBqdXN0IG1vdW50ZWQgKGFkZGVkIGJhY2sgdG8gdGhlIHBhcGVyIGJ5IHZpZXdwb3J0IGZ1bmN0aW9uKVxuICAgICAgICAgICAgLy8gMy4gdGhlIGNoYW5nZSB3YXMgbWFya2VkIGFzIGBpc29sYXRlYC5cbiAgICAgICAgICAgIC8vIDQuIHRoZSB2aWV3IG1vZGVsIHdhcyBqdXN0IHJlbW92ZWQgZnJvbSB0aGUgZ3JhcGhcbiAgICAgICAgICAgIGlmICgoZmxhZyAmICh2aWV3LkZMQUdfSU5TRVJUIHwgdmlldy5GTEFHX1JFTU9WRSkpIHx8IG9wdC5tb3VudGluZyB8fCBvcHQuaXNvbGF0ZSkgcmV0dXJuO1xuICAgICAgICAgICAgcGFwZXIucmVxdWVzdENvbm5lY3RlZExpbmtzVXBkYXRlKHZpZXcsIHByaW9yaXR5LCBvcHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIG5vIGRvY3MgeWV0XG4gICAgICAgIG9uVmlld1Bvc3Rwb25lZDogZnVuY3Rpb24odmlldywgZmxhZywgcGFwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXBlci5mb3JjZVBvc3Rwb25lZFZpZXdVcGRhdGUodmlldywgZmxhZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmVmb3JlUmVuZGVyOiBudWxsLCAvLyBmdW5jdGlvbihvcHQsIHBhcGVyKSB7IH0sXG5cbiAgICAgICAgYWZ0ZXJSZW5kZXI6IG51bGwsIC8vIGZ1bmN0aW9uKHN0YXRzLCBvcHQsIHBhcGVyKSB7XG5cbiAgICAgICAgdmlld3BvcnQ6IG51bGwsXG5cbiAgICAgICAgLy8gRGVmYXVsdCBuYW1lc3BhY2VzXG5cbiAgICAgICAgY2VsbFZpZXdOYW1lc3BhY2U6IG51bGwsXG5cbiAgICAgICAgcm91dGVyTmFtZXNwYWNlOiBudWxsLFxuXG4gICAgICAgIGNvbm5lY3Rvck5hbWVzcGFjZTogbnVsbCxcblxuICAgICAgICBoaWdobGlnaHRlck5hbWVzcGFjZTogaGlnaGxpZ2h0ZXJzLFxuXG4gICAgICAgIGFuY2hvck5hbWVzcGFjZTogYW5jaG9ycyxcblxuICAgICAgICBsaW5rQW5jaG9yTmFtZXNwYWNlOiBsaW5rQW5jaG9ycyxcblxuICAgICAgICBjb25uZWN0aW9uUG9pbnROYW1lc3BhY2U6IGNvbm5lY3Rpb25Qb2ludHMsXG5cbiAgICAgICAgb3ZlcmZsb3c6IGZhbHNlXG4gICAgfSxcblxuICAgIGV2ZW50czoge1xuICAgICAgICAnZGJsY2xpY2snOiAncG9pbnRlcmRibGNsaWNrJyxcbiAgICAgICAgJ2RibHRhcCc6ICdwb2ludGVyZGJsY2xpY2snLFxuICAgICAgICAnY29udGV4dG1lbnUnOiAnY29udGV4dG1lbnUnLFxuICAgICAgICAnbW91c2Vkb3duJzogJ3BvaW50ZXJkb3duJyxcbiAgICAgICAgJ3RvdWNoc3RhcnQnOiAncG9pbnRlcmRvd24nLFxuICAgICAgICAnbW91c2VvdmVyJzogJ21vdXNlb3ZlcicsXG4gICAgICAgICdtb3VzZW91dCc6ICdtb3VzZW91dCcsXG4gICAgICAgICdtb3VzZWVudGVyJzogJ21vdXNlZW50ZXInLFxuICAgICAgICAnbW91c2VsZWF2ZSc6ICdtb3VzZWxlYXZlJyxcbiAgICAgICAgJ3doZWVsJzogJ21vdXNld2hlZWwnLFxuICAgICAgICAnbW91c2VlbnRlciAuam9pbnQtY2VsbCc6ICdtb3VzZWVudGVyJyxcbiAgICAgICAgJ21vdXNlbGVhdmUgLmpvaW50LWNlbGwnOiAnbW91c2VsZWF2ZScsXG4gICAgICAgICdtb3VzZWVudGVyIC5qb2ludC10b29scyc6ICdtb3VzZWVudGVyJyxcbiAgICAgICAgJ21vdXNlbGVhdmUgLmpvaW50LXRvb2xzJzogJ21vdXNlbGVhdmUnLFxuICAgICAgICAnZGJsY2xpY2sgLmpvaW50LWNlbGwgW21hZ25ldF0nOiAnbWFnbmV0cG9pbnRlcmRibGNsaWNrJyxcbiAgICAgICAgJ2NvbnRleHRtZW51IC5qb2ludC1jZWxsIFttYWduZXRdJzogJ21hZ25ldGNvbnRleHRtZW51JyxcbiAgICAgICAgJ21vdXNlZG93biAuam9pbnQtbGluayAubGFiZWwnOiAnb25sYWJlbCcsIC8vIGludGVyYWN0aW9uIHdpdGggbGluayBsYWJlbFxuICAgICAgICAndG91Y2hzdGFydCAuam9pbnQtbGluayAubGFiZWwnOiAnb25sYWJlbCcsXG4gICAgICAgICdkcmFnc3RhcnQgLmpvaW50LWNlbGwgaW1hZ2UnOiAnb25JbWFnZURyYWdTdGFydCcgLy8gZmlyZWZveCBmaXhcbiAgICB9LFxuXG4gICAgZG9jdW1lbnRFdmVudHM6IHtcbiAgICAgICAgJ21vdXNlbW92ZSc6ICdwb2ludGVybW92ZScsXG4gICAgICAgICd0b3VjaG1vdmUnOiAncG9pbnRlcm1vdmUnLFxuICAgICAgICAnbW91c2V1cCc6ICdwb2ludGVydXAnLFxuICAgICAgICAndG91Y2hlbmQnOiAncG9pbnRlcnVwJyxcbiAgICAgICAgJ3RvdWNoY2FuY2VsJzogJ3BvaW50ZXJ1cCdcbiAgICB9LFxuXG4gICAgLyogQ1NTIHdpdGhpbiB0aGUgU1ZHIGRvY3VtZW50XG4gICAgKiAxLiBBZGRpbmcgdmVjdG9yLWVmZmVjdDogbm9uLXNjYWxpbmctc3Ryb2tlOyB0byBwcmV2ZW50IHRoZSBzdHJva2Ugd2lkdGggZnJvbSBzY2FsaW5nIGZvclxuICAgICogICAgZWxlbWVudHMgdGhhdCB1c2UgdGhlIGBzY2FsYWJsZWAgZ3JvdXAuXG4gICAgKi9cbiAgICBzdHlsZXNoZWV0OiAvKmNzcyovYFxuICAgICAgICAuam9pbnQtZWxlbWVudCAuc2NhbGFibGUgKiB7XG4gICAgICAgICAgICB2ZWN0b3ItZWZmZWN0OiBub24tc2NhbGluZy1zdHJva2U7XG4gICAgICAgIH1cbiAgICBgLFxuXG4gICAgc3ZnOiBudWxsLFxuICAgIHZpZXdwb3J0OiBudWxsLFxuICAgIGRlZnM6IG51bGwsXG4gICAgdG9vbHM6IG51bGwsXG4gICAgbGF5ZXJzOiBudWxsLFxuXG4gICAgLy8gRm9yIHN0b3JpbmcgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4IChDVE0pIG9mIHRoZSBwYXBlcidzIHZpZXdwb3J0LlxuICAgIF92aWV3cG9ydE1hdHJpeDogbnVsbCxcbiAgICAvLyBGb3IgdmVyaWZ5aW5nIHdoZXRoZXIgdGhlIENUTSBpcyB1cC10by1kYXRlLiBUaGUgdmlld3BvcnQgdHJhbnNmb3JtIGF0dHJpYnV0ZVxuICAgIC8vIGNvdWxkIGhhdmUgYmVlbiBtYW5pcHVsYXRlZCBkaXJlY3RseS5cbiAgICBfdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmc6IG51bGwsXG4gICAgLy8gVXBkYXRlcyBkYXRhIChwcmlvcml0aWVzLCB1bm1vdW50ZWQgdmlld3MgZXRjLilcbiAgICBfdXBkYXRlczogbnVsbCxcbiAgICAvLyBQYXBlciBMYXllcnNcbiAgICBfbGF5ZXJzOiBudWxsLFxuXG4gICAgU09SVF9ERUxBWUlOR19CQVRDSEVTOiBbJ2FkZCcsICd0by1mcm9udCcsICd0by1iYWNrJ10sXG4gICAgVVBEQVRFX0RFTEFZSU5HX0JBVENIRVM6IFsndHJhbnNsYXRlJ10sXG4gICAgLy8gSWYgeW91IGludGVyYWN0IHdpdGggdGhlc2UgZWxlbWVudHMsXG4gICAgLy8gdGhlIGRlZmF1bHQgaW50ZXJhY3Rpb24gc3VjaCBhcyBgZWxlbWVudCBtb3ZlYCBpcyBwcmV2ZW50ZWQuXG4gICAgRk9STV9DT05UUk9MX1RBR19OQU1FUzogWydURVhUQVJFQScsICdJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ09QVElPTiddICxcbiAgICAvLyBJZiB5b3UgaW50ZXJhY3Qgd2l0aCB0aGVzZSBlbGVtZW50cywgdGhlIGV2ZW50cyBhcmUgbm90IHByb3BhZ2F0ZWQgdG8gdGhlIHBhcGVyXG4gICAgLy8gaS5lLiBwYXBlciBldmVudHMgc3VjaCBhcyBgZWxlbWVudDpwb2ludGVyZG93bmAgYXJlIG5vdCB0cmlnZ2VyZWQuXG4gICAgR1VBUkRFRF9UQUdfTkFNRVM6IFtcbiAgICAgICAgLy8gR3VhcmQgPHNlbGVjdD4gZm9yIGNvbnNpc3RlbmN5LiBXaGVuIHlvdSBjbGljayBvbiBpdDpcbiAgICAgICAgLy8gQ2hyb21lOiB0cmlnZ2VycyBgcG9pbnRlcmRvd25gLCBgcG9pbnRlcnVwYCwgYHBvaW50ZXJjbGlja2AgdG8gb3BlblxuICAgICAgICAvLyBGaXJlZm94OiB0cmlnZ2VycyBgcG9pbnRlcmRvd25gIG9uIG9wZW4sIGBwb2ludGVydXBgIChhbmQgYHBvaW50ZXJjbGlja2Agb25seSBpZiB5b3UgaGF2ZW4ndCBtb3ZlZCkuXG4gICAgICAgIC8vICAgICAgICAgIG9uIGNsb3NlLiBIb3dldmVyLCBpZiB5b3Ugb3BlbiBhbmQgdGhlbiBjbG9zZSBieSBjbGlja2luZyBlbHNld2hlcmUgb24gdGhlIHBhZ2UsXG4gICAgICAgIC8vICAgICAgICAgICBubyBvdGhlciBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIC8vIFNhZmFyaTogd2hlbiB5b3Ugb3BlbiBpdCwgaXQgdHJpZ2dlcnMgYHBvaW50ZXJkb3duYC4gVGhhdCdzIGl0LlxuICAgICAgICAnU0VMRUNUJyxcbiAgICBdLFxuICAgIE1JTl9TQ0FMRTogMWUtNixcblxuICAgIC8vIERlZmF1bHQgZmluZCBidWZmZXIgZm9yIHRoZSBmaW5kVmlld3NJbkFyZWEgYW5kIGZpbmRWaWV3c0F0UG9pbnQgbWV0aG9kcy5cbiAgICAvLyBUaGUgZmluZCBidWZmZXIgaXMgdXNlZCB0byBleHRlbmQgdGhlIGFyZWEgb2YgdGhlIHNlYXJjaFxuICAgIC8vIHRvIG1pdGlnYXRlIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdmlldyBnZW9tZXRyeS5cbiAgICBERUZBVUxUX0ZJTkRfQlVGRkVSOiAyMDAsXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0aW9ucy5jZWxsVmlld05hbWVzcGFjZSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgICAgIG9wdGlvbnMuY2VsbFZpZXdOYW1lc3BhY2UgPSB0eXBlb2Ygam9pbnQgIT09ICd1bmRlZmluZWQnICYmIGhhcyhqb2ludCwgJ3NoYXBlcycpID8gam9pbnQuc2hhcGVzIDogbnVsbDtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWwgfHwgbmV3IEdyYXBoO1xuXG4gICAgICAgIC8vIExheWVycyAoU1ZHR3JvdXBzKVxuICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcblxuICAgICAgICB0aGlzLmNsb25lT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLl9zZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcblxuICAgICAgICAvLyBIYXNoIG9mIGFsbCBjZWxsIHZpZXdzLlxuICAgICAgICB0aGlzLl92aWV3cyA9IHt9O1xuXG4gICAgICAgIC8vIE1vdXNlIHdoZWVsIGV2ZW50cyBidWZmZXJcbiAgICAgICAgdGhpcy5fbXdfZXZ0X2J1ZmZlciA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFzOiBbXSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZW5kZXIgZXhpc3RpbmcgY2VsbHMgaW4gdGhlIGdyYXBoXG4gICAgICAgIHRoaXMucmVzZXRWaWV3cyhtb2RlbC5hdHRyaWJ1dGVzLmNlbGxzLm1vZGVscyk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSZW5kZXJpbmcgTG9vcFxuICAgICAgICBpZiAoIXRoaXMuaXNGcm96ZW4oKSAmJiB0aGlzLmlzQXN5bmMoKSkgdGhpcy51cGRhdGVWaWV3c0FzeW5jKCk7XG4gICAgfSxcblxuICAgIF9yZXNldFVwZGF0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fdXBkYXRlcyAmJiB0aGlzLl91cGRhdGVzLmlkKSBjYW5jZWxGcmFtZSh0aGlzLl91cGRhdGVzLmlkKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlcyA9IHtcbiAgICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgICAgcHJpb3JpdGllczogW3t9LCB7fSwge31dLFxuICAgICAgICAgICAgdW5tb3VudGVkQ2lkczogW10sXG4gICAgICAgICAgICBtb3VudGVkQ2lkczogW10sXG4gICAgICAgICAgICB1bm1vdW50ZWQ6IHt9LFxuICAgICAgICAgICAgbW91bnRlZDoge30sXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIGtleUZyb3plbjogZmFsc2UsXG4gICAgICAgICAgICBmcmVlemVLZXk6IG51bGwsXG4gICAgICAgICAgICBzb3J0OiBmYWxzZSxcbiAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlkbGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHN0YXJ0TGlzdGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdGhpcy5saXN0ZW5Ubyhtb2RlbCwgJ2FkZCcsIHRoaXMub25DZWxsQWRkZWQpXG4gICAgICAgICAgICAubGlzdGVuVG8obW9kZWwsICdyZW1vdmUnLCB0aGlzLm9uQ2VsbFJlbW92ZWQpXG4gICAgICAgICAgICAubGlzdGVuVG8obW9kZWwsICdjaGFuZ2UnLCB0aGlzLm9uQ2VsbENoYW5nZSlcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ3Jlc2V0JywgdGhpcy5vbkdyYXBoUmVzZXQpXG4gICAgICAgICAgICAubGlzdGVuVG8obW9kZWwsICdzb3J0JywgdGhpcy5vbkdyYXBoU29ydClcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ2JhdGNoOnN0b3AnLCB0aGlzLm9uR3JhcGhCYXRjaFN0b3ApO1xuICAgICAgICB0aGlzLm9uKCdjZWxsOmhpZ2hsaWdodCcsIHRoaXMub25DZWxsSGlnaGxpZ2h0KVxuICAgICAgICAgICAgLm9uKCdjZWxsOnVuaGlnaGxpZ2h0JywgdGhpcy5vbkNlbGxVbmhpZ2hsaWdodClcbiAgICAgICAgICAgIC5vbigndHJhbnNmb3JtJywgdGhpcy51cGRhdGUpO1xuICAgIH0sXG5cbiAgICBvbkNlbGxBZGRlZDogZnVuY3Rpb24oY2VsbCwgXywgb3B0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG9wdC5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpIHx8ICFpc051bWJlcihwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhjZWxsLCBvcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdC5tYXhQb3NpdGlvbiA9PT0gcG9zaXRpb24pIHRoaXMuZnJlZXplKHsga2V5OiAnYWRkQ2VsbHMnIH0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KGNlbGwsIG9wdCk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDApIHRoaXMudW5mcmVlemUoeyBrZXk6ICdhZGRDZWxscycgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25DZWxsUmVtb3ZlZDogZnVuY3Rpb24oY2VsbCwgXywgb3B0KSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmZpbmRWaWV3QnlNb2RlbChjZWxsKTtcbiAgICAgICAgaWYgKHZpZXcpIHRoaXMucmVxdWVzdFZpZXdVcGRhdGUodmlldywgdmlldy5GTEFHX1JFTU9WRSwgdmlldy5VUERBVEVfUFJJT1JJVFksIG9wdCk7XG4gICAgfSxcblxuICAgIG9uQ2VsbENoYW5nZTogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG4gICAgICAgIGlmIChjZWxsID09PSB0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuY2VsbHMpIHJldHVybjtcbiAgICAgICAgaWYgKGNlbGwuaGFzQ2hhbmdlZCgneicpICYmIHRoaXMub3B0aW9ucy5zb3J0aW5nID09PSBzb3J0aW5nVHlwZXMuQVBQUk9YKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwoY2VsbCk7XG4gICAgICAgICAgICBpZiAodmlldykgdGhpcy5yZXF1ZXN0Vmlld1VwZGF0ZSh2aWV3LCB2aWV3LkZMQUdfSU5TRVJULCB2aWV3LlVQREFURV9QUklPUklUWSwgb3B0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkdyYXBoUmVzZXQ6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG9wdCkge1xuICAgICAgICB0aGlzLnJlc2V0TGF5ZXJzKCk7XG4gICAgICAgIHRoaXMucmVzZXRWaWV3cyhjb2xsZWN0aW9uLm1vZGVscywgb3B0KTtcbiAgICB9LFxuXG4gICAgb25HcmFwaFNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNBY3RpdmVCYXRjaCh0aGlzLlNPUlRfREVMQVlJTkdfQkFUQ0hFUykpIHJldHVybjtcbiAgICAgICAgdGhpcy5zb3J0Vmlld3MoKTtcbiAgICB9LFxuXG4gICAgb25HcmFwaEJhdGNoU3RvcDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0Zyb3plbigpKSByZXR1cm47XG4gICAgICAgIHZhciBuYW1lID0gZGF0YSAmJiBkYXRhLmJhdGNoTmFtZTtcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5tb2RlbDtcbiAgICAgICAgaWYgKCF0aGlzLmlzQXN5bmMoKSkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZURlbGF5aW5nQmF0Y2hlcyA9IHRoaXMuVVBEQVRFX0RFTEFZSU5HX0JBVENIRVM7XG4gICAgICAgICAgICBpZiAodXBkYXRlRGVsYXlpbmdCYXRjaGVzLmluY2x1ZGVzKG5hbWUpICYmICFncmFwaC5oYXNBY3RpdmVCYXRjaCh1cGRhdGVEZWxheWluZ0JhdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cyhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydERlbGF5aW5nQmF0Y2hlcyA9IHRoaXMuU09SVF9ERUxBWUlOR19CQVRDSEVTO1xuICAgICAgICBpZiAoc29ydERlbGF5aW5nQmF0Y2hlcy5pbmNsdWRlcyhuYW1lKSAmJiAhZ3JhcGguaGFzQWN0aXZlQmF0Y2goc29ydERlbGF5aW5nQmF0Y2hlcykpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFZpZXdzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmVPcHRpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGRlZmF1bHRDb25uZWN0b3IsXG4gICAgICAgICAgICBkZWZhdWx0Um91dGVyLFxuICAgICAgICAgICAgZGVmYXVsdENvbm5lY3Rpb25Qb2ludCxcbiAgICAgICAgICAgIGRlZmF1bHRBbmNob3IsXG4gICAgICAgICAgICBkZWZhdWx0TGlua0FuY2hvcixcbiAgICAgICAgICAgIGhpZ2hsaWdodGluZyxcbiAgICAgICAgICAgIGNlbGxWaWV3TmFtZXNwYWNlLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmVcbiAgICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBjZWxsVmlldyBuYW1lc3BhY2UgZm9yIEVTNVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgICAgICBpZiAoIWNlbGxWaWV3TmFtZXNwYWNlICYmIHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzKGpvaW50LCAnc2hhcGVzJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2VsbFZpZXdOYW1lc3BhY2UgPSBqb2ludC5zaGFwZXM7XG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgICAgIC8vIEhlcmUgaWYgYSBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIHdlIGNhbiBub3QgY2xvbmUgaXQsIGFzIHRoaXMgd291bGQgcmVzdWx0IGluIGxvb3NpbmcgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJZiB0aGUgZGVmYXVsdCBpcyB1c2VkLCB0aGUgY2xvbmluZyBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gcHJldmVudCBtb2RpZnlpbmcgdGhlIG9wdGlvbnMgb24gcHJvdG90eXBlLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdENvbm5lY3RvcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdENvbm5lY3RvciA9IGNsb25lRGVlcChkZWZhdWx0Q29ubmVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdFJvdXRlcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdFJvdXRlciA9IGNsb25lRGVlcChkZWZhdWx0Um91dGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdENvbm5lY3Rpb25Qb2ludCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdENvbm5lY3Rpb25Qb2ludCA9IGNsb25lRGVlcChkZWZhdWx0Q29ubmVjdGlvblBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdEFuY2hvcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFuY2hvciA9IGNsb25lRGVlcChkZWZhdWx0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmYXVsdExpbmtBbmNob3IpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRMaW5rQW5jaG9yID0gY2xvbmVEZWVwKGRlZmF1bHRMaW5rQW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChpbnRlcmFjdGl2ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaW50ZXJhY3RpdmUgPSBhc3NpZ24oe30sIGludGVyYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChoaWdobGlnaHRpbmcpKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgaGlnaGxpZ2h0aW5nIG9wdGlvbnMgaW50byB0aGUgdXNlciBzcGVjaWZpZWQgb3B0aW9ucy5cbiAgICAgICAgICAgIG9wdGlvbnMuaGlnaGxpZ2h0aW5nID0gZGVmYXVsdHNEZWVwKHt9LCBoaWdobGlnaHRpbmcsIGRlZmF1bHRIaWdobGlnaHRpbmcpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5zID0gVi5uYW1lc3BhY2U7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBucy54aHRtbCxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBhZGRDbGFzc05hbWVQcmVmaXgoJ3BhcGVyLWJhY2tncm91bmQnKSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYmFja2dyb3VuZCcsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGluc2V0OiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZVVSSTogbnMuc3ZnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ3N2ZycsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogJzEwMCUnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ3htbG5zOnhsaW5rJzogbnMueGxpbmtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3RvcjogJ3N2ZycsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGluc2V0OiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFt7XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIGA8ZGVmcz5gIGVsZW1lbnQgdG8gdGhlIFNWRyBkb2N1bWVudC4gVGhpcyBpcyB1c2VmdWwgZm9yIGZpbHRlcnMgYW5kIGdyYWRpZW50cy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIGRlc2lyZWQgdG8gaGF2ZSB0aGUgZGVmcyBkZWZpbmVkIGJlZm9yZSB0aGUgdmlld3BvcnQgKGUuZy4gdG8gbWFrZSBhIFBERiBkb2N1bWVudCBwaWNrIHVwIGRlZnMgcHJvcGVybHkpLlxuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdkZWZzJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2RlZnMnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2cnLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogYWRkQ2xhc3NOYW1lUHJlZml4KCdsYXllcnMnKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2xheWVycydcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1dO1xuICAgIH0sXG5cbiAgICBoYXNMYXllclZpZXcobGF5ZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiAgKGxheWVyTmFtZSBpbiB0aGlzLl9sYXllcnMpO1xuICAgIH0sXG5cbiAgICBnZXRMYXllclZpZXcobGF5ZXJOYW1lKSB7XG4gICAgICAgIGNvbnN0IHsgX2xheWVycyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGxheWVyTmFtZSBpbiBfbGF5ZXJzKSByZXR1cm4gX2xheWVyc1tsYXllck5hbWVdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpYS5QYXBlcjogVW5rbm93biBsYXllciBcIiR7bGF5ZXJOYW1lfVwiYCk7XG4gICAgfSxcblxuICAgIGdldExheWVyTm9kZShsYXllck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJWaWV3KGxheWVyTmFtZSkuZWw7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgICAgICBjb25zdCB7IGVsLCBjaGlsZE5vZGVzLCBvcHRpb25zLCBzdHlsZXNoZWV0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHN2ZywgZGVmcywgbGF5ZXJzIH0gPSBjaGlsZE5vZGVzO1xuXG4gICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgc3ZnLnN0eWxlLm92ZXJmbG93ID0gb3B0aW9ucy5vdmVyZmxvdyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuXG4gICAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgICB0aGlzLmRlZnMgPSBkZWZzO1xuICAgICAgICB0aGlzLmxheWVycyA9IGxheWVycztcblxuICAgICAgICB0aGlzLnJlbmRlckxheWVycygpO1xuXG4gICAgICAgIFYuZW5zdXJlSWQoc3ZnKTtcblxuICAgICAgICB0aGlzLmFkZFN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChvcHRpb25zLmJhY2tncm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZHJhd0dyaWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0R3JpZChvcHRpb25zLmRyYXdHcmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRTdHlsZXNoZWV0OiBmdW5jdGlvbihjc3MpIHtcbiAgICAgICAgaWYgKCFjc3MpIHJldHVybjtcbiAgICAgICAgVih0aGlzLnN2ZykucHJlcGVuZChWLmNyZWF0ZVNWR1N0eWxlKGNzcykpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVMYXllcihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgY2FzZSBMYXllcnNOYW1lcy5HUklEOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR3JpZExheWVyKHsgbmFtZSwgcGFwZXI6IHRoaXMsIHBhdHRlcm5zOiB0aGlzLmNvbnN0cnVjdG9yLmdyaWRQYXR0ZXJucyB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXBlckxheWVyKHsgbmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJMYXllcnM6IGZ1bmN0aW9uKGxheWVycyA9IGRlZmF1bHRMYXllcnMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXllcnMoKTtcbiAgICAgICAgLy8gVE9ETzogTGF5ZXJzIHRvIGJlIHJlYWQgZnJvbSB0aGUgZ3JhcGggYGxheWVyc2AgYXR0cmlidXRlXG4gICAgICAgIGxheWVycy5mb3JFYWNoKCh7IG5hbWUsIHNvcnRlZCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYXllclZpZXcgPSB0aGlzLmNyZWF0ZUxheWVyKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5sYXllcnMuYXBwZW5kQ2hpbGQobGF5ZXJWaWV3LmVsKTtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyc1tuYW1lXSA9IGxheWVyVmlldztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRocm93cyBhbiBleGNlcHRpb24gaWYgZG9lc24ndCBleGlzdFxuICAgICAgICBjb25zdCBjZWxsc0xheWVyVmlldyA9IHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLkNFTExTKTtcbiAgICAgICAgY29uc3QgdG9vbHNMYXllclZpZXcgPSB0aGlzLmdldExheWVyVmlldyhMYXllcnNOYW1lcy5UT09MUyk7XG4gICAgICAgIGNvbnN0IGxhYmVsc0xheWVyVmlldyA9IHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLkxBQkVMUyk7XG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHRoaXMudG9vbHMgPSB0b29sc0xheWVyVmlldy5lbDtcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMudmlld3BvcnQgPSBjZWxsc0xheWVyVmlldy5lbDtcbiAgICAgICAgLy8gdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIGNlbGxzTGF5ZXJWaWV3LnZlbC5hZGRDbGFzcyhhZGRDbGFzc05hbWVQcmVmaXgoJ3ZpZXdwb3J0JykpO1xuICAgICAgICBsYWJlbHNMYXllclZpZXcudmVsLmFkZENsYXNzKGFkZENsYXNzTmFtZVByZWZpeCgndmlld3BvcnQnKSk7XG4gICAgICAgIGNlbGxzTGF5ZXJWaWV3LmVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGNlbGxzTGF5ZXJWaWV3LmVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGxhYmVsc0xheWVyVmlldy5lbC5zdHlsZS53ZWJraXRVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBsYWJlbHNMYXllclZpZXcuZWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBfbGF5ZXJzIH0gPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhfbGF5ZXJzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgX2xheWVyc1tuYW1lXS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfbGF5ZXJzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVzZXRMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IF9sYXllcnMgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKF9sYXllcnMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICBfbGF5ZXJzW25hbWVdLnJlbW92ZVBpdm90cygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAodGhpcy5fYmFja2dyb3VuZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2UodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjdG0gPSB0aGlzLm1hdHJpeCgpO1xuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKHN4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBWLm1hdHJpeFRvU2NhbGUoY3RtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgaWYgKHN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5ID0gc3g7XG4gICAgICAgIH1cbiAgICAgICAgc3ggPSBNYXRoLm1heChzeCB8fCAwLCB0aGlzLk1JTl9TQ0FMRSk7XG4gICAgICAgIHN5ID0gTWF0aC5tYXgoc3kgfHwgMCwgdGhpcy5NSU5fU0NBTEUpO1xuICAgICAgICBjdG0uYSA9IHN4O1xuICAgICAgICBjdG0uZCA9IHN5O1xuICAgICAgICB0aGlzLm1hdHJpeChjdG0sIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGVVbmlmb3JtQXRQb2ludDogZnVuY3Rpb24oc2NhbGUsIHBvaW50LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgYTogc3gsIGQ6IHN5LCBlOiB0eCwgZjogdHkgfSA9IHRoaXMubWF0cml4KCk7XG4gICAgICAgIHNjYWxlID0gTWF0aC5tYXgoc2NhbGUgfHwgMCwgdGhpcy5NSU5fU0NBTEUpO1xuICAgICAgICBpZiAoc2NhbGUgPT09IHN4ICYmIHNjYWxlID09PSBzeSkge1xuICAgICAgICAgICAgLy8gVGhlIHNjYWxlIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgdHggLSBwb2ludC54ICogKHNjYWxlIC0gc3gpLFxuICAgICAgICAgICAgICAgIHR5IC0gcG9pbnQueSAqIChzY2FsZSAtIHN5KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIHRoaXMubWF0cml4KG1hdHJpeCwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSwgZGF0YSkge1xuICAgICAgICBjb25zdCBjdG0gPSB0aGlzLm1hdHJpeCgpO1xuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKHR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBWLm1hdHJpeFRvVHJhbnNsYXRlKGN0bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHR4IHx8ICh0eCA9IDApO1xuICAgICAgICB0eSB8fCAodHkgPSAwKTtcbiAgICAgICAgaWYgKGN0bS5lID09PSB0eCAmJiBjdG0uZiA9PT0gdHkpIHJldHVybiB0aGlzO1xuICAgICAgICBjdG0uZSA9IHR4O1xuICAgICAgICBjdG0uZiA9IHR5O1xuICAgICAgICB0aGlzLm1hdHJpeChjdG0sIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbWF0cml4OiBmdW5jdGlvbihjdG0sIGRhdGEgPSB7fSkge1xuXG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMubGF5ZXJzO1xuXG4gICAgICAgIC8vIEdldHRlcjpcbiAgICAgICAgaWYgKGN0bSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1TdHJpbmcgPSB2aWV3cG9ydC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX3ZpZXdwb3J0VHJhbnNmb3JtU3RyaW5nIHx8IG51bGwpID09PSB0cmFuc2Zvcm1TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIG9rIHRvIHJldHVybiB0aGUgY2FjaGVkIG1hdHJpeC4gVGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaGFzIG5vdCBjaGFuZ2VkIHNpbmNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIG1hdHJpeCB3YXMgc3RvcmVkLlxuICAgICAgICAgICAgICAgIGN0bSA9IHRoaXMuX3ZpZXdwb3J0TWF0cml4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdmlld3BvcnQgdHJhbnNmb3JtIGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC4gTWVhc3VyZSB0aGUgbWF0cml4IGFuZCBjYWNoZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjdG0gPSB2aWV3cG9ydC5nZXRDVE0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydE1hdHJpeCA9IGN0bTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydFRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVN0cmluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGNhY2hlZCBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICAgICAgICAgIC8vIElmIG5vIG1hdHJpeCBwcmV2aW91c2x5IHN0b3JlZCB0aGUgaWRlbnRpdHkgbWF0cml4IGlzIHJldHVybmVkLlxuICAgICAgICAgICAgcmV0dXJuIFYuY3JlYXRlU1ZHTWF0cml4KGN0bSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR0ZXI6XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hdHJpeCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gVi5jcmVhdGVTVkdNYXRyaXgoY3RtKTtcbiAgICAgICAgY29uc3QgY3VycmVudFRyYW5zZm9ybVN0cmluZyA9IHRoaXMuX3ZpZXdwb3J0VHJhbnNmb3JtU3RyaW5nO1xuICAgICAgICBjb25zdCBjdG1TdHJpbmcgPSBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKGN1cnJlbnQpO1xuICAgICAgICBpZiAoY3RtU3RyaW5nID09PSBjdXJyZW50VHJhbnNmb3JtU3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IHRyYW5zZm9ybSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1cGRhdGUgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRUcmFuc2Zvcm1TdHJpbmcgJiYgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZygpID09PSBjdG1TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IHRyYW5zZm9ybSBzdHJpbmcgaXMgZW1wdHkgYW5kIHRoZSBuZXcgb25lIGlzIGFuIGlkZW50aXR5IG1hdHJpeC5cbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGEsIGQsIGUsIGYgfSA9IGN1cnJlbnQ7XG5cbiAgICAgICAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBjdG1TdHJpbmcpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydE1hdHJpeCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0VHJhbnNmb3JtU3RyaW5nID0gdmlld3BvcnQuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcblxuICAgICAgICAvLyBzY2FsZSBldmVudFxuICAgICAgICBpZiAoYSAhPT0gcHJldi5hIHx8IGQgIT09IHByZXYuZCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzY2FsZScsIGEsIGQsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJhbnNsYXRlIGV2ZW50XG4gICAgICAgIGlmIChlICE9PSBwcmV2LmUgfHwgZiAhPT0gcHJldi5mKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZScsIGUsIGYsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0cmFuc2Zvcm0nLCBjdXJyZW50LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsaWVudE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIFYuY3JlYXRlU1ZHTWF0cml4KHRoaXMuY2VsbHMuZ2V0U2NyZWVuQ1RNKCkpO1xuICAgIH0sXG5cbiAgICByZXF1ZXN0Q29ubmVjdGVkTGlua3NVcGRhdGU6IGZ1bmN0aW9uKHZpZXcsIHByaW9yaXR5LCBvcHQpIHtcbiAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBDZWxsVmlldykge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdmlldy5tb2RlbDtcbiAgICAgICAgICAgIHZhciBsaW5rcyA9IHRoaXMubW9kZWwuZ2V0Q29ubmVjdGVkTGlua3MobW9kZWwpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IGxpbmtzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rVmlldyA9IHRoaXMuZmluZFZpZXdCeU1vZGVsKGxpbmspO1xuICAgICAgICAgICAgICAgIGlmICghbGlua1ZpZXcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhciBmbGFnTGFiZWxzID0gWydVUERBVEUnXTtcbiAgICAgICAgICAgICAgICBpZiAobGluay5nZXRUYXJnZXRDZWxsKCkgPT09IG1vZGVsKSBmbGFnTGFiZWxzLnB1c2goJ1RBUkdFVCcpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rLmdldFNvdXJjZUNlbGwoKSA9PT0gbW9kZWwpIGZsYWdMYWJlbHMucHVzaCgnU09VUkNFJyk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRQcmlvcml0eSA9IE1hdGgubWF4KHByaW9yaXR5ICsgMSwgbGlua1ZpZXcuVVBEQVRFX1BSSU9SSVRZKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlVmlld1VwZGF0ZShsaW5rVmlldywgbGlua1ZpZXcuZ2V0RmxhZyhmbGFnTGFiZWxzKSwgbmV4dFByaW9yaXR5LCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZvcmNlUG9zdHBvbmVkVmlld1VwZGF0ZTogZnVuY3Rpb24odmlldywgZmxhZykge1xuICAgICAgICBpZiAoIXZpZXcgfHwgISh2aWV3IGluc3RhbmNlb2YgQ2VsbFZpZXcpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBtb2RlbCA9IHZpZXcubW9kZWw7XG4gICAgICAgIGlmIChtb2RlbC5pc0VsZW1lbnQoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoKGZsYWcgJiB2aWV3LmdldEZsYWcoWydTT1VSQ0UnLCAnVEFSR0VUJ10pKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGR1bXBPcHRpb25zID0geyBzaWxlbnQ6IHRydWUgfTtcbiAgICAgICAgICAgIC8vIExpbmtWaWV3IGlzIHdhaXRpbmcgZm9yIHRoZSB0YXJnZXQgb3IgdGhlIHNvdXJjZSBjZWxsVmlldyB0byBiZSByZW5kZXJlZFxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIGNlbGxzIGFyZSBub3QgaW4gdGhlIHZpZXdwb3J0LlxuICAgICAgICAgICAgdmFyIHNvdXJjZUZsYWcgPSAwO1xuICAgICAgICAgICAgdmFyIHNvdXJjZVZpZXcgPSB0aGlzLmZpbmRWaWV3QnlNb2RlbChtb2RlbC5nZXRTb3VyY2VDZWxsKCkpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZVZpZXcgJiYgIXRoaXMuaXNWaWV3TW91bnRlZChzb3VyY2VWaWV3KSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUZsYWcgPSB0aGlzLmR1bXBWaWV3KHNvdXJjZVZpZXcsIGR1bXBPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZUVuZE1hZ25ldCgnc291cmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RmxhZyA9IDA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0VmlldyA9IHRoaXMuZmluZFZpZXdCeU1vZGVsKG1vZGVsLmdldFRhcmdldENlbGwoKSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0VmlldyAmJiAhdGhpcy5pc1ZpZXdNb3VudGVkKHRhcmdldFZpZXcpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RmxhZyA9IHRoaXMuZHVtcFZpZXcodGFyZ2V0VmlldywgZHVtcE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlRW5kTWFnbmV0KCd0YXJnZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VGbGFnID09PSAwICYmIHRhcmdldEZsYWcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBsZWZ0b3ZlciBmbGFnIGlzIDAsIGFsbCB2aWV3IHVwZGF0ZXMgd2VyZSBkb25lLlxuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5kdW1wVmlldyh2aWV3LCBkdW1wT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXF1ZXN0Vmlld1VwZGF0ZTogZnVuY3Rpb24odmlldywgZmxhZywgcHJpb3JpdHksIG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVZpZXdVcGRhdGUodmlldywgZmxhZywgcHJpb3JpdHksIG9wdCk7XG4gICAgICAgIHZhciBpc0FzeW5jID0gdGhpcy5pc0FzeW5jKCk7XG4gICAgICAgIGlmICh0aGlzLmlzRnJvemVuKCkgfHwgKGlzQXN5bmMgJiYgb3B0LmFzeW5jICE9PSBmYWxzZSkpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuaGFzQWN0aXZlQmF0Y2godGhpcy5VUERBVEVfREVMQVlJTkdfQkFUQ0hFUykpIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXRzID0gdGhpcy51cGRhdGVWaWV3cyhvcHQpO1xuICAgICAgICBpZiAoaXNBc3luYykgdGhpcy5ub3RpZnlBZnRlclJlbmRlcihzdGF0cywgb3B0KTtcbiAgICB9LFxuXG4gICAgc2NoZWR1bGVWaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCB0eXBlLCBwcmlvcml0eSwgb3B0KSB7XG4gICAgICAgIGNvbnN0IHsgX3VwZGF0ZXM6IHVwZGF0ZXMsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICh1cGRhdGVzLmlkbGUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9GcmVlemUpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLmlkbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuZnJlZXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBGTEFHX1JFTU9WRSwgRkxBR19JTlNFUlQsIFVQREFURV9QUklPUklUWSwgY2lkIH0gPSB2aWV3O1xuICAgICAgICBsZXQgcHJpb3JpdHlVcGRhdGVzID0gdXBkYXRlcy5wcmlvcml0aWVzW3ByaW9yaXR5XTtcbiAgICAgICAgaWYgKCFwcmlvcml0eVVwZGF0ZXMpIHByaW9yaXR5VXBkYXRlcyA9IHVwZGF0ZXMucHJpb3JpdGllc1twcmlvcml0eV0gPSB7fTtcbiAgICAgICAgLy8gTW92ZSBoaWdoZXIgcHJpb3JpdHkgdXBkYXRlcyB0byB0aGlzIHByaW9yaXR5XG4gICAgICAgIGlmIChwcmlvcml0eSA+IFVQREFURV9QUklPUklUWSkge1xuICAgICAgICAgICAgLy8gTm90IHRoZSBkZWZhdWx0IHByaW9yaXR5IGZvciB0aGlzIHZpZXcuIEl0J3MgbW9zdCBsaWtlbHkgYSBsaW5rIHZpZXdcbiAgICAgICAgICAgIC8vIGNvbm5lY3RlZCB0byBhbm90aGVyIGxpbmsgdmlldywgd2hpY2ggdHJpZ2dlcmVkIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICAvLyBUT0RPOiBJZiB0aGVyZSBpcyBhbiB1cGRhdGUgc2NoZWR1bGVkIHdpdGggYSBsb3dlciBwcmlvcml0eSBhbHJlYWR5LCB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgcmVxdWVzdGVkIHByaW9yaXR5IHRvIHRoZSBsb3dlc3Qgb25lLiBEb2VzIG5vdCBzZWVtIHRvIGJlIGNyaXRpY2FsXG4gICAgICAgICAgICAvLyByaWdodCBub3csIGFzIGl0IFwib25seVwiIHJlc3VsdHMgaW4gbXVsdGlwbGUgdXBkYXRlcyBvbiB0aGUgc2FtZSB2aWV3LlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByaW9yaXR5IC0gMTsgaSA+PSBVUERBVEVfUFJJT1JJVFk7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZQcmlvcml0eVVwZGF0ZXMgPSB1cGRhdGVzLnByaW9yaXRpZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2UHJpb3JpdHlVcGRhdGVzIHx8ICEoY2lkIGluIHByZXZQcmlvcml0eVVwZGF0ZXMpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBwcmlvcml0eVVwZGF0ZXNbY2lkXSB8PSBwcmV2UHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByZXZQcmlvcml0eVVwZGF0ZXNbY2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudFR5cGUgPSBwcmlvcml0eVVwZGF0ZXNbY2lkXSB8fCAwO1xuICAgICAgICAvLyBQcmV2ZW50IGN5Y2xpbmdcbiAgICAgICAgaWYgKChjdXJyZW50VHlwZSAmIHR5cGUpID09PSB0eXBlKSByZXR1cm47XG4gICAgICAgIGlmICghY3VycmVudFR5cGUpIHVwZGF0ZXMuY291bnQrKztcbiAgICAgICAgaWYgKHR5cGUgJiBGTEFHX1JFTU9WRSAmJiBjdXJyZW50VHlwZSAmIEZMQUdfSU5TRVJUKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgdmlldyBpcyByZW1vdmVkIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBpbnNlcnQgZmxhZyBhcyB0aGlzIGlzIGEgcmVpbnNlcnRcbiAgICAgICAgICAgIHByaW9yaXR5VXBkYXRlc1tjaWRdIF49IEZMQUdfSU5TRVJUO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgJiBGTEFHX0lOU0VSVCAmJiBjdXJyZW50VHlwZSAmIEZMQUdfUkVNT1ZFKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgdmlldyBpcyBhZGRlZCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgcmVtb3ZlIGZsYWcgYXMgdGhpcyBpcyB2aWV3IHdhcyBwcmV2aW91c2x5IHJlbW92ZWRcbiAgICAgICAgICAgIHByaW9yaXR5VXBkYXRlc1tjaWRdIF49IEZMQUdfUkVNT1ZFO1xuICAgICAgICB9XG4gICAgICAgIHByaW9yaXR5VXBkYXRlc1tjaWRdIHw9IHR5cGU7XG4gICAgICAgIGNvbnN0IHZpZXdVcGRhdGVGbiA9IG9wdGlvbnMub25WaWV3VXBkYXRlO1xuICAgICAgICBpZiAodHlwZW9mIHZpZXdVcGRhdGVGbiA9PT0gJ2Z1bmN0aW9uJykgdmlld1VwZGF0ZUZuLmNhbGwodGhpcywgdmlldywgdHlwZSwgcHJpb3JpdHksIG9wdCB8fCB7fSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGR1bXBWaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuIDA7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIGNpZCA9IHZpZXcuY2lkO1xuICAgICAgICB2YXIgcHJpb3JpdHlVcGRhdGVzID0gdXBkYXRlcy5wcmlvcml0aWVzW3ZpZXcuVVBEQVRFX1BSSU9SSVRZXTtcbiAgICAgICAgdmFyIGZsYWcgPSB0aGlzLnJlZ2lzdGVyTW91bnRlZFZpZXcodmlldykgfCBwcmlvcml0eVVwZGF0ZXNbY2lkXTtcbiAgICAgICAgZGVsZXRlIHByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9LFxuXG4gICAgZHVtcFZpZXc6IGZ1bmN0aW9uKHZpZXcsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZsYWcgPSB0aGlzLmR1bXBWaWV3VXBkYXRlKHZpZXcpO1xuICAgICAgICBpZiAoIWZsYWcpIHJldHVybiAwO1xuICAgICAgICBjb25zdCBzaG91bGROb3RpZnkgPSAhb3B0LnNpbGVudDtcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeSkgdGhpcy5ub3RpZnlCZWZvcmVSZW5kZXIob3B0KTtcbiAgICAgICAgY29uc3QgbGVmdG92ZXIgPSB0aGlzLnVwZGF0ZVZpZXcodmlldywgZmxhZywgb3B0KTtcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHMgPSB7IHVwZGF0ZWQ6IDEsIHByaW9yaXR5OiB2aWV3LlVQREFURV9QUklPUklUWSB9O1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlBZnRlclJlbmRlcihzdGF0cywgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdG92ZXI7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZpZXc6IGZ1bmN0aW9uKHZpZXcsIGZsYWcsIG9wdCkge1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybiAwO1xuICAgICAgICBjb25zdCB7IEZMQUdfUkVNT1ZFLCBGTEFHX0lOU0VSVCwgRkxBR19JTklULCBtb2RlbCB9ID0gdmlldztcbiAgICAgICAgaWYgKHZpZXcgaW5zdGFuY2VvZiBDZWxsVmlldykge1xuICAgICAgICAgICAgaWYgKGZsYWcgJiBGTEFHX1JFTU9WRSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVmlldyhtb2RlbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZyAmIEZMQUdfSU5TRVJUKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbml0aWFsSW5zZXJ0ID0gISEoZmxhZyAmIEZMQUdfSU5JVCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbEluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnIF49IEZMQUdfSU5JVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRWaWV3KHZpZXcsIGlzSW5pdGlhbEluc2VydCk7XG4gICAgICAgICAgICAgICAgZmxhZyBePSBGTEFHX0lOU0VSVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsYWcpIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gdmlldy5jb25maXJtVXBkYXRlKGZsYWcsIG9wdCB8fCB7fSk7XG4gICAgfSxcblxuICAgIHJlcXVpcmVWaWV3OiBmdW5jdGlvbihtb2RlbCwgb3B0KSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwobW9kZWwpO1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLmR1bXBWaWV3KHZpZXcsIG9wdCk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG5cbiAgICByZWdpc3RlclVubW91bnRlZFZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgdmFyIGNpZCA9IHZpZXcuY2lkO1xuICAgICAgICB2YXIgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIGlmIChjaWQgaW4gdXBkYXRlcy51bm1vdW50ZWQpIHJldHVybiAwO1xuICAgICAgICB2YXIgZmxhZyA9IHVwZGF0ZXMudW5tb3VudGVkW2NpZF0gfD0gdmlldy5GTEFHX0lOU0VSVDtcbiAgICAgICAgdXBkYXRlcy51bm1vdW50ZWRDaWRzLnB1c2goY2lkKTtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZXMubW91bnRlZFtjaWRdO1xuICAgICAgICByZXR1cm4gZmxhZztcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJNb3VudGVkVmlldzogZnVuY3Rpb24odmlldykge1xuICAgICAgICB2YXIgY2lkID0gdmlldy5jaWQ7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgaWYgKGNpZCBpbiB1cGRhdGVzLm1vdW50ZWQpIHJldHVybiAwO1xuICAgICAgICB1cGRhdGVzLm1vdW50ZWRbY2lkXSA9IHRydWU7XG4gICAgICAgIHVwZGF0ZXMubW91bnRlZENpZHMucHVzaChjaWQpO1xuICAgICAgICB2YXIgZmxhZyA9IHVwZGF0ZXMudW5tb3VudGVkW2NpZF0gfHwgMDtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZXMudW5tb3VudGVkW2NpZF07XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICBpc1ZpZXdNb3VudGVkOiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY2lkID0gdmlldy5jaWQ7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgcmV0dXJuIChjaWQgaW4gdXBkYXRlcy5tb3VudGVkKTtcbiAgICB9LFxuXG4gICAgZHVtcFZpZXdzOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdmFyIHBhc3NpbmdPcHQgPSBkZWZhdWx0cyh7fSwgb3B0LCB7IHZpZXdwb3J0OiBudWxsIH0pO1xuICAgICAgICB0aGlzLmNoZWNrVmlld3BvcnQocGFzc2luZ09wdCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlld3MocGFzc2luZ09wdCk7XG4gICAgfSxcblxuICAgIC8vIFN5bmNocm9ub3VzIHZpZXdzIHVwZGF0ZVxuICAgIHVwZGF0ZVZpZXdzOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlCZWZvcmVSZW5kZXIob3B0KTtcbiAgICAgICAgbGV0IGJhdGNoU3RhdHM7XG4gICAgICAgIGxldCB1cGRhdGVDb3VudCA9IDA7XG4gICAgICAgIGxldCBiYXRjaENvdW50ID0gMDtcbiAgICAgICAgbGV0IHByaW9yaXR5ID0gTUlOX1BSSU9SSVRZO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBiYXRjaENvdW50Kys7XG4gICAgICAgICAgICBiYXRjaFN0YXRzID0gdGhpcy51cGRhdGVWaWV3c0JhdGNoKG9wdCk7XG4gICAgICAgICAgICB1cGRhdGVDb3VudCArPSBiYXRjaFN0YXRzLnVwZGF0ZWQ7XG4gICAgICAgICAgICBwcmlvcml0eSA9IE1hdGgubWluKGJhdGNoU3RhdHMucHJpb3JpdHksIHByaW9yaXR5KTtcbiAgICAgICAgfSB3aGlsZSAoIWJhdGNoU3RhdHMuZW1wdHkpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHsgdXBkYXRlZDogdXBkYXRlQ291bnQsIGJhdGNoZXM6IGJhdGNoQ291bnQsIHByaW9yaXR5IH07XG4gICAgICAgIHRoaXMubm90aWZ5QWZ0ZXJSZW5kZXIoc3RhdHMsIG9wdCk7XG4gICAgICAgIHJldHVybiBzdGF0cztcbiAgICB9LFxuXG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHByaW9yaXRpZXMgPSB0aGlzLl91cGRhdGVzLnByaW9yaXRpZXM7XG4gICAgICAgIGNvbnN0IHByaW9yaXR5SW5kZXhlcyA9IE9iamVjdC5rZXlzKHByaW9yaXRpZXMpOyAvLyBjb252ZXJ0IHByaW9yaXRpZXMgdG8gYSBkZW5zZSBhcnJheVxuICAgICAgICBsZXQgaSA9IHByaW9yaXR5SW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiBpLS0pIHtcbiAgICAgICAgICAgIC8vIGEgZmFzdGVyIHdheSBob3cgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICAgICAgICBmb3IgKGxldCBfa2V5IGluIHByaW9yaXRpZXNbcHJpb3JpdHlJbmRleGVzW2ldXSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICB1cGRhdGVWaWV3c0FzeW5jOiBmdW5jdGlvbihvcHQsIGRhdGEpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSB7IHByb2Nlc3NlZDogMCwgcHJpb3JpdHk6IE1JTl9QUklPUklUWSB9KTtcbiAgICAgICAgY29uc3QgeyBfdXBkYXRlczogdXBkYXRlcywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaWQgPSB1cGRhdGVzLmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNhbmNlbEZyYW1lKGlkKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnByb2Nlc3NlZCA9PT0gMCAmJiB0aGlzLmhhc1NjaGVkdWxlZFVwZGF0ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5QmVmb3JlUmVuZGVyKG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMudXBkYXRlVmlld3NCYXRjaChvcHQpO1xuICAgICAgICAgICAgY29uc3QgcGFzc2luZ09wdCA9IGRlZmF1bHRzKHt9LCBvcHQsIHtcbiAgICAgICAgICAgICAgICBtb3VudEJhdGNoU2l6ZTogTU9VTlRfQkFUQ0hfU0laRSAtIHN0YXRzLm1vdW50ZWQsXG4gICAgICAgICAgICAgICAgdW5tb3VudEJhdGNoU2l6ZTogTU9VTlRfQkFUQ0hfU0laRSAtIHN0YXRzLnVubW91bnRlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjaGVja1N0YXRzID0gdGhpcy5jaGVja1ZpZXdwb3J0KHBhc3NpbmdPcHQpO1xuICAgICAgICAgICAgY29uc3QgdW5tb3VudENvdW50ID0gY2hlY2tTdGF0cy51bm1vdW50ZWQ7XG4gICAgICAgICAgICBjb25zdCBtb3VudENvdW50ID0gY2hlY2tTdGF0cy5tb3VudGVkO1xuICAgICAgICAgICAgbGV0IHByb2Nlc3NlZCA9IGRhdGEucHJvY2Vzc2VkO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSB1cGRhdGVzLmNvdW50O1xuICAgICAgICAgICAgaWYgKHN0YXRzLnVwZGF0ZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSB1cGRhdGVzIGhhdmUgYmVlbiBqdXN0IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZCArPSBzdGF0cy51cGRhdGVkICsgc3RhdHMudW5tb3VudGVkO1xuICAgICAgICAgICAgICAgIHN0YXRzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcbiAgICAgICAgICAgICAgICBkYXRhLnByaW9yaXR5ID0gTWF0aC5taW4oc3RhdHMucHJpb3JpdHksIGRhdGEucHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0cy5lbXB0eSAmJiBtb3VudENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnVubW91bnRlZCArPSB1bm1vdW50Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLm1vdW50ZWQgKz0gbW91bnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMucHJpb3JpdHkgPSBkYXRhLnByaW9yaXR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUFmdGVyUmVuZGVyKHN0YXRzLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnByb2Nlc3NlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJpb3JpdHkgPSBNSU5fUFJJT1JJVFk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMuY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJvY2Vzc2VkID0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVzLmlkbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0ZyZWV6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMuaWRsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbmRlcjppZGxlJywgb3B0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2dyZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzc0ZuID0gb3B0LnByb2dyZXNzO1xuICAgICAgICAgICAgaWYgKHRvdGFsICYmIHR5cGVvZiBwcm9ncmVzc0ZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NGbi5jYWxsKHRoaXMsIHN0YXRzLmVtcHR5LCBwcm9jZXNzZWQsIHRvdGFsLCBzdGF0cywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY3VycmVudCBmcmFtZSBjb3VsZCBoYXZlIGJlZW4gY2FuY2VsZWQgaW4gYSBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXMuaWQgIT09IGlkKSByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLlBhcGVyOiBjYW4gbm90IHVuZnJlZXplIHRoZSBwYXBlciBhZnRlciBpdCB3YXMgcmVtb3ZlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZXMuaWQgPSBuZXh0RnJhbWUodGhpcy51cGRhdGVWaWV3c0FzeW5jLCB0aGlzLCBvcHQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBub3RpZnlCZWZvcmVSZW5kZXI6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG4gICAgICAgIGxldCBiZWZvcmVGbiA9IG9wdC5iZWZvcmVSZW5kZXI7XG4gICAgICAgIGlmICh0eXBlb2YgYmVmb3JlRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGJlZm9yZUZuID0gdGhpcy5vcHRpb25zLmJlZm9yZVJlbmRlcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVmb3JlRm4gIT09ICdmdW5jdGlvbicpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVGbi5jYWxsKHRoaXMsIG9wdCwgdGhpcyk7XG4gICAgfSxcblxuICAgIG5vdGlmeUFmdGVyUmVuZGVyOiBmdW5jdGlvbihzdGF0cywgb3B0ID0ge30pIHtcbiAgICAgICAgbGV0IGFmdGVyRm4gPSBvcHQuYWZ0ZXJSZW5kZXI7XG4gICAgICAgIGlmICh0eXBlb2YgYWZ0ZXJGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWZ0ZXJGbiA9IHRoaXMub3B0aW9ucy5hZnRlclJlbmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFmdGVyRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFmdGVyRm4uY2FsbCh0aGlzLCBzdGF0cywgb3B0LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbmRlcjpkb25lJywgc3RhdHMsIG9wdCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZpZXdzQmF0Y2g6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IG9wdC5iYXRjaFNpemUgfHwgVVBEQVRFX0JBVENIX1NJWkU7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIHVwZGF0ZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIHBvc3Rwb25lQ291bnQgPSAwO1xuICAgICAgICB2YXIgdW5tb3VudENvdW50ID0gMDtcbiAgICAgICAgdmFyIG1vdW50Q291bnQgPSAwO1xuICAgICAgICB2YXIgbWF4UHJpb3JpdHkgPSBNSU5fUFJJT1JJVFk7XG4gICAgICAgIHZhciBlbXB0eSA9IHRydWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgcHJpb3JpdGllcyA9IHVwZGF0ZXMucHJpb3JpdGllcztcbiAgICAgICAgdmFyIHZpZXdwb3J0Rm4gPSAndmlld3BvcnQnIGluIG9wdCA/IG9wdC52aWV3cG9ydCA6IG9wdGlvbnMudmlld3BvcnQ7XG4gICAgICAgIGlmICh0eXBlb2Ygdmlld3BvcnRGbiAhPT0gJ2Z1bmN0aW9uJykgdmlld3BvcnRGbiA9IG51bGw7XG4gICAgICAgIHZhciBwb3N0cG9uZVZpZXdGbiA9IG9wdGlvbnMub25WaWV3UG9zdHBvbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHBvc3Rwb25lVmlld0ZuICE9PSAnZnVuY3Rpb24nKSBwb3N0cG9uZVZpZXdGbiA9IG51bGw7XG4gICAgICAgIHZhciBwcmlvcml0eUluZGV4ZXMgPSBPYmplY3Qua2V5cyhwcmlvcml0aWVzKTsgLy8gY29udmVydCBwcmlvcml0aWVzIHRvIGEgZGVuc2UgYXJyYXlcbiAgICAgICAgbWFpbjogZm9yICh2YXIgaSA9IDAsIG4gPSBwcmlvcml0eUluZGV4ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdHkgPSArcHJpb3JpdHlJbmRleGVzW2ldO1xuICAgICAgICAgICAgdmFyIHByaW9yaXR5VXBkYXRlcyA9IHByaW9yaXRpZXNbcHJpb3JpdHldO1xuICAgICAgICAgICAgZm9yICh2YXIgY2lkIGluIHByaW9yaXR5VXBkYXRlcykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVDb3VudCA+PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgbWFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSB2aWV3c1tjaWRdO1xuICAgICAgICAgICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3Qgb2NjdXJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRGbGFnID0gcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50RmxhZyAmIHZpZXcuRkxBR19SRU1PVkUpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBjaGVjayBhIHZpZXcgZm9yIHZpZXdwb3J0IGlmIHdlIGFyZSBhYm91dCB0byByZW1vdmUgdGhlIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRGV0YWNoZWQgPSBjaWQgaW4gdXBkYXRlcy51bm1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3LkRFVEFDSEFCTEUgJiYgdmlld3BvcnRGbiAmJiAhdmlld3BvcnRGbi5jYWxsKHRoaXMsIHZpZXcsICFpc0RldGFjaGVkLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5tb3VudCBWaWV3XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVW5tb3VudGVkVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGFjaFZpZXcodmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzLnVubW91bnRlZFtjaWRdIHw9IGN1cnJlbnRGbGFnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBNb3VudCBWaWV3XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RldGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RmxhZyB8PSB2aWV3LkZMQUdfSU5TRVJUO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91bnRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGbGFnIHw9IHRoaXMucmVnaXN0ZXJNb3VudGVkVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRvdmVyRmxhZyA9IHRoaXMudXBkYXRlVmlldyh2aWV3LCBjdXJyZW50RmxhZywgb3B0KTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdG92ZXJGbGFnID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWaWV3IHVwZGF0ZSBoYXMgbm90IGZpbmlzaGVkIGNvbXBsZXRlbHlcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gPSBsZWZ0b3ZlckZsYWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zdHBvbmVWaWV3Rm4gfHwgIXBvc3Rwb25lVmlld0ZuLmNhbGwodGhpcywgdmlldywgbGVmdG92ZXJGbGFnLCB0aGlzKSB8fCBwcmlvcml0eVVwZGF0ZXNbY2lkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXhQcmlvcml0eSA+IHByaW9yaXR5KSBtYXhQcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmlvcml0eTogbWF4UHJpb3JpdHksXG4gICAgICAgICAgICB1cGRhdGVkOiB1cGRhdGVDb3VudCxcbiAgICAgICAgICAgIHBvc3Rwb25lZDogcG9zdHBvbmVDb3VudCxcbiAgICAgICAgICAgIHVubW91bnRlZDogdW5tb3VudENvdW50LFxuICAgICAgICAgICAgbW91bnRlZDogbW91bnRDb3VudCxcbiAgICAgICAgICAgIGVtcHR5OiBlbXB0eVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRVbm1vdW50ZWRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICBjb25zdCB1bm1vdW50ZWRDaWRzID0gT2JqZWN0LmtleXModXBkYXRlcy51bm1vdW50ZWQpO1xuICAgICAgICBjb25zdCBuID0gdW5tb3VudGVkQ2lkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHVubW91bnRlZFZpZXdzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdW5tb3VudGVkVmlld3NbaV0gPSB2aWV3c1t1bm1vdW50ZWRDaWRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5tb3VudGVkVmlld3M7XG4gICAgfSxcblxuICAgIGdldE1vdW50ZWRWaWV3czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICBjb25zdCBtb3VudGVkQ2lkcyA9IE9iamVjdC5rZXlzKHVwZGF0ZXMubW91bnRlZCk7XG4gICAgICAgIGNvbnN0IG4gPSBtb3VudGVkQ2lkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1vdW50ZWRWaWV3cyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIG1vdW50ZWRWaWV3c1tpXSA9IHZpZXdzW21vdW50ZWRDaWRzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW91bnRlZFZpZXdzO1xuICAgIH0sXG5cbiAgICBjaGVja1VubW91bnRlZFZpZXdzOiBmdW5jdGlvbih2aWV3cG9ydEZuLCBvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgID0ge30pO1xuICAgICAgICB2YXIgbW91bnRDb3VudCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygdmlld3BvcnRGbiAhPT0gJ2Z1bmN0aW9uJykgdmlld3BvcnRGbiA9IG51bGw7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSAnbW91bnRCYXRjaFNpemUnIGluIG9wdCA/IG9wdC5tb3VudEJhdGNoU2l6ZSA6IEluZmluaXR5O1xuICAgICAgICB2YXIgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIHZhciB1bm1vdW50ZWRDaWRzID0gdXBkYXRlcy51bm1vdW50ZWRDaWRzO1xuICAgICAgICB2YXIgdW5tb3VudGVkID0gdXBkYXRlcy51bm1vdW50ZWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gTWF0aC5taW4odW5tb3VudGVkQ2lkcy5sZW5ndGgsIGJhdGNoU2l6ZSk7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaWQgPSB1bm1vdW50ZWRDaWRzW2ldO1xuICAgICAgICAgICAgaWYgKCEoY2lkIGluIHVubW91bnRlZCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB2aWV3c1tjaWRdO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICh2aWV3LkRFVEFDSEFCTEUgJiYgdmlld3BvcnRGbiAmJiAhdmlld3BvcnRGbi5jYWxsKHRoaXMsIHZpZXcsIGZhbHNlLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIC8vIFB1c2ggYXQgdGhlIGVuZCBvZiBhbGwgdW5tb3VudGVkIGlkcywgc28gdGhpcyBjYW4gYmUgY2hlY2sgbGF0ZXIgYWdhaW5cbiAgICAgICAgICAgICAgICB1bm1vdW50ZWRDaWRzLnB1c2goY2lkKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vdW50Q291bnQrKztcbiAgICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5yZWdpc3Rlck1vdW50ZWRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgaWYgKGZsYWcpIHRoaXMuc2NoZWR1bGVWaWV3VXBkYXRlKHZpZXcsIGZsYWcsIHZpZXcuVVBEQVRFX1BSSU9SSVRZLCB7IG1vdW50aW5nOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByaWQgb2Ygdmlld3MsIHRoYXQgaGF2ZSBiZWVuIG1vdW50ZWRcbiAgICAgICAgdW5tb3VudGVkQ2lkcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybiBtb3VudENvdW50O1xuICAgIH0sXG5cbiAgICBjaGVja01vdW50ZWRWaWV3czogZnVuY3Rpb24odmlld3BvcnRGbiwgb3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB2YXIgdW5tb3VudENvdW50ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydEZuICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gdW5tb3VudENvdW50O1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gJ3VubW91bnRCYXRjaFNpemUnIGluIG9wdCA/IG9wdC51bm1vdW50QmF0Y2hTaXplIDogSW5maW5pdHk7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIG1vdW50ZWRDaWRzID0gdXBkYXRlcy5tb3VudGVkQ2lkcztcbiAgICAgICAgdmFyIG1vdW50ZWQgPSB1cGRhdGVzLm1vdW50ZWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gTWF0aC5taW4obW91bnRlZENpZHMubGVuZ3RoLCBiYXRjaFNpemUpOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2lkID0gbW91bnRlZENpZHNbaV07XG4gICAgICAgICAgICBpZiAoIShjaWQgaW4gbW91bnRlZCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB2aWV3c1tjaWRdO1xuICAgICAgICAgICAgaWYgKCF2aWV3KSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghdmlldy5ERVRBQ0hBQkxFIHx8IHZpZXdwb3J0Rm4uY2FsbCh0aGlzLCB2aWV3LCB0cnVlLCB0aGlzKSkge1xuICAgICAgICAgICAgICAgIC8vIFB1c2ggYXQgdGhlIGVuZCBvZiBhbGwgbW91bnRlZCBpZHMsIHNvIHRoaXMgY2FuIGJlIGNoZWNrIGxhdGVyIGFnYWluXG4gICAgICAgICAgICAgICAgbW91bnRlZENpZHMucHVzaChjaWQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5tb3VudENvdW50Kys7XG4gICAgICAgICAgICB2YXIgZmxhZyA9IHRoaXMucmVnaXN0ZXJVbm1vdW50ZWRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgaWYgKGZsYWcpIHRoaXMuZGV0YWNoVmlldyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgcmlkIG9mIHZpZXdzLCB0aGF0IGhhdmUgYmVlbiB1bm1vdW50ZWRcbiAgICAgICAgbW91bnRlZENpZHMuc3BsaWNlKDAsIGkpO1xuICAgICAgICByZXR1cm4gdW5tb3VudENvdW50O1xuICAgIH0sXG5cbiAgICBjaGVja1ZpZXdWaXNpYmlsaXR5OiBmdW5jdGlvbihjZWxsVmlldywgb3B0ID0ge30pIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0Rm4gPSAndmlld3BvcnQnIGluIG9wdCA/IG9wdC52aWV3cG9ydCA6IHRoaXMub3B0aW9ucy52aWV3cG9ydDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydEZuICE9PSAnZnVuY3Rpb24nKSB2aWV3cG9ydEZuID0gbnVsbDtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIGNvbnN0IHsgbW91bnRlZCwgdW5tb3VudGVkIH0gPSB1cGRhdGVzO1xuICAgICAgICBjb25zdCB2aXNpYmxlID0gIWNlbGxWaWV3LkRFVEFDSEFCTEUgfHwgIXZpZXdwb3J0Rm4gfHwgdmlld3BvcnRGbi5jYWxsKHRoaXMsIGNlbGxWaWV3LCBmYWxzZSwgdGhpcyk7XG5cbiAgICAgICAgbGV0IGlzVW5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc01vdW50ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoY2VsbFZpZXcuY2lkIGluIG1vdW50ZWQgJiYgIXZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSB0aGlzLnJlZ2lzdGVyVW5tb3VudGVkVmlldyhjZWxsVmlldyk7XG4gICAgICAgICAgICBpZiAoZmxhZykgdGhpcy5kZXRhY2hWaWV3KGNlbGxWaWV3KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB1cGRhdGVzLm1vdW50ZWRDaWRzLmluZGV4T2YoY2VsbFZpZXcuY2lkKTtcbiAgICAgICAgICAgIHVwZGF0ZXMubW91bnRlZENpZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1VubW91bnRlZCAmJiBjZWxsVmlldy5jaWQgaW4gdW5tb3VudGVkICYmIHZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB1cGRhdGVzLnVubW91bnRlZENpZHMuaW5kZXhPZihjZWxsVmlldy5jaWQpO1xuICAgICAgICAgICAgdXBkYXRlcy51bm1vdW50ZWRDaWRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5yZWdpc3Rlck1vdW50ZWRWaWV3KGNlbGxWaWV3KTtcbiAgICAgICAgICAgIGlmIChmbGFnKSB0aGlzLnNjaGVkdWxlVmlld1VwZGF0ZShjZWxsVmlldywgZmxhZywgY2VsbFZpZXcuVVBEQVRFX1BSSU9SSVRZLCB7IG1vdW50aW5nOiB0cnVlIH0pO1xuICAgICAgICAgICAgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb3VudGVkOiBpc01vdW50ZWQgPyAxIDogMCxcbiAgICAgICAgICAgIHVubW91bnRlZDogaXNVbm1vdW50ZWQgPyAxIDogMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjaGVja1ZpZXdwb3J0OiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdmFyIHBhc3NpbmdPcHQgPSBkZWZhdWx0cyh7fSwgb3B0LCB7XG4gICAgICAgICAgICBtb3VudEJhdGNoU2l6ZTogSW5maW5pdHksXG4gICAgICAgICAgICB1bm1vdW50QmF0Y2hTaXplOiBJbmZpbml0eVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZpZXdwb3J0Rm4gPSAndmlld3BvcnQnIGluIHBhc3NpbmdPcHQgPyBwYXNzaW5nT3B0LnZpZXdwb3J0IDogdGhpcy5vcHRpb25zLnZpZXdwb3J0O1xuICAgICAgICB2YXIgdW5tb3VudGVkQ291bnQgPSB0aGlzLmNoZWNrTW91bnRlZFZpZXdzKHZpZXdwb3J0Rm4sIHBhc3NpbmdPcHQpO1xuICAgICAgICBpZiAodW5tb3VudGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgY2hlY2sgdmlld3MsIHRoYXQgaGF2ZSBiZWVuIGp1c3QgdW5tb3VudGVkIGFuZCBwdXNoZWQgYXQgdGhlIGVuZCBvZiB0aGUgY2lkcyBhcnJheVxuICAgICAgICAgICAgdmFyIHVubW91bnRlZENpZHMgPSB0aGlzLl91cGRhdGVzLnVubW91bnRlZENpZHM7XG4gICAgICAgICAgICBwYXNzaW5nT3B0Lm1vdW50QmF0Y2hTaXplID0gTWF0aC5taW4odW5tb3VudGVkQ2lkcy5sZW5ndGggLSB1bm1vdW50ZWRDb3VudCwgcGFzc2luZ09wdC5tb3VudEJhdGNoU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vdW50ZWRDb3VudCA9IHRoaXMuY2hlY2tVbm1vdW50ZWRWaWV3cyh2aWV3cG9ydEZuLCBwYXNzaW5nT3B0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdW50ZWQ6IG1vdW50ZWRDb3VudCxcbiAgICAgICAgICAgIHVubW91bnRlZDogdW5tb3VudGVkQ291bnRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZnJlZXplOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIGtleSA9IG9wdC5rZXk7XG4gICAgICAgIHZhciBpc0Zyb3plbiA9IHRoaXMub3B0aW9ucy5mcm96ZW47XG4gICAgICAgIHZhciBmcmVlemVLZXkgPSB1cGRhdGVzLmZyZWV6ZUtleTtcbiAgICAgICAgaWYgKGtleSAmJiBrZXkgIT09IGZyZWV6ZUtleSkgIHtcbiAgICAgICAgICAgIC8vIGtleSBwYXNzZWQsIGJ1dCB0aGUgcGFwZXIgaXMgYWxyZWFkeSBmcmVlemVkIHdpdGggYW5vdGhlciBrZXlcbiAgICAgICAgICAgIGlmIChpc0Zyb3plbiAmJiBmcmVlemVLZXkpIHJldHVybjtcbiAgICAgICAgICAgIHVwZGF0ZXMuZnJlZXplS2V5ID0ga2V5O1xuICAgICAgICAgICAgdXBkYXRlcy5rZXlGcm96ZW4gPSBpc0Zyb3plbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlkID0gdXBkYXRlcy5pZDtcbiAgICAgICAgdXBkYXRlcy5pZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmlzQXN5bmMoKSAmJiBpZCkgY2FuY2VsRnJhbWUoaWQpO1xuICAgIH0sXG5cbiAgICB1bmZyZWV6ZTogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB2YXIgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIHZhciBrZXkgPSBvcHQua2V5O1xuICAgICAgICB2YXIgZnJlZXplS2V5ID0gdXBkYXRlcy5mcmVlemVLZXk7XG4gICAgICAgIC8vIGtleSBwYXNzZWQsIGJ1dCB0aGUgcGFwZXIgaXMgYWxyZWFkeSBmcmVlemVkIHdpdGggYW5vdGhlciBrZXlcbiAgICAgICAgaWYgKGtleSAmJiBmcmVlemVLZXkgJiYga2V5ICE9PSBmcmVlemVLZXkpIHJldHVybjtcbiAgICAgICAgdXBkYXRlcy5mcmVlemVLZXkgPSBudWxsO1xuICAgICAgICAvLyBrZXkgcGFzc2VkLCBidXQgdGhlIHBhcGVyIGlzIGFscmVhZHkgZnJlZXplZFxuICAgICAgICBpZiAoa2V5ICYmIGtleSA9PT0gZnJlZXplS2V5ICYmIHVwZGF0ZXMua2V5RnJvemVuKSByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLmlzQXN5bmMoKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlemUoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3NBc3luYyhvcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cyhvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5mcm96ZW4gPSB1cGRhdGVzLmtleUZyb3plbiA9IGZhbHNlO1xuICAgICAgICBpZiAodXBkYXRlcy5zb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRWaWV3cygpO1xuICAgICAgICAgICAgdXBkYXRlcy5zb3J0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNBc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9ucy5hc3luYztcbiAgICB9LFxuXG4gICAgaXNGcm96ZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLm9wdGlvbnMuZnJvemVuO1xuICAgIH0sXG5cbiAgICBpc0V4YWN0U29ydGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc29ydGluZyA9PT0gc29ydGluZ1R5cGVzLkVYQUNUO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5mcmVlemUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIC8vY2xlYW4gdXAgYWxsIERPTSBlbGVtZW50cy92aWV3cyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVycygpO1xuICAgICAgICB0aGlzLnJlbW92ZVZpZXdzKCk7XG4gICAgfSxcblxuICAgIGdldENvbXB1dGVkU2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciB3ID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgdmFyIGggPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgaWYgKCFpc051bWJlcih3KSkgdyA9IHRoaXMuZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmICghaXNOdW1iZXIoaCkpIGggPSB0aGlzLmVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IHcsIGhlaWdodDogaCB9O1xuICAgIH0sXG5cbiAgICBzZXREaW1lbnNpb25zOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBkYXRhID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHdpZHRoOiBjdXJyZW50V2lkdGgsIGhlaWdodDogY3VycmVudEhlaWdodCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHcgPSAod2lkdGggPT09IHVuZGVmaW5lZCkgPyBjdXJyZW50V2lkdGggOiB3aWR0aDtcbiAgICAgICAgbGV0IGggPSAoaGVpZ2h0ID09PSB1bmRlZmluZWQpID8gY3VycmVudEhlaWdodCA6IGhlaWdodDtcbiAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCA9PT0gdyAmJiBjdXJyZW50SGVpZ2h0ID09PSBoKSByZXR1cm47XG4gICAgICAgIG9wdGlvbnMud2lkdGggPSB3O1xuICAgICAgICBvcHRpb25zLmhlaWdodCA9IGg7XG4gICAgICAgIHRoaXMuX3NldERpbWVuc2lvbnMoKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWRTaXplID0gdGhpcy5nZXRDb21wdXRlZFNpemUoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXNpemUnLCBjb21wdXRlZFNpemUud2lkdGgsIGNvbXB1dGVkU2l6ZS5oZWlnaHQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBfc2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHcgPSBvcHRpb25zLndpZHRoO1xuICAgICAgICBsZXQgaCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICBpZiAoaXNOdW1iZXIodykpIHcgPSBgJHtNYXRoLnJvdW5kKHcpfXB4YDtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGgpKSBoID0gYCR7TWF0aC5yb3VuZChoKX1weGA7XG4gICAgICAgIHRoaXMuJGVsLmNzcyh7XG4gICAgICAgICAgICB3aWR0aDogKHcgPT09IG51bGwpID8gJycgOiB3LFxuICAgICAgICAgICAgaGVpZ2h0OiAoaCA9PT0gbnVsbCkgPyAnJyA6IGhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEV4cGFuZC9zaHJpbmsgdGhlIHBhcGVyIHRvIGZpdCB0aGUgY29udGVudC5cbiAgICAvLyBBbHRlcm5hdGl2ZWx5IHNpZ25hdHVyZSBmdW5jdGlvbihvcHQpXG4gICAgZml0VG9Db250ZW50OiBmdW5jdGlvbihncmlkV2lkdGgsIGdyaWRIZWlnaHQsIHBhZGRpbmcsIG9wdCkge1xuXG4gICAgICAgIGlmIChpc09iamVjdChncmlkV2lkdGgpKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBwYXJhbWV0ZXIgaXMgYW4gb3B0aW9uIG9iamVjdFxuICAgICAgICAgICAgb3B0ID0gZ3JpZFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgYSBkZXByZWNhdGVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgb3B0ID0gYXNzaWduKHsgZ3JpZFdpZHRoLCBncmlkSGVpZ2h0LCBwYWRkaW5nIH0sIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuZ2V0Rml0VG9Db250ZW50QXJlYShvcHQpO1xuICAgICAgICBjb25zdCB7IHN4LCBzeSB9ID0gdGhpcy5zY2FsZSgpO1xuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKC14ICogc3gsIC15ICogc3ksIG9wdCk7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyh3aWR0aCAqIHN4LCBoZWlnaHQgKiBzeSwgb3B0KTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIGdldEZpdFRvQ29udGVudEFyZWE6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXBlciBzaXplIHRvIGFjY29tbW9kYXRlIGFsbCB0aGUgZ3JhcGgncyBlbGVtZW50cy5cblxuICAgICAgICBjb25zdCBncmlkV2lkdGggPSBvcHQuZ3JpZFdpZHRoIHx8IDE7XG4gICAgICAgIGNvbnN0IGdyaWRIZWlnaHQgPSBvcHQuZ3JpZEhlaWdodCB8fCAxO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gbm9ybWFsaXplU2lkZXMob3B0LnBhZGRpbmcgfHwgMCk7XG5cbiAgICAgICAgY29uc3QgbWluV2lkdGggPSBNYXRoLm1heChvcHQubWluV2lkdGggfHwgMCwgZ3JpZFdpZHRoKTtcbiAgICAgICAgY29uc3QgbWluSGVpZ2h0ID0gTWF0aC5tYXgob3B0Lm1pbkhlaWdodCB8fCAwLCBncmlkSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSBvcHQubWF4V2lkdGggfHwgTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gb3B0Lm1heEhlaWdodCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBjb25zdCBuZXdPcmlnaW4gPSBvcHQuYWxsb3dOZXdPcmlnaW47XG5cbiAgICAgICAgY29uc3QgYXJlYSA9ICgnY29udGVudEFyZWEnIGluIG9wdCkgPyBuZXcgUmVjdChvcHQuY29udGVudEFyZWEpIDogdGhpcy5nZXRDb250ZW50QXJlYShvcHQpO1xuICAgICAgICBjb25zdCB7IHN4LCBzeSB9ID0gdGhpcy5zY2FsZSgpO1xuICAgICAgICBhcmVhLnggKj0gc3g7XG4gICAgICAgIGFyZWEueSAqPSBzeTtcbiAgICAgICAgYXJlYS53aWR0aCAqPSBzeDtcbiAgICAgICAgYXJlYS5oZWlnaHQgKj0gc3k7XG5cbiAgICAgICAgbGV0IGNhbGNXaWR0aCA9IE1hdGguY2VpbCgoYXJlYS53aWR0aCArIGFyZWEueCkgLyBncmlkV2lkdGgpO1xuICAgICAgICBsZXQgY2FsY0hlaWdodCA9IE1hdGguY2VpbCgoYXJlYS5oZWlnaHQgKyBhcmVhLnkpIC8gZ3JpZEhlaWdodCk7XG4gICAgICAgIGlmICghb3B0LmFsbG93TmVnYXRpdmVCb3R0b21SaWdodCkge1xuICAgICAgICAgICAgY2FsY1dpZHRoID0gTWF0aC5tYXgoY2FsY1dpZHRoLCAxKTtcbiAgICAgICAgICAgIGNhbGNIZWlnaHQgPSBNYXRoLm1heChjYWxjSGVpZ2h0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxjV2lkdGggKj0gZ3JpZFdpZHRoO1xuICAgICAgICBjYWxjSGVpZ2h0ICo9IGdyaWRIZWlnaHQ7XG5cbiAgICAgICAgbGV0IHR4ID0gMDtcbiAgICAgICAgaWYgKChuZXdPcmlnaW4gPT09ICduZWdhdGl2ZScgJiYgYXJlYS54IDwgMCkgfHwgKG5ld09yaWdpbiA9PT0gJ3Bvc2l0aXZlJyAmJiBhcmVhLnggPj0gMCkgfHwgbmV3T3JpZ2luID09PSAnYW55Jykge1xuICAgICAgICAgICAgdHggPSBNYXRoLmNlaWwoLWFyZWEueCAvIGdyaWRXaWR0aCkgKiBncmlkV2lkdGg7XG4gICAgICAgICAgICB0eCArPSBwYWRkaW5nLmxlZnQ7XG4gICAgICAgICAgICBjYWxjV2lkdGggKz0gdHg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdHkgPSAwO1xuICAgICAgICBpZiAoKG5ld09yaWdpbiA9PT0gJ25lZ2F0aXZlJyAmJiBhcmVhLnkgPCAwKSB8fCAobmV3T3JpZ2luID09PSAncG9zaXRpdmUnICYmIGFyZWEueSA+PSAwKSB8fCBuZXdPcmlnaW4gPT09ICdhbnknKSB7XG4gICAgICAgICAgICB0eSA9IE1hdGguY2VpbCgtYXJlYS55IC8gZ3JpZEhlaWdodCkgKiBncmlkSGVpZ2h0O1xuICAgICAgICAgICAgdHkgKz0gcGFkZGluZy50b3A7XG4gICAgICAgICAgICBjYWxjSGVpZ2h0ICs9IHR5O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsY1dpZHRoICs9IHBhZGRpbmcucmlnaHQ7XG4gICAgICAgIGNhbGNIZWlnaHQgKz0gcGFkZGluZy5ib3R0b207XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZXN1bHRpbmcgd2lkdGggYW5kIGhlaWdodCBhcmUgZ3JlYXRlciB0aGFuIG1pbmltdW0uXG4gICAgICAgIGNhbGNXaWR0aCA9IE1hdGgubWF4KGNhbGNXaWR0aCwgbWluV2lkdGgpO1xuICAgICAgICBjYWxjSGVpZ2h0ID0gTWF0aC5tYXgoY2FsY0hlaWdodCwgbWluSGVpZ2h0KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlc3VsdGluZyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBsZXNzZXIgdGhhbiBtYXhpbXVtLlxuICAgICAgICBjYWxjV2lkdGggPSBNYXRoLm1pbihjYWxjV2lkdGgsIG1heFdpZHRoKTtcbiAgICAgICAgY2FsY0hlaWdodCA9IE1hdGgubWluKGNhbGNIZWlnaHQsIG1heEhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KC10eCAvIHN4LCAtdHkgLyBzeSwgY2FsY1dpZHRoIC8gc3gsIGNhbGNIZWlnaHQgLyBzeSk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybVRvRml0Q29udGVudDogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuXG4gICAgICAgIGxldCBjb250ZW50QkJveCwgY29udGVudExvY2FsT3JpZ2luO1xuICAgICAgICBpZiAoJ2NvbnRlbnRBcmVhJyBpbiBvcHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRBcmVhID0gb3B0LmNvbnRlbnRBcmVhO1xuICAgICAgICAgICAgY29udGVudEJCb3ggPSB0aGlzLmxvY2FsVG9QYXBlclJlY3QoY29udGVudEFyZWEpO1xuICAgICAgICAgICAgY29udGVudExvY2FsT3JpZ2luID0gbmV3IFBvaW50KGNvbnRlbnRBcmVhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRCQm94ID0gdGhpcy5nZXRDb250ZW50QkJveChvcHQpO1xuICAgICAgICAgICAgY29udGVudExvY2FsT3JpZ2luID0gdGhpcy5wYXBlclRvTG9jYWxQb2ludChjb250ZW50QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbnRlbnRCQm94LndpZHRoIHx8ICFjb250ZW50QkJveC5oZWlnaHQpIHJldHVybjtcblxuICAgICAgICBkZWZhdWx0cyhvcHQsIHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVHcmlkOiBudWxsLFxuICAgICAgICAgICAgbWluU2NhbGU6IDAsXG4gICAgICAgICAgICBtYXhTY2FsZTogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICAvL21pblNjYWxlWFxuICAgICAgICAgICAgLy9taW5TY2FsZVlcbiAgICAgICAgICAgIC8vbWF4U2NhbGVYXG4gICAgICAgICAgICAvL21heFNjYWxlWVxuICAgICAgICAgICAgLy9maXR0aW5nQkJveFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBwYWRkaW5nID0gbm9ybWFsaXplU2lkZXMob3B0LnBhZGRpbmcpO1xuXG4gICAgICAgIGNvbnN0IG1pblNjYWxlWCA9IG9wdC5taW5TY2FsZVggfHwgb3B0Lm1pblNjYWxlO1xuICAgICAgICBjb25zdCBtYXhTY2FsZVggPSBvcHQubWF4U2NhbGVYIHx8IG9wdC5tYXhTY2FsZTtcbiAgICAgICAgY29uc3QgbWluU2NhbGVZID0gb3B0Lm1pblNjYWxlWSB8fCBvcHQubWluU2NhbGU7XG4gICAgICAgIGNvbnN0IG1heFNjYWxlWSA9IG9wdC5tYXhTY2FsZVkgfHwgb3B0Lm1heFNjYWxlO1xuXG4gICAgICAgIGxldCBmaXR0aW5nQkJveDtcbiAgICAgICAgaWYgKG9wdC5maXR0aW5nQkJveCkge1xuICAgICAgICAgICAgZml0dGluZ0JCb3ggPSBvcHQuZml0dGluZ0JCb3g7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU2l6ZSA9IHRoaXMuZ2V0Q29tcHV0ZWRTaXplKCk7XG4gICAgICAgICAgICBmaXR0aW5nQkJveCA9IHtcbiAgICAgICAgICAgICAgICB4OiBjdXJyZW50VHJhbnNsYXRlLnR4LFxuICAgICAgICAgICAgICAgIHk6IGN1cnJlbnRUcmFuc2xhdGUudHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbXB1dGVkU2l6ZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbXB1dGVkU2l6ZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmaXR0aW5nQkJveCA9IG5ldyBSZWN0KGZpdHRpbmdCQm94KS5tb3ZlQW5kRXhwYW5kKHtcbiAgICAgICAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAgIHk6IHBhZGRpbmcudG9wLFxuICAgICAgICAgICAgd2lkdGg6IC1wYWRkaW5nLmxlZnQgLSBwYWRkaW5nLnJpZ2h0LFxuICAgICAgICAgICAgaGVpZ2h0OiAtcGFkZGluZy50b3AgLSBwYWRkaW5nLmJvdHRvbVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjdG0gPSB0aGlzLm1hdHJpeCgpO1xuICAgICAgICBjb25zdCB7IGE6IHN4LCBkOiBzeSwgZTogdHgsIGY6IHR5IH0gPSBjdG07XG5cbiAgICAgICAgbGV0IG5ld1N4ID0gZml0dGluZ0JCb3gud2lkdGggLyBjb250ZW50QkJveC53aWR0aCAqIHN4O1xuICAgICAgICBsZXQgbmV3U3kgPSBmaXR0aW5nQkJveC5oZWlnaHQgLyBjb250ZW50QkJveC5oZWlnaHQgKiBzeTtcblxuICAgICAgICBpZiAob3B0LnByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIG5ld1N4ID0gbmV3U3kgPSBNYXRoLm1pbihuZXdTeCwgbmV3U3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc25hcCBzY2FsZSB0byBhIGdyaWRcbiAgICAgICAgaWYgKG9wdC5zY2FsZUdyaWQpIHtcblxuICAgICAgICAgICAgY29uc3QgZ3JpZFNpemUgPSBvcHQuc2NhbGVHcmlkO1xuXG4gICAgICAgICAgICBuZXdTeCA9IGdyaWRTaXplICogTWF0aC5mbG9vcihuZXdTeCAvIGdyaWRTaXplKTtcbiAgICAgICAgICAgIG5ld1N5ID0gZ3JpZFNpemUgKiBNYXRoLmZsb29yKG5ld1N5IC8gZ3JpZFNpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2NhbGUgbWluL21heCBib3VuZGFyaWVzXG4gICAgICAgIG5ld1N4ID0gTWF0aC5taW4obWF4U2NhbGVYLCBNYXRoLm1heChtaW5TY2FsZVgsIG5ld1N4KSk7XG4gICAgICAgIG5ld1N5ID0gTWF0aC5taW4obWF4U2NhbGVZLCBNYXRoLm1heChtaW5TY2FsZVksIG5ld1N5KSk7XG5cbiAgICAgICAgY29uc3Qgc2NhbGVEaWZmID0ge1xuICAgICAgICAgICAgeDogbmV3U3ggLyBzeCxcbiAgICAgICAgICAgIHk6IG5ld1N5IC8gc3lcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgbmV3T3ggPSBmaXR0aW5nQkJveC54IC0gY29udGVudExvY2FsT3JpZ2luLnggKiBuZXdTeCAtIHR4O1xuICAgICAgICBsZXQgbmV3T3kgPSBmaXR0aW5nQkJveC55IC0gY29udGVudExvY2FsT3JpZ2luLnkgKiBuZXdTeSAtIHR5O1xuXG4gICAgICAgIHN3aXRjaCAob3B0LnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgbmV3T3kgPSBuZXdPeSArIChmaXR0aW5nQkJveC5oZWlnaHQgLSBjb250ZW50QkJveC5oZWlnaHQgKiBzY2FsZURpZmYueSkgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICBuZXdPeSA9IG5ld095ICsgKGZpdHRpbmdCQm94LmhlaWdodCAtIGNvbnRlbnRCQm94LmhlaWdodCAqIHNjYWxlRGlmZi55KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChvcHQuaG9yaXpvbnRhbEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgIG5ld094ID0gbmV3T3ggKyAoZml0dGluZ0JCb3gud2lkdGggLSBjb250ZW50QkJveC53aWR0aCAqIHNjYWxlRGlmZi54KSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbmV3T3ggPSBuZXdPeCArIChmaXR0aW5nQkJveC53aWR0aCAtIGNvbnRlbnRCQm94LndpZHRoICogc2NhbGVEaWZmLngpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY3RtLmEgPSBuZXdTeDtcbiAgICAgICAgY3RtLmQgPSBuZXdTeTtcbiAgICAgICAgY3RtLmUgPSBuZXdPeDtcbiAgICAgICAgY3RtLmYgPSBuZXdPeTtcbiAgICAgICAgdGhpcy5tYXRyaXgoY3RtLCBvcHQpO1xuICAgIH0sXG5cbiAgICBzY2FsZUNvbnRlbnRUb0ZpdDogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtVG9GaXRDb250ZW50KG9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29udGVudCBhcmVhIGluIGxvY2FsIHVuaXRzICh3aXRob3V0IHRyYW5zZm9ybWF0aW9ucykuXG4gICAgZ2V0Q29udGVudEFyZWE6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIGlmIChvcHQgJiYgb3B0LnVzZU1vZGVsR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmdldEJCb3goKSB8fCBuZXcgUmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFYodGhpcy5jZWxscykuZ2V0QkJveCgpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvbnRlbnQgYmJveCBpbiB0aGUgcGFwZXIgdW5pdHMgKGFzIGl0IGFwcGVhcnMgb24gc2NyZWVuKS5cbiAgICBnZXRDb250ZW50QkJveDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxUb1BhcGVyUmVjdCh0aGlzLmdldENvbnRlbnRBcmVhKG9wdCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgZ2VvbWV0cnkgcmVjdGFuZ2xlIHJlcHJlc2VudGluZyB0aGUgZW50aXJlXG4gICAgLy8gcGFwZXIgYXJlYSAoY29vcmRpbmF0ZXMgZnJvbSB0aGUgbGVmdCBwYXBlciBib3JkZXIgdG8gdGhlIHJpZ2h0IG9uZVxuICAgIC8vIGFuZCB0aGUgdG9wIGJvcmRlciB0byB0aGUgYm90dG9tIG9uZSkuXG4gICAgZ2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFwZXJUb0xvY2FsUmVjdCh0aGlzLmdldENvbXB1dGVkU2l6ZSgpKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVzdHJpY3RlZEFyZWE6IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblxuICAgICAgICBjb25zdCB7IHJlc3RyaWN0VHJhbnNsYXRlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgbGV0IHJlc3RyaWN0ZWRBcmVhO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXN0cmljdFRyYW5zbGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIEEgbWV0aG9kIHJldHVybmluZyBhIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgcmVzdHJpY3RlZEFyZWEgPSByZXN0cmljdFRyYW5zbGF0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN0cmljdFRyYW5zbGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHBhcGVyIGFyZWFcbiAgICAgICAgICAgIHJlc3RyaWN0ZWRBcmVhID0gdGhpcy5nZXRBcmVhKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3RyaWN0VHJhbnNsYXRlKSB7XG4gICAgICAgICAgICAvLyBmYWxzeSB2YWx1ZVxuICAgICAgICAgICAgcmVzdHJpY3RlZEFyZWEgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYW55IG90aGVyIHZhbHVlXG4gICAgICAgICAgICByZXN0cmljdGVkQXJlYSA9IG5ldyBSZWN0KHJlc3RyaWN0VHJhbnNsYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN0cmljdGVkQXJlYTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVmlld0Zvck1vZGVsOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICAvLyBBIGNsYXNzIHRha2VuIGZyb20gdGhlIHBhcGVyIG9wdGlvbnMuXG4gICAgICAgIHZhciBvcHRpb25hbFZpZXdDbGFzcztcblxuICAgICAgICAvLyBBIGRlZmF1bHQgYmFzaWMgY2xhc3MgKGVpdGhlciBkaWEuRWxlbWVudFZpZXcgb3IgZGlhLkxpbmtWaWV3KVxuICAgICAgICB2YXIgZGVmYXVsdFZpZXdDbGFzcztcblxuICAgICAgICAvLyBBIHNwZWNpYWwgY2xhc3MgZGVmaW5lZCBmb3IgdGhpcyBtb2RlbCBpbiB0aGUgY29ycmVzcG9uZGluZyBuYW1lc3BhY2UuXG4gICAgICAgIC8vIGUuZy4gam9pbnQuc2hhcGVzLnN0YW5kYXJkLlJlY3RhbmdsZSBzZWFyY2hlcyBmb3Igam9pbnQuc2hhcGVzLnN0YW5kYXJkLlJlY3RhbmdsZVZpZXdcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG9wdGlvbnMuY2VsbFZpZXdOYW1lc3BhY2U7XG4gICAgICAgIHZhciB0eXBlID0gY2VsbC5nZXQoJ3R5cGUnKSArICdWaWV3JztcbiAgICAgICAgdmFyIG5hbWVzcGFjZVZpZXdDbGFzcyA9IGdldEJ5UGF0aChuYW1lc3BhY2UsIHR5cGUsICcuJyk7XG5cbiAgICAgICAgaWYgKGNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsVmlld0NsYXNzID0gb3B0aW9ucy5saW5rVmlldztcbiAgICAgICAgICAgIGRlZmF1bHRWaWV3Q2xhc3MgPSBMaW5rVmlldztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbmFsVmlld0NsYXNzID0gb3B0aW9ucy5lbGVtZW50VmlldztcbiAgICAgICAgICAgIGRlZmF1bHRWaWV3Q2xhc3MgPSBFbGVtZW50VmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGEpIHRoZSBwYXBlciBvcHRpb25zIHZpZXcgaXMgYSBjbGFzcyAoZGVwcmVjYXRlZClcbiAgICAgICAgLy8gIDEuIHNlYXJjaCB0aGUgbmFtZXNwYWNlIGZvciBhIHZpZXdcbiAgICAgICAgLy8gIDIuIGlmIG5vIHZpZXcgd2FzIGZvdW5kLCB1c2UgdmlldyBmcm9tIHRoZSBwYXBlciBvcHRpb25zXG4gICAgICAgIC8vIGIpIHRoZSBwYXBlciBvcHRpb25zIHZpZXcgaXMgYSBmdW5jdGlvblxuICAgICAgICAvLyAgMS4gY2FsbCB0aGUgZnVuY3Rpb24gZnJvbSB0aGUgcGFwZXIgb3B0aW9uc1xuICAgICAgICAvLyAgMi4gaWYgbm8gdmlldyB3YXMgcmV0dXJuLCBzZWFyY2ggdGhlIG5hbWVzcGFjZSBmb3IgYSB2aWV3XG4gICAgICAgIC8vICAzLiBpZiBubyB2aWV3IHdhcyBmb3VuZCwgdXNlIHRoZSBkZWZhdWx0XG4gICAgICAgIHZhciBWaWV3Q2xhc3MgPSAob3B0aW9uYWxWaWV3Q2xhc3MucHJvdG90eXBlIGluc3RhbmNlb2YgVmlld0Jhc2UpXG4gICAgICAgICAgICA/IG5hbWVzcGFjZVZpZXdDbGFzcyB8fCBvcHRpb25hbFZpZXdDbGFzc1xuICAgICAgICAgICAgOiBvcHRpb25hbFZpZXdDbGFzcy5jYWxsKHRoaXMsIGNlbGwpIHx8IG5hbWVzcGFjZVZpZXdDbGFzcyB8fCBkZWZhdWx0Vmlld0NsYXNzO1xuXG4gICAgICAgIHJldHVybiBuZXcgVmlld0NsYXNzKHtcbiAgICAgICAgICAgIG1vZGVsOiBjZWxsLFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IG9wdGlvbnMuaW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBsYWJlbHNMYXllcjogb3B0aW9ucy5sYWJlbHNMYXllciA9PT0gdHJ1ZSA/IExheWVyc05hbWVzLkxBQkVMUyA6IG9wdGlvbnMubGFiZWxzTGF5ZXJcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHJlbW92ZVZpZXc6IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICBjb25zdCB7IGlkIH0gPSBjZWxsO1xuICAgICAgICBjb25zdCB7IF92aWV3cywgX3VwZGF0ZXMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBfdmlld3NbaWRdO1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmFyIHsgY2lkIH0gPSB2aWV3O1xuICAgICAgICAgICAgY29uc3QgeyBtb3VudGVkLCB1bm1vdW50ZWQgfSA9IF91cGRhdGVzO1xuICAgICAgICAgICAgdmlldy5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdmlld3NbaWRdO1xuICAgICAgICAgICAgZGVsZXRlIG1vdW50ZWRbY2lkXTtcbiAgICAgICAgICAgIGRlbGV0ZSB1bm1vdW50ZWRbY2lkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuXG4gICAgcmVuZGVyVmlldzogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG5cbiAgICAgICAgY29uc3QgeyBpZCB9ID0gY2VsbDtcbiAgICAgICAgY29uc3Qgdmlld3MgPSB0aGlzLl92aWV3cztcbiAgICAgICAgbGV0IHZpZXcsIGZsYWc7XG4gICAgICAgIGxldCBjcmVhdGUgPSB0cnVlO1xuICAgICAgICBpZiAoaWQgaW4gdmlld3MpIHtcbiAgICAgICAgICAgIHZpZXcgPSB2aWV3c1tpZF07XG4gICAgICAgICAgICBpZiAodmlldy5tb2RlbCA9PT0gY2VsbCkge1xuICAgICAgICAgICAgICAgIGZsYWcgPSB2aWV3LkZMQUdfSU5TRVJUO1xuICAgICAgICAgICAgICAgIGNyZWF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdmlldyBmb3IgdGhpcyBgaWRgIGFscmVhZHkgZXhpc3QuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNlbGwgaXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIG1vZGVsIHdpdGggaWRlbnRpY2FsIGlkXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2ltcGx5IHJlbW92ZSB0aGUgZXhpc3RpbmcgdmlldyBhbmQgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVmlldyhjZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICB2aWV3ID0gdmlld3NbaWRdID0gdGhpcy5jcmVhdGVWaWV3Rm9yTW9kZWwoY2VsbCk7XG4gICAgICAgICAgICB2aWV3LnBhcGVyID0gdGhpcztcbiAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlZ2lzdGVyVW5tb3VudGVkVmlldyh2aWV3KSB8IHRoaXMuRkxBR19JTklUIHwgdmlldy5nZXRGbGFnKHJlc3VsdCh2aWV3LCAnaW5pdEZsYWcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0Vmlld1VwZGF0ZSh2aWV3LCBmbGFnLCB2aWV3LlVQREFURV9QUklPUklUWSwgb3B0KTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcblxuICAgIG9uSW1hZ2VEcmFnU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50IGltYWdlIGRyYWdnaW5nIGluIEZpcmVmb3ggdGhhdCB3b3Jrcy5cbiAgICAgICAgLy8gU2V0dGluZyAtbW96LXVzZXItc2VsZWN0OiBub25lLCBkcmFnZ2FibGU9XCJmYWxzZVwiIGF0dHJpYnV0ZSBvciB1c2VyLWRyYWc6IG5vbmUgZGlkbid0IGhlbHAuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXNldFZpZXdzOiBmdW5jdGlvbihjZWxscywgb3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICBjZWxscyB8fCAoY2VsbHMgPSBbXSk7XG4gICAgICAgIHRoaXMuX3Jlc2V0VXBkYXRlcygpO1xuICAgICAgICAvLyBjbGVhcmluZyB2aWV3cyByZW1vdmVzIGFueSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5yZW1vdmVWaWV3cygpO1xuICAgICAgICAvLyBBbGxvd3MgdG8gdW5mcmVlemUgbm9ybWFsbHkgd2hpbGUgaW4gdGhlIGlkbGUgc3RhdGUgdXNpbmcgYXV0b0ZyZWV6ZSBvcHRpb25cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5vcHRpb25zLmF1dG9GcmVlemUgPyBudWxsIDogJ3Jlc2V0JztcbiAgICAgICAgdGhpcy5mcmVlemUoeyBrZXkgfSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoY2VsbHNbaV0sIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmZyZWV6ZSh7IGtleSB9KTtcbiAgICAgICAgdGhpcy5zb3J0Vmlld3MoKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVmlld3M6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGludm9rZSh0aGlzLl92aWV3cywgJ3JlbW92ZScpO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdzID0ge307XG4gICAgfSxcblxuICAgIHNvcnRWaWV3czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRXhhY3RTb3J0aW5nKCkpIHtcbiAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Zyb3plbigpKSB7XG4gICAgICAgICAgICAvLyBzb3J0IHZpZXdzIG9uY2UgdW5mcm96ZW5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZXMuc29ydCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3J0Vmlld3NFeGFjdCgpO1xuICAgIH0sXG5cbiAgICBzb3J0Vmlld3NFeGFjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gUnVuIGluc2VydGlvbiBzb3J0IGFsZ29yaXRobSBpbiBvcmRlciB0byBlZmZpY2llbnRseSBzb3J0IERPTSBlbGVtZW50cyBhY2NvcmRpbmcgdG8gdGhlaXJcbiAgICAgICAgLy8gYXNzb2NpYXRlZCBtb2RlbCBgemAgYXR0cmlidXRlLlxuXG4gICAgICAgIHZhciBjZWxsTm9kZXMgPSBBcnJheS5mcm9tKHRoaXMuY2VsbHMuY2hpbGROb2RlcykuZmlsdGVyKG5vZGUgPT4gbm9kZS5nZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJykpO1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLm1vZGVsLmdldCgnY2VsbHMnKTtcblxuICAgICAgICBzb3J0RWxlbWVudHMoY2VsbE5vZGVzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY2VsbEEgPSBjZWxscy5nZXQoYS5nZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJykpO1xuICAgICAgICAgICAgdmFyIGNlbGxCID0gY2VsbHMuZ2V0KGIuZ2V0QXR0cmlidXRlKCdtb2RlbC1pZCcpKTtcbiAgICAgICAgICAgIHZhciB6QSA9IGNlbGxBLmF0dHJpYnV0ZXMueiB8fCAwO1xuICAgICAgICAgICAgdmFyIHpCID0gY2VsbEIuYXR0cmlidXRlcy56IHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gKHpBID09PSB6QikgPyAwIDogKHpBIDwgekIpID8gLTEgOiAxO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0VmlldzogZnVuY3Rpb24odmlldywgaXNJbml0aWFsSW5zZXJ0KSB7XG4gICAgICAgIGNvbnN0IGxheWVyVmlldyA9IHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLkNFTExTKTtcbiAgICAgICAgY29uc3QgeyBlbCwgbW9kZWwgfSA9IHZpZXc7XG4gICAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnNvcnRpbmcpIHtcbiAgICAgICAgICAgIGNhc2Ugc29ydGluZ1R5cGVzLkFQUFJPWDpcbiAgICAgICAgICAgICAgICBsYXllclZpZXcuaW5zZXJ0U29ydGVkTm9kZShlbCwgbW9kZWwuZ2V0KCd6JykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb3J0aW5nVHlwZXMuRVhBQ1Q6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxheWVyVmlldy5pbnNlcnROb2RlKGVsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2aWV3Lm9uTW91bnQoaXNJbml0aWFsSW5zZXJ0KTtcbiAgICB9LFxuXG4gICAgZGV0YWNoVmlldyh2aWV3KSB7XG4gICAgICAgIHZpZXcudW5tb3VudCgpO1xuICAgICAgICB2aWV3Lm9uRGV0YWNoKCk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IHZpZXcgY2xpbWJpbmcgdXAgdGhlIERPTSB0cmVlIHN0YXJ0aW5nIGF0IGVsZW1lbnQgYGVsYC4gTm90ZSB0aGF0IGBlbGAgY2FuIGFsc29cbiAgICAvLyBiZSBhIHNlbGVjdG9yIG9yIGEgalF1ZXJ5IG9iamVjdC5cbiAgICBmaW5kVmlldzogZnVuY3Rpb24oJGVsKSB7XG5cbiAgICAgICAgdmFyIGVsID0gaXNTdHJpbmcoJGVsKVxuICAgICAgICAgICAgPyB0aGlzLmNlbGxzLnF1ZXJ5U2VsZWN0b3IoJGVsKVxuICAgICAgICAgICAgOiAkZWwgaW5zdGFuY2VvZiAkID8gJGVsWzBdIDogJGVsO1xuXG4gICAgICAgIHZhciBpZCA9IHRoaXMuZmluZEF0dHJpYnV0ZSgnbW9kZWwtaWQnLCBlbCk7XG4gICAgICAgIGlmIChpZCkgcmV0dXJuIHRoaXMuX3ZpZXdzW2lkXTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGEgdmlldyBmb3IgYSBtb2RlbCBgY2VsbGAuIGBjZWxsYCBjYW4gYWxzbyBiZSBhIHN0cmluZyBvciBudW1iZXIgcmVwcmVzZW50aW5nIGEgbW9kZWwgYGlkYC5cbiAgICBmaW5kVmlld0J5TW9kZWw6IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICB2YXIgaWQgPSAoaXNTdHJpbmcoY2VsbCkgfHwgaXNOdW1iZXIoY2VsbCkpID8gY2VsbCA6IChjZWxsICYmIGNlbGwuaWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3c1tpZF07XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIHZpZXdzIGF0IGdpdmVuIHBvaW50XG4gICAgZmluZFZpZXdzRnJvbVBvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcCA9IG5ldyBQb2ludChwKTtcblxuICAgICAgICB2YXIgdmlld3MgPSB0aGlzLm1vZGVsLmdldEVsZW1lbnRzKCkubWFwKHRoaXMuZmluZFZpZXdCeU1vZGVsLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdmlld3MuZmlsdGVyKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3ICYmIHZpZXcudmVsLmdldEJCb3goeyB0YXJnZXQ6IHRoaXMuY2VsbHMgfSkuY29udGFpbnNQb2ludChwKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIHZpZXdzIGluIGdpdmVuIGFyZWFcbiAgICBmaW5kVmlld3NJbkFyZWE6IGZ1bmN0aW9uKHJlY3QsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IGRlZmF1bHRzKG9wdCB8fCB7fSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICByZWN0ID0gbmV3IFJlY3QocmVjdCk7XG5cbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy5tb2RlbC5nZXRFbGVtZW50cygpLm1hcCh0aGlzLmZpbmRWaWV3QnlNb2RlbCwgdGhpcyk7XG4gICAgICAgIHZhciBtZXRob2QgPSBvcHQuc3RyaWN0ID8gJ2NvbnRhaW5zUmVjdCcgOiAnaW50ZXJzZWN0JztcblxuICAgICAgICByZXR1cm4gdmlld3MuZmlsdGVyKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3ICYmIHJlY3RbbWV0aG9kXSh2aWV3LnZlbC5nZXRCQm94KHsgdGFyZ2V0OiB0aGlzLmNlbGxzIH0pKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGZpbmRFbGVtZW50Vmlld3NJbkFyZWEocGxhaW5BcmVhLCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclZpZXdzSW5BcmVhKFxuICAgICAgICAgICAgcGxhaW5BcmVhLFxuICAgICAgICAgICAgKGV4dEFyZWEsIGZpbmRPcHQpID0+IHRoaXMubW9kZWwuZmluZEVsZW1lbnRzSW5BcmVhKGV4dEFyZWEsIGZpbmRPcHQpLFxuICAgICAgICAgICAgb3B0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZpbmRMaW5rVmlld3NJbkFyZWE6IGZ1bmN0aW9uKHBsYWluQXJlYSwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJWaWV3c0luQXJlYShcbiAgICAgICAgICAgIHBsYWluQXJlYSxcbiAgICAgICAgICAgIChleHRBcmVhLCBmaW5kT3B0KSA9PiB0aGlzLm1vZGVsLmZpbmRMaW5rc0luQXJlYShleHRBcmVhLCBmaW5kT3B0KSxcbiAgICAgICAgICAgIG9wdFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmaW5kQ2VsbFZpZXdzSW5BcmVhOiBmdW5jdGlvbihwbGFpbkFyZWEsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyVmlld3NJbkFyZWEoXG4gICAgICAgICAgICBwbGFpbkFyZWEsXG4gICAgICAgICAgICAoZXh0QXJlYSwgZmluZE9wdCkgPT4gdGhpcy5tb2RlbC5maW5kQ2VsbHNJbkFyZWEoZXh0QXJlYSwgZmluZE9wdCksXG4gICAgICAgICAgICBvcHRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZmluZEVsZW1lbnRWaWV3c0F0UG9pbnQ6IGZ1bmN0aW9uKHBsYWluUG9pbnQsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyVmlld3NBdFBvaW50KFxuICAgICAgICAgICAgcGxhaW5Qb2ludCxcbiAgICAgICAgICAgIChleHRBcmVhKSA9PiB0aGlzLm1vZGVsLmZpbmRFbGVtZW50c0luQXJlYShleHRBcmVhKSxcbiAgICAgICAgICAgIG9wdFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmaW5kTGlua1ZpZXdzQXRQb2ludDogZnVuY3Rpb24ocGxhaW5Qb2ludCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJWaWV3c0F0UG9pbnQoXG4gICAgICAgICAgICBwbGFpblBvaW50LFxuICAgICAgICAgICAgKGV4dEFyZWEpID0+IHRoaXMubW9kZWwuZmluZExpbmtzSW5BcmVhKGV4dEFyZWEpLFxuICAgICAgICAgICAgb3B0LFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmaW5kQ2VsbFZpZXdzQXRQb2ludDogZnVuY3Rpb24ocGxhaW5Qb2ludCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJWaWV3c0F0UG9pbnQoXG4gICAgICAgICAgICBwbGFpblBvaW50LFxuICAgICAgICAgICAgLy8gTm90ZTogd2UgZG8gbm90IHdhbnQgdG8gcGFzcyBgb3B0YCB0byBgZmluZENlbGxzSW5BcmVhYFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgYHN0cmljdGAgb3B0aW9uIHdvcmtzIGRpZmZlcmVudGx5IGZvciBxdWVyeWluZyBhdCBhIHBvaW50XG4gICAgICAgICAgICAoZXh0QXJlYSkgPT4gdGhpcy5tb2RlbC5maW5kQ2VsbHNJbkFyZWEoZXh0QXJlYSksXG4gICAgICAgICAgICBvcHRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgX2ZpbmRJbkV4dGVuZGVkQXJlYTogZnVuY3Rpb24oYXJlYSwgZmluZENlbGxzRm4sIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHRoaXMuREVGQVVMVF9GSU5EX0JVRkZFUixcbiAgICAgICAgfSA9IG9wdDtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRBcmVhID0gKG5ldyBSZWN0KGFyZWEpKS5pbmZsYXRlKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGNlbGxzSW5FeHRlbmRlZEFyZWEgPSBmaW5kQ2VsbHNGbihleHRlbmRlZEFyZWEsIG9wdCk7XG4gICAgICAgIHJldHVybiBjZWxsc0luRXh0ZW5kZWRBcmVhLm1hcChlbGVtZW50ID0+IHRoaXMuZmluZFZpZXdCeU1vZGVsKGVsZW1lbnQpKTtcbiAgICB9LFxuXG4gICAgX2ZpbHRlclZpZXdzSW5BcmVhOiBmdW5jdGlvbihwbGFpbkFyZWEsIGZpbmRDZWxscywgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgYXJlYSA9IG5ldyBSZWN0KHBsYWluQXJlYSk7XG4gICAgICAgIGNvbnN0IHZpZXdzSW5FeHRlbmRlZEFyZWEgPSB0aGlzLl9maW5kSW5FeHRlbmRlZEFyZWEoYXJlYSwgZmluZENlbGxzLCBvcHQpO1xuICAgICAgICBjb25zdCB2aWV3c0luQXJlYSA9IHZpZXdzSW5FeHRlbmRlZEFyZWEuZmlsdGVyKHZpZXcgPT4ge1xuICAgICAgICAgICAgaWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5pc0luQXJlYShhcmVhLCBvcHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZpZXdzSW5BcmVhO1xuICAgIH0sXG5cbiAgICBfZmlsdGVyVmlld3NBdFBvaW50OiBmdW5jdGlvbihwbGFpblBvaW50LCBmaW5kQ2VsbHMsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBuZXcgUmVjdChwbGFpblBvaW50KTsgLy8gemVyby1zaXplIGFyZWFcbiAgICAgICAgY29uc3Qgdmlld3NJbkV4dGVuZGVkQXJlYSA9IHRoaXMuX2ZpbmRJbkV4dGVuZGVkQXJlYShhcmVhLCBmaW5kQ2VsbHMsIG9wdCk7XG4gICAgICAgIGNvbnN0IHZpZXdzQXRQb2ludCA9IHZpZXdzSW5FeHRlbmRlZEFyZWEuZmlsdGVyKHZpZXcgPT4ge1xuICAgICAgICAgICAgaWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5pc0F0UG9pbnQocGxhaW5Qb2ludCwgb3B0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2aWV3c0F0UG9pbnQ7XG4gICAgfSxcblxuICAgIHJlbW92ZVRvb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRvb2xzRXZlbnQoJ3JlbW92ZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlkZVRvb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRvb2xzRXZlbnQoJ2hpZGUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNob3dUb29sczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb29sc0V2ZW50KCdzaG93Jyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaFRvb2xzRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gICAgICAgIHRoaXMudHJpZ2dlcigndG9vbHM6ZXZlbnQnLCBldmVudCwgLi4uYXJncyk7XG4gICAgfSxcblxuXG4gICAgZ2V0TW9kZWxCeUlkOiBmdW5jdGlvbihpZCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmdldENlbGwoaWQpO1xuICAgIH0sXG5cbiAgICBzbmFwVG9HcmlkOiBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgLy8gQ29udmVydCBnbG9iYWwgY29vcmRpbmF0ZXMgdG8gdGhlIGxvY2FsIG9uZXMgb2YgdGhlIGB2aWV3cG9ydGAuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gaW1wcm9wZXIgdHJhbnNmb3JtYXRpb24gd291bGQgYmUgYXBwbGllZCB3aGVuIHRoZSB2aWV3cG9ydCBnZXRzIHRyYW5zZm9ybWVkIChzY2FsZWQvcm90YXRlZCkuXG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudFRvTG9jYWxQb2ludCh4LCB5KS5zbmFwVG9HcmlkKHRoaXMub3B0aW9ucy5ncmlkU2l6ZSk7XG4gICAgfSxcblxuICAgIGxvY2FsVG9QYXBlclBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHBvaW50IGFuZCBgeWAgdW5kZWZpbmVkXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB2YXIgcGFwZXJQb2ludCA9IFYudHJhbnNmb3JtUG9pbnQobG9jYWxQb2ludCwgdGhpcy5tYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBwYXBlclBvaW50O1xuICAgIH0sXG5cbiAgICBsb2NhbFRvUGFwZXJSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHJlY3RhbmdsZSBhbmQgcmVzdCBhcmd1bWVudHMgdW5kZWZpbmVkXG4gICAgICAgIHZhciBsb2NhbFJlY3QgPSBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIHBhcGVyUmVjdCA9IFYudHJhbnNmb3JtUmVjdChsb2NhbFJlY3QsIHRoaXMubWF0cml4KCkpO1xuICAgICAgICByZXR1cm4gcGFwZXJSZWN0O1xuICAgIH0sXG5cbiAgICBwYXBlclRvTG9jYWxQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSBwb2ludCBhbmQgYHlgIHVuZGVmaW5lZFxuICAgICAgICB2YXIgcGFwZXJQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSBWLnRyYW5zZm9ybVBvaW50KHBhcGVyUG9pbnQsIHRoaXMubWF0cml4KCkuaW52ZXJzZSgpKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsUG9pbnQ7XG4gICAgfSxcblxuICAgIHBhcGVyVG9Mb2NhbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcmVjdGFuZ2xlIGFuZCByZXN0IGFyZ3VtZW50cyB1bmRlZmluZWRcbiAgICAgICAgdmFyIHBhcGVyUmVjdCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgbG9jYWxSZWN0ID0gVi50cmFuc2Zvcm1SZWN0KHBhcGVyUmVjdCwgdGhpcy5tYXRyaXgoKS5pbnZlcnNlKCkpO1xuICAgICAgICByZXR1cm4gbG9jYWxSZWN0O1xuICAgIH0sXG5cbiAgICBsb2NhbFRvQ2xpZW50UG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcG9pbnQgYW5kIGB5YCB1bmRlZmluZWRcbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHZhciBjbGllbnRQb2ludCA9IFYudHJhbnNmb3JtUG9pbnQobG9jYWxQb2ludCwgdGhpcy5jbGllbnRNYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBjbGllbnRQb2ludDtcbiAgICB9LFxuXG4gICAgbG9jYWxUb0NsaWVudFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcG9pbnQgYW5kIGB5YCB1bmRlZmluZWRcbiAgICAgICAgdmFyIGxvY2FsUmVjdCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IFYudHJhbnNmb3JtUmVjdChsb2NhbFJlY3QsIHRoaXMuY2xpZW50TWF0cml4KCkpO1xuICAgICAgICByZXR1cm4gY2xpZW50UmVjdDtcbiAgICB9LFxuXG4gICAgLy8gVHJhbnNmb3JtIGNsaWVudCBjb29yZGluYXRlcyB0byB0aGUgcGFwZXIgbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgLy8gVXNlZnVsIHdoZW4geW91IGhhdmUgYSBtb3VzZSBldmVudCBvYmplY3QgYW5kIHlvdSdkIGxpa2UgdG8gZ2V0IGNvb3JkaW5hdGVzXG4gICAgLy8gaW5zaWRlIHRoZSBwYXBlciB0aGF0IGNvcnJlc3BvbmQgdG8gYGV2dC5jbGllbnRYYCBhbmQgYGV2dC5jbGllbnRZYCBwb2ludC5cbiAgICAvLyBFeGFtcGxlOiB2YXIgbG9jYWxQb2ludCA9IHBhcGVyLmNsaWVudFRvTG9jYWxQb2ludCh7IHg6IGV2dC5jbGllbnRYLCB5OiBldnQuY2xpZW50WSB9KTtcbiAgICBjbGllbnRUb0xvY2FsUG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcG9pbnQgYW5kIGB5YCB1bmRlZmluZWRcbiAgICAgICAgdmFyIGNsaWVudFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IFYudHJhbnNmb3JtUG9pbnQoY2xpZW50UG9pbnQsIHRoaXMuY2xpZW50TWF0cml4KCkuaW52ZXJzZSgpKTtcbiAgICAgICAgcmV0dXJuIGxvY2FsUG9pbnQ7XG4gICAgfSxcblxuICAgIGNsaWVudFRvTG9jYWxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHBvaW50IGFuZCBgeWAgdW5kZWZpbmVkXG4gICAgICAgIHZhciBjbGllbnRSZWN0ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBsb2NhbFJlY3QgPSBWLnRyYW5zZm9ybVJlY3QoY2xpZW50UmVjdCwgdGhpcy5jbGllbnRNYXRyaXgoKS5pbnZlcnNlKCkpO1xuICAgICAgICByZXR1cm4gbG9jYWxSZWN0O1xuICAgIH0sXG5cbiAgICBsb2NhbFRvUGFnZVBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxUb1BhcGVyUG9pbnQoeCwgeSkub2Zmc2V0KHRoaXMucGFnZU9mZnNldCgpKTtcbiAgICB9LFxuXG4gICAgbG9jYWxUb1BhZ2VSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxUb1BhcGVyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KS5vZmZzZXQodGhpcy5wYWdlT2Zmc2V0KCkpO1xuICAgIH0sXG5cbiAgICBwYWdlVG9Mb2NhbFBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgdmFyIHBhZ2VQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIHBhcGVyUG9pbnQgPSBwYWdlUG9pbnQuZGlmZmVyZW5jZSh0aGlzLnBhZ2VPZmZzZXQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcGVyVG9Mb2NhbFBvaW50KHBhcGVyUG9pbnQpO1xuICAgIH0sXG5cbiAgICBwYWdlVG9Mb2NhbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IHRoaXMucGFnZU9mZnNldCgpO1xuICAgICAgICB2YXIgcGFwZXJSZWN0ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBhcGVyUmVjdC54IC09IHBhZ2VPZmZzZXQueDtcbiAgICAgICAgcGFwZXJSZWN0LnkgLT0gcGFnZU9mZnNldC55O1xuICAgICAgICByZXR1cm4gdGhpcy5wYXBlclRvTG9jYWxSZWN0KHBhcGVyUmVjdCk7XG4gICAgfSxcblxuICAgIGNsaWVudE9mZnNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLnN2Zy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChjbGllbnRSZWN0LmxlZnQsIGNsaWVudFJlY3QudG9wKTtcbiAgICB9LFxuXG4gICAgcGFnZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T2Zmc2V0KCkub2Zmc2V0KHdpbmRvdy5zY3JvbGxYLCB3aW5kb3cuc2Nyb2xsWSk7XG4gICAgfSxcblxuICAgIGxpbmtBbGxvd2VkOiBmdW5jdGlvbihsaW5rVmlldykge1xuXG4gICAgICAgIGlmICghKGxpbmtWaWV3IGluc3RhbmNlb2YgTGlua1ZpZXcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGxpbmtWaWV3LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmsgPSBsaW5rVmlldy5tb2RlbDtcbiAgICAgICAgdmFyIHBhcGVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG5zID0gZ3JhcGguY29uc3RydWN0b3IudmFsaWRhdGlvbnM7XG5cbiAgICAgICAgaWYgKCFwYXBlck9wdGlvbnMubXVsdGlMaW5rcykge1xuICAgICAgICAgICAgaWYgKCFucy5tdWx0aUxpbmtzLmNhbGwodGhpcywgZ3JhcGgsIGxpbmspKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcGVyT3B0aW9ucy5saW5rUGlubmluZykge1xuICAgICAgICAgICAgLy8gTGluayBwaW5uaW5nIGlzIG5vdCBhbGxvd2VkIGFuZCB0aGUgbGluayBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICBpZiAoIW5zLmxpbmtQaW5uaW5nLmNhbGwodGhpcywgZ3JhcGgsIGxpbmspKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHBhcGVyT3B0aW9ucy5hbGxvd0xpbmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICghcGFwZXJPcHRpb25zLmFsbG93TGluay5jYWxsKHRoaXMsIGxpbmtWaWV3LCB0aGlzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGdldERlZmF1bHRMaW5rOiBmdW5jdGlvbihjZWxsVmlldywgbWFnbmV0KSB7XG5cbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmRlZmF1bHRMaW5rKVxuICAgICAgICAvLyBkZWZhdWx0IGxpbmsgaXMgYSBmdW5jdGlvbiBwcm9kdWNpbmcgbGluayBtb2RlbFxuICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMuZGVmYXVsdExpbmsuY2FsbCh0aGlzLCBjZWxsVmlldywgbWFnbmV0KVxuICAgICAgICAvLyBkZWZhdWx0IGxpbmsgaXMgdGhlIG12YyBtb2RlbFxuICAgICAgICAgICAgOiB0aGlzLm9wdGlvbnMuZGVmYXVsdExpbmsuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2VsbCBoaWdobGlnaHRpbmcuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICByZXNvbHZlSGlnaGxpZ2h0ZXI6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgbGV0IHsgaGlnaGxpZ2h0ZXI6IGhpZ2hsaWdodGVyRGVmLCB0eXBlIH0gPSBvcHQ7XG4gICAgICAgIGNvbnN0IHsgaGlnaGxpZ2h0aW5nLGhpZ2hsaWdodGVyTmFtZXNwYWNlICB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBFeHBlY3Rpbmcgb3B0LmhpZ2hsaWdodGVyIHRvIGhhdmUgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2hpZ2hsaWdodGVyLW5hbWUnLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgc29tZTogJ3ZhbHVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyRGVmID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgLy8gSXMgaGlnaGxpZ2h0aW5nIGRpc2FibGVkP1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBidWlsdC1pbiB0eXBlc1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlckRlZiA9IGhpZ2hsaWdodGluZ1t0eXBlXTtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIHNwZWNpZmljIHR5cGUgaGlnaGxpZ2h0IGRpc2FibGVkP1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRlckRlZiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGlnaGxpZ2h0ZXJEZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlIG5vdCBkZWZpbmVkIHVzZSBkZWZhdWx0IGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVyRGVmID0gaGlnaGxpZ2h0aW5nWydkZWZhdWx0J107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIG9wdC5oaWdobGlnaHRlciBpcyBmYWxzeS5cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIGNhc2UgdG8gbm90IGhpZ2hsaWdodCBjZWxsKHMpIGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byBOT1QgaGlnaGxpZ2h0IHdoZW4gZW1iZWRkaW5nIGVsZW1lbnRzXG4gICAgICAgIC8vIG9yIHVzZSBhIGN1c3RvbSBoaWdobGlnaHRlci5cbiAgICAgICAgaWYgKCFoaWdobGlnaHRlckRlZikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIEFsbG93IHNwZWNpZnlpbmcgYSBoaWdobGlnaHRlciBieSBuYW1lLlxuICAgICAgICBpZiAoaXNTdHJpbmcoaGlnaGxpZ2h0ZXJEZWYpKSB7XG4gICAgICAgICAgICBoaWdobGlnaHRlckRlZiA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBoaWdobGlnaHRlckRlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBoaWdobGlnaHRlckRlZi5uYW1lO1xuICAgICAgICBjb25zdCBoaWdobGlnaHRlciA9IGhpZ2hsaWdodGVyTmFtZXNwYWNlW25hbWVdO1xuXG4gICAgICAgIC8vIEhpZ2hsaWdodGVyIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKCFoaWdobGlnaHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGhpZ2hsaWdodGVyIChcIicgKyBuYW1lICsgJ1wiKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGlnaGxpZ2h0ZXIuaGlnaGxpZ2h0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hpZ2hsaWdodGVyIChcIicgKyBuYW1lICsgJ1wiKSBpcyBtaXNzaW5nIHJlcXVpcmVkIGhpZ2hsaWdodCgpIG1ldGhvZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGlnaGxpZ2h0ZXIgKFwiJyArIG5hbWUgKyAnXCIpIGlzIG1pc3NpbmcgcmVxdWlyZWQgdW5oaWdobGlnaHQoKSBtZXRob2QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWdobGlnaHRlcixcbiAgICAgICAgICAgIG9wdGlvbnM6IGhpZ2hsaWdodGVyRGVmLm9wdGlvbnMgfHwge30sXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG9uQ2VsbEhpZ2hsaWdodDogZnVuY3Rpb24oY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHQpIHtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yID0gdGhpcy5yZXNvbHZlSGlnaGxpZ2h0ZXIob3B0KTtcbiAgICAgICAgaWYgKCFoaWdobGlnaHRlckRlc2NyaXB0b3IpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBoaWdobGlnaHRlciwgb3B0aW9ucyB9ID0gaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yO1xuICAgICAgICBoaWdobGlnaHRlci5oaWdobGlnaHQoY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgb25DZWxsVW5oaWdobGlnaHQ6IGZ1bmN0aW9uKGNlbGxWaWV3LCBtYWduZXRFbCwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVyRGVzY3JpcHRvciA9IHRoaXMucmVzb2x2ZUhpZ2hsaWdodGVyKG9wdCk7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgaGlnaGxpZ2h0ZXIsIG9wdGlvbnMgfSA9IGhpZ2hsaWdodGVyRGVzY3JpcHRvcjtcbiAgICAgICAgaGlnaGxpZ2h0ZXIudW5oaWdobGlnaHQoY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJhY3Rpb24uXG4gICAgLy8gLS0tLS0tLS0tLS0tXG5cbiAgICBwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIG1hZ25ldHBvaW50ZXJkYmxjbGljayBjYW4gc3RvcCBwcm9wYWdhdGlvblxuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KGV2dC50YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5wb2ludGVyZGJsY2xpY2soZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICAvLyBtYWduZXRwb2ludGVyY2xpY2sgY2FuIHN0b3AgcHJvcGFnYXRpb25cblxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgb25seSBpZiBtb3VzZSBoYXMgbm90IG1vdmVkLlxuICAgICAgICBpZiAoZGF0YS5tb3VzZW1vdmVkIDw9IHRoaXMub3B0aW9ucy5jbGlja1RocmVzaG9sZCkge1xuXG4gICAgICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcoZXZ0LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG5cbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmlldy5wb2ludGVyY2xpY2soZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazpwb2ludGVyY2xpY2snLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50Q29udGV4dE1lbnUpIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRNZW51RmlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVGaXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICB0aGlzLmNvbnRleHRNZW51VHJpZ2dlcihldnQpO1xuICAgIH0sXG5cbiAgICBjb250ZXh0TWVudVRyaWdnZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcoZXZ0LnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcblxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3LmNvbnRleHRtZW51KGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOmNvbnRleHRtZW51JywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9pbnRlcmRvd246IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIGJ1dHRvbiB9ID0gZXZ0O1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyh0YXJnZXQpO1xuICAgICAgICBjb25zdCBpc0NvbnRleHRNZW51ID0gKGJ1dHRvbiA9PT0gMik7XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcblxuICAgICAgICAgICAgaWYgKCFpc0NvbnRleHRNZW51ICYmIHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpc1RhcmdldEZvcm1Ob2RlID0gdGhpcy5GT1JNX0NPTlRST0xfVEFHX05BTUVTLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdFZpZXdBY3Rpb24gJiYgIWlzVGFyZ2V0Rm9ybU5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgZm9ybSBlbGVtZW50LCB3ZSBkbyBub3Qgd2FudCB0byBwcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHNlbGVjdCB0ZXh0IGluIGEgdGV4dCBpbnB1dCBvclxuICAgICAgICAgICAgICAgIC8vIHRvIGJlIGFibGUgdG8gY2xpY2sgb24gYSBjaGVja2JveC5cbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0Rm9ybU5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgZm9ybSBlbGVtZW50LCB3ZSBkbyBub3Qgd2FudCB0byBzdGFydCBkcmFnZ2luZyB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2Ugd2FudCB0byBiZSBhYmxlIHRvIHNlbGVjdCB0ZXh0IGJ5IGRyYWdnaW5nIHRoZSBtb3VzZS5cbiAgICAgICAgICAgICAgICB2aWV3LnByZXZlbnREZWZhdWx0SW50ZXJhY3Rpb24oZXZ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3VzdG9tIGV2ZW50XG4gICAgICAgICAgICBjb25zdCBldmVudEV2dCA9IHRoaXMuY3VzdG9tRXZlbnRUcmlnZ2VyKGV2dCwgdmlldyk7XG4gICAgICAgICAgICBpZiAoZXZlbnRFdnQpIHtcbiAgICAgICAgICAgIC8vIGBvbmV2ZW50YCBjb3VsZCBoYXZlIHN0b3BwZWQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSBldmVudEV2dC5kYXRhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGVtZW50IG1hZ25ldFxuICAgICAgICAgICAgY29uc3QgbWFnbmV0Tm9kZSA9IHRhcmdldC5jbG9zZXN0KCdbbWFnbmV0XScpO1xuICAgICAgICAgICAgaWYgKG1hZ25ldE5vZGUgJiYgdmlldy5lbCAhPT0gbWFnbmV0Tm9kZSAmJiB2aWV3LmVsLmNvbnRhaW5zKG1hZ25ldE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFnbmV0RXZ0ID0gbm9ybWFsaXplRXZlbnQobmV3ICQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZXZ0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgdGhlIGV2ZW50IGxpc3RlbmVyIHdhcyBhdHRhY2hlZCB0byB0aGUgbWFnbmV0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IG1hZ25ldE5vZGVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm1hZ25ldChtYWduZXRFdnQpO1xuICAgICAgICAgICAgICAgIGlmIChtYWduZXRFdnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGBvbm1hZ25ldGAgc3RvcHMgcHJvcGFnYXRpb24gd2hlbiBgYWRkTGlua0Zyb21NYWduZXRgIGlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICBpZiAobWFnbmV0RXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYG1hZ25ldDpwb2ludGVybW92ZWAgYW5kIGBtYWduZXQ6cG9pbnRlcnVwYCBldmVudHMgbXVzdCBiZSBmaXJlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDb250ZXh0TWVudSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlRHJhZ0V2ZW50cyh2aWV3LCBtYWduZXRFdnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSBtYWduZXRFdnQuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dG1lbnVFdnQgPSBuZXcgJC5FdmVudChldnQub3JpZ2luYWxFdmVudCwgeyB0eXBlOiAnY29udGV4dG1lbnUnLCBkYXRhOiBldnQuZGF0YSB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVUcmlnZ2VyKGNvbnRleHRtZW51RXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmlldy5wb2ludGVyZG93bihldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50RGVmYXVsdEJsYW5rQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOnBvaW50ZXJkb3duJywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVEcmFnRXZlbnRzKHZpZXcsIGV2dC5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICAvLyBtb3VzZSBtb3ZlZCBjb3VudGVyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgaWYgKCFkYXRhLm1vdXNlbW92ZWQpIHtcbiAgICAgICAgICAgIGRhdGEubW91c2Vtb3ZlZCA9IDA7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBldmVudHMgbGlrZSBgbW91c2VlbnRlcmAgYW5kIGBtb3VzZWxlYXZlYCBhcmVcbiAgICAgICAgICAgIC8vIG5vdCB0cmlnZ2VyZWQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgYSBjZWxsVmlldy5cbiAgICAgICAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlIGV2ZW50cyBhcmUgdW5kZWxlZ2F0ZWQgYWZ0ZXIgdGhlIGZpcnN0IGBwb2ludGVybW92ZWAgZXZlbnQuXG4gICAgICAgICAgICAvLyBOb3Qgb24gYHBvaW50ZXJkb3duYCB0byBtYWtlIHN1cmUgdGhhdCBgZGJsdGFwYCBpcyByZWNvZ25pemVkLlxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdXNlbW92ZWQgPSArK2RhdGEubW91c2Vtb3ZlZDtcblxuICAgICAgICBpZiAobW91c2Vtb3ZlZCA8PSB0aGlzLm9wdGlvbnMubW92ZVRocmVzaG9sZCkgcmV0dXJuO1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgICAgICB2YXIgdmlldyA9IGRhdGEuc291cmNlVmlldztcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcucG9pbnRlcm1vdmUoZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOnBvaW50ZXJtb3ZlJywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIGRhdGEpO1xuICAgIH0sXG5cbiAgICBwb2ludGVydXA6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdnQuY2xpZW50WCwgbm9ybWFsaXplZEV2dC5jbGllbnRZKTtcblxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuZXZlbnREYXRhKGV2dCkuc291cmNlVmlldztcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcucG9pbnRlcnVwKG5vcm1hbGl6ZWRFdnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6cG9pbnRlcnVwJywgbm9ybWFsaXplZEV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub3JtYWxpemVkRXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlcmNsaWNrKG5ldyAkLkV2ZW50KGV2dC5vcmlnaW5hbEV2ZW50LCB7IHR5cGU6ICdjbGljaycsIGRhdGE6IGV2dC5kYXRhIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICB9LFxuXG4gICAgbW91c2VvdmVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3Lm1vdXNlb3ZlcihldnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbCA9PT0gZXZ0LnRhcmdldCkgcmV0dXJuOyAvLyBwcmV2ZW50IGJvcmRlciBvZiBwYXBlciBmcm9tIHRyaWdnZXJpbmcgdGhpc1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazptb3VzZW92ZXInLCBldnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3Lm1vdXNlb3V0KGV2dCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsID09PSBldnQudGFyZ2V0KSByZXR1cm47IC8vIHByZXZlbnQgYm9yZGVyIG9mIHBhcGVyIGZyb20gdHJpZ2dlcmluZyB0aGlzXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOm1vdXNlb3V0JywgZXZ0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZWVudGVyOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldCwgLy8gVGhlIEV2ZW50VGFyZ2V0IHRoZSBwb2ludGluZyBkZXZpY2UgZW50ZXJlZCB0b1xuICAgICAgICAgICAgcmVsYXRlZFRhcmdldCwgLy8gVGhlIEV2ZW50VGFyZ2V0IHRoZSBwb2ludGluZyBkZXZpY2UgZXhpdGVkIGZyb21cbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgLy8gVGhlIEV2ZW50VGFyZ2V0IG9uIHdoaWNoIHRoZSBldmVudCBsaXN0ZW5lciB3YXMgcmVnaXN0ZXJlZFxuICAgICAgICB9ID0gZXZ0O1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyh0YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRWaWV3ID0gdGhpcy5maW5kVmlldyhyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIGlmIChyZWxhdGVkVmlldyA9PT0gdmlldykge1xuICAgICAgICAgICAgICAgIC8vIE1vdXNlIGxlZnQgYSBjZWxsIHRvb2xcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3Lm1vdXNlZW50ZXIoZXZ0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsLmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBvaW50ZXIgcmVtYWlucyBpbnNpZGUgdGhlIHBhcGVyLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRlZFZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcmV2ZW50IGRvdWJsZSBgbW91c2VlbnRlcmAgZXZlbnQgaWYgdGhlIGByZWxhdGVkVGFyZ2V0YCBpcyBvdXRzaWRlIHRoZSBwYXBlclxuICAgICAgICAvLyAobW91c2VlbnRlciBtZXRob2Qgd291bGQgYmUgZmlyZWQgdHdpY2UpXG4gICAgICAgIGlmIChjdXJyZW50VGFyZ2V0ID09PSB0aGlzLmVsKSB7XG4gICAgICAgICAgICAvLyBgcGFwZXJgIChtb3JlIGRlc2NyaXB0aXZlKSwgbm90IGBibGFua2BcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFwZXI6bW91c2VlbnRlcicsIGV2dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91c2VsZWF2ZTogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXQsIC8vIFRoZSBFdmVudFRhcmdldCB0aGUgcG9pbnRpbmcgZGV2aWNlIGV4aXRlZCBmcm9tXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0LCAvLyBUaGUgRXZlbnRUYXJnZXQgdGhlIHBvaW50aW5nIGRldmljZSBlbnRlcmVkIHRvXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0IC8vIFRoZSBFdmVudFRhcmdldCBvbiB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgd2FzIHJlZ2lzdGVyZWRcbiAgICAgICAgfSA9IGV2dDtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuZmluZFZpZXcodGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuICAgICAgICBjb25zdCByZWxhdGVkVmlldyA9IHRoaXMuZmluZFZpZXcocmVsYXRlZFRhcmdldCk7XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAocmVsYXRlZFZpZXcgPT09IHZpZXcpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3VzZSBlbnRlcmVkIGEgY2VsbCB0b29sXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5tb3VzZWxlYXZlKGV2dCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbC5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwb2ludGVyIGhhcyBleGl0ZWQgYSBjZWxsVmlldy4gVGhlIHBvaW50ZXIgaXMgc3RpbGwgaW5zaWRlIG9mIHRoZSBwYXBlci5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0ZWRWaWV3KSB7XG4gICAgICAgICAgICAvLyBUaGUgcG9pbnRlciBoYXMgZW50ZXJlZCBhIG5ldyBjZWxsVmlld1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGBtb3VzZWxlYXZlYCBldmVudCBpZiB0aGUgYHJlbGF0ZWRUYXJnZXRgIGlzIG91dHNpZGUgdGhlIHBhcGVyXG4gICAgICAgIC8vIChtb3VzZWxlYXZlIG1ldGhvZCB3b3VsZCBiZSBmaXJlZCB0d2ljZSlcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNlbGxWaWV3IHVuZGVyIHRoZSBwb2ludGVyLCBub3IgdGhlIGJsYW5rIGFyZWEgb2YgdGhlIHBhcGVyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhcGVyOm1vdXNlbGVhdmUnLCBldnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9wcm9jZXNzTW91c2VXaGVlbEV2dEJ1ZjogZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnQsIGRlbHRhcyB9ID0gdGhpcy5fbXdfZXZ0X2J1ZmZlcjtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gZGVsdGFzLnJlZHVjZSgoYWNjLCBkZWx0YVkpID0+IGFjYyArIGNhcChkZWx0YVksIFdIRUVMX0NBUCksIDApO1xuXG4gICAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMC45OTUsIGRlbHRhWSk7IC8vIDEuMDA1IGZvciBpbnZlcnRlZCBwaW5jaC96b29tXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5jbGllbnRUb0xvY2FsUG9pbnQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFwZXI6cGluY2gnLCBldmVudCwgeCwgeSwgc2NhbGUpO1xuXG4gICAgICAgIHRoaXMuX213X2V2dF9idWZmZXIgPSB7XG4gICAgICAgICAgICBldmVudDogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhczogW10sXG4gICAgICAgIH07XG4gICAgfSwgV0hFRUxfV0FJVF9NUywgeyBtYXhXYWl0OiBXSEVFTF9XQUlUX01TIH0pLFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBldnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChvcmlnaW5hbEV2ZW50LmNsaWVudFgsIG9yaWdpbmFsRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGNvbnN0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IG5vcm1hbGl6ZVdoZWVsKG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgIGNvbnN0IHBpbmNoSGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbJ3BhcGVyOnBpbmNoJ107XG5cbiAgICAgICAgLy8gVG91Y2hwYWQgZGV2aWNlcyB3aWxsIHNlbmQgYSBmYWtlIENUUkwgcHJlc3Mgd2hlbiBhIHBpbmNoIGlzIHBlcmZvcm1lZFxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBhbHNvIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgc3Vic2NyaWJlcnMgdG8gcGFwZXI6cGluY2ggZXZlbnQuIElmIHRoZXJlIGFyZSBub25lLFxuICAgICAgICAvLyBqdXN0IHNraXAgdGhlIGVudGlyZSBibG9jayBvZiBjb2RlICh3ZSBkb24ndCB3YW50IHRvIGJsaW5kbHkgY2FsbFxuICAgICAgICAvLyAucHJldmVudERlZmF1bHQoKSBpZiB3ZSByZWFsbHkgZG9uJ3QgaGF2ZSB0bykuXG4gICAgICAgIGlmIChldnQuY3RybEtleSAmJiBwaW5jaEhhbmRsZXJzICYmIHBpbmNoSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHBpbmNoIGdlc3R1cmUsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCB3ZSBtdXN0IGNhbGwgLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX213X2V2dF9idWZmZXIuZXZlbnQgPSBldnQ7XG4gICAgICAgICAgICB0aGlzLl9td19ldnRfYnVmZmVyLmRlbHRhcy5wdXNoKGRlbHRhWSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTW91c2VXaGVlbEV2dEJ1ZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgb3JpZ2luYWxFdmVudC53aGVlbERlbHRhKSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIHZpZXcubW91c2V3aGVlbChldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55LCBkZWx0YSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazptb3VzZXdoZWVsJywgZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSwgZGVsdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhcGVyOnBhbicsIGV2dCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uZXZlbnQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHZhciBldmVudE5vZGUgPSBldnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2V2ZW50Jyk7XG4gICAgICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldmVudE5vZGUpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcblxuICAgICAgICAgICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICB2aWV3Lm9uZXZlbnQoZXZ0LCBldmVudE5hbWUsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYWduZXRFdmVudDogZnVuY3Rpb24oZXZ0LCBoYW5kbGVyKSB7XG5cbiAgICAgICAgdmFyIG1hZ25ldE5vZGUgPSBldnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgdmFyIG1hZ25ldFZhbHVlID0gbWFnbmV0Tm9kZS5nZXRBdHRyaWJ1dGUoJ21hZ25ldCcpO1xuICAgICAgICBpZiAobWFnbmV0VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhtYWduZXROb2RlKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgdmlldywgZXZ0LCBtYWduZXROb2RlLCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25tYWduZXQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGlmIChldnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYWduZXRDb250ZXh0TWVudUZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRtZW51RXZ0ID0gbmV3ICQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29udGV4dG1lbnUnLFxuICAgICAgICAgICAgICAgIGRhdGE6IGV2dC5kYXRhLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGV2dC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldENvbnRleHRNZW51VHJpZ2dlcihjb250ZXh0bWVudUV2dCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dG1lbnVFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFnbmV0RXZlbnQoZXZ0LCBmdW5jdGlvbih2aWV3LCBldnQsIF8sIHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2aWV3Lm9ubWFnbmV0KGV2dCwgeCwgeSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubWFnbmV0RXZlbnQoZXZ0LCBmdW5jdGlvbih2aWV3LCBldnQsIG1hZ25ldCwgeCwgeSkge1xuICAgICAgICAgICAgdmlldy5tYWduZXRwb2ludGVyZGJsY2xpY2soZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0Y29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRDb250ZXh0TWVudSkgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWFnbmV0Q29udGV4dE1lbnVGaXJlZCkge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRDb250ZXh0TWVudUZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hZ25ldENvbnRleHRNZW51VHJpZ2dlcihldnQpO1xuICAgIH0sXG5cbiAgICBtYWduZXRDb250ZXh0TWVudVRyaWdnZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0aGlzLm1hZ25ldEV2ZW50KGV2dCwgZnVuY3Rpb24odmlldywgZXZ0LCBtYWduZXQsIHgsIHkpIHtcbiAgICAgICAgICAgIHZpZXcubWFnbmV0Y29udGV4dG1lbnUoZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgb25sYWJlbDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdmFyIGxhYmVsTm9kZSA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhsYWJlbE5vZGUpO1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybjtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgLy8gQ3VzdG9tIGV2ZW50XG4gICAgICAgIGNvbnN0IGV2ZW50RXZ0ID0gdGhpcy5jdXN0b21FdmVudFRyaWdnZXIoZXZ0LCB2aWV3LCBsYWJlbE5vZGUpO1xuICAgICAgICBpZiAoZXZlbnRFdnQpIHtcbiAgICAgICAgICAgIC8vIGBvbmV2ZW50YCBjb3VsZCBoYXZlIHN0b3BwZWQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgIGlmIChldmVudEV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGV2dC5kYXRhID0gZXZlbnRFdnQuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG4gICAgICAgIHZpZXcub25sYWJlbChldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRlckFyZ3MoZXZ0KSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuc25hcFRvR3JpZChub3JtYWxpemVkRXZ0LmNsaWVudFgsIG5vcm1hbGl6ZWRFdnQuY2xpZW50WSk7XG4gICAgICAgIHJldHVybiBbbm9ybWFsaXplZEV2dCwgeCwgeV07XG4gICAgfSxcblxuICAgIGRlbGVnYXRlRHJhZ0V2ZW50czogZnVuY3Rpb24odmlldywgZGF0YSkge1xuXG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSB7fSk7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKHsgZGF0YTogZGF0YSB9LCB7IHNvdXJjZVZpZXc6IHZpZXcgfHwgbnVsbCwgbW91c2Vtb3ZlZDogMCB9KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKG51bGwsIGRhdGEpO1xuICAgIH0sXG5cbiAgICAvLyBHdWFyZCB0aGUgc3BlY2lmaWVkIGV2ZW50LiBJZiB0aGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQsIGd1YXJkIHJldHVybnMgYHRydWVgLlxuICAgIC8vIE90aGVyd2lzZSwgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgIGd1YXJkOiBmdW5jdGlvbihldnQsIHZpZXcpIHtcblxuICAgICAgICBpZiAoZXZ0LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2dC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZWQgYXMgYGNvbnRleHRtZW51YCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3VhcmQgJiYgdGhpcy5vcHRpb25zLmd1YXJkKGV2dCwgdmlldykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2dC5kYXRhICYmIGV2dC5kYXRhLmd1YXJkZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2dC5kYXRhLmd1YXJkZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZXZ0O1xuXG4gICAgICAgIGlmICh0aGlzLkdVQVJERURfVEFHX05BTUVTLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmlldyAmJiB2aWV3Lm1vZGVsICYmICh2aWV3Lm1vZGVsIGluc3RhbmNlb2YgQ2VsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVsID09PSB0YXJnZXQgfHwgdGhpcy5zdmcuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7ICAgIC8vIEV2ZW50IGd1YXJkZWQuIFBhcGVyIHNob3VsZCBub3QgcmVhY3Qgb24gaXQgaW4gYW55IHdheS5cbiAgICB9LFxuXG4gICAgc2V0R3JpZFNpemU6IGZ1bmN0aW9uKGdyaWRTaXplKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgb3B0aW9ucy5ncmlkU2l6ZSA9IGdyaWRTaXplO1xuICAgICAgICBpZiAob3B0aW9ucy5kcmF3R3JpZCAmJiAhb3B0aW9ucy5kcmF3R3JpZFNpemUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCByZWRyYXcgdGhlIGdyaWQgaWYgdGhlIGBkcmF3R3JpZFNpemVgIGlzIHNldC5cbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLkdSSUQpLnJlbmRlckdyaWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0R3JpZDogZnVuY3Rpb24oZHJhd0dyaWQpIHtcbiAgICAgICAgdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuR1JJRCkuc2V0R3JpZChkcmF3R3JpZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1cGRhdGVCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgYmFja2dyb3VuZFBvc2l0aW9uID0gb3B0LnBvc2l0aW9uIHx8ICdjZW50ZXInO1xuICAgICAgICB2YXIgYmFja2dyb3VuZFNpemUgPSBvcHQuc2l6ZSB8fCAnYXV0byBhdXRvJztcblxuICAgICAgICB2YXIgY3VycmVudFNjYWxlID0gdGhpcy5zY2FsZSgpO1xuICAgICAgICB2YXIgY3VycmVudFRyYW5zbGF0ZSA9IHRoaXMudHJhbnNsYXRlKCk7XG5cbiAgICAgICAgLy8gYmFja2dyb3VuZFBvc2l0aW9uXG4gICAgICAgIGlmIChpc09iamVjdChiYWNrZ3JvdW5kUG9zaXRpb24pKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGN1cnJlbnRUcmFuc2xhdGUudHggKyAoY3VycmVudFNjYWxlLnN4ICogKGJhY2tncm91bmRQb3NpdGlvbi54IHx8IDApKTtcbiAgICAgICAgICAgIHZhciB5ID0gY3VycmVudFRyYW5zbGF0ZS50eSArIChjdXJyZW50U2NhbGUuc3kgKiAoYmFja2dyb3VuZFBvc2l0aW9uLnkgfHwgMCkpO1xuICAgICAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uID0geCArICdweCAnICsgeSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrZ3JvdW5kU2l6ZVxuICAgICAgICBpZiAoaXNPYmplY3QoYmFja2dyb3VuZFNpemUpKSB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSA9IG5ldyBSZWN0KGJhY2tncm91bmRTaXplKS5zY2FsZShjdXJyZW50U2NhbGUuc3gsIGN1cnJlbnRTY2FsZS5zeSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZSA9IGJhY2tncm91bmRTaXplLndpZHRoICsgJ3B4ICcgKyBiYWNrZ3JvdW5kU2l6ZS5oZWlnaHQgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBiYWNrZ3JvdW5kIH0gPSB0aGlzLmNoaWxkTm9kZXM7XG4gICAgICAgIGJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZFNpemUgPSBiYWNrZ3JvdW5kU2l6ZTtcbiAgICAgICAgYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBiYWNrZ3JvdW5kUG9zaXRpb247XG4gICAgfSxcblxuICAgIGRyYXdCYWNrZ3JvdW5kSW1hZ2U6IGZ1bmN0aW9uKGltZywgb3B0KSB7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIGJhY2tncm91bmQgaW1hZ2UgaWYgbm8gaW1hZ2UgcHJvdmlkZWRcbiAgICAgICAgaWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGROb2Rlcy5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICcnO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9iYWNrZ3JvdW5kIHx8IHRoaXMuX2JhY2tncm91bmQuaWQgIT09IG9wdC5pZCkge1xuICAgICAgICAgICAgLy8gRHJhdyBvbmx5IHRoZSBsYXN0IGltYWdlIHJlcXVlc3RlZCAoc2VlIGRyYXdCYWNrZ3JvdW5kKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIGJhY2tncm91bmRJbWFnZTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRTaXplID0gb3B0LnNpemU7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kUmVwZWF0ID0gb3B0LnJlcGVhdCB8fCAnbm8tcmVwZWF0JztcbiAgICAgICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gb3B0Lm9wYWNpdHkgfHwgMTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRRdWFsaXR5ID0gTWF0aC5hYnMob3B0LnF1YWxpdHkpIHx8IDE7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kUGF0dGVybiA9IHRoaXMuY29uc3RydWN0b3IuYmFja2dyb3VuZFBhdHRlcm5zW2NhbWVsQ2FzZShiYWNrZ3JvdW5kUmVwZWF0KV07XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYmFja2dyb3VuZFBhdHRlcm4pKSB7XG4gICAgICAgICAgICAvLyAnZmxpcC14JywgJ2ZsaXAteScsICdmbGlwLXh5JywgJ3dhdGVybWFyaycgYW5kIGN1c3RvbVxuICAgICAgICAgICAgaW1nLndpZHRoICo9IGJhY2tncm91bmRRdWFsaXR5O1xuICAgICAgICAgICAgaW1nLmhlaWdodCAqPSBiYWNrZ3JvdW5kUXVhbGl0eTtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBiYWNrZ3JvdW5kUGF0dGVybihpbWcsIG9wdCk7XG4gICAgICAgICAgICBpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5QYXBlcjogYmFja2dyb3VuZCBwYXR0ZXJuIG11c3QgcmV0dXJuIGFuIEhUTUwgQ2FudmFzIGluc3RhbmNlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgYmFja2dyb3VuZFJlcGVhdCA9ICdyZXBlYXQnO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGJhY2tncm91bmRTaXplKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSB0aWxlIHNpemUgaWYgYW4gb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRTaXplLndpZHRoICo9IGNhbnZhcy53aWR0aCAvIGltZy53aWR0aDtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZS5oZWlnaHQgKj0gY2FudmFzLmhlaWdodCAvIGltZy5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJhY2tncm91bmRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRpbGUgc2l6ZSBpZiBubyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIG9wdC5zaXplID0ge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoIC8gYmFja2dyb3VuZFF1YWxpdHksXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCAvIGJhY2tncm91bmRRdWFsaXR5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJhY2tncm91bmRSZXBlYXQ6XG4gICAgICAgICAgICAvLyBuby1yZXBlYXQnLCAncm91bmQnLCAnc3BhY2UnLCAncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15J1xuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlID0gaW1nLnNyYztcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFzcyB0aGUgaW1hZ2Ugc2l6ZSBmb3IgIHRoZSBiYWNrZ3JvdW5kU2l6ZSBpZiBubyBzaXplIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgb3B0LnNpemUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoaWxkTm9kZXMuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gYmFja2dyb3VuZE9wYWNpdHk7XG4gICAgICAgIHRoaXMuY2hpbGROb2Rlcy5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBiYWNrZ3JvdW5kUmVwZWF0O1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXMuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7YmFja2dyb3VuZEltYWdlfSlgO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZEltYWdlKG9wdCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24oY29sb3IpIHtcblxuICAgICAgICB0aGlzLiRlbC5jc3MoJ2JhY2tncm91bmRDb2xvcicsIGNvbG9yIHx8ICcnKTtcbiAgICB9LFxuXG4gICAgZHJhd0JhY2tncm91bmQ6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUJhY2tncm91bmRDb2xvcihvcHQuY29sb3IpO1xuXG4gICAgICAgIGlmIChvcHQuaW1hZ2UpIHtcbiAgICAgICAgICAgIG9wdCA9IHRoaXMuX2JhY2tncm91bmQgPSBjbG9uZURlZXAob3B0KTtcbiAgICAgICAgICAgIGd1aWQob3B0KTtcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSB0aGlzLmRyYXdCYWNrZ3JvdW5kSW1hZ2UuYmluZCh0aGlzLCBpbWcsIG9wdCk7XG4gICAgICAgICAgICBpbWcuc3JjID0gb3B0LmltYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZEltYWdlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0SW50ZXJhY3Rpdml0eTogZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUgPSB2YWx1ZTtcblxuICAgICAgICBpbnZva2UodGhpcy5fdmlld3MsICdzZXRJbnRlcmFjdGl2aXR5JywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyBQYXBlciBkZWZpbml0aW9ucy5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGlzRGVmaW5lZDogZnVuY3Rpb24oZGVmSWQpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLnN2Zy5nZXRFbGVtZW50QnlJZChkZWZJZCk7XG4gICAgfSxcblxuICAgIGRlZmluZUZpbHRlcjogZnVuY3Rpb24oZmlsdGVyKSB7XG5cbiAgICAgICAgaWYgKCFpc09iamVjdChmaWx0ZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuUGFwZXI6IGRlZmluZUZpbHRlcigpIHJlcXVpcmVzIDEuIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWx0ZXJJZCA9IGZpbHRlci5pZDtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWx0ZXIubmFtZTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBoYXNoIGNvZGUgZnJvbSB0aGUgc3RyaW5naWZpZWQgZmlsdGVyIGRlZmluaXRpb24uIFRoaXMgZ2l2ZXMgdXNcbiAgICAgICAgLy8gYSB1bmlxdWUgZmlsdGVyIElEIGZvciBkaWZmZXJlbnQgZGVmaW5pdGlvbnMuXG4gICAgICAgIGlmICghZmlsdGVySWQpIHtcbiAgICAgICAgICAgIGZpbHRlcklkID0gbmFtZSArIHRoaXMuc3ZnLmlkICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkoZmlsdGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGZpbHRlciBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgYW5kIHdlIGNhbiBqdXN0IHVzZSBpdCAocmVmZXJlbmNlIGl0IHVzaW5nIGB1cmwoKWApLlxuICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBvbmUuXG4gICAgICAgIGlmICghdGhpcy5pc0RlZmluZWQoZmlsdGVySWQpKSB7XG5cbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBfZmlsdGVyO1xuICAgICAgICAgICAgdmFyIGZpbHRlclNWR1N0cmluZyA9IG5hbWVzcGFjZVtuYW1lXSAmJiBuYW1lc3BhY2VbbmFtZV0oZmlsdGVyLmFyZ3MgfHwge30pO1xuICAgICAgICAgICAgaWYgKCFmaWx0ZXJTVkdTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1leGlzdGluZyBmaWx0ZXIgJyArIG5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTVkcgPGZpbHRlci8+IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIHZhciBmaWx0ZXJBdHRycyA9IGFzc2lnbih7XG4gICAgICAgICAgICAgICAgZmlsdGVyVW5pdHM6ICd1c2VyU3BhY2VPblVzZScsXG4gICAgICAgICAgICB9LCBmaWx0ZXIuYXR0cnMsIHtcbiAgICAgICAgICAgICAgICBpZDogZmlsdGVySWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBWKGZpbHRlclNWR1N0cmluZywgZmlsdGVyQXR0cnMpLmFwcGVuZFRvKHRoaXMuZGVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgfSxcblxuICAgIGRlZmluZUdyYWRpZW50OiBmdW5jdGlvbihncmFkaWVudCkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGdyYWRpZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlhLlBhcGVyOiBkZWZpbmVHcmFkaWVudCgpIHJlcXVpcmVzIDEuIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN2ZywgZGVmcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgaGFzaCBjb2RlIGZyb20gdGhlIHN0cmluZ2lmaWVkIGZpbHRlciBkZWZpbml0aW9uLiBUaGlzIGdpdmVzIHVzXG4gICAgICAgICAgICAvLyBhIHVuaXF1ZSBmaWx0ZXIgSUQgZm9yIGRpZmZlcmVudCBkZWZpbml0aW9ucy5cbiAgICAgICAgICAgIGlkID0gdHlwZSArIHN2Zy5pZCArIGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KGdyYWRpZW50KSksXG4gICAgICAgICAgICBzdG9wcyxcbiAgICAgICAgICAgIGF0dHJzID0ge31cbiAgICAgICAgfSA9IGdyYWRpZW50O1xuICAgICAgICAvLyBJZiB0aGUgZ3JhZGllbnQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRvY3VtZW50LFxuICAgICAgICAvLyB3ZSdyZSBkb25lIGFuZCB3ZSBjYW4ganVzdCB1c2UgaXQgKHJlZmVyZW5jZSBpdCB1c2luZyBgdXJsKClgKS5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZpbmVkKGlkKSkgcmV0dXJuIGlkO1xuICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBvbmUuXG4gICAgICAgIGNvbnN0IHN0b3BWRWxzID0gdG9BcnJheShzdG9wcykubWFwKCh7IG9mZnNldCwgY29sb3IsIG9wYWNpdHkgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFYoJ3N0b3AnKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAnb2Zmc2V0Jzogb2Zmc2V0LFxuICAgICAgICAgICAgICAgICdzdG9wLWNvbG9yJzogY29sb3IsXG4gICAgICAgICAgICAgICAgJ3N0b3Atb3BhY2l0eSc6IE51bWJlci5pc0Zpbml0ZShvcGFjaXR5KSA/IG9wYWNpdHkgOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdyYWRpZW50VkVsID0gVih0eXBlLCBhdHRycywgc3RvcFZFbHMpO1xuICAgICAgICBncmFkaWVudFZFbC5pZCA9IGlkO1xuICAgICAgICBncmFkaWVudFZFbC5hcHBlbmRUbyhkZWZzKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG5cbiAgICBkZWZpbmVQYXR0ZXJuOiBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QocGF0dGVybikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5QYXBlcjogZGVmaW5lUGF0dGVybigpIHJlcXVpcmVzIDEuIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN2ZywgZGVmcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBoYXNoIGNvZGUgZnJvbSB0aGUgc3RyaW5naWZpZWQgZmlsdGVyIGRlZmluaXRpb24uIFRoaXMgZ2l2ZXMgdXNcbiAgICAgICAgICAgIC8vIGEgdW5pcXVlIGZpbHRlciBJRCBmb3IgZGlmZmVyZW50IGRlZmluaXRpb25zLlxuICAgICAgICAgICAgaWQgPSBzdmcuaWQgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShwYXR0ZXJuKSksXG4gICAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgICBhdHRycyA9IHt9XG4gICAgICAgIH0gPSBwYXR0ZXJuO1xuICAgICAgICBpZiAoIW1hcmt1cCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlhLlBhcGVyOiBkZWZpbmVQYXR0ZXJuKCkgcmVxdWlyZXMgbWFya3VwLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBncmFkaWVudCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgYW5kIHdlIGNhbiBqdXN0IHVzZSBpdCAocmVmZXJlbmNlIGl0IHVzaW5nIGB1cmwoKWApLlxuICAgICAgICBpZiAodGhpcy5pc0RlZmluZWQoaWQpKSByZXR1cm4gaWQ7XG4gICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZS5cbiAgICAgICAgY29uc3QgcGF0dGVyblZFbCA9IFYoJ3BhdHRlcm4nLCB7XG4gICAgICAgICAgICBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdHRlcm5WRWwuaWQgPSBpZDtcbiAgICAgICAgcGF0dGVyblZFbC5hdHRyKGF0dHJzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuVkVsLmFwcGVuZChWKG1hcmt1cCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBmcmFnbWVudCB9ID0gcGFyc2VET01KU09OKG1hcmt1cCk7XG4gICAgICAgICAgICBwYXR0ZXJuVkVsLmFwcGVuZChmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVyblZFbC5hcHBlbmRUbyhkZWZzKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG5cbiAgICBkZWZpbmVNYXJrZXI6IGZ1bmN0aW9uKG1hcmtlcikge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KG1hcmtlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5QYXBlcjogZGVmaW5lTWFya2VyKCkgcmVxdWlyZXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN2ZywgZGVmcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBoYXNoIGNvZGUgZnJvbSB0aGUgc3RyaW5naWZpZWQgZmlsdGVyIGRlZmluaXRpb24uIFRoaXMgZ2l2ZXMgdXNcbiAgICAgICAgICAgIC8vIGEgdW5pcXVlIGZpbHRlciBJRCBmb3IgZGlmZmVyZW50IGRlZmluaXRpb25zLlxuICAgICAgICAgICAgaWQgPSBzdmcuaWQgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShtYXJrZXIpKSxcbiAgICAgICAgICAgIC8vIHVzZXItcHJvdmlkZWQgbWFya3VwXG4gICAgICAgICAgICAvLyAoZS5nLiBkZWZpbmVkIHdoZW4gY3JlYXRpbmcgbGluayB2aWEgYGF0dHJzL2xpbmUvc291cmNlTWFya2VyL21hcmt1cGApXG4gICAgICAgICAgICBtYXJrdXAsXG4gICAgICAgICAgICAvLyB1c2VyLXByb3ZpZGVkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIChlLmcuIGRlZmluZWQgd2hlbiBjcmVhdGluZyBsaW5rIHZpYSBgYXR0cnMvbGluZS9zb3VyY2VNYXJrZXIvYXR0cnNgKVxuICAgICAgICAgICAgLy8gbm90ZTogYHRyYW5zZm9ybWAgYXR0cnMgYXJlIGlnbm9yZWQgYnkgYnJvd3NlcnNcbiAgICAgICAgICAgIGF0dHJzID0ge30sXG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkIC0gdXNlIGBhdHRycy9tYXJrZXJVbml0c2AgaW5zdGVhZCAod2hpY2ggaGFzIGhpZ2hlciBwcmlvcml0eSlcbiAgICAgICAgICAgIG1hcmtlclVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgICB9ID0gbWFya2VyO1xuICAgICAgICAvLyBJZiB0aGUgbWFya2VyIGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudCxcbiAgICAgICAgLy8gd2UncmUgZG9uZSBhbmQgd2UgY2FuIGp1c3QgdXNlIGl0IChyZWZlcmVuY2UgaXQgdXNpbmcgYHVybCgpYCkuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmaW5lZChpZCkpIHJldHVybiBpZDtcbiAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lLlxuICAgICAgICBjb25zdCBtYXJrZXJWRWwgPSBWKCdtYXJrZXInLCB7XG4gICAgICAgICAgICBvcmllbnQ6ICdhdXRvJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAndmlzaWJsZScsXG4gICAgICAgICAgICBtYXJrZXJVbml0czogbWFya2VyVW5pdHNcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtlclZFbC5pZCA9IGlkO1xuICAgICAgICBtYXJrZXJWRWwuYXR0cihhdHRycyk7XG4gICAgICAgIGxldCBtYXJrZXJDb250ZW50VkVsO1xuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgICBsZXQgbWFya3VwVkVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFya2VyIG9iamVjdCBoYXMgYSBgbWFya3VwYCBwcm9wZXJ0eSBvZiB0eXBlIHN0cmluZy5cbiAgICAgICAgICAgICAgICAvLyAtIENvbnN0cnVjdCBWIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBtYXJrdXBWRWwgPSBWKG1hcmt1cCk7XG4gICAgICAgICAgICAgICAgLy8gYG1hcmt1cFZFbGAgaXMgbm93IGVpdGhlciBhIHNpbmdsZSBWRWwsIG9yIGFuIGFycmF5IG9mIFZFbHMuXG4gICAgICAgICAgICAgICAgLy8gLSBDb2VyY2UgaXQgdG8gYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgbWFya3VwVkVsID0gKEFycmF5LmlzQXJyYXkobWFya3VwVkVsKSA/IG1hcmt1cFZFbCA6IFttYXJrdXBWRWxdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWFya2VyIG9iamVjdCBoYXMgYSBgbWFya3VwYCBwcm9wZXJ0eSBvZiB0eXBlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAvLyAtIENvbnN0cnVjdCBWIGZyb20gdGhlIG9iamVjdCBieSBwYXJzaW5nIGl0IGFzIERPTSBKU09OLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJhZ21lbnQgfSA9IHBhcnNlRE9NSlNPTihtYXJrdXApO1xuICAgICAgICAgICAgICAgIG1hcmt1cFZFbCA9IFYoZnJhZ21lbnQpLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBgbWFya3VwVkVsYCBpcyBhbiBhcnJheSB3aXRoIG9uZSBvciBtb3JlIFZFbHMgaW5zaWRlLlxuICAgICAgICAgICAgLy8gLSBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgVkVscywgd3JhcCB0aGVtIGluIGEgbmV3bHktY29uc3RydWN0ZWQgPGc+IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChtYXJrdXBWRWwubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIG1hcmtlckNvbnRlbnRWRWwgPSBWKCdnJykuYXBwZW5kKG1hcmt1cFZFbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcmtlckNvbnRlbnRWRWwgPSBtYXJrdXBWRWxbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBNYXJrZXIgb2JqZWN0IGlzIGEgZmxhdCBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAvLyAtIENvbnN0cnVjdCBhIG5ldyBWIG9mIHR5cGUgYG1hcmtlci50eXBlYC5cbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSA9ICdwYXRoJyB9ID0gbWFya2VyO1xuICAgICAgICAgICAgbWFya2VyQ29udGVudFZFbCA9IFYodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYG1hcmtlckNvbnRlbnRWRWxgIGlzIGEgc2luZ2xlIFZFbC5cbiAgICAgICAgLy8gQXNzaWduIGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byBpdCAoPSBjb250ZXh0IGF0dHJpYnV0ZXMgKyBtYXJrZXIgYXR0cmlidXRlcyk6XG4gICAgICAgIC8vIC0gQXR0cmlidXRlIHZhbHVlcyBhcmUgdGFrZW4gZnJvbSBub24tc3BlY2lhbCBwcm9wZXJ0aWVzIG9mIGBtYXJrZXJgLlxuICAgICAgICBjb25zdCBtYXJrZXJBdHRycyA9IG9taXQobWFya2VyLCAndHlwZScsICdpZCcsICdtYXJrdXAnLCAnYXR0cnMnLCAnbWFya2VyVW5pdHMnKTtcbiAgICAgICAgY29uc3QgbWFya2VyQXR0cnNLZXlzID0gT2JqZWN0LmtleXMobWFya2VyQXR0cnMpO1xuICAgICAgICBtYXJrZXJBdHRyc0tleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hcmtlckF0dHJzW2tleV07XG4gICAgICAgICAgICBjb25zdCBtYXJrdXBWYWx1ZSA9IG1hcmtlckNvbnRlbnRWRWwuYXR0cihrZXkpOyAvLyB2YWx1ZSBjb21pbmcgZnJvbSBtYXJrdXBWRWwgKGlmIGFueSkgPSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChtYXJrdXBWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBsb2dpYzpcbiAgICAgICAgICAgICAgICBtYXJrZXJDb250ZW50VkVsLmF0dHIoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgd2l0aCBzcGVjaWFsIGxvZ2ljIHNob3VsZCBiZSBhZGRlZCBhcyBjYXNlcyB0byB0aGlzIHN3aXRjaCBibG9jazpcbiAgICAgICAgICAgICAgICBzd2l0Y2goa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIFByZXBlbmQgYHRyYW5zZm9ybWAgdG8gZXhpc3RpbmcgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJDb250ZW50VkVsLmF0dHIoa2V5LCAodmFsdWUgKyAnICcgKyBtYXJrdXBWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWFya2VyQ29udGVudFZFbC5hcHBlbmRUbyhtYXJrZXJWRWwpO1xuICAgICAgICBtYXJrZXJWRWwuYXBwZW5kVG8oZGVmcyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9LFxuXG4gICAgY3VzdG9tRXZlbnRUcmlnZ2VyOiBmdW5jdGlvbihldnQsIHZpZXcsIHJvb3ROb2RlID0gdmlldy5lbCkge1xuXG4gICAgICAgIGNvbnN0IGV2ZW50Tm9kZSA9IGV2dC50YXJnZXQuY2xvc2VzdCgnW2V2ZW50XScpO1xuXG4gICAgICAgIGlmIChldmVudE5vZGUgJiYgcm9vdE5vZGUgIT09IGV2ZW50Tm9kZSAmJiB2aWV3LmVsLmNvbnRhaW5zKGV2ZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RXZ0ID0gbm9ybWFsaXplRXZlbnQobmV3ICQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBldnQuZGF0YSxcbiAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IHRoZSBldmVudCBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgdG8gdGhlIGV2ZW50IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogZXZlbnROb2RlXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMub25ldmVudChldmVudEV2dCk7XG5cbiAgICAgICAgICAgIGlmIChldmVudEV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXZlbnRFdnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbn0sIHtcblxuICAgIHNvcnRpbmc6IHNvcnRpbmdUeXBlcyxcblxuICAgIExheWVyczogTGF5ZXJzTmFtZXMsXG5cbiAgICBiYWNrZ3JvdW5kUGF0dGVybnM6IHtcblxuICAgICAgICBmbGlwWHk6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgLy8gZCBiXG4gICAgICAgICAgICAvLyBxIHBcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDIgKiBpbWdXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSAyICogaW1nSGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAvLyB0b3AtbGVmdCBpbWFnZVxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8geHktZmxpcHBlZCBib3R0b20tcmlnaHQgaW1hZ2VcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLTEsIDAsIDAsIC0xLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8geC1mbGlwcGVkIHRvcC1yaWdodCBpbWFnZVxuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgtMSwgMCwgMCwgMSwgY2FudmFzLndpZHRoLCAwKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIHktZmxpcHBlZCBib3R0b20tbGVmdCBpbWFnZVxuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxpcFg6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgLy8gZCBiXG4gICAgICAgICAgICAvLyBkIGJcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZ1dpZHRoICogMjtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWdIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIC8vIGxlZnQgaW1hZ2VcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIGZsaXBwZWQgcmlnaHQgaW1hZ2VcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMiAqIGltZ1dpZHRoLCAwKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmxpcFk6IGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgICAgLy8gZCBkXG4gICAgICAgICAgICAvLyBxIHFcblxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZ1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZ0hlaWdodCAqIDI7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIC8vIHRvcCBpbWFnZVxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8gZmxpcHBlZCBib3R0b20gaW1hZ2VcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgMiAqIGltZ0hlaWdodCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdhdGVybWFyazogZnVuY3Rpb24oaW1nLCBvcHQpIHtcbiAgICAgICAgICAgIC8vICAgZFxuICAgICAgICAgICAgLy8gZFxuXG4gICAgICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgICAgIHZhciBpbWdIZWlnaHQgPSBpbWcuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWdXaWR0aCAqIDM7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0ICogMztcblxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gaXNOdW1iZXIob3B0LndhdGVybWFya0FuZ2xlKSA/IC1vcHQud2F0ZXJtYXJrQW5nbGUgOiAtMjA7XG4gICAgICAgICAgICB2YXIgcmFkaWFucyA9IHRvUmFkKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBzdGVwWCA9IGNhbnZhcy53aWR0aCAvIDQ7XG4gICAgICAgICAgICB2YXIgc3RlcFkgPSBjYW52YXMuaGVpZ2h0IC8gNDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGkgKyBqKSAlIDIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNldCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgKDIgKiBpIC0gMSkgKiBzdGVwWCwgKDIgKiBqIC0gMSkgKiBzdGVwWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucm90YXRlKHJhZGlhbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIC1pbWdXaWR0aCAvIDIsIC1pbWdIZWlnaHQgLyAyLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBncmlkUGF0dGVybnM6IHtcbiAgICAgICAgZG90OiBbe1xuICAgICAgICAgICAgY29sb3I6ICcjQUFBQUFBJyxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgIG1hcmt1cDogJ3JlY3QnLFxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihlbCwgb3B0KSB7XG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBvcHQudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdC50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IG9wdC5jb2xvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZml4ZWREb3Q6IFt7XG4gICAgICAgICAgICBjb2xvcjogJyNBQUFBQUEnLFxuICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgbWFya3VwOiAncmVjdCcsXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGVsLCBvcHQpIHtcbiAgICAgICAgICAgICAgICBWKGVsKS5hdHRyKHsgZmlsbDogb3B0LmNvbG9yIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24oZWwsIG9wdCwgcGFwZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN4LCBzeSB9ID0gcGFwZXIuc2NhbGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IHN4IDw9IDEgPyBvcHQudGhpY2tuZXNzIDogb3B0LnRoaWNrbmVzcyAvIHN4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHN5IDw9IDEgPyBvcHQudGhpY2tuZXNzIDogb3B0LnRoaWNrbmVzcyAvIHN5O1xuICAgICAgICAgICAgICAgIFYoZWwpLmF0dHIoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgbWVzaDogW3tcbiAgICAgICAgICAgIGNvbG9yOiAnI0FBQUFBQScsXG4gICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICBtYXJrdXA6ICdwYXRoJyxcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oZWwsIG9wdCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gb3B0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBvcHQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB0aGlja25lc3MgPSBvcHQudGhpY2tuZXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIC0gdGhpY2tuZXNzID49IDAgJiYgaGVpZ2h0IC0gdGhpY2tuZXNzID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IFsnTScsIHdpZHRoLCAwLCAnSDAgTTAgMCBWMCcsIGhlaWdodF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnTSAwIDAgMCAwJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBWKGVsKS5hdHRyKHsgJ2QnOiBkLCBzdHJva2U6IG9wdC5jb2xvciwgJ3N0cm9rZS13aWR0aCc6IG9wdC50aGlja25lc3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICBkb3VibGVNZXNoOiBbe1xuICAgICAgICAgICAgY29sb3I6ICcjQUFBQUFBJyxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgIG1hcmt1cDogJ3BhdGgnLFxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihlbCwgb3B0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBvcHQud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IG9wdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRoaWNrbmVzcyA9IG9wdC50aGlja25lc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAod2lkdGggLSB0aGlja25lc3MgPj0gMCAmJiBoZWlnaHQgLSB0aGlja25lc3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gWydNJywgd2lkdGgsIDAsICdIMCBNMCAwIFYwJywgaGVpZ2h0XS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICdNIDAgMCAwIDAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFYoZWwpLmF0dHIoeyAnZCc6IGQsIHN0cm9rZTogb3B0LmNvbG9yLCAnc3Ryb2tlLXdpZHRoJzogb3B0LnRoaWNrbmVzcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMyxcbiAgICAgICAgICAgIHNjYWxlRmFjdG9yOiA0LFxuICAgICAgICAgICAgbWFya3VwOiAncGF0aCcsXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGVsLCBvcHQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9wdC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gb3B0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gb3B0LnRoaWNrbmVzcztcblxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCAtIHRoaWNrbmVzcyA+PSAwICYmIGhlaWdodCAtIHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBbJ00nLCB3aWR0aCwgMCwgJ0gwIE0wIDAgVjAnLCBoZWlnaHRdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gJ00gMCAwIDAgMCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7ICdkJzogZCwgc3Ryb2tlOiBvcHQuY29sb3IsICdzdHJva2Utd2lkdGgnOiBvcHQudGhpY2tuZXNzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XVxuICAgIH1cbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/Paper.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/PaperLayer.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/PaperLayer.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayersNames: () => (/* binding */ LayersNames),\n/* harmony export */   PaperLayer: () => (/* binding */ PaperLayer)\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nconst LayersNames = {\n    GRID: 'grid',\n    CELLS: 'cells',\n    BACK: 'back',\n    FRONT: 'front',\n    TOOLS: 'tools',\n    LABELS: 'labels'\n};\n\nconst PaperLayer = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n\n    tagName: 'g',\n    svgElement: true,\n    pivotNodes: null,\n    defaultTheme: null,\n\n    options: {\n        name: ''\n    },\n\n    className: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix)(`${this.options.name}-layer`);\n    },\n\n    init: function() {\n        this.pivotNodes = {};\n    },\n\n    insertSortedNode: function(node, z) {\n        this.el.insertBefore(node, this.insertPivot(z));\n    },\n\n    insertNode: function(node) {\n        const { el } = this;\n        if (node.parentNode !== el) {\n            el.appendChild(node);\n        }\n    },\n\n    insertPivot: function(z) {\n        const { el, pivotNodes } = this;\n        z = +z;\n        z || (z = 0);\n        let pivotNode = pivotNodes[z];\n        if (pivotNode) return pivotNode;\n        pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));\n        let neighborZ = -Infinity;\n        for (let currentZ in pivotNodes) {\n            currentZ = +currentZ;\n            if (currentZ < z && currentZ > neighborZ) {\n                neighborZ = currentZ;\n                if (neighborZ === z - 1) continue;\n            }\n        }\n        if (neighborZ !== -Infinity) {\n            const neighborPivot = pivotNodes[neighborZ];\n            // Insert After\n            el.insertBefore(pivotNode, neighborPivot.nextSibling);\n        } else {\n            // First Child\n            el.insertBefore(pivotNode, el.firstChild);\n        }\n        return pivotNode;\n    },\n\n    removePivots: function() {\n        const { el, pivotNodes } = this;\n        for (let z in pivotNodes) el.removeChild(pivotNodes[z]);\n        this.pivotNodes = {};\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9QYXBlckxheWVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ2M7O0FBRS9DO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sbUJBQW1CLGdEQUFJOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsa0VBQWtCLElBQUksa0JBQWtCO0FBQ3ZELEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvUGFwZXJMYXllci5tanM/ZGQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaWV3IH0gZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBhZGRDbGFzc05hbWVQcmVmaXggfSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcblxuZXhwb3J0IGNvbnN0IExheWVyc05hbWVzID0ge1xuICAgIEdSSUQ6ICdncmlkJyxcbiAgICBDRUxMUzogJ2NlbGxzJyxcbiAgICBCQUNLOiAnYmFjaycsXG4gICAgRlJPTlQ6ICdmcm9udCcsXG4gICAgVE9PTFM6ICd0b29scycsXG4gICAgTEFCRUxTOiAnbGFiZWxzJ1xufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVyTGF5ZXIgPSBWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAnZycsXG4gICAgc3ZnRWxlbWVudDogdHJ1ZSxcbiAgICBwaXZvdE5vZGVzOiBudWxsLFxuICAgIGRlZmF1bHRUaGVtZTogbnVsbCxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgbmFtZTogJydcbiAgICB9LFxuXG4gICAgY2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFkZENsYXNzTmFtZVByZWZpeChgJHt0aGlzLm9wdGlvbnMubmFtZX0tbGF5ZXJgKTtcbiAgICB9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucGl2b3ROb2RlcyA9IHt9O1xuICAgIH0sXG5cbiAgICBpbnNlcnRTb3J0ZWROb2RlOiBmdW5jdGlvbihub2RlLCB6KSB7XG4gICAgICAgIHRoaXMuZWwuaW5zZXJ0QmVmb3JlKG5vZGUsIHRoaXMuaW5zZXJ0UGl2b3QoeikpO1xuICAgIH0sXG5cbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUgIT09IGVsKSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRQaXZvdDogZnVuY3Rpb24oeikge1xuICAgICAgICBjb25zdCB7IGVsLCBwaXZvdE5vZGVzIH0gPSB0aGlzO1xuICAgICAgICB6ID0gK3o7XG4gICAgICAgIHogfHwgKHogPSAwKTtcbiAgICAgICAgbGV0IHBpdm90Tm9kZSA9IHBpdm90Tm9kZXNbel07XG4gICAgICAgIGlmIChwaXZvdE5vZGUpIHJldHVybiBwaXZvdE5vZGU7XG4gICAgICAgIHBpdm90Tm9kZSA9IHBpdm90Tm9kZXNbel0gPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd6LWluZGV4OicgKyAoeiArIDEpKTtcbiAgICAgICAgbGV0IG5laWdoYm9yWiA9IC1JbmZpbml0eTtcbiAgICAgICAgZm9yIChsZXQgY3VycmVudFogaW4gcGl2b3ROb2Rlcykge1xuICAgICAgICAgICAgY3VycmVudFogPSArY3VycmVudFo7XG4gICAgICAgICAgICBpZiAoY3VycmVudFogPCB6ICYmIGN1cnJlbnRaID4gbmVpZ2hib3JaKSB7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JaID0gY3VycmVudFo7XG4gICAgICAgICAgICAgICAgaWYgKG5laWdoYm9yWiA9PT0geiAtIDEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZWlnaGJvclogIT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JQaXZvdCA9IHBpdm90Tm9kZXNbbmVpZ2hib3JaXTtcbiAgICAgICAgICAgIC8vIEluc2VydCBBZnRlclxuICAgICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKHBpdm90Tm9kZSwgbmVpZ2hib3JQaXZvdC5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBDaGlsZFxuICAgICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKHBpdm90Tm9kZSwgZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpdm90Tm9kZTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlUGl2b3RzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBlbCwgcGl2b3ROb2RlcyB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgeiBpbiBwaXZvdE5vZGVzKSBlbC5yZW1vdmVDaGlsZChwaXZvdE5vZGVzW3pdKTtcbiAgICAgICAgdGhpcy5waXZvdE5vZGVzID0ge307XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ToolView.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolView: () => (/* binding */ ToolView)\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n\n\nconst ToolView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    name: null,\n    tagName: 'g',\n    className: 'tool',\n    svgElement: true,\n    _visible: true,\n    _visibleExplicit: true,\n\n    init: function() {\n        var name = this.name;\n        if (name) this.vel.attr('data-tool-name', name);\n    },\n\n    configure: function(view, toolsView) {\n        this.relatedView = view;\n        this.paper = view.paper;\n        this.parentView = toolsView;\n        this.simulateRelatedView(this.el);\n        // Delegate events in case the ToolView was removed from the DOM and reused.\n        this.delegateEvents();\n        return this;\n    },\n\n    simulateRelatedView: function(el) {\n        if (el) el.setAttribute('model-id', this.relatedView.model.id);\n    },\n\n    getName: function() {\n        return this.name;\n    },\n\n    // Evaluate the visibility of the tool and update the `display` CSS property\n    updateVisibility: function() {\n        const isVisible = this.computeVisibility();\n        this.el.style.display = isVisible ? '' : 'none';\n        this._visible = isVisible;\n    },\n\n    // Evaluate the visibility of the tool. The method returns `true` if the tool\n    // should be visible in the DOM.\n    computeVisibility() {\n        if (!this.isExplicitlyVisible()) return false;\n        const { visibility } = this.options;\n        if (typeof visibility !== 'function') return true;\n        return !!visibility.call(this, this.relatedView, this);\n    },\n\n    show: function() {\n        this._visibleExplicit = true;\n        this.updateVisibility();\n    },\n\n    hide: function() {\n        this._visibleExplicit = false;\n        this.updateVisibility();\n    },\n\n    // The method returns `false` if the `hide()` method was called on the tool.\n    isExplicitlyVisible: function() {\n        return !!this._visibleExplicit;\n    },\n\n    // The method returns `false` if the tool is not visible (it has `display: none`).\n    // This can happen if the `hide()` method was called or the tool is not visible\n    // because of the `visibility` option was evaluated to `false`.\n    isVisible: function() {\n        return !!this._visible;\n    },\n\n    focus: function() {\n        var opacity = this.options.focusOpacity;\n        if (isFinite(opacity)) this.el.style.opacity = opacity;\n        this.parentView.focusTool(this);\n    },\n\n    blur: function() {\n        this.el.style.opacity = '';\n        this.parentView.blurTool(this);\n    },\n\n    update: function() {\n        // to be overridden\n    },\n\n    guard: function(evt) {\n        // Let the context-menu event bubble up to the relatedView\n        const { paper, relatedView } = this;\n        if (!paper || !relatedView) return true;\n        return paper.guard(evt, relatedView);\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9Ub29sVmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7O0FBRWpDLGlCQUFpQixnREFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvVG9vbFZpZXcubWpzPzE3NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbXZjIGZyb20gJy4uL212Yy9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3QgVG9vbFZpZXcgPSBtdmMuVmlldy5leHRlbmQoe1xuICAgIG5hbWU6IG51bGwsXG4gICAgdGFnTmFtZTogJ2cnLFxuICAgIGNsYXNzTmFtZTogJ3Rvb2wnLFxuICAgIHN2Z0VsZW1lbnQ6IHRydWUsXG4gICAgX3Zpc2libGU6IHRydWUsXG4gICAgX3Zpc2libGVFeHBsaWNpdDogdHJ1ZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKG5hbWUpIHRoaXMudmVsLmF0dHIoJ2RhdGEtdG9vbC1uYW1lJywgbmFtZSk7XG4gICAgfSxcblxuICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24odmlldywgdG9vbHNWaWV3KSB7XG4gICAgICAgIHRoaXMucmVsYXRlZFZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBhcGVyID0gdmlldy5wYXBlcjtcbiAgICAgICAgdGhpcy5wYXJlbnRWaWV3ID0gdG9vbHNWaWV3O1xuICAgICAgICB0aGlzLnNpbXVsYXRlUmVsYXRlZFZpZXcodGhpcy5lbCk7XG4gICAgICAgIC8vIERlbGVnYXRlIGV2ZW50cyBpbiBjYXNlIHRoZSBUb29sVmlldyB3YXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gYW5kIHJldXNlZC5cbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2ltdWxhdGVSZWxhdGVkVmlldzogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgaWYgKGVsKSBlbC5zZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJywgdGhpcy5yZWxhdGVkVmlldy5tb2RlbC5pZCk7XG4gICAgfSxcblxuICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH0sXG5cbiAgICAvLyBFdmFsdWF0ZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdG9vbCBhbmQgdXBkYXRlIHRoZSBgZGlzcGxheWAgQ1NTIHByb3BlcnR5XG4gICAgdXBkYXRlVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IHRoaXMuY29tcHV0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gaXNWaXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8vIEV2YWx1YXRlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB0b29sLiBUaGUgbWV0aG9kIHJldHVybnMgYHRydWVgIGlmIHRoZSB0b29sXG4gICAgLy8gc2hvdWxkIGJlIHZpc2libGUgaW4gdGhlIERPTS5cbiAgICBjb21wdXRlVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhwbGljaXRseVZpc2libGUoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB7IHZpc2liaWxpdHkgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmlsaXR5ICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICEhdmlzaWJpbGl0eS5jYWxsKHRoaXMsIHRoaXMucmVsYXRlZFZpZXcsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92aXNpYmxlRXhwbGljaXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSxcblxuICAgIC8vIFRoZSBtZXRob2QgcmV0dXJucyBgZmFsc2VgIGlmIHRoZSBgaGlkZSgpYCBtZXRob2Qgd2FzIGNhbGxlZCBvbiB0aGUgdG9vbC5cbiAgICBpc0V4cGxpY2l0bHlWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdmlzaWJsZUV4cGxpY2l0O1xuICAgIH0sXG5cbiAgICAvLyBUaGUgbWV0aG9kIHJldHVybnMgYGZhbHNlYCBpZiB0aGUgdG9vbCBpcyBub3QgdmlzaWJsZSAoaXQgaGFzIGBkaXNwbGF5OiBub25lYCkuXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHRoZSBgaGlkZSgpYCBtZXRob2Qgd2FzIGNhbGxlZCBvciB0aGUgdG9vbCBpcyBub3QgdmlzaWJsZVxuICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGB2aXNpYmlsaXR5YCBvcHRpb24gd2FzIGV2YWx1YXRlZCB0byBgZmFsc2VgLlxuICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3Zpc2libGU7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLm9wdGlvbnMuZm9jdXNPcGFjaXR5O1xuICAgICAgICBpZiAoaXNGaW5pdGUob3BhY2l0eSkpIHRoaXMuZWwuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgIHRoaXMucGFyZW50Vmlldy5mb2N1c1Rvb2wodGhpcyk7XG4gICAgfSxcblxuICAgIGJsdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgICAgdGhpcy5wYXJlbnRWaWV3LmJsdXJUb29sKHRoaXMpO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyB0byBiZSBvdmVycmlkZGVuXG4gICAgfSxcblxuICAgIGd1YXJkOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgLy8gTGV0IHRoZSBjb250ZXh0LW1lbnUgZXZlbnQgYnViYmxlIHVwIHRvIHRoZSByZWxhdGVkVmlld1xuICAgICAgICBjb25zdCB7IHBhcGVyLCByZWxhdGVkVmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFwYXBlciB8fCAhcmVsYXRlZFZpZXcpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gcGFwZXIuZ3VhcmQoZXZ0LCByZWxhdGVkVmlldyk7XG4gICAgfVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/ToolsView.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ToolsView.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolsView: () => (/* binding */ ToolsView)\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n\n\n\n\n\n\nconst ToolsView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: 'g',\n    className: 'tools',\n    svgElement: true,\n    tools: null,\n    isRendered: false,\n    options: {\n        tools: null,\n        relatedView: null,\n        name: null,\n        // layer?: LayersNames.TOOLS\n        // z?: number\n    },\n\n    configure: function(options) {\n        options = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign(this.options, options);\n        var tools = options.tools;\n        if (!Array.isArray(tools)) return this;\n        var relatedView = options.relatedView;\n        if (!(relatedView instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__.CellView)) return this;\n        var views = this.tools = [];\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (!(tool instanceof _ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__.ToolView)) continue;\n            tool.configure(relatedView, this);\n            this.vel.append(tool.el);\n            views.push(tool);\n        }\n        this.isRendered = false;\n        relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n        return this;\n    },\n\n    getName: function() {\n        return this.options.name;\n    },\n\n    update: function(opt) {\n\n        opt || (opt = {});\n        const tools = this.tools;\n        if (!tools) return this;\n        const n = tools.length;\n        const wasRendered = this.isRendered;\n        for (let i = 0; i < n; i++) {\n            const tool = tools[i];\n            tool.updateVisibility();\n            if (!tool.isVisible()) continue;\n            if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {\n                tool.update();\n            }\n        }\n        if (!this.isRendered && n > 0) {\n            // None of the tools is visible\n            // Note: ToolsView with no tools are always mounted\n            return this;\n        }\n        if (!this.isMounted()) {\n            this.mount();\n        }\n        if (!wasRendered) {\n            // Make sure tools are visible (if they were hidden and the tool removed)\n            this.blurTool();\n        }\n        return this;\n    },\n\n    ensureToolRendered(tools, i) {\n        if (!this.isRendered) {\n            // There is at least one visible tool\n            this.isRendered = Array(tools.length).fill(false);\n        }\n        if (!this.isRendered[i]) {\n            // First update executes render()\n            tools[i].render();\n            this.isRendered[i] = true;\n            return false;\n        }\n        return true;\n    },\n\n    focusTool: function(focusedTool) {\n\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (focusedTool === tool) {\n                tool.show();\n            } else {\n                tool.hide();\n            }\n        }\n        return this;\n    },\n\n    blurTool: function(blurredTool) {\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (tool !== blurredTool && !tool.isExplicitlyVisible()) {\n                tool.show();\n                // Check if the tool is conditionally visible too\n                if (tool.isVisible()) {\n                    this.ensureToolRendered(tools, i) && tool.update();\n                }\n            }\n        }\n        return this;\n    },\n\n    hide: function() {\n        return this.focusTool(null);\n    },\n\n    show: function() {\n        this.blurTool(null);\n        // If this the first time the tools are shown, make sure they are mounted\n        if (!this.isMounted()) {\n            this.mount();\n        }\n        return this;\n    },\n\n    onRemove: function() {\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            tools[i].remove();\n        }\n        this.tools = null;\n    },\n\n    mount: function() {\n        const { options, el } = this;\n        const { relatedView, layer = _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_4__.LayersNames.TOOLS, z } = options;\n        if (relatedView) {\n            if (layer) {\n                relatedView.paper.getLayerView(layer).insertSortedNode(el, z);\n            } else {\n                relatedView.el.appendChild(el);\n            }\n        }\n        return this;\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9Ub29sc1ZpZXcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QztBQUNFO0FBQ0E7QUFDSztBQUNMOztBQUVuQyxrQkFBa0IsZ0RBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrQkFBa0IsbURBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1EQUFRO0FBQzdDO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQSxrQ0FBa0MsbURBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUIsZ0JBQWdCLHFCQUFxQix3REFBVyxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvVG9vbHNWaWV3Lm1qcz8zNmYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG12YyBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ2VsbFZpZXcgfSBmcm9tICcuL0NlbGxWaWV3Lm1qcyc7XG5pbXBvcnQgeyBMYXllcnNOYW1lcyB9IGZyb20gJy4vUGFwZXJMYXllci5tanMnO1xuaW1wb3J0IHsgVG9vbFZpZXcgfSBmcm9tICcuL1Rvb2xWaWV3Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBUb29sc1ZpZXcgPSBtdmMuVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBjbGFzc05hbWU6ICd0b29scycsXG4gICAgc3ZnRWxlbWVudDogdHJ1ZSxcbiAgICB0b29sczogbnVsbCxcbiAgICBpc1JlbmRlcmVkOiBmYWxzZSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHRvb2xzOiBudWxsLFxuICAgICAgICByZWxhdGVkVmlldzogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgLy8gbGF5ZXI/OiBMYXllcnNOYW1lcy5UT09MU1xuICAgICAgICAvLyB6PzogbnVtYmVyXG4gICAgfSxcblxuICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gdXRpbC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHRvb2xzID0gb3B0aW9ucy50b29scztcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRvb2xzKSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IG9wdGlvbnMucmVsYXRlZFZpZXc7XG4gICAgICAgIGlmICghKHJlbGF0ZWRWaWV3IGluc3RhbmNlb2YgQ2VsbFZpZXcpKSByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIHZpZXdzID0gdGhpcy50b29scyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvb2xzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvb2wgPSB0b29sc1tpXTtcbiAgICAgICAgICAgIGlmICghKHRvb2wgaW5zdGFuY2VvZiBUb29sVmlldykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdG9vbC5jb25maWd1cmUocmVsYXRlZFZpZXcsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52ZWwuYXBwZW5kKHRvb2wuZWwpO1xuICAgICAgICAgICAgdmlld3MucHVzaCh0b29sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgcmVsYXRlZFZpZXcucmVxdWVzdFVwZGF0ZShyZWxhdGVkVmlldy5nZXRGbGFnKCdUT09MUycpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gdGhpcy50b29scztcbiAgICAgICAgaWYgKCF0b29scykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IG4gPSB0b29scy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHdhc1JlbmRlcmVkID0gdGhpcy5pc1JlbmRlcmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW2ldO1xuICAgICAgICAgICAgdG9vbC51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICAgICAgICBpZiAoIXRvb2wuaXNWaXNpYmxlKCkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5zdXJlVG9vbFJlbmRlcmVkKHRvb2xzLCBpKSAmJiBvcHQudG9vbCAhPT0gdG9vbC5jaWQpIHtcbiAgICAgICAgICAgICAgICB0b29sLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1JlbmRlcmVkICYmIG4gPiAwKSB7XG4gICAgICAgICAgICAvLyBOb25lIG9mIHRoZSB0b29scyBpcyB2aXNpYmxlXG4gICAgICAgICAgICAvLyBOb3RlOiBUb29sc1ZpZXcgd2l0aCBubyB0b29scyBhcmUgYWx3YXlzIG1vdW50ZWRcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5tb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2FzUmVuZGVyZWQpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0b29scyBhcmUgdmlzaWJsZSAoaWYgdGhleSB3ZXJlIGhpZGRlbiBhbmQgdGhlIHRvb2wgcmVtb3ZlZClcbiAgICAgICAgICAgIHRoaXMuYmx1clRvb2woKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZW5zdXJlVG9vbFJlbmRlcmVkKHRvb2xzLCBpKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlbmRlcmVkKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgdmlzaWJsZSB0b29sXG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBBcnJheSh0b29scy5sZW5ndGgpLmZpbGwoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1JlbmRlcmVkW2ldKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCB1cGRhdGUgZXhlY3V0ZXMgcmVuZGVyKClcbiAgICAgICAgICAgIHRvb2xzW2ldLnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZm9jdXNUb29sOiBmdW5jdGlvbihmb2N1c2VkVG9vbCkge1xuXG4gICAgICAgIHZhciB0b29scyA9IHRoaXMudG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMpIHJldHVybiB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvb2xzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvb2wgPSB0b29sc1tpXTtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkVG9vbCA9PT0gdG9vbCkge1xuICAgICAgICAgICAgICAgIHRvb2wuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b29sLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYmx1clRvb2w6IGZ1bmN0aW9uKGJsdXJyZWRUb29sKSB7XG4gICAgICAgIHZhciB0b29scyA9IHRoaXMudG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMpIHJldHVybiB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvb2xzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvb2wgPSB0b29sc1tpXTtcbiAgICAgICAgICAgIGlmICh0b29sICE9PSBibHVycmVkVG9vbCAmJiAhdG9vbC5pc0V4cGxpY2l0bHlWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0b29sLnNob3coKTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdG9vbCBpcyBjb25kaXRpb25hbGx5IHZpc2libGUgdG9vXG4gICAgICAgICAgICAgICAgaWYgKHRvb2wuaXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVUb29sUmVuZGVyZWQodG9vbHMsIGkpICYmIHRvb2wudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNUb29sKG51bGwpO1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5ibHVyVG9vbChudWxsKTtcbiAgICAgICAgLy8gSWYgdGhpcyB0aGUgZmlyc3QgdGltZSB0aGUgdG9vbHMgYXJlIHNob3duLCBtYWtlIHN1cmUgdGhleSBhcmUgbW91bnRlZFxuICAgICAgICBpZiAoIXRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMubW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG9vbHMgPSB0aGlzLnRvb2xzO1xuICAgICAgICBpZiAoIXRvb2xzKSByZXR1cm4gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b29scy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRvb2xzW2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9vbHMgPSBudWxsO1xuICAgIH0sXG5cbiAgICBtb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXcsIGxheWVyID0gTGF5ZXJzTmFtZXMuVE9PTFMsIHogfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChyZWxhdGVkVmlldykge1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZFZpZXcucGFwZXIuZ2V0TGF5ZXJWaWV3KGxheWVyKS5pbnNlcnRTb3J0ZWROb2RlKGVsLCB6KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZFZpZXcuZWwuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/ToolsView.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/connection.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/connection.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nconst connectionAttributesNS = {\n\n    'connection': {\n        qualify: isLinkView,\n        unset: 'd',\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const segmentSubdivisions = this.getConnectionSubdivisions();\n                const sourceParts = path.divideAtLength(offset, { segmentSubdivisions });\n                const targetParts = path.divideAtLength(-offset, { segmentSubdivisions });\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    'at-connection-length-keep-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    'at-connection-length-ignore-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    'at-connection-ratio-keep-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    'at-connection-ratio-ignore-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n\n};\n\nconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\nconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (connectionAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2Nvbm5lY3Rpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDOztBQUUxQztBQUNBLHlCQUF5QiwrQ0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHFCQUFxQjtBQUN2RixtRUFBbUUscUJBQXFCO0FBQ3hGO0FBQ0EsMkJBQTJCLDRCQUE0QixFQUFFLDJCQUEyQjtBQUNwRjtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxzQkFBc0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2Nvbm5lY3Rpb24ubWpzPzk5MmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9nL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIGF0Q29ubmVjdGlvbldyYXBwZXIobWV0aG9kLCBvcHQpIHtcbiAgICB2YXIgemVyb1ZlY3RvciA9IG5ldyBQb2ludCgxLCAwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHAsIGFuZ2xlO1xuICAgICAgICB2YXIgdGFuZ2VudCA9IHRoaXNbbWV0aG9kXSh2YWx1ZSk7XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBhbmdsZSA9IChvcHQucm90YXRlKSA/IHRhbmdlbnQudmVjdG9yKCkudmVjdG9yQW5nbGUoemVyb1ZlY3RvcikgOiAwO1xuICAgICAgICAgICAgcCA9IHRhbmdlbnQuc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gdGhpcy5wYXRoLnN0YXJ0O1xuICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmdsZSA9PT0gMCkgcmV0dXJuIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyBwLnggKyAnLCcgKyBwLnkgKyAnKScgfTtcbiAgICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyBwLnggKyAnLCcgKyBwLnkgKyAnKSByb3RhdGUoJyArIGFuZ2xlICsgJyknIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNMaW5rVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbC5pc0xpbmsoKTtcbn1cblxuY29uc3QgY29ubmVjdGlvbkF0dHJpYnV0ZXNOUyA9IHtcblxuICAgICdjb25uZWN0aW9uJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc0xpbmtWaWV3LFxuICAgICAgICB1bnNldDogJ2QnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHsgc3R1YnMgPSAwIH0pIHtcbiAgICAgICAgICAgIGxldCBkO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKHN0dWJzKSAmJiBzdHVicyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0dWJzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAodGhpcy5nZXRDb25uZWN0aW9uTGVuZ3RoKCkgKyBzdHVicykgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHN0dWJzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudFN1YmRpdmlzaW9ucyA9IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBhcnRzID0gcGF0aC5kaXZpZGVBdExlbmd0aChvZmZzZXQsIHsgc2VnbWVudFN1YmRpdmlzaW9ucyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXJ0cyA9IHBhdGguZGl2aWRlQXRMZW5ndGgoLW9mZnNldCwgeyBzZWdtZW50U3ViZGl2aXNpb25zIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VQYXJ0cyAmJiB0YXJnZXRQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICBkID0gYCR7c291cmNlUGFydHNbMF0uc2VyaWFsaXplKCl9ICR7dGFyZ2V0UGFydHNbMV0uc2VyaWFsaXplKCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IGQ6IGQgfHwgdGhpcy5nZXRTZXJpYWxpemVkQ29ubmVjdGlvbigpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2F0LWNvbm5lY3Rpb24tbGVuZ3RoLWtlZXAtZ3JhZGllbnQnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHVuc2V0OiAndHJhbnNmb3JtJyxcbiAgICAgICAgc2V0OiBhdENvbm5lY3Rpb25XcmFwcGVyKCdnZXRUYW5nZW50QXRMZW5ndGgnLCB7IHJvdGF0ZTogdHJ1ZSB9KVxuICAgIH0sXG5cbiAgICAnYXQtY29ubmVjdGlvbi1sZW5ndGgtaWdub3JlLWdyYWRpZW50Jzoge1xuICAgICAgICBxdWFsaWZ5OiBpc0xpbmtWaWV3LFxuICAgICAgICB1bnNldDogJ3RyYW5zZm9ybScsXG4gICAgICAgIHNldDogYXRDb25uZWN0aW9uV3JhcHBlcignZ2V0VGFuZ2VudEF0TGVuZ3RoJywgeyByb3RhdGU6IGZhbHNlIH0pXG4gICAgfSxcblxuICAgICdhdC1jb25uZWN0aW9uLXJhdGlvLWtlZXAtZ3JhZGllbnQnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHVuc2V0OiAndHJhbnNmb3JtJyxcbiAgICAgICAgc2V0OiBhdENvbm5lY3Rpb25XcmFwcGVyKCdnZXRUYW5nZW50QXRSYXRpbycsIHsgcm90YXRlOiB0cnVlIH0pXG4gICAgfSxcblxuICAgICdhdC1jb25uZWN0aW9uLXJhdGlvLWlnbm9yZS1ncmFkaWVudCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNMaW5rVmlldyxcbiAgICAgICAgdW5zZXQ6ICd0cmFuc2Zvcm0nLFxuICAgICAgICBzZXQ6IGF0Q29ubmVjdGlvbldyYXBwZXIoJ2dldFRhbmdlbnRBdFJhdGlvJywgeyByb3RhdGU6IGZhbHNlIH0pXG4gICAgfVxuXG59O1xuXG5jb25uZWN0aW9uQXR0cmlidXRlc05TWydhdC1jb25uZWN0aW9uLWxlbmd0aCddID0gY29ubmVjdGlvbkF0dHJpYnV0ZXNOU1snYXQtY29ubmVjdGlvbi1sZW5ndGgta2VlcC1ncmFkaWVudCddO1xuY29ubmVjdGlvbkF0dHJpYnV0ZXNOU1snYXQtY29ubmVjdGlvbi1yYXRpbyddID0gY29ubmVjdGlvbkF0dHJpYnV0ZXNOU1snYXQtY29ubmVjdGlvbi1yYXRpby1rZWVwLWdyYWRpZW50J107XG5cbmV4cG9ydCBkZWZhdWx0IGNvbm5lY3Rpb25BdHRyaWJ1dGVzTlM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/connection.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/defs.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/defs.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregarded here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === 'string') {\n        marker['stroke'] = stroke;\n        marker['fill'] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context['stroke-opacity'];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker['stroke-opacity'] = strokeOpacity;\n        marker['fill-opacity'] = strokeOpacity;\n    }\n    return marker;\n}\n\nfunction setPaintURL(def) {\n    const { paper } = this;\n    const url = (def.type === 'pattern')\n        ? paper.definePattern(def)\n        : paper.defineGradient(def);\n    return `url(#${url})`;\n}\n\nconst defsAttributesNS = {\n\n    'source-marker': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        unset: 'marker-start',\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(contextMarker(attrs), marker);\n            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'target-marker': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        unset: 'marker-end',\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'vertex-marker': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        unset: 'marker-mid',\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(contextMarker(attrs), marker);\n            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'fill': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: setPaintURL\n    },\n\n    'stroke': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: setPaintURL\n    },\n\n    'filter': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: function(filter) {\n            return 'url(#' + this.paper.defineFilter(filter) + ')';\n        }\n    },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defsAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2RlZnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQU07QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQix5REFBYTtBQUM5QjtBQUNBO0FBQ0EscUJBQXFCLHNEQUFNLHlCQUF5Qiw0QkFBNEI7QUFDaEYscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQix5REFBYTtBQUM5QjtBQUNBO0FBQ0EscUJBQXFCLHNEQUFNO0FBQzNCLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQkFBaUIseURBQWE7QUFDOUI7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQix5REFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUVBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvYXR0cmlidXRlcy9kZWZzLm1qcz9hNDhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2lnbiwgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuXG5mdW5jdGlvbiBjb250ZXh0TWFya2VyKGNvbnRleHQpIHtcbiAgICB2YXIgbWFya2VyID0ge307XG4gICAgLy8gU3Ryb2tlXG4gICAgLy8gVGhlIGNvbnRleHQgJ2ZpbGwnIGlzIGRpc3JlZ2FyZGVkIGhlcmUuIFRoZSB1c3VhbCBjYXNlIGlzIHRvIHVzZSB0aGUgbWFya2VyIHdpdGggYSBjb25uZWN0aW9uXG4gICAgLy8gKGZvciB3aGljaCAnZmlsbCcgYXR0cmlidXRlIGlzIHNldCB0byAnbm9uZScpLlxuICAgIHZhciBzdHJva2UgPSBjb250ZXh0LnN0cm9rZTtcbiAgICBpZiAodHlwZW9mIHN0cm9rZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya2VyWydzdHJva2UnXSA9IHN0cm9rZTtcbiAgICAgICAgbWFya2VyWydmaWxsJ10gPSBzdHJva2U7XG4gICAgfVxuICAgIC8vIE9wYWNpdHlcbiAgICAvLyBBZ2FpbiB0aGUgY29udGV4dCAnZmlsbC1vcGFjaXR5JyBpcyBpZ25vcmVkLlxuICAgIHZhciBzdHJva2VPcGFjaXR5ID0gY29udGV4dFsnc3Ryb2tlLW9wYWNpdHknXTtcbiAgICBpZiAoc3Ryb2tlT3BhY2l0eSA9PT0gdW5kZWZpbmVkKSBzdHJva2VPcGFjaXR5ID0gY29udGV4dC5vcGFjaXR5O1xuICAgIGlmIChzdHJva2VPcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFya2VyWydzdHJva2Utb3BhY2l0eSddID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgbWFya2VyWydmaWxsLW9wYWNpdHknXSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXI7XG59XG5cbmZ1bmN0aW9uIHNldFBhaW50VVJMKGRlZikge1xuICAgIGNvbnN0IHsgcGFwZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgdXJsID0gKGRlZi50eXBlID09PSAncGF0dGVybicpXG4gICAgICAgID8gcGFwZXIuZGVmaW5lUGF0dGVybihkZWYpXG4gICAgICAgIDogcGFwZXIuZGVmaW5lR3JhZGllbnQoZGVmKTtcbiAgICByZXR1cm4gYHVybCgjJHt1cmx9KWA7XG59XG5cbmNvbnN0IGRlZnNBdHRyaWJ1dGVzTlMgPSB7XG5cbiAgICAnc291cmNlLW1hcmtlcic6IHtcbiAgICAgICAgcXVhbGlmeTogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgdW5zZXQ6ICdtYXJrZXItc3RhcnQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG1hcmtlciwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFzc2lnbihjb250ZXh0TWFya2VyKGF0dHJzKSwgbWFya2VyKTtcbiAgICAgICAgICAgIHJldHVybiB7ICdtYXJrZXItc3RhcnQnOiAndXJsKCMnICsgdGhpcy5wYXBlci5kZWZpbmVNYXJrZXIobWFya2VyKSArICcpJyB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICd0YXJnZXQtbWFya2VyJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICB1bnNldDogJ21hcmtlci1lbmQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG1hcmtlciwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFzc2lnbihjb250ZXh0TWFya2VyKGF0dHJzKSwgeyAndHJhbnNmb3JtJzogJ3JvdGF0ZSgxODApJyB9LCBtYXJrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgJ21hcmtlci1lbmQnOiAndXJsKCMnICsgdGhpcy5wYXBlci5kZWZpbmVNYXJrZXIobWFya2VyKSArICcpJyB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICd2ZXJ0ZXgtbWFya2VyJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICB1bnNldDogJ21hcmtlci1taWQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG1hcmtlciwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFzc2lnbihjb250ZXh0TWFya2VyKGF0dHJzKSwgbWFya2VyKTtcbiAgICAgICAgICAgIHJldHVybiB7ICdtYXJrZXItbWlkJzogJ3VybCgjJyArIHRoaXMucGFwZXIuZGVmaW5lTWFya2VyKG1hcmtlcikgKyAnKScgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnZmlsbCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgc2V0OiBzZXRQYWludFVSTFxuICAgIH0sXG5cbiAgICAnc3Ryb2tlJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IHNldFBhaW50VVJMXG4gICAgfSxcblxuICAgICdmaWx0ZXInOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHNldDogZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMucGFwZXIuZGVmaW5lRmlsdGVyKGZpbHRlcikgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmc0F0dHJpYnV0ZXNOUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/defs.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/eval.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/eval.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalAttribute: () => (/* binding */ evalAttribute),\n/* harmony export */   evalAttributes: () => (/* binding */ evalAttributes)\n/* harmony export */ });\n/* harmony import */ var _util_calc_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/calc.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/calc.mjs\");\n\n\nconst calcAttributesList = [\n    'transform',\n    'x',\n    'y',\n    'cx',\n    'cy',\n    'dx',\n    'dy',\n    'x1',\n    'y1',\n    'x2',\n    'y2',\n    'points',\n    'd',\n    'r',\n    'rx',\n    'ry',\n    'width',\n    'height',\n    'stroke-width',\n    'font-size',\n];\n\nconst positiveValueList = [\n    'r',\n    'rx',\n    'ry',\n    'width',\n    'height',\n    'stroke-width',\n    'font-size',\n];\n\nconst calcAttributes = calcAttributesList.reduce((acc, attrName) => {\n    acc[attrName] = true;\n    return acc;\n}, {});\n\nconst positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {\n    acc[attrName] = true;\n    return acc;\n}, {});\n\nfunction evalAttributes(attrs, refBBox) {\n    const evalAttrs = {};\n    for (let attrName in attrs) {\n        if (!attrs.hasOwnProperty(attrName)) continue;\n        evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);\n    }\n    return evalAttrs;\n}\n\nfunction evalAttribute(attrName, attrValue, refBBox) {\n    if (attrName in calcAttributes && (0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_0__.isCalcExpression)(attrValue)) {\n        let evalAttrValue = (0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_0__.evalCalcExpression)(attrValue, refBBox);\n        if (attrName in positiveValueAttributes) {\n            evalAttrValue = Math.max(0, evalAttrValue);\n        }\n        return evalAttrValue;\n    }\n    return attrValue;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2V2YWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUU7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHNDQUFzQyxnRUFBZ0I7QUFDdEQsNEJBQTRCLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2V2YWwubWpzPzMxODQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNDYWxjRXhwcmVzc2lvbiwgZXZhbENhbGNFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jYWxjLm1qcyc7XG5cbmNvbnN0IGNhbGNBdHRyaWJ1dGVzTGlzdCA9IFtcbiAgICAndHJhbnNmb3JtJyxcbiAgICAneCcsXG4gICAgJ3knLFxuICAgICdjeCcsXG4gICAgJ2N5JyxcbiAgICAnZHgnLFxuICAgICdkeScsXG4gICAgJ3gxJyxcbiAgICAneTEnLFxuICAgICd4MicsXG4gICAgJ3kyJyxcbiAgICAncG9pbnRzJyxcbiAgICAnZCcsXG4gICAgJ3InLFxuICAgICdyeCcsXG4gICAgJ3J5JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICdzdHJva2Utd2lkdGgnLFxuICAgICdmb250LXNpemUnLFxuXTtcblxuY29uc3QgcG9zaXRpdmVWYWx1ZUxpc3QgPSBbXG4gICAgJ3InLFxuICAgICdyeCcsXG4gICAgJ3J5JyxcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICdzdHJva2Utd2lkdGgnLFxuICAgICdmb250LXNpemUnLFxuXTtcblxuY29uc3QgY2FsY0F0dHJpYnV0ZXMgPSBjYWxjQXR0cmlidXRlc0xpc3QucmVkdWNlKChhY2MsIGF0dHJOYW1lKSA9PiB7XG4gICAgYWNjW2F0dHJOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcblxuY29uc3QgcG9zaXRpdmVWYWx1ZUF0dHJpYnV0ZXMgPSBwb3NpdGl2ZVZhbHVlTGlzdC5yZWR1Y2UoKGFjYywgYXR0ck5hbWUpID0+IHtcbiAgICBhY2NbYXR0ck5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuXG5leHBvcnQgZnVuY3Rpb24gZXZhbEF0dHJpYnV0ZXMoYXR0cnMsIHJlZkJCb3gpIHtcbiAgICBjb25zdCBldmFsQXR0cnMgPSB7fTtcbiAgICBmb3IgKGxldCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSkgY29udGludWU7XG4gICAgICAgIGV2YWxBdHRyc1thdHRyTmFtZV0gPSBldmFsQXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyc1thdHRyTmFtZV0sIHJlZkJCb3gpO1xuICAgIH1cbiAgICByZXR1cm4gZXZhbEF0dHJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlLCByZWZCQm94KSB7XG4gICAgaWYgKGF0dHJOYW1lIGluIGNhbGNBdHRyaWJ1dGVzICYmIGlzQ2FsY0V4cHJlc3Npb24oYXR0clZhbHVlKSkge1xuICAgICAgICBsZXQgZXZhbEF0dHJWYWx1ZSA9IGV2YWxDYWxjRXhwcmVzc2lvbihhdHRyVmFsdWUsIHJlZkJCb3gpO1xuICAgICAgICBpZiAoYXR0ck5hbWUgaW4gcG9zaXRpdmVWYWx1ZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGV2YWxBdHRyVmFsdWUgPSBNYXRoLm1heCgwLCBldmFsQXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZhbEF0dHJWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJWYWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/eval.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attributes: () => (/* binding */ attributes)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _props_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/props.mjs\");\n/* harmony import */ var _legacy_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./legacy.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/legacy.mjs\");\n/* harmony import */ var _text_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/text.mjs\");\n/* harmony import */ var _connection_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./connection.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/connection.mjs\");\n/* harmony import */ var _shape_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shape.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/shape.mjs\");\n/* harmony import */ var _defs_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./defs.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/defs.mjs\");\n/* harmony import */ var _offset_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./offset.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/offset.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction setIfChangedWrapper(attribute) {\n    return function setIfChanged(value, _, node) {\n        const vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n        if (vel.attr(attribute) === value) return;\n        vel.attr(attribute, value);\n    };\n}\n\nconst attributesNS = {\n\n    'ref': {\n        // We do not set `ref` attribute directly on an element.\n        // The attribute itself does not qualify for relative positioning.\n    },\n\n    'href': {\n        set: setIfChangedWrapper('href')\n    },\n\n    'xlink:href': {\n        set: setIfChangedWrapper('xlink:href')\n    },\n\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    'port': {\n        set: function(port) {\n            return (port === null || port.id === undefined) ? port : port.id;\n        }\n    },\n\n    // `style` attribute is special in the sense that it sets the CSS style of the sub-element.\n    'style': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject,\n        set: function(styles, refBBox, node) {\n            (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).css(styles);\n        }\n    },\n\n    'html': {\n        unset: function(node) {\n            (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).empty();\n        },\n        set: function(html, refBBox, node) {\n            (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).html(html + '');\n        }\n    },\n\n    // Properties setter (set various properties on the node)\n    props: _props_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n};\n\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _legacy_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _text_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _connection_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _shape_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _defs_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _offset_mjs__WEBPACK_IMPORTED_MODULE_9__[\"default\"]);\n\nconst attributes = attributesNS;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE0RDtBQUNwQjtBQUNOOztBQUVGO0FBQ2M7QUFDSjtBQUNZO0FBQ1Y7QUFDRjtBQUNJOztBQUU5QztBQUNBO0FBQ0Esb0JBQW9CLHdEQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGlCQUFpQix5REFBYTtBQUM5QjtBQUNBLFlBQVksOERBQUM7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLFlBQVksOERBQUM7QUFDYixTQUFTO0FBQ1Q7QUFDQSxZQUFZLDhEQUFDO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0EsU0FBUztBQUNUOztBQUVBLHNEQUFNLGVBQWUsbURBQWtCO0FBQ3ZDLHNEQUFNLGVBQWUsaURBQWdCO0FBQ3JDLHNEQUFNLGVBQWUsdURBQXNCO0FBQzNDLHNEQUFNLGVBQWUsa0RBQWlCO0FBQ3RDLHNEQUFNLGVBQWUsaURBQWdCO0FBQ3JDLHNEQUFNLGVBQWUsbURBQWtCOztBQUVoQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2luZGV4Lm1qcz84MGZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2lnbiwgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuaW1wb3J0ICQgZnJvbSAnLi4vLi4vbXZjL0RvbS9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vLi4vVi9pbmRleC5tanMnO1xuXG5pbXBvcnQgcHJvcHMgZnJvbSAnLi9wcm9wcy5tanMnO1xuaW1wb3J0IGxlZ2FjeUF0dHJpYnV0ZXNOUyBmcm9tICcuL2xlZ2FjeS5tanMnO1xuaW1wb3J0IHRleHRBdHRyaWJ1dGVzTlMgZnJvbSAnLi90ZXh0Lm1qcyc7XG5pbXBvcnQgY29ubmVjdGlvbkF0dHJpYnV0ZXNOUyBmcm9tICcuL2Nvbm5lY3Rpb24ubWpzJztcbmltcG9ydCBzaGFwZUF0dHJpYnV0ZXNOUyBmcm9tICcuL3NoYXBlLm1qcyc7XG5pbXBvcnQgZGVmc0F0dHJpYnV0ZXNOUyBmcm9tICcuL2RlZnMubWpzJztcbmltcG9ydCBvZmZzZXRBdHRyaWJ1dGVzTlMgZnJvbSAnLi9vZmZzZXQubWpzJztcblxuZnVuY3Rpb24gc2V0SWZDaGFuZ2VkV3JhcHBlcihhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0SWZDaGFuZ2VkKHZhbHVlLCBfLCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHZlbCA9IFYobm9kZSk7XG4gICAgICAgIGlmICh2ZWwuYXR0cihhdHRyaWJ1dGUpID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICB2ZWwuYXR0cihhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9O1xufVxuXG5jb25zdCBhdHRyaWJ1dGVzTlMgPSB7XG5cbiAgICAncmVmJzoge1xuICAgICAgICAvLyBXZSBkbyBub3Qgc2V0IGByZWZgIGF0dHJpYnV0ZSBkaXJlY3RseSBvbiBhbiBlbGVtZW50LlxuICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGl0c2VsZiBkb2VzIG5vdCBxdWFsaWZ5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmluZy5cbiAgICB9LFxuXG4gICAgJ2hyZWYnOiB7XG4gICAgICAgIHNldDogc2V0SWZDaGFuZ2VkV3JhcHBlcignaHJlZicpXG4gICAgfSxcblxuICAgICd4bGluazpocmVmJzoge1xuICAgICAgICBzZXQ6IHNldElmQ2hhbmdlZFdyYXBwZXIoJ3hsaW5rOmhyZWYnKVxuICAgIH0sXG5cbiAgICAvLyBgcG9ydGAgYXR0cmlidXRlIGNvbnRhaW5zIHRoZSBgaWRgIG9mIHRoZSBwb3J0IHRoYXQgdGhlIHVuZGVybHlpbmcgbWFnbmV0IHJlcHJlc2VudHMuXG4gICAgJ3BvcnQnOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24ocG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIChwb3J0ID09PSBudWxsIHx8IHBvcnQuaWQgPT09IHVuZGVmaW5lZCkgPyBwb3J0IDogcG9ydC5pZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGluIHRoZSBzZW5zZSB0aGF0IGl0IHNldHMgdGhlIENTUyBzdHlsZSBvZiB0aGUgc3ViLWVsZW1lbnQuXG4gICAgJ3N0eWxlJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0eWxlcywgcmVmQkJveCwgbm9kZSkge1xuICAgICAgICAgICAgJChub2RlKS5jc3Moc3R5bGVzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnaHRtbCc6IHtcbiAgICAgICAgdW5zZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICQobm9kZSkuZW1wdHkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihodG1sLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgICAgICAkKG5vZGUpLmh0bWwoaHRtbCArICcnKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBQcm9wZXJ0aWVzIHNldHRlciAoc2V0IHZhcmlvdXMgcHJvcGVydGllcyBvbiB0aGUgbm9kZSlcbiAgICBwcm9wcyxcbn07XG5cbmFzc2lnbihhdHRyaWJ1dGVzTlMsIGxlZ2FjeUF0dHJpYnV0ZXNOUyk7XG5hc3NpZ24oYXR0cmlidXRlc05TLCB0ZXh0QXR0cmlidXRlc05TKTtcbmFzc2lnbihhdHRyaWJ1dGVzTlMsIGNvbm5lY3Rpb25BdHRyaWJ1dGVzTlMpO1xuYXNzaWduKGF0dHJpYnV0ZXNOUywgc2hhcGVBdHRyaWJ1dGVzTlMpO1xuYXNzaWduKGF0dHJpYnV0ZXNOUywgZGVmc0F0dHJpYnV0ZXNOUyk7XG5hc3NpZ24oYXR0cmlidXRlc05TLCBvZmZzZXRBdHRyaWJ1dGVzTlMpO1xuXG5leHBvcnQgY29uc3QgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXNOUztcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/legacy.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/legacy.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n\n        var point = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point)();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n\n        return attrs;\n    };\n}\n\nconst legacyAttributesNS = {\n\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n    'ref-x': {\n        position: positionWrapper('x', 'width', 'origin')\n    },\n\n    'ref-y': {\n        position: positionWrapper('y', 'height', 'origin')\n    },\n\n    // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom\n    // coordinate of the reference element.\n\n    'ref-dx': {\n        position: positionWrapper('x', 'width', 'corner')\n    },\n\n    'ref-dy': {\n        position: positionWrapper('y', 'height', 'corner')\n    },\n\n    // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n    'ref-width': {\n        set: setWrapper('width', 'width')\n    },\n\n    'ref-height': {\n        set: setWrapper('height', 'height')\n    },\n\n    'ref-rx': {\n        set: setWrapper('rx', 'width')\n    },\n\n    'ref-ry': {\n        set: setWrapper('ry', 'height')\n    },\n\n    'ref-cx': {\n        set: setWrapper('cx', 'width')\n    },\n\n    'ref-cy': {\n        set: setWrapper('cy', 'height')\n    },\n\n    'ref-r-inscribed': {\n        set: (function(attrName) {\n            var widthFn = setWrapper(attrName, 'width');\n            var heightFn = setWrapper(attrName, 'height');\n            return function(value, refBBox) {\n                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        })('r')\n    },\n\n    'ref-r-circumscribed': {\n        set: function(value, refBBox) {\n            var isValuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n\n            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n\n            return { r: rValue };\n        }\n    },\n};\n\n// NOTE: refX & refY are SVG attributes that define the reference point of the marker.\n// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).\nlegacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];\nlegacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nlegacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];\nlegacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];\nlegacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];\nlegacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];\n\n// Aliases\nlegacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (legacyAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2xlZ2FjeS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ1M7O0FBRW5EO0FBQ0E7QUFDQSw4QkFBOEIsNERBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG1EQUFLO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsNERBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxvQ0FBb0MsNERBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvYXR0cmlidXRlcy9sZWdhY3kubWpzP2QxY2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc1BlcmNlbnRhZ2UgfSBmcm9tICcuLi8uLi91dGlsL3V0aWwubWpzJztcblxuZnVuY3Rpb24gcG9zaXRpb25XcmFwcGVyKGF4aXMsIGRpbWVuc2lvbiwgb3JpZ2luKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94KSB7XG4gICAgICAgIHZhciB2YWx1ZVBlcmNlbnRhZ2UgPSBpc1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAodmFsdWVQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVsdGE7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciByZWZPcmlnaW4gPSByZWZCQm94W29yaWdpbl0oKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVBlcmNlbnRhZ2UgfHwgdmFsdWUgPiAwICYmIHZhbHVlIDwgMSkge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcmVmT3JpZ2luW2F4aXNdICsgcmVmQkJveFtkaW1lbnNpb25dICogdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbHRhID0gcmVmT3JpZ2luW2F4aXNdICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQgPSBQb2ludCgpO1xuICAgICAgICBwb2ludFtheGlzXSA9IGRlbHRhIHx8IDA7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzZXRXcmFwcGVyKGF0dHJOYW1lLCBkaW1lbnNpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHJlZkJCb3gpIHtcbiAgICAgICAgdmFyIGlzVmFsdWVQZXJjZW50YWdlID0gaXNQZXJjZW50YWdlKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzVmFsdWVQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXR0cnMgPSB7fTtcbiAgICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGF0dHJWYWx1ZSA9IChpc1ZhbHVlUGVyY2VudGFnZSB8fCB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEpXG4gICAgICAgICAgICAgICAgPyB2YWx1ZSAqIHJlZkJCb3hbZGltZW5zaW9uXVxuICAgICAgICAgICAgICAgIDogTWF0aC5tYXgodmFsdWUgKyByZWZCQm94W2RpbWVuc2lvbl0sIDApO1xuICAgICAgICAgICAgYXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG59XG5cbmNvbnN0IGxlZ2FjeUF0dHJpYnV0ZXNOUyA9IHtcblxuICAgIC8vIGlmIGByZWZYYCBpcyBpbiBbMCwgMV0gdGhlbiBgcmVmWGAgaXMgYSBmcmFjdGlvbiBvZiBib3VuZGluZyBib3ggd2lkdGhcbiAgICAvLyBpZiBgcmVmWGAgaXMgPCAwIHRoZW4gYHJlZlhgJ3MgYWJzb2x1dGUgdmFsdWVzIGlzIHRoZSByaWdodCBjb29yZGluYXRlIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAvLyBvdGhlcndpc2UsIGByZWZYYCBpcyB0aGUgbGVmdCBjb29yZGluYXRlIG9mIHRoZSBib3VuZGluZyBib3hcbiAgICAncmVmLXgnOiB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbldyYXBwZXIoJ3gnLCAnd2lkdGgnLCAnb3JpZ2luJylcbiAgICB9LFxuXG4gICAgJ3JlZi15Jzoge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25XcmFwcGVyKCd5JywgJ2hlaWdodCcsICdvcmlnaW4nKVxuICAgIH0sXG5cbiAgICAvLyBgcmVmLWR4YCBhbmQgYHJlZi1keWAgZGVmaW5lIHRoZSBvZmZzZXQgb2YgdGhlIHN1Yi1lbGVtZW50IHJlbGF0aXZlIHRvIHRoZSByaWdodCBhbmQvb3IgYm90dG9tXG4gICAgLy8gY29vcmRpbmF0ZSBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG5cbiAgICAncmVmLWR4Jzoge1xuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25XcmFwcGVyKCd4JywgJ3dpZHRoJywgJ2Nvcm5lcicpXG4gICAgfSxcblxuICAgICdyZWYtZHknOiB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbldyYXBwZXIoJ3knLCAnaGVpZ2h0JywgJ2Nvcm5lcicpXG4gICAgfSxcblxuICAgIC8vICdyZWYtd2lkdGgnLydyZWYtaGVpZ2h0JyBkZWZpbmVzIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHN1Yi1lbGVtZW50IHJlbGF0aXZlbHkgdG9cbiAgICAvLyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgc2l6ZVxuICAgIC8vIHZhbCBpbiAwLi4xICAgICAgICAgcmVmLXdpZHRoID0gMC43NSBzZXRzIHRoZSB3aWR0aCB0byA3NSUgb2YgdGhlIHJlZi4gZWwuIHdpZHRoXG4gICAgLy8gdmFsIDwgMCB8fCB2YWwgPiAxICByZWYtaGVpZ2h0ID0gLTIwIHNldHMgdGhlIGhlaWdodCB0byB0aGUgcmVmLiBlbC4gaGVpZ2h0IHNob3J0ZXIgYnkgMjBcblxuICAgICdyZWYtd2lkdGgnOiB7XG4gICAgICAgIHNldDogc2V0V3JhcHBlcignd2lkdGgnLCAnd2lkdGgnKVxuICAgIH0sXG5cbiAgICAncmVmLWhlaWdodCc6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCdoZWlnaHQnLCAnaGVpZ2h0JylcbiAgICB9LFxuXG4gICAgJ3JlZi1yeCc6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCdyeCcsICd3aWR0aCcpXG4gICAgfSxcblxuICAgICdyZWYtcnknOiB7XG4gICAgICAgIHNldDogc2V0V3JhcHBlcigncnknLCAnaGVpZ2h0JylcbiAgICB9LFxuXG4gICAgJ3JlZi1jeCc6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCdjeCcsICd3aWR0aCcpXG4gICAgfSxcblxuICAgICdyZWYtY3knOiB7XG4gICAgICAgIHNldDogc2V0V3JhcHBlcignY3knLCAnaGVpZ2h0JylcbiAgICB9LFxuXG4gICAgJ3JlZi1yLWluc2NyaWJlZCc6IHtcbiAgICAgICAgc2V0OiAoZnVuY3Rpb24oYXR0ck5hbWUpIHtcbiAgICAgICAgICAgIHZhciB3aWR0aEZuID0gc2V0V3JhcHBlcihhdHRyTmFtZSwgJ3dpZHRoJyk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0Rm4gPSBzZXRXcmFwcGVyKGF0dHJOYW1lLCAnaGVpZ2h0Jyk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHJlZkJCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSAocmVmQkJveC5oZWlnaHQgPiByZWZCQm94LndpZHRoKSA/IHdpZHRoRm4gOiBoZWlnaHRGbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4odmFsdWUsIHJlZkJCb3gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoJ3InKVxuICAgIH0sXG5cbiAgICAncmVmLXItY2lyY3Vtc2NyaWJlZCc6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSwgcmVmQkJveCkge1xuICAgICAgICAgICAgdmFyIGlzVmFsdWVQZXJjZW50YWdlID0gaXNQZXJjZW50YWdlKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaWFnb25hbExlbmd0aCA9IE1hdGguc3FydCgocmVmQkJveC5oZWlnaHQgKiByZWZCQm94LmhlaWdodCkgKyAocmVmQkJveC53aWR0aCAqIHJlZkJCb3gud2lkdGgpKTtcblxuICAgICAgICAgICAgdmFyIHJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZVBlcmNlbnRhZ2UgfHwgdmFsdWUgPj0gMCAmJiB2YWx1ZSA8PSAxKSByVmFsdWUgPSB2YWx1ZSAqIGRpYWdvbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGVsc2UgclZhbHVlID0gTWF0aC5tYXgodmFsdWUgKyBkaWFnb25hbExlbmd0aCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHI6IHJWYWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbi8vIE5PVEU6IHJlZlggJiByZWZZIGFyZSBTVkcgYXR0cmlidXRlcyB0aGF0IGRlZmluZSB0aGUgcmVmZXJlbmNlIHBvaW50IG9mIHRoZSBtYXJrZXIuXG4vLyBUaGF0J3Mgd2h5IHdlIG5lZWQgdG8gZGVmaW5lIGJvdGggdmFyaWFudHM6IGByZWZYYCBhbmQgYHJlZi14YCAoYW5kIGByZWZZYCBhbmQgYHJlZi15YCkuXG5sZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZlgnXSA9IGxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLXgnXTtcbmxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmWSddID0gbGVnYWN5QXR0cmlidXRlc05TWydyZWYteSddO1xuXG4vLyBUaGlzIGFsbG93cyB0byBjb21iaW5lIGJvdGggYWJzb2x1dGUgYW5kIHJlbGF0aXZlIHBvc2l0aW9uaW5nXG4vLyByZWZYOiA1MCUsIHJlZlgyOiAyMFxubGVnYWN5QXR0cmlidXRlc05TWydyZWYteDInXSA9IGxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLXgnXTtcbmxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLXkyJ10gPSBsZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi15J107XG5sZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi13aWR0aDInXSA9IGxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLXdpZHRoJ107XG5sZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi1oZWlnaHQyJ10gPSBsZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi1oZWlnaHQnXTtcblxuLy8gQWxpYXNlc1xubGVnYWN5QXR0cmlidXRlc05TWydyZWYtciddID0gbGVnYWN5QXR0cmlidXRlc05TWydyZWYtci1pbnNjcmliZWQnXTtcblxuZXhwb3J0IGRlZmF1bHQgbGVnYWN5QXR0cmlidXRlc05TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/legacy.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/offset.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/offset.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n// Offset attributes require the cell view to be rendered before they can be applied\n// (they must be appended to the DOM).\n\n\n\n\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === 'middle') {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n\n        var point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\n\nconst offsetAttributesNS = {\n\n    // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n    'x-alignment': {\n        offset: offsetWrapper('x', 'width', 'right')\n    },\n\n    // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n    'y-alignment': {\n        offset: offsetWrapper('y', 'height', 'bottom')\n    },\n\n    'reset-offset': {\n        offset: function(val, nodeBBox) {\n            return (val)\n                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n                : { x: 0, y: 0 };\n        }\n    },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (offsetAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL29mZnNldC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUNBO0FBQ0E7O0FBRTBDO0FBQ1M7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVUsU0FBUyw0REFBWTtBQUMvQjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLHdCQUF3QiwrQ0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsaUVBQWUsa0JBQWtCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvYXR0cmlidXRlcy9vZmZzZXQubWpzP2RhMWIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBPZmZzZXQgYXR0cmlidXRlcyByZXF1aXJlIHRoZSBjZWxsIHZpZXcgdG8gYmUgcmVuZGVyZWQgYmVmb3JlIHRoZXkgY2FuIGJlIGFwcGxpZWRcbi8vICh0aGV5IG11c3QgYmUgYXBwZW5kZWQgdG8gdGhlIERPTSkuXG5cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNQZXJjZW50YWdlIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsLm1qcyc7XG5cbmZ1bmN0aW9uIG9mZnNldFdyYXBwZXIoYXhpcywgZGltZW5zaW9uLCBjb3JuZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG5vZGVCQm94KSB7XG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgZGVsdGEgPSBub2RlQkJveFtkaW1lbnNpb25dIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gY29ybmVyKSB7XG4gICAgICAgICAgICBkZWx0YSA9IG5vZGVCQm94W2RpbWVuc2lvbl07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBvciBub3QgdG8gZG8gYSBicmVha2luZyBjaGFuZ2U/XG4gICAgICAgICAgICBkZWx0YSA9ICh2YWx1ZSA+IC0xICYmIHZhbHVlIDwgMSkgPyAoLW5vZGVCQm94W2RpbWVuc2lvbl0gKiB2YWx1ZSkgOiAtdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQZXJjZW50YWdlKHZhbHVlKSkge1xuICAgICAgICAgICAgZGVsdGEgPSBub2RlQkJveFtkaW1lbnNpb25dICogcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgcG9pbnRbYXhpc10gPSAtKG5vZGVCQm94W2F4aXNdICsgZGVsdGEpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfTtcbn1cblxuY29uc3Qgb2Zmc2V0QXR0cmlidXRlc05TID0ge1xuXG4gICAgLy8gYHgtYWxpZ25tZW50YCB3aGVuIHNldCB0byBgbWlkZGxlYCBjYXVzZXMgY2VudGVyaW5nIG9mIHRoZSBzdWItZWxlbWVudCBhcm91bmQgaXRzIG5ldyB4IGNvb3JkaW5hdGUuXG4gICAgLy8gYHgtYWxpZ25tZW50YCB3aGVuIHNldCB0byBgcmlnaHRgIHVzZXMgdGhlIHggY29vcmRpbmF0ZSBhcyByZWZlcmVuY2VkIHRvIHRoZSByaWdodCBvZiB0aGUgYmJveC5cbiAgICAneC1hbGlnbm1lbnQnOiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0V3JhcHBlcigneCcsICd3aWR0aCcsICdyaWdodCcpXG4gICAgfSxcblxuICAgIC8vIGB5LWFsaWdubWVudGAgd2hlbiBzZXQgdG8gYG1pZGRsZWAgY2F1c2VzIGNlbnRlcmluZyBvZiB0aGUgc3ViLWVsZW1lbnQgYXJvdW5kIGl0cyBuZXcgeSBjb29yZGluYXRlLlxuICAgIC8vIGB5LWFsaWdubWVudGAgd2hlbiBzZXQgdG8gYGJvdHRvbWAgdXNlcyB0aGUgeSBjb29yZGluYXRlIGFzIHJlZmVyZW5jZWQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgYmJveC5cbiAgICAneS1hbGlnbm1lbnQnOiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0V3JhcHBlcigneScsICdoZWlnaHQnLCAnYm90dG9tJylcbiAgICB9LFxuXG4gICAgJ3Jlc2V0LW9mZnNldCc6IHtcbiAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbih2YWwsIG5vZGVCQm94KSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbClcbiAgICAgICAgICAgICAgICA/IHsgeDogLW5vZGVCQm94LngsIHk6IC1ub2RlQkJveC55IH1cbiAgICAgICAgICAgICAgICA6IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9mZnNldEF0dHJpYnV0ZXNOUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/offset.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/props.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/props.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\nconst validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];\n\nconst validProperties = validPropertiesList.reduce((acc, key) => {\n    acc[key] = true;\n    return acc;\n}, {});\n\nconst props = {\n    qualify: function(properties) {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(properties);\n    },\n    set: function(properties, _, node) {\n        Object.keys(properties).forEach(function(key) {\n            if (validProperties[key] && key in node) {\n                const value = properties[key];\n                if (node.tagName === 'SELECT' && Array.isArray(value)) {\n                    Array.from(node.options).forEach(function(option, index) {\n                        option.selected = value.includes(option.value);\n                    });\n                } else {\n                    node[key] = value;\n                }\n            }\n        });\n    }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (props);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL3Byb3BzLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQSxlQUFlLDZEQUFhO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsaUVBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvcHJvcHMubWpzP2RhMjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuXG5jb25zdCB2YWxpZFByb3BlcnRpZXNMaXN0ID0gWydjaGVja2VkJywgJ3NlbGVjdGVkJywgJ2Rpc2FibGVkJywgJ3JlYWRPbmx5JywgJ2NvbnRlbnRFZGl0YWJsZScsICd2YWx1ZScsICdpbmRldGVybWluYXRlJ107XG5cbmNvbnN0IHZhbGlkUHJvcGVydGllcyA9IHZhbGlkUHJvcGVydGllc0xpc3QucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuXG5jb25zdCBwcm9wcyA9IHtcbiAgICBxdWFsaWZ5OiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihwcm9wZXJ0aWVzLCBfLCBub2RlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAodmFsaWRQcm9wZXJ0aWVzW2tleV0gJiYga2V5IGluIG5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAnU0VMRUNUJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5mcm9tKG5vZGUub3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihvcHRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB2YWx1ZS5pbmNsdWRlcyhvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/props.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/shape.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/shape.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = 'joint-shape';\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var cache = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].data.get(node, cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].data.set(node, cacheName, cache);\n        }\n\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n\n        return shape;\n    };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].normalizePathData(value));\n    }\n\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\n\nconst shapeAttributesNS = {\n\n    'ref-d-reset-offset': {\n        unset: 'd',\n        set: dWrapper({ resetOffset: true })\n    },\n\n    'ref-d-keep-offset': {\n        unset: 'd',\n        set: dWrapper({ resetOffset: false })\n    },\n\n    'ref-points-reset-offset': {\n        unset: 'points',\n        set: pointsWrapper({ resetOffset: true })\n    },\n\n    'ref-points-keep-offset': {\n        unset: 'points',\n        set: pointsWrapper({ resetOffset: false })\n    },\n};\n\n// Aliases\nshapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];\nshapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shapeAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL3NoYXBlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRDtBQUNYO0FBQ047O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFDO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFDO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFJLENBQUMsb0RBQUM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRCxLQUFLOztBQUVMO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsaUJBQWlCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvYXR0cmlidXRlcy9zaGFwZS5tanM/Yjk2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRoLCBQb2x5bGluZSB9IGZyb20gJy4uLy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAkIGZyb20gJy4uLy4uL212Yy9Eb20vaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uLy4uL1YvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gc2hhcGVXcmFwcGVyKHNoYXBlQ29uc3RydWN0b3IsIG9wdCkge1xuICAgIHZhciBjYWNoZU5hbWUgPSAnam9pbnQtc2hhcGUnO1xuICAgIHZhciByZXNldE9mZnNldCA9IG9wdCAmJiBvcHQucmVzZXRPZmZzZXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgIHZhciBjYWNoZSA9ICQuZGF0YS5nZXQobm9kZSwgY2FjaGVOYW1lKTtcbiAgICAgICAgaWYgKCFjYWNoZSB8fCBjYWNoZS52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVjYWxjdWxhdGUgaWYgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBjYWNoZWRTaGFwZSA9IHNoYXBlQ29uc3RydWN0b3IodmFsdWUpO1xuICAgICAgICAgICAgY2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHNoYXBlOiBjYWNoZWRTaGFwZSxcbiAgICAgICAgICAgICAgICBzaGFwZUJCb3g6IGNhY2hlZFNoYXBlLmJib3goKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQuZGF0YS5zZXQobm9kZSwgY2FjaGVOYW1lLCBjYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGUgPSBjYWNoZS5zaGFwZS5jbG9uZSgpO1xuICAgICAgICB2YXIgc2hhcGVCQm94ID0gY2FjaGUuc2hhcGVCQm94LmNsb25lKCk7XG4gICAgICAgIHZhciBzaGFwZU9yaWdpbiA9IHNoYXBlQkJveC5vcmlnaW4oKTtcbiAgICAgICAgdmFyIHJlZk9yaWdpbiA9IHJlZkJCb3gub3JpZ2luKCk7XG5cbiAgICAgICAgc2hhcGVCQm94LnggPSByZWZPcmlnaW4ueDtcbiAgICAgICAgc2hhcGVCQm94LnkgPSByZWZPcmlnaW4ueTtcblxuICAgICAgICB2YXIgZml0U2NhbGUgPSByZWZCQm94Lm1heFJlY3RTY2FsZVRvRml0KHNoYXBlQkJveCwgcmVmT3JpZ2luKTtcbiAgICAgICAgLy8gYG1heFJlY3RTY2FsZVRvRml0YCBjYW4gZ2l2ZSBJbmZpbml0eSBpZiB3aWR0aCBvciBoZWlnaHQgaXMgMFxuICAgICAgICB2YXIgc3ggPSAoc2hhcGVCQm94LndpZHRoID09PSAwIHx8IHJlZkJCb3gud2lkdGggPT09IDApID8gMSA6IGZpdFNjYWxlLnN4O1xuICAgICAgICB2YXIgc3kgPSAoc2hhcGVCQm94LmhlaWdodCA9PT0gMCB8fCByZWZCQm94LmhlaWdodCA9PT0gMCkgPyAxIDogZml0U2NhbGUuc3k7XG5cbiAgICAgICAgc2hhcGUuc2NhbGUoc3gsIHN5LCBzaGFwZU9yaWdpbik7XG4gICAgICAgIGlmIChyZXNldE9mZnNldCkge1xuICAgICAgICAgICAgc2hhcGUudHJhbnNsYXRlKC1zaGFwZU9yaWdpbi54LCAtc2hhcGVPcmlnaW4ueSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgfTtcbn1cblxuLy8gYGRgIGF0dHJpYnV0ZSBmb3IgU1ZHUGF0aHNcbmZ1bmN0aW9uIGRXcmFwcGVyKG9wdCkge1xuICAgIGZ1bmN0aW9uIHBhdGhDb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgoVi5ub3JtYWxpemVQYXRoRGF0YSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IHNoYXBlV3JhcHBlcihwYXRoQ29uc3RydWN0b3IsIG9wdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgIHZhciBwYXRoID0gc2hhcGUodmFsdWUsIHJlZkJCb3gsIG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZDogcGF0aC5zZXJpYWxpemUoKVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbi8vIGBwb2ludHNgIGF0dHJpYnV0ZSBmb3IgU1ZHUG9seWxpbmVzIGFuZCBTVkdQb2x5Z29uc1xuZnVuY3Rpb24gcG9pbnRzV3JhcHBlcihvcHQpIHtcbiAgICB2YXIgc2hhcGUgPSBzaGFwZVdyYXBwZXIoUG9seWxpbmUsIG9wdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgIHZhciBwb2x5bGluZSA9IHNoYXBlKHZhbHVlLCByZWZCQm94LCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50czogcG9seWxpbmUuc2VyaWFsaXplKClcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5jb25zdCBzaGFwZUF0dHJpYnV0ZXNOUyA9IHtcblxuICAgICdyZWYtZC1yZXNldC1vZmZzZXQnOiB7XG4gICAgICAgIHVuc2V0OiAnZCcsXG4gICAgICAgIHNldDogZFdyYXBwZXIoeyByZXNldE9mZnNldDogdHJ1ZSB9KVxuICAgIH0sXG5cbiAgICAncmVmLWQta2VlcC1vZmZzZXQnOiB7XG4gICAgICAgIHVuc2V0OiAnZCcsXG4gICAgICAgIHNldDogZFdyYXBwZXIoeyByZXNldE9mZnNldDogZmFsc2UgfSlcbiAgICB9LFxuXG4gICAgJ3JlZi1wb2ludHMtcmVzZXQtb2Zmc2V0Jzoge1xuICAgICAgICB1bnNldDogJ3BvaW50cycsXG4gICAgICAgIHNldDogcG9pbnRzV3JhcHBlcih7IHJlc2V0T2Zmc2V0OiB0cnVlIH0pXG4gICAgfSxcblxuICAgICdyZWYtcG9pbnRzLWtlZXAtb2Zmc2V0Jzoge1xuICAgICAgICB1bnNldDogJ3BvaW50cycsXG4gICAgICAgIHNldDogcG9pbnRzV3JhcHBlcih7IHJlc2V0T2Zmc2V0OiBmYWxzZSB9KVxuICAgIH0sXG59O1xuXG4vLyBBbGlhc2VzXG5zaGFwZUF0dHJpYnV0ZXNOU1sncmVmLWQnXSA9IHNoYXBlQXR0cmlidXRlc05TWydyZWYtZC1yZXNldC1vZmZzZXQnXTtcbnNoYXBlQXR0cmlidXRlc05TWydyZWYtcG9pbnRzJ10gPSBzaGFwZUF0dHJpYnV0ZXNOU1sncmVmLXBvaW50cy1yZXNldC1vZmZzZXQnXTtcblxuZXhwb3J0IGRlZmF1bHQgc2hhcGVBdHRyaWJ1dGVzTlM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/shape.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/attributes/text.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/text.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/calc.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\n\nconst textAttributesNS = {\n\n    'line-height': {\n        qualify: isTextInUse\n    },\n\n    'text-vertical-anchor': {\n        qualify: isTextInUse\n    },\n\n    'text-path': {\n        qualify: isTextInUse\n    },\n\n    'annotations': {\n        qualify: isTextInUse\n    },\n\n    'eol': {\n        qualify: isTextInUse\n    },\n\n    'display-empty': {\n        qualify: isTextInUse\n    },\n\n    'text': {\n        qualify: function(_text, _node, attrs) {\n            const textWrap = attrs['text-wrap'];\n            return !textWrap || !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(textWrap);\n        },\n        unset: function(node) {\n            node.textContent = '';\n        },\n        set: function(text, refBBox, node, attrs) {\n            const cacheName = 'joint-text';\n            const cache = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.get(node, cacheName);\n            const lineHeight = attrs['line-height'];\n            const textVerticalAnchor = attrs['text-vertical-anchor'];\n            const displayEmpty = attrs['display-empty'];\n            const fontSize = attrs['font-size'];\n            const annotations = attrs.annotations;\n            const eol = attrs.eol;\n            const x = attrs.x;\n            let textPath = attrs['text-path'];\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // <tspan> positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(textPath)) {\n                    const pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        const pathNode = this.findNode(pathSelector);\n                        if (pathNode instanceof SVGPathElement) {\n                            textPath = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).text('' + text, {\n                    lineHeight,\n                    annotations,\n                    textPath,\n                    x,\n                    textVerticalAnchor,\n                    eol,\n                    displayEmpty\n                });\n                _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.set(node, cacheName, textHash);\n            }\n        }\n    },\n\n    'text-wrap': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if ((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression)(width)) {\n                size.width = Number((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression)(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if ((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression)(height)) {\n                size.height = Number((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression)(height, refBBox));\n            } else {\n                if (value.height === null) {\n                    // if height is not specified breakText() does not\n                    // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n\n                const breakTextFn = value.breakText || _util_util_mjs__WEBPACK_IMPORTED_MODULE_3__.breakText;\n                const computedStyles = getComputedStyle(node);\n                const wrapFontAttributes = {};\n                // The font size attributes must be set on the node\n                // to get the correct text wrapping.\n                // TODO: set the native SVG attributes before special attributes\n                for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n                    const name = FONT_ATTRIBUTES[i];\n                    if (name in attrs) {\n                        node.setAttribute(name, attrs[name]);\n                    }\n                    // Note: computedStyles is a live object\n                    // i.e. the properties are evaluated when accessed.\n                    wrapFontAttributes[name] = computedStyles[name];\n                }\n\n                // The `line-height` attribute in SVG is JoinJS specific.\n                // TODO: change the `lineHeight` to breakText option.\n                wrapFontAttributes.lineHeight = attrs['line-height'];\n\n                wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    separator: value.separator,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = '';\n            }\n            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        },\n        // We expose the font attributes list to allow\n        // the user to take other custom font attributes into account\n        // when wrapping the text.\n        FONT_ATTRIBUTES\n    },\n\n    'title': {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        unset: function(node) {\n            _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.remove(node, 'joint-title');\n            const titleNode = node.firstElementChild;\n            if (titleNode) {\n                titleNode.remove();\n            }\n        },\n        set: function(title, refBBox, node) {\n            var cacheName = 'joint-title';\n            var cache = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.get(node, cacheName);\n            if (cache === undefined || cache !== title) {\n                _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.set(node, cacheName, title);\n                if (node.tagName === 'title') {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === 'title') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (textAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL3RleHQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErRjtBQUNwQjtBQUNuQztBQUNOOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDZEQUFhO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEIsMERBQUM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3REFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzREFBTSxHQUFHLGlDQUFpQztBQUNqRjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCLDBEQUFDO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFZO0FBQzVCO0FBQ0EsY0FBYyxTQUFTLGdFQUFnQjtBQUN2QyxvQ0FBb0Msa0VBQWtCO0FBQ3RELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBWTtBQUM1QjtBQUNBLGNBQWMsU0FBUyxnRUFBZ0I7QUFDdkMscUNBQXFDLGtFQUFrQjtBQUN2RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVELHFEQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksMERBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFDO0FBQ3pCO0FBQ0EsZ0JBQWdCLDBEQUFDO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGlFQUFlLGdCQUFnQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvdGV4dC5tanM/MmY5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NpZ24sIGlzUGxhaW5PYmplY3QsIGlzT2JqZWN0LCBpc1BlcmNlbnRhZ2UsIGJyZWFrVGV4dCB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuaW1wb3J0IHsgaXNDYWxjRXhwcmVzc2lvbiwgZXZhbENhbGNFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jYWxjLm1qcyc7XG5pbXBvcnQgJCBmcm9tICcuLi8uLi9tdmMvRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi8uLi9WL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIGlzVGV4dEluVXNlKF92YWx1ZSwgX25vZGUsIGF0dHJzKSB7XG4gICAgcmV0dXJuIChhdHRycy50ZXh0ICE9PSB1bmRlZmluZWQpO1xufVxuXG5jb25zdCBGT05UX0FUVFJJQlVURVMgPSBbJ2ZvbnQtd2VpZ2h0JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdsZXR0ZXItc3BhY2luZycsICd0ZXh0LXRyYW5zZm9ybSddO1xuXG5jb25zdCB0ZXh0QXR0cmlidXRlc05TID0ge1xuXG4gICAgJ2xpbmUtaGVpZ2h0Jzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1RleHRJblVzZVxuICAgIH0sXG5cbiAgICAndGV4dC12ZXJ0aWNhbC1hbmNob3InOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgICd0ZXh0LXBhdGgnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgICdhbm5vdGF0aW9ucyc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgJ2VvbCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgJ2Rpc3BsYXktZW1wdHknOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgICd0ZXh0Jzoge1xuICAgICAgICBxdWFsaWZ5OiBmdW5jdGlvbihfdGV4dCwgX25vZGUsIGF0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0V3JhcCA9IGF0dHJzWyd0ZXh0LXdyYXAnXTtcbiAgICAgICAgICAgIHJldHVybiAhdGV4dFdyYXAgfHwgIWlzUGxhaW5PYmplY3QodGV4dFdyYXApO1xuICAgICAgICB9LFxuICAgICAgICB1bnNldDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleHQsIHJlZkJCb3gsIG5vZGUsIGF0dHJzKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZU5hbWUgPSAnam9pbnQtdGV4dCc7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9ICQuZGF0YS5nZXQobm9kZSwgY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBhdHRyc1snbGluZS1oZWlnaHQnXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRWZXJ0aWNhbEFuY2hvciA9IGF0dHJzWyd0ZXh0LXZlcnRpY2FsLWFuY2hvciddO1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheUVtcHR5ID0gYXR0cnNbJ2Rpc3BsYXktZW1wdHknXTtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTaXplID0gYXR0cnNbJ2ZvbnQtc2l6ZSddO1xuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSBhdHRycy5hbm5vdGF0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGVvbCA9IGF0dHJzLmVvbDtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhdHRycy54O1xuICAgICAgICAgICAgbGV0IHRleHRQYXRoID0gYXR0cnNbJ3RleHQtcGF0aCddO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0ZXh0IG9ubHkgaWYgdGhlcmUgd2FzIGEgY2hhbmdlIGluIHRoZSBzdHJpbmdcbiAgICAgICAgICAgIC8vIG9yIGFueSBvZiBpdHMgYXR0cmlidXRlcy5cbiAgICAgICAgICAgIGNvbnN0IHRleHRIYXNoID0gSlNPTi5zdHJpbmdpZnkoW3RleHQsIGxpbmVIZWlnaHQsIGFubm90YXRpb25zLCB0ZXh0VmVydGljYWxBbmNob3IsIGVvbCwgZGlzcGxheUVtcHR5LCB0ZXh0UGF0aCwgeCwgZm9udFNpemVdKTtcbiAgICAgICAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkIHx8IGNhY2hlICE9PSB0ZXh0SGFzaCkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBidWc6XG4gICAgICAgICAgICAgICAgLy8gPHRzcGFuPiBwb3NpdGlvbnMgZGVmaW5lZCBhcyBgZW1gIGFyZSBub3QgdXBkYXRlZFxuICAgICAgICAgICAgICAgIC8vIHdoZW4gY29udGFpbmVyIGBmb250LXNpemVgIGNoYW5nZS5cbiAgICAgICAgICAgICAgICBpZiAoZm9udFNpemUpIG5vZGUuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBmb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGV4dCBBbG9uZyBQYXRoIFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRleHRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoU2VsZWN0b3IgPSB0ZXh0UGF0aC5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoTm9kZSA9IHRoaXMuZmluZE5vZGUocGF0aFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoTm9kZSBpbnN0YW5jZW9mIFNWR1BhdGhFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFBhdGggPSBhc3NpZ24oeyAneGxpbms6aHJlZic6ICcjJyArIHBhdGhOb2RlLmlkIH0sIHRleHRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBWKG5vZGUpLnRleHQoJycgKyB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yLFxuICAgICAgICAgICAgICAgICAgICBlb2wsXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlFbXB0eVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICQuZGF0YS5zZXQobm9kZSwgY2FjaGVOYW1lLCB0ZXh0SGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3RleHQtd3JhcCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0ge307XG4gICAgICAgICAgICAvLyBvcHRpb24gYHdpZHRoYFxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdmFsdWUud2lkdGggfHwgMDtcbiAgICAgICAgICAgIGlmIChpc1BlcmNlbnRhZ2Uod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZS53aWR0aCA9IHJlZkJCb3gud2lkdGggKiBwYXJzZUZsb2F0KHdpZHRoKSAvIDEwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxjRXhwcmVzc2lvbih3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gTnVtYmVyKGV2YWxDYWxjRXhwcmVzc2lvbih3aWR0aCwgcmVmQkJveCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUud2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWtUZXh0KCkgcmVxdWlyZXMgd2lkdGggdG8gYmUgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUud2lkdGggPSByZWZCQm94LndpZHRoICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wdGlvbiBgaGVpZ2h0YFxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHZhbHVlLmhlaWdodCB8fCAwO1xuICAgICAgICAgICAgaWYgKGlzUGVyY2VudGFnZShoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSByZWZCQm94LmhlaWdodCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxjRXhwcmVzc2lvbihoZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSBOdW1iZXIoZXZhbENhbGNFeHByZXNzaW9uKGhlaWdodCwgcmVmQkJveCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGVpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkIGJyZWFrVGV4dCgpIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3RyaWN0IHRoZSBoZWlnaHQgb2YgdGhlIHRleHQuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaXplLmhlaWdodCA9IHJlZkJCb3guaGVpZ2h0ICsgaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wdGlvbiBgdGV4dGBcbiAgICAgICAgICAgIHZhciB3cmFwcGVkVGV4dDtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdmFsdWUudGV4dDtcbiAgICAgICAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHRleHQgPSBhdHRycy50ZXh0O1xuICAgICAgICAgICAgaWYgKHRleHQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYnJlYWtUZXh0Rm4gPSB2YWx1ZS5icmVha1RleHQgfHwgYnJlYWtUZXh0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3cmFwRm9udEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZm9udCBzaXplIGF0dHJpYnV0ZXMgbXVzdCBiZSBzZXQgb24gdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAvLyB0byBnZXQgdGhlIGNvcnJlY3QgdGV4dCB3cmFwcGluZy5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzZXQgdGhlIG5hdGl2ZSBTVkcgYXR0cmlidXRlcyBiZWZvcmUgc3BlY2lhbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBGT05UX0FUVFJJQlVURVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IEZPTlRfQVRUUklCVVRFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBjb21wdXRlZFN0eWxlcyBpcyBhIGxpdmUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGkuZS4gdGhlIHByb3BlcnRpZXMgYXJlIGV2YWx1YXRlZCB3aGVuIGFjY2Vzc2VkLlxuICAgICAgICAgICAgICAgICAgICB3cmFwRm9udEF0dHJpYnV0ZXNbbmFtZV0gPSBjb21wdXRlZFN0eWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYGxpbmUtaGVpZ2h0YCBhdHRyaWJ1dGUgaW4gU1ZHIGlzIEpvaW5KUyBzcGVjaWZpYy5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgdGhlIGBsaW5lSGVpZ2h0YCB0byBicmVha1RleHQgb3B0aW9uLlxuICAgICAgICAgICAgICAgIHdyYXBGb250QXR0cmlidXRlcy5saW5lSGVpZ2h0ID0gYXR0cnNbJ2xpbmUtaGVpZ2h0J107XG5cbiAgICAgICAgICAgICAgICB3cmFwcGVkVGV4dCA9IGJyZWFrVGV4dEZuKCcnICsgdGV4dCwgc2l6ZSwgd3JhcEZvbnRBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgYW4gZXhpc3RpbmcgU1ZHIERvY3VtZW50IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBjcmVhdGluZyBhIHRlbXBvcmFyeSBvbmUgb3ZlciBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgc3ZnRG9jdW1lbnQ6IHRoaXMucGFwZXIuc3ZnLFxuICAgICAgICAgICAgICAgICAgICBlbGxpcHNpczogdmFsdWUuZWxsaXBzaXMsXG4gICAgICAgICAgICAgICAgICAgIGh5cGhlbjogdmFsdWUuaHlwaGVuLFxuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3I6IHZhbHVlLnNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgbWF4TGluZUNvdW50OiB2YWx1ZS5tYXhMaW5lQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlU3BhY2VzOiB2YWx1ZS5wcmVzZXJ2ZVNwYWNlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkVGV4dCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEF0dHJpYnV0ZXNOUy50ZXh0LnNldC5jYWxsKHRoaXMsIHdyYXBwZWRUZXh0LCByZWZCQm94LCBub2RlLCBhdHRycyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIGV4cG9zZSB0aGUgZm9udCBhdHRyaWJ1dGVzIGxpc3QgdG8gYWxsb3dcbiAgICAgICAgLy8gdGhlIHVzZXIgdG8gdGFrZSBvdGhlciBjdXN0b20gZm9udCBhdHRyaWJ1dGVzIGludG8gYWNjb3VudFxuICAgICAgICAvLyB3aGVuIHdyYXBwaW5nIHRoZSB0ZXh0LlxuICAgICAgICBGT05UX0FUVFJJQlVURVNcbiAgICB9LFxuXG4gICAgJ3RpdGxlJzoge1xuICAgICAgICBxdWFsaWZ5OiBmdW5jdGlvbih0aXRsZSwgbm9kZSkge1xuICAgICAgICAgICAgLy8gSFRNTEVsZW1lbnQgdGl0bGUgaXMgc3BlY2lmaWVkIHZpYSBhbiBhdHRyaWJ1dGUgKGkuZS4gbm90IGFuIGVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAkLmRhdGEucmVtb3ZlKG5vZGUsICdqb2ludC10aXRsZScpO1xuICAgICAgICAgICAgY29uc3QgdGl0bGVOb2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIGlmICh0aXRsZU5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aXRsZU5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odGl0bGUsIHJlZkJCb3gsIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZU5hbWUgPSAnam9pbnQtdGl0bGUnO1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gJC5kYXRhLmdldChub2RlLCBjYWNoZU5hbWUpO1xuICAgICAgICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQgfHwgY2FjaGUgIT09IHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgJC5kYXRhLnNldChub2RlLCBjYWNoZU5hbWUsIHRpdGxlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50YWdOYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBpcyBhIDx0aXRsZT4gZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYWxseSA8dGl0bGU+IGVsZW1lbnQgc2hvdWxkIGJlIHRoZSBmaXJzdCBjaGlsZCBlbGVtZW50IG9mIGl0cyBwYXJlbnQuXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgYW4gZXhpc3RpbmcgdGl0bGVcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDaGlsZC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyB0aXRsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdGl0bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5vZGUubmFtZXNwYWNlVVJJLCAndGl0bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVOb2RlLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKHRpdGxlTm9kZSwgZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRleHRBdHRyaWJ1dGVzTlM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/attributes/text.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: () => (/* reexport safe */ _Cell_mjs__WEBPACK_IMPORTED_MODULE_3__.Cell),\n/* harmony export */   CellView: () => (/* reexport safe */ _CellView_mjs__WEBPACK_IMPORTED_MODULE_4__.CellView),\n/* harmony export */   Element: () => (/* reexport safe */ _Element_mjs__WEBPACK_IMPORTED_MODULE_5__.Element),\n/* harmony export */   ElementView: () => (/* reexport safe */ _ElementView_mjs__WEBPACK_IMPORTED_MODULE_6__.ElementView),\n/* harmony export */   Graph: () => (/* reexport safe */ _Graph_mjs__WEBPACK_IMPORTED_MODULE_0__.Graph),\n/* harmony export */   HighlighterView: () => (/* reexport safe */ _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_12__.HighlighterView),\n/* harmony export */   LayersNames: () => (/* reexport safe */ _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_2__.LayersNames),\n/* harmony export */   Link: () => (/* reexport safe */ _Link_mjs__WEBPACK_IMPORTED_MODULE_7__.Link),\n/* harmony export */   LinkView: () => (/* reexport safe */ _LinkView_mjs__WEBPACK_IMPORTED_MODULE_8__.LinkView),\n/* harmony export */   Paper: () => (/* reexport safe */ _Paper_mjs__WEBPACK_IMPORTED_MODULE_9__.Paper),\n/* harmony export */   PaperLayer: () => (/* reexport safe */ _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_2__.PaperLayer),\n/* harmony export */   ToolView: () => (/* reexport safe */ _ToolView_mjs__WEBPACK_IMPORTED_MODULE_10__.ToolView),\n/* harmony export */   ToolsView: () => (/* reexport safe */ _ToolsView_mjs__WEBPACK_IMPORTED_MODULE_11__.ToolsView),\n/* harmony export */   attributes: () => (/* reexport safe */ _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_1__.attributes)\n/* harmony export */ });\n/* harmony import */ var _Graph_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graph.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Graph.mjs\");\n/* harmony import */ var _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attributes/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/index.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Cell.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CellView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _Element_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Element.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Element.mjs\");\n/* harmony import */ var _ElementView_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ElementView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ElementView.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Link.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Link.mjs\");\n/* harmony import */ var _LinkView_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LinkView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/LinkView.mjs\");\n/* harmony import */ var _Paper_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Paper.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Paper.mjs\");\n/* harmony import */ var _ToolView_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _ToolsView_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ToolsView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolsView.mjs\");\n/* harmony import */ var _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ1c7QUFDTjtBQUNOO0FBQ0k7QUFDRDtBQUNJO0FBQ1A7QUFDSTtBQUNIO0FBQ0c7QUFDQztBQUNNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2luZGV4Lm1qcz82M2Q4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vR3JhcGgubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vYXR0cmlidXRlcy9pbmRleC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9QYXBlckxheWVyLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0NlbGwubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vQ2VsbFZpZXcubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vRWxlbWVudC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9FbGVtZW50Vmlldy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9MaW5rLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0xpbmtWaWV3Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL1BhcGVyLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL1Rvb2xWaWV3Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL1Rvb2xzVmlldy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9IaWdobGlnaHRlclZpZXcubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/layers/GridLayer.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/layers/GridLayer.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayer: () => (/* binding */ GridLayer)\n/* harmony export */ });\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PaperLayer.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\nconst GridLayer = _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_0__.PaperLayer.extend({\n\n    style: {\n        'pointer-events': 'none'\n    },\n\n    _gridCache: null,\n    _gridSettings: null,\n\n    init() {\n        _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_0__.PaperLayer.prototype.init.apply(this, arguments);\n        const { options: { paper }} = this;\n        this._gridCache = null;\n        this._gridSettings = [];\n        this.listenTo(paper, 'transform resize', this.updateGrid);\n    },\n\n    setGrid(drawGrid) {\n        this._gridSettings = this.getGridSettings(drawGrid);\n        this.renderGrid();\n    },\n\n    getGridSettings(drawGrid) {\n        const gridSettings = [];\n        if (drawGrid) {\n            const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n            optionsList.forEach((item) => {\n                gridSettings.push(...this._resolveDrawGridOption(item));\n            });\n        }\n        return gridSettings;\n    },\n\n    removeGrid() {\n        const { _gridCache: grid } = this;\n        if (!grid) return;\n        grid.root.remove();\n        this._gridCache = null;\n    },\n\n    renderGrid() {\n\n        const { options: { paper }} = this;\n        const { _gridSettings: gridSettings } = this;\n\n        this.removeGrid();\n\n        if (gridSettings.length === 0) return;\n\n        const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n        if (gridSize <= 1) {\n            return;\n        }\n\n        const refs = this._getGridRefs();\n\n        gridSettings.forEach((gridLayerSetting, index) => {\n\n            const id = this._getPatternId(index);\n            const options = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, gridLayerSetting);\n            const { scaleFactor = 1 } = options;\n            options.width = gridSize * scaleFactor || 1;\n            options.height = gridSize * scaleFactor || 1;\n\n            let vPattern;\n            if (!refs.exist(id)) {\n                vPattern = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(options.markup));\n                refs.add(id, vPattern);\n            } else {\n                vPattern = refs.get(id);\n            }\n\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.render)) {\n                options.render(vPattern.node.firstChild, options, paper);\n            }\n            vPattern.attr({\n                width: options.width,\n                height: options.height\n            });\n        });\n\n        refs.root.appendTo(this.el);\n        this.updateGrid();\n    },\n\n    updateGrid() {\n\n        const { _gridCache: grid, _gridSettings: gridSettings, options: { paper }} = this;\n        if (!grid) return;\n        const { root: vSvg, patterns } = grid;\n        const { x, y, width, height } = paper.getArea();\n        vSvg.attr({ x, y, width, height });\n        for (const patternId in patterns) {\n            const vPattern = patterns[patternId];\n            vPattern.attr({ x: -x, y: -y });\n        }\n        gridSettings.forEach((options, index) => {\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.update)) {\n                const vPattern = patterns[this._getPatternId(index)];\n                options.update(vPattern.node.firstChild, options, paper);\n            }\n        });\n    },\n\n    _getPatternId(index) {\n        return `pattern_${this.options.paper.cid}_${index}`;\n    },\n\n    _getGridRefs() {\n        let { _gridCache: grid } = this;\n        if (grid) return grid;\n        const defsVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('defs');\n        const svgVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('svg', { width: '100%', height: '100%' }, [defsVEl]);\n        grid = this._gridCache = {\n            root: svgVEl,\n            patterns: {},\n            add: function(id, patternVEl) {\n                const rectVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('rect', { width: '100%', height: '100%', fill: `url(#${id})` });\n                defsVEl.append(patternVEl);\n                svgVEl.append(rectVEl);\n                this.patterns[id] = patternVEl;\n            },\n            get: function(id) {\n                return this.patterns[id];\n            },\n            exist: function(id) {\n                return this.patterns[id] !== undefined;\n            }\n        };\n        return grid;\n    },\n\n    _resolveDrawGridOption(opt) {\n\n        var namespace = this.options.patterns;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, item);\n            });\n        }\n\n        var options = opt || { args: [{}] };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n\n        if (!isArray && !name && !options.markup) {\n            name = 'dot';\n        }\n\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, item);\n            });\n\n            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.defaults)(args[0], (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit)(opt, 'args'));\n            for (var i = 0; i < args.length; i++) {\n                if (pattern[i]) {\n                    (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n\n        return isArray ? options : [options];\n    },\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9sYXllcnMvR3JpZExheWVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStDO0FBUWpCO0FBQ0k7O0FBRTNCLGtCQUFrQix1REFBVTs7QUFFbkM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFFBQVEsdURBQVU7QUFDbEIsZ0JBQWdCLFdBQVcsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZ0JBQWdCLFdBQVcsU0FBUztBQUNwQyxnQkFBZ0IsOEJBQThCOztBQUU5Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUE0QixzREFBSyxHQUFHO0FBQ3BDLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFDLGNBQWMsd0NBQXdDLEVBQUUsd0RBQUM7QUFDckY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxnQkFBZ0IsMkRBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLGdCQUFnQiwwREFBMEQsU0FBUztBQUNuRjtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsZ0JBQWdCLHNCQUFzQjtBQUN0QyxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCLHVCQUF1QixHQUFHLE1BQU07QUFDMUQsS0FBSzs7QUFFTDtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0Esd0JBQXdCLHdEQUFDO0FBQ3pCLHVCQUF1Qix3REFBQyxVQUFVLCtCQUErQjtBQUNqRTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsZ0NBQWdDLHdEQUFDLFdBQVcsNkNBQTZDLEdBQUcsSUFBSTtBQUNoRztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLFlBQVkseURBQVE7QUFDcEI7QUFDQSx1QkFBdUIsdURBQU0sR0FBRztBQUNoQyxhQUFhO0FBQ2I7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix1REFBTSxHQUFHO0FBQ2hDLGFBQWE7O0FBRWIsdUZBQXVGOztBQUV2RixZQUFZLHlEQUFRLFVBQVUscURBQUk7QUFDbEMsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBLG9CQUFvQix1REFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9sYXllcnMvR3JpZExheWVyLm1qcz82ZjRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcGVyTGF5ZXIgfSBmcm9tICcuLi9QYXBlckxheWVyLm1qcyc7XG5pbXBvcnQge1xuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNTdHJpbmcsXG4gICAgZGVmYXVsdHMsXG4gICAgb21pdCxcbiAgICBhc3NpZ24sXG4gICAgbWVyZ2UsXG59IGZyb20gJy4uLy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uLy4uL1YvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IEdyaWRMYXllciA9IFBhcGVyTGF5ZXIuZXh0ZW5kKHtcblxuICAgIHN0eWxlOiB7XG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgIH0sXG5cbiAgICBfZ3JpZENhY2hlOiBudWxsLFxuICAgIF9ncmlkU2V0dGluZ3M6IG51bGwsXG5cbiAgICBpbml0KCkge1xuICAgICAgICBQYXBlckxheWVyLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9uczogeyBwYXBlciB9fSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2dyaWRDYWNoZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dyaWRTZXR0aW5ncyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RlblRvKHBhcGVyLCAndHJhbnNmb3JtIHJlc2l6ZScsIHRoaXMudXBkYXRlR3JpZCk7XG4gICAgfSxcblxuICAgIHNldEdyaWQoZHJhd0dyaWQpIHtcbiAgICAgICAgdGhpcy5fZ3JpZFNldHRpbmdzID0gdGhpcy5nZXRHcmlkU2V0dGluZ3MoZHJhd0dyaWQpO1xuICAgICAgICB0aGlzLnJlbmRlckdyaWQoKTtcbiAgICB9LFxuXG4gICAgZ2V0R3JpZFNldHRpbmdzKGRyYXdHcmlkKSB7XG4gICAgICAgIGNvbnN0IGdyaWRTZXR0aW5ncyA9IFtdO1xuICAgICAgICBpZiAoZHJhd0dyaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gQXJyYXkuaXNBcnJheShkcmF3R3JpZCkgPyBkcmF3R3JpZCA6IFtkcmF3R3JpZCB8fCB7fV07XG4gICAgICAgICAgICBvcHRpb25zTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgZ3JpZFNldHRpbmdzLnB1c2goLi4udGhpcy5fcmVzb2x2ZURyYXdHcmlkT3B0aW9uKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmlkU2V0dGluZ3M7XG4gICAgfSxcblxuICAgIHJlbW92ZUdyaWQoKSB7XG4gICAgICAgIGNvbnN0IHsgX2dyaWRDYWNoZTogZ3JpZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFncmlkKSByZXR1cm47XG4gICAgICAgIGdyaWQucm9vdC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fZ3JpZENhY2hlID0gbnVsbDtcbiAgICB9LFxuXG4gICAgcmVuZGVyR3JpZCgpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnM6IHsgcGFwZXIgfX0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IF9ncmlkU2V0dGluZ3M6IGdyaWRTZXR0aW5ncyB9ID0gdGhpcztcblxuICAgICAgICB0aGlzLnJlbW92ZUdyaWQoKTtcblxuICAgICAgICBpZiAoZ3JpZFNldHRpbmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGdyaWRTaXplID0gcGFwZXIub3B0aW9ucy5kcmF3R3JpZFNpemUgfHwgcGFwZXIub3B0aW9ucy5ncmlkU2l6ZTtcbiAgICAgICAgaWYgKGdyaWRTaXplIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZnMgPSB0aGlzLl9nZXRHcmlkUmVmcygpO1xuXG4gICAgICAgIGdyaWRTZXR0aW5ncy5mb3JFYWNoKChncmlkTGF5ZXJTZXR0aW5nLCBpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMuX2dldFBhdHRlcm5JZChpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gbWVyZ2Uoe30sIGdyaWRMYXllclNldHRpbmcpO1xuICAgICAgICAgICAgY29uc3QgeyBzY2FsZUZhY3RvciA9IDEgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zLndpZHRoID0gZ3JpZFNpemUgKiBzY2FsZUZhY3RvciB8fCAxO1xuICAgICAgICAgICAgb3B0aW9ucy5oZWlnaHQgPSBncmlkU2l6ZSAqIHNjYWxlRmFjdG9yIHx8IDE7XG5cbiAgICAgICAgICAgIGxldCB2UGF0dGVybjtcbiAgICAgICAgICAgIGlmICghcmVmcy5leGlzdChpZCkpIHtcbiAgICAgICAgICAgICAgICB2UGF0dGVybiA9IFYoJ3BhdHRlcm4nLCB7IGlkOiBpZCwgcGF0dGVyblVuaXRzOiAndXNlclNwYWNlT25Vc2UnIH0sIFYob3B0aW9ucy5tYXJrdXApKTtcbiAgICAgICAgICAgICAgICByZWZzLmFkZChpZCwgdlBhdHRlcm4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2UGF0dGVybiA9IHJlZnMuZ2V0KGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5yZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIodlBhdHRlcm4ubm9kZS5maXJzdENoaWxkLCBvcHRpb25zLCBwYXBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2UGF0dGVybi5hdHRyKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVmcy5yb290LmFwcGVuZFRvKHRoaXMuZWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlR3JpZCgpIHtcblxuICAgICAgICBjb25zdCB7IF9ncmlkQ2FjaGU6IGdyaWQsIF9ncmlkU2V0dGluZ3M6IGdyaWRTZXR0aW5ncywgb3B0aW9uczogeyBwYXBlciB9fSA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JpZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHJvb3Q6IHZTdmcsIHBhdHRlcm5zIH0gPSBncmlkO1xuICAgICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHBhcGVyLmdldEFyZWEoKTtcbiAgICAgICAgdlN2Zy5hdHRyKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuSWQgaW4gcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZQYXR0ZXJuID0gcGF0dGVybnNbcGF0dGVybklkXTtcbiAgICAgICAgICAgIHZQYXR0ZXJuLmF0dHIoeyB4OiAteCwgeTogLXkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZFNldHRpbmdzLmZvckVhY2goKG9wdGlvbnMsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2UGF0dGVybiA9IHBhdHRlcm5zW3RoaXMuX2dldFBhdHRlcm5JZChpbmRleCldO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudXBkYXRlKHZQYXR0ZXJuLm5vZGUuZmlyc3RDaGlsZCwgb3B0aW9ucywgcGFwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2dldFBhdHRlcm5JZChpbmRleCkge1xuICAgICAgICByZXR1cm4gYHBhdHRlcm5fJHt0aGlzLm9wdGlvbnMucGFwZXIuY2lkfV8ke2luZGV4fWA7XG4gICAgfSxcblxuICAgIF9nZXRHcmlkUmVmcygpIHtcbiAgICAgICAgbGV0IHsgX2dyaWRDYWNoZTogZ3JpZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGdyaWQpIHJldHVybiBncmlkO1xuICAgICAgICBjb25zdCBkZWZzVkVsID0gVignZGVmcycpO1xuICAgICAgICBjb25zdCBzdmdWRWwgPSBWKCdzdmcnLCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH0sIFtkZWZzVkVsXSk7XG4gICAgICAgIGdyaWQgPSB0aGlzLl9ncmlkQ2FjaGUgPSB7XG4gICAgICAgICAgICByb290OiBzdmdWRWwsXG4gICAgICAgICAgICBwYXR0ZXJuczoge30sXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGlkLCBwYXR0ZXJuVkVsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjdFZFbCA9IFYoJ3JlY3QnLCB7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBmaWxsOiBgdXJsKCMke2lkfSlgIH0pO1xuICAgICAgICAgICAgICAgIGRlZnNWRWwuYXBwZW5kKHBhdHRlcm5WRWwpO1xuICAgICAgICAgICAgICAgIHN2Z1ZFbC5hcHBlbmQocmVjdFZFbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXR0ZXJuc1tpZF0gPSBwYXR0ZXJuVkVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuc1tpZF07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhpc3Q6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVybnNbaWRdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBncmlkO1xuICAgIH0sXG5cbiAgICBfcmVzb2x2ZURyYXdHcmlkT3B0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLm9wdGlvbnMucGF0dGVybnM7XG4gICAgICAgIGlmIChpc1N0cmluZyhvcHQpICYmIEFycmF5LmlzQXJyYXkobmFtZXNwYWNlW29wdF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlW29wdF0ubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBvcHQgfHwgeyBhcmdzOiBbe31dIH07XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShvcHRpb25zKTtcbiAgICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG5cbiAgICAgICAgaWYgKCFpc0FycmF5ICYmICFuYW1lICYmICFvcHRpb25zLm1hcmt1cCkge1xuICAgICAgICAgICAgbmFtZSA9ICdkb3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgJiYgQXJyYXkuaXNBcnJheShuYW1lc3BhY2VbbmFtZV0pKSB7XG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IG5hbWVzcGFjZVtuYW1lXS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ24oe30sIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmFyZ3MpID8gb3B0aW9ucy5hcmdzIDogW29wdGlvbnMuYXJncyB8fCB7fV07XG5cbiAgICAgICAgICAgIGRlZmF1bHRzKGFyZ3NbMF0sIG9taXQob3B0LCAnYXJncycpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbihwYXR0ZXJuW2ldLCBhcmdzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0FycmF5ID8gb3B0aW9ucyA6IFtvcHRpb25zXTtcbiAgICB9LFxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/layers/GridLayer.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/dia/ports.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ports.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   elementPortPrototype: () => (/* binding */ elementPortPrototype),\n/* harmony export */   elementViewPortPrototype: () => (/* binding */ elementViewPortPrototype)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/ports/port.mjs */ \"(ssr)/./node_modules/@joint/core/src/layout/ports/port.mjs\");\n/* harmony import */ var _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout/ports/portLabel.mjs */ \"(ssr)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs\");\n\n\n\n\n\n\nvar PortData = function(data) {\n\n    var clonedData = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(data) || {};\n    this.ports = [];\n    this.groups = {};\n    this.portLayoutNamespace = _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_1__;\n    this.portLabelLayoutNamespace = _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__;\n\n    this._init(clonedData);\n};\n\nPortData.prototype = {\n\n    getPorts: function() {\n        return this.ports;\n    },\n\n    getGroup: function(name) {\n        return this.groups[name] || {};\n    },\n\n    getPortsByGroup: function(groupName) {\n\n        return this.ports.filter(function(port) {\n            return port.group === groupName;\n        });\n    },\n\n    getGroupPortsMetrics: function(groupName, elBBox) {\n\n        var group = this.getGroup(groupName);\n        var ports = this.getPortsByGroup(groupName);\n\n        var groupPosition = group.position || {};\n        var groupPositionName = groupPosition.name;\n        var namespace = this.portLayoutNamespace;\n        if (!namespace[groupPositionName]) {\n            groupPositionName = 'left';\n        }\n\n        var groupArgs = groupPosition.args || {};\n        var portsArgs = ports.map(function(port) {\n            return port && port.position && port.position.args;\n        });\n        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n\n        var accumulator = {\n            ports: ports,\n            result: []\n        };\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(groupPortTransformations).reduce(function(res, portTransformation, index) {\n            var port = res.ports[index];\n            res.result.push({\n                portId: port.id,\n                portTransformation: portTransformation,\n                labelTransformation: this._getPortLabelLayout(port, (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point)(portTransformation), elBBox),\n                portAttrs: port.attrs,\n                portSize: port.size,\n                labelSize: port.label.size\n            });\n            return res;\n        }.bind(this), accumulator);\n\n        return accumulator.result;\n    },\n\n    _getPortLabelLayout: function(port, portPosition, elBBox) {\n\n        var namespace = this.portLabelLayoutNamespace;\n        var labelPosition = port.label.position.name || 'left';\n\n        if (namespace[labelPosition]) {\n            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n        }\n\n        return null;\n    },\n\n    _init: function(data) {\n\n        // prepare groups\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(data.groups)) {\n            var groups = Object.keys(data.groups);\n            for (var i = 0, n = groups.length; i < n; i++) {\n                var key = groups[i];\n                this.groups[key] = this._evaluateGroup(data.groups[key]);\n            }\n        }\n\n        // prepare ports\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(data.items);\n        for (var j = 0, m = ports.length; j < m; j++) {\n            this.ports.push(this._evaluatePort(ports[j]));\n        }\n    },\n\n    _evaluateGroup: function(group) {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge(group, {\n            position: this._getPosition(group.position, true),\n            label: this._getLabel(group, true)\n        });\n    },\n\n    _evaluatePort: function(port) {\n\n        var evaluated = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, port);\n\n        var group = this.getGroup(port.group);\n\n        evaluated.markup = evaluated.markup || group.markup;\n        evaluated.attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({}, group.attrs, evaluated.attrs);\n        evaluated.position = this._createPositionNode(group, evaluated);\n        evaluated.label = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({}, group.label, this._getLabel(evaluated));\n        evaluated.z = this._getZIndex(group, evaluated);\n        evaluated.size = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, group.size, evaluated.size);\n\n        return evaluated;\n    },\n\n    _getZIndex: function(group, port) {\n\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(port.z)) {\n            return port.z;\n        }\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(group.z) || group.z === 'auto') {\n            return group.z;\n        }\n        return 'auto';\n    },\n\n    _createPositionNode: function(group, port) {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({\n            name: 'left',\n            args: {}\n        }, group.position, { args: port.args });\n    },\n\n    _getPosition: function(position, setDefault) {\n\n        var args = {};\n        var positionName;\n\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(position)) {\n            positionName = 'fn';\n            args.fn = position;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(position)) {\n            positionName = position;\n        } else if (position === undefined) {\n            positionName = setDefault ? 'left' : null;\n        } else if (Array.isArray(position)) {\n            positionName = 'absolute';\n            args.x = position[0];\n            args.y = position[1];\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(position)) {\n            positionName = position.name;\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign(args, position.args);\n        }\n\n        var result = { args: args };\n\n        if (positionName) {\n            result.name = positionName;\n        }\n        return result;\n    },\n\n    _getLabel: function(item, setDefaults) {\n\n        var label = item.label || {};\n\n        var ret = label;\n        ret.position = this._getPosition(label.position, setDefaults);\n\n        return ret;\n    }\n};\n\nconst elementPortPrototype = {\n\n    _initializePorts: function() {\n\n        this._createPortData();\n        this.on('change:ports', function() {\n\n            this._processRemovedPort();\n            this._createPortData();\n        }, this);\n    },\n\n    /**\n     * remove links tied wiht just removed element\n     * @private\n     */\n    _processRemovedPort: function() {\n\n        var current = this.get('ports') || {};\n        var currentItemsMap = {};\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(current.items).forEach(function(item) {\n            currentItemsMap[item.id] = true;\n        });\n\n        var previous = this.previous('ports') || {};\n        var removed = {};\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(previous.items).forEach(function(item) {\n            if (!currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n\n        var graph = this.graph;\n        if (graph && !_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty(removed)) {\n\n            var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removed[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removed[link.get('source').port]) link.remove();\n            });\n        }\n    },\n\n    /**\n     * @returns {boolean}\n     */\n    hasPorts: function() {\n\n        var ports = this.prop('ports/items');\n        return Array.isArray(ports) && ports.length > 0;\n    },\n\n    /**\n     * @param {string} id\n     * @returns {boolean}\n     */\n    hasPort: function(id) {\n\n        return this.getPortIndex(id) !== -1;\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getPorts: function() {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(this.prop('ports/items')) || [];\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getGroupPorts: function(groupName) {\n        const groupPorts = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop(['ports','items'])).filter(port => port.group === groupName);\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(groupPorts);\n    },\n\n    /**\n     * @param {string} id\n     * @returns {object}\n     */\n    getPort: function(id) {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop('ports/items')).find(function(port) {\n            return port.id && port.id === id;\n        }));\n    },\n\n    getPortGroupNames: function() {\n        return Object.keys(this._portSettingsData.groups);\n    },\n\n    /**\n     * @param {string} groupName\n     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n     */\n    getPortsPositions: function(groupName) {\n\n        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect)(this.size()));\n\n        return portsMetrics.reduce(function(positions, metrics) {\n            var transformation = metrics.portTransformation;\n            positions[metrics.portId] = {\n                x: transformation.x,\n                y: transformation.y,\n                angle: transformation.angle\n            };\n            return positions;\n        }, {});\n    },\n\n    /**\n     * @param {string|Port} port port id or port\n     * @returns {number} port index\n     */\n    getPortIndex: function(port) {\n\n        var id = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) ? port.id : port;\n\n        if (!this._isValidPortId(id)) {\n            return -1;\n        }\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop('ports/items')).findIndex(function(item) {\n            return item.id === id;\n        });\n    },\n\n    /**\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    addPort: function(port, opt) {\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) || Array.isArray(port)) {\n            throw new Error('Element: addPort requires an object.');\n        }\n\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop('ports/items'));\n        ports.push(port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string|Port|number} before\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    insertPort: function(before, port, opt) {\n        const index = (typeof before === 'number') ? before : this.getPortIndex(before);\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) || Array.isArray(port)) {\n            throw new Error('dia.Element: insertPort requires an object.');\n        }\n\n        const ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop('ports/items'));\n        ports.splice(index, 0, port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string} portId\n     * @param {string|object=} path\n     * @param {*=} value\n     * @param {object=} opt\n     * @returns {joint.dia.Element}\n     */\n    portProp: function(portId, path, value, opt) {\n\n        var index = this.getPortIndex(portId);\n\n        if (index === -1) {\n            throw new Error('Element: unable to find port with id ' + portId);\n        }\n\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (Array.isArray(path)) {\n            args[0] = ['ports', 'items', index].concat(path);\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(path)) {\n\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = ['ports/items/', index, '/', path].join('');\n\n        } else {\n\n            args = ['ports/items/' + index];\n            if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(path)) {\n                args.push(path);\n                args.push(value);\n            }\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    _validatePorts: function() {\n\n        var portsAttr = this.get('ports') || {};\n\n        var errorMessages = [];\n        portsAttr = portsAttr || {};\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(portsAttr.items);\n\n        ports.forEach(function(p) {\n\n            if (typeof p !== 'object') {\n                errorMessages.push('Element: invalid port ', p);\n            }\n\n            if (!this._isValidPortId(p.id)) {\n                p.id = this.generatePortId();\n            }\n        }, this);\n\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq(ports, 'id').length !== ports.length) {\n            errorMessages.push('Element: found id duplicities in ports.');\n        }\n\n        return errorMessages;\n    },\n\n    generatePortId: function() {\n        return this.generateId();\n    },\n\n    /**\n     * @param {string} id port id\n     * @returns {boolean}\n     * @private\n     */\n    _isValidPortId: function(id) {\n\n        return id !== null && id !== undefined && !_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(id);\n    },\n\n    addPorts: function(ports, opt) {\n\n        if (ports.length) {\n            this.prop('ports/items', _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop('ports/items')).concat(ports), opt);\n        }\n\n        return this;\n    },\n\n    removePort: function(port, opt) {\n        const options = opt || {};\n        const index = this.getPortIndex(port);\n        if (index !== -1) {\n            const ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(['ports', 'items']));\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.startBatch('port-remove');\n            this.prop(['ports', 'items'], ports, options);\n            this.stopBatch('port-remove');\n        }\n        return this;\n    },\n\n    removePorts: function(portsForRemoval, opt) {\n        let options, newPorts;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length === 0) return this.this;\n            const currentPorts = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(['ports', 'items']));\n            newPorts = currentPorts.filter(function(cp) {\n                return !portsForRemoval.some(function(rp) {\n                    const rpId = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(rp) ? rp.id : rp;\n                    return cp.id === rpId;\n                });\n            });\n        } else {\n            options = portsForRemoval || {};\n            newPorts = [];\n        }\n        this.startBatch('port-remove');\n        options.rewrite = true;\n        this.prop(['ports', 'items'], newPorts, options);\n        this.stopBatch('port-remove');\n        return this;\n    },\n\n    /**\n     * @private\n     */\n    _createPortData: function() {\n\n        var err = this._validatePorts();\n\n        if (err.length > 0) {\n            this.set('ports', this.previous('ports'));\n            throw new Error(err.join(' '));\n        }\n\n        var prevPortData;\n\n        if (this._portSettingsData) {\n\n            prevPortData = this._portSettingsData.getPorts();\n        }\n\n        this._portSettingsData = new PortData(this.get('ports'));\n\n        var curPortData = this._portSettingsData.getPorts();\n\n        if (prevPortData) {\n\n            var added = curPortData.filter(function(item) {\n                if (!prevPortData.find(function(prevPort) {\n                    return prevPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            var removed = prevPortData.filter(function(item) {\n                if (!curPortData.find(function(curPort) {\n                    return curPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            if (removed.length > 0) {\n                this.trigger('ports:remove', this, removed);\n            }\n\n            if (added.length > 0) {\n                this.trigger('ports:add', this, added);\n            }\n        }\n    }\n};\n\nconst elementViewPortPrototype = {\n\n    portContainerMarkup: 'g',\n    portMarkup: [{\n        tagName: 'circle',\n        selector: 'circle',\n        attributes: {\n            'r': 10,\n            'fill': '#FFFFFF',\n            'stroke': '#000000'\n        }\n    }],\n    portLabelMarkup: [{\n        tagName: 'text',\n        selector: 'text',\n        attributes: {\n            'fill': '#000000'\n        }\n    }],\n    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n    _portElementsCache: null,\n\n    /**\n     * @private\n     */\n    _initializePorts: function() {\n        this._cleanPortsCache();\n    },\n\n    /**\n     * @typedef {Object} Port\n     *\n     * @property {string} id\n     * @property {Object} position\n     * @property {Object} label\n     * @property {Object} attrs\n     * @property {string} markup\n     * @property {string} group\n     */\n\n    /**\n     * @private\n     */\n    _refreshPorts: function() {\n\n        this._removePorts();\n        this._cleanPortsCache();\n        this._renderPorts();\n    },\n\n    _cleanPortsCache: function() {\n        this._portElementsCache = {};\n    },\n\n    /**\n     * @private\n     */\n    _renderPorts: function() {\n\n        // references to rendered elements without z-index\n        var elementReferences = [];\n        var elem = this._getContainerElement();\n\n        for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n            elementReferences.push(elem.node.childNodes[i]);\n        }\n\n        var portsGropsByZ = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.groupBy(this.model._portSettingsData.getPorts(), 'z');\n        var withoutZKey = 'auto';\n\n        // render non-z first\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n            var portElement = this._getPortElement(port);\n            elem.append(portElement);\n            elementReferences.push(portElement);\n        }, this);\n\n        var groupNames = Object.keys(portsGropsByZ);\n        for (var k = 0; k < groupNames.length; k++) {\n            var groupName = groupNames[k];\n            if (groupName !== withoutZKey) {\n                var z = parseInt(groupName, 10);\n                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n            }\n        }\n\n        this._updatePorts();\n    },\n\n    /**\n     * @returns {V}\n     * @private\n     */\n    _getContainerElement: function() {\n\n        return this.rotatableNode || this.vel;\n    },\n\n    /**\n     * @param {Array<Port>}ports\n     * @param {number} z\n     * @param refs\n     * @private\n     */\n    _appendPorts: function(ports, z, refs) {\n\n        var containerElement = this._getContainerElement();\n        var portElements = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(ports).map(this._getPortElement, this);\n\n        if (refs[z] || z < 0) {\n            (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(refs[Math.max(z, 0)]).before(portElements);\n        } else {\n            containerElement.append(portElements);\n        }\n    },\n\n    /**\n     * Try to get element from cache,\n     * @param port\n     * @returns {*}\n     * @private\n     */\n    _getPortElement: function(port) {\n\n        if (this._portElementsCache[port.id]) {\n            return this._portElementsCache[port.id].portElement;\n        }\n        return this._createPortElement(port);\n    },\n\n    findPortNodes: function(portId, selector) {\n        const portCache = this._portElementsCache[portId];\n        if (!portCache) return [];\n        if (!selector) return [portCache.portContentElement.node];\n        const portRoot = portCache.portElement.node;\n        const portSelectors = portCache.portSelectors;\n        return this.findBySelector(selector, portRoot, portSelectors);\n    },\n\n    findPortNode: function(portId, selector) {\n        const [node = null] = this.findPortNodes(portId, selector);\n        return node;\n    },\n\n    /**\n     * @private\n     */\n    _updatePorts: function() {\n\n        // layout ports without group\n        this._updatePortGroup(undefined);\n        // layout ports with explicit group\n        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n        groupsNames.forEach(this._updatePortGroup, this);\n    },\n\n    /**\n     * @private\n     */\n    _removePorts: function() {\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.invoke(this._portElementsCache, 'portElement.remove');\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {V}\n     * @private\n     */\n    _createPortElement: function(port) {\n\n        let portElement;\n        let labelElement;\n        let labelSelectors;\n        let portSelectors;\n\n        var portContainerElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.portContainerMarkup).addClass('joint-port');\n\n        var portMarkup = this._getPortMarkup(port);\n        if (Array.isArray(portMarkup)) {\n            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n            var portFragment = portDoc.fragment;\n            if (portFragment.childNodes.length > 1) {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(portFragment);\n            } else {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(portFragment.firstChild);\n            }\n            portSelectors = portDoc.selectors;\n        } else {\n            portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(portMarkup);\n            if (Array.isArray(portElement)) {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(portElement);\n            }\n        }\n\n        if (!portElement) {\n            throw new Error('ElementView: Invalid port markup.');\n        }\n\n        portElement.attr({\n            'port': port.id,\n            'port-group': port.group\n        });\n\n        // If the port ID is a number, we need to add\n        // extra information to the port element to distinguish\n        // between ports with the same ID but different types.\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(port.id)) {\n            portElement.attr('port-id-type', 'number');\n        }\n\n        const labelMarkupDef = this._getPortLabelMarkup(port.label);\n        if (Array.isArray(labelMarkupDef)) {\n            // JSON Markup\n            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n            const childCount = fragment.childNodes.length;\n            if (childCount > 0) {\n                labelSelectors = selectors;\n                labelElement = (childCount === 1) ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fragment.firstChild) : (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(fragment);\n            }\n        } else {\n            // String Markup\n            labelElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(labelMarkupDef);\n            if (Array.isArray(labelElement)) {\n                labelElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(labelElement);\n            }\n        }\n\n        var portContainerSelectors;\n        if (portSelectors && labelSelectors) {\n            for (var key in labelSelectors) {\n                if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n            }\n            portContainerSelectors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, portSelectors, labelSelectors);\n        } else {\n            portContainerSelectors = portSelectors || labelSelectors || {};\n        }\n\n        // The `portRootSelector` points to the root SVGNode of the port.\n        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n        // Or the single SVGNode of the port.\n        const portRootSelector = 'portRoot';\n        // The `labelRootSelector` points to the root SVGNode of the label.\n        const labelRootSelector = 'labelRoot';\n        // The `labelTextSelector` points to all text SVGNodes of the label.\n        const labelTextSelector = 'labelText';\n\n        if (!(portRootSelector in portContainerSelectors)) {\n            portContainerSelectors[portRootSelector] = portElement.node;\n        }\n\n        if (labelElement) {\n            const labelNode = labelElement.node;\n            if (!(labelRootSelector in portContainerSelectors)) {\n                portContainerSelectors[labelRootSelector] = labelNode;\n            }\n            if (!(labelTextSelector in portContainerSelectors)) {\n                // If the label is a <text> element, we can use it directly.\n                // Otherwise, we need to find the <text> element within the label.\n                const labelTextNode = (labelElement.tagName() === 'TEXT')\n                    ? labelNode\n                    : Array.from(labelNode.querySelectorAll('text'));\n                portContainerSelectors[labelTextSelector] = labelTextNode;\n                if (!labelSelectors) labelSelectors = {};\n                labelSelectors[labelTextSelector] = labelTextNode;\n            }\n        }\n\n        portContainerElement.append(portElement.addClass('joint-port-body'));\n        if (labelElement) {\n            portContainerElement.append(labelElement.addClass('joint-port-label'));\n        }\n\n        this._portElementsCache[port.id] = {\n            portElement: portContainerElement,\n            portLabelElement: labelElement,\n            portSelectors: portContainerSelectors,\n            portLabelSelectors: labelSelectors,\n            portContentElement: portElement,\n            portContentSelectors: portSelectors\n        };\n\n        return portContainerElement;\n    },\n\n    /**\n     * @param {string=} groupName\n     * @private\n     */\n    _updatePortGroup: function(groupName) {\n\n        var elementBBox = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect)(this.model.size());\n        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n\n        for (var i = 0, n = portsMetrics.length; i < n; i++) {\n            var metrics = portsMetrics[i];\n            var portId = metrics.portId;\n            var cached = this._portElementsCache[portId] || {};\n            var portTransformation = metrics.portTransformation;\n            var labelTransformation = metrics.labelTransformation;\n            if (labelTransformation && cached.portLabelElement) {\n                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n                    rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(metrics.labelSize),\n                    selectors: cached.portLabelSelectors\n                });\n                this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\n            }\n            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n                rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(metrics.portSize),\n                selectors: cached.portSelectors\n            });\n            this.applyPortTransform(cached.portElement, portTransformation);\n        }\n    },\n\n    /**\n     * @param {Vectorizer} element\n     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n     * @param {number=} initialAngle\n     * @constructor\n     */\n    applyPortTransform: function(element, transformData, initialAngle) {\n\n        var matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix()\n            .rotate(initialAngle || 0)\n            .translate(transformData.x || 0, transformData.y || 0)\n            .rotate(transformData.angle || 0);\n\n        element.transform(matrix, { absolute: true });\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {string}\n     * @private\n     */\n    _getPortMarkup: function(port) {\n\n        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n    },\n\n    /**\n     * @param {Object} label\n     * @returns {string}\n     * @private\n     */\n    _getPortLabelMarkup: function(label) {\n\n        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9wb3J0cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDWDtBQUNjO0FBQ0k7QUFDVTs7QUFFM0Q7O0FBRUEscUJBQXFCLHNEQUFjO0FBQ25DO0FBQ0E7QUFDQSwrQkFBK0IsbURBQUk7QUFDbkMsb0NBQW9DLHdEQUFTOztBQUU3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxvREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtREFBSztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxZQUFZLHFEQUFhO0FBQ3pCO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0RBQVk7QUFDaEMsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZUFBZSxrREFBVTtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7O0FBRUEsd0JBQXdCLG1EQUFXLEdBQUc7O0FBRXRDOztBQUVBO0FBQ0EsMEJBQTBCLGtEQUFVLEdBQUc7QUFDdkM7QUFDQSwwQkFBMEIsa0RBQVUsR0FBRztBQUN2QztBQUNBLHlCQUF5QixtREFBVyxHQUFHOztBQUV2QztBQUNBLEtBQUs7O0FBRUw7O0FBRUEsWUFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBSTtBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQUk7QUFDbEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLHlFQUF5RTtBQUN6RixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixvREFBQztBQUN0QjtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGdCQUFnQjtBQUNwRCxLQUFLOztBQUVMO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL3BvcnRzLm1qcz85MGE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgUmVjdCwgUG9pbnQgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBQb3J0IGZyb20gJy4uL2xheW91dC9wb3J0cy9wb3J0Lm1qcyc7XG5pbXBvcnQgKiBhcyBQb3J0TGFiZWwgZnJvbSAnLi4vbGF5b3V0L3BvcnRzL3BvcnRMYWJlbC5tanMnO1xuXG52YXIgUG9ydERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICB2YXIgY2xvbmVkRGF0YSA9IHV0aWwuY2xvbmVEZWVwKGRhdGEpIHx8IHt9O1xuICAgIHRoaXMucG9ydHMgPSBbXTtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMucG9ydExheW91dE5hbWVzcGFjZSA9IFBvcnQ7XG4gICAgdGhpcy5wb3J0TGFiZWxMYXlvdXROYW1lc3BhY2UgPSBQb3J0TGFiZWw7XG5cbiAgICB0aGlzLl9pbml0KGNsb25lZERhdGEpO1xufTtcblxuUG9ydERhdGEucHJvdG90eXBlID0ge1xuXG4gICAgZ2V0UG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3J0cztcbiAgICB9LFxuXG4gICAgZ2V0R3JvdXA6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzW25hbWVdIHx8IHt9O1xuICAgIH0sXG5cbiAgICBnZXRQb3J0c0J5R3JvdXA6IGZ1bmN0aW9uKGdyb3VwTmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvcnRzLmZpbHRlcihmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9ydC5ncm91cCA9PT0gZ3JvdXBOYW1lO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0R3JvdXBQb3J0c01ldHJpY3M6IGZ1bmN0aW9uKGdyb3VwTmFtZSwgZWxCQm94KSB7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5nZXRHcm91cChncm91cE5hbWUpO1xuICAgICAgICB2YXIgcG9ydHMgPSB0aGlzLmdldFBvcnRzQnlHcm91cChncm91cE5hbWUpO1xuXG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uID0gZ3JvdXAucG9zaXRpb24gfHwge307XG4gICAgICAgIHZhciBncm91cFBvc2l0aW9uTmFtZSA9IGdyb3VwUG9zaXRpb24ubmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMucG9ydExheW91dE5hbWVzcGFjZTtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2VbZ3JvdXBQb3NpdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICBncm91cFBvc2l0aW9uTmFtZSA9ICdsZWZ0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBncm91cEFyZ3MgPSBncm91cFBvc2l0aW9uLmFyZ3MgfHwge307XG4gICAgICAgIHZhciBwb3J0c0FyZ3MgPSBwb3J0cy5tYXAoZnVuY3Rpb24ocG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcnQgJiYgcG9ydC5wb3NpdGlvbiAmJiBwb3J0LnBvc2l0aW9uLmFyZ3M7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZ3JvdXBQb3J0VHJhbnNmb3JtYXRpb25zID0gbmFtZXNwYWNlW2dyb3VwUG9zaXRpb25OYW1lXShwb3J0c0FyZ3MsIGVsQkJveCwgZ3JvdXBBcmdzKTtcblxuICAgICAgICB2YXIgYWNjdW11bGF0b3IgPSB7XG4gICAgICAgICAgICBwb3J0czogcG9ydHMsXG4gICAgICAgICAgICByZXN1bHQ6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgdXRpbC50b0FycmF5KGdyb3VwUG9ydFRyYW5zZm9ybWF0aW9ucykucmVkdWNlKGZ1bmN0aW9uKHJlcywgcG9ydFRyYW5zZm9ybWF0aW9uLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHBvcnQgPSByZXMucG9ydHNbaW5kZXhdO1xuICAgICAgICAgICAgcmVzLnJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3J0SWQ6IHBvcnQuaWQsXG4gICAgICAgICAgICAgICAgcG9ydFRyYW5zZm9ybWF0aW9uOiBwb3J0VHJhbnNmb3JtYXRpb24sXG4gICAgICAgICAgICAgICAgbGFiZWxUcmFuc2Zvcm1hdGlvbjogdGhpcy5fZ2V0UG9ydExhYmVsTGF5b3V0KHBvcnQsIFBvaW50KHBvcnRUcmFuc2Zvcm1hdGlvbiksIGVsQkJveCksXG4gICAgICAgICAgICAgICAgcG9ydEF0dHJzOiBwb3J0LmF0dHJzLFxuICAgICAgICAgICAgICAgIHBvcnRTaXplOiBwb3J0LnNpemUsXG4gICAgICAgICAgICAgICAgbGFiZWxTaXplOiBwb3J0LmxhYmVsLnNpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfS5iaW5kKHRoaXMpLCBhY2N1bXVsYXRvcik7XG5cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yLnJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dldFBvcnRMYWJlbExheW91dDogZnVuY3Rpb24ocG9ydCwgcG9ydFBvc2l0aW9uLCBlbEJCb3gpIHtcblxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5wb3J0TGFiZWxMYXlvdXROYW1lc3BhY2U7XG4gICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gcG9ydC5sYWJlbC5wb3NpdGlvbi5uYW1lIHx8ICdsZWZ0JztcblxuICAgICAgICBpZiAobmFtZXNwYWNlW2xhYmVsUG9zaXRpb25dKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXNwYWNlW2xhYmVsUG9zaXRpb25dKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBwb3J0LmxhYmVsLnBvc2l0aW9uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9pbml0OiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgLy8gcHJlcGFyZSBncm91cHNcbiAgICAgICAgaWYgKHV0aWwuaXNPYmplY3QoZGF0YS5ncm91cHMpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gT2JqZWN0LmtleXMoZGF0YS5ncm91cHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3Vwc1trZXldID0gdGhpcy5fZXZhbHVhdGVHcm91cChkYXRhLmdyb3Vwc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXBhcmUgcG9ydHNcbiAgICAgICAgdmFyIHBvcnRzID0gdXRpbC50b0FycmF5KGRhdGEuaXRlbXMpO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IHBvcnRzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgdGhpcy5wb3J0cy5wdXNoKHRoaXMuX2V2YWx1YXRlUG9ydChwb3J0c1tqXSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9ldmFsdWF0ZUdyb3VwOiBmdW5jdGlvbihncm91cCkge1xuXG4gICAgICAgIHJldHVybiB1dGlsLm1lcmdlKGdyb3VwLCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5fZ2V0UG9zaXRpb24oZ3JvdXAucG9zaXRpb24sIHRydWUpLFxuICAgICAgICAgICAgbGFiZWw6IHRoaXMuX2dldExhYmVsKGdyb3VwLCB0cnVlKVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2V2YWx1YXRlUG9ydDogZnVuY3Rpb24ocG9ydCkge1xuXG4gICAgICAgIHZhciBldmFsdWF0ZWQgPSB1dGlsLmFzc2lnbih7fSwgcG9ydCk7XG5cbiAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5nZXRHcm91cChwb3J0Lmdyb3VwKTtcblxuICAgICAgICBldmFsdWF0ZWQubWFya3VwID0gZXZhbHVhdGVkLm1hcmt1cCB8fCBncm91cC5tYXJrdXA7XG4gICAgICAgIGV2YWx1YXRlZC5hdHRycyA9IHV0aWwubWVyZ2Uoe30sIGdyb3VwLmF0dHJzLCBldmFsdWF0ZWQuYXR0cnMpO1xuICAgICAgICBldmFsdWF0ZWQucG9zaXRpb24gPSB0aGlzLl9jcmVhdGVQb3NpdGlvbk5vZGUoZ3JvdXAsIGV2YWx1YXRlZCk7XG4gICAgICAgIGV2YWx1YXRlZC5sYWJlbCA9IHV0aWwubWVyZ2Uoe30sIGdyb3VwLmxhYmVsLCB0aGlzLl9nZXRMYWJlbChldmFsdWF0ZWQpKTtcbiAgICAgICAgZXZhbHVhdGVkLnogPSB0aGlzLl9nZXRaSW5kZXgoZ3JvdXAsIGV2YWx1YXRlZCk7XG4gICAgICAgIGV2YWx1YXRlZC5zaXplID0gdXRpbC5hc3NpZ24oe30sIGdyb3VwLnNpemUsIGV2YWx1YXRlZC5zaXplKTtcblxuICAgICAgICByZXR1cm4gZXZhbHVhdGVkO1xuICAgIH0sXG5cbiAgICBfZ2V0WkluZGV4OiBmdW5jdGlvbihncm91cCwgcG9ydCkge1xuXG4gICAgICAgIGlmICh1dGlsLmlzTnVtYmVyKHBvcnQueikpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3J0Lno7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwuaXNOdW1iZXIoZ3JvdXAueikgfHwgZ3JvdXAueiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2F1dG8nO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlUG9zaXRpb25Ob2RlOiBmdW5jdGlvbihncm91cCwgcG9ydCkge1xuXG4gICAgICAgIHJldHVybiB1dGlsLm1lcmdlKHtcbiAgICAgICAgICAgIG5hbWU6ICdsZWZ0JyxcbiAgICAgICAgICAgIGFyZ3M6IHt9XG4gICAgICAgIH0sIGdyb3VwLnBvc2l0aW9uLCB7IGFyZ3M6IHBvcnQuYXJncyB9KTtcbiAgICB9LFxuXG4gICAgX2dldFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbiwgc2V0RGVmYXVsdCkge1xuXG4gICAgICAgIHZhciBhcmdzID0ge307XG4gICAgICAgIHZhciBwb3NpdGlvbk5hbWU7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNGdW5jdGlvbihwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTmFtZSA9ICdmbic7XG4gICAgICAgICAgICBhcmdzLmZuID0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmluZyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTmFtZSA9IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTmFtZSA9IHNldERlZmF1bHQgPyAnbGVmdCcgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocG9zaXRpb24pKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk5hbWUgPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgYXJncy54ID0gcG9zaXRpb25bMF07XG4gICAgICAgICAgICBhcmdzLnkgPSBwb3NpdGlvblsxXTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gcG9zaXRpb24ubmFtZTtcbiAgICAgICAgICAgIHV0aWwuYXNzaWduKGFyZ3MsIHBvc2l0aW9uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgYXJnczogYXJncyB9O1xuXG4gICAgICAgIGlmIChwb3NpdGlvbk5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5uYW1lID0gcG9zaXRpb25OYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9nZXRMYWJlbDogZnVuY3Rpb24oaXRlbSwgc2V0RGVmYXVsdHMpIHtcblxuICAgICAgICB2YXIgbGFiZWwgPSBpdGVtLmxhYmVsIHx8IHt9O1xuXG4gICAgICAgIHZhciByZXQgPSBsYWJlbDtcbiAgICAgICAgcmV0LnBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb24obGFiZWwucG9zaXRpb24sIHNldERlZmF1bHRzKTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbGVtZW50UG9ydFByb3RvdHlwZSA9IHtcblxuICAgIF9pbml0aWFsaXplUG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcnREYXRhKCk7XG4gICAgICAgIHRoaXMub24oJ2NoYW5nZTpwb3J0cycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzUmVtb3ZlZFBvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVBvcnREYXRhKCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgbGlua3MgdGllZCB3aWh0IGp1c3QgcmVtb3ZlZCBlbGVtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvY2Vzc1JlbW92ZWRQb3J0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0KCdwb3J0cycpIHx8IHt9O1xuICAgICAgICB2YXIgY3VycmVudEl0ZW1zTWFwID0ge307XG5cbiAgICAgICAgdXRpbC50b0FycmF5KGN1cnJlbnQuaXRlbXMpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgY3VycmVudEl0ZW1zTWFwW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5wcmV2aW91cygncG9ydHMnKSB8fCB7fTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSB7fTtcblxuICAgICAgICB1dGlsLnRvQXJyYXkocHJldmlvdXMuaXRlbXMpLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50SXRlbXNNYXBbaXRlbS5pZF0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkW2l0ZW0uaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgICAgaWYgKGdyYXBoICYmICF1dGlsLmlzRW1wdHkocmVtb3ZlZCkpIHtcblxuICAgICAgICAgICAgdmFyIGluYm91bmRMaW5rcyA9IGdyYXBoLmdldENvbm5lY3RlZExpbmtzKHRoaXMsIHsgaW5ib3VuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGluYm91bmRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkW2xpbmsuZ2V0KCd0YXJnZXQnKS5wb3J0XSkgbGluay5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgb3V0Ym91bmRMaW5rcyA9IGdyYXBoLmdldENvbm5lY3RlZExpbmtzKHRoaXMsIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICBvdXRib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRbbGluay5nZXQoJ3NvdXJjZScpLnBvcnRdKSBsaW5rLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb3J0cyA9IHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocG9ydHMpICYmIHBvcnRzLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1BvcnQ6IGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9ydEluZGV4KGlkKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtBcnJheTxvYmplY3Q+fVxuICAgICAqL1xuICAgIGdldFBvcnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdXRpbC5jbG9uZURlZXAodGhpcy5wcm9wKCdwb3J0cy9pdGVtcycpKSB8fCBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PG9iamVjdD59XG4gICAgICovXG4gICAgZ2V0R3JvdXBQb3J0czogZnVuY3Rpb24oZ3JvdXBOYW1lKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwUG9ydHMgPSB1dGlsLnRvQXJyYXkodGhpcy5wcm9wKFsncG9ydHMnLCdpdGVtcyddKSkuZmlsdGVyKHBvcnQgPT4gcG9ydC5ncm91cCA9PT0gZ3JvdXBOYW1lKTtcbiAgICAgICAgcmV0dXJuIHV0aWwuY2xvbmVEZWVwKGdyb3VwUG9ydHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFBvcnQ6IGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHV0aWwuY2xvbmVEZWVwKHV0aWwudG9BcnJheSh0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpLmZpbmQoZnVuY3Rpb24ocG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcnQuaWQgJiYgcG9ydC5pZCA9PT0gaWQ7XG4gICAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgZ2V0UG9ydEdyb3VwTmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcG9ydFNldHRpbmdzRGF0YS5ncm91cHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lXG4gICAgICogQHJldHVybnMge09iamVjdDxwb3J0SWQsIHt4OiBudW1iZXIsIHk6IG51bWJlciwgYW5nbGU6IG51bWJlcn0+fVxuICAgICAqL1xuICAgIGdldFBvcnRzUG9zaXRpb25zOiBmdW5jdGlvbihncm91cE5hbWUpIHtcblxuICAgICAgICB2YXIgcG9ydHNNZXRyaWNzID0gdGhpcy5fcG9ydFNldHRpbmdzRGF0YS5nZXRHcm91cFBvcnRzTWV0cmljcyhncm91cE5hbWUsIFJlY3QodGhpcy5zaXplKCkpKTtcblxuICAgICAgICByZXR1cm4gcG9ydHNNZXRyaWNzLnJlZHVjZShmdW5jdGlvbihwb3NpdGlvbnMsIG1ldHJpY3MpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1hdGlvbiA9IG1ldHJpY3MucG9ydFRyYW5zZm9ybWF0aW9uO1xuICAgICAgICAgICAgcG9zaXRpb25zW21ldHJpY3MucG9ydElkXSA9IHtcbiAgICAgICAgICAgICAgICB4OiB0cmFuc2Zvcm1hdGlvbi54LFxuICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybWF0aW9uLnksXG4gICAgICAgICAgICAgICAgYW5nbGU6IHRyYW5zZm9ybWF0aW9uLmFuZ2xlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICAgICAgfSwge30pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQb3J0fSBwb3J0IHBvcnQgaWQgb3IgcG9ydFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHBvcnQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRQb3J0SW5kZXg6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICB2YXIgaWQgPSB1dGlsLmlzT2JqZWN0KHBvcnQpID8gcG9ydC5pZCA6IHBvcnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkUG9ydElkKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHV0aWwudG9BcnJheSh0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gaWQ7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9ydFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0XVxuICAgICAqIEByZXR1cm5zIHtqb2ludC5kaWEuRWxlbWVudH1cbiAgICAgKi9cbiAgICBhZGRQb3J0OiBmdW5jdGlvbihwb3J0LCBvcHQpIHtcblxuICAgICAgICBpZiAoIXV0aWwuaXNPYmplY3QocG9ydCkgfHwgQXJyYXkuaXNBcnJheShwb3J0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50OiBhZGRQb3J0IHJlcXVpcmVzIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3J0cyA9IHV0aWwuYXNzaWduKFtdLCB0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpO1xuICAgICAgICBwb3J0cy5wdXNoKHBvcnQpO1xuICAgICAgICB0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJywgcG9ydHMsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFBvcnR8bnVtYmVyfSBiZWZvcmVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcG9ydFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0XVxuICAgICAqIEByZXR1cm5zIHtqb2ludC5kaWEuRWxlbWVudH1cbiAgICAgKi9cbiAgICBpbnNlcnRQb3J0OiBmdW5jdGlvbihiZWZvcmUsIHBvcnQsIG9wdCkge1xuICAgICAgICBjb25zdCBpbmRleCA9ICh0eXBlb2YgYmVmb3JlID09PSAnbnVtYmVyJykgPyBiZWZvcmUgOiB0aGlzLmdldFBvcnRJbmRleChiZWZvcmUpO1xuXG4gICAgICAgIGlmICghdXRpbC5pc09iamVjdChwb3J0KSB8fCBBcnJheS5pc0FycmF5KHBvcnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5FbGVtZW50OiBpbnNlcnRQb3J0IHJlcXVpcmVzIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBvcnRzID0gdXRpbC5hc3NpZ24oW10sIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKSk7XG4gICAgICAgIHBvcnRzLnNwbGljZShpbmRleCwgMCwgcG9ydCk7XG4gICAgICAgIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnLCBwb3J0cywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBvcnRJZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdD19IHBhdGhcbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0XG4gICAgICogQHJldHVybnMge2pvaW50LmRpYS5FbGVtZW50fVxuICAgICAqL1xuICAgIHBvcnRQcm9wOiBmdW5jdGlvbihwb3J0SWQsIHBhdGgsIHZhbHVlLCBvcHQpIHtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldFBvcnRJbmRleChwb3J0SWQpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudDogdW5hYmxlIHRvIGZpbmQgcG9ydCB3aXRoIGlkICcgKyBwb3J0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICAgICAgYXJnc1swXSA9IFsncG9ydHMnLCAnaXRlbXMnLCBpbmRleF0uY29uY2F0KHBhdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkpIHtcblxuICAgICAgICAgICAgLy8gR2V0L3NldCBhbiBhdHRyaWJ1dGUgYnkgYSBzcGVjaWFsIHBhdGggc3ludGF4IHRoYXQgZGVsaW1pdHNcbiAgICAgICAgICAgIC8vIG5lc3RlZCBvYmplY3RzIGJ5IHRoZSBjb2xvbiBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBhcmdzWzBdID0gWydwb3J0cy9pdGVtcy8nLCBpbmRleCwgJy8nLCBwYXRoXS5qb2luKCcnKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBhcmdzID0gWydwb3J0cy9pdGVtcy8nICsgaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChwYXRoKSkge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgX3ZhbGlkYXRlUG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb3J0c0F0dHIgPSB0aGlzLmdldCgncG9ydHMnKSB8fCB7fTtcblxuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICAgICAgICBwb3J0c0F0dHIgPSBwb3J0c0F0dHIgfHwge307XG4gICAgICAgIHZhciBwb3J0cyA9IHV0aWwudG9BcnJheShwb3J0c0F0dHIuaXRlbXMpO1xuXG4gICAgICAgIHBvcnRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHAgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKCdFbGVtZW50OiBpbnZhbGlkIHBvcnQgJywgcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNWYWxpZFBvcnRJZChwLmlkKSkge1xuICAgICAgICAgICAgICAgIHAuaWQgPSB0aGlzLmdlbmVyYXRlUG9ydElkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICh1dGlsLnVuaXEocG9ydHMsICdpZCcpLmxlbmd0aCAhPT0gcG9ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goJ0VsZW1lbnQ6IGZvdW5kIGlkIGR1cGxpY2l0aWVzIGluIHBvcnRzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZXM7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlUG9ydElkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgcG9ydCBpZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2lzVmFsaWRQb3J0SWQ6IGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIGlkICE9PSBudWxsICYmIGlkICE9PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNPYmplY3QoaWQpO1xuICAgIH0sXG5cbiAgICBhZGRQb3J0czogZnVuY3Rpb24ocG9ydHMsIG9wdCkge1xuXG4gICAgICAgIGlmIChwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnLCB1dGlsLmFzc2lnbihbXSwgdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycpKS5jb25jYXQocG9ydHMpLCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVBvcnQ6IGZ1bmN0aW9uKHBvcnQsIG9wdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gb3B0IHx8IHt9O1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0UG9ydEluZGV4KHBvcnQpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0cyA9IHV0aWwuYXNzaWduKFtdLCB0aGlzLnByb3AoWydwb3J0cycsICdpdGVtcyddKSk7XG4gICAgICAgICAgICBwb3J0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgb3B0aW9ucy5yZXdyaXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncG9ydC1yZW1vdmUnKTtcbiAgICAgICAgICAgIHRoaXMucHJvcChbJ3BvcnRzJywgJ2l0ZW1zJ10sIHBvcnRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEJhdGNoKCdwb3J0LXJlbW92ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVQb3J0czogZnVuY3Rpb24ocG9ydHNGb3JSZW1vdmFsLCBvcHQpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMsIG5ld1BvcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3J0c0ZvclJlbW92YWwpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0IHx8IHt9O1xuICAgICAgICAgICAgaWYgKHBvcnRzRm9yUmVtb3ZhbC5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnRoaXM7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UG9ydHMgPSB1dGlsLmFzc2lnbihbXSwgdGhpcy5wcm9wKFsncG9ydHMnLCAnaXRlbXMnXSkpO1xuICAgICAgICAgICAgbmV3UG9ydHMgPSBjdXJyZW50UG9ydHMuZmlsdGVyKGZ1bmN0aW9uKGNwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwb3J0c0ZvclJlbW92YWwuc29tZShmdW5jdGlvbihycCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBycElkID0gdXRpbC5pc09iamVjdChycCkgPyBycC5pZCA6IHJwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3AuaWQgPT09IHJwSWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBwb3J0c0ZvclJlbW92YWwgfHwge307XG4gICAgICAgICAgICBuZXdQb3J0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncG9ydC1yZW1vdmUnKTtcbiAgICAgICAgb3B0aW9ucy5yZXdyaXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcm9wKFsncG9ydHMnLCAnaXRlbXMnXSwgbmV3UG9ydHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0b3BCYXRjaCgncG9ydC1yZW1vdmUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVBvcnREYXRhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZXJyID0gdGhpcy5fdmFsaWRhdGVQb3J0cygpO1xuXG4gICAgICAgIGlmIChlcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoJ3BvcnRzJywgdGhpcy5wcmV2aW91cygncG9ydHMnKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldlBvcnREYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9wb3J0U2V0dGluZ3NEYXRhKSB7XG5cbiAgICAgICAgICAgIHByZXZQb3J0RGF0YSA9IHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEuZ2V0UG9ydHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEgPSBuZXcgUG9ydERhdGEodGhpcy5nZXQoJ3BvcnRzJykpO1xuXG4gICAgICAgIHZhciBjdXJQb3J0RGF0YSA9IHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEuZ2V0UG9ydHMoKTtcblxuICAgICAgICBpZiAocHJldlBvcnREYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciBhZGRlZCA9IGN1clBvcnREYXRhLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2UG9ydERhdGEuZmluZChmdW5jdGlvbihwcmV2UG9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlBvcnQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gcHJldlBvcnREYXRhLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJQb3J0RGF0YS5maW5kKGZ1bmN0aW9uKGN1clBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1clBvcnQuaWQgPT09IGl0ZW0uaWQ7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BvcnRzOnJlbW92ZScsIHRoaXMsIHJlbW92ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncG9ydHM6YWRkJywgdGhpcywgYWRkZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVsZW1lbnRWaWV3UG9ydFByb3RvdHlwZSA9IHtcblxuICAgIHBvcnRDb250YWluZXJNYXJrdXA6ICdnJyxcbiAgICBwb3J0TWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdjaXJjbGUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAncic6IDEwLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyMwMDAwMDAnXG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBwb3J0TGFiZWxNYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICd0ZXh0JyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnIzAwMDAwMCdcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywge3BvcnRFbGVtZW50OiBWZWN0b3JpemVyLCBwb3J0TGFiZWxFbGVtZW50OiBWZWN0b3JpemVyfT59ICovXG4gICAgX3BvcnRFbGVtZW50c0NhY2hlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fY2xlYW5Qb3J0c0NhY2hlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFBvcnRcbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpZFxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwb3NpdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBsYWJlbFxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhdHRyc1xuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXJrdXBcbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZ3JvdXBcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZnJlc2hQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9ydHMoKTtcbiAgICAgICAgdGhpcy5fY2xlYW5Qb3J0c0NhY2hlKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclBvcnRzKCk7XG4gICAgfSxcblxuICAgIF9jbGVhblBvcnRzQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW5kZXJQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gcmVmZXJlbmNlcyB0byByZW5kZXJlZCBlbGVtZW50cyB3aXRob3V0IHotaW5kZXhcbiAgICAgICAgdmFyIGVsZW1lbnRSZWZlcmVuY2VzID0gW107XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBjb3VudCA9IGVsZW0ubm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2VzLnB1c2goZWxlbS5ub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcnRzR3JvcHNCeVogPSB1dGlsLmdyb3VwQnkodGhpcy5tb2RlbC5fcG9ydFNldHRpbmdzRGF0YS5nZXRQb3J0cygpLCAneicpO1xuICAgICAgICB2YXIgd2l0aG91dFpLZXkgPSAnYXV0byc7XG5cbiAgICAgICAgLy8gcmVuZGVyIG5vbi16IGZpcnN0XG4gICAgICAgIHV0aWwudG9BcnJheShwb3J0c0dyb3BzQnlaW3dpdGhvdXRaS2V5XSkuZm9yRWFjaChmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICB2YXIgcG9ydEVsZW1lbnQgPSB0aGlzLl9nZXRQb3J0RWxlbWVudChwb3J0KTtcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kKHBvcnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnRSZWZlcmVuY2VzLnB1c2gocG9ydEVsZW1lbnQpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgZ3JvdXBOYW1lcyA9IE9iamVjdC5rZXlzKHBvcnRzR3JvcHNCeVopO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyb3VwTmFtZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cE5hbWUgPSBncm91cE5hbWVzW2tdO1xuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZSAhPT0gd2l0aG91dFpLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHBhcnNlSW50KGdyb3VwTmFtZSwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZFBvcnRzKHBvcnRzR3JvcHNCeVpbZ3JvdXBOYW1lXSwgeiwgZWxlbWVudFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUG9ydHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1Z9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0Q29udGFpbmVyRWxlbWVudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucm90YXRhYmxlTm9kZSB8fCB0aGlzLnZlbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheTxQb3J0Pn1wb3J0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6XG4gICAgICogQHBhcmFtIHJlZnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hcHBlbmRQb3J0czogZnVuY3Rpb24ocG9ydHMsIHosIHJlZnMpIHtcblxuICAgICAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHRoaXMuX2dldENvbnRhaW5lckVsZW1lbnQoKTtcbiAgICAgICAgdmFyIHBvcnRFbGVtZW50cyA9IHV0aWwudG9BcnJheShwb3J0cykubWFwKHRoaXMuX2dldFBvcnRFbGVtZW50LCB0aGlzKTtcblxuICAgICAgICBpZiAocmVmc1t6XSB8fCB6IDwgMCkge1xuICAgICAgICAgICAgVihyZWZzW01hdGgubWF4KHosIDApXSkuYmVmb3JlKHBvcnRFbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZChwb3J0RWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyeSB0byBnZXQgZWxlbWVudCBmcm9tIGNhY2hlLFxuICAgICAqIEBwYXJhbSBwb3J0XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0UG9ydEVsZW1lbnQ6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICBpZiAodGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGVbcG9ydC5pZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0LmlkXS5wb3J0RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUG9ydEVsZW1lbnQocG9ydCk7XG4gICAgfSxcblxuICAgIGZpbmRQb3J0Tm9kZXM6IGZ1bmN0aW9uKHBvcnRJZCwgc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcG9ydENhY2hlID0gdGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGVbcG9ydElkXTtcbiAgICAgICAgaWYgKCFwb3J0Q2FjaGUpIHJldHVybiBbXTtcbiAgICAgICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIFtwb3J0Q2FjaGUucG9ydENvbnRlbnRFbGVtZW50Lm5vZGVdO1xuICAgICAgICBjb25zdCBwb3J0Um9vdCA9IHBvcnRDYWNoZS5wb3J0RWxlbWVudC5ub2RlO1xuICAgICAgICBjb25zdCBwb3J0U2VsZWN0b3JzID0gcG9ydENhY2hlLnBvcnRTZWxlY3RvcnM7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCBwb3J0Um9vdCwgcG9ydFNlbGVjdG9ycyk7XG4gICAgfSxcblxuICAgIGZpbmRQb3J0Tm9kZTogZnVuY3Rpb24ocG9ydElkLCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBbbm9kZSA9IG51bGxdID0gdGhpcy5maW5kUG9ydE5vZGVzKHBvcnRJZCwgc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlUG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGxheW91dCBwb3J0cyB3aXRob3V0IGdyb3VwXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvcnRHcm91cCh1bmRlZmluZWQpO1xuICAgICAgICAvLyBsYXlvdXQgcG9ydHMgd2l0aCBleHBsaWNpdCBncm91cFxuICAgICAgICB2YXIgZ3JvdXBzTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLl9wb3J0U2V0dGluZ3NEYXRhLmdyb3Vwcyk7XG4gICAgICAgIGdyb3Vwc05hbWVzLmZvckVhY2godGhpcy5fdXBkYXRlUG9ydEdyb3VwLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB1dGlsLmludm9rZSh0aGlzLl9wb3J0RWxlbWVudHNDYWNoZSwgJ3BvcnRFbGVtZW50LnJlbW92ZScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnRcbiAgICAgKiBAcmV0dXJucyB7Vn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jcmVhdGVQb3J0RWxlbWVudDogZnVuY3Rpb24ocG9ydCkge1xuXG4gICAgICAgIGxldCBwb3J0RWxlbWVudDtcbiAgICAgICAgbGV0IGxhYmVsRWxlbWVudDtcbiAgICAgICAgbGV0IGxhYmVsU2VsZWN0b3JzO1xuICAgICAgICBsZXQgcG9ydFNlbGVjdG9ycztcblxuICAgICAgICB2YXIgcG9ydENvbnRhaW5lckVsZW1lbnQgPSBWKHRoaXMucG9ydENvbnRhaW5lck1hcmt1cCkuYWRkQ2xhc3MoJ2pvaW50LXBvcnQnKTtcblxuICAgICAgICB2YXIgcG9ydE1hcmt1cCA9IHRoaXMuX2dldFBvcnRNYXJrdXAocG9ydCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvcnRNYXJrdXApKSB7XG4gICAgICAgICAgICB2YXIgcG9ydERvYyA9IHRoaXMucGFyc2VET01KU09OKHBvcnRNYXJrdXAsIHBvcnRDb250YWluZXJFbGVtZW50Lm5vZGUpO1xuICAgICAgICAgICAgdmFyIHBvcnRGcmFnbWVudCA9IHBvcnREb2MuZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAocG9ydEZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHBvcnRFbGVtZW50ID0gVignZycpLmFwcGVuZChwb3J0RnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3J0RWxlbWVudCA9IFYocG9ydEZyYWdtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9ydFNlbGVjdG9ycyA9IHBvcnREb2Muc2VsZWN0b3JzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydEVsZW1lbnQgPSBWKHBvcnRNYXJrdXApO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9ydEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcG9ydEVsZW1lbnQgPSBWKCdnJykuYXBwZW5kKHBvcnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcG9ydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudFZpZXc6IEludmFsaWQgcG9ydCBtYXJrdXAuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwb3J0RWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAgICdwb3J0JzogcG9ydC5pZCxcbiAgICAgICAgICAgICdwb3J0LWdyb3VwJzogcG9ydC5ncm91cFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiB0aGUgcG9ydCBJRCBpcyBhIG51bWJlciwgd2UgbmVlZCB0byBhZGRcbiAgICAgICAgLy8gZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIHBvcnQgZWxlbWVudCB0byBkaXN0aW5ndWlzaFxuICAgICAgICAvLyBiZXR3ZWVuIHBvcnRzIHdpdGggdGhlIHNhbWUgSUQgYnV0IGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgaWYgKHV0aWwuaXNOdW1iZXIocG9ydC5pZCkpIHtcbiAgICAgICAgICAgIHBvcnRFbGVtZW50LmF0dHIoJ3BvcnQtaWQtdHlwZScsICdudW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhYmVsTWFya3VwRGVmID0gdGhpcy5fZ2V0UG9ydExhYmVsTWFya3VwKHBvcnQubGFiZWwpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYWJlbE1hcmt1cERlZikpIHtcbiAgICAgICAgICAgIC8vIEpTT04gTWFya3VwXG4gICAgICAgICAgICBjb25zdCB7IGZyYWdtZW50LCBzZWxlY3RvcnMgfSA9IHRoaXMucGFyc2VET01KU09OKGxhYmVsTWFya3VwRGVmLCBwb3J0Q29udGFpbmVyRWxlbWVudC5ub2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjaGlsZENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGxhYmVsU2VsZWN0b3JzID0gc2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgIGxhYmVsRWxlbWVudCA9IChjaGlsZENvdW50ID09PSAxKSA/IFYoZnJhZ21lbnQuZmlyc3RDaGlsZCkgOiBWKCdnJykuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFN0cmluZyBNYXJrdXBcbiAgICAgICAgICAgIGxhYmVsRWxlbWVudCA9IFYobGFiZWxNYXJrdXBEZWYpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFiZWxFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGxhYmVsRWxlbWVudCA9IFYoJ2cnKS5hcHBlbmQobGFiZWxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3J0Q29udGFpbmVyU2VsZWN0b3JzO1xuICAgICAgICBpZiAocG9ydFNlbGVjdG9ycyAmJiBsYWJlbFNlbGVjdG9ycykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGxhYmVsU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcnRTZWxlY3RvcnNba2V5XSAmJiBrZXkgIT09IHRoaXMuc2VsZWN0b3IpIHRocm93IG5ldyBFcnJvcignRWxlbWVudFZpZXc6IHNlbGVjdG9ycyB3aXRoaW4gcG9ydCBtdXN0IGJlIHVuaXF1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcnRDb250YWluZXJTZWxlY3RvcnMgPSB1dGlsLmFzc2lnbih7fSwgcG9ydFNlbGVjdG9ycywgbGFiZWxTZWxlY3RvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9ydENvbnRhaW5lclNlbGVjdG9ycyA9IHBvcnRTZWxlY3RvcnMgfHwgbGFiZWxTZWxlY3RvcnMgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgYHBvcnRSb290U2VsZWN0b3JgIHBvaW50cyB0byB0aGUgcm9vdCBTVkdOb2RlIG9mIHRoZSBwb3J0LlxuICAgICAgICAvLyBFaXRoZXIgdGhlIGltcGxpY2l0IHdyYXBwaW5nIGdyb3VwIDxnLz4gaW4gY2FzZSB0aGUgcG9ydCBjb25zaXN0IG9mIG11bHRpcGxlIFNWR05vZGVzLlxuICAgICAgICAvLyBPciB0aGUgc2luZ2xlIFNWR05vZGUgb2YgdGhlIHBvcnQuXG4gICAgICAgIGNvbnN0IHBvcnRSb290U2VsZWN0b3IgPSAncG9ydFJvb3QnO1xuICAgICAgICAvLyBUaGUgYGxhYmVsUm9vdFNlbGVjdG9yYCBwb2ludHMgdG8gdGhlIHJvb3QgU1ZHTm9kZSBvZiB0aGUgbGFiZWwuXG4gICAgICAgIGNvbnN0IGxhYmVsUm9vdFNlbGVjdG9yID0gJ2xhYmVsUm9vdCc7XG4gICAgICAgIC8vIFRoZSBgbGFiZWxUZXh0U2VsZWN0b3JgIHBvaW50cyB0byBhbGwgdGV4dCBTVkdOb2RlcyBvZiB0aGUgbGFiZWwuXG4gICAgICAgIGNvbnN0IGxhYmVsVGV4dFNlbGVjdG9yID0gJ2xhYmVsVGV4dCc7XG5cbiAgICAgICAgaWYgKCEocG9ydFJvb3RTZWxlY3RvciBpbiBwb3J0Q29udGFpbmVyU2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgcG9ydENvbnRhaW5lclNlbGVjdG9yc1twb3J0Um9vdFNlbGVjdG9yXSA9IHBvcnRFbGVtZW50Lm5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFiZWxFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbE5vZGUgPSBsYWJlbEVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgIGlmICghKGxhYmVsUm9vdFNlbGVjdG9yIGluIHBvcnRDb250YWluZXJTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgcG9ydENvbnRhaW5lclNlbGVjdG9yc1tsYWJlbFJvb3RTZWxlY3Rvcl0gPSBsYWJlbE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShsYWJlbFRleHRTZWxlY3RvciBpbiBwb3J0Q29udGFpbmVyU2VsZWN0b3JzKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYWJlbCBpcyBhIDx0ZXh0PiBlbGVtZW50LCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBmaW5kIHRoZSA8dGV4dD4gZWxlbWVudCB3aXRoaW4gdGhlIGxhYmVsLlxuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dE5vZGUgPSAobGFiZWxFbGVtZW50LnRhZ05hbWUoKSA9PT0gJ1RFWFQnKVxuICAgICAgICAgICAgICAgICAgICA/IGxhYmVsTm9kZVxuICAgICAgICAgICAgICAgICAgICA6IEFycmF5LmZyb20obGFiZWxOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHQnKSk7XG4gICAgICAgICAgICAgICAgcG9ydENvbnRhaW5lclNlbGVjdG9yc1tsYWJlbFRleHRTZWxlY3Rvcl0gPSBsYWJlbFRleHROb2RlO1xuICAgICAgICAgICAgICAgIGlmICghbGFiZWxTZWxlY3RvcnMpIGxhYmVsU2VsZWN0b3JzID0ge307XG4gICAgICAgICAgICAgICAgbGFiZWxTZWxlY3RvcnNbbGFiZWxUZXh0U2VsZWN0b3JdID0gbGFiZWxUZXh0Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcnRDb250YWluZXJFbGVtZW50LmFwcGVuZChwb3J0RWxlbWVudC5hZGRDbGFzcygnam9pbnQtcG9ydC1ib2R5JykpO1xuICAgICAgICBpZiAobGFiZWxFbGVtZW50KSB7XG4gICAgICAgICAgICBwb3J0Q29udGFpbmVyRWxlbWVudC5hcHBlbmQobGFiZWxFbGVtZW50LmFkZENsYXNzKCdqb2ludC1wb3J0LWxhYmVsJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGVbcG9ydC5pZF0gPSB7XG4gICAgICAgICAgICBwb3J0RWxlbWVudDogcG9ydENvbnRhaW5lckVsZW1lbnQsXG4gICAgICAgICAgICBwb3J0TGFiZWxFbGVtZW50OiBsYWJlbEVsZW1lbnQsXG4gICAgICAgICAgICBwb3J0U2VsZWN0b3JzOiBwb3J0Q29udGFpbmVyU2VsZWN0b3JzLFxuICAgICAgICAgICAgcG9ydExhYmVsU2VsZWN0b3JzOiBsYWJlbFNlbGVjdG9ycyxcbiAgICAgICAgICAgIHBvcnRDb250ZW50RWxlbWVudDogcG9ydEVsZW1lbnQsXG4gICAgICAgICAgICBwb3J0Q29udGVudFNlbGVjdG9yczogcG9ydFNlbGVjdG9yc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwb3J0Q29udGFpbmVyRWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBncm91cE5hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVQb3J0R3JvdXA6IGZ1bmN0aW9uKGdyb3VwTmFtZSkge1xuXG4gICAgICAgIHZhciBlbGVtZW50QkJveCA9IFJlY3QodGhpcy5tb2RlbC5zaXplKCkpO1xuICAgICAgICB2YXIgcG9ydHNNZXRyaWNzID0gdGhpcy5tb2RlbC5fcG9ydFNldHRpbmdzRGF0YS5nZXRHcm91cFBvcnRzTWV0cmljcyhncm91cE5hbWUsIGVsZW1lbnRCQm94KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvcnRzTWV0cmljcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRyaWNzID0gcG9ydHNNZXRyaWNzW2ldO1xuICAgICAgICAgICAgdmFyIHBvcnRJZCA9IG1ldHJpY3MucG9ydElkO1xuICAgICAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMuX3BvcnRFbGVtZW50c0NhY2hlW3BvcnRJZF0gfHwge307XG4gICAgICAgICAgICB2YXIgcG9ydFRyYW5zZm9ybWF0aW9uID0gbWV0cmljcy5wb3J0VHJhbnNmb3JtYXRpb247XG4gICAgICAgICAgICB2YXIgbGFiZWxUcmFuc2Zvcm1hdGlvbiA9IG1ldHJpY3MubGFiZWxUcmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgICAgIGlmIChsYWJlbFRyYW5zZm9ybWF0aW9uICYmIGNhY2hlZC5wb3J0TGFiZWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVET01TdWJ0cmVlQXR0cmlidXRlcyhjYWNoZWQucG9ydExhYmVsRWxlbWVudC5ub2RlLCBsYWJlbFRyYW5zZm9ybWF0aW9uLmF0dHJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RCQm94OiBuZXcgUmVjdChtZXRyaWNzLmxhYmVsU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczogY2FjaGVkLnBvcnRMYWJlbFNlbGVjdG9yc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlQb3J0VHJhbnNmb3JtKGNhY2hlZC5wb3J0TGFiZWxFbGVtZW50LCBsYWJlbFRyYW5zZm9ybWF0aW9uLCAoLXBvcnRUcmFuc2Zvcm1hdGlvbi5hbmdsZSB8fCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKGNhY2hlZC5wb3J0RWxlbWVudC5ub2RlLCBtZXRyaWNzLnBvcnRBdHRycywge1xuICAgICAgICAgICAgICAgIHJvb3RCQm94OiBuZXcgUmVjdChtZXRyaWNzLnBvcnRTaXplKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IGNhY2hlZC5wb3J0U2VsZWN0b3JzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlQb3J0VHJhbnNmb3JtKGNhY2hlZC5wb3J0RWxlbWVudCwgcG9ydFRyYW5zZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1ZlY3Rvcml6ZXJ9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3tkeDpudW1iZXIsIGR5Om51bWJlciwgYW5nbGU6IG51bWJlciwgYXR0cnM6IE9iamVjdCwgeDpudW1iZXI6IHk6bnVtYmVyfX0gdHJhbnNmb3JtRGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gaW5pdGlhbEFuZ2xlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgYXBwbHlQb3J0VHJhbnNmb3JtOiBmdW5jdGlvbihlbGVtZW50LCB0cmFuc2Zvcm1EYXRhLCBpbml0aWFsQW5nbGUpIHtcblxuICAgICAgICB2YXIgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKVxuICAgICAgICAgICAgLnJvdGF0ZShpbml0aWFsQW5nbGUgfHwgMClcbiAgICAgICAgICAgIC50cmFuc2xhdGUodHJhbnNmb3JtRGF0YS54IHx8IDAsIHRyYW5zZm9ybURhdGEueSB8fCAwKVxuICAgICAgICAgICAgLnJvdGF0ZSh0cmFuc2Zvcm1EYXRhLmFuZ2xlIHx8IDApO1xuXG4gICAgICAgIGVsZW1lbnQudHJhbnNmb3JtKG1hdHJpeCwgeyBhYnNvbHV0ZTogdHJ1ZSB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtQb3J0fSBwb3J0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRQb3J0TWFya3VwOiBmdW5jdGlvbihwb3J0KSB7XG5cbiAgICAgICAgcmV0dXJuIHBvcnQubWFya3VwIHx8IHRoaXMubW9kZWwuZ2V0KCdwb3J0TWFya3VwJykgfHwgdGhpcy5tb2RlbC5wb3J0TWFya3VwIHx8IHRoaXMucG9ydE1hcmt1cDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxhYmVsXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRQb3J0TGFiZWxNYXJrdXA6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cbiAgICAgICAgcmV0dXJuIGxhYmVsLm1hcmt1cCB8fCB0aGlzLm1vZGVsLmdldCgncG9ydExhYmVsTWFya3VwJykgfHwgdGhpcy5tb2RlbC5wb3J0TGFiZWxNYXJrdXAgfHwgdGhpcy5wb3J0TGFiZWxNYXJrdXA7XG4gICAgfVxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/dia/ports.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/elementTools/HoverConnect.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@joint/core/src/elementTools/HoverConnect.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HoverConnect: () => (/* binding */ HoverConnect)\n/* harmony export */ });\n/* harmony import */ var _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cellTools/HoverConnect.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _util_calc_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/calc.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cellTools/helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\n\nconst HoverConnect = _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__.HoverConnect.extend({\n\n    getTrackPath() {\n        const { relatedView: view, options } = this;\n        let {\n            useModelGeometry,\n            trackPath =  'M 0 0 H calc(w) V calc(h) H 0 Z'\n        } = options;\n        if (typeof trackPath === 'function') {\n            trackPath = trackPath.call(this, view);\n        }\n        if ((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_1__.isCalcExpression)(trackPath)) {\n            const bbox = (0,_cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getViewBBox)(view, useModelGeometry);\n            trackPath = (0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_1__.evalCalcExpression)(trackPath, bbox);\n        }\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].normalizePathData(trackPath));\n    },\n\n    getTrackMatrix() {\n        const { relatedView: view, options } = this;\n        let { useModelGeometry, rotate } = options;\n        let bbox = (0,_cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getViewBBox)(view, useModelGeometry);\n        const angle = view.model.angle();\n        if (!rotate) bbox = bbox.bbox(angle);\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n        if (rotate) matrix = matrix.rotate(angle);\n        matrix = matrix.translate(- bbox.width / 2, - bbox.height / 2);\n        return matrix;\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2VsZW1lbnRUb29scy9Ib3ZlckNvbm5lY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFpRjtBQUNsRDtBQUNLO0FBQ29DO0FBQ2pCOztBQUVoRCxxQkFBcUIscUVBQWdCOztBQUU1QztBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0VBQWdCO0FBQzVCLHlCQUF5QixtRUFBVztBQUNwQyx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0EsbUJBQW1CLDhDQUFNLENBQUMsb0RBQUM7QUFDM0IsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsY0FBYywyQkFBMkI7QUFDekMsbUJBQW1CLG1FQUFXO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2VsZW1lbnRUb29scy9Ib3ZlckNvbm5lY3QubWpzPzBlNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSG92ZXJDb25uZWN0IGFzIExpbmtIb3ZlckNvbm5lY3QgfSBmcm9tICcuLi9jZWxsVG9vbHMvSG92ZXJDb25uZWN0Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzQ2FsY0V4cHJlc3Npb24sIGV2YWxDYWxjRXhwcmVzc2lvbiB9IGZyb20gJy4uL3V0aWwvY2FsYy5tanMnO1xuaW1wb3J0IHsgZ2V0Vmlld0JCb3ggfSBmcm9tICcuLi9jZWxsVG9vbHMvaGVscGVycy5tanMnO1xuXG5leHBvcnQgY29uc3QgSG92ZXJDb25uZWN0ID0gTGlua0hvdmVyQ29ubmVjdC5leHRlbmQoe1xuXG4gICAgZ2V0VHJhY2tQYXRoKCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3OiB2aWV3LCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQge1xuICAgICAgICAgICAgdXNlTW9kZWxHZW9tZXRyeSxcbiAgICAgICAgICAgIHRyYWNrUGF0aCA9ICAnTSAwIDAgSCBjYWxjKHcpIFYgY2FsYyhoKSBIIDAgWidcbiAgICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhY2tQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cmFja1BhdGggPSB0cmFja1BhdGguY2FsbCh0aGlzLCB2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxjRXhwcmVzc2lvbih0cmFja1BhdGgpKSB7XG4gICAgICAgICAgICBjb25zdCBiYm94ID0gZ2V0Vmlld0JCb3godmlldywgdXNlTW9kZWxHZW9tZXRyeSk7XG4gICAgICAgICAgICB0cmFja1BhdGggPSBldmFsQ2FsY0V4cHJlc3Npb24odHJhY2tQYXRoLCBiYm94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGcuUGF0aChWLm5vcm1hbGl6ZVBhdGhEYXRhKHRyYWNrUGF0aCkpO1xuICAgIH0sXG5cbiAgICBnZXRUcmFja01hdHJpeCgpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldzogdmlldywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdXNlTW9kZWxHZW9tZXRyeSwgcm90YXRlIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgYmJveCA9IGdldFZpZXdCQm94KHZpZXcsIHVzZU1vZGVsR2VvbWV0cnkpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IHZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKCFyb3RhdGUpIGJib3ggPSBiYm94LmJib3goYW5nbGUpO1xuICAgICAgICBsZXQgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKS50cmFuc2xhdGUoYmJveC54ICsgYmJveC53aWR0aCAvIDIsIGJib3gueSArIGJib3guaGVpZ2h0IC8gMik7XG4gICAgICAgIGlmIChyb3RhdGUpIG1hdHJpeCA9IG1hdHJpeC5yb3RhdGUoYW5nbGUpO1xuICAgICAgICBtYXRyaXggPSBtYXRyaXgudHJhbnNsYXRlKC0gYmJveC53aWR0aCAvIDIsIC0gYmJveC5oZWlnaHQgLyAyKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/elementTools/HoverConnect.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/elementTools/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/elementTools/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Boundary: () => (/* reexport safe */ _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_3__.Boundary),\n/* harmony export */   Button: () => (/* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_1__.Button),\n/* harmony export */   Connect: () => (/* reexport safe */ _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_2__.Connect),\n/* harmony export */   Control: () => (/* reexport safe */ _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_4__.Control),\n/* harmony export */   HoverConnect: () => (/* reexport safe */ _HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__.HoverConnect),\n/* harmony export */   Remove: () => (/* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_1__.Remove)\n/* harmony export */ });\n/* harmony import */ var _HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HoverConnect.mjs */ \"(ssr)/./node_modules/@joint/core/src/elementTools/HoverConnect.mjs\");\n/* harmony import */ var _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cellTools/Button.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Button.mjs\");\n/* harmony import */ var _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cellTools/Connect.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Connect.mjs\");\n/* harmony import */ var _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cellTools/Boundary.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Boundary.mjs\");\n/* harmony import */ var _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cellTools/Control.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Control.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2VsZW1lbnRUb29scy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBa0Q7O0FBRU87QUFDTjtBQUNFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9lbGVtZW50VG9vbHMvaW5kZXgubWpzP2JlZmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgSG92ZXJDb25uZWN0IH0gZnJvbSAnLi9Ib3ZlckNvbm5lY3QubWpzJztcblxuZXhwb3J0IHsgQnV0dG9uLCBSZW1vdmUgfSBmcm9tICcuLi9jZWxsVG9vbHMvQnV0dG9uLm1qcyc7XG5leHBvcnQgeyBDb25uZWN0IH0gZnJvbSAnLi4vY2VsbFRvb2xzL0Nvbm5lY3QubWpzJztcbmV4cG9ydCB7IEJvdW5kYXJ5IH0gZnJvbSAnLi4vY2VsbFRvb2xzL0JvdW5kYXJ5Lm1qcyc7XG5leHBvcnQgeyBDb250cm9sIH0gZnJvbSAnLi4vY2VsbFRvb2xzL0NvbnRyb2wubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/elementTools/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/env/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/env/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: () => (/* binding */ env)\n/* harmony export */ });\nconst env = {\n\n    _results: {},\n\n    _tests: {\n\n        svgforeignobject: function() {\n            return !!document.createElementNS &&\n                /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n        },\n\n        // works for iOS browsers too\n        isSafari: function() {\n            return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);\n        }\n    },\n\n    addTest: function(name, fn) {\n\n        return this._tests[name] = fn;\n    },\n\n    test: function(name) {\n\n        var fn = this._tests[name];\n\n        if (!fn) {\n            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n        }\n\n        var result = this._results[name];\n\n        if (typeof result !== 'undefined') {\n            return result;\n        }\n\n        try {\n            result = fn();\n        } catch (error) {\n            result = false;\n        }\n\n        // Cache the test result.\n        this._results[name] = result;\n\n        return result;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Vudi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPOztBQUVQLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9lbnYvaW5kZXgubWpzPzU1OTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGVudiA9IHtcblxuICAgIF9yZXN1bHRzOiB7fSxcblxuICAgIF90ZXN0czoge1xuXG4gICAgICAgIHN2Z2ZvcmVpZ25vYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TICYmXG4gICAgICAgICAgICAgICAgL1NWR0ZvcmVpZ25PYmplY3QvLnRlc3QoKHt9KS50b1N0cmluZy5jYWxsKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnZm9yZWlnbk9iamVjdCcpKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gd29ya3MgZm9yIGlPUyBicm93c2VycyB0b29cbiAgICAgICAgaXNTYWZhcmk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFRlc3Q6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3RzW25hbWVdID0gZm47XG4gICAgfSxcblxuICAgIHRlc3Q6IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICB2YXIgZm4gPSB0aGlzLl90ZXN0c1tuYW1lXTtcblxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgbm90IGRlZmluZWQgKFwiJyArIG5hbWUgKyAnXCIpLiBVc2UgYGpvaW50LmVudi5hZGRUZXN0KG5hbWUsIGZuKSB0byBhZGQgYSBuZXcgdGVzdC5gJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcmVzdWx0c1tuYW1lXTtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIHRlc3QgcmVzdWx0LlxuICAgICAgICB0aGlzLl9yZXN1bHRzW25hbWVdID0gcmVzdWx0O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/env/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/bezier.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/g/bezier.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezier: () => (/* binding */ bezier)\n/* harmony export */ });\n/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\n\n\nconst bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new _path_mjs__WEBPACK_IMPORTED_MODULE_0__.Path(_curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvYmV6aWVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ0U7QUFDQTs7QUFFN0I7O0FBRVA7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTs7QUFFQSxtQkFBbUIsMkNBQUksQ0FBQyw2Q0FBSztBQUM3QixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkNBQUs7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLDZDQUFLO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdDQUF3Qyw2Q0FBSzs7QUFFN0M7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBSztBQUNsRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLDZDQUE2Qyw2Q0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLDZDQUFLOztBQUU3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3Qiw2Q0FBSzs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL2Jlemllci5tanM/NDhjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRoIH0gZnJvbSAnLi9wYXRoLm1qcyc7XG5pbXBvcnQgeyBDdXJ2ZSB9IGZyb20gJy4vY3VydmUubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuXG5leHBvcnQgY29uc3QgYmV6aWVyID0ge1xuXG4gICAgLy8gQ3ViaWMgQmV6aWVyIGN1cnZlIHBhdGggdGhyb3VnaCBwb2ludHMuXG4gICAgLy8gQGRlcHJlY2F0ZWRcbiAgICAvLyBAcGFyYW0ge2FycmF5fSBwb2ludHMgQXJyYXkgb2YgcG9pbnRzIHRocm91Z2ggd2hpY2ggdGhlIHNtb290aCBsaW5lIHdpbGwgZ28uXG4gICAgLy8gQHJldHVybiB7YXJyYXl9IFNWRyBQYXRoIGNvbW1hbmRzIGFzIGFuIGFycmF5XG4gICAgY3VydmVUaHJvdWdoUG9pbnRzOiBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQnKTtcblxuICAgICAgICByZXR1cm4gbmV3IFBhdGgoQ3VydmUudGhyb3VnaFBvaW50cyhwb2ludHMpKS5zZXJpYWxpemUoKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IG9wZW4tZW5kZWQgQmV6aWVyIFNwbGluZSBDb250cm9sIFBvaW50cy5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSBrbm90cyBJbnB1dCBLbm90IEJlemllciBzcGxpbmUgcG9pbnRzIChBdCBsZWFzdCB0d28gcG9pbnRzISkuXG4gICAgLy8gQHBhcmFtIGZpcnN0Q29udHJvbFBvaW50cyBPdXRwdXQgRmlyc3QgQ29udHJvbCBwb2ludHMuIEFycmF5IG9mIGtub3RzLmxlbmd0aCAtIDEgbGVuZ3RoLlxuICAgIC8vIEBwYXJhbSBzZWNvbmRDb250cm9sUG9pbnRzIE91dHB1dCBTZWNvbmQgQ29udHJvbCBwb2ludHMuIEFycmF5IG9mIGtub3RzLmxlbmd0aCAtIDEgbGVuZ3RoLlxuICAgIGdldEN1cnZlQ29udHJvbFBvaW50czogZnVuY3Rpb24oa25vdHMpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQnKTtcblxuICAgICAgICB2YXIgZmlyc3RDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzZWNvbmRDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHZhciBuID0ga25vdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBCZXppZXIgY3VydmUgc2hvdWxkIGJlIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgLy8gM1AxID0gMlAwICsgUDNcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAoMiAqIGtub3RzWzBdLnggKyBrbm90c1sxXS54KSAvIDMsXG4gICAgICAgICAgICAgICAgKDIgKiBrbm90c1swXS55ICsga25vdHNbMV0ueSkgLyAzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBQMiA9IDJQMSDigJMgUDBcbiAgICAgICAgICAgIHNlY29uZENvbnRyb2xQb2ludHNbMF0gPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgMiAqIGZpcnN0Q29udHJvbFBvaW50c1swXS54IC0ga25vdHNbMF0ueCxcbiAgICAgICAgICAgICAgICAyICogZmlyc3RDb250cm9sUG9pbnRzWzBdLnkgLSBrbm90c1swXS55XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gW2ZpcnN0Q29udHJvbFBvaW50cywgc2Vjb25kQ29udHJvbFBvaW50c107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgZmlyc3QgQmV6aWVyIGNvbnRyb2wgcG9pbnRzLlxuICAgICAgICAvLyBSaWdodCBoYW5kIHNpZGUgdmVjdG9yLlxuICAgICAgICB2YXIgcmhzID0gW107XG5cbiAgICAgICAgLy8gU2V0IHJpZ2h0IGhhbmQgc2lkZSBYIHZhbHVlcy5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS54ICsgMiAqIGtub3RzW2kgKyAxXS54O1xuICAgICAgICB9XG5cbiAgICAgICAgcmhzWzBdID0ga25vdHNbMF0ueCArIDIgKiBrbm90c1sxXS54O1xuICAgICAgICByaHNbbiAtIDFdID0gKDggKiBrbm90c1tuIC0gMV0ueCArIGtub3RzW25dLngpIC8gMi4wO1xuXG4gICAgICAgIC8vIEdldCBmaXJzdCBjb250cm9sIHBvaW50cyBYLXZhbHVlcy5cbiAgICAgICAgdmFyIHggPSB0aGlzLmdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG4gICAgICAgIC8vIFNldCByaWdodCBoYW5kIHNpZGUgWSB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICByaHNbaV0gPSA0ICoga25vdHNbaV0ueSArIDIgKiBrbm90c1tpICsgMV0ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJoc1swXSA9IGtub3RzWzBdLnkgKyAyICoga25vdHNbMV0ueTtcbiAgICAgICAgcmhzW24gLSAxXSA9ICg4ICoga25vdHNbbiAtIDFdLnkgKyBrbm90c1tuXS55KSAvIDIuMDtcblxuICAgICAgICAvLyBHZXQgZmlyc3QgY29udHJvbCBwb2ludHMgWS12YWx1ZXMuXG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuICAgICAgICAvLyBGaWxsIG91dHB1dCBhcnJheXMuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gICAgICAgICAgICBmaXJzdENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoeFtpXSwgeVtpXSkpO1xuXG4gICAgICAgICAgICAvLyBTZWNvbmQgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAgIGlmIChpIDwgbiAtIDEpIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAyICoga25vdHMgW2kgKyAxXS54IC0geFtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgIDIgKiBrbm90c1tpICsgMV0ueSAtIHlbaSArIDFdXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kQ29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgKGtub3RzW25dLnggKyB4W24gLSAxXSkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0ueSArIHlbbiAtIDFdKSAvIDIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbZmlyc3RDb250cm9sUG9pbnRzLCBzZWNvbmRDb250cm9sUG9pbnRzXTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlIGEgQmV6aWVyIGN1cnZlIGludG8gdHdvIGF0IHBvaW50IGRlZmluZWQgYnkgdmFsdWUgJ3QnIDwwLDE+LlxuICAgIC8vIFVzaW5nIGRlQ2FzdGVsamF1IGFsZ29yaXRobS4gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8zMTc4NjdcbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSBjb250cm9sIHBvaW50cyAoc3RhcnQsIGNvbnRyb2wgc3RhcnQsIGNvbnRyb2wgZW5kLCBlbmQpXG4gICAgLy8gQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0IGFuZCByZXR1cm5zIDIgY3VydmVzLlxuICAgIGdldEN1cnZlRGl2aWRlcjogZnVuY3Rpb24ocDAsIHAxLCBwMiwgcDMpIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ2RlcHJlY2F0ZWQnKTtcblxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgQ3VydmUocDAsIHAxLCBwMiwgcDMpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBkaXZpZGVDdXJ2ZSh0KSB7XG5cbiAgICAgICAgICAgIHZhciBkaXZpZGVkID0gY3VydmUuZGl2aWRlKHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICBwMDogZGl2aWRlZFswXS5zdGFydCxcbiAgICAgICAgICAgICAgICBwMTogZGl2aWRlZFswXS5jb250cm9sUG9pbnQxLFxuICAgICAgICAgICAgICAgIHAyOiBkaXZpZGVkWzBdLmNvbnRyb2xQb2ludDIsXG4gICAgICAgICAgICAgICAgcDM6IGRpdmlkZWRbMF0uZW5kXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcDA6IGRpdmlkZWRbMV0uc3RhcnQsXG4gICAgICAgICAgICAgICAgcDE6IGRpdmlkZWRbMV0uY29udHJvbFBvaW50MSxcbiAgICAgICAgICAgICAgICBwMjogZGl2aWRlZFsxXS5jb250cm9sUG9pbnQyLFxuICAgICAgICAgICAgICAgIHAzOiBkaXZpZGVkWzFdLmVuZFxuICAgICAgICAgICAgfV07XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIFNvbHZlcyBhIHRyaWRpYWdvbmFsIHN5c3RlbSBmb3Igb25lIG9mIGNvb3JkaW5hdGVzICh4IG9yIHkpIG9mIGZpcnN0IEJlemllciBjb250cm9sIHBvaW50cy5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSByaHMgUmlnaHQgaGFuZCBzaWRlIHZlY3Rvci5cbiAgICAvLyBAcmV0dXJuIFNvbHV0aW9uIHZlY3Rvci5cbiAgICBnZXRGaXJzdENvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKHJocykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHZhciBuID0gcmhzLmxlbmd0aDtcbiAgICAgICAgLy8gYHhgIGlzIGEgc29sdXRpb24gdmVjdG9yLlxuICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICB2YXIgdG1wID0gW107XG4gICAgICAgIHZhciBiID0gMi4wO1xuXG4gICAgICAgIHhbMF0gPSByaHNbMF0gLyBiO1xuXG4gICAgICAgIC8vIERlY29tcG9zaXRpb24gYW5kIGZvcndhcmQgc3Vic3RpdHV0aW9uLlxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gMSAvIGI7XG4gICAgICAgICAgICBiID0gKGkgPCBuIC0gMSA/IDQuMCA6IDMuNSkgLSB0bXBbaV07XG4gICAgICAgICAgICB4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBCYWNrc3Vic3RpdHV0aW9uLlxuICAgICAgICAgICAgeFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICAvLyBTb2x2ZXMgYW4gaW52ZXJzaW9uIHByb2JsZW0gLS0gR2l2ZW4gdGhlICh4LCB5KSBjb29yZGluYXRlcyBvZiBhIHBvaW50IHdoaWNoIGxpZXMgb25cbiAgICAvLyBhIHBhcmFtZXRyaWMgY3VydmUgeCA9IHgodCkvdyh0KSwgeSA9IHkodCkvdyh0KSwg76yBbmQgdGhlIHBhcmFtZXRlciB2YWx1ZSB0XG4gICAgLy8gd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhhdCBwb2ludC5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSBjb250cm9sIHBvaW50cyAoc3RhcnQsIGNvbnRyb2wgc3RhcnQsIGNvbnRyb2wgZW5kLCBlbmQpXG4gICAgLy8gQHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHBvaW50IGFuZCByZXR1cm5zIHQuXG4gICAgZ2V0SW52ZXJzaW9uU29sdmVyOiBmdW5jdGlvbihwMCwgcDEsIHAyLCBwMykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZShwMCwgcDEsIHAyLCBwMyk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNvbHZlSW52ZXJzaW9uKHApIHtcblxuICAgICAgICAgICAgcmV0dXJuIGN1cnZlLmNsb3Nlc3RQb2ludFQocCk7XG4gICAgICAgIH07XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/bezier.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/curve.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/curve.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Curve: () => (/* binding */ Curve)\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\n\nconst {\n    abs,\n    sqrt,\n    min,\n    max,\n    pow\n} = Math;\n\nconst Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1);\n    this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2);\n    this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p3);\n    this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Curve,\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(start, control1)).pointAt(t);\n        var midpoint2 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        var subdivisions = [new Curve(start, control1, control2, end)];\n        if (precision === 0) return subdivisions;\n\n        // special case #1: point-like curves\n        // - no need to calculate subdivisions, they would all be identical\n        var isPoint = !this.isDifferentiable();\n        if (isPoint) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // - (i.e. cubic curves cannot intersect the baseline more than once)\n        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n        // - (unless it's a straight-line curve, see below)\n        var minIterations = 2; // = 2*1\n\n        // special case #3: straight-line curves have the same observed length in all iterations\n        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n        // - we enforce the expected number of iterations = 2 * precision\n        var isLine = ((control1.cross(start, end) === 0) && (control2.cross(start, end) === 0));\n        if (isLine) {\n            minIterations = (2 * precision);\n        }\n\n        // recursively divide curve at `t = 0.5`\n        // until we reach `minIterations`\n        // and until the difference between observed length at subsequent iterations is lower than `precision`\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached minimum number of iterations\n            if (iteration >= minIterations) {\n\n                // check if we have reached required observed precision\n                var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n                if (observedPrecisionRatio < precisionRatio) {\n                    return newSubdivisions;\n                }\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new _polyline_mjs__WEBPACK_IMPORTED_MODULE_4__.Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvY3VydmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvQztBQUNGO0FBQ0E7QUFDUTtBQUNOOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVLOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDZDQUFLO0FBQzFCLDZCQUE2Qiw2Q0FBSztBQUNsQyw2QkFBNkIsNkNBQUs7QUFDbEMsbUJBQW1CLDZDQUFLO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZDQUFLO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qyw2Q0FBSztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSx3Q0FBd0MsNkNBQUs7O0FBRTdDO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQUs7QUFDbEQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCw2Q0FBNkMsNkNBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7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QUNBLHdCQUF3QixPQUFPO0FBQy9COztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFOztBQUVBLGdFQUFnRTs7QUFFaEU7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7O0FBRUEsa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxtR0FBbUc7QUFDbkc7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RjtBQUN4RixxRkFBcUYsc0JBQXNCO0FBQzNHOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCwyRkFBMkY7QUFDM0Y7QUFDQTs7QUFFQSxtQkFBbUIsbURBQVE7QUFDM0IsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL2N1cnZlLm1qcz8yNDNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vcmVjdC5tanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3BvbHlsaW5lLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcblxuY29uc3Qge1xuICAgIGFicyxcbiAgICBzcXJ0LFxuICAgIG1pbixcbiAgICBtYXgsXG4gICAgcG93XG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IEN1cnZlID0gZnVuY3Rpb24ocDEsIHAyLCBwMywgcDQpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXJ2ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZShwMSwgcDIsIHAzLCBwNCk7XG4gICAgfVxuXG4gICAgaWYgKHAxIGluc3RhbmNlb2YgQ3VydmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZShwMS5zdGFydCwgcDEuY29udHJvbFBvaW50MSwgcDEuY29udHJvbFBvaW50MiwgcDEuZW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KHAxKTtcbiAgICB0aGlzLmNvbnRyb2xQb2ludDEgPSBuZXcgUG9pbnQocDIpO1xuICAgIHRoaXMuY29udHJvbFBvaW50MiA9IG5ldyBQb2ludChwMyk7XG4gICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQocDQpO1xufTtcblxuLy8gQ3VydmUgcGFzc2luZyB0aHJvdWdoIHBvaW50cy5cbi8vIFBvcnRlZCBmcm9tIEMjIGltcGxlbWVudGF0aW9uIGJ5IE9sZWcgVi4gUG9saWthcnBvdGNoa2luIGFuZCBQZXRlciBMZWUgKGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL0tCL2dyYXBoaWNzL0JlemllclNwbGluZS5hc3B4KS5cbi8vIEBwYXJhbSB7YXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgdGhyb3VnaCB3aGljaCB0aGUgc21vb3RoIGxpbmUgd2lsbCBnby5cbi8vIEByZXR1cm4ge2FycmF5fSBjdXJ2ZXMuXG5DdXJ2ZS50aHJvdWdoUG9pbnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gR2V0IG9wZW4tZW5kZWQgQmV6aWVyIFNwbGluZSBDb250cm9sIFBvaW50cy5cbiAgICAvLyBAcGFyYW0ga25vdHMgSW5wdXQgS25vdCBCZXppZXIgc3BsaW5lIHBvaW50cyAoQXQgbGVhc3QgdHdvIHBvaW50cyEpLlxuICAgIC8vIEBwYXJhbSBmaXJzdENvbnRyb2xQb2ludHMgT3V0cHV0IEZpcnN0IENvbnRyb2wgcG9pbnRzLiBBcnJheSBvZiBrbm90cy5sZW5ndGggLSAxIGxlbmd0aC5cbiAgICAvLyBAcGFyYW0gc2Vjb25kQ29udHJvbFBvaW50cyBPdXRwdXQgU2Vjb25kIENvbnRyb2wgcG9pbnRzLiBBcnJheSBvZiBrbm90cy5sZW5ndGggLSAxIGxlbmd0aC5cbiAgICBmdW5jdGlvbiBnZXRDdXJ2ZUNvbnRyb2xQb2ludHMoa25vdHMpIHtcblxuICAgICAgICB2YXIgZmlyc3RDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHZhciBzZWNvbmRDb250cm9sUG9pbnRzID0gW107XG4gICAgICAgIHZhciBuID0ga25vdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBCZXppZXIgY3VydmUgc2hvdWxkIGJlIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgaWYgKG4gPT0gMSkge1xuICAgICAgICAgICAgLy8gM1AxID0gMlAwICsgUDNcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAoMiAqIGtub3RzWzBdLnggKyBrbm90c1sxXS54KSAvIDMsXG4gICAgICAgICAgICAgICAgKDIgKiBrbm90c1swXS55ICsga25vdHNbMV0ueSkgLyAzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBQMiA9IDJQMSDigJMgUDBcbiAgICAgICAgICAgIHNlY29uZENvbnRyb2xQb2ludHNbMF0gPSBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgMiAqIGZpcnN0Q29udHJvbFBvaW50c1swXS54IC0ga25vdHNbMF0ueCxcbiAgICAgICAgICAgICAgICAyICogZmlyc3RDb250cm9sUG9pbnRzWzBdLnkgLSBrbm90c1swXS55XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gW2ZpcnN0Q29udHJvbFBvaW50cywgc2Vjb25kQ29udHJvbFBvaW50c107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgZmlyc3QgQmV6aWVyIGNvbnRyb2wgcG9pbnRzLlxuICAgICAgICAvLyBSaWdodCBoYW5kIHNpZGUgdmVjdG9yLlxuICAgICAgICB2YXIgcmhzID0gW107XG5cbiAgICAgICAgLy8gU2V0IHJpZ2h0IGhhbmQgc2lkZSBYIHZhbHVlcy5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS54ICsgMiAqIGtub3RzW2kgKyAxXS54O1xuICAgICAgICB9XG5cbiAgICAgICAgcmhzWzBdID0ga25vdHNbMF0ueCArIDIgKiBrbm90c1sxXS54O1xuICAgICAgICByaHNbbiAtIDFdID0gKDggKiBrbm90c1tuIC0gMV0ueCArIGtub3RzW25dLngpIC8gMi4wO1xuXG4gICAgICAgIC8vIEdldCBmaXJzdCBjb250cm9sIHBvaW50cyBYLXZhbHVlcy5cbiAgICAgICAgdmFyIHggPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuICAgICAgICAvLyBTZXQgcmlnaHQgaGFuZCBzaWRlIFkgdmFsdWVzLlxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSkge1xuICAgICAgICAgICAgcmhzW2ldID0gNCAqIGtub3RzW2ldLnkgKyAyICoga25vdHNbaSArIDFdLnk7XG4gICAgICAgIH1cblxuICAgICAgICByaHNbMF0gPSBrbm90c1swXS55ICsgMiAqIGtub3RzWzFdLnk7XG4gICAgICAgIHJoc1tuIC0gMV0gPSAoOCAqIGtub3RzW24gLSAxXS55ICsga25vdHNbbl0ueSkgLyAyLjA7XG5cbiAgICAgICAgLy8gR2V0IGZpcnN0IGNvbnRyb2wgcG9pbnRzIFktdmFsdWVzLlxuICAgICAgICB2YXIgeSA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG4gICAgICAgIC8vIEZpbGwgb3V0cHV0IGFycmF5cy5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludCh4W2ldLCB5W2ldKSk7XG5cbiAgICAgICAgICAgIC8vIFNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICAgICAgICAgaWYgKGkgPCBuIC0gMSkge1xuICAgICAgICAgICAgICAgIHNlY29uZENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIDIgKiBrbm90cyBbaSArIDFdLnggLSB4W2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgMiAqIGtub3RzW2kgKyAxXS55IC0geVtpICsgMV1cbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0ueCArIHhbbiAtIDFdKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIChrbm90c1tuXS55ICsgeVtuIC0gMV0pIC8gMlxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtmaXJzdENvbnRyb2xQb2ludHMsIHNlY29uZENvbnRyb2xQb2ludHNdO1xuICAgIH1cblxuICAgIC8vIFNvbHZlcyBhIHRyaWRpYWdvbmFsIHN5c3RlbSBmb3Igb25lIG9mIGNvb3JkaW5hdGVzICh4IG9yIHkpIG9mIGZpcnN0IEJlemllciBjb250cm9sIHBvaW50cy5cbiAgICAvLyBAcGFyYW0gcmhzIFJpZ2h0IGhhbmQgc2lkZSB2ZWN0b3IuXG4gICAgLy8gQHJldHVybiBTb2x1dGlvbiB2ZWN0b3IuXG4gICAgZnVuY3Rpb24gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocykge1xuXG4gICAgICAgIHZhciBuID0gcmhzLmxlbmd0aDtcbiAgICAgICAgLy8gYHhgIGlzIGEgc29sdXRpb24gdmVjdG9yLlxuICAgICAgICB2YXIgeCA9IFtdO1xuICAgICAgICB2YXIgdG1wID0gW107XG4gICAgICAgIHZhciBiID0gMi4wO1xuXG4gICAgICAgIHhbMF0gPSByaHNbMF0gLyBiO1xuXG4gICAgICAgIC8vIERlY29tcG9zaXRpb24gYW5kIGZvcndhcmQgc3Vic3RpdHV0aW9uLlxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gMSAvIGI7XG4gICAgICAgICAgICBiID0gKGkgPCBuIC0gMSA/IDQuMCA6IDMuNSkgLSB0bXBbaV07XG4gICAgICAgICAgICB4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBCYWNrc3Vic3RpdHV0aW9uLlxuICAgICAgICAgICAgeFtuIC0gaSAtIDFdIC09IHRtcFtuIC0gaV0gKiB4W24gLSBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgICAgICBpZiAoIXBvaW50cyB8fCAoQXJyYXkuaXNBcnJheShwb2ludHMpICYmIHBvaW50cy5sZW5ndGggPCAyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCAyIHBvaW50cyBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gZ2V0Q3VydmVDb250cm9sUG9pbnRzKHBvaW50cyk7XG5cbiAgICAgICAgdmFyIGN1cnZlcyA9IFtdO1xuICAgICAgICB2YXIgbiA9IGNvbnRyb2xQb2ludHNbMF0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgY29udHJvbFBvaW50MSA9IG5ldyBQb2ludChjb250cm9sUG9pbnRzWzBdW2ldLngsIGNvbnRyb2xQb2ludHNbMF1baV0ueSk7XG4gICAgICAgICAgICB2YXIgY29udHJvbFBvaW50MiA9IG5ldyBQb2ludChjb250cm9sUG9pbnRzWzFdW2ldLngsIGNvbnRyb2xQb2ludHNbMV1baV0ueSk7XG5cbiAgICAgICAgICAgIGN1cnZlcy5wdXNoKG5ldyBDdXJ2ZShwb2ludHNbaV0sIGNvbnRyb2xQb2ludDEsIGNvbnRyb2xQb2ludDIsIHBvaW50c1tpICsgMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJ2ZXM7XG4gICAgfTtcbn0pKCk7XG5cbkN1cnZlLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLkN1cnZlLFxuXG4gICAgLy8gUmV0dXJucyBhIGJib3ggdGhhdCB0aWdodGx5IGVudmVsb3BzIHRoZSBjdXJ2ZS5cbiAgICBiYm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY29udHJvbFBvaW50MSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludDIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICB2YXIgeDAgPSBzdGFydC54O1xuICAgICAgICB2YXIgeTAgPSBzdGFydC55O1xuICAgICAgICB2YXIgeDEgPSBjb250cm9sUG9pbnQxLng7XG4gICAgICAgIHZhciB5MSA9IGNvbnRyb2xQb2ludDEueTtcbiAgICAgICAgdmFyIHgyID0gY29udHJvbFBvaW50Mi54O1xuICAgICAgICB2YXIgeTIgPSBjb250cm9sUG9pbnQyLnk7XG4gICAgICAgIHZhciB4MyA9IGVuZC54O1xuICAgICAgICB2YXIgeTMgPSBlbmQueTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KCk7IC8vIGxvY2FsIGV4dHJlbWVzXG4gICAgICAgIHZhciB0dmFsdWVzID0gbmV3IEFycmF5KCk7IC8vIHQgdmFsdWVzIG9mIGxvY2FsIGV4dHJlbWVzXG4gICAgICAgIHZhciBib3VuZHMgPSBbbmV3IEFycmF5KCksIG5ldyBBcnJheSgpXTtcblxuICAgICAgICB2YXIgYSwgYiwgYywgdDtcbiAgICAgICAgdmFyIHQxLCB0MjtcbiAgICAgICAgdmFyIGIyYWMsIHNxcnRiMmFjO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICAgICAgICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICAgICAgICAgICAgYyA9IDMgKiB4MSAtIDMgKiB4MDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgICAgICAgICBhID0gLTMgKiB5MCArIDkgKiB5MSAtIDkgKiB5MiArIDMgKiB5MztcbiAgICAgICAgICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWJzKGEpIDwgMWUtMTIpIHsgLy8gTnVtZXJpY2FsIHJvYnVzdG5lc3NcbiAgICAgICAgICAgICAgICBpZiAoYWJzKGIpIDwgMWUtMTIpIHsgLy8gTnVtZXJpY2FsIHJvYnVzdG5lc3NcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAoKDAgPCB0KSAmJiAodCA8IDEpKSB0dmFsdWVzLnB1c2godCk7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgICAgICAgc3FydGIyYWMgPSBzcXJ0KGIyYWMpO1xuXG4gICAgICAgICAgICBpZiAoYjJhYyA8IDApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB0MSA9ICgtYiArIHNxcnRiMmFjKSAvICgyICogYSk7XG4gICAgICAgICAgICBpZiAoKDAgPCB0MSkgJiYgKHQxIDwgMSkpIHR2YWx1ZXMucHVzaCh0MSk7XG5cbiAgICAgICAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIGlmICgoMCA8IHQyKSAmJiAodDIgPCAxKSkgdHZhbHVlcy5wdXNoKHQyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqID0gdHZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHZhciBqbGVuID0gajtcbiAgICAgICAgdmFyIG10O1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgICAgICAgIG10ID0gMSAtIHQ7XG5cbiAgICAgICAgICAgIHggPSAobXQgKiBtdCAqIG10ICogeDApICsgKDMgKiBtdCAqIG10ICogdCAqIHgxKSArICgzICogbXQgKiB0ICogdCAqIHgyKSArICh0ICogdCAqIHQgKiB4Myk7XG4gICAgICAgICAgICBib3VuZHNbMF1bal0gPSB4O1xuXG4gICAgICAgICAgICB5ID0gKG10ICogbXQgKiBtdCAqIHkwKSArICgzICogbXQgKiBtdCAqIHQgKiB5MSkgKyAoMyAqIG10ICogdCAqIHQgKiB5MikgKyAodCAqIHQgKiB0ICogeTMpO1xuICAgICAgICAgICAgYm91bmRzWzFdW2pdID0geTtcblxuICAgICAgICAgICAgcG9pbnRzW2pdID0geyBYOiB4LCBZOiB5IH07XG4gICAgICAgIH1cblxuICAgICAgICB0dmFsdWVzW2psZW5dID0gMDtcbiAgICAgICAgdHZhbHVlc1tqbGVuICsgMV0gPSAxO1xuXG4gICAgICAgIHBvaW50c1tqbGVuXSA9IHsgWDogeDAsIFk6IHkwIH07XG4gICAgICAgIHBvaW50c1tqbGVuICsgMV0gPSB7IFg6IHgzLCBZOiB5MyB9O1xuXG4gICAgICAgIGJvdW5kc1swXVtqbGVuXSA9IHgwO1xuICAgICAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcblxuICAgICAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcblxuICAgICAgICB0dmFsdWVzLmxlbmd0aCA9IGpsZW4gKyAyO1xuICAgICAgICBib3VuZHNbMF0ubGVuZ3RoID0gamxlbiArIDI7XG4gICAgICAgIGJvdW5kc1sxXS5sZW5ndGggPSBqbGVuICsgMjtcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IGpsZW4gKyAyO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgICAgIHZhciB0b3AgPSBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzFdKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgICAgIHZhciBib3R0b20gPSBtYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QobGVmdCwgdG9wLCAocmlnaHQgLSBsZWZ0KSwgKGJvdHRvbSAtIHRvcCkpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLnN0YXJ0LCB0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBwb2ludCBvbiB0aGUgY3VydmUgY2xvc2VzdCB0byBwb2ludCBgcGBcbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXRUKHRoaXMuY2xvc2VzdFBvaW50VChwLCBvcHQpKTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50TGVuZ3RoOiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoQXRUKHRoaXMuY2xvc2VzdFBvaW50VChwLCBsb2NhbE9wdCksIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBjcExlbmd0aCA9IHRoaXMuY2xvc2VzdFBvaW50TGVuZ3RoKHAsIGxvY2FsT3B0KTtcbiAgICAgICAgaWYgKCFjcExlbmd0aCkgcmV0dXJuIDA7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKGxvY2FsT3B0KTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG5cbiAgICAgICAgcmV0dXJuIGNwTGVuZ3RoIC8gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0YCBvZiB0aGUgcG9pbnQgb24gdGhlIGN1cnZlIGNsb3Nlc3QgdG8gcG9pbnQgYHBgXG4gICAgY2xvc2VzdFBvaW50VDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBkb2VzIG5vdCB1c2UgbG9jYWxPcHRcblxuICAgICAgICAvLyBpZGVudGlmeSB0aGUgc3ViZGl2aXNpb24gdGhhdCBjb250YWlucyB0aGUgcG9pbnQ6XG4gICAgICAgIHZhciBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbjtcbiAgICAgICAgdmFyIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUOyAvLyBhc3N1bWUgdGhhdCBzdWJkaXZpc2lvbnMgYXJlIGV2ZW5seSBzcGFjZWRcbiAgICAgICAgdmFyIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVDtcbiAgICAgICAgdmFyIGRpc3RGcm9tU3RhcnQ7IC8vIGRpc3RhbmNlIG9mIHBvaW50IGZyb20gc3RhcnQgb2YgYmFzZWxpbmVcbiAgICAgICAgdmFyIGRpc3RGcm9tRW5kOyAvLyBkaXN0YW5jZSBvZiBwb2ludCBmcm9tIGVuZCBvZiBiYXNlbGluZVxuICAgICAgICB2YXIgY2hvcmRMZW5ndGg7IC8vIGRpc3RhbmNlIGJldHdlZW4gc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3ViZGl2aXNpb25cbiAgICAgICAgdmFyIG1pblN1bURpc3Q7IC8vIGxvd2VzdCBvYnNlcnZlZCBzdW0gb2YgdGhlIHR3byBkaXN0YW5jZXNcbiAgICAgICAgdmFyIG4gPSBzdWJkaXZpc2lvbnMubGVuZ3RoO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25TaXplID0gKG4gPyAoMSAvIG4pIDogMCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50U3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbnNbaV07XG5cbiAgICAgICAgICAgIHZhciBzdGFydERpc3QgPSBjdXJyZW50U3ViZGl2aXNpb24uc3RhcnQuZGlzdGFuY2UocCk7XG4gICAgICAgICAgICB2YXIgZW5kRGlzdCA9IGN1cnJlbnRTdWJkaXZpc2lvbi5lbmQuZGlzdGFuY2UocCk7XG4gICAgICAgICAgICB2YXIgc3VtRGlzdCA9IHN0YXJ0RGlzdCArIGVuZERpc3Q7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHBvaW50IGlzIGNsb3Nlc3QgdG8gY3VycmVudCBzdWJkaXZpc2lvbiBhbmQgbm90IGFueSBvdGhlclxuICAgICAgICAgICAgaWYgKCFtaW5TdW1EaXN0IHx8IChzdW1EaXN0IDwgbWluU3VtRGlzdCkpIHtcbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbiA9IGN1cnJlbnRTdWJkaXZpc2lvbjtcblxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUID0gaSAqIHN1YmRpdmlzaW9uU2l6ZTtcbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQgPSAoaSArIDEpICogc3ViZGl2aXNpb25TaXplO1xuXG4gICAgICAgICAgICAgICAgZGlzdEZyb21TdGFydCA9IHN0YXJ0RGlzdDtcbiAgICAgICAgICAgICAgICBkaXN0RnJvbUVuZCA9IGVuZERpc3Q7XG5cbiAgICAgICAgICAgICAgICBjaG9yZExlbmd0aCA9IGN1cnJlbnRTdWJkaXZpc2lvbi5zdGFydC5kaXN0YW5jZShjdXJyZW50U3ViZGl2aXNpb24uZW5kKTtcblxuICAgICAgICAgICAgICAgIG1pblN1bURpc3QgPSBzdW1EaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZWNpc2lvblJhdGlvID0gcG93KDEwLCAtcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyByZWN1cnNpdmVseSBkaXZpZGUgaW52ZXN0aWdhdGVkIHN1YmRpdmlzaW9uOlxuICAgICAgICAvLyB1bnRpbCBkaXN0YW5jZSBiZXR3ZWVuIGJhc2VsaW5lUG9pbnQgYW5kIGNsb3Nlc3QgcGF0aCBlbmRwb2ludCBpcyB3aXRoaW4gMTBeKC1wcmVjaXNpb24pXG4gICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBjbG9zZXN0IGVuZHBvaW50IG9mIHRoYXQgZmluYWwgc3ViZGl2aXNpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBvYnNlcnZlZCBwcmVjaXNpb25cbiAgICAgICAgICAgIC8vIC0gY2FsY3VsYXRlZCBhczogdGhlIGRpZmZlcmVuY2UgaW4gZGlzdGFuY2VzIGZyb20gcG9pbnQgdG8gc3RhcnQgYW5kIGVuZCBkaXZpZGVkIGJ5IHRoZSBkaXN0YW5jZVxuICAgICAgICAgICAgLy8gLSBub3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBub3QgbW9ub3RvbmljID0gaXQgZG9lc24ndCBjb252ZXJnZSBzdGFibHkgYnV0IGhhcyBcInRlZXRoXCJcbiAgICAgICAgICAgIC8vIC0gdGhlIGZ1bmN0aW9uIGRlY3JlYXNlcyB3aGlsZSBvbmUgb2YgdGhlIGVuZHBvaW50cyBpcyBmaXhlZCBidXQgXCJqdW1wc1wiIHdoZW5ldmVyIHdlIHN3aXRjaFxuICAgICAgICAgICAgLy8gLSB0aGlzIGNyaXRlcmlvbiB3b3JrcyB3ZWxsIGZvciBwb2ludHMgbHlpbmcgZmFyIGF3YXkgZnJvbSB0aGUgY3VydmVcbiAgICAgICAgICAgIHZhciBzdGFydFByZWNpc2lvblJhdGlvID0gKGRpc3RGcm9tU3RhcnQgPyAoYWJzKGRpc3RGcm9tU3RhcnQgLSBkaXN0RnJvbUVuZCkgLyBkaXN0RnJvbVN0YXJ0KSA6IDApO1xuICAgICAgICAgICAgdmFyIGVuZFByZWNpc2lvblJhdGlvID0gKGRpc3RGcm9tRW5kID8gKGFicyhkaXN0RnJvbVN0YXJ0IC0gZGlzdEZyb21FbmQpIC8gZGlzdEZyb21FbmQpIDogMCk7XG4gICAgICAgICAgICB2YXIgaGFzUmVxdWlyZWRQcmVjaXNpb24gPSAoKHN0YXJ0UHJlY2lzaW9uUmF0aW8gPCBwcmVjaXNpb25SYXRpbykgfHwgKGVuZFByZWNpc2lvblJhdGlvIDwgcHJlY2lzaW9uUmF0aW8pKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBtaW5pbWFsIGRpc3RhbmNlXG4gICAgICAgICAgICAvLyAtIGNhbGN1bGF0ZWQgYXM6IHRoZSBzdWJkaXZpc2lvbiBjaG9yZCBsZW5ndGggbXVsdGlwbGllZCBieSBwcmVjaXNpb25SYXRpb1xuICAgICAgICAgICAgLy8gLSBjYWxjdWxhdGlvbiBpcyByZWxhdGl2ZSBzbyBpdCB3aWxsIHdvcmsgZm9yIGFyYml0cmFyaWx5IGxhcmdlL3NtYWxsIGN1cnZlcyBhbmQgdGhlaXIgc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAvLyAtIHRoaXMgaXMgYSBiYWNrdXAgY3JpdGVyaW9uIHRoYXQgd29ya3Mgd2VsbCBmb3IgcG9pbnRzIGx5aW5nIFwiYWxtb3N0IGF0XCIgdGhlIGN1cnZlXG4gICAgICAgICAgICB2YXIgaGFzTWluaW1hbFN0YXJ0RGlzdGFuY2UgPSAoZGlzdEZyb21TdGFydCA/IChkaXN0RnJvbVN0YXJ0IDwgKGNob3JkTGVuZ3RoICogcHJlY2lzaW9uUmF0aW8pKSA6IHRydWUpO1xuICAgICAgICAgICAgdmFyIGhhc01pbmltYWxFbmREaXN0YW5jZSA9IChkaXN0RnJvbUVuZCA/IChkaXN0RnJvbUVuZCA8IChjaG9yZExlbmd0aCAqIHByZWNpc2lvblJhdGlvKSkgOiB0cnVlKTtcbiAgICAgICAgICAgIHZhciBoYXNNaW5pbWFsRGlzdGFuY2UgPSAoaGFzTWluaW1hbFN0YXJ0RGlzdGFuY2UgfHwgaGFzTWluaW1hbEVuZERpc3RhbmNlKTtcblxuICAgICAgICAgICAgLy8gZG8gd2Ugc3RvcCBub3c/XG4gICAgICAgICAgICBpZiAoaGFzUmVxdWlyZWRQcmVjaXNpb24gfHwgaGFzTWluaW1hbERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoZGlzdEZyb21TdGFydCA8PSBkaXN0RnJvbUVuZCkgPyBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VCA6IGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgc2V0IHVwIGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgdmFyIGRpdmlkZWQgPSBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbi5kaXZpZGUoMC41KTtcbiAgICAgICAgICAgIHN1YmRpdmlzaW9uU2l6ZSAvPSAyO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnREaXN0MSA9IGRpdmlkZWRbMF0uc3RhcnQuZGlzdGFuY2UocCk7XG4gICAgICAgICAgICB2YXIgZW5kRGlzdDEgPSBkaXZpZGVkWzBdLmVuZC5kaXN0YW5jZShwKTtcbiAgICAgICAgICAgIHZhciBzdW1EaXN0MSA9IHN0YXJ0RGlzdDEgKyBlbmREaXN0MTtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0RGlzdDIgPSBkaXZpZGVkWzFdLnN0YXJ0LmRpc3RhbmNlKHApO1xuICAgICAgICAgICAgdmFyIGVuZERpc3QyID0gZGl2aWRlZFsxXS5lbmQuZGlzdGFuY2UocCk7XG4gICAgICAgICAgICB2YXIgc3VtRGlzdDIgPSBzdGFydERpc3QyICsgZW5kRGlzdDI7XG5cbiAgICAgICAgICAgIGlmIChzdW1EaXN0MSA8PSBzdW1EaXN0Mikge1xuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uID0gZGl2aWRlZFswXTtcblxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVCAtPSBzdWJkaXZpc2lvblNpemU7IC8vIHN1YmRpdmlzaW9uU2l6ZSB3YXMgYWxyZWFkeSBoYWx2ZWRcblxuICAgICAgICAgICAgICAgIGRpc3RGcm9tU3RhcnQgPSBzdGFydERpc3QxO1xuICAgICAgICAgICAgICAgIGRpc3RGcm9tRW5kID0gZW5kRGlzdDE7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24gPSBkaXZpZGVkWzFdO1xuXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQgKz0gc3ViZGl2aXNpb25TaXplOyAvLyBzdWJkaXZpc2lvblNpemUgd2FzIGFscmVhZHkgaGFsdmVkXG5cbiAgICAgICAgICAgICAgICBkaXN0RnJvbVN0YXJ0ID0gc3RhcnREaXN0MjtcbiAgICAgICAgICAgICAgICBkaXN0RnJvbUVuZCA9IGVuZERpc3QyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludFRhbmdlbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdFQodGhpcy5jbG9zZXN0UG9pbnRUKHAsIG9wdCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJlYSBzdXJyb3VuZGVkIGJ5IHRoZSBjdXJ2ZSBjb250YWlucyB0aGUgcG9pbnQgYHBgLlxuICAgIC8vIEltcGxlbWVudHMgdGhlIGV2ZW4tb2RkIGFsZ29yaXRobSAoc2VsZi1pbnRlcnNlY3Rpb25zIGFyZSBcIm91dHNpZGVcIikuXG4gICAgLy8gQ2xvc2VzIG9wZW4gY3VydmVzIChhbHdheXMgaW1hZ2luZXMgYSBjbG9zaW5nIHNlZ21lbnQpLlxuICAgIC8vIFByZWNpc2lvbiBtYXkgYmUgYWRqdXN0ZWQgYnkgcGFzc2luZyBhbiBgb3B0YCBvYmplY3QuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHBvbHlsaW5lID0gdGhpcy50b1BvbHlsaW5lKG9wdCk7XG4gICAgICAgIHJldHVybiBwb2x5bGluZS5jb250YWluc1BvaW50KHApO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBjdXJ2ZSBpbnRvIHR3byBhdCByZXF1ZXN0ZWQgYHJhdGlvYCBiZXR3ZWVuIDAgYW5kIDEgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBGb3IgYSBmdW5jdGlvbiB0aGF0IHVzZXMgYHRgLCB1c2UgQ3VydmUuZGl2aWRlQXRUKCkuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICBpZiAocmF0aW8gPD0gMCkgcmV0dXJuIHRoaXMuZGl2aWRlQXRUKDApO1xuICAgICAgICBpZiAocmF0aW8gPj0gMSkgcmV0dXJuIHRoaXMuZGl2aWRlQXRUKDEpO1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy50QXQocmF0aW8sIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlQXRUKHQpO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBjdXJ2ZSBpbnRvIHR3byBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgZGl2aWRlQXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRBdExlbmd0aChsZW5ndGgsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlQXRUKHQpO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBjdXJ2ZSBpbnRvIHR3byBhdCBwb2ludCBkZWZpbmVkIGJ5IGB0YCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgLy8gVXNpbmcgZGUgQ2FzdGVsamF1J3MgYWxnb3JpdGhtIChodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzMxNzg2NykuXG4gICAgLy8gQWRkaXRpb25hbCByZXNvdXJjZTogaHR0cHM6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jZGVjYXN0ZWxqYXVcbiAgICBkaXZpZGVBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY29udHJvbFBvaW50MSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludDIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICAvLyBzaG9ydGN1dHMgZm9yIGB0YCB2YWx1ZXMgdGhhdCBhcmUgb3V0IG9mIHJhbmdlXG4gICAgICAgIGlmICh0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IEN1cnZlKHN0YXJ0LCBzdGFydCwgc3RhcnQsIHN0YXJ0KSxcbiAgICAgICAgICAgICAgICBuZXcgQ3VydmUoc3RhcnQsIGNvbnRyb2xQb2ludDEsIGNvbnRyb2xQb2ludDIsIGVuZClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5ldyBDdXJ2ZShzdGFydCwgY29udHJvbFBvaW50MSwgY29udHJvbFBvaW50MiwgZW5kKSxcbiAgICAgICAgICAgICAgICBuZXcgQ3VydmUoZW5kLCBlbmQsIGVuZCwgZW5kKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXZpZGVyUG9pbnRzID0gdGhpcy5nZXRTa2VsZXRvblBvaW50cyh0KTtcblxuICAgICAgICB2YXIgc3RhcnRDb250cm9sMSA9IGRpdmlkZXJQb2ludHMuc3RhcnRDb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgc3RhcnRDb250cm9sMiA9IGRpdmlkZXJQb2ludHMuc3RhcnRDb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZGl2aWRlciA9IGRpdmlkZXJQb2ludHMuZGl2aWRlcjtcbiAgICAgICAgdmFyIGRpdmlkZXJDb250cm9sMSA9IGRpdmlkZXJQb2ludHMuZGl2aWRlckNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBkaXZpZGVyQ29udHJvbDIgPSBkaXZpZGVyUG9pbnRzLmRpdmlkZXJDb250cm9sUG9pbnQyO1xuXG4gICAgICAgIC8vIHJldHVybiBhcnJheSB3aXRoIHR3byBuZXcgY3VydmVzXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ3VydmUoc3RhcnQsIHN0YXJ0Q29udHJvbDEsIHN0YXJ0Q29udHJvbDIsIGRpdmlkZXIpLFxuICAgICAgICAgICAgbmV3IEN1cnZlKGRpdmlkZXIsIGRpdmlkZXJDb250cm9sMSwgZGl2aWRlckNvbnRyb2wyLCBlbmQpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGN1cnZlJ3Mgc3RhcnQgYW5kIGVuZCBwb2ludHMuXG4gICAgZW5kcG9pbnREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2UodGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3Mgd2hldGhlciB0d28gY3VydmVzIGFyZSBleGFjdGx5IHRoZSBzYW1lLlxuICAgIGVxdWFsczogZnVuY3Rpb24oYykge1xuXG4gICAgICAgIHJldHVybiAhIWMgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnQueCA9PT0gYy5zdGFydC54ICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnkgPT09IGMuc3RhcnQueSAmJlxuICAgICAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxLnggPT09IGMuY29udHJvbFBvaW50MS54ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEueSA9PT0gYy5jb250cm9sUG9pbnQxLnkgJiZcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi54ID09PSBjLmNvbnRyb2xQb2ludDIueCAmJlxuICAgICAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyLnkgPT09IGMuY29udHJvbFBvaW50Mi55ICYmXG4gICAgICAgICAgICB0aGlzLmVuZC54ID09PSBjLmVuZC54ICYmXG4gICAgICAgICAgICB0aGlzLmVuZC55ID09PSBjLmVuZC55O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGZpdmUgaGVscGVyIHBvaW50cyBuZWNlc3NhcnkgZm9yIGN1cnZlIGRpdmlzaW9uLlxuICAgIGdldFNrZWxldG9uUG9pbnRzOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGNvbnRyb2wxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgY29udHJvbDIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICAvLyBzaG9ydGN1dHMgZm9yIGB0YCB2YWx1ZXMgdGhhdCBhcmUgb3V0IG9mIHJhbmdlXG4gICAgICAgIGlmICh0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnRDb250cm9sUG9pbnQxOiBzdGFydC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udHJvbFBvaW50Mjogc3RhcnQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBkaXZpZGVyOiBzdGFydC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGRpdmlkZXJDb250cm9sUG9pbnQxOiBjb250cm9sMS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGRpdmlkZXJDb250cm9sUG9pbnQyOiBjb250cm9sMi5jbG9uZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydENvbnRyb2xQb2ludDE6IGNvbnRyb2wxLmNsb25lKCksXG4gICAgICAgICAgICAgICAgc3RhcnRDb250cm9sUG9pbnQyOiBjb250cm9sMi5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGRpdmlkZXI6IGVuZC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGRpdmlkZXJDb250cm9sUG9pbnQxOiBlbmQuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBkaXZpZGVyQ29udHJvbFBvaW50MjogZW5kLmNsb25lKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWlkcG9pbnQxID0gKG5ldyBMaW5lKHN0YXJ0LCBjb250cm9sMSkpLnBvaW50QXQodCk7XG4gICAgICAgIHZhciBtaWRwb2ludDIgPSAobmV3IExpbmUoY29udHJvbDEsIGNvbnRyb2wyKSkucG9pbnRBdCh0KTtcbiAgICAgICAgdmFyIG1pZHBvaW50MyA9IChuZXcgTGluZShjb250cm9sMiwgZW5kKSkucG9pbnRBdCh0KTtcblxuICAgICAgICB2YXIgc3ViQ29udHJvbDEgPSAobmV3IExpbmUobWlkcG9pbnQxLCBtaWRwb2ludDIpKS5wb2ludEF0KHQpO1xuICAgICAgICB2YXIgc3ViQ29udHJvbDIgPSAobmV3IExpbmUobWlkcG9pbnQyLCBtaWRwb2ludDMpKS5wb2ludEF0KHQpO1xuXG4gICAgICAgIHZhciBkaXZpZGVyID0gKG5ldyBMaW5lKHN1YkNvbnRyb2wxLCBzdWJDb250cm9sMikpLnBvaW50QXQodCk7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgICAgIHN0YXJ0Q29udHJvbFBvaW50MTogbWlkcG9pbnQxLFxuICAgICAgICAgICAgc3RhcnRDb250cm9sUG9pbnQyOiBzdWJDb250cm9sMSxcbiAgICAgICAgICAgIGRpdmlkZXI6IGRpdmlkZXIsXG4gICAgICAgICAgICBkaXZpZGVyQ29udHJvbFBvaW50MTogc3ViQ29udHJvbDIsXG4gICAgICAgICAgICBkaXZpZGVyQ29udHJvbFBvaW50MjogbWlkcG9pbnQzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGxpc3Qgb2YgY3VydmVzIHdob3NlIGZsYXR0ZW5lZCBsZW5ndGggaXMgYmV0dGVyIHRoYW4gYG9wdC5wcmVjaXNpb25gLlxuICAgIC8vIFRoYXQgaXMsIG9ic2VydmVkIGRpZmZlcmVuY2UgaW4gbGVuZ3RoIGJldHdlZW4gcmVjdXJzaW9ucyBpcyBsZXNzIHRoYW4gMTBeKC0zKSA9IDAuMDAxID0gMC4xJVxuICAgIC8vIChPYnNlcnZlZCBkaWZmZXJlbmNlIGlzIG5vdCByZWFsIHByZWNpc2lvbiwgYnV0IGNsb3NlIGVub3VnaCBhcyBsb25nIGFzIHNwZWNpYWwgY2FzZXMgYXJlIGNvdmVyZWQpXG4gICAgLy8gQXMgYSBydWxlIG9mIHRodW1iLCBpbmNyZWFzaW5nIGBwcmVjaXNpb25gIGJ5IDEgcmVxdWlyZXMgMiBtb3JlIGl0ZXJhdGlvbnMgKD0gbGV2ZWxzIG9mIGRpdmlzaW9uIG9wZXJhdGlvbnMpXG4gICAgLy8gLSBQcmVjaXNpb24gMCAoZW5kcG9pbnREaXN0YW5jZSkgLSAwIGl0ZXJhdGlvbnMgPT4gdG90YWwgb2YgMl4wIC0gMSA9IDAgb3BlcmF0aW9ucyAoMSBzdWJkaXZpc2lvbilcbiAgICAvLyAtIFByZWNpc2lvbiAxICg8MTAlIGVycm9yKSAtIDIgaXRlcmF0aW9ucyA9PiB0b3RhbCBvZiAyXjIgLSAxID0gMyBvcGVyYXRpb25zICg0IHN1YmRpdmlzaW9ucylcbiAgICAvLyAtIFByZWNpc2lvbiAyICg8MSUgZXJyb3IpIC0gNCBpdGVyYXRpb25zID0+IHRvdGFsIG9mIDJeNCAtIDEgPSAxNSBvcGVyYXRpb25zIHJlcXVpcmVzIDQgZGl2aXNpb24gb3BlcmF0aW9ucyBvbiBhbGwgZWxlbWVudHMgKDE1IG9wZXJhdGlvbnMgdG90YWwpICgxNiBzdWJkaXZpc2lvbnMpXG4gICAgLy8gLSBQcmVjaXNpb24gMyAoPDAuMSUgZXJyb3IpIC0gNiBpdGVyYXRpb25zID0+IHRvdGFsIG9mIDJeNiAtIDEgPSA2MyBvcGVyYXRpb25zIC0gYWNjZXB0YWJsZSB3aGVuIGRyYXdpbmcgKDY0IHN1YmRpdmlzaW9ucylcbiAgICAvLyAtIFByZWNpc2lvbiA0ICg8MC4wMSUgZXJyb3IpIC0gOCBpdGVyYXRpb25zID0+IHRvdGFsIG9mIDJeOCAtIDEgPSAyNTUgb3BlcmF0aW9ucyAtIGhpZ2ggcmVzb2x1dGlvbiwgY2FuIGJlIHVzZWQgdG8gaW50ZXJwb2xhdGUgYHRgICgyNTYgc3ViZGl2aXNpb25zKVxuICAgIC8vIChWYXJpYXRpb24gb2YgMSByZWN1cnNpb24gd29yc2Ugb3IgYmV0dGVyIGlzIHBvc3NpYmxlIGRlcGVuZGluZyBvbiB0aGUgY3VydmUsIGRvdWJsaW5nL2hhbHZpbmcgdGhlIG51bWJlciBvZiBvcGVyYXRpb25zIGFjY29yZGluZ2x5KVxuICAgIGdldFN1YmRpdmlzaW9uczogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIC8vIG5vdCB1c2luZyBvcHQuc3ViZGl2aXNpb25zXG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sMSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2wyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IFtuZXcgQ3VydmUoc3RhcnQsIGNvbnRyb2wxLCBjb250cm9sMiwgZW5kKV07XG4gICAgICAgIGlmIChwcmVjaXNpb24gPT09IDApIHJldHVybiBzdWJkaXZpc2lvbnM7XG5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlICMxOiBwb2ludC1saWtlIGN1cnZlc1xuICAgICAgICAvLyAtIG5vIG5lZWQgdG8gY2FsY3VsYXRlIHN1YmRpdmlzaW9ucywgdGhleSB3b3VsZCBhbGwgYmUgaWRlbnRpY2FsXG4gICAgICAgIHZhciBpc1BvaW50ID0gIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpO1xuICAgICAgICBpZiAoaXNQb2ludCkgcmV0dXJuIHN1YmRpdmlzaW9ucztcblxuICAgICAgICB2YXIgcHJldmlvdXNMZW5ndGggPSB0aGlzLmVuZHBvaW50RGlzdGFuY2UoKTtcblxuICAgICAgICB2YXIgcHJlY2lzaW9uUmF0aW8gPSBwb3coMTAsIC1wcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSAjMjogc2luZS1saWtlIGN1cnZlcyBtYXkgaGF2ZSB0aGUgc2FtZSBvYnNlcnZlZCBsZW5ndGggaW4gaXRlcmF0aW9uIDAgYW5kIDEgLSBza2lwIGl0ZXJhdGlvbiAxXG4gICAgICAgIC8vIC0gbm90IGEgcHJvYmxlbSBmb3IgZnVydGhlciBpdGVyYXRpb25zIGJlY2F1c2UgY3ViaWMgY3VydmVzIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiB0d28gbG9jYWwgZXh0cmVtYVxuICAgICAgICAvLyAtIChpLmUuIGN1YmljIGN1cnZlcyBjYW5ub3QgaW50ZXJzZWN0IHRoZSBiYXNlbGluZSBtb3JlIHRoYW4gb25jZSlcbiAgICAgICAgLy8gLSB0aGVyZWZvcmUgc3RhcnRpbmcgZnJvbSBpdGVyYXRpb24gPSAyIGVuc3VyZXMgdGhhdCBzdWJzZXF1ZW50IGl0ZXJhdGlvbnMgZG8gbm90IHByb2R1Y2Ugc2FtcGxpbmcgd2l0aCBlcXVhbCBsZW5ndGhcbiAgICAgICAgLy8gLSAodW5sZXNzIGl0J3MgYSBzdHJhaWdodC1saW5lIGN1cnZlLCBzZWUgYmVsb3cpXG4gICAgICAgIHZhciBtaW5JdGVyYXRpb25zID0gMjsgLy8gPSAyKjFcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgIzM6IHN0cmFpZ2h0LWxpbmUgY3VydmVzIGhhdmUgdGhlIHNhbWUgb2JzZXJ2ZWQgbGVuZ3RoIGluIGFsbCBpdGVyYXRpb25zXG4gICAgICAgIC8vIC0gdGhpcyBjYXVzZXMgb2JzZXJ2ZWQgcHJlY2lzaW9uIHJhdGlvIHRvIGFsd2F5cyBiZSAwICg9IGxvd2VyIHRoYW4gYHByZWNpc2lvblJhdGlvYCwgd2hpY2ggaXMgb3VyIGV4aXQgY29uZGl0aW9uKVxuICAgICAgICAvLyAtIHdlIGVuZm9yY2UgdGhlIGV4cGVjdGVkIG51bWJlciBvZiBpdGVyYXRpb25zID0gMiAqIHByZWNpc2lvblxuICAgICAgICB2YXIgaXNMaW5lID0gKChjb250cm9sMS5jcm9zcyhzdGFydCwgZW5kKSA9PT0gMCkgJiYgKGNvbnRyb2wyLmNyb3NzKHN0YXJ0LCBlbmQpID09PSAwKSk7XG4gICAgICAgIGlmIChpc0xpbmUpIHtcbiAgICAgICAgICAgIG1pbkl0ZXJhdGlvbnMgPSAoMiAqIHByZWNpc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBkaXZpZGUgY3VydmUgYXQgYHQgPSAwLjVgXG4gICAgICAgIC8vIHVudGlsIHdlIHJlYWNoIGBtaW5JdGVyYXRpb25zYFxuICAgICAgICAvLyBhbmQgdW50aWwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvYnNlcnZlZCBsZW5ndGggYXQgc3Vic2VxdWVudCBpdGVyYXRpb25zIGlzIGxvd2VyIHRoYW4gYHByZWNpc2lvbmBcbiAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpdGVyYXRpb24gKz0gMTtcblxuICAgICAgICAgICAgLy8gZGl2aWRlIGFsbCBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgIHZhciBuZXdTdWJkaXZpc2lvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBudW1TdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TdWJkaXZpc2lvbnM7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2aWRlZCA9IGN1cnJlbnRTdWJkaXZpc2lvbi5kaXZpZGUoMC41KTsgLy8gZGl2aWRpbmcgYXQgdCA9IDAuNSAobm90IGF0IG1pZGRsZSBsZW5ndGghKVxuICAgICAgICAgICAgICAgIG5ld1N1YmRpdmlzaW9ucy5wdXNoKGRpdmlkZWRbMF0sIGRpdmlkZWRbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtZWFzdXJlIG5ldyBsZW5ndGhcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICAgICAgdmFyIG51bU5ld1N1YmRpdmlzaW9ucyA9IG5ld1N1YmRpdmlzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5ld1N1YmRpdmlzaW9uczsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5ld1N1YmRpdmlzaW9uID0gbmV3U3ViZGl2aXNpb25zW2pdO1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSBjdXJyZW50TmV3U3ViZGl2aXNpb24uZW5kcG9pbnREaXN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHJlYWNoZWQgbWluaW11bSBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgICAgICAgICAgaWYgKGl0ZXJhdGlvbiA+PSBtaW5JdGVyYXRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHJlYWNoZWQgcmVxdWlyZWQgb2JzZXJ2ZWQgcHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVkUHJlY2lzaW9uUmF0aW8gPSAoKGxlbmd0aCAhPT0gMCkgPyAoKGxlbmd0aCAtIHByZXZpb3VzTGVuZ3RoKSAvIGxlbmd0aCkgOiAwKTtcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZWRQcmVjaXNpb25SYXRpbyA8IHByZWNpc2lvblJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdWJkaXZpc2lvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHNldCB1cCBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIHN1YmRpdmlzaW9ucyA9IG5ld1N1YmRpdmlzaW9ucztcbiAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sMSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2wyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgcmV0dXJuICEoc3RhcnQuZXF1YWxzKGNvbnRyb2wxKSAmJiBjb250cm9sMS5lcXVhbHMoY29udHJvbDIpICYmIGNvbnRyb2wyLmVxdWFscyhlbmQpKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBmbGF0dGVuZWQgbGVuZ3RoIG9mIHRoZSBjdXJ2ZSB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uOyAvLyBvcHQucHJlY2lzaW9uIG9ubHkgdXNlZCBpbiBnZXRTdWJkaXZpc2lvbnMoKSBjYWxsXG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG4gPSBzdWJkaXZpc2lvbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFN1YmRpdmlzaW9uID0gc3ViZGl2aXNpb25zW2ldO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGN1cnJlbnRTdWJkaXZpc2lvbi5lbmRwb2ludERpc3RhbmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGRpc3RhbmNlIGFsb25nIHRoZSBjdXJ2ZSB1cCB0byBgdGAgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYC4gKE5vdCB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AuKVxuICAgIGxlbmd0aEF0VDogZnVuY3Rpb24odCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIC8vIG5vdCB1c2luZyBvcHQuc3ViZGl2aXNpb25zXG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBzdWJDdXJ2ZSA9IHRoaXMuZGl2aWRlKHQpWzBdO1xuICAgICAgICB2YXIgc3ViQ3VydmVMZW5ndGggPSBzdWJDdXJ2ZS5sZW5ndGgoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KTtcblxuICAgICAgICByZXR1cm4gc3ViQ3VydmVMZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcG9pbnQgYXQgcmVxdWVzdGVkIGByYXRpb2AgYmV0d2VlbiAwIGFuZCAxIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gTWlycm9ycyBMaW5lLnBvaW50QXQoKSBmdW5jdGlvbi5cbiAgICAvLyBGb3IgYSBmdW5jdGlvbiB0aGF0IHRyYWNrcyBgdGAsIHVzZSBDdXJ2ZS5wb2ludEF0VCgpLlxuICAgIHBvaW50QXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICBpZiAocmF0aW8gPD0gMCkgcmV0dXJuIHRoaXMuc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgaWYgKHJhdGlvID49IDEpIHJldHVybiB0aGlzLmVuZC5jbG9uZSgpO1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy50QXQocmF0aW8sIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdFQodCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcG9pbnQgYXQgcmVxdWVzdGVkIGBsZW5ndGhgIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRBdExlbmd0aChsZW5ndGgsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdFQodCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHBvaW50IGF0IHByb3ZpZGVkIGB0YCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgLy8gYHRgIGRvZXMgbm90IHRyYWNrIGRpc3RhbmNlIGFsb25nIGN1cnZlIGFzIGl0IGRvZXMgaW4gTGluZSBvYmplY3RzLlxuICAgIC8vIE5vbi1saW5lYXIgcmVsYXRpb25zaGlwLCBzcGVlZHMgdXAgYW5kIHNsb3dzIGRvd24gYXMgY3VydmUgd2FycHMhXG4gICAgLy8gRm9yIGxpbmVhciBsZW5ndGgtYmFzZWQgc29sdXRpb24sIHVzZSBDdXJ2ZS5wb2ludEF0KCkuXG4gICAgcG9pbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAodCA8PSAwKSByZXR1cm4gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBpZiAodCA+PSAxKSByZXR1cm4gdGhpcy5lbmQuY2xvbmUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTa2VsZXRvblBvaW50cyh0KS5kaXZpZGVyO1xuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIFBSRUNJU0lPTjogMyxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5lbmQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHRoaXMuc3RhcnQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLmVuZC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgdGFuZ2VudCBsaW5lIGF0IHJlcXVlc3RlZCBgcmF0aW9gIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHJhdGlvID4gMSkgcmF0aW8gPSAxO1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy50QXQocmF0aW8sIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0VCh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHRhbmdlbnQgbGluZSBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3IgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIHRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgdCA9IHRoaXMudEF0TGVuZ3RoKGxlbmd0aCwgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy50YW5nZW50QXRUKHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgdGFuZ2VudCBsaW5lIGF0IHJlcXVlc3RlZCBgdGAuXG4gICAgdGFuZ2VudEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0RpZmZlcmVudGlhYmxlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmICh0IDwgMCkgdCA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHQgPiAxKSB0ID0gMTtcblxuICAgICAgICB2YXIgc2tlbGV0b25Qb2ludHMgPSB0aGlzLmdldFNrZWxldG9uUG9pbnRzKHQpO1xuXG4gICAgICAgIHZhciBwMSA9IHNrZWxldG9uUG9pbnRzLnN0YXJ0Q29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIHAyID0gc2tlbGV0b25Qb2ludHMuZGl2aWRlckNvbnRyb2xQb2ludDE7XG5cbiAgICAgICAgdmFyIHRhbmdlbnRTdGFydCA9IHNrZWxldG9uUG9pbnRzLmRpdmlkZXI7XG5cbiAgICAgICAgdmFyIHRhbmdlbnRMaW5lID0gbmV3IExpbmUocDEsIHAyKTtcbiAgICAgICAgdGFuZ2VudExpbmUudHJhbnNsYXRlKHRhbmdlbnRTdGFydC54IC0gcDEueCwgdGFuZ2VudFN0YXJ0LnkgLSBwMS55KTsgLy8gbW92ZSBzbyB0aGF0IHRhbmdlbnQgbGluZSBzdGFydHMgYXQgdGhlIHBvaW50IHJlcXVlc3RlZFxuXG4gICAgICAgIHJldHVybiB0YW5nZW50TGluZTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdGAgYXQgcmVxdWVzdGVkIGByYXRpb2Agd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgdEF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgaWYgKHJhdGlvIDw9IDApIHJldHVybiAwO1xuICAgICAgICBpZiAocmF0aW8gPj0gMSkgcmV0dXJuIDE7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBjdXJ2ZUxlbmd0aCA9IHRoaXMubGVuZ3RoKGxvY2FsT3B0KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGN1cnZlTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudEF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0YCBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gVXNlcyBgcHJlY2lzaW9uYCB0byBhcHByb3hpbWF0ZSBsZW5ndGggd2l0aGluIGBwcmVjaXNpb25gIChhbHdheXMgdW5kZXJlc3RpbWF0ZXMpXG4gICAgLy8gVGhlbiB1c2VzIGEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBgdGAgb2YgYSBzdWJkaXZpc2lvbiBlbmRwb2ludCB0aGF0IGlzIGNsb3NlICh3aXRoaW4gYHByZWNpc2lvbmApIHRvIHRoZSBgbGVuZ3RoYCwgaWYgdGhlIGN1cnZlIHdhcyBhcyBsb25nIGFzIGFwcHJveGltYXRlZFxuICAgIC8vIEFzIGEgcnVsZSBvZiB0aHVtYiwgaW5jcmVhc2luZyBgcHJlY2lzaW9uYCBieSAxIGNhdXNlcyB0aGUgYWxnb3JpdGhtIHRvIGdvIDJeKHByZWNpc2lvbiAtIDEpIGRlZXBlclxuICAgIC8vIC0gUHJlY2lzaW9uIDAgKGNob29zZXMgb25lIG9mIHRoZSB0d28gZW5kcG9pbnRzKSAtIDAgbGV2ZWxzXG4gICAgLy8gLSBQcmVjaXNpb24gMSAoY2hvb3NlcyBvbmUgb2YgNSBwb2ludHMsIDwxMCUgZXJyb3IpIC0gMSBsZXZlbFxuICAgIC8vIC0gUHJlY2lzaW9uIDIgKDwxJSBlcnJvcikgLSAzIGxldmVsc1xuICAgIC8vIC0gUHJlY2lzaW9uIDMgKDwwLjElIGVycm9yKSAtIDcgbGV2ZWxzXG4gICAgLy8gLSBQcmVjaXNpb24gNCAoPDAuMDElIGVycm9yKSAtIDE1IGxldmVsc1xuICAgIHRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgLy8gaWRlbnRpZnkgdGhlIHN1YmRpdmlzaW9uIHRoYXQgY29udGFpbnMgdGhlIHBvaW50IGF0IHJlcXVlc3RlZCBgbGVuZ3RoYDpcbiAgICAgICAgdmFyIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uO1xuICAgICAgICB2YXIgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQ7IC8vIGFzc3VtZSB0aGF0IHN1YmRpdmlzaW9ucyBhcmUgZXZlbmx5IHNwYWNlZFxuICAgICAgICB2YXIgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUO1xuICAgICAgICAvL3ZhciBiYXNlbGluZTsgLy8gc3RyYWlnaHRlbmVkIHZlcnNpb24gb2Ygc3ViZGl2aXNpb24gdG8gaW52ZXN0aWdhdGVcbiAgICAgICAgLy92YXIgYmFzZWxpbmVQb2ludDsgLy8gcG9pbnQgb24gdGhlIGJhc2VsaW5lIHRoYXQgaXMgdGhlIHJlcXVlc3RlZCBkaXN0YW5jZSBhd2F5IGZyb20gc3RhcnRcbiAgICAgICAgdmFyIGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0OyAvLyBkaXN0YW5jZSBvZiBiYXNlbGluZVBvaW50IGZyb20gc3RhcnQgb2YgYmFzZWxpbmVcbiAgICAgICAgdmFyIGJhc2VsaW5lUG9pbnREaXN0RnJvbUVuZDsgLy8gZGlzdGFuY2Ugb2YgYmFzZWxpbmVQb2ludCBmcm9tIGVuZCBvZiBiYXNlbGluZVxuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgdmFyIG4gPSBzdWJkaXZpc2lvbnMubGVuZ3RoO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25TaXplID0gMSAvIG47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChuIC0gMSAtIGkpKTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBkID0gY3VycmVudFN1YmRpdmlzaW9uLmVuZHBvaW50RGlzdGFuY2UoKTsgLy8gbGVuZ3RoIG9mIGN1cnJlbnQgc3ViZGl2aXNpb25cblxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24gPSBjdXJyZW50U3ViZGl2aXNpb247XG5cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VCA9IGluZGV4ICogc3ViZGl2aXNpb25TaXplO1xuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVCA9IChpbmRleCArIDEpICogc3ViZGl2aXNpb25TaXplO1xuXG4gICAgICAgICAgICAgICAgYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgPSAoZnJvbVN0YXJ0ID8gKGxlbmd0aCAtIGwpIDogKChkICsgbCkgLSBsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBiYXNlbGluZVBvaW50RGlzdEZyb21FbmQgPSAoZnJvbVN0YXJ0ID8gKChkICsgbCkgLSBsZW5ndGgpIDogKGxlbmd0aCAtIGwpKTtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsICs9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludmVzdGlnYXRlZFN1YmRpdmlzaW9uKSByZXR1cm4gKGZyb21TdGFydCA/IDEgOiAwKTsgLy8gbGVuZ3RoIHJlcXVlc3RlZCBpcyBvdXQgb2YgcmFuZ2UgLSByZXR1cm4gbWF4aW11bSB0XG4gICAgICAgIC8vIG5vdGUgdGhhdCBwcmVjaXNpb24gYWZmZWN0cyB3aGF0IGxlbmd0aCBpcyByZWNvcmRlZFxuICAgICAgICAvLyAoaW1wcmVjaXNlIG1lYXN1cmVtZW50cyB1bmRlcmVzdGltYXRlIGxlbmd0aCBieSB1cCB0byAxMF4oLXByZWNpc2lvbikgb2YgdGhlIHByZWNpc2UgbGVuZ3RoKVxuICAgICAgICAvLyBlLmcuIGF0IHByZWNpc2lvbiAxLCB0aGUgbGVuZ3RoIG1heSBiZSB1bmRlcmVzdGltYXRlZCBieSB1cCB0byAxMCUgYW5kIGNhdXNlIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIDFcblxuICAgICAgICB2YXIgY3VydmVMZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG5cbiAgICAgICAgdmFyIHByZWNpc2lvblJhdGlvID0gcG93KDEwLCAtcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyByZWN1cnNpdmVseSBkaXZpZGUgaW52ZXN0aWdhdGVkIHN1YmRpdmlzaW9uOlxuICAgICAgICAvLyB1bnRpbCBkaXN0YW5jZSBiZXR3ZWVuIGJhc2VsaW5lUG9pbnQgYW5kIGNsb3Nlc3QgcGF0aCBlbmRwb2ludCBpcyB3aXRoaW4gMTBeKC1wcmVjaXNpb24pXG4gICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBjbG9zZXN0IGVuZHBvaW50IG9mIHRoYXQgZmluYWwgc3ViZGl2aXNpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSByZWFjaGVkIHJlcXVpcmVkIG9ic2VydmVkIHByZWNpc2lvblxuICAgICAgICAgICAgdmFyIG9ic2VydmVkUHJlY2lzaW9uUmF0aW87XG5cbiAgICAgICAgICAgIG9ic2VydmVkUHJlY2lzaW9uUmF0aW8gPSAoKGN1cnZlTGVuZ3RoICE9PSAwKSA/IChiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCAvIGN1cnZlTGVuZ3RoKSA6IDApO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkUHJlY2lzaW9uUmF0aW8gPCBwcmVjaXNpb25SYXRpbykgcmV0dXJuIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUO1xuICAgICAgICAgICAgb2JzZXJ2ZWRQcmVjaXNpb25SYXRpbyA9ICgoY3VydmVMZW5ndGggIT09IDApID8gKGJhc2VsaW5lUG9pbnREaXN0RnJvbUVuZCAvIGN1cnZlTGVuZ3RoKSA6IDApO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVkUHJlY2lzaW9uUmF0aW8gPCBwcmVjaXNpb25SYXRpbykgcmV0dXJuIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVDtcblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBzZXQgdXAgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YXIgbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQ7XG4gICAgICAgICAgICB2YXIgbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tRW5kO1xuXG4gICAgICAgICAgICB2YXIgZGl2aWRlZCA9IGludmVzdGlnYXRlZFN1YmRpdmlzaW9uLmRpdmlkZSgwLjUpO1xuICAgICAgICAgICAgc3ViZGl2aXNpb25TaXplIC89IDI7XG5cbiAgICAgICAgICAgIHZhciBiYXNlbGluZTFMZW5ndGggPSBkaXZpZGVkWzBdLmVuZHBvaW50RGlzdGFuY2UoKTtcbiAgICAgICAgICAgIHZhciBiYXNlbGluZTJMZW5ndGggPSBkaXZpZGVkWzFdLmVuZHBvaW50RGlzdGFuY2UoKTtcblxuICAgICAgICAgICAgaWYgKGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0IDw9IGJhc2VsaW5lMUxlbmd0aCkgeyAvLyBwb2ludCBhdCByZXF1ZXN0ZWQgbGVuZ3RoIGlzIGluc2lkZSBkaXZpZGVkWzBdXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24gPSBkaXZpZGVkWzBdO1xuXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUIC09IHN1YmRpdmlzaW9uU2l6ZTsgLy8gc3VkaXZpc2lvblNpemUgd2FzIGFscmVhZHkgaGFsdmVkXG5cbiAgICAgICAgICAgICAgICBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCA9IGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0O1xuICAgICAgICAgICAgICAgIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbUVuZCA9IGJhc2VsaW5lMUxlbmd0aCAtIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0O1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBwb2ludCBhdCByZXF1ZXN0ZWQgbGVuZ3RoIGlzIGluc2lkZSBkaXZpZGVkWzFdXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24gPSBkaXZpZGVkWzFdO1xuXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQgKz0gc3ViZGl2aXNpb25TaXplOyAvLyBzdWJkaXZpc2lvblNpemUgd2FzIGFscmVhZHkgaGFsdmVkXG5cbiAgICAgICAgICAgICAgICBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCA9IGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0IC0gYmFzZWxpbmUxTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbUVuZCA9IGJhc2VsaW5lMkxlbmd0aCAtIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCA9IG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0O1xuICAgICAgICAgICAgYmFzZWxpbmVQb2ludERpc3RGcm9tRW5kID0gbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tRW5kO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgcG9pbnRzIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VydmUgd2hlbiBmbGF0dGVuZWQsIHVwIHRvIGBvcHQucHJlY2lzaW9uYDsgb3IgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIEZsYXR0ZW5lZCBsZW5ndGggaXMgbm8gbW9yZSB0aGFuIDEwXigtcHJlY2lzaW9uKSBhd2F5IGZyb20gcmVhbCBjdXJ2ZSBsZW5ndGguXG4gICAgdG9Qb2ludHM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uOyAvLyBvcHQucHJlY2lzaW9uIG9ubHkgdXNlZCBpbiBnZXRTdWJkaXZpc2lvbnMoKSBjYWxsXG4gICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSAob3B0LnN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgcG9pbnRzID0gW3N1YmRpdmlzaW9uc1swXS5zdGFydC5jbG9uZSgpXTtcbiAgICAgICAgdmFyIG4gPSBzdWJkaXZpc2lvbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFN1YmRpdmlzaW9uID0gc3ViZGl2aXNpb25zW2ldO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3VycmVudFN1YmRpdmlzaW9uLmVuZC5jbG9uZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBwb2x5bGluZSB0aGF0IHJlcHJlc2VudHMgdGhlIGN1cnZlIHdoZW4gZmxhdHRlbmVkLCB1cCB0byBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBGbGF0dGVuZWQgbGVuZ3RoIGlzIG5vIG1vcmUgdGhhbiAxMF4oLXByZWNpc2lvbikgYXdheSBmcm9tIHJlYWwgY3VydmUgbGVuZ3RoLlxuICAgIHRvUG9seWxpbmU6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUodGhpcy50b1BvaW50cyhvcHQpKTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgJyAnICsgdGhpcy5jb250cm9sUG9pbnQxICsgJyAnICsgdGhpcy5jb250cm9sUG9pbnQyICsgJyAnICsgdGhpcy5lbmQ7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuZW5kLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5DdXJ2ZS5wcm90b3R5cGUuZGl2aWRlID0gQ3VydmUucHJvdG90eXBlLmRpdmlkZUF0VDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/curve.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/g/ellipse.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse),\n/* harmony export */   ellipse: () => (/* binding */ ellipse)\n/* harmony export */ });\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\nconst {\n    sqrt,\n    round,\n    pow\n} = Math;\n\nconst Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Ellipse,\n\n    bbox: function() {\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this));\n        var mDir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p);\n\n        if (angle) p.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\n// For backwards compatibility:\nconst ellipse = Ellipse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvZWxsaXBzZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0M7QUFDRTtBQUNBOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUs7O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDZDQUFLO0FBQ3BDOztBQUVBLFlBQVksNkNBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLDJDQUFJO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSw2Q0FBSzs7QUFFZjs7QUFFQSxtQkFBbUIsMkNBQUk7QUFDdkIsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBLG1CQUFtQiw2Q0FBSztBQUN4QixLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkNBQUs7QUFDMUMsdUJBQXVCLDZDQUFLO0FBQzVCLHdCQUF3Qiw2Q0FBSzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUEsZ0JBQWdCLDZDQUFLOztBQUVyQixnQ0FBZ0MsNkNBQUs7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELDZDQUFLO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw2Q0FBSzs7QUFFMUIsNENBQTRDLDZDQUFLO0FBQ2pEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw2Q0FBSzs7QUFFekIsS0FBSzs7QUFFTDs7QUFFQSxvQkFBb0IsNkNBQUs7QUFDekI7QUFDQTs7QUFFQTtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9lbGxpcHNlLm1qcz80N2Q1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBzcXJ0LFxuICAgIHJvdW5kLFxuICAgIHBvd1xufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBFbGxpcHNlID0gZnVuY3Rpb24oYywgYSwgYikge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVsbGlwc2UpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWxsaXBzZShjLCBhLCBiKTtcbiAgICB9XG5cbiAgICBpZiAoYyBpbnN0YW5jZW9mIEVsbGlwc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKG5ldyBQb2ludChjLngsIGMueSksIGMuYSwgYy5iKTtcbiAgICB9XG5cbiAgICBjID0gbmV3IFBvaW50KGMpO1xuICAgIHRoaXMueCA9IGMueDtcbiAgICB0aGlzLnkgPSBjLnk7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xufTtcblxuRWxsaXBzZS5mcm9tUmVjdCA9IGZ1bmN0aW9uKHJlY3QpIHtcblxuICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0KTtcbiAgICByZXR1cm4gbmV3IEVsbGlwc2UocmVjdC5jZW50ZXIoKSwgcmVjdC53aWR0aCAvIDIsIHJlY3QuaGVpZ2h0IC8gMik7XG59O1xuXG5FbGxpcHNlLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLkVsbGlwc2UsXG5cbiAgICBiYm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy54IC0gdGhpcy5hLCB0aGlzLnkgLSB0aGlzLmIsIDIgKiB0aGlzLmEsIDIgKiB0aGlzLmIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Zy5Qb2ludH1cbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2cuUG9pbnR9IHBcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZERpc3RhbmNlKHApIDw9IDE7XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24oZWxsaXBzZSkge1xuXG4gICAgICAgIHJldHVybiAhIWVsbGlwc2UgJiZcbiAgICAgICAgICAgIGVsbGlwc2UueCA9PT0gdGhpcy54ICYmXG4gICAgICAgICAgICBlbGxpcHNlLnkgPT09IHRoaXMueSAmJlxuICAgICAgICAgICAgZWxsaXBzZS5hID09PSB0aGlzLmEgJiZcbiAgICAgICAgICAgIGVsbGlwc2UuYiA9PT0gdGhpcy5iO1xuICAgIH0sXG5cbiAgICAvLyBpbmZsYXRlIGJ5IGR4IGFuZCBkeVxuICAgIC8vIEBwYXJhbSBkeCB7ZGVsdGFfeH0gcmVwcmVzZW50aW5nIGFkZGl0aW9uYWwgc2l6ZSB0byB4XG4gICAgLy8gQHBhcmFtIGR5IHtkZWx0YV95fSByZXByZXNlbnRpbmcgYWRkaXRpb25hbCBzaXplIHRvIHkgLVxuICAgIC8vIGR5IHBhcmFtIGlzIG5vdCByZXF1aXJlZCAtPiBpbiB0aGF0IGNhc2UgeSBpcyBzaXplZCBieSBkeFxuICAgIGluZmxhdGU6IGZ1bmN0aW9uKGR4LCBkeSkge1xuICAgICAgICBpZiAoZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR5ID0gZHg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmEgKz0gMiAqIGR4O1xuICAgICAgICB0aGlzLmIgKz0gMiAqIGR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZTogZnVuY3Rpb24obGluZSkge1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIHZhciBhMSA9IGxpbmUuc3RhcnQ7XG4gICAgICAgIHZhciBhMiA9IGxpbmUuZW5kO1xuICAgICAgICB2YXIgcnggPSB0aGlzLmE7XG4gICAgICAgIHZhciByeSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGRpciA9IGxpbmUudmVjdG9yKCk7XG4gICAgICAgIHZhciBkaWZmID0gYTEuZGlmZmVyZW5jZShuZXcgUG9pbnQodGhpcykpO1xuICAgICAgICB2YXIgbURpciA9IG5ldyBQb2ludChkaXIueCAvIChyeCAqIHJ4KSwgZGlyLnkgLyAocnkgKiByeSkpO1xuICAgICAgICB2YXIgbURpZmYgPSBuZXcgUG9pbnQoZGlmZi54IC8gKHJ4ICogcngpLCBkaWZmLnkgLyAocnkgKiByeSkpO1xuXG4gICAgICAgIHZhciBhID0gZGlyLmRvdChtRGlyKTtcbiAgICAgICAgdmFyIGIgPSBkaXIuZG90KG1EaWZmKTtcbiAgICAgICAgdmFyIGMgPSBkaWZmLmRvdChtRGlmZikgLSAxLjA7XG4gICAgICAgIHZhciBkID0gYiAqIGIgLSBhICogYztcblxuICAgICAgICBpZiAoZCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHNxcnQoZCk7XG4gICAgICAgICAgICB2YXIgdGEgPSAoLWIgLSByb290KSAvIGE7XG4gICAgICAgICAgICB2YXIgdGIgPSAoLWIgKyByb290KSAvIGE7XG5cbiAgICAgICAgICAgIGlmICgodGEgPCAwIHx8IDEgPCB0YSkgJiYgKHRiIDwgMCB8fCAxIDwgdGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKCh0YSA8IDAgJiYgdGIgPCAwKSB8fCAodGEgPiAxICYmIHRiID4gMSkpIG91dHNpZGUgZWxzZSBpbnNpZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gdGEgJiYgdGEgPD0gMSkgaW50ZXJzZWN0aW9ucy5wdXNoKGExLmxlcnAoYTIsIHRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPD0gdGIgJiYgdGIgPD0gMSkgaW50ZXJzZWN0aW9ucy5wdXNoKGExLmxlcnAoYTIsIHRiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdCA9IC1iIC8gYTtcbiAgICAgICAgICAgIGlmICgwIDw9IHQgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGExLmxlcnAoYTIsIHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3V0c2lkZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgcG9pbnQgb24gbWUgd2hlcmUgbGluZSBmcm9tIG15IGNlbnRlciB0b1xuICAgIC8vIHBvaW50IHAgaW50ZXJzZWN0cyBteSBib3VuZGFyeS5cbiAgICAvLyBAcGFyYW0ge251bWJlcn0gYW5nbGUgSWYgYW5nbGUgaXMgc3BlY2lmaWVkLCBpbnRlcnNlY3Rpb24gd2l0aCByb3RhdGVkIGVsbGlwc2UgaXMgY29tcHV0ZWQuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludDogZnVuY3Rpb24ocCwgYW5nbGUpIHtcblxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuXG4gICAgICAgIGlmIChhbmdsZSkgcC5yb3RhdGUobmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSwgYW5nbGUpO1xuXG4gICAgICAgIHZhciBkeCA9IHAueCAtIHRoaXMueDtcbiAgICAgICAgdmFyIGR5ID0gcC55IC0gdGhpcy55O1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmIChkeCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5iYm94KCkucG9pbnROZWFyZXN0VG9Qb2ludChwKTtcbiAgICAgICAgICAgIGlmIChhbmdsZSkgcmV0dXJuIHJlc3VsdC5yb3RhdGUobmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSwgLWFuZ2xlKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IGR5IC8gZHg7XG4gICAgICAgIHZhciBtU3F1YXJlZCA9IG0gKiBtO1xuICAgICAgICB2YXIgYVNxdWFyZWQgPSB0aGlzLmEgKiB0aGlzLmE7XG4gICAgICAgIHZhciBiU3F1YXJlZCA9IHRoaXMuYiAqIHRoaXMuYjtcblxuICAgICAgICB2YXIgeCA9IHNxcnQoMSAvICgoMSAvIGFTcXVhcmVkKSArIChtU3F1YXJlZCAvIGJTcXVhcmVkKSkpO1xuICAgICAgICB4ID0gZHggPCAwID8gLXggOiB4O1xuXG4gICAgICAgIHZhciB5ID0gbSAqIHg7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBQb2ludCh0aGlzLnggKyB4LCB0aGlzLnkgKyB5KTtcblxuICAgICAgICBpZiAoYW5nbGUpIHJldHVybiByZXN1bHQucm90YXRlKG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSksIC1hbmdsZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Zy5Qb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSByZXN1bHQgPCAxIC0gaW5zaWRlIGVsbGlwc2UsIHJlc3VsdCA9PSAxIC0gb24gZWxsaXBzZSBib3VuZGFyeSwgcmVzdWx0ID4gMSAtIG91dHNpZGVcbiAgICAgKi9cbiAgICBub3JtYWxpemVkRGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgdmFyIHgwID0gcG9pbnQueDtcbiAgICAgICAgdmFyIHkwID0gcG9pbnQueTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgICAgICAgcmV0dXJuICgoeDAgLSB4KSAqICh4MCAtIHgpKSAvIChhICogYSkgKyAoKHkwIC0geSkgKiAoeTAgLSB5KSkgLyAoYiAqIGIpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgbGV0IGYgPSAxOyAvLyBjYXNlIDBcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGYgPSAxMDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBmID0gMTAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IGYgPSAxMDAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmID0gcG93KDEwLCBwcmVjaXNpb24pOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IHJvdW5kKHRoaXMueCAqIGYpIC8gZjtcbiAgICAgICAgdGhpcy55ID0gcm91bmQodGhpcy55ICogZikgLyBmO1xuICAgICAgICB0aGlzLmEgPSByb3VuZCh0aGlzLmEgKiBmKSAvIGY7XG4gICAgICAgIHRoaXMuYiA9IHJvdW5kKHRoaXMuYiAqIGYpIC8gZjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKiBDb21wdXRlIGFuZ2xlIGJldHdlZW4gdGFuZ2VudCBhbmQgeCBheGlzXG4gICAgICogQHBhcmFtIHtnLlBvaW50fSBwIFBvaW50IG9mIHRhbmdlbmN5LCBpdCBoYXMgdG8gYmUgb24gZWxsaXBzZSBib3VuZGFyaWVzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGJldHdlZW4gdGFuZ2VudCBhbmQgeCBheGlzXG4gICAgICovXG4gICAgdGFuZ2VudFRoZXRhOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIHJlZlBvaW50RGVsdGEgPSAzMDtcbiAgICAgICAgdmFyIHgwID0gcC54O1xuICAgICAgICB2YXIgeTAgPSBwLnk7XG4gICAgICAgIHZhciBhID0gdGhpcy5hO1xuICAgICAgICB2YXIgYiA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYmJveCgpLmNlbnRlcigpO1xuICAgICAgICB2YXIgbSA9IGNlbnRlci54O1xuICAgICAgICB2YXIgbiA9IGNlbnRlci55O1xuXG4gICAgICAgIHZhciBxMSA9IHgwID4gY2VudGVyLnggKyBhIC8gMjtcbiAgICAgICAgdmFyIHEzID0geDAgPCBjZW50ZXIueCAtIGEgLyAyO1xuXG4gICAgICAgIHZhciB5LCB4O1xuICAgICAgICBpZiAocTEgfHwgcTMpIHtcbiAgICAgICAgICAgIHkgPSB4MCA+IGNlbnRlci54ID8geTAgLSByZWZQb2ludERlbHRhIDogeTAgKyByZWZQb2ludERlbHRhO1xuICAgICAgICAgICAgeCA9IChhICogYSAvICh4MCAtIG0pKSAtIChhICogYSAqICh5MCAtIG4pICogKHkgLSBuKSkgLyAoYiAqIGIgKiAoeDAgLSBtKSkgKyBtO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0geTAgPiBjZW50ZXIueSA/IHgwICsgcmVmUG9pbnREZWx0YSA6IHgwIC0gcmVmUG9pbnREZWx0YTtcbiAgICAgICAgICAgIHkgPSAoYiAqIGIgLyAoeTAgLSBuKSkgLSAoYiAqIGIgKiAoeDAgLSBtKSAqICh4IC0gbSkpIC8gKGEgKiBhICogKHkwIC0gbikpICsgbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmV3IFBvaW50KHgsIHkpKS50aGV0YShwKTtcblxuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIChuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpKS50b1N0cmluZygpICsgJyAnICsgdGhpcy5hICsgJyAnICsgdGhpcy5iO1xuICAgIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbmV4cG9ydCBjb25zdCBlbGxpcHNlID0gRWxsaXBzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/extend.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/g/extend.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extend: () => (/* binding */ extend)\n/* harmony export */ });\n// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nfunction extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvZXh0ZW5kLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCwrRkFBK0YsSUFBSSw0Q0FBNEMsSUFBSTtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZLElBQUksY0FBYyxJQUFJLGdCQUFnQixZQUFZLDZCQUE2QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxPQUFPO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsK0VBQStFO0FBQy9FLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvZXh0ZW5kLm1qcz80YzI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIExvY2FsIGhlbHBlciBmdW5jdGlvbi5cbi8vIEFkZCBwcm9wZXJ0aWVzIGZyb20gYXJndW1lbnRzIG9uIHRvcCBvZiBwcm9wZXJ0aWVzIGZyb20gYG9iamAuXG4vLyBUaGlzIGFsbG93cyBmb3IgcnVkaW1lbnRhcnkgaW5oZXJpdGFuY2UuXG4vLyAtIFRoZSBgb2JqYCBhcmd1bWVudCBhY3RzIGFzIHBhcmVudC5cbi8vIC0gVGhpcyBmdW5jdGlvbiBjcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGFsbCBgb2JqYCBwcm9wZXJ0aWVzIGFuZCBhZGRzL3JlcGxhY2VzIHRob3NlIHRoYXQgYXJlIHByZXNlbnQgaW4gYXJndW1lbnRzLlxuLy8gLSBBIGhpZ2gtbGV2ZWwgZXhhbXBsZTogY2FsbGluZyBgZXh0ZW5kKFZlaGljbGUsIENhcilgIHdvdWxkIGJlIGFraW4gdG8gZGVjbGFyaW5nIGBjbGFzcyBDYXIgZXh0ZW5kcyBWZWhpY2xlYC5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQob2JqKSB7XG4gICAgLy8gSW4gSmF2YVNjcmlwdCwgdGhlIGNvbWJpbmF0aW9uIG9mIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gKGUuZy4gYGcuTGluZSA9IGZ1bmN0aW9uKC4uLikgey4uLn1gKSBhbmQgcHJvdG90eXBlIChlLmcuIGBnLkxpbmUucHJvdG90eXBlID0gey4uLn0pIGlzIGFraW4gdG8gYSBDKysgY2xhc3MuXG4gICAgLy8gLSBXaGVuIGluaGVyaXRhbmNlIGlzIG5vdCBuZWNlc3NhcnksIHdlIGNhbiBsZWF2ZSBpdCBhdCB0aGF0LiAoVGhpcyB3b3VsZCBiZSBha2luIHRvIGNhbGxpbmcgZXh0ZW5kIHdpdGggb25seSBgb2JqYC4pXG4gICAgLy8gLSBCdXQsIHdoYXQgaWYgd2Ugd2FudGVkIHRoZSBgZy5MaW5lYCBxdWFzaWNsYXNzIHRvIGluaGVyaXQgZnJvbSBhbm90aGVyIHF1YXNpY2xhc3MgKGxldCdzIGNhbGwgaXQgYGcuR2VvbWV0cnlPYmplY3RgKSBpbiBKYXZhU2NyaXB0P1xuICAgIC8vIC0gRmlyc3QsIHJlYWxpemUgdGhhdCBib3RoIG9mIHRob3NlIHF1YXNpY2xhc3NlcyB3b3VsZCBzdGlsbCBoYXZlIHRoZWlyIG93biBzZXBhcmF0ZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAvLyAtIFNvIHdoYXQgd2UgYXJlIGFjdHVhbGx5IHNheWluZyBpcyB0aGF0IHdlIHdhbnQgdGhlIGBnLkxpbmVgIHByb3RvdHlwZSB0byBpbmhlcml0IGZyb20gYGcuR2VvbWV0cnlPYmplY3RgIHByb3RvdHlwZS5cbiAgICAvLyAtIFRoaXMgbWV0aG9kIHByb3ZpZGVzIGEgd2F5IHRvIGRvIGV4YWN0bHkgdGhhdC5cbiAgICAvLyAtIEl0IGNvcGllcyBwYXJlbnQgcHJvdG90eXBlJ3MgcHJvcGVydGllcywgdGhlbiBhZGRzIGV4dHJhIG9uZXMgZnJvbSBjaGlsZCBwcm90b3R5cGUvb3ZlcnJpZGVzIHBhcmVudCBwcm90b3R5cGUgcHJvcGVydGllcyB3aXRoIGNoaWxkIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICAgIC8vIC0gVGhlcmVmb3JlLCB0byBjb250aW51ZSB3aXRoIHRoZSBleGFtcGxlIGFib3ZlOlxuICAgIC8vICAgLSBgZy5MaW5lLnByb3RvdHlwZSA9IGV4dGVuZChnLkdlb21ldHJ5T2JqZWN0LnByb3RvdHlwZSwgbGluZVByb3RvdHlwZSlgXG4gICAgLy8gICAtIFdoZXJlIGBsaW5lUHJvdG90eXBlYCBpcyBhIHByb3BlcnRpZXMgb2JqZWN0IHRoYXQgbG9va3MganVzdCBsaWtlIGBnLkxpbmUucHJvdG90eXBlYCBkb2VzIHJpZ2h0IG5vdy5cbiAgICAvLyAgIC0gVGhlbiwgYGcuTGluZWAgd291bGQgYWxsb3cgdGhlIHByb2dyYW1tZXIgdG8gYWNjZXNzIHRvIGFsbCBtZXRob2RzIGN1cnJlbnRseSBpbiBgZy5MaW5lLlByb3RvdHlwZWAsIHBsdXMgYW55IG5vbi1vdmVycmlkZGVuIG1ldGhvZHMgZnJvbSBgZy5HZW9tZXRyeU9iamVjdC5wcm90b3R5cGVgLlxuICAgIC8vICAgLSBJbiB0aGF0IGFzcGVjdCwgYGcuR2VvbWV0cnlPYmplY3RgIHdvdWxkIHRoZW4gYWN0IGxpa2UgdGhlIHBhcmVudCBvZiBgZy5MaW5lYC5cbiAgICAvLyAtIE11bHRpcGxlIGluaGVyaXRhbmNlIGlzIGFsc28gcG9zc2libGUsIGlmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAgLy8gLSBXaGF0IGlmIHdlIHdhbnRlZCB0byBhZGQgYW5vdGhlciBsZXZlbCBvZiBhYnN0cmFjdGlvbiBiZXR3ZWVuIGBnLkdlb21ldHJ5T2JqZWN0YCBhbmQgYGcuTGluZWAgKGxldCdzIGNhbGwgaXQgYGcuTGluZWFyT2JqZWN0YCk/XG4gICAgLy8gICAtIGBnLkxpbmUucHJvdG90eXBlID0gZXh0ZW5kKGcuR2VvbWV0cnlPYmplY3QucHJvdG90eXBlLCBnLkxpbmVhck9iamVjdC5wcm90b3R5cGUsIGxpbmVQcm90b3R5cGUpYFxuICAgIC8vICAgLSBUaGUgYW5jZXN0b3JzIGFyZSBhcHBsaWVkIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAgLy8gICAtIFRoYXQgbWVhbnMgdGhhdCBgZy5MaW5lYCB3b3VsZCBoYXZlIGluaGVyaXRlZCBmcm9tIGBnLkxpbmVhck9iamVjdGAgdGhhdCB3b3VsZCBoYXZlIGluaGVyaXRlZCBmcm9tIGBnLkdlb21ldHJ5T2JqZWN0YC5cbiAgICAvLyAgIC0gQW55IG51bWJlciBvZiBhbmNlc3RvcnMgbWF5IGJlIHByb3ZpZGVkLlxuICAgIC8vIC0gTm90ZSB0aGF0IG5laXRoZXIgYG9iamAgbm9yIGFueSBvZiB0aGUgYXJndW1lbnRzIG5lZWQgdG8gYWN0dWFsbHkgYmUgcHJvdG90eXBlcyBvZiBhbnkgSmF2YVNjcmlwdCBxdWFzaWNsYXNzLCB0aGF0IHdhcyBqdXN0IGEgc2ltcGxpZmllZCBleHBsYW5hdGlvbi5cbiAgICAvLyAtIFdlIGNhbiBjcmVhdGUgYSBuZXcgb2JqZWN0IGNvbXBvc2VkIGZyb20gdGhlIHByb3BlcnRpZXMgb2YgYW55IG51bWJlciBvZiBvdGhlciBvYmplY3RzIChzaW5jZSB0aGV5IGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IsIHdlIGNhbiB0aGluayBvZiB0aG9zZSBhcyBpbnRlcmZhY2VzKS5cbiAgICAvLyAgIC0gYGV4dGVuZCh7IGE6IDEsIGI6IDIgfSwgeyBiOiAxMCwgYzogMjAgfSwgeyBjOiAxMDAsIGQ6IDIwMCB9KWAgZ2l2ZXMgYHsgYTogMSwgYjogMTAsIGM6IDEwMCwgZDogMjAwIH1gLlxuICAgIC8vICAgLSBCYXNpY2FsbHksIHdpdGggdGhpcyBmdW5jdGlvbiwgd2UgY2FuIGVtdWxhdGUgdGhlIGBleHRlbmRzYCBrZXl3b3JkIGFzIHdlbGwgYXMgdGhlIGBpbXBsZW1lbnRzYCBrZXl3b3JkLlxuICAgIC8vIC0gVGhlcmVmb3JlLCBib3RoIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHZhbGlkOlxuICAgIC8vICAgLSBgTGluZXRvLnByb3RvdHlwZSA9IGV4dGVuZChMaW5lLnByb3RvdHlwZSwgc2VnbWVudFByb3RvdHlwZSwgbGluZXRvUHJvdG90eXBlKWBcbiAgICAvLyAgIC0gYE1vdmV0by5wcm90b3R5cGUgPSBleHRlbmQoc2VnbWVudFByb3RvdHlwZSwgbW92ZXRvUHJvdG90eXBlKWBcblxuICAgIHZhciBpO1xuICAgIHZhciBuO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7IC8vIHNraXAgb3ZlciBvYmpcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCFvYmopIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBhIHBhcmVudCBvYmplY3QuJyk7XG4gICAgdmFyIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShvYmopO1xuXG4gICAgbiA9IGFyZ3MubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICB2YXIgc3JjID0gYXJnc1tpXTtcblxuICAgICAgICB2YXIgaW5oZXJpdGVkUHJvcGVydHk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIHNyYykge1xuXG4gICAgICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hpbGRba2V5XTsgLy8gZGVsZXRlIHByb3BlcnR5IGluaGVyaXRlZCBmcm9tIHBhcmVudFxuICAgICAgICAgICAgICAgIGluaGVyaXRlZFByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzcmMsIGtleSk7IC8vIGdldCBuZXcgZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eSBmcm9tIHNyY1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwga2V5LCBpbmhlcml0ZWRQcm9wZXJ0eSk7IC8vIHJlLWFkZCBwcm9wZXJ0eSB3aXRoIG5ldyBkZWZpbml0aW9uIChpbmNsdWRlcyBnZXR0ZXIvc2V0dGVyIG1ldGhvZHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/extend.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/g/geometry.helpers.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeAngle: () => (/* binding */ normalizeAngle),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   scale: () => (/* binding */ scale),\n/* harmony export */   snapToGrid: () => (/* binding */ snapToGrid),\n/* harmony export */   toDeg: () => (/* binding */ toDeg),\n/* harmony export */   toRad: () => (/* binding */ toRad)\n/* harmony export */ });\n// Declare shorthands to the most used math functions.\nconst {\n    round,\n    floor,\n    PI\n} = Math;\n\nconst scale = {\n\n    // Return the `value` from the `domain` interval scaled to the `range` interval.\n    linear: function(domain, range, value) {\n\n        var domainSpan = domain[1] - domain[0];\n        var rangeSpan = range[1] - range[0];\n        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n    }\n};\n\nconst normalizeAngle = function(angle) {\n\n    return (angle % 360) + (angle < 0 ? 360 : 0);\n};\n\nconst snapToGrid = function(value, gridSize) {\n\n    return gridSize * round(value / gridSize);\n};\n\nconst toDeg = function(rad) {\n\n    return (180 * rad / PI) % 360;\n};\n\nconst toRad = function(deg, over360) {\n\n    over360 = over360 || false;\n    deg = over360 ? deg : (deg % 360);\n    return deg * PI / 180;\n};\n\n// Return a random integer from the interval [min,max], inclusive.\nconst random = function(min, max) {\n\n    if (max === undefined) {\n        // use first argument as max, min is 0\n        max = (min === undefined) ? 1 : min;\n        min = 0;\n\n    } else if (max < min) {\n        // switch max and min\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n\n    return floor((Math.random() * (max - min + 1)) + min);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvZ2VvbWV0cnkuaGVscGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUs7O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvZ2VvbWV0cnkuaGVscGVycy5tanM/ZWY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEZWNsYXJlIHNob3J0aGFuZHMgdG8gdGhlIG1vc3QgdXNlZCBtYXRoIGZ1bmN0aW9ucy5cbmNvbnN0IHtcbiAgICByb3VuZCxcbiAgICBmbG9vcixcbiAgICBQSVxufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBzY2FsZSA9IHtcblxuICAgIC8vIFJldHVybiB0aGUgYHZhbHVlYCBmcm9tIHRoZSBgZG9tYWluYCBpbnRlcnZhbCBzY2FsZWQgdG8gdGhlIGByYW5nZWAgaW50ZXJ2YWwuXG4gICAgbGluZWFyOiBmdW5jdGlvbihkb21haW4sIHJhbmdlLCB2YWx1ZSkge1xuXG4gICAgICAgIHZhciBkb21haW5TcGFuID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xuICAgICAgICB2YXIgcmFuZ2VTcGFuID0gcmFuZ2VbMV0gLSByYW5nZVswXTtcbiAgICAgICAgcmV0dXJuICgoKHZhbHVlIC0gZG9tYWluWzBdKSAvIGRvbWFpblNwYW4pICogcmFuZ2VTcGFuICsgcmFuZ2VbMF0pIHx8IDA7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUFuZ2xlID0gZnVuY3Rpb24oYW5nbGUpIHtcblxuICAgIHJldHVybiAoYW5nbGUgJSAzNjApICsgKGFuZ2xlIDwgMCA/IDM2MCA6IDApO1xufTtcblxuZXhwb3J0IGNvbnN0IHNuYXBUb0dyaWQgPSBmdW5jdGlvbih2YWx1ZSwgZ3JpZFNpemUpIHtcblxuICAgIHJldHVybiBncmlkU2l6ZSAqIHJvdW5kKHZhbHVlIC8gZ3JpZFNpemUpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvRGVnID0gZnVuY3Rpb24ocmFkKSB7XG5cbiAgICByZXR1cm4gKDE4MCAqIHJhZCAvIFBJKSAlIDM2MDtcbn07XG5cbmV4cG9ydCBjb25zdCB0b1JhZCA9IGZ1bmN0aW9uKGRlZywgb3ZlcjM2MCkge1xuXG4gICAgb3ZlcjM2MCA9IG92ZXIzNjAgfHwgZmFsc2U7XG4gICAgZGVnID0gb3ZlcjM2MCA/IGRlZyA6IChkZWcgJSAzNjApO1xuICAgIHJldHVybiBkZWcgKiBQSSAvIDE4MDtcbn07XG5cbi8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGZyb20gdGhlIGludGVydmFsIFttaW4sbWF4XSwgaW5jbHVzaXZlLlxuZXhwb3J0IGNvbnN0IHJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG5cbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXNlIGZpcnN0IGFyZ3VtZW50IGFzIG1heCwgbWluIGlzIDBcbiAgICAgICAgbWF4ID0gKG1pbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiBtaW47XG4gICAgICAgIG1pbiA9IDA7XG5cbiAgICB9IGVsc2UgaWYgKG1heCA8IG1pbikge1xuICAgICAgICAvLyBzd2l0Y2ggbWF4IGFuZCBtaW5cbiAgICAgICAgY29uc3QgdGVtcCA9IG1pbjtcbiAgICAgICAgbWluID0gbWF4O1xuICAgICAgICBtYXggPSB0ZW1wO1xuICAgIH1cblxuICAgIHJldHVybiBmbG9vcigoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW4pO1xufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Curve: () => (/* reexport safe */ _curve_mjs__WEBPACK_IMPORTED_MODULE_2__.Curve),\n/* harmony export */   Ellipse: () => (/* reexport safe */ _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__.Ellipse),\n/* harmony export */   Line: () => (/* reexport safe */ _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line),\n/* harmony export */   Path: () => (/* reexport safe */ _path_mjs__WEBPACK_IMPORTED_MODULE_5__.Path),\n/* harmony export */   Point: () => (/* reexport safe */ _point_mjs__WEBPACK_IMPORTED_MODULE_6__.Point),\n/* harmony export */   Polygon: () => (/* reexport safe */ _polygon_mjs__WEBPACK_IMPORTED_MODULE_8__.Polygon),\n/* harmony export */   Polyline: () => (/* reexport safe */ _polyline_mjs__WEBPACK_IMPORTED_MODULE_7__.Polyline),\n/* harmony export */   Rect: () => (/* reexport safe */ _rect_mjs__WEBPACK_IMPORTED_MODULE_9__.Rect),\n/* harmony export */   bezier: () => (/* reexport safe */ _bezier_mjs__WEBPACK_IMPORTED_MODULE_1__.bezier),\n/* harmony export */   ellipse: () => (/* reexport safe */ _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__.ellipse),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   line: () => (/* reexport safe */ _line_mjs__WEBPACK_IMPORTED_MODULE_4__.line),\n/* harmony export */   normalizeAngle: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle),\n/* harmony export */   point: () => (/* reexport safe */ _point_mjs__WEBPACK_IMPORTED_MODULE_6__.point),\n/* harmony export */   random: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random),\n/* harmony export */   rect: () => (/* reexport safe */ _rect_mjs__WEBPACK_IMPORTED_MODULE_9__.rect),\n/* harmony export */   scale: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.scale),\n/* harmony export */   snapToGrid: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid),\n/* harmony export */   toDeg: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg),\n/* harmony export */   toRad: () => (/* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad),\n/* harmony export */   types: () => (/* reexport safe */ _types_mjs__WEBPACK_IMPORTED_MODULE_10__.types)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _bezier_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/bezier.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipse.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polygon.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polygon.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _intersection_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./intersection.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/intersection.mjs\");\n// Geometry library.\n// -----------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst intersection = _intersection_mjs__WEBPACK_IMPORTED_MODULE_11__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRXVDO0FBQ1Y7QUFDRDtBQUNFO0FBQ0g7QUFDQTtBQUNDO0FBQ0c7QUFDRDtBQUNIO0FBQ0M7O0FBRXdCO0FBQzdDLHFCQUFxQiwrQ0FBYSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvaW5kZXgubWpzPzAzMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VvbWV0cnkgbGlicmFyeS5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCAqIGZyb20gJy4vZ2VvbWV0cnkuaGVscGVycy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9iZXppZXIubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vY3VydmUubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vZWxsaXBzZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saW5lLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BhdGgubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcG9pbnQubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcG9seWxpbmUubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcG9seWdvbi5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWN0Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmltcG9ydCAqIGFzIF9pbnRlcnNlY3Rpb24gZnJvbSAnLi9pbnRlcnNlY3Rpb24ubWpzJztcbmV4cG9ydCBjb25zdCBpbnRlcnNlY3Rpb24gPSBfaW50ZXJzZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/intersection.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/g/intersection.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ellipseWithEllipse: () => (/* binding */ ellipseWithEllipse),\n/* harmony export */   ellipseWithLine: () => (/* binding */ ellipseWithLine),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   lineWithLine: () => (/* binding */ lineWithLine),\n/* harmony export */   pathWithEllipse: () => (/* binding */ pathWithEllipse),\n/* harmony export */   pathWithLine: () => (/* binding */ pathWithLine),\n/* harmony export */   pathWithPath: () => (/* binding */ pathWithPath),\n/* harmony export */   pathWithPolygon: () => (/* binding */ pathWithPolygon),\n/* harmony export */   pathWithPolyline: () => (/* binding */ pathWithPolyline),\n/* harmony export */   pathWithRect: () => (/* binding */ pathWithRect),\n/* harmony export */   polygonWithEllipse: () => (/* binding */ polygonWithEllipse),\n/* harmony export */   polygonWithLine: () => (/* binding */ polygonWithLine),\n/* harmony export */   polygonWithPolygon: () => (/* binding */ polygonWithPolygon),\n/* harmony export */   polygonWithPolyline: () => (/* binding */ polygonWithPolyline),\n/* harmony export */   polygonWithRect: () => (/* binding */ polygonWithRect),\n/* harmony export */   polylineWithEllipse: () => (/* binding */ polylineWithEllipse),\n/* harmony export */   polylineWithLine: () => (/* binding */ polylineWithLine),\n/* harmony export */   polylineWithPolyline: () => (/* binding */ polylineWithPolyline),\n/* harmony export */   polylineWithRect: () => (/* binding */ polylineWithRect),\n/* harmony export */   rectWithEllipse: () => (/* binding */ rectWithEllipse),\n/* harmony export */   rectWithLine: () => (/* binding */ rectWithLine),\n/* harmony export */   rectWithRect: () => (/* binding */ rectWithRect)\n/* harmony export */ });\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polygon.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\nfunction exists(shape1, shape2, shape1opt, shape2opt) {\n    switch (shape1.type) {\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return lineWithLine(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return ellipseWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return ellipseWithEllipse(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return rectWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return rectWithEllipse(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return rectWithRect(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return polylineWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return polylineWithEllipse(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return polylineWithRect(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n                    return polylineWithPolyline(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return polygonWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return polygonWithEllipse(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return polygonWithRect(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n                    return polygonWithPolyline(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon: {\n                    return polygonWithPolygon(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return pathWithLine(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return pathWithEllipse(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return pathWithRect(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n                    return pathWithPolyline(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon: {\n                    return pathWithPolygon(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path: {\n                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                }\n            }\n            break;\n        }\n    }\n    // None of the cases above\n    switch (shape2.type) {\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path: {\n            return exists(shape2, shape1, shape2opt, shape1opt);\n        }\n        default: {\n            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n        }\n    }\n}\n\n/* Line */\n\nfunction lineWithLine(line1, line2) {\n    const x1 = line1.start.x;\n    const y1 = line1.start.y;\n    const x2 = line1.end.x;\n    const y2 = line1.end.y;\n    const x3 = line2.start.x;\n    const y3 = line2.start.y;\n    const x4 = line2.end.x;\n    const y4 = line2.end.y;\n    const s1x = x2 - x1;\n    const s1y = y2 - y1;\n    const s2x = x4 - x3;\n    const s2y = y4 - y3;\n    const s3x = x1 - x3;\n    const s3y = y1 - y3;\n    const p = s1x * s2y - s2x * s1y;\n    const s = (s1x * s3y - s1y * s3x) / p;\n    const t = (s2x * s3y - s2y * s3x) / p;\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/* Ellipse */\n\nfunction ellipseWithLine(ellipse, line) {\n    const rex = ellipse.a;\n    const rey = ellipse.b;\n    const xe = ellipse.x;\n    const ye = ellipse.y;\n    const x1 = line.start.x - xe;\n    const x2 = line.end.x - xe;\n    const y1 = line.start.y - ye;\n    const y2 = line.end.y - ye;\n    const rex_2 = rex * rex;\n    const rey_2 = rey * rey;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const A = dx * dx / rex_2 + dy * dy / rey_2;\n    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n    const D = B * B - 4 * A * C;\n    if (D === 0) {\n        const t = -B / 2 / A;\n        return t >= 0 && t <= 1;\n    } else if (D > 0) {\n        const sqrt = Math.sqrt(D);\n        const t1 = (-B + sqrt) / 2 / A;\n        const t2 = (-B - sqrt) / 2 / A;\n        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);\n    }\n    return false;\n}\n\nfunction ellipseWithEllipse(ellipse1, ellipse2) {\n    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n\n/* Rect */\n\nfunction rectWithLine(rect, line) {\n    const { start, end } = line;\n    const { x, y, width, height } = rect;\n    if (\n        (start.x > x + width && end.x > x + width)\n        || (start.x < x && end.x < x)\n        || (start.y > y + height && end.y > y + height)\n        || (start.y < y && end.y < y)\n    ) {\n        return false;\n    }\n    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n        return true;\n    }\n    return lineWithLine(rect.topLine(), line)\n        || lineWithLine(rect.rightLine(), line)\n        || lineWithLine(rect.bottomLine(), line)\n        || lineWithLine(rect.leftLine(), line);\n}\n\nfunction rectWithEllipse(rect, ellipse) {\n    if (!rectWithRect(rect, _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect.fromEllipse(ellipse))) return false;\n    return polygonWithEllipse(_polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect), ellipse);\n}\n\nfunction rectWithRect(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width\n        && rect1.x + rect1.width > rect2.x\n        && rect1.y < rect2.y + rect2.height\n        && rect1.y + rect1.height > rect2.y;\n}\n\n/* Polyline */\n\nfunction polylineWithLine(polyline, line) {\n    return _polylineWithLine(polyline, line, { interior: false });\n}\n\nfunction polylineWithEllipse(polyline, ellipse) {\n    return _polylineWithEllipse(polyline, ellipse, { interior: false });\n}\n\nfunction polylineWithRect(polyline, rect) {\n    return _polylineWithRect(polyline, rect, { interior: false });\n}\n\nfunction polylineWithPolyline(polyline1, polyline2) {\n    return _polylineWithPolyline(polyline1, polyline2, { interior: false });\n}\n\n/* Polygon */\n\nfunction polygonWithLine(polygon, line) {\n    return _polylineWithLine(polygon, line, { interior: true });\n}\n\nfunction polygonWithEllipse(polygon, ellipse) {\n    return _polylineWithEllipse(polygon, ellipse, { interior: true });\n}\n\nfunction polygonWithRect(polygon, rect) {\n    return _polylineWithRect(polygon, rect, { interior: true });\n}\n\nfunction polygonWithPolyline(polygon, polyline) {\n    return _polylineWithPolyline(polygon, polyline, { interior: true });\n}\n\nfunction polygonWithPolygon(polygon1, polygon2) {\n    return _polylineWithPolygon(polygon1, polygon2, { interior: true });\n}\n\n/* Path */\n\nfunction pathWithLine(path, line, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithLine(polyline, line);\n        } else {\n            return polylineWithLine(polyline, line);\n        }\n    });\n}\n\nfunction pathWithEllipse(path, ellipse, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithEllipse(polyline, ellipse);\n        } else {\n            return polylineWithEllipse(polyline, ellipse);\n        }\n    });\n}\n\nfunction pathWithRect(path, rect, pathOpt) {\n    return pathWithPolygon(path, _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect), pathOpt);\n}\n\nfunction pathWithPolyline(path, polyline, pathOpt) {\n    return _pathWithPolyline(path, polyline, pathOpt, { interior: false });\n}\n\nfunction pathWithPolygon(path, polygon, pathOpt) {\n    return _pathWithPolyline(path, polygon, pathOpt, { interior: true });\n}\n\nfunction pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n    return path1.getSubpaths().some(subpath => {\n        const [polyline1] = subpath.toPolylines(pathOpt1);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return pathWithPolygon(path2, polyline1, pathOpt2);\n        } else {\n            return pathWithPolyline(path2, polyline1, pathOpt2);\n        }\n    });\n}\n\nfunction _polylineWithLine(polyline, line, opt = {}) {\n    const { interior = false } = opt;\n    let thisPoints;\n    if (interior) {\n        if (polyline.containsPoint(line.start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        const { start, end, points } = polyline;\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = polyline.points;\n    }\n    const { length } = thisPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (lineWithLine(line, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n    const { start, end, points } = polyline;\n    if (ellipse.containsPoint(start)) {\n        return true;\n    }\n    let thisPoints;\n    const { interior = false } = opt;\n    if (interior) {\n        if (polyline.containsPoint(ellipse.center())) {\n            // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n        }\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = points;\n    }\n\n    const { length } = thisPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (ellipseWithLine(ellipse, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithRect(polyline, rect, opt) {\n    const polygon = _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect);\n    return _polylineWithPolygon(polyline, polygon, opt);\n}\n\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline2] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return _polylineWithPolygon(polyline1, polyline2, opt);\n        } else {\n            return _polylineWithPolyline(polyline1, polyline2, opt);\n        }\n    });\n}\n\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n    const { interior = false } = opt;\n    let thisPolyline;\n    if (interior) {\n        const { start } = polyline2;\n        if (polyline1.containsPoint(start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        thisPolyline = polyline1.clone().close();\n    } else {\n        thisPolyline = polyline1;\n    }\n    const otherPoints = polyline2.points;\n    const { length } = otherPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = otherPoints[i];\n        segment.end = otherPoints[i + 1];\n        if (polylineWithLine(thisPolyline, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\n\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n    const { cos, sin } = Math;\n    const sinW1 = sin(w1);\n    const cosW1 = cos(w1);\n    const sinW2 = sin(w2);\n    const cosW2 = cos(w2);\n    const sinW1s = sinW1 * sinW1;\n    const cosW1s = cosW1 * cosW1;\n    const sinCos1 = sinW1 * cosW1;\n    const sinW2s = sinW2 * sinW2;\n    const cosW2s = cosW2 * cosW2;\n    const sinCos2 = sinW2 * cosW2;\n    const a1s = e1.a * e1.a;\n    const b1s = e1.b * e1.b;\n    const a2s = e2.a * e2.a;\n    const b2s = e2.b * e2.b;\n    const A1 = a1s * sinW1s + b1s * cosW1s;\n    const A2 = a2s * sinW2s + b2s * cosW2s;\n    const B1 = a1s * cosW1s + b1s * sinW1s;\n    const B2 = a2s * cosW2s + b2s * sinW2s;\n    let C1 = 2 * (b1s - a1s) * sinCos1;\n    let C2 = 2 * (b2s - a2s) * sinCos2;\n    let D1 = (-2 * A1 * e1.x - C1 * e1.y);\n    let D2 = (-2 * A2 * e2.x - C2 * e2.y);\n    let E1 = (-C1 * e1.x - 2 * B1 * e1.y);\n    let E2 = (-C2 * e2.x - 2 * B2 * e2.y);\n    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\n    C1 = C1 / 2;\n    C2 = C2 / 2;\n    D1 = D1 / 2;\n    D2 = D2 / 2;\n    E1 = E1 / 2;\n    E2 = E2 / 2;\n\n    const l3 = det3([\n        [A1, C1, D1],\n        [C1, B1, E1],\n        [D1, E1, F1]\n    ]);\n    const l0 = det3([\n        [A2, C2, D2],\n        [C2, B2, E2],\n        [D2, E2, F2]\n    ]);\n    const l2 = 0.33333333 * (det3([\n        [A2, C1, D1],\n        [C2, B1, E1],\n        [D2, E1, F1]\n    ]) + det3([\n        [A1, C2, D1],\n        [C1, B2, E1],\n        [D1, E2, F1]\n    ]) + det3([\n        [A1, C1, D2],\n        [C1, B1, E2],\n        [D1, E1, F2]\n    ]));\n    const l1 = 0.33333333 * (det3([\n        [A1, C2, D2],\n        [C1, B2, E2],\n        [D1, E2, F2]\n    ]) + det3([\n        [A2, C1, D2],\n        [C2, B1, E2],\n        [D2, E1, F2]\n    ]) + det3([\n        [A2, C2, D1],\n        [C2, B2, E1],\n        [D2, E2, F1]\n    ]));\n\n    const delta1 = det2([\n        [l3, l2],\n        [l2, l1]\n    ]);\n    const delta2 = det2([\n        [l3, l1],\n        [l2, l0]\n    ]);\n    const delta3 = det2([\n        [l2, l1],\n        [l1, l0]\n    ]);\n\n    const dP = det2([\n        [2 * delta1, delta2],\n        [delta2, 2 * delta3]\n    ]);\n\n    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n        return false;\n    }\n    return true;\n}\n\nfunction det2(m) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\n\nfunction det3(m) {\n    return m[0][0] * m[1][1] * m[2][2] -\n        m[0][0] * m[1][2] * m[2][1] -\n        m[0][1] * m[1][0] * m[2][2] +\n        m[0][1] * m[1][2] * m[2][0] +\n        m[0][2] * m[1][0] * m[2][1] -\n        m[0][2] * m[1][1] * m[2][0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvaW50ZXJzZWN0aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrQztBQUNNO0FBQ047QUFDRTs7QUFFN0I7QUFDUDtBQUNBLGFBQWEsNkNBQUs7QUFDbEI7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQUs7QUFDbEI7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQjtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQUs7QUFDbEI7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkNBQUs7QUFDbEI7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQjtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztB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QGpvaW50L2NvcmUvc3JjL2cvaW50ZXJzZWN0aW9uLm1qcz9kMmQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmUgfSBmcm9tICcuL2xpbmUubWpzJztcbmltcG9ydCB7IFBvbHlnb24gfSBmcm9tICcuL3BvbHlnb24ubWpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQsIHNoYXBlMm9wdCkge1xuICAgIHN3aXRjaCAoc2hhcGUxLnR5cGUpIHtcbiAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lV2l0aExpbmUoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxsaXBzZVdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGxpcHNlV2l0aEVsbGlwc2Uoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuUmVjdDoge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aEVsbGlwc2Uoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RXaXRoUmVjdChzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlcy5Qb2x5bGluZToge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoTGluZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoRWxsaXBzZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUmVjdDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoUmVjdChzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lV2l0aFBvbHlsaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHR5cGVzLlBvbHlnb246IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2hhcGUyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25XaXRoTGluZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWdvbldpdGhFbGxpcHNlKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5SZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aFJlY3Qoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlBvbHlsaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aFBvbHlsaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5Qb2x5Z29uOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aFBvbHlnb24oc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuUGF0aDoge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkVsbGlwc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoRWxsaXBzZShzaGFwZTEsIHNoYXBlMiwgc2hhcGUxb3B0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5SZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoV2l0aFJlY3Qoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUG9seWxpbmUoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWdvbjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhQb2x5Z29uKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUGF0aChzaGFwZTEsIHNoYXBlMiwgc2hhcGUxb3B0LCBzaGFwZTJvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vbmUgb2YgdGhlIGNhc2VzIGFib3ZlXG4gICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLkVsbGlwc2U6XG4gICAgICAgIGNhc2UgdHlwZXMuUmVjdDpcbiAgICAgICAgY2FzZSB0eXBlcy5Qb2x5bGluZTpcbiAgICAgICAgY2FzZSB0eXBlcy5Qb2x5Z29uOlxuICAgICAgICBjYXNlIHR5cGVzLlBhdGg6IHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdHMoc2hhcGUyLCBzaGFwZTEsIHNoYXBlMm9wdCwgc2hhcGUxb3B0KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlIGludGVyc2VjdGlvbiBmb3IgJHtzaGFwZTF9IGFuZCAke3NoYXBlMn0gY291bGQgbm90IGJlIGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKiBMaW5lICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lV2l0aExpbmUobGluZTEsIGxpbmUyKSB7XG4gICAgY29uc3QgeDEgPSBsaW5lMS5zdGFydC54O1xuICAgIGNvbnN0IHkxID0gbGluZTEuc3RhcnQueTtcbiAgICBjb25zdCB4MiA9IGxpbmUxLmVuZC54O1xuICAgIGNvbnN0IHkyID0gbGluZTEuZW5kLnk7XG4gICAgY29uc3QgeDMgPSBsaW5lMi5zdGFydC54O1xuICAgIGNvbnN0IHkzID0gbGluZTIuc3RhcnQueTtcbiAgICBjb25zdCB4NCA9IGxpbmUyLmVuZC54O1xuICAgIGNvbnN0IHk0ID0gbGluZTIuZW5kLnk7XG4gICAgY29uc3QgczF4ID0geDIgLSB4MTtcbiAgICBjb25zdCBzMXkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IHMyeCA9IHg0IC0geDM7XG4gICAgY29uc3QgczJ5ID0geTQgLSB5MztcbiAgICBjb25zdCBzM3ggPSB4MSAtIHgzO1xuICAgIGNvbnN0IHMzeSA9IHkxIC0geTM7XG4gICAgY29uc3QgcCA9IHMxeCAqIHMyeSAtIHMyeCAqIHMxeTtcbiAgICBjb25zdCBzID0gKHMxeCAqIHMzeSAtIHMxeSAqIHMzeCkgLyBwO1xuICAgIGNvbnN0IHQgPSAoczJ4ICogczN5IC0gczJ5ICogczN4KSAvIHA7XG4gICAgcmV0dXJuIHMgPj0gMCAmJiBzIDw9IDEgJiYgdCA+PSAwICYmIHQgPD0gMTtcbn1cblxuLyogRWxsaXBzZSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzZVdpdGhMaW5lKGVsbGlwc2UsIGxpbmUpIHtcbiAgICBjb25zdCByZXggPSBlbGxpcHNlLmE7XG4gICAgY29uc3QgcmV5ID0gZWxsaXBzZS5iO1xuICAgIGNvbnN0IHhlID0gZWxsaXBzZS54O1xuICAgIGNvbnN0IHllID0gZWxsaXBzZS55O1xuICAgIGNvbnN0IHgxID0gbGluZS5zdGFydC54IC0geGU7XG4gICAgY29uc3QgeDIgPSBsaW5lLmVuZC54IC0geGU7XG4gICAgY29uc3QgeTEgPSBsaW5lLnN0YXJ0LnkgLSB5ZTtcbiAgICBjb25zdCB5MiA9IGxpbmUuZW5kLnkgLSB5ZTtcbiAgICBjb25zdCByZXhfMiA9IHJleCAqIHJleDtcbiAgICBjb25zdCByZXlfMiA9IHJleSAqIHJleTtcbiAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgY29uc3QgZHkgPSB5MiAtIHkxO1xuICAgIGNvbnN0IEEgPSBkeCAqIGR4IC8gcmV4XzIgKyBkeSAqIGR5IC8gcmV5XzI7XG4gICAgY29uc3QgQiA9IDIgKiB4MSAqIGR4IC8gcmV4XzIgKyAyICogeTEgKiBkeSAvIHJleV8yO1xuICAgIGNvbnN0IEMgPSB4MSAqIHgxIC8gcmV4XzIgKyB5MSAqIHkxIC8gcmV5XzIgLSAxO1xuICAgIGNvbnN0IEQgPSBCICogQiAtIDQgKiBBICogQztcbiAgICBpZiAoRCA9PT0gMCkge1xuICAgICAgICBjb25zdCB0ID0gLUIgLyAyIC8gQTtcbiAgICAgICAgcmV0dXJuIHQgPj0gMCAmJiB0IDw9IDE7XG4gICAgfSBlbHNlIGlmIChEID4gMCkge1xuICAgICAgICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KEQpO1xuICAgICAgICBjb25zdCB0MSA9ICgtQiArIHNxcnQpIC8gMiAvIEE7XG4gICAgICAgIGNvbnN0IHQyID0gKC1CIC0gc3FydCkgLyAyIC8gQTtcbiAgICAgICAgcmV0dXJuICh0MSA+PSAwICYmIHQxIDw9IDEpIHx8ICh0MiA+PSAwICYmIHQyIDw9IDEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbGxpcHNlV2l0aEVsbGlwc2UoZWxsaXBzZTEsIGVsbGlwc2UyKSB7XG4gICAgcmV0dXJuIF9lbGxpcHNlc0ludGVyc2VjdGlvbihlbGxpcHNlMSwgMCwgZWxsaXBzZTIsIDApO1xufVxuXG4vKiBSZWN0ICovXG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0V2l0aExpbmUocmVjdCwgbGluZSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gbGluZTtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHJlY3Q7XG4gICAgaWYgKFxuICAgICAgICAoc3RhcnQueCA+IHggKyB3aWR0aCAmJiBlbmQueCA+IHggKyB3aWR0aClcbiAgICAgICAgfHwgKHN0YXJ0LnggPCB4ICYmIGVuZC54IDwgeClcbiAgICAgICAgfHwgKHN0YXJ0LnkgPiB5ICsgaGVpZ2h0ICYmIGVuZC55ID4geSArIGhlaWdodClcbiAgICAgICAgfHwgKHN0YXJ0LnkgPCB5ICYmIGVuZC55IDwgeSlcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVjdC5jb250YWluc1BvaW50KGxpbmUuc3RhcnQpIHx8IHJlY3QuY29udGFpbnNQb2ludChsaW5lLmVuZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBsaW5lV2l0aExpbmUocmVjdC50b3BMaW5lKCksIGxpbmUpXG4gICAgICAgIHx8IGxpbmVXaXRoTGluZShyZWN0LnJpZ2h0TGluZSgpLCBsaW5lKVxuICAgICAgICB8fCBsaW5lV2l0aExpbmUocmVjdC5ib3R0b21MaW5lKCksIGxpbmUpXG4gICAgICAgIHx8IGxpbmVXaXRoTGluZShyZWN0LmxlZnRMaW5lKCksIGxpbmUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVjdFdpdGhFbGxpcHNlKHJlY3QsIGVsbGlwc2UpIHtcbiAgICBpZiAoIXJlY3RXaXRoUmVjdChyZWN0LCBSZWN0LmZyb21FbGxpcHNlKGVsbGlwc2UpKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBwb2x5Z29uV2l0aEVsbGlwc2UoUG9seWdvbi5mcm9tUmVjdChyZWN0KSwgZWxsaXBzZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0V2l0aFJlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgcmV0dXJuIHJlY3QxLnggPCByZWN0Mi54ICsgcmVjdDIud2lkdGhcbiAgICAgICAgJiYgcmVjdDEueCArIHJlY3QxLndpZHRoID4gcmVjdDIueFxuICAgICAgICAmJiByZWN0MS55IDwgcmVjdDIueSArIHJlY3QyLmhlaWdodFxuICAgICAgICAmJiByZWN0MS55ICsgcmVjdDEuaGVpZ2h0ID4gcmVjdDIueTtcbn1cblxuLyogUG9seWxpbmUgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lV2l0aExpbmUocG9seWxpbmUsIGxpbmUpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aExpbmUocG9seWxpbmUsIGxpbmUsIHsgaW50ZXJpb3I6IGZhbHNlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5bGluZSwgZWxsaXBzZSkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5bGluZSwgZWxsaXBzZSwgeyBpbnRlcmlvcjogZmFsc2UgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZVdpdGhSZWN0KHBvbHlsaW5lLCByZWN0KSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhSZWN0KHBvbHlsaW5lLCByZWN0LCB7IGludGVyaW9yOiBmYWxzZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlsaW5lMSwgcG9seWxpbmUyKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhQb2x5bGluZShwb2x5bGluZTEsIHBvbHlsaW5lMiwgeyBpbnRlcmlvcjogZmFsc2UgfSk7XG59XG5cbi8qIFBvbHlnb24gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25XaXRoTGluZShwb2x5Z29uLCBsaW5lKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhMaW5lKHBvbHlnb24sIGxpbmUsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uV2l0aEVsbGlwc2UocG9seWdvbiwgZWxsaXBzZSkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5Z29uLCBlbGxpcHNlLCB7IGludGVyaW9yOiB0cnVlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbldpdGhSZWN0KHBvbHlnb24sIHJlY3QpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFJlY3QocG9seWdvbiwgcmVjdCwgeyBpbnRlcmlvcjogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25XaXRoUG9seWxpbmUocG9seWdvbiwgcG9seWxpbmUpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlnb24sIHBvbHlsaW5lLCB7IGludGVyaW9yOiB0cnVlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbldpdGhQb2x5Z29uKHBvbHlnb24xLCBwb2x5Z29uMikge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWdvbihwb2x5Z29uMSwgcG9seWdvbjIsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbi8qIFBhdGggKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoTGluZShwYXRoLCBsaW5lLCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIHBhdGguZ2V0U3VicGF0aHMoKS5zb21lKHN1YnBhdGggPT4ge1xuICAgICAgICBjb25zdCBbcG9seWxpbmVdID0gc3VicGF0aC50b1BvbHlsaW5lcyhwYXRoT3B0KTtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBzdWJwYXRoLmdldFNlZ21lbnQoLTEpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbldpdGhMaW5lKHBvbHlsaW5lLCBsaW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwb2x5bGluZVdpdGhMaW5lKHBvbHlsaW5lLCBsaW5lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhFbGxpcHNlKHBhdGgsIGVsbGlwc2UsIHBhdGhPcHQpIHtcbiAgICByZXR1cm4gcGF0aC5nZXRTdWJwYXRocygpLnNvbWUoc3VicGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IFtwb2x5bGluZV0gPSBzdWJwYXRoLnRvUG9seWxpbmVzKHBhdGhPcHQpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN1YnBhdGguZ2V0U2VnbWVudCgtMSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aEVsbGlwc2UocG9seWxpbmUsIGVsbGlwc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lV2l0aEVsbGlwc2UocG9seWxpbmUsIGVsbGlwc2UpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aFJlY3QocGF0aCwgcmVjdCwgcGF0aE9wdCkge1xuICAgIHJldHVybiBwYXRoV2l0aFBvbHlnb24ocGF0aCwgUG9seWdvbi5mcm9tUmVjdChyZWN0KSwgcGF0aE9wdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aFBvbHlsaW5lKHBhdGgsIHBvbHlsaW5lLCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIF9wYXRoV2l0aFBvbHlsaW5lKHBhdGgsIHBvbHlsaW5lLCBwYXRoT3B0LCB7IGludGVyaW9yOiBmYWxzZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoUG9seWdvbihwYXRoLCBwb2x5Z29uLCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIF9wYXRoV2l0aFBvbHlsaW5lKHBhdGgsIHBvbHlnb24sIHBhdGhPcHQsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aFBhdGgocGF0aDEsIHBhdGgyLCBwYXRoT3B0MSwgcGF0aE9wdDIpIHtcbiAgICByZXR1cm4gcGF0aDEuZ2V0U3VicGF0aHMoKS5zb21lKHN1YnBhdGggPT4ge1xuICAgICAgICBjb25zdCBbcG9seWxpbmUxXSA9IHN1YnBhdGgudG9Qb2x5bGluZXMocGF0aE9wdDEpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN1YnBhdGguZ2V0U2VnbWVudCgtMSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoV2l0aFBvbHlnb24ocGF0aDIsIHBvbHlsaW5lMSwgcGF0aE9wdDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUG9seWxpbmUocGF0aDIsIHBvbHlsaW5lMSwgcGF0aE9wdDIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhMaW5lKHBvbHlsaW5lLCBsaW5lLCBvcHQgPSB7fSkge1xuICAgIGNvbnN0IHsgaW50ZXJpb3IgPSBmYWxzZSB9ID0gb3B0O1xuICAgIGxldCB0aGlzUG9pbnRzO1xuICAgIGlmIChpbnRlcmlvcikge1xuICAgICAgICBpZiAocG9seWxpbmUuY29udGFpbnNQb2ludChsaW5lLnN0YXJ0KSkge1xuICAgICAgICAgICAgLy8gSWYgYW55IHBvaW50IG9mIHRoZSBwb2x5bGluZSBsaWVzIGluc2lkZSB0aGlzIHBvbHlnb24gKGludGVyaW9yID0gdHJ1ZSlcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiAod2UndmUgY2hvc2VuIHRoZSBzdGFydCBwb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgcG9pbnRzIH0gPSBwb2x5bGluZTtcbiAgICAgICAgdGhpc1BvaW50cyA9IGVuZC5lcXVhbHMoc3RhcnQpID8gcG9pbnRzIDogWy4uLnBvaW50cywgc3RhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNQb2ludHMgPSBwb2x5bGluZS5wb2ludHM7XG4gICAgfVxuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0aGlzUG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgTGluZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnQuc3RhcnQgPSB0aGlzUG9pbnRzW2ldO1xuICAgICAgICBzZWdtZW50LmVuZCA9IHRoaXNQb2ludHNbaSArIDFdO1xuICAgICAgICBpZiAobGluZVdpdGhMaW5lKGxpbmUsIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhFbGxpcHNlKHBvbHlsaW5lLCBlbGxpcHNlLCBvcHQgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgcG9pbnRzIH0gPSBwb2x5bGluZTtcbiAgICBpZiAoZWxsaXBzZS5jb250YWluc1BvaW50KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHRoaXNQb2ludHM7XG4gICAgY29uc3QgeyBpbnRlcmlvciA9IGZhbHNlIH0gPSBvcHQ7XG4gICAgaWYgKGludGVyaW9yKSB7XG4gICAgICAgIGlmIChwb2x5bGluZS5jb250YWluc1BvaW50KGVsbGlwc2UuY2VudGVyKCkpKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgcG9pbnQgb2YgdGhlIGVsbGlwc2UgbGllcyBpbnNpZGUgdGhpcyBwb2x5Z29uIChpbnRlcmlvciA9IHRydWUpXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24gKHdlJ3ZlIGNob3NlbiB0aGUgY2VudGVyIHBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1BvaW50cyA9IGVuZC5lcXVhbHMoc3RhcnQpID8gcG9pbnRzIDogWy4uLnBvaW50cywgc3RhcnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNQb2ludHMgPSBwb2ludHM7XG4gICAgfVxuXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHRoaXNQb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudCA9IG5ldyBMaW5lKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgc2VnbWVudC5zdGFydCA9IHRoaXNQb2ludHNbaV07XG4gICAgICAgIHNlZ21lbnQuZW5kID0gdGhpc1BvaW50c1tpICsgMV07XG4gICAgICAgIGlmIChlbGxpcHNlV2l0aExpbmUoZWxsaXBzZSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3BvbHlsaW5lV2l0aFJlY3QocG9seWxpbmUsIHJlY3QsIG9wdCkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBQb2x5Z29uLmZyb21SZWN0KHJlY3QpO1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWdvbihwb2x5bGluZSwgcG9seWdvbiwgb3B0KTtcbn1cblxuZnVuY3Rpb24gX3BhdGhXaXRoUG9seWxpbmUocGF0aCwgcG9seWxpbmUxLCBwYXRoT3B0LCBvcHQpIHtcbiAgICByZXR1cm4gcGF0aC5nZXRTdWJwYXRocygpLnNvbWUoc3VicGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IFtwb2x5bGluZTJdID0gc3VicGF0aC50b1BvbHlsaW5lcyhwYXRoT3B0KTtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSBzdWJwYXRoLmdldFNlZ21lbnQoLTEpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlnb24ocG9seWxpbmUxLCBwb2x5bGluZTIsIG9wdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlsaW5lMSwgcG9seWxpbmUyLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhQb2x5bGluZShwb2x5bGluZTEsIHBvbHlsaW5lMiwgb3B0ID0ge30pIHtcbiAgICBjb25zdCB7IGludGVyaW9yID0gZmFsc2UgfSA9IG9wdDtcbiAgICBsZXQgdGhpc1BvbHlsaW5lO1xuICAgIGlmIChpbnRlcmlvcikge1xuICAgICAgICBjb25zdCB7IHN0YXJ0IH0gPSBwb2x5bGluZTI7XG4gICAgICAgIGlmIChwb2x5bGluZTEuY29udGFpbnNQb2ludChzdGFydCkpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBwb2ludCBvZiB0aGUgcG9seWxpbmUgbGllcyBpbnNpZGUgdGhpcyBwb2x5Z29uIChpbnRlcmlvciA9IHRydWUpXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBhbiBpbnRlcnNlY3Rpb24gKHdlJ3ZlIGNob3NlbiB0aGUgc3RhcnQgcG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzUG9seWxpbmUgPSBwb2x5bGluZTEuY2xvbmUoKS5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNQb2x5bGluZSA9IHBvbHlsaW5lMTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJQb2ludHMgPSBwb2x5bGluZTIucG9pbnRzO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBvdGhlclBvaW50cztcbiAgICBjb25zdCBzZWdtZW50ID0gbmV3IExpbmUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBzZWdtZW50LnN0YXJ0ID0gb3RoZXJQb2ludHNbaV07XG4gICAgICAgIHNlZ21lbnQuZW5kID0gb3RoZXJQb2ludHNbaSArIDFdO1xuICAgICAgICBpZiAocG9seWxpbmVXaXRoTGluZSh0aGlzUG9seWxpbmUsIHNlZ21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9wb2x5bGluZVdpdGhQb2x5Z29uKHBvbHlsaW5lLCBwb2x5Z29uLCBvcHQpIHtcbiAgICByZXR1cm4gcG9seWdvbi5jb250YWluc1BvaW50KHBvbHlsaW5lLnN0YXJ0KSB8fCBfcG9seWxpbmVXaXRoUG9seWxpbmUocG9seWxpbmUsIHBvbHlnb24uY2xvbmUoKS5jbG9zZSgpLCBvcHQpO1xufVxuXG5mdW5jdGlvbiBfZWxsaXBzZXNJbnRlcnNlY3Rpb24oZTEsIHcxLCBlMiwgdzIpIHtcbiAgICBjb25zdCB7IGNvcywgc2luIH0gPSBNYXRoO1xuICAgIGNvbnN0IHNpblcxID0gc2luKHcxKTtcbiAgICBjb25zdCBjb3NXMSA9IGNvcyh3MSk7XG4gICAgY29uc3Qgc2luVzIgPSBzaW4odzIpO1xuICAgIGNvbnN0IGNvc1cyID0gY29zKHcyKTtcbiAgICBjb25zdCBzaW5XMXMgPSBzaW5XMSAqIHNpblcxO1xuICAgIGNvbnN0IGNvc1cxcyA9IGNvc1cxICogY29zVzE7XG4gICAgY29uc3Qgc2luQ29zMSA9IHNpblcxICogY29zVzE7XG4gICAgY29uc3Qgc2luVzJzID0gc2luVzIgKiBzaW5XMjtcbiAgICBjb25zdCBjb3NXMnMgPSBjb3NXMiAqIGNvc1cyO1xuICAgIGNvbnN0IHNpbkNvczIgPSBzaW5XMiAqIGNvc1cyO1xuICAgIGNvbnN0IGExcyA9IGUxLmEgKiBlMS5hO1xuICAgIGNvbnN0IGIxcyA9IGUxLmIgKiBlMS5iO1xuICAgIGNvbnN0IGEycyA9IGUyLmEgKiBlMi5hO1xuICAgIGNvbnN0IGIycyA9IGUyLmIgKiBlMi5iO1xuICAgIGNvbnN0IEExID0gYTFzICogc2luVzFzICsgYjFzICogY29zVzFzO1xuICAgIGNvbnN0IEEyID0gYTJzICogc2luVzJzICsgYjJzICogY29zVzJzO1xuICAgIGNvbnN0IEIxID0gYTFzICogY29zVzFzICsgYjFzICogc2luVzFzO1xuICAgIGNvbnN0IEIyID0gYTJzICogY29zVzJzICsgYjJzICogc2luVzJzO1xuICAgIGxldCBDMSA9IDIgKiAoYjFzIC0gYTFzKSAqIHNpbkNvczE7XG4gICAgbGV0IEMyID0gMiAqIChiMnMgLSBhMnMpICogc2luQ29zMjtcbiAgICBsZXQgRDEgPSAoLTIgKiBBMSAqIGUxLnggLSBDMSAqIGUxLnkpO1xuICAgIGxldCBEMiA9ICgtMiAqIEEyICogZTIueCAtIEMyICogZTIueSk7XG4gICAgbGV0IEUxID0gKC1DMSAqIGUxLnggLSAyICogQjEgKiBlMS55KTtcbiAgICBsZXQgRTIgPSAoLUMyICogZTIueCAtIDIgKiBCMiAqIGUyLnkpO1xuICAgIGNvbnN0IEYxID0gQTEgKiBlMS54ICogZTEueCArIEIxICogZTEueSAqIGUxLnkgKyBDMSAqIGUxLnggKiBlMS55IC0gYTFzICogYjFzO1xuICAgIGNvbnN0IEYyID0gQTIgKiBlMi54ICogZTIueCArIEIyICogZTIueSAqIGUyLnkgKyBDMiAqIGUyLnggKiBlMi55IC0gYTJzICogYjJzO1xuXG4gICAgQzEgPSBDMSAvIDI7XG4gICAgQzIgPSBDMiAvIDI7XG4gICAgRDEgPSBEMSAvIDI7XG4gICAgRDIgPSBEMiAvIDI7XG4gICAgRTEgPSBFMSAvIDI7XG4gICAgRTIgPSBFMiAvIDI7XG5cbiAgICBjb25zdCBsMyA9IGRldDMoW1xuICAgICAgICBbQTEsIEMxLCBEMV0sXG4gICAgICAgIFtDMSwgQjEsIEUxXSxcbiAgICAgICAgW0QxLCBFMSwgRjFdXG4gICAgXSk7XG4gICAgY29uc3QgbDAgPSBkZXQzKFtcbiAgICAgICAgW0EyLCBDMiwgRDJdLFxuICAgICAgICBbQzIsIEIyLCBFMl0sXG4gICAgICAgIFtEMiwgRTIsIEYyXVxuICAgIF0pO1xuICAgIGNvbnN0IGwyID0gMC4zMzMzMzMzMyAqIChkZXQzKFtcbiAgICAgICAgW0EyLCBDMSwgRDFdLFxuICAgICAgICBbQzIsIEIxLCBFMV0sXG4gICAgICAgIFtEMiwgRTEsIEYxXVxuICAgIF0pICsgZGV0MyhbXG4gICAgICAgIFtBMSwgQzIsIEQxXSxcbiAgICAgICAgW0MxLCBCMiwgRTFdLFxuICAgICAgICBbRDEsIEUyLCBGMV1cbiAgICBdKSArIGRldDMoW1xuICAgICAgICBbQTEsIEMxLCBEMl0sXG4gICAgICAgIFtDMSwgQjEsIEUyXSxcbiAgICAgICAgW0QxLCBFMSwgRjJdXG4gICAgXSkpO1xuICAgIGNvbnN0IGwxID0gMC4zMzMzMzMzMyAqIChkZXQzKFtcbiAgICAgICAgW0ExLCBDMiwgRDJdLFxuICAgICAgICBbQzEsIEIyLCBFMl0sXG4gICAgICAgIFtEMSwgRTIsIEYyXVxuICAgIF0pICsgZGV0MyhbXG4gICAgICAgIFtBMiwgQzEsIEQyXSxcbiAgICAgICAgW0MyLCBCMSwgRTJdLFxuICAgICAgICBbRDIsIEUxLCBGMl1cbiAgICBdKSArIGRldDMoW1xuICAgICAgICBbQTIsIEMyLCBEMV0sXG4gICAgICAgIFtDMiwgQjIsIEUxXSxcbiAgICAgICAgW0QyLCBFMiwgRjFdXG4gICAgXSkpO1xuXG4gICAgY29uc3QgZGVsdGExID0gZGV0MihbXG4gICAgICAgIFtsMywgbDJdLFxuICAgICAgICBbbDIsIGwxXVxuICAgIF0pO1xuICAgIGNvbnN0IGRlbHRhMiA9IGRldDIoW1xuICAgICAgICBbbDMsIGwxXSxcbiAgICAgICAgW2wyLCBsMF1cbiAgICBdKTtcbiAgICBjb25zdCBkZWx0YTMgPSBkZXQyKFtcbiAgICAgICAgW2wyLCBsMV0sXG4gICAgICAgIFtsMSwgbDBdXG4gICAgXSk7XG5cbiAgICBjb25zdCBkUCA9IGRldDIoW1xuICAgICAgICBbMiAqIGRlbHRhMSwgZGVsdGEyXSxcbiAgICAgICAgW2RlbHRhMiwgMiAqIGRlbHRhM11cbiAgICBdKTtcblxuICAgIGlmIChkUCA+IDAgJiYgKGwxID4gMCB8fCBsMiA+IDApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRldDIobSkge1xuICAgIHJldHVybiBtWzBdWzBdICogbVsxXVsxXSAtIG1bMF1bMV0gKiBtWzFdWzBdO1xufVxuXG5mdW5jdGlvbiBkZXQzKG0pIHtcbiAgICByZXR1cm4gbVswXVswXSAqIG1bMV1bMV0gKiBtWzJdWzJdIC1cbiAgICAgICAgbVswXVswXSAqIG1bMV1bMl0gKiBtWzJdWzFdIC1cbiAgICAgICAgbVswXVsxXSAqIG1bMV1bMF0gKiBtWzJdWzJdICtcbiAgICAgICAgbVswXVsxXSAqIG1bMV1bMl0gKiBtWzJdWzBdICtcbiAgICAgICAgbVswXVsyXSAqIG1bMV1bMF0gKiBtWzJdWzFdIC1cbiAgICAgICAgbVswXVsyXSAqIG1bMV1bMV0gKiBtWzJdWzBdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/intersection.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/line.bearing.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.bearing.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bearing: () => (/* binding */ bearing)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\n\nconst {\n    cos,\n    sin,\n    atan2\n} = Math;\n\nconst bearing = function(p, q) {\n\n    var lat1 = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(p.y);\n    var lat2 = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(q.y);\n    var lon1 = p.x;\n    var lon2 = q.x;\n    var dLon = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(lon2 - lon1);\n    var y = sin(dLon) * cos(lat2);\n    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n    var brng = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg)(atan2(y, x));\n\n    var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n    var index = brng - 22.5;\n    if (index < 0)\n        index += 360;\n    index = parseInt(index / 45);\n\n    return bearings[index];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvbGluZS5iZWFyaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0EsYUFBYSxRQUFRO0FBQ2lDOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUs7O0FBRVAsZUFBZSw0REFBSztBQUNwQixlQUFlLDREQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLDREQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLDREQUFLOztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLmJlYXJpbmcubWpzPzk1MzUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHJldHVybiB0aGUgYmVhcmluZyAoY2FyZGluYWwgZGlyZWN0aW9uKSBvZiB0aGUgbGluZS4gRm9yIGV4YW1wbGUgTiwgVywgb3IgU0UuXG4vLyBAcmV0dXJucyB7U3RyaW5nfSBPbmUgb2YgdGhlIGZvbGxvd2luZyBiZWFyaW5ncyA6IE5FLCBFLCBTRSwgUywgU1csIFcsIE5XLCBOLlxuaW1wb3J0IHsgdG9EZWcsIHRvUmFkIH0gZnJvbSAnLi9nZW9tZXRyeS5oZWxwZXJzLm1qcyc7XG5cbmNvbnN0IHtcbiAgICBjb3MsXG4gICAgc2luLFxuICAgIGF0YW4yXG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IGJlYXJpbmcgPSBmdW5jdGlvbihwLCBxKSB7XG5cbiAgICB2YXIgbGF0MSA9IHRvUmFkKHAueSk7XG4gICAgdmFyIGxhdDIgPSB0b1JhZChxLnkpO1xuICAgIHZhciBsb24xID0gcC54O1xuICAgIHZhciBsb24yID0gcS54O1xuICAgIHZhciBkTG9uID0gdG9SYWQobG9uMiAtIGxvbjEpO1xuICAgIHZhciB5ID0gc2luKGRMb24pICogY29zKGxhdDIpO1xuICAgIHZhciB4ID0gY29zKGxhdDEpICogc2luKGxhdDIpIC0gc2luKGxhdDEpICogY29zKGxhdDIpICogY29zKGRMb24pO1xuICAgIHZhciBicm5nID0gdG9EZWcoYXRhbjIoeSwgeCkpO1xuXG4gICAgdmFyIGJlYXJpbmdzID0gWydORScsICdFJywgJ1NFJywgJ1MnLCAnU1cnLCAnVycsICdOVycsICdOJ107XG5cbiAgICB2YXIgaW5kZXggPSBicm5nIC0gMjIuNTtcbiAgICBpZiAoaW5kZXggPCAwKVxuICAgICAgICBpbmRleCArPSAzNjA7XG4gICAgaW5kZXggPSBwYXJzZUludChpbmRleCAvIDQ1KTtcblxuICAgIHJldHVybiBiZWFyaW5nc1tpbmRleF07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/line.bearing.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/line.length.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.length.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   length: () => (/* binding */ length)\n/* harmony export */ });\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\");\n\n\nconst length = function(start, end) {\n    return Math.sqrt((0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredLength)(start, end));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvbGluZS5sZW5ndGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlEOztBQUVsRDtBQUNQLHFCQUFxQixzRUFBYTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvbGluZS5sZW5ndGgubWpzP2ZhZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3F1YXJlZExlbmd0aCB9IGZyb20gJy4vbGluZS5zcXVhcmVkTGVuZ3RoLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChzcXVhcmVkTGVuZ3RoKHN0YXJ0LCBlbmQpKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/line.length.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/line.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   line: () => (/* binding */ line)\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _line_bearing_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.bearing.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.bearing.mjs\");\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\");\n/* harmony import */ var _line_length_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.length.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.length.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\n\n\nconst {\n    max,\n    min\n} = Math;\n\nconst Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1);\n    this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2);\n};\n\nLine.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Line,\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return (0,_line_bearing_mjs__WEBPACK_IMPORTED_MODULE_3__.bearing)(this.start, this.end);\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n        return (0,_line_length_mjs__WEBPACK_IMPORTED_MODULE_4__.length)(this.start, this.end);\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return (0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_5__.squaredLength)(this.start, this.end);\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n\n// For backwards compatibility:\nconst line = Line;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvbGluZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRjtBQUNXO0FBQ1k7QUFDZDtBQUNQOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVLOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDZDQUFLO0FBQzFCLG1CQUFtQiw2Q0FBSztBQUN4Qjs7QUFFQTs7QUFFQSxVQUFVLDZDQUFLOztBQUVmO0FBQ0E7O0FBRUEsa0NBQWtDLDZDQUFLO0FBQ3ZDO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkNBQUk7QUFDdkIsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsZUFBZSwwREFBTztBQUN0QixLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEseUJBQXlCLDZDQUFLO0FBQzlCLHlCQUF5Qiw2Q0FBSztBQUM5QjtBQUNBLDBCQUEwQiw2Q0FBSztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkNBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxlQUFlLHdEQUFNO0FBQ3JCLEtBQUs7O0FBRUwsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixRQUFRO0FBQ3hCOztBQUVBO0FBQ0EsZ0JBQWdCLDZDQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0EsZUFBZSxzRUFBYTtBQUM1QixLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDOztBQUU1QztBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtRkFBbUY7O0FBRW5GO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsdUJBQXVCLE9BQU87QUFDOUI7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvbGluZS5tanM/MDNmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcG9pbnQubWpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IGJlYXJpbmcgfSBmcm9tICcuL2xpbmUuYmVhcmluZy5tanMnO1xuaW1wb3J0IHsgc3F1YXJlZExlbmd0aCB9IGZyb20gJy4vbGluZS5zcXVhcmVkTGVuZ3RoLm1qcyc7XG5pbXBvcnQgeyBsZW5ndGggfSBmcm9tICcuL2xpbmUubGVuZ3RoLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcblxuY29uc3Qge1xuICAgIG1heCxcbiAgICBtaW5cbn0gPSBNYXRoO1xuXG5leHBvcnQgY29uc3QgTGluZSA9IGZ1bmN0aW9uKHAxLCBwMikge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZShwMSwgcDIpO1xuICAgIH1cblxuICAgIGlmIChwMSBpbnN0YW5jZW9mIExpbmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHAxLnN0YXJ0LCBwMS5lbmQpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9pbnQocDEpO1xuICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KHAyKTtcbn07XG5cbkxpbmUucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuTGluZSxcblxuICAgIC8vIEByZXR1cm5zIHRoZSBhbmdsZSBvZiBpbmNsaW5lIG9mIHRoZSBsaW5lLlxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaG9yaXpvbnRhbFBvaW50ID0gbmV3IFBvaW50KHRoaXMuc3RhcnQueCArIDEsIHRoaXMuc3RhcnQueSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmFuZ2xlQmV0d2Vlbih0aGlzLmVuZCwgaG9yaXpvbnRhbFBvaW50KTtcbiAgICB9LFxuXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBtaW4odGhpcy5zdGFydC54LCB0aGlzLmVuZC54KTtcbiAgICAgICAgdmFyIHRvcCA9IG1pbih0aGlzLnN0YXJ0LnksIHRoaXMuZW5kLnkpO1xuICAgICAgICB2YXIgcmlnaHQgPSBtYXgodGhpcy5zdGFydC54LCB0aGlzLmVuZC54KTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IG1heCh0aGlzLnN0YXJ0LnksIHRoaXMuZW5kLnkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdChsZWZ0LCB0b3AsIChyaWdodCAtIGxlZnQpLCAoYm90dG9tIC0gdG9wKSk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4gdGhlIGJlYXJpbmcgKGNhcmRpbmFsIGRpcmVjdGlvbikgb2YgdGhlIGxpbmUuIEZvciBleGFtcGxlIE4sIFcsIG9yIFNFLlxuICAgIC8vIEByZXR1cm5zIHtTdHJpbmd9IE9uZSBvZiB0aGUgZm9sbG93aW5nIGJlYXJpbmdzIDogTkUsIEUsIFNFLCBTLCBTVywgVywgTlcsIE4uXG4gICAgYmVhcmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiZWFyaW5nKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3BvaW50fSB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSB0byBwb2ludCBgcGBcbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0KHRoaXMuY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aChwKSk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCkgKiB0aGlzLmxlbmd0aCgpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtudW1iZXJ9IHRoZSBub3JtYWxpemVkIGxlbmd0aCBvZiB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSB0byBwb2ludCBgcGBcbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIHByb2R1Y3QgPSB0aGlzLnZlY3RvcigpLmRvdCgobmV3IExpbmUodGhpcy5zdGFydCwgcCkpLnZlY3RvcigpKTtcbiAgICAgICAgdmFyIGNwTm9ybWFsaXplZExlbmd0aCA9IG1pbigxLCBtYXgoMCwgcHJvZHVjdCAvIHRoaXMuc3F1YXJlZExlbmd0aCgpKSk7XG5cbiAgICAgICAgLy8gY3BOb3JtYWxpemVkTGVuZ3RoIHJldHVybnMgYE5hTmAgaWYgdGhpcyBsaW5lIGhhcyB6ZXJvIGxlbmd0aFxuICAgICAgICAvLyB3ZSBjYW4gd29yayB3aXRoIHRoYXQgLSBpZiBgTmFOYCwgcmV0dXJuIDBcbiAgICAgICAgaWYgKGNwTm9ybWFsaXplZExlbmd0aCAhPT0gY3BOb3JtYWxpemVkTGVuZ3RoKSByZXR1cm4gMDsgLy8gY29uZGl0aW9uIGV2YWx1YXRlcyB0byBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWYgY3BOb3JtYWxpemVkTGVuZ3RoIGlzIGBOYU5gXG4gICAgICAgIC8vIChgTmFOYCBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYpXG5cbiAgICAgICAgcmV0dXJuIGNwTm9ybWFsaXplZExlbmd0aDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdCh0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcG9pbnQgbGllcyBvbiB0aGUgbGluZS5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIGlmIChzdGFydC5jcm9zcyhwLCBlbmQpICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGVsc2U6IGNyb3NzIHByb2R1Y3Qgb2YgMCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGxpbmUgYW5kIHRoZSB2ZWN0b3IgdG8gYHBgIGFyZSBjb2xsaW5lYXJcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKChuZXcgTGluZShzdGFydCwgcCkpLmxlbmd0aCgpID4gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgobmV3IExpbmUocCwgZW5kKSkubGVuZ3RoKCkgPiBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gZWxzZTogYHBgIGxpZXMgYmV0d2VlbiBzdGFydCBhbmQgZW5kIG9mIHRoZSBsaW5lXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIGxpbmUgaW50byB0d28gYXQgcmVxdWVzdGVkIGByYXRpb2AgYmV0d2VlbiAwIGFuZCAxLlxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbihyYXRpbykge1xuXG4gICAgICAgIHZhciBkaXZpZGVyUG9pbnQgPSB0aGlzLnBvaW50QXQocmF0aW8pO1xuXG4gICAgICAgIC8vIHJldHVybiBhcnJheSB3aXRoIHR3byBsaW5lc1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IExpbmUodGhpcy5zdGFydCwgZGl2aWRlclBvaW50KSxcbiAgICAgICAgICAgIG5ldyBMaW5lKGRpdmlkZXJQb2ludCwgdGhpcy5lbmQpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIGxpbmUgaW50byB0d28gYXQgcmVxdWVzdGVkIGBsZW5ndGhgLlxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgZGl2aWRlclBvaW50ID0gdGhpcy5wb2ludEF0TGVuZ3RoKGxlbmd0aCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGFycmF5IHdpdGggdHdvIG5ldyBsaW5lc1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IExpbmUodGhpcy5zdGFydCwgZGl2aWRlclBvaW50KSxcbiAgICAgICAgICAgIG5ldyBMaW5lKGRpdmlkZXJQb2ludCwgdGhpcy5lbmQpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24obCkge1xuXG4gICAgICAgIHJldHVybiAhIWwgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnQueCA9PT0gbC5zdGFydC54ICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnkgPT09IGwuc3RhcnQueSAmJlxuICAgICAgICAgICAgdGhpcy5lbmQueCA9PT0gbC5lbmQueCAmJlxuICAgICAgICAgICAgdGhpcy5lbmQueSA9PT0gbC5lbmQueTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7cG9pbnR9IFBvaW50IHdoZXJlIEknbSBpbnRlcnNlY3RpbmcgYSBsaW5lLlxuICAgIC8vIEByZXR1cm4gW3BvaW50XSBQb2ludHMgd2hlcmUgSSdtIGludGVyc2VjdGluZyBhIHJlY3RhbmdsZS5cbiAgICAvLyBAc2VlIFNxdWVhayBTbWFsbHRhbGssIExpbmVTZWdtZW50Pj5pbnRlcnNlY3Rpb25XaXRoOlxuICAgIGludGVyc2VjdDogZnVuY3Rpb24oc2hhcGUsIG9wdCkge1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pbnRlcnNlY3Rpb25XaXRoTGluZSkge1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHNoYXBlLmludGVyc2VjdGlvbldpdGhMaW5lKHRoaXMsIG9wdCk7XG5cbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uICYmIChzaGFwZSBpbnN0YW5jZW9mIExpbmUpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG5cbiAgICAgICAgdmFyIHB0MURpciA9IG5ldyBQb2ludCh0aGlzLmVuZC54IC0gdGhpcy5zdGFydC54LCB0aGlzLmVuZC55IC0gdGhpcy5zdGFydC55KTtcbiAgICAgICAgdmFyIHB0MkRpciA9IG5ldyBQb2ludChsaW5lLmVuZC54IC0gbGluZS5zdGFydC54LCBsaW5lLmVuZC55IC0gbGluZS5zdGFydC55KTtcbiAgICAgICAgdmFyIGRldCA9IChwdDFEaXIueCAqIHB0MkRpci55KSAtIChwdDFEaXIueSAqIHB0MkRpci54KTtcbiAgICAgICAgdmFyIGRlbHRhUHQgPSBuZXcgUG9pbnQobGluZS5zdGFydC54IC0gdGhpcy5zdGFydC54LCBsaW5lLnN0YXJ0LnkgLSB0aGlzLnN0YXJ0LnkpO1xuICAgICAgICB2YXIgYWxwaGEgPSAoZGVsdGFQdC54ICogcHQyRGlyLnkpIC0gKGRlbHRhUHQueSAqIHB0MkRpci54KTtcbiAgICAgICAgdmFyIGJldGEgPSAoZGVsdGFQdC54ICogcHQxRGlyLnkpIC0gKGRlbHRhUHQueSAqIHB0MURpci54KTtcblxuICAgICAgICBpZiAoZGV0ID09PSAwIHx8IGFscGhhICogZGV0IDwgMCB8fCBiZXRhICogZGV0IDwgMCkge1xuICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uIGZvdW5kLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGV0ID4gMCkge1xuICAgICAgICAgICAgaWYgKGFscGhhID4gZGV0IHx8IGJldGEgPiBkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgZGV0IHx8IGJldGEgPCBkZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbbmV3IFBvaW50KFxuICAgICAgICAgICAgdGhpcy5zdGFydC54ICsgKGFscGhhICogcHQxRGlyLnggLyBkZXQpLFxuICAgICAgICAgICAgdGhpcy5zdGFydC55ICsgKGFscGhhICogcHQxRGlyLnkgLyBkZXQpXG4gICAgICAgICldO1xuICAgIH0sXG5cbiAgICBpc0RpZmZlcmVudGlhYmxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gIXRoaXMuc3RhcnQuZXF1YWxzKHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7ZG91YmxlfSBsZW5ndGggb2YgdGhlIGxpbmVcbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7cG9pbnR9IG15IG1pZHBvaW50XG4gICAgbWlkcG9pbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAodGhpcy5zdGFydC54ICsgdGhpcy5lbmQueCkgLyAyLFxuICAgICAgICAgICAgKHRoaXMuc3RhcnQueSArIHRoaXMuZW5kLnkpIC8gMlxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBwYXJhbGxlbDogZnVuY3Rpb24oZGlzdGFuY2UpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIGw7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gbDtcbiAgICAgICAgY29uc3QgZVJlZiA9IHN0YXJ0LmNsb25lKCkucm90YXRlKGVuZCwgMjcwKTtcbiAgICAgICAgY29uc3Qgc1JlZiA9IGVuZC5jbG9uZSgpLnJvdGF0ZShzdGFydCwgOTApO1xuICAgICAgICBzdGFydC5tb3ZlKHNSZWYsIGRpc3RhbmNlKTtcbiAgICAgICAgZW5kLm1vdmUoZVJlZiwgZGlzdGFuY2UpO1xuICAgICAgICByZXR1cm4gbDtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7cG9pbnR9IG15IHBvaW50IGF0ICd0JyA8MCwxPlxuICAgIHBvaW50QXQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgaWYgKHQgPD0gMCkgcmV0dXJuIHN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGlmICh0ID49IDEpIHJldHVybiBlbmQuY2xvbmUoKTtcblxuICAgICAgICByZXR1cm4gc3RhcnQubGVycChlbmQsIHQpO1xuICAgIH0sXG5cbiAgICBwb2ludEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuZ3RoID49IGxpbmVMZW5ndGgpIHJldHVybiAoZnJvbVN0YXJ0ID8gZW5kLmNsb25lKCkgOiBzdGFydC5jbG9uZSgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0KChmcm9tU3RhcnQgPyAobGVuZ3RoKSA6IChsaW5lTGVuZ3RoIC0gbGVuZ3RoKSkgLyBsaW5lTGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7bnVtYmVyfSB0aGUgb2Zmc2V0IG9mIHRoZSBwb2ludCBgcGAgZnJvbSB0aGUgbGluZS4gKyBpZiB0aGUgcG9pbnQgYHBgIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBsaW5lLCAtIGlmIG9uIHRoZSBsZWZ0IGFuZCAwIGlmIG9uIHRoZSBsaW5lLlxuICAgIHBvaW50T2Zmc2V0OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgc2lnbiBvZiB0aGUgZGV0ZXJtaW5hbnQgb2YgdmVjdG9ycyAoc3RhcnQsZW5kKSwgd2hlcmUgcCBpcyB0aGUgcXVlcnkgcG9pbnQuXG4gICAgICAgIHAgPSBuZXcgUG9pbnQocCk7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgdmFyIGRldGVybWluYW50ID0gKChlbmQueCAtIHN0YXJ0LngpICogKHAueSAtIHN0YXJ0LnkpIC0gKGVuZC55IC0gc3RhcnQueSkgKiAocC54IC0gc3RhcnQueCkpO1xuXG4gICAgICAgIHJldHVybiBkZXRlcm1pbmFudCAvIHRoaXMubGVuZ3RoKCk7XG4gICAgfSxcblxuICAgIHJvdGF0ZTogZnVuY3Rpb24ob3JpZ2luLCBhbmdsZSkge1xuXG4gICAgICAgIHRoaXMuc3RhcnQucm90YXRlKG9yaWdpbiwgYW5nbGUpO1xuICAgICAgICB0aGlzLmVuZC5yb3RhdGUob3JpZ2luLCBhbmdsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLmVuZC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgb3JpZ2luKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuZW5kLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge251bWJlcn0gc2NhbGUgdGhlIGxpbmUgc28gdGhhdCBpdCBoYXMgdGhlIHJlcXVlc3RlZCBsZW5ndGhcbiAgICBzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBjdXJyZW50TGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgaWYgKCFjdXJyZW50TGVuZ3RoKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgc2NhbGVGYWN0b3IgPSBsZW5ndGggLyBjdXJyZW50TGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShzY2FsZUZhY3Rvciwgc2NhbGVGYWN0b3IsIHRoaXMuc3RhcnQpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtpbnRlZ2VyfSBsZW5ndGggd2l0aG91dCBzcXJ0XG4gICAgLy8gQG5vdGUgZm9yIGFwcGxpY2F0aW9ucyB3aGVyZSB0aGUgZXhhY3QgbGVuZ3RoIGlzIG5vdCBuZWNlc3NhcnkgKGUuZy4gY29tcGFyZSBvbmx5KVxuICAgIHNxdWFyZWRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3F1YXJlZExlbmd0aCh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0RpZmZlcmVudGlhYmxlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICB2YXIgdGFuZ2VudFN0YXJ0ID0gdGhpcy5wb2ludEF0KHQpOyAvLyBjb25zdHJhaW5zIGB0YCBiZXR3ZWVuIDAgYW5kIDFcblxuICAgICAgICB2YXIgdGFuZ2VudExpbmUgPSBuZXcgTGluZShzdGFydCwgZW5kKTtcbiAgICAgICAgdGFuZ2VudExpbmUudHJhbnNsYXRlKHRhbmdlbnRTdGFydC54IC0gc3RhcnQueCwgdGFuZ2VudFN0YXJ0LnkgLSBzdGFydC55KTsgLy8gbW92ZSBzbyB0aGF0IHRhbmdlbnQgbGluZSBzdGFydHMgYXQgdGhlIHBvaW50IHJlcXVlc3RlZFxuXG4gICAgICAgIHJldHVybiB0YW5nZW50TGluZTtcbiAgICB9LFxuXG4gICAgdGFuZ2VudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgdmFyIHRhbmdlbnRTdGFydCA9IHRoaXMucG9pbnRBdExlbmd0aChsZW5ndGgpO1xuXG4gICAgICAgIHZhciB0YW5nZW50TGluZSA9IG5ldyBMaW5lKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0YW5nZW50TGluZS50cmFuc2xhdGUodGFuZ2VudFN0YXJ0LnggLSBzdGFydC54LCB0YW5nZW50U3RhcnQueSAtIHN0YXJ0LnkpOyAvLyBtb3ZlIHNvIHRoYXQgdGFuZ2VudCBsaW5lIHN0YXJ0cyBhdCB0aGUgcG9pbnQgcmVxdWVzdGVkXG5cbiAgICAgICAgcmV0dXJuIHRhbmdlbnRMaW5lO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQudG9TdHJpbmcoKSArICcgJyArIHRoaXMuZW5kLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuc2VyaWFsaXplKCkgKyAnICcgKyB0aGlzLmVuZC5zZXJpYWxpemUoKTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLmVuZC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4gdmVjdG9yIHtwb2ludH0gb2YgdGhlIGxpbmVcbiAgICB2ZWN0b3I6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5lbmQueCAtIHRoaXMuc3RhcnQueCwgdGhpcy5lbmQueSAtIHRoaXMuc3RhcnQueSk7XG4gICAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuTGluZS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gTGluZS5wcm90b3R5cGUuaW50ZXJzZWN0O1xuXG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbmV4cG9ydCBjb25zdCBsaW5lID0gTGluZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/line.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/line.squaredLength.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.squaredLength.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squaredLength: () => (/* binding */ squaredLength)\n/* harmony export */ });\n// @return {integer} length without sqrt\n// @note for applications where the exact length is not necessary (e.g. compare only)\nconst squaredLength = function(start, end) {\n\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = end.x;\n    var y1 = end.y;\n    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvbGluZS5zcXVhcmVkTGVuZ3RoLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLnNxdWFyZWRMZW5ndGgubWpzPzZmOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHJldHVybiB7aW50ZWdlcn0gbGVuZ3RoIHdpdGhvdXQgc3FydFxuLy8gQG5vdGUgZm9yIGFwcGxpY2F0aW9ucyB3aGVyZSB0aGUgZXhhY3QgbGVuZ3RoIGlzIG5vdCBuZWNlc3NhcnkgKGUuZy4gY29tcGFyZSBvbmx5KVxuZXhwb3J0IGNvbnN0IHNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG5cbiAgICB2YXIgeDAgPSBzdGFydC54O1xuICAgIHZhciB5MCA9IHN0YXJ0Lnk7XG4gICAgdmFyIHgxID0gZW5kLng7XG4gICAgdmFyIHkxID0gZW5kLnk7XG4gICAgcmV0dXJuICh4MCAtPSB4MSkgKiB4MCArICh5MCAtPSB5MSkgKiB5MDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/path.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@joint/core/src/g/path.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Path: () => (/* binding */ Path)\n/* harmony export */ });\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _extend_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extend.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/extend.mjs\");\n// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\n\n\n\n\n\n\nconst Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) || (obj instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__.Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_3__.types.Path,\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__.Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[2], +args[3]);\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[1]);\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcGF0aC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQzBDO0FBQ1I7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNFO0FBQy9COztBQUVQO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxtREFBbUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsZ0NBQWdDO0FBQ2hDLHdCQUF3QixPQUFPOztBQUUvQjs7QUFFQTtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBLHdCQUF3QixPQUFPOztBQUUvQjs7QUFFQSxzQ0FBc0MsMkNBQUkscUJBQXFCLDZDQUFLO0FBQ3BFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUMsMkNBQUk7QUFDdkM7O0FBRUEsa0JBQWtCLHdCQUF3Qiw2Q0FBSztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLDBCQUEwQjtBQUNoQzs7QUFFQSxNQUFNLHdCQUF3QiwyQ0FBSSxJQUFJO0FBQ3RDO0FBQ0E7O0FBRUEsTUFBTSx3QkFBd0IsNkNBQUssSUFBSTtBQUN2QztBQUNBOztBQUVBLE1BQU0sd0JBQXdCLG1EQUFRLElBQUk7QUFDMUMsZ0VBQWdFOztBQUVoRTtBQUNBLG9CQUFvQixPQUFPOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNB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Q0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFROztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FB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QUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSx1QkFBdUIsMkNBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSx1QkFBdUIsMkNBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrSkFBa0o7O0FBRWxKO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRCxzQkFBc0IsbURBQU0sbUJBQW1CLDJDQUFJOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL3BhdGgubWpzP2QwYjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWNjZXB0cyBwYXRoIGRhdGEgc3RyaW5nLCBhcnJheSBvZiBzZWdtZW50cywgYXJyYXkgb2YgQ3VydmVzIGFuZC9vciBMaW5lcywgb3IgYSBQb2x5bGluZS5cbi8vIFBhdGggY3JlYXRlZCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhIHZhbGlkIChzZXJpYWxpemFibGUpIHBhdGggKG1pZ2h0IG5vdCBzdGFydCB3aXRoIGFuIE0pLlxuaW1wb3J0IHsgUG9seWxpbmUgfSBmcm9tICcuL3BvbHlsaW5lLm1qcyc7XG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi9yZWN0Lm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcG9pbnQubWpzJztcbmltcG9ydCB7IExpbmUgfSBmcm9tICcuL2xpbmUubWpzJztcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi9jdXJ2ZS5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuL2V4dGVuZC5tanMnO1xuZXhwb3J0IGNvbnN0IFBhdGggPSBmdW5jdGlvbihhcmcpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXRoKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgoYXJnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHsgLy8gY3JlYXRlIGZyb20gYSBwYXRoIGRhdGEgc3RyaW5nXG4gICAgICAgIHJldHVybiBuZXcgUGF0aC5wYXJzZShhcmcpO1xuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcblxuICAgIHZhciBpO1xuICAgIHZhciBuO1xuXG4gICAgaWYgKCFhcmcpIHtcbiAgICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmdcblxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5sZW5ndGggIT09IDApIHsgLy8gaWYgYXJnIGlzIGEgbm9uLWVtcHR5IGFycmF5XG4gICAgICAgIC8vIGZsYXR0ZW4gb25lIGxldmVsIGRlZXBcbiAgICAgICAgLy8gc28gd2UgY2FuIGNoYWluIGFyYml0cmFyeSBQYXRoLmNyZWF0ZVNlZ21lbnQgcmVzdWx0c1xuICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjLmNvbmNhdCh2YWwpO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdbMF0uaXNTZWdtZW50KSB7IC8vIGNyZWF0ZSBmcm9tIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGFyZ1tpXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBjcmVhdGUgZnJvbSBhbiBhcnJheSBvZiBDdXJ2ZXMgYW5kL29yIExpbmVzXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNPYmogPSBudWxsO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ1tpXTtcblxuICAgICAgICAgICAgICAgIGlmICghKChvYmogaW5zdGFuY2VvZiBMaW5lKSB8fCAob2JqIGluc3RhbmNlb2YgQ3VydmUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBwYXRoIHNlZ21lbnQgZnJvbSB0aGUgcHJvdmlkZWQgb2JqZWN0LicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB0aGlzLmFwcGVuZFNlZ21lbnQoUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgb2JqLnN0YXJ0KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBvYmplY3RzIGRvIG5vdCBsaW5rIHVwLCBtb3ZldG8gc2VnbWVudHMgYXJlIGluc2VydGVkIHRvIGNvdmVyIHRoZSBnYXBzXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzT2JqICYmICFwcmV2aW91c09iai5lbmQuZXF1YWxzKG9iai5zdGFydCkpIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBvYmouc3RhcnQpKTtcblxuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBvYmouZW5kKSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBvYmouY29udHJvbFBvaW50MSwgb2JqLmNvbnRyb2xQb2ludDIsIG9iai5lbmQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwcmV2aW91c09iaiA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChhcmcuaXNTZWdtZW50KSB7IC8vIGNyZWF0ZSBmcm9tIGEgc2luZ2xlIHNlZ21lbnRcbiAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KGFyZyk7XG5cbiAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIExpbmUpIHsgLy8gY3JlYXRlIGZyb20gYSBzaW5nbGUgTGluZVxuICAgICAgICB0aGlzLmFwcGVuZFNlZ21lbnQoUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgYXJnLnN0YXJ0KSk7XG4gICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBhcmcuZW5kKSk7XG5cbiAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEN1cnZlKSB7IC8vIGNyZWF0ZSBmcm9tIGEgc2luZ2xlIEN1cnZlXG4gICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBhcmcuc3RhcnQpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnQycsIGFyZy5jb250cm9sUG9pbnQxLCBhcmcuY29udHJvbFBvaW50MiwgYXJnLmVuZCkpO1xuXG4gICAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBQb2x5bGluZSkgeyAvLyBjcmVhdGUgZnJvbSBhIFBvbHlsaW5lXG4gICAgICAgIGlmICghKGFyZy5wb2ludHMgJiYgKGFyZy5wb2ludHMubGVuZ3RoICE9PSAwKSkpIHJldHVybjsgLy8gaWYgUG9seWxpbmUgaGFzIG5vIHBvaW50cywgbGVhdmUgUGF0aCBlbXB0eVxuXG4gICAgICAgIG4gPSBhcmcucG9pbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBhcmcucG9pbnRzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTScsIHBvaW50KSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBwb2ludCkpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyB1bmtub3duIG9iamVjdFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBwYXRoIGZyb20gdGhlIHByb3ZpZGVkIG9iamVjdC4nKTtcbiAgICB9XG59O1xuXG4vLyBNb3JlIHBlcm1pc3NpdmUgdGhhbiBWLm5vcm1hbGl6ZVBhdGhEYXRhIGFuZCBQYXRoLnByb3RvdHlwZS5zZXJpYWxpemUuXG4vLyBBbGxvd3MgcGF0aCBkYXRhIHN0cmluZ3MgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aCBhIE1vdmV0byBjb21tYW5kICh1bmxpa2UgU1ZHIHNwZWNpZmljYXRpb24pLlxuLy8gRG9lcyBub3QgcmVxdWlyZSBzcGFjZXMgYmV0d2VlbiBlbGVtZW50czsgY29tbWFzIGFyZSBhbGxvd2VkLCBzZXBhcmF0b3JzIG1heSBiZSBvbWl0dGVkIHdoZW4gdW5hbWJpZ3VvdXMgKGUuZy4gJ1pNMTAsMTAnLCAnTDEuNi44JywgJ00xMDAtMjAwJykuXG4vLyBBbGxvd3MgZm9yIGNvbW1hbmQgYXJndW1lbnQgY2hhaW5pbmcuXG4vLyBUaHJvd3MgYW4gZXJyb3IgaWYgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBwcm92aWRlZCB3aXRoIGEgY29tbWFuZC5cbi8vIFRocm93cyBhbiBlcnJvciBpZiBhbiB1bnJlY29nbml6ZWQgcGF0aCBjb21tYW5kIGlzIHByb3ZpZGVkIChhY2NvcmRpbmcgdG8gUGF0aC5zZWdtZW50VHlwZXMpLiBPbmx5IGEgc3Vic2V0IG9mIFNWRyBjb21tYW5kcyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkIChMLCBDLCBNLCBaKS5cblBhdGgucGFyc2UgPSBmdW5jdGlvbihwYXRoRGF0YSkge1xuXG4gICAgaWYgKCFwYXRoRGF0YSkgcmV0dXJuIG5ldyBQYXRoKCk7XG5cbiAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKCk7XG5cbiAgICB2YXIgY29tbWFuZFJlID0gLyg/OlthLXpBLVpdICopKD86KD86LT9cXGQrKD86XFwuXFxkKyk/KD86ZVstK10/XFxkKyk/ICosPyAqKXwoPzotP1xcLlxcZCsgKiw/ICopKSt8KD86W2EtekEtWl0gKikoPyEgfFxcZHwtfFxcLikvZztcbiAgICB2YXIgY29tbWFuZHMgPSBwYXRoRGF0YS5tYXRjaChjb21tYW5kUmUpO1xuXG4gICAgdmFyIG51bUNvbW1hbmRzID0gY29tbWFuZHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29tbWFuZHM7IGkrKykge1xuXG4gICAgICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbaV07XG4gICAgICAgIHZhciBhcmdSZSA9IC8oPzpbYS16QS1aXSl8KD86KD86LT9cXGQrKD86XFwuXFxkKyk/KD86ZVstK10/XFxkKyk/KSl8KD86KD86LT9cXC5cXGQrKSkvZztcbiAgICAgICAgdmFyIGFyZ3MgPSBjb21tYW5kLm1hdGNoKGFyZ1JlKTtcblxuICAgICAgICB2YXIgc2VnbWVudCA9IFBhdGguY3JlYXRlU2VnbWVudC5hcHBseSh0aGlzLCBhcmdzKTsgLy8gYXJncyA9IFt0eXBlLCBjb29yZGluYXRlMSwgY29vcmRpbmF0ZTIuLi5dXG4gICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cbi8vIENyZWF0ZSBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4vLyBBY2NlcHRzIHVubGltaXRlZCBwb2ludHMvY29vcmRzIGFyZ3VtZW50cyBhZnRlciBgdHlwZWAuXG5QYXRoLmNyZWF0ZVNlZ21lbnQgPSBmdW5jdGlvbih0eXBlKSB7XG5cbiAgICBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcignVHlwZSBtdXN0IGJlIHByb3ZpZGVkLicpO1xuXG4gICAgdmFyIHNlZ21lbnRDb25zdHJ1Y3RvciA9IFBhdGguc2VnbWVudFR5cGVzW3R5cGVdO1xuICAgIGlmICghc2VnbWVudENvbnN0cnVjdG9yKSB0aHJvdyBuZXcgRXJyb3IodHlwZSArICcgaXMgbm90IGEgcmVjb2duaXplZCBwYXRoIHNlZ21lbnQgdHlwZS4nKTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7IC8vIGRvIG5vdCBhZGQgZmlyc3QgZWxlbWVudCAoYHR5cGVgKSB0byBhcmdzIGFycmF5XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcHBseVRvTmV3KHNlZ21lbnRDb25zdHJ1Y3RvciwgYXJncyk7XG59O1xuXG5QYXRoLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLlBhdGgsXG5cbiAgICAvLyBBY2NlcHRzIG9uZSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFzIGFyZ3VtZW50LlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBhcmd1bWVudCBpcyBub3QgYSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzLlxuICAgIGFwcGVuZFNlZ21lbnQ6IGZ1bmN0aW9uKGFyZykge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIHZhciBjdXJyZW50U2VnbWVudDtcblxuICAgICAgICB2YXIgcHJldmlvdXNTZWdtZW50ID0gKChudW1TZWdtZW50cyAhPT0gMCkgPyBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdIDogbnVsbCk7IC8vIGlmIHdlIGFyZSBhcHBlbmRpbmcgdG8gYW4gZW1wdHkgcGF0aCwgcHJldmlvdXNTZWdtZW50IGlzIG51bGxcbiAgICAgICAgdmFyIG5leHRTZWdtZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkgeyAvLyBhcmcgaXMgYSBzZWdtZW50XG4gICAgICAgICAgICBpZiAoIWFyZyB8fCAhYXJnLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50IHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHRoaXMucHJlcGFyZVNlZ21lbnQoYXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VycmVudFNlZ21lbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGFyZyBpcyBhbiBhcnJheSBvZiBzZWdtZW50c1xuICAgICAgICAgICAgLy8gZmxhdHRlbiBvbmUgbGV2ZWwgZGVlcFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGNoYWluIGFyYml0cmFyeSBQYXRoLmNyZWF0ZVNlZ21lbnQgcmVzdWx0c1xuICAgICAgICAgICAgYXJnID0gYXJnLnJlZHVjZShmdW5jdGlvbihhY2MsIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgIGlmICghYXJnWzBdLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50cyByZXF1aXJlZC4nKTtcblxuICAgICAgICAgICAgdmFyIG4gPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QXJnID0gYXJnW2ldO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0gdGhpcy5wcmVwYXJlU2VnbWVudChjdXJyZW50QXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGN1cnJlbnRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBjdXJyZW50U2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBiYm94IG9mIHRoZSBwYXRoLlxuICAgIC8vIElmIHBhdGggaGFzIG5vIHNlZ21lbnRzLCByZXR1cm5zIG51bGwuXG4gICAgLy8gSWYgcGF0aCBoYXMgb25seSBpbnZpc2libGUgc2VnbWVudHMsIHJldHVybnMgYmJveCBvZiB0aGUgZW5kIHBvaW50IG9mIGxhc3Qgc2VnbWVudC5cbiAgICBiYm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgdmFyIGJib3g7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRCQm94ID0gc2VnbWVudC5iYm94KCk7XG4gICAgICAgICAgICAgICAgYmJveCA9IGJib3ggPyBiYm94LnVuaW9uKHNlZ21lbnRCQm94KSA6IHNlZ21lbnRCQm94O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJib3gpIHJldHVybiBiYm94O1xuXG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIGhhcyBvbmx5IGludmlzaWJsZSBlbGVtZW50cywgcmV0dXJuIGVuZCBwb2ludCBvZiBsYXN0IHNlZ21lbnRcbiAgICAgICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KGxhc3RTZWdtZW50LmVuZC54LCBsYXN0U2VnbWVudC5lbmQueSwgMCwgMCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBuZXcgcGF0aCB0aGF0IGlzIGEgY2xvbmUgb2YgdGhpcyBwYXRoLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIHdvcmtzIGV2ZW4gaWYgcGF0aCBoYXMgbm8gc2VnbWVudHNcblxuICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldLmNsb25lKCk7XG4gICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VChwLCBvcHQpO1xuICAgICAgICBpZiAoIXQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXRUKHQpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHNlZ21lbnRTdWJkaXZpc2lvbnM6IHNlZ21lbnRTdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICB2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VChwLCBsb2NhbE9wdCk7XG4gICAgICAgIGlmICghdCkgcmV0dXJuIDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoQXRUKHQsIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBjcExlbmd0aCA9IHRoaXMuY2xvc2VzdFBvaW50TGVuZ3RoKHAsIGxvY2FsT3B0KTtcbiAgICAgICAgaWYgKGNwTGVuZ3RoID09PSAwKSByZXR1cm4gMDsgLy8gc2hvcnRjdXRcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMDsgLy8gcHJldmVudHMgZGl2aXNpb24gYnkgemVyb1xuXG4gICAgICAgIHJldHVybiBjcExlbmd0aCAvIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbi5cbiAgICBjbG9zZXN0UG9pbnRUOiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludFQ7XG4gICAgICAgIHZhciBtaW5TcXVhcmVkRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRDbG9zZXN0UG9pbnRUID0gc2VnbWVudC5jbG9zZXN0UG9pbnRUKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRDbG9zZXN0UG9pbnQgPSBzZWdtZW50LnBvaW50QXRUKHNlZ21lbnRDbG9zZXN0UG9pbnRUKTtcbiAgICAgICAgICAgICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gKG5ldyBMaW5lKHNlZ21lbnRDbG9zZXN0UG9pbnQsIHApKS5zcXVhcmVkTGVuZ3RoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RQb2ludFQgPSB7IHNlZ21lbnRJbmRleDogaSwgdmFsdWU6IHNlZ21lbnRDbG9zZXN0UG9pbnRUIH07XG4gICAgICAgICAgICAgICAgICAgIG1pblNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xvc2VzdFBvaW50VCkgcmV0dXJuIGNsb3Nlc3RQb2ludFQ7XG5cbiAgICAgICAgLy8gaWYgbm8gdmlzaWJsZSBzZWdtZW50LCByZXR1cm4gZW5kIG9mIGxhc3Qgc2VnbWVudFxuICAgICAgICByZXR1cm4geyBzZWdtZW50SW5kZXg6IG51bVNlZ21lbnRzIC0gMSwgdmFsdWU6IDEgfTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBjbG9zZXN0UG9pbnRUYW5nZW50O1xuICAgICAgICB2YXIgbWluU3F1YXJlZERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaV07XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50LmlzRGlmZmVyZW50aWFibGUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50Q2xvc2VzdFBvaW50VCA9IHNlZ21lbnQuY2xvc2VzdFBvaW50VChwLCB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50Q2xvc2VzdFBvaW50ID0gc2VnbWVudC5wb2ludEF0VChzZWdtZW50Q2xvc2VzdFBvaW50VCk7XG4gICAgICAgICAgICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IChuZXcgTGluZShzZWdtZW50Q2xvc2VzdFBvaW50LCBwKSkuc3F1YXJlZExlbmd0aCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8IG1pblNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0UG9pbnRUYW5nZW50ID0gc2VnbWVudC50YW5nZW50QXRUKHNlZ21lbnRDbG9zZXN0UG9pbnRUKTtcbiAgICAgICAgICAgICAgICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZXN0UG9pbnRUYW5nZW50KSByZXR1cm4gY2xvc2VzdFBvaW50VGFuZ2VudDtcblxuICAgICAgICAvLyBpZiBubyB2YWxpZCBzZWdtZW50LCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZWEgc3Vycm91bmRlZCBieSB0aGUgcGF0aCBjb250YWlucyB0aGUgcG9pbnQgYHBgLlxuICAgIC8vIEltcGxlbWVudHMgdGhlIGV2ZW4tb2RkIGFsZ29yaXRobSAoc2VsZi1pbnRlcnNlY3Rpb25zIGFyZSBcIm91dHNpZGVcIikuXG4gICAgLy8gQ2xvc2VzIG9wZW4gcGF0aHMgKGFsd2F5cyBpbWFnaW5lcyBhIGZpbmFsIGNsb3Npbmcgc2VnbWVudCkuXG4gICAgLy8gUHJlY2lzaW9uIG1heSBiZSBhZGp1c3RlZCBieSBwYXNzaW5nIGFuIGBvcHRgIG9iamVjdC5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICB2YXIgcG9seWxpbmVzID0gdGhpcy50b1BvbHlsaW5lcyhvcHQpO1xuICAgICAgICBpZiAoIXBvbHlsaW5lcykgcmV0dXJuIGZhbHNlOyAvLyBzaG9ydGN1dCAodGhpcyBwYXRoIGhhcyBubyBwb2x5bGluZXMpXG5cbiAgICAgICAgdmFyIG51bVBvbHlsaW5lcyA9IHBvbHlsaW5lcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gaG93IG1hbnkgY29tcG9uZW50IHBvbHlsaW5lcyBkb2VzIGBwYCBsaWUgd2l0aGluP1xuICAgICAgICB2YXIgbnVtSW50ZXJzZWN0aW9ucyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9seWxpbmVzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2x5bGluZSA9IHBvbHlsaW5lc1tpXTtcbiAgICAgICAgICAgIGlmIChwb2x5bGluZS5jb250YWluc1BvaW50KHApKSB7XG4gICAgICAgICAgICAgICAgLy8gYHBgIGxpZXMgd2l0aGluIHRoaXMgcG9seWxpbmVcbiAgICAgICAgICAgICAgICBudW1JbnRlcnNlY3Rpb25zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIGB0cnVlYCBmb3Igb2RkIG51bWJlcnMgb2YgaW50ZXJzZWN0aW9ucyAoZXZlbi1vZGQgYWxnb3JpdGhtKVxuICAgICAgICByZXR1cm4gKChudW1JbnRlcnNlY3Rpb25zICUgMikgPT09IDEpO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBwYXRoIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgcmF0aW9gIGJldHdlZW4gMCBhbmQgMSB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIGlmIChyYXRpbyA8IDApIHJhdGlvID0gMDtcbiAgICAgICAgaWYgKHJhdGlvID4gMSkgcmF0aW8gPSAxO1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHNlZ21lbnRTdWJkaXZpc2lvbnM6IHNlZ21lbnRTdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICB2YXIgcGF0aExlbmd0aCA9IHRoaXMubGVuZ3RoKGxvY2FsT3B0KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGhMZW5ndGggKiByYXRpbztcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVBdExlbmd0aChsZW5ndGgsIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlcyB0aGUgcGF0aCBpbnRvIHR3byBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgZGl2aWRlQXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gdGhpcy5zZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICAgIC8vIGlkZW50aWZ5IHRoZSBzZWdtZW50IHRvIGRpdmlkZTpcblxuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgdmFyIGRpdmlkZWQ7XG4gICAgICAgIHZhciBkaXZpZGVkU2VnbWVudEluZGV4O1xuICAgICAgICB2YXIgbGFzdFZhbGlkU2VnbWVudDsgLy8gdmlzaWJsZSBBTkQgZGlmZmVyZW50aWFibGVcbiAgICAgICAgdmFyIGxhc3RWYWxpZFNlZ21lbnRJbmRleDtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChudW1TZWdtZW50cyAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHNlZ21lbnQgPSB0aGlzLmdldFNlZ21lbnQoaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNEaWZmZXJlbnRpYWJsZSgpKSB7IC8vIHNlZ21lbnQgaXMgbm90IGp1c3QgYSBwb2ludFxuICAgICAgICAgICAgICAgIGxhc3RWYWxpZFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIGxhc3RWYWxpZFNlZ21lbnRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZWRTZWdtZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlZCA9IHNlZ21lbnQuZGl2aWRlQXRMZW5ndGgoKChmcm9tU3RhcnQgPyAxIDogLTEpICogKGxlbmd0aCAtIGwpKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9uc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsICs9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxhc3RWYWxpZFNlZ21lbnQpIHsgLy8gbm8gdmFsaWQgc2VnbWVudCBmb3VuZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlOiB0aGUgcGF0aCBjb250YWlucyBhdCBsZWFzdCBvbmUgdmFsaWQgc2VnbWVudFxuXG4gICAgICAgIGlmICghZGl2aWRlZCkgeyAvLyB0aGUgZGVzaXJlZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIHBhdGhcbiAgICAgICAgICAgIGRpdmlkZWRTZWdtZW50SW5kZXggPSBsYXN0VmFsaWRTZWdtZW50SW5kZXg7XG4gICAgICAgICAgICB0ID0gKGZyb21TdGFydCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGRpdmlkZWQgPSBsYXN0VmFsaWRTZWdtZW50LmRpdmlkZUF0VCh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgdGhpcyBwYXRoIGFuZCByZXBsYWNlIHRoZSBpZGVudGlmaWVkIHNlZ21lbnQgd2l0aCBpdHMgdHdvIGRpdmlkZWQgcGFydHM6XG5cbiAgICAgICAgdmFyIHBhdGhDb3B5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwYXRoQ29weS5yZXBsYWNlU2VnbWVudChkaXZpZGVkU2VnbWVudEluZGV4LCBkaXZpZGVkKTtcblxuICAgICAgICB2YXIgZGl2aXNpb25TdGFydEluZGV4ID0gZGl2aWRlZFNlZ21lbnRJbmRleDtcbiAgICAgICAgdmFyIGRpdmlzaW9uTWlkSW5kZXggPSBkaXZpZGVkU2VnbWVudEluZGV4ICsgMTtcbiAgICAgICAgdmFyIGRpdmlzaW9uRW5kSW5kZXggPSBkaXZpZGVkU2VnbWVudEluZGV4ICsgMjtcblxuICAgICAgICAvLyBkbyBub3QgaW5zZXJ0IHRoZSBwYXJ0IGlmIGl0IGxvb2tzIGxpa2UgYSBwb2ludFxuICAgICAgICBpZiAoIWRpdmlkZWRbMF0uaXNEaWZmZXJlbnRpYWJsZSgpKSB7XG4gICAgICAgICAgICBwYXRoQ29weS5yZW1vdmVTZWdtZW50KGRpdmlzaW9uU3RhcnRJbmRleCk7XG4gICAgICAgICAgICBkaXZpc2lvbk1pZEluZGV4IC09IDE7XG4gICAgICAgICAgICBkaXZpc2lvbkVuZEluZGV4IC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnNlcnQgYSBNb3ZldG8gc2VnbWVudCB0byBlbnN1cmUgc2Vjb25kUGF0aCB3aWxsIGJlIHZhbGlkOlxuICAgICAgICB2YXIgbW92ZXRvRW5kID0gcGF0aENvcHkuZ2V0U2VnbWVudChkaXZpc2lvbk1pZEluZGV4KS5zdGFydDtcbiAgICAgICAgcGF0aENvcHkuaW5zZXJ0U2VnbWVudChkaXZpc2lvbk1pZEluZGV4LCBQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBtb3ZldG9FbmQpKTtcbiAgICAgICAgZGl2aXNpb25FbmRJbmRleCArPSAxO1xuXG4gICAgICAgIC8vIGRvIG5vdCBpbnNlcnQgdGhlIHBhcnQgaWYgaXQgbG9va3MgbGlrZSBhIHBvaW50XG4gICAgICAgIGlmICghZGl2aWRlZFsxXS5pc0RpZmZlcmVudGlhYmxlKCkpIHtcbiAgICAgICAgICAgIHBhdGhDb3B5LnJlbW92ZVNlZ21lbnQoZGl2aXNpb25FbmRJbmRleCAtIDEpO1xuICAgICAgICAgICAgZGl2aXNpb25FbmRJbmRleCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgQ2xvc2VwYXRoIHNlZ21lbnRzIGluIHNlY29uZFBhdGggd2lsbCBiZSBhc3NpZ25lZCBjb3JyZWN0IHN1YnBhdGhTdGFydFNlZ21lbnQ6XG5cbiAgICAgICAgdmFyIHNlY29uZFBhdGhTZWdtZW50SW5kZXhDb252ZXJzaW9uID0gZGl2aXNpb25FbmRJbmRleCAtIGRpdmlzaW9uU3RhcnRJbmRleCAtIDE7XG4gICAgICAgIGZvciAoaSA9IGRpdmlzaW9uRW5kSW5kZXg7IGkgPCBwYXRoQ29weS5zZWdtZW50cy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxTZWdtZW50ID0gdGhpcy5nZXRTZWdtZW50KGkgLSBzZWNvbmRQYXRoU2VnbWVudEluZGV4Q29udmVyc2lvbik7XG4gICAgICAgICAgICBzZWdtZW50ID0gcGF0aENvcHkuZ2V0U2VnbWVudChpKTtcblxuICAgICAgICAgICAgaWYgKChzZWdtZW50LnR5cGUgPT09ICdaJykgJiYgIW9yaWdpbmFsU2VnbWVudC5zdWJwYXRoU3RhcnRTZWdtZW50LmVuZC5lcXVhbHMoc2VnbWVudC5zdWJwYXRoU3RhcnRTZWdtZW50LmVuZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXRoQ29weSBzZWdtZW50J3Mgc3VicGF0aFN0YXJ0U2VnbWVudCBpcyBkaWZmZXJlbnQgZnJvbSBvcmlnaW5hbCBzZWdtZW50J3Mgb25lXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCB0aGlzIENsb3NlcGF0aCBzZWdtZW50IHRvIGEgTGluZXRvIGFuZCByZXBsYWNlIGl0IGluIHBhdGhDb3B5XG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlZFNlZ21lbnQgPSBQYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBvcmlnaW5hbFNlZ21lbnQuZW5kKTtcbiAgICAgICAgICAgICAgICBwYXRoQ29weS5yZXBsYWNlU2VnbWVudChpLCBjb252ZXJ0ZWRTZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpc3RyaWJ1dGUgcGF0aENvcHkgc2VnbWVudHMgaW50byB0d28gcGF0aHMgYW5kIHJldHVybiB0aG9zZTpcblxuICAgICAgICB2YXIgZmlyc3RQYXRoID0gbmV3IFBhdGgocGF0aENvcHkuc2VnbWVudHMuc2xpY2UoMCwgZGl2aXNpb25NaWRJbmRleCkpO1xuICAgICAgICB2YXIgc2Vjb25kUGF0aCA9IG5ldyBQYXRoKHBhdGhDb3B5LnNlZ21lbnRzLnNsaWNlKGRpdmlzaW9uTWlkSW5kZXgpKTtcblxuICAgICAgICByZXR1cm4gW2ZpcnN0UGF0aCwgc2Vjb25kUGF0aF07XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIHR3byBwYXRocyBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgICAvLyBJZiBgcGAgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybnMgZmFsc2UuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgaWYgKCFwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG90aGVyU2VnbWVudHMgPSBwLnNlZ21lbnRzO1xuXG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG90aGVyU2VnbWVudHMubGVuZ3RoICE9PSBudW1TZWdtZW50cykgcmV0dXJuIGZhbHNlOyAvLyBpZiB0aGUgdHdvIHBhdGhzIGhhdmUgZGlmZmVyZW50IG51bWJlciBvZiBzZWdtZW50cywgdGhleSBjYW5ub3QgYmUgZXF1YWxcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBvdGhlclNlZ21lbnQgPSBvdGhlclNlZ21lbnRzW2ldO1xuXG4gICAgICAgICAgICAvLyBhcyBzb29uIGFzIGFuIGluZXF1YWxpdHkgaXMgZm91bmQgaW4gc2VnbWVudHMsIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgaWYgKChzZWdtZW50LnR5cGUgIT09IG90aGVyU2VnbWVudC50eXBlKSB8fCAoIXNlZ21lbnQuZXF1YWxzKG90aGVyU2VnbWVudCkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBpbmVxdWFsaXR5IGZvdW5kIGluIHNlZ21lbnRzLCByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBpbmRpY2VzLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBwYXRoIGhhcyBubyBzZWdtZW50cy5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgIGdldFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHRocm93IG5ldyBFcnJvcignUGF0aCBoYXMgbm8gc2VnbWVudHMuJyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBudW1TZWdtZW50cyArIGluZGV4OyAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXMgdG8gcG9zaXRpdmVcbiAgICAgICAgaWYgKGluZGV4ID49IG51bVNlZ21lbnRzIHx8IGluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UuJyk7XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBzZWdtZW50IHN1YmRpdmlzaW9ucywgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYC5cbiAgICBnZXRTZWdtZW50U3ViZGl2aXNpb25zOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIHdvcmtzIGV2ZW4gaWYgcGF0aCBoYXMgbm8gc2VnbWVudHNcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgLy8gbm90IHVzaW5nIG9wdC5zZWdtZW50U3ViZGl2aXNpb25zXG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnQuZ2V0U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSk7XG4gICAgICAgICAgICBzZWdtZW50U3ViZGl2aXNpb25zLnB1c2goc3ViZGl2aXNpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWdtZW50U3ViZGl2aXNpb25zO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHN1YnBhdGhzIG9mIHRoaXMgcGF0aC5cbiAgICAvLyBJbnZhbGlkIHBhdGhzIGFyZSB2YWxpZGF0ZWQgZmlyc3QuXG4gICAgLy8gUmV0dXJucyBgW11gIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzLlxuICAgIGdldFN1YnBhdGhzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCB2YWxpZGF0ZWRQYXRoID0gdGhpcy5jbG9uZSgpLnZhbGlkYXRlKCk7XG5cbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB2YWxpZGF0ZWRQYXRoLnNlZ21lbnRzO1xuICAgICAgICBjb25zdCBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBjb25zdCBzdWJwYXRocyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBlbmNvdW50ZXJlZCBhIHN1YnBhdGggc3RhcnQgc2VnbWVudFxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwYXRoIGZvciBzZWdtZW50LCBhbmQgcHVzaCBpdCB0byBsaXN0IG9mIHN1YnBhdGhzXG4gICAgICAgICAgICAgICAgc3VicGF0aHMucHVzaChuZXcgUGF0aChzZWdtZW50KSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGN1cnJlbnQgc2VnbWVudCB0byB0aGUgbGFzdCBzdWJwYXRoXG4gICAgICAgICAgICAgICAgc3VicGF0aHNbc3VicGF0aHMubGVuZ3RoIC0gMV0uYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdWJwYXRocztcbiAgICB9LFxuXG4gICAgLy8gSW5zZXJ0IGBhcmdgIGF0IGdpdmVuIGBpbmRleGAuXG4gICAgLy8gYGluZGV4ID0gMGAgbWVhbnMgaW5zZXJ0IGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgLy8gYGluZGV4ID0gc2VnbWVudHMubGVuZ3RoYCBtZWFucyBpbnNlcnQgYXQgdGhlIGVuZC5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGluZGljZXMsIGZyb20gYC0xYCB0byBgLShzZWdtZW50cy5sZW5ndGggKyAxKWAuXG4gICAgLy8gQWNjZXB0cyBvbmUgc2VnbWVudCBvciBhbiBhcnJheSBvZiBzZWdtZW50cyBhcyBhcmd1bWVudC5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBhcmd1bWVudCBpcyBub3QgYSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzLlxuICAgIGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4LCBhcmcpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIHdvcmtzIGV2ZW4gaWYgcGF0aCBoYXMgbm8gc2VnbWVudHNcblxuICAgICAgICAvLyBub3RlIHRoYXQgdGhlc2UgYXJlIGluY3JlbWVudGVkIGNvbXBhcmVkIHRvIGdldFNlZ21lbnRzKClcbiAgICAgICAgLy8gd2UgY2FuIGluc2VydCBhZnRlciBsYXN0IGVsZW1lbnQgKG5vdGUgdGhhdCB0aGlzIGNoYW5nZXMgdGhlIG1lYW5pbmcgb2YgaW5kZXggLTEpXG4gICAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbnVtU2VnbWVudHMgKyBpbmRleCArIDE7IC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlcyB0byBwb3NpdGl2ZVxuICAgICAgICBpZiAoaW5kZXggPiBudW1TZWdtZW50cyB8fCBpbmRleCA8IDApIHRocm93IG5ldyBFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlLicpO1xuXG4gICAgICAgIHZhciBjdXJyZW50U2VnbWVudDtcblxuICAgICAgICB2YXIgcHJldmlvdXNTZWdtZW50ID0gbnVsbDtcbiAgICAgICAgdmFyIG5leHRTZWdtZW50ID0gbnVsbDtcblxuICAgICAgICBpZiAobnVtU2VnbWVudHMgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTZWdtZW50ID0gc2VnbWVudHNbaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9IHByZXZpb3VzU2VnbWVudC5uZXh0U2VnbWVudDsgLy8gaWYgd2UgYXJlIGluc2VydGluZyBhdCBlbmQsIG5leHRTZWdtZW50IGlzIG51bGxcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaWYgaW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1NlZ21lbnQgaXMgbnVsbFxuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gc2VnbWVudHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgaWYgKCFhcmcgfHwgIWFyZy5pc1NlZ21lbnQpIHRocm93IG5ldyBFcnJvcignU2VnbWVudCByZXF1aXJlZC4nKTtcblxuICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGFyZywgcHJldmlvdXNTZWdtZW50LCBuZXh0U2VnbWVudCk7XG4gICAgICAgICAgICBzZWdtZW50cy5zcGxpY2UoaW5kZXgsIDAsIGN1cnJlbnRTZWdtZW50KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxhdHRlbiBvbmUgbGV2ZWwgZGVlcFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGNoYWluIGFyYml0cmFyeSBQYXRoLmNyZWF0ZVNlZ21lbnQgcmVzdWx0c1xuICAgICAgICAgICAgYXJnID0gYXJnLnJlZHVjZShmdW5jdGlvbihhY2MsIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgIGlmICghYXJnWzBdLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50cyByZXF1aXJlZC4nKTtcblxuICAgICAgICAgICAgdmFyIG4gPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QXJnID0gYXJnW2ldO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0gdGhpcy5wcmVwYXJlU2VnbWVudChjdXJyZW50QXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5zcGxpY2UoKGluZGV4ICsgaSksIDAsIGN1cnJlbnRTZWdtZW50KTsgLy8gaW5jcmVtZW50aW5nIGluZGV4IHRvIGluc2VydCBzdWJzZXF1ZW50IHNlZ21lbnRzIGFmdGVyIGluc2VydGVkIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTZWdtZW50ID0gY3VycmVudFNlZ21lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmU6IGZ1bmN0aW9uKGxpbmUsIG9wdCkge1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB2YXIgcG9seWxpbmVzID0gdGhpcy50b1BvbHlsaW5lcyhvcHQpO1xuICAgICAgICBpZiAoIXBvbHlsaW5lcykgcmV0dXJuIG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWxpbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gcG9seWxpbmVzW2ldO1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lSW50ZXJzZWN0aW9uID0gbGluZS5pbnRlcnNlY3QocG9seWxpbmUpO1xuICAgICAgICAgICAgaWYgKHBvbHlsaW5lSW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uIHx8IChpbnRlcnNlY3Rpb24gPSBbXSk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9seWxpbmVJbnRlcnNlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGludGVyc2VjdGlvbiwgcG9seWxpbmVJbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5wdXNoKHBvbHlsaW5lSW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgIH0sXG5cbiAgICBpc0RpZmZlcmVudGlhYmxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICAvLyBhcyBzb29uIGFzIGEgZGlmZmVyZW50aWFibGUgc2VnbWVudCBpcyBmb3VuZCBpbiBzZWdtZW50cywgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBkaWZmZXJlbnRpYWJsZSBzZWdtZW50IGlzIGZvdW5kIGluIHNlZ21lbnRzLCByZXR1cm4gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3Mgd2hldGhlciBjdXJyZW50IHBhdGggc2VnbWVudHMgYXJlIHZhbGlkLlxuICAgIC8vIE5vdGUgdGhhdCBkIGlzIGFsbG93ZWQgdG8gYmUgZW1wdHkgLSBzaG91bGQgZGlzYWJsZSByZW5kZXJpbmcgb2YgdGhlIHBhdGguXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAoc2VnbWVudHMubGVuZ3RoID09PSAwKSB8fCAoc2VnbWVudHNbMF0udHlwZSA9PT0gJ00nKTsgLy8gZWl0aGVyIGVtcHR5IG9yIGZpcnN0IHNlZ21lbnQgaXMgYSBNb3ZldG9cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgbGVuZ3RoIG9mIHRoZSBwYXRoLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvciB1c2luZyBgb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIElmIHBhdGggaGFzIG5vIHNlZ21lbnRzLCByZXR1cm5zIDAuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIDA7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247IC8vIG9wdC5wcmVjaXNpb24gb25seSB1c2VkIGluIGdldFNlZ21lbnRTdWJkaXZpc2lvbnMoKSBjYWxsXG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaV07XG4gICAgICAgICAgICBsZW5ndGggKz0gc2VnbWVudC5sZW5ndGgoeyBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgZnVuY3Rpb24uXG4gICAgbGVuZ3RoQXRUOiBmdW5jdGlvbih0LCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIDA7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IHQuc2VnbWVudEluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgcmV0dXJuIDA7IC8vIHJlZ2FyZGxlc3Mgb2YgdC52YWx1ZVxuXG4gICAgICAgIHZhciB0VmFsdWUgPSB0LnZhbHVlO1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4ID49IG51bVNlZ21lbnRzKSB7XG4gICAgICAgICAgICBzZWdtZW50SW5kZXggPSBudW1TZWdtZW50cyAtIDE7XG4gICAgICAgICAgICB0VmFsdWUgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRWYWx1ZSA8IDApIHRWYWx1ZSA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRWYWx1ZSA+IDEpIHRWYWx1ZSA9IDE7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudEluZGV4OyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaV07XG4gICAgICAgICAgICBsZW5ndGggKz0gc2VnbWVudC5sZW5ndGgoeyBwcmVjaXNpc29uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VnbWVudCA9IHNlZ21lbnRzW3NlZ21lbnRJbmRleF07XG4gICAgICAgIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgbGVuZ3RoICs9IHNlZ21lbnQubGVuZ3RoQXRUKHRWYWx1ZSwgeyBwcmVjaXNpc29uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuXG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcG9pbnQgYXQgcmVxdWVzdGVkIGByYXRpb2AgYmV0d2VlbiAwIGFuZCAxLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc2VnbWVudFN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgcG9pbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBpZiAocmF0aW8gPD0gMCkgcmV0dXJuIHRoaXMuc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgaWYgKHJhdGlvID49IDEpIHJldHVybiB0aGlzLmVuZC5jbG9uZSgpO1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHNlZ21lbnRTdWJkaXZpc2lvbnM6IHNlZ21lbnRTdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICB2YXIgcGF0aExlbmd0aCA9IHRoaXMubGVuZ3RoKGxvY2FsT3B0KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGhMZW5ndGggKiByYXRpbztcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHBvaW50IGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCwgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgbGVuZ3RoLlxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiB0aGlzLnN0YXJ0LmNsb25lKCk7XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlU2VnbWVudDtcbiAgICAgICAgdmFyIGwgPSAwOyAvLyBsZW5ndGggc28gZmFyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKGZyb21TdGFydCA/IGkgOiAobnVtU2VnbWVudHMgLSAxIC0gaSkpO1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBzZWdtZW50U3ViZGl2aXNpb25zW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBkID0gc2VnbWVudC5sZW5ndGgoeyBwcmVjaXNpb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfSk7XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPD0gKGwgKyBkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VnbWVudC5wb2ludEF0TGVuZ3RoKCgoZnJvbVN0YXJ0ID8gMSA6IC0xKSAqIChsZW5ndGggLSBsKSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGFzdFZpc2libGVTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVuZ3RoIHJlcXVlc3RlZCBpcyBoaWdoZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoLCByZXR1cm4gbGFzdCB2aXNpYmxlIHNlZ21lbnQgZW5kcG9pbnRcbiAgICAgICAgaWYgKGxhc3RWaXNpYmxlU2VnbWVudCkgcmV0dXJuIChmcm9tU3RhcnQgPyBsYXN0VmlzaWJsZVNlZ21lbnQuZW5kIDogbGFzdFZpc2libGVTZWdtZW50LnN0YXJ0KTtcblxuICAgICAgICAvLyBpZiBubyB2aXNpYmxlIHNlZ21lbnQsIHJldHVybiBsYXN0IHNlZ21lbnQgZW5kIHBvaW50IChubyBtYXR0ZXIgaWYgZnJvbVN0YXJ0IG9yIG5vKVxuICAgICAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdO1xuICAgICAgICByZXR1cm4gbGFzdFNlZ21lbnQuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgZnVuY3Rpb24uXG4gICAgcG9pbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IHQuc2VnbWVudEluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgcmV0dXJuIHNlZ21lbnRzWzBdLnBvaW50QXRUKDApO1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4ID49IG51bVNlZ21lbnRzKSByZXR1cm4gc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXS5wb2ludEF0VCgxKTtcblxuICAgICAgICB2YXIgdFZhbHVlID0gdC52YWx1ZTtcbiAgICAgICAgaWYgKHRWYWx1ZSA8IDApIHRWYWx1ZSA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRWYWx1ZSA+IDEpIHRWYWx1ZSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRJbmRleF0ucG9pbnRBdFQodFZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBwcmVjaXNpb25cbiAgICBQUkVDSVNJT046IDMsXG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kIGZvciBhZGRpbmcgc2VnbWVudHMuXG4gICAgcHJlcGFyZVNlZ21lbnQ6IGZ1bmN0aW9uKHNlZ21lbnQsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpIHtcblxuICAgICAgICAvLyBpbnNlcnQgYWZ0ZXIgcHJldmlvdXMgc2VnbWVudCBhbmQgYmVmb3JlIHByZXZpb3VzIHNlZ21lbnQncyBuZXh0IHNlZ21lbnRcbiAgICAgICAgc2VnbWVudC5wcmV2aW91c1NlZ21lbnQgPSBwcmV2aW91c1NlZ21lbnQ7XG4gICAgICAgIHNlZ21lbnQubmV4dFNlZ21lbnQgPSBuZXh0U2VnbWVudDtcbiAgICAgICAgaWYgKHByZXZpb3VzU2VnbWVudCkgcHJldmlvdXNTZWdtZW50Lm5leHRTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgaWYgKG5leHRTZWdtZW50KSBuZXh0U2VnbWVudC5wcmV2aW91c1NlZ21lbnQgPSBzZWdtZW50O1xuXG4gICAgICAgIHZhciB1cGRhdGVTdWJwYXRoU3RhcnQgPSBzZWdtZW50O1xuICAgICAgICBpZiAoc2VnbWVudC5pc1N1YnBhdGhTdGFydCkge1xuICAgICAgICAgICAgc2VnbWVudC5zdWJwYXRoU3RhcnRTZWdtZW50ID0gc2VnbWVudDsgLy8gYXNzaWduIHNlbGYgYXMgc3VicGF0aCBzdGFydCBzZWdtZW50XG4gICAgICAgICAgICB1cGRhdGVTdWJwYXRoU3RhcnQgPSBuZXh0U2VnbWVudDsgLy8gc3RhcnQgdXBkYXRpbmcgZnJvbSBuZXh0IHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFzc2lnbiBwcmV2aW91cyBzZWdtZW50J3Mgc3VicGF0aCBzdGFydCAob3Igc2VsZiBpZiBpdCBpcyBhIHN1YnBhdGggc3RhcnQpIHRvIHN1YnNlcXVlbnQgc2VnbWVudHNcbiAgICAgICAgaWYgKHVwZGF0ZVN1YnBhdGhTdGFydCkgdGhpcy51cGRhdGVTdWJwYXRoU3RhcnRTZWdtZW50KHVwZGF0ZVN1YnBhdGhTdGFydCk7XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnQ7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGUgc2VnbWVudCBhdCBgaW5kZXhgLlxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgaW5kaWNlcywgZnJvbSBgLTFgIHRvIGAtc2VnbWVudHMubGVuZ3RoYC5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgcGF0aCBoYXMgbm8gc2VnbWVudHMuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGluZGV4IGlzIG91dCBvZiByYW5nZS5cbiAgICByZW1vdmVTZWdtZW50OiBmdW5jdGlvbihpbmRleCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggaGFzIG5vIHNlZ21lbnRzLicpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ID0gbnVtU2VnbWVudHMgKyBpbmRleDsgLy8gY29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIHRvIHBvc2l0aXZlXG4gICAgICAgIGlmIChpbmRleCA+PSBudW1TZWdtZW50cyB8fCBpbmRleCA8IDApIHRocm93IG5ldyBFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlLicpO1xuXG4gICAgICAgIHZhciByZW1vdmVkU2VnbWVudCA9IHNlZ21lbnRzLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSByZW1vdmVkU2VnbWVudC5wcmV2aW91c1NlZ21lbnQ7XG4gICAgICAgIHZhciBuZXh0U2VnbWVudCA9IHJlbW92ZWRTZWdtZW50Lm5leHRTZWdtZW50O1xuXG4gICAgICAgIC8vIGxpbmsgdGhlIHByZXZpb3VzIGFuZCBuZXh0IHNlZ21lbnRzIHRvZ2V0aGVyIChpZiBwcmVzZW50KVxuICAgICAgICBpZiAocHJldmlvdXNTZWdtZW50KSBwcmV2aW91c1NlZ21lbnQubmV4dFNlZ21lbnQgPSBuZXh0U2VnbWVudDsgLy8gbWF5IGJlIG51bGxcbiAgICAgICAgaWYgKG5leHRTZWdtZW50KSBuZXh0U2VnbWVudC5wcmV2aW91c1NlZ21lbnQgPSBwcmV2aW91c1NlZ21lbnQ7IC8vIG1heSBiZSBudWxsXG5cbiAgICAgICAgLy8gaWYgcmVtb3ZlZCBzZWdtZW50IHVzZWQgdG8gc3RhcnQgYSBzdWJwYXRoLCB1cGRhdGUgYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMgdW50aWwgYW5vdGhlciBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgaXMgcmVhY2hlZFxuICAgICAgICBpZiAocmVtb3ZlZFNlZ21lbnQuaXNTdWJwYXRoU3RhcnQgJiYgbmV4dFNlZ21lbnQpIHRoaXMudXBkYXRlU3VicGF0aFN0YXJ0U2VnbWVudChuZXh0U2VnbWVudCk7XG4gICAgfSxcblxuICAgIC8vIFJlcGxhY2UgdGhlIHNlZ21lbnQgYXQgYGluZGV4YCB3aXRoIGBhcmdgLlxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgaW5kaWNlcywgZnJvbSBgLTFgIHRvIGAtc2VnbWVudHMubGVuZ3RoYC5cbiAgICAvLyBBY2NlcHRzIG9uZSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFzIGFyZ3VtZW50LlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBwYXRoIGhhcyBubyBzZWdtZW50cy5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBhcmd1bWVudCBpcyBub3QgYSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzLlxuICAgIHJlcGxhY2VTZWdtZW50OiBmdW5jdGlvbihpbmRleCwgYXJnKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHRocm93IG5ldyBFcnJvcignUGF0aCBoYXMgbm8gc2VnbWVudHMuJyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBudW1TZWdtZW50cyArIGluZGV4OyAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXMgdG8gcG9zaXRpdmVcbiAgICAgICAgaWYgKGluZGV4ID49IG51bVNlZ21lbnRzIHx8IGluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UuJyk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50O1xuXG4gICAgICAgIHZhciByZXBsYWNlZFNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSByZXBsYWNlZFNlZ21lbnQucHJldmlvdXNTZWdtZW50O1xuICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSByZXBsYWNlZFNlZ21lbnQubmV4dFNlZ21lbnQ7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVN1YnBhdGhTdGFydCA9IHJlcGxhY2VkU2VnbWVudC5pc1N1YnBhdGhTdGFydDsgLy8gYm9vbGVhbjogaXMgYW4gdXBkYXRlIG9mIHN1YnBhdGggc3RhcnRzIG5lY2Vzc2FyeT9cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgaWYgKCFhcmcgfHwgIWFyZy5pc1NlZ21lbnQpIHRocm93IG5ldyBFcnJvcignU2VnbWVudCByZXF1aXJlZC4nKTtcblxuICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGFyZywgcHJldmlvdXNTZWdtZW50LCBuZXh0U2VnbWVudCk7XG4gICAgICAgICAgICBzZWdtZW50cy5zcGxpY2UoaW5kZXgsIDEsIGN1cnJlbnRTZWdtZW50KTsgLy8gZGlyZWN0bHkgcmVwbGFjZVxuXG4gICAgICAgICAgICBpZiAodXBkYXRlU3VicGF0aFN0YXJ0ICYmIGN1cnJlbnRTZWdtZW50LmlzU3VicGF0aFN0YXJ0KSB1cGRhdGVTdWJwYXRoU3RhcnQgPSBmYWxzZTsgLy8gYWxyZWFkeSB1cGRhdGVkIGJ5IGBwcmVwYXJlU2VnbWVudGBcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxhdHRlbiBvbmUgbGV2ZWwgZGVlcFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIGNoYWluIGFyYml0cmFyeSBQYXRoLmNyZWF0ZVNlZ21lbnQgcmVzdWx0c1xuICAgICAgICAgICAgYXJnID0gYXJnLnJlZHVjZShmdW5jdGlvbihhY2MsIHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgICAgIGlmICghYXJnWzBdLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50cyByZXF1aXJlZC4nKTtcblxuICAgICAgICAgICAgc2VnbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgdmFyIG4gPSBhcmcubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QXJnID0gYXJnW2ldO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0gdGhpcy5wcmVwYXJlU2VnbWVudChjdXJyZW50QXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5zcGxpY2UoKGluZGV4ICsgaSksIDAsIGN1cnJlbnRTZWdtZW50KTsgLy8gaW5jcmVtZW50aW5nIGluZGV4IHRvIGluc2VydCBzdWJzZXF1ZW50IHNlZ21lbnRzIGFmdGVyIGluc2VydGVkIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTZWdtZW50ID0gY3VycmVudFNlZ21lbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlU3VicGF0aFN0YXJ0ICYmIGN1cnJlbnRTZWdtZW50LmlzU3VicGF0aFN0YXJ0KSB1cGRhdGVTdWJwYXRoU3RhcnQgPSBmYWxzZTsgLy8gYWxyZWFkeSB1cGRhdGVkIGJ5IGBwcmVwYXJlU2VnbWVudGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHJlcGxhY2VkIHNlZ21lbnQgdXNlZCB0byBzdGFydCBhIHN1YnBhdGggYW5kIG5vIG5ldyBzdWJwYXRoIHN0YXJ0IHdhcyBhZGRlZCwgdXBkYXRlIGFsbCBzdWJzZXF1ZW50IHNlZ21lbnRzIHVudGlsIGFub3RoZXIgc3VicGF0aCBzdGFydCBzZWdtZW50IGlzIHJlYWNoZWRcbiAgICAgICAgaWYgKHVwZGF0ZVN1YnBhdGhTdGFydCAmJiBuZXh0U2VnbWVudCkgdGhpcy51cGRhdGVTdWJwYXRoU3RhcnRTZWdtZW50KG5leHRTZWdtZW50KTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHNlZ21lbnQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBzZWdtZW50LnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZWdtZW50QXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleEF0KHJhdGlvLCBvcHQpO1xuICAgICAgICBpZiAoIWluZGV4KSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWdtZW50KGluZGV4KTtcbiAgICB9LFxuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBsZW5ndGguXG4gICAgc2VnbWVudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4QXRMZW5ndGgobGVuZ3RoLCBvcHQpO1xuICAgICAgICBpZiAoIWluZGV4KSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWdtZW50KGluZGV4KTtcbiAgICB9LFxuXG4gICAgc2VnbWVudEluZGV4QXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgMCkgcmF0aW8gPSAwO1xuICAgICAgICBpZiAocmF0aW8gPiAxKSByYXRpbyA9IDE7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aExlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRJbmRleEF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGxlbmd0aC5cbiAgICBzZWdtZW50SW5kZXhBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlU2VnbWVudEluZGV4ID0gbnVsbDtcbiAgICAgICAgdmFyIGwgPSAwOyAvLyBsZW5ndGggc28gZmFyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKGZyb21TdGFydCA/IGkgOiAobnVtU2VnbWVudHMgLSAxIC0gaSkpO1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBzZWdtZW50U3ViZGl2aXNpb25zW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBkID0gc2VnbWVudC5sZW5ndGgoeyBwcmVjaXNpb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfSk7XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPD0gKGwgKyBkKSkgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgIGxhc3RWaXNpYmxlU2VnbWVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlbmd0aCByZXF1ZXN0ZWQgaXMgaGlnaGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgcmV0dXJuIGxhc3QgdmlzaWJsZSBzZWdtZW50IGluZGV4XG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIG51bGxcbiAgICAgICAgcmV0dXJuIGxhc3RWaXNpYmxlU2VnbWVudEluZGV4O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVjb25zdHJ1Y3QgdGhlIHBhdGguXG4gICAgLy8gQWRkaXRpb25hbCBlcnJvciBjaGVja2luZyBjb21wYXJlZCB0byB0b1N0cmluZyAobXVzdCBzdGFydCB3aXRoIE0gc2VnbWVudCkuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0aCBzZWdtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRhbmdlbnQgbGluZSBhdCByZXF1ZXN0ZWQgYHJhdGlvYCBiZXR3ZWVuIDAgYW5kIDEsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zZWdtZW50U3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgMCkgcmF0aW8gPSAwO1xuICAgICAgICBpZiAocmF0aW8gPiAxKSByYXRpbyA9IDE7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aExlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdExlbmd0aChsZW5ndGgsIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0YW5nZW50IGxpbmUgYXQgcmVxdWVzdGVkIGBsZW5ndGhgLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc2VnbWVudFN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBsZW5ndGguXG4gICAgdGFuZ2VudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGFzdFZhbGlkU2VnbWVudDsgLy8gdmlzaWJsZSBBTkQgZGlmZmVyZW50aWFibGUgKHdpdGggYSB0YW5nZW50KVxuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChudW1TZWdtZW50cyAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNEaWZmZXJlbnRpYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWdtZW50LnRhbmdlbnRBdExlbmd0aCgoKGZyb21TdGFydCA/IDEgOiAtMSkgKiAobGVuZ3RoIC0gbCkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxhc3RWYWxpZFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsICs9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZW5ndGggcmVxdWVzdGVkIGlzIGhpZ2hlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIHBhdGgsIHJldHVybiB0YW5nZW50IG9mIGVuZHBvaW50IG9mIGxhc3QgdmFsaWQgc2VnbWVudFxuICAgICAgICBpZiAobGFzdFZhbGlkU2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIHQgPSAoZnJvbVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWYWxpZFNlZ21lbnQudGFuZ2VudEF0VCh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZhbGlkIHNlZ21lbnQsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIGZ1bmN0aW9uLlxuICAgIHRhbmdlbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IHQuc2VnbWVudEluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgcmV0dXJuIHNlZ21lbnRzWzBdLnRhbmdlbnRBdFQoMCk7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPj0gbnVtU2VnbWVudHMpIHJldHVybiBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLnRhbmdlbnRBdFQoMSk7XG5cbiAgICAgICAgdmFyIHRWYWx1ZSA9IHQudmFsdWU7XG4gICAgICAgIGlmICh0VmFsdWUgPCAwKSB0VmFsdWUgPSAwO1xuICAgICAgICBlbHNlIGlmICh0VmFsdWUgPiAxKSB0VmFsdWUgPSAxO1xuXG4gICAgICAgIHJldHVybiBzZWdtZW50c1tzZWdtZW50SW5kZXhdLnRhbmdlbnRBdFQodFZhbHVlKTtcbiAgICB9LFxuXG4gICAgdG9Qb2ludHM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHBhcnRpYWxQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50U3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNlZ21lbnRTdWJkaXZpc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25Qb2ludHMgPSBjdXJyZW50U2VnbWVudFN1YmRpdmlzaW9ucy5tYXAoZnVuY3Rpb24oY3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJ2ZS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHBhcnRpYWxQb2ludHMsIHN1YmRpdmlzaW9uUG9pbnRzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsUG9pbnRzLnB1c2goc2VnbWVudC5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0aWFsUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsUG9pbnRzLnB1c2goc2VnbWVudHNbaSAtIDFdLmVuZCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocGFydGlhbFBvaW50cyk7XG4gICAgICAgICAgICAgICAgcGFydGlhbFBvaW50cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRpYWxQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFydGlhbFBvaW50cy5wdXNoKHRoaXMuZW5kKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBhcnRpYWxQb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfSxcblxuICAgIHRvUG9seWxpbmVzOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICB2YXIgcG9seWxpbmVzID0gW107XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnRvUG9pbnRzKG9wdCk7XG4gICAgICAgIGlmICghcG9pbnRzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBwb2x5bGluZXMucHVzaChuZXcgUG9seWxpbmUocG9pbnRzW2ldKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9seWxpbmVzO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBwYXRoRGF0YSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHBhdGhEYXRhICs9IHNlZ21lbnQuc2VyaWFsaXplKCkgKyAnICc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aERhdGEudHJpbSgpO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHNlZ21lbnQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gSGVscGVyIG1ldGhvZCBmb3IgdXBkYXRpbmcgc3VicGF0aCBzdGFydCBvZiBzZWdtZW50cywgc3RhcnRpbmcgd2l0aCB0aGUgb25lIHByb3ZpZGVkLlxuICAgIHVwZGF0ZVN1YnBhdGhTdGFydFNlZ21lbnQ6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblxuICAgICAgICB2YXIgcHJldmlvdXNTZWdtZW50ID0gc2VnbWVudC5wcmV2aW91c1NlZ21lbnQ7IC8vIG1heSBiZSBudWxsXG4gICAgICAgIHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50LmlzU3VicGF0aFN0YXJ0KSB7XG5cbiAgICAgICAgICAgIC8vIGFzc2lnbiBwcmV2aW91cyBzZWdtZW50J3Mgc3VicGF0aCBzdGFydCBzZWdtZW50IHRvIHRoaXMgc2VnbWVudFxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2VnbWVudCkgc2VnbWVudC5zdWJwYXRoU3RhcnRTZWdtZW50ID0gcHJldmlvdXNTZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQ7IC8vIG1heSBiZSBudWxsXG4gICAgICAgICAgICBlbHNlIHNlZ21lbnQuc3VicGF0aFN0YXJ0U2VnbWVudCA9IG51bGw7IC8vIGlmIHNlZ21lbnQgaGFkIG5vIHByZXZpb3VzIHNlZ21lbnQsIGFzc2lnbiBudWxsIC0gY3JlYXRlcyBhbiBpbnZhbGlkIHBhdGghXG5cbiAgICAgICAgICAgIHByZXZpb3VzU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudC5uZXh0U2VnbWVudDsgLy8gbW92ZSBvbiB0byB0aGUgc2VnbWVudCBhZnRlciBldGMuXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gSWYgdGhlIHBhdGggaXMgbm90IHZhbGlkLCBpbnNlcnQgTSAwIDAgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAvLyBQYXRoIHdpdGggbm8gc2VnbWVudHMgaXMgY29uc2lkZXJlZCB2YWxpZCwgc28gbm90aGluZyBpcyBpbnNlcnRlZC5cbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkgdGhpcy5pbnNlcnRTZWdtZW50KDAsIFBhdGguY3JlYXRlU2VnbWVudCgnTScsIDAsIDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhdGgucHJvdG90eXBlLCAnc3RhcnQnLCB7XG4gICAgLy8gR2V0dGVyIGZvciB0aGUgZmlyc3QgdmlzaWJsZSBlbmRwb2ludCBvZiB0aGUgcGF0aC5cblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmlzVmlzaWJsZSkgcmV0dXJuIHNlZ21lbnQuc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyB2aXNpYmxlIHNlZ21lbnQsIHJldHVybiBsYXN0IHNlZ21lbnQgZW5kIHBvaW50XG4gICAgICAgIHJldHVybiBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLmVuZDtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhdGgucHJvdG90eXBlLCAnZW5kJywge1xuICAgIC8vIEdldHRlciBmb3IgdGhlIGxhc3QgdmlzaWJsZSBlbmRwb2ludCBvZiB0aGUgcGF0aC5cblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gbnVtU2VnbWVudHMgLSAxOyBpID49IDA7IGktLSkge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSByZXR1cm4gc2VnbWVudC5lbmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyB2aXNpYmxlIHNlZ21lbnQsIHJldHVybiBsYXN0IHNlZ21lbnQgZW5kIHBvaW50XG4gICAgICAgIHJldHVybiBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLmVuZDtcbiAgICB9XG59KTtcblxuXG4vLyBMb2NhbCBoZWxwZXIgZnVuY3Rpb24uXG4vLyBVc2UgYW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGNhbGwgYSBjb25zdHJ1Y3RvciAoZnVuY3Rpb24gY2FsbGVkIHdpdGggYG5ld2ApLlxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84ODQzMTgxLzIyNjM1OTVcbi8vIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gdXNlIHRoaXMgZnVuY3Rpb24gaWYgdGhlIGFyZ3VtZW50cyBjYW4gYmUgcGFzc2VkIHNlcGFyYXRlbHkgKGkuZS4gaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgbGltaXRlZCkuXG4vLyAtIElmIHRoYXQgaXMgdGhlIGNhc2UsIHVzZSBgbmV3IGNvbnN0cnVjdG9yKGFyZzEsIGFyZzIpYCwgZm9yIGV4YW1wbGUuXG4vLyBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIHVzZSB0aGlzIGZ1bmN0aW9uIGlmIHRoZSBmdW5jdGlvbiB0aGF0IG5lZWRzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgdXNlZCBhcyBhIGNvbnN0cnVjdG9yLlxuLy8gLSBJZiB0aGF0IGlzIHRoZSBjYXNlLCB1c2UgYGYuYXBwbHkodGhpc0FyZywgW2FyZzEsIGFyZzIuLi5dKWAsIGZvciBleGFtcGxlLlxuZnVuY3Rpb24gYXBwbHlUb05ldyhjb25zdHJ1Y3RvciwgYXJnc0FycmF5KSB7XG4gICAgLy8gVGhlIGBuZXdgIGtleXdvcmQgY2FuIG9ubHkgYmUgYXBwbGllZCB0byBmdW5jdGlvbnMgdGhhdCB0YWtlIGEgbGltaXRlZCBudW1iZXIgb2YgYXJndW1lbnRzLlxuICAgIC8vIC0gV2UgY2FuIGZha2UgdGhhdCB3aXRoIC5iaW5kKCkuXG4gICAgLy8gLSBJdCBjYWxscyBhIGZ1bmN0aW9uIChgY29uc3RydWN0b3JgLCBoZXJlKSB3aXRoIHRoZSBhcmd1bWVudHMgdGhhdCB3ZXJlIHByb3ZpZGVkIHRvIGl0IC0gZWZmZWN0aXZlbHkgdHJhbnNmb3JtaW5nIGFuIHVubGltaXRlZCBudW1iZXIgb2YgYXJndW1lbnRzIGludG8gbGltaXRlZC5cbiAgICAvLyAtIFNvIGBuZXcgKGNvbnN0cnVjdG9yLmJpbmQodGhpc0FyZywgYXJnMSwgYXJnMi4uLikpYFxuICAgIC8vIC0gYHRoaXNBcmdgIGNhbiBiZSBhbnl0aGluZyAoZS5nLiBudWxsKSBiZWNhdXNlIGBuZXdgIGtleXdvcmQgcmVzZXRzIGNvbnRleHQgdG8gdGhlIGNvbnN0cnVjdG9yIG9iamVjdC5cbiAgICAvLyBXZSBuZWVkIHRvIHBhc3MgaW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHRoZSBiaW5kKCkgY2FsbC5cbiAgICAvLyAtIFdlIGNhbiB1c2UgLmFwcGx5KCkuXG4gICAgLy8gLSBTbyBgbmV3IChjb25zdHJ1Y3Rvci5iaW5kLmFwcGx5KGNvbnN0cnVjdG9yLCBbdGhpc0FyZywgYXJnMSwgYXJnMi4uLl0pKWBcbiAgICAvLyAtIGB0aGlzQXJnYCBjYW4gc3RpbGwgYmUgYW55dGhpbmcgYmVjYXVzZSBgbmV3YCBvdmVyd3JpdGVzIGl0LlxuICAgIC8vIEZpbmFsbHksIHRvIG1ha2Ugc3VyZSB0aGF0IGNvbnN0cnVjdG9yLmJpbmQgb3ZlcndyaXRpbmcgaXMgbm90IGEgcHJvYmxlbSwgd2Ugc3dpdGNoIHRvIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAuXG4gICAgLy8gLSBTbywgdGhlIGZpbmFsIHZlcnNpb24gaXMgYG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoY29uc3RydWN0b3IsIFt0aGlzQXJnLCBhcmcxLCBhcmcyLi4uXSkpYFxuXG4gICAgLy8gVGhlIGZ1bmN0aW9uIGV4cGVjdHMgYGFyZ3NBcnJheVswXWAgdG8gYmUgYHRoaXNBcmdgLlxuICAgIC8vIC0gVGhpcyBtZWFucyB0aGF0IHdoYXRldmVyIGlzIHNlbnQgYXMgdGhlIGZpcnN0IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICAgIC8vIC0gVGhlIGNvbnN0cnVjdG9yIHdpbGwgb25seSBzZWUgYXJndW1lbnRzIHN0YXJ0aW5nIGZyb20gYXJnc0FycmF5WzFdLlxuICAgIC8vIC0gU28sIGEgbmV3IGR1bW15IGVsZW1lbnQgaXMgaW5zZXJ0ZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheS5cbiAgICBhcmdzQXJyYXkudW5zaGlmdChudWxsKTtcblxuICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KGNvbnN0cnVjdG9yLCBhcmdzQXJyYXkpKTtcbn1cblxuLy8gUGF0aCBzZWdtZW50IGludGVyZmFjZTpcbnZhciBzZWdtZW50UHJvdG90eXBlID0ge1xuXG4gICAgLy8gdmlydHVhbFxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyBSZWRpcmVjdCBjYWxscyB0byBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKCkgZnVuY3Rpb24gaWYgY2xvc2VzdFBvaW50VCgpIGlzIG5vdCBkZWZpbmVkIGZvciBzZWdtZW50LlxuICAgIGNsb3Nlc3RQb2ludFQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICBpZiAodGhpcy5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKHApO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBjbG9zZXN0UG9pbnRUKCkgbm9yIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgoKSBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZC4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGNsb3Nlc3RQb2ludFRhbmdlbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyBSZWRpcmVjdCBjYWxscyB0byBkaXZpZGVBdCgpIGZ1bmN0aW9uIGlmIGRpdmlkZUF0VCgpIGlzIG5vdCBkZWZpbmVkIGZvciBzZWdtZW50LlxuICAgIGRpdmlkZUF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0aGlzLmRpdmlkZUF0KSByZXR1cm4gdGhpcy5kaXZpZGVBdCh0KTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05laXRoZXIgZGl2aWRlQXRUKCkgbm9yIGRpdmlkZUF0KCkgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQuJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBlcXVhbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGdldFN1YmRpdmlzaW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICBpc1NlZ21lbnQ6IHRydWUsXG5cbiAgICBpc1N1YnBhdGhTdGFydDogZmFsc2UsIC8vIHRydWUgZm9yIE1vdmV0byBzZWdtZW50c1xuXG4gICAgaXNWaXNpYmxlOiB0cnVlLCAvLyBmYWxzZSBmb3IgTW92ZXRvIHNlZ21lbnRzXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhIGZyYWN0aW9uIG9mIHJlc3VsdCBvZiBsZW5ndGgoKSBmdW5jdGlvbiBpZiBsZW5ndGhBdFQoKSBpcyBub3QgZGVmaW5lZCBmb3Igc2VnbWVudC5cbiAgICBsZW5ndGhBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgICAgICBpZiAodCA+PSAxKSByZXR1cm4gbGVuZ3RoO1xuXG4gICAgICAgIHJldHVybiBsZW5ndGggKiB0O1xuICAgIH0sXG5cbiAgICBuZXh0U2VnbWVudDogbnVsbCwgLy8gbmVlZGVkIGZvciBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgdXBkYXRpbmdcblxuICAgIC8vIHZpcnR1YWxcbiAgICBwb2ludEF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBwb2ludEF0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIFJlZGlyZWN0IGNhbGxzIHRvIHBvaW50QXQoKSBmdW5jdGlvbiBpZiBwb2ludEF0VCgpIGlzIG5vdCBkZWZpbmVkIGZvciBzZWdtZW50LlxuICAgIHBvaW50QXRUOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMucG9pbnRBdCkgcmV0dXJuIHRoaXMucG9pbnRBdCh0KTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05laXRoZXIgcG9pbnRBdFQoKSBub3IgcG9pbnRBdCgpIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICBwcmV2aW91c1NlZ21lbnQ6IG51bGwsIC8vIG5lZWRlZCB0byBnZXQgc2VnbWVudCBzdGFydCBwcm9wZXJ0eVxuXG4gICAgLy8gdmlydHVhbFxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIHN1YnBhdGhTdGFydFNlZ21lbnQ6IG51bGwsIC8vIG5lZWRlZCB0byBnZXQgQ2xvc2VwYXRoIHNlZ21lbnQgZW5kIHByb3BlcnR5XG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgdGFuZ2VudEF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gUmVkaXJlY3QgY2FsbHMgdG8gdGFuZ2VudEF0KCkgZnVuY3Rpb24gaWYgdGFuZ2VudEF0VCgpIGlzIG5vdCBkZWZpbmVkIGZvciBzZWdtZW50LlxuICAgIHRhbmdlbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAodGhpcy50YW5nZW50QXQpIHJldHVybiB0aGlzLnRhbmdlbnRBdCh0KTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05laXRoZXIgdGFuZ2VudEF0VCgpIG5vciB0YW5nZW50QXQoKSBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZC4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9XG59O1xuXG4vLyB1c3VhbGx5IGRpcmVjdGx5IGFzc2lnbmVkXG4vLyBnZXR0ZXIgZm9yIENsb3NlcGF0aFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlZ21lbnRQcm90b3R5cGUsICdlbmQnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vLyBhbHdheXMgYSBnZXR0ZXJcbi8vIGFsd2F5cyB0aHJvd3MgZXJyb3IgZm9yIE1vdmV0b1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlZ21lbnRQcm90b3R5cGUsICdzdGFydCcsIHtcbiAgICAvLyBnZXQgYSByZWZlcmVuY2UgdG8gdGhlIGVuZCBwb2ludCBvZiBwcmV2aW91cyBzZWdtZW50XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJldmlvdXMgc2VnbWVudC4gKFRoaXMgc2VnbWVudCBjYW5ub3QgYmUgdGhlIGZpcnN0IHNlZ21lbnQgb2YgYSBwYXRoOyBPUiBzZWdtZW50IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQgdG8gYSBwYXRoLiknKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91c1NlZ21lbnQuZW5kO1xuICAgIH1cbn0pO1xuXG4vLyB2aXJ0dWFsXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2VnbWVudFByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzZWdtZW50IGRlY2xhcmF0aW9uLiBObyB0eXBlIHNwZWNpZmllZC4nKTtcbiAgICB9XG59KTtcblxuLy8gUGF0aCBzZWdtZW50IGltcGxlbWVudGF0aW9uczpcbnZhciBMaW5ldG8gPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5ldG8pKSB7IC8vIHN3aXRjaGluZyBjb250ZXh0IG9mIGB0aGlzYCB0byBMaW5ldG8gd2hlbiBjYWxsZWQgd2l0aG91dCBgbmV3YFxuICAgICAgICByZXR1cm4gYXBwbHlUb05ldyhMaW5ldG8sIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGluZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzIChub25lIHByb3ZpZGVkKS4nKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0QXJyYXk7XG5cbiAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIExpbmUpIHsgLy8gbGluZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYXJnc1swXS5lbmQuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGxpbmVzIHByb3ZpZGVkKS4nKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInKSB7IC8vIGNvb3JkaW5hdGVzIHByb3ZpZGVkXG4gICAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBQb2ludCgrYXJnc1swXSwgK2FyZ3NbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5ldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGxpbmUsIDEgcG9pbnQsIG9yIDIgY29vcmRpbmF0ZXMgKCcgKyBuICsgJyBjb29yZGluYXRlcyBwcm92aWRlZCkuJyk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhpcyBpcyBhIHBvbHktbGluZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudENvb3JkcztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAyKSB7IC8vIGNvb3JkcyBjb21lIGluIGdyb3VwcyBvZiB0d29cblxuICAgICAgICAgICAgICAgIHNlZ21lbnRDb29yZHMgPSBhcmdzLnNsaWNlKGksIGkgKyAyKTsgLy8gd2lsbCBzZW5kIG9uZSBjb29yZCBpZiBhcmdzLmxlbmd0aCBub3QgZGl2aXNpYmxlIGJ5IDJcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKGFwcGx5VG9OZXcoTGluZXRvLCBzZWdtZW50Q29vcmRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIHBvaW50cyBwcm92aWRlZCAobmVlZHMgdG8gYmUgbGFzdCB0byBhbHNvIGNvdmVyIHBsYWluIG9iamVjdHMgd2l0aCB4IGFuZCB5KVxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQoYXJnc1swXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGlzIGlzIGEgcG9seS1saW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBzZWdtZW50UG9pbnQ7XG4gICAgICAgICAgICBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvaW50ID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKG5ldyBMaW5ldG8oc2VnbWVudFBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbGluZXRvUHJvdG90eXBlID0ge1xuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZXRvKHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIHZhciBkaXZpZGVkID0gbGluZS5kaXZpZGVBdChyYXRpbyk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgTGluZXRvKGRpdmlkZWRbMF0pLFxuICAgICAgICAgICAgbmV3IExpbmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIHZhciBkaXZpZGVkID0gbGluZS5kaXZpZGVBdExlbmd0aChsZW5ndGgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IExpbmV0byhkaXZpZGVkWzBdKSxcbiAgICAgICAgICAgIG5ldyBMaW5ldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZ2V0U3ViZGl2aXNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c1NlZ21lbnQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gIXRoaXMuc3RhcnQuZXF1YWxzKHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuZW5kLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB0aGlzLmVuZC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIGVuZC54ICsgJyAnICsgZW5kLnk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyAnICsgdGhpcy5zdGFydCArICcgJyArIHRoaXMuZW5kO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSkge1xuXG4gICAgICAgIHRoaXMuZW5kLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobGluZXRvUHJvdG90eXBlLCAndHlwZScsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB2YWx1ZTogJ0wnXG59KTtcblxuTGluZXRvLnByb3RvdHlwZSA9IGV4dGVuZChzZWdtZW50UHJvdG90eXBlLCBMaW5lLnByb3RvdHlwZSwgbGluZXRvUHJvdG90eXBlKTtcblxudmFyIEN1cnZldG8gPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXJ2ZXRvKSkgeyAvLyBzd2l0Y2hpbmcgY29udGV4dCBvZiBgdGhpc2AgdG8gQ3VydmV0byB3aGVuIGNhbGxlZCB3aXRob3V0IGBuZXdgXG4gICAgICAgIHJldHVybiBhcHBseVRvTmV3KEN1cnZldG8sIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VydmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgY3VydmUsIDMgcG9pbnRzLCBvciA2IGNvb3JkaW5hdGVzIChub25lIHByb3ZpZGVkKS4nKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0QXJyYXk7XG5cbiAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIEN1cnZlKSB7IC8vIGN1cnZlcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxID0gYXJnc1swXS5jb250cm9sUG9pbnQxLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIgPSBhcmdzWzBdLmNvbnRyb2xQb2ludDIuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYXJnc1swXS5lbmQuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnZldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGN1cnZlLCAzIHBvaW50cywgb3IgNiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGN1cnZlcyBwcm92aWRlZCkuJyk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJykgeyAvLyBjb29yZGluYXRlcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gNikge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxID0gbmV3IFBvaW50KCthcmdzWzBdLCArYXJnc1sxXSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIgPSBuZXcgUG9pbnQoK2FyZ3NbMl0sICthcmdzWzNdKTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KCthcmdzWzRdLCArYXJnc1s1XSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgaWYgKG4gPCA2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnZldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGN1cnZlLCAzIHBvaW50cywgb3IgNiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGNvb3JkaW5hdGVzIHByb3ZpZGVkKS4nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGlzIGlzIGEgcG9seS1iZXppZXIgc2VnbWVudFxuICAgICAgICAgICAgdmFyIHNlZ21lbnRDb29yZHM7XG4gICAgICAgICAgICBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gNikgeyAvLyBjb29yZHMgY29tZSBpbiBncm91cHMgb2Ygc2l4XG5cbiAgICAgICAgICAgICAgICBzZWdtZW50Q29vcmRzID0gYXJncy5zbGljZShpLCBpICsgNik7IC8vIHdpbGwgc2VuZCBmZXdlciB0aGFuIHNpeCBjb29yZHMgaWYgYXJncy5sZW5ndGggbm90IGRpdmlzaWJsZSBieSA2XG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KEN1cnZldG8sIHNlZ21lbnRDb29yZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gcG9pbnRzIHByb3ZpZGVkIChuZWVkcyB0byBiZSBsYXN0IHRvIGFsc28gY292ZXIgcGxhaW4gb2JqZWN0cyB3aXRoIHggYW5kIHkpXG4gICAgICAgIGlmIChuID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEgPSBuZXcgUG9pbnQoYXJnc1swXSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIgPSBuZXcgUG9pbnQoYXJnc1sxXSk7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBQb2ludChhcmdzWzJdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VydmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgY3VydmUsIDMgcG9pbnRzLCBvciA2IGNvb3JkaW5hdGVzICgnICsgbiArICcgcG9pbnRzIHByb3ZpZGVkKS4nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGlzIGlzIGEgcG9seS1iZXppZXIgc2VnbWVudFxuICAgICAgICAgICAgdmFyIHNlZ21lbnRQb2ludHM7XG4gICAgICAgICAgICBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gMykgeyAvLyBwb2ludHMgY29tZSBpbiBncm91cHMgb2YgdGhyZWVcblxuICAgICAgICAgICAgICAgIHNlZ21lbnRQb2ludHMgPSBhcmdzLnNsaWNlKGksIGkgKyAzKTsgLy8gd2lsbCBzZW5kIGZld2VyIHRoYW4gdGhyZWUgcG9pbnRzIGlmIGFyZ3MubGVuZ3RoIGlzIG5vdCBkaXZpc2libGUgYnkgM1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goYXBwbHlUb05ldyhDdXJ2ZXRvLCBzZWdtZW50UG9pbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgY3VydmV0b1Byb3RvdHlwZSA9IHtcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IEN1cnZldG8odGhpcy5jb250cm9sUG9pbnQxLCB0aGlzLmNvbnRyb2xQb2ludDIsIHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgQ3VydmUodGhpcy5zdGFydCwgdGhpcy5jb250cm9sUG9pbnQxLCB0aGlzLmNvbnRyb2xQb2ludDIsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBjdXJ2ZS5kaXZpZGVBdChyYXRpbywgb3B0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBDdXJ2ZXRvKGRpdmlkZWRbMF0pLFxuICAgICAgICAgICAgbmV3IEN1cnZldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGN1cnZlID0gbmV3IEN1cnZlKHRoaXMuc3RhcnQsIHRoaXMuY29udHJvbFBvaW50MSwgdGhpcy5jb250cm9sUG9pbnQyLCB0aGlzLmVuZCk7XG4gICAgICAgIHZhciBkaXZpZGVkID0gY3VydmUuZGl2aWRlQXRMZW5ndGgobGVuZ3RoLCBvcHQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IEN1cnZldG8oZGl2aWRlZFswXSksXG4gICAgICAgICAgICBuZXcgQ3VydmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgQ3VydmUodGhpcy5zdGFydCwgdGhpcy5jb250cm9sUG9pbnQxLCB0aGlzLmNvbnRyb2xQb2ludDIsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBjdXJ2ZS5kaXZpZGVBdFQodCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ3VydmV0byhkaXZpZGVkWzBdKSxcbiAgICAgICAgICAgIG5ldyBDdXJ2ZXRvKGRpdmlkZWRbMV0pXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c1NlZ21lbnQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY29udHJvbDEgPSB0aGlzLmNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBjb250cm9sMiA9IHRoaXMuY29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHJldHVybiAhKHN0YXJ0LmVxdWFscyhjb250cm9sMSkgJiYgY29udHJvbDEuZXF1YWxzKGNvbnRyb2wyKSAmJiBjb250cm9sMi5lcXVhbHMoZW5kKSk7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuZW5kLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLmVuZC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjMSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGMyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnICcgKyBjMS54ICsgJyAnICsgYzEueSArICcgJyArIGMyLnggKyAnICcgKyBjMi55ICsgJyAnICsgZW5kLnggKyAnICcgKyBlbmQueTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnICcgKyB0aGlzLnN0YXJ0ICsgJyAnICsgdGhpcy5jb250cm9sUG9pbnQxICsgJyAnICsgdGhpcy5jb250cm9sUG9pbnQyICsgJyAnICsgdGhpcy5lbmQ7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuZW5kLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmV0b1Byb3RvdHlwZSwgJ3R5cGUnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgdmFsdWU6ICdDJ1xufSk7XG5cbkN1cnZldG8ucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIEN1cnZlLnByb3RvdHlwZSwgY3VydmV0b1Byb3RvdHlwZSk7XG5cbnZhciBNb3ZldG8gPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb3ZldG8pKSB7IC8vIHN3aXRjaGluZyBjb250ZXh0IG9mIGB0aGlzYCB0byBNb3ZldG8gd2hlbiBjYWxsZWQgd2l0aG91dCBgbmV3YFxuICAgICAgICByZXR1cm4gYXBwbHlUb05ldyhNb3ZldG8sIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTW92ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCBhIGN1cnZlLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzIChub25lIHByb3ZpZGVkKS4nKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0cHV0QXJyYXk7XG5cbiAgICBpZiAoYXJnc1swXSBpbnN0YW5jZW9mIExpbmUpIHsgLy8gbGluZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYXJnc1swXS5lbmQuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vdmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgYSBjdXJ2ZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGxpbmVzIHByb3ZpZGVkKS4nKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgQ3VydmUpIHsgLy8gY3VydmVzIHByb3ZpZGVkXG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGFyZ3NbMF0uZW5kLmNsb25lKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb3ZldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGxpbmUsIGEgY3VydmUsIDEgcG9pbnQsIG9yIDIgY29vcmRpbmF0ZXMgKCcgKyBuICsgJyBjdXJ2ZXMgcHJvdmlkZWQpLicpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicpIHsgLy8gY29vcmRpbmF0ZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KCthcmdzWzBdLCArYXJnc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgaWYgKG4gPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vdmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgYSBjdXJ2ZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGNvb3JkaW5hdGVzIHByb3ZpZGVkKS4nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGlzIGlzIGEgbW92ZXRvLXdpdGgtc3Vic2VxdWVudC1wb2x5LWxpbmUgc2VnbWVudFxuICAgICAgICAgICAgdmFyIHNlZ21lbnRDb29yZHM7XG4gICAgICAgICAgICBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gMikgeyAvLyBjb29yZHMgY29tZSBpbiBncm91cHMgb2YgdHdvXG5cbiAgICAgICAgICAgICAgICBzZWdtZW50Q29vcmRzID0gYXJncy5zbGljZShpLCBpICsgMik7IC8vIHdpbGwgc2VuZCBvbmUgY29vcmQgaWYgYXJncy5sZW5ndGggbm90IGRpdmlzaWJsZSBieSAyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIG91dHB1dEFycmF5LnB1c2goYXBwbHlUb05ldyhNb3ZldG8sIHNlZ21lbnRDb29yZHMpKTtcbiAgICAgICAgICAgICAgICBlbHNlIG91dHB1dEFycmF5LnB1c2goYXBwbHlUb05ldyhMaW5ldG8sIHNlZ21lbnRDb29yZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gcG9pbnRzIHByb3ZpZGVkIChuZWVkcyB0byBiZSBsYXN0IHRvIGFsc28gY292ZXIgcGxhaW4gb2JqZWN0cyB3aXRoIHggYW5kIHkpXG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBQb2ludChhcmdzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBtb3ZldG8td2l0aC1zdWJzZXF1ZW50LXBvbHktbGluZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudFBvaW50O1xuICAgICAgICAgICAgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IDEpIHsgLy8gcG9pbnRzIGNvbWUgb25lIGJ5IG9uZVxuXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvaW50ID0gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgb3V0cHV0QXJyYXkucHVzaChuZXcgTW92ZXRvKHNlZ21lbnRQb2ludCkpO1xuICAgICAgICAgICAgICAgIGVsc2Ugb3V0cHV0QXJyYXkucHVzaChuZXcgTGluZXRvKHNlZ21lbnRQb2ludCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG1vdmV0b1Byb3RvdHlwZSA9IHtcblxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBNb3ZldG8odGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludFRhbmdlbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuY2xvbmUoKSxcbiAgICAgICAgICAgIHRoaXMuY2xvbmUoKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMuY2xvbmUoKSxcbiAgICAgICAgICAgIHRoaXMuY2xvbmUoKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKG0pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbmQuZXF1YWxzKG0uZW5kKTtcbiAgICB9LFxuXG4gICAgZ2V0U3ViZGl2aXNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgaXNTdWJwYXRoU3RhcnQ6IHRydWUsXG5cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgbGVuZ3RoQXRUOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgcG9pbnRBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICBwb2ludEF0VDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICB0aGlzLmVuZC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgb3JpZ2luKSB7XG5cbiAgICAgICAgdGhpcy5lbmQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnICcgKyBlbmQueCArICcgJyArIGVuZC55O1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXRUOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnICcgKyB0aGlzLmVuZDtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICB0aGlzLmVuZC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vdmV0b1Byb3RvdHlwZSwgJ3N0YXJ0Jywge1xuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGFjY2Vzcy4gTW92ZXRvIHNlZ21lbnRzIHNob3VsZCBub3QgbmVlZCBhIHN0YXJ0IHByb3BlcnR5LicpO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW92ZXRvUHJvdG90eXBlLCAndHlwZScsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB2YWx1ZTogJ00nXG59KTtcblxuTW92ZXRvLnByb3RvdHlwZSA9IGV4dGVuZChzZWdtZW50UHJvdG90eXBlLCBtb3ZldG9Qcm90b3R5cGUpOyAvLyBkb2VzIG5vdCBpbmhlcml0IGZyb20gYW55IG90aGVyIGdlb21ldHJ5IG9iamVjdFxuXG52YXIgQ2xvc2VwYXRoID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ2xvc2VwYXRoKSkgeyAvLyBzd2l0Y2hpbmcgY29udGV4dCBvZiBgdGhpc2AgdG8gQ2xvc2VwYXRoIHdoZW4gY2FsbGVkIHdpdGhvdXQgYG5ld2BcbiAgICAgICAgcmV0dXJuIGFwcGx5VG9OZXcoQ2xvc2VwYXRoLCBhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAobiA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9zZXBhdGggY29uc3RydWN0b3IgZXhwZWN0cyBubyBhcmd1bWVudHMuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgY2xvc2VwYXRoUHJvdG90eXBlID0ge1xuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ2xvc2VwYXRoKCk7XG4gICAgfSxcblxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbihyYXRpbykge1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGxpbmUuZGl2aWRlQXQocmF0aW8pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGFjdHVhbGx5IGN1dCBpbnRvIHRoZSBzZWdtZW50LCBmaXJzdCBkaXZpZGVkIHBhcnQgY2FuIHN0YXkgYXMgWlxuICAgICAgICAgICAgKGRpdmlkZWRbMV0uaXNEaWZmZXJlbnRpYWJsZSgpID8gbmV3IExpbmV0byhkaXZpZGVkWzBdKSA6IHRoaXMuY2xvbmUoKSksXG4gICAgICAgICAgICBuZXcgTGluZXRvKGRpdmlkZWRbMV0pXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBsaW5lLmRpdmlkZUF0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgYWN0dWFsbHkgY3V0IGludG8gdGhlIHNlZ21lbnQsIGZpcnN0IGRpdmlkZWQgcGFydCBjYW4gc3RheSBhcyBaXG4gICAgICAgICAgICAoZGl2aWRlZFsxXS5pc0RpZmZlcmVudGlhYmxlKCkgPyBuZXcgTGluZXRvKGRpdmlkZWRbMF0pIDogdGhpcy5jbG9uZSgpKSxcbiAgICAgICAgICAgIG5ldyBMaW5ldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZ2V0U3ViZGl2aXNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c1NlZ21lbnQgfHwgIXRoaXMuc3VicGF0aFN0YXJ0U2VnbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydC5lcXVhbHModGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIHRoaXMuc3RhcnQgKyAnICcgKyB0aGlzLmVuZDtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvc2VwYXRoUHJvdG90eXBlLCAnZW5kJywge1xuICAgIC8vIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgZW5kIHBvaW50IG9mIHN1YnBhdGggc3RhcnQgc2VnbWVudFxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnN1YnBhdGhTdGFydFNlZ21lbnQpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQuIChUaGlzIHNlZ21lbnQgbmVlZHMgYSBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgKGUuZy4gTW92ZXRvKTsgT1Igc2VnbWVudCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIGEgcGF0aC4pJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicGF0aFN0YXJ0U2VnbWVudC5lbmQ7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZXBhdGhQcm90b3R5cGUsICd0eXBlJywge1xuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIHZhbHVlOiAnWidcbn0pO1xuXG5DbG9zZXBhdGgucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIExpbmUucHJvdG90eXBlLCBjbG9zZXBhdGhQcm90b3R5cGUpO1xuXG52YXIgc2VnbWVudFR5cGVzID0gUGF0aC5zZWdtZW50VHlwZXMgPSB7XG4gICAgTDogTGluZXRvLFxuICAgIEM6IEN1cnZldG8sXG4gICAgTTogTW92ZXRvLFxuICAgIFo6IENsb3NlcGF0aCxcbiAgICB6OiBDbG9zZXBhdGhcbn07XG5cblBhdGgucmVnZXhTdXBwb3J0ZWREYXRhID0gbmV3IFJlZ0V4cCgnXltcXFxcc1xcXFxkJyArIE9iamVjdC5rZXlzKHNlZ21lbnRUeXBlcykuam9pbignJykgKyAnLC5dKiQnKTtcblxuUGF0aC5pc0RhdGFTdXBwb3J0ZWQgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucmVnZXhTdXBwb3J0ZWREYXRhLnRlc3QoZGF0YSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/path.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/point.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/point.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   point: () => (/* binding */ point)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _line_bearing_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.bearing.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.bearing.mjs\");\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\");\n/* harmony import */ var _line_length_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.length.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.length.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\n\n\n\n\n\n\nconst {\n    abs,\n    cos,\n    sin,\n    sqrt,\n    min,\n    max,\n    atan2,\n    round,\n    pow,\n    PI\n} = Math;\n\nconst Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle)((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg)(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random)(x1, x2), (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random)(y1, y2));\n};\n\nPoint.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Point,\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return (0,_line_bearing_mjs__WEBPACK_IMPORTED_MODULE_2__.bearing)(this, point);\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return (0,_line_length_mjs__WEBPACK_IMPORTED_MODULE_3__.length)(this, p);\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle)(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid)(this.x, gx);\n        this.y = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid)(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n        return (0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_4__.squaredLength)(this, p);\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nconst point = Point;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9pbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwRjtBQUM3QztBQUNZO0FBQ2Q7QUFDUDs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUs7O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxRUFBYyxDQUFDLDREQUFLOztBQUVsQztBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsNkRBQU0sVUFBVSw2REFBTTtBQUMzQzs7QUFFQTs7QUFFQSxVQUFVLDZDQUFLOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLDBEQUFPO0FBQ3RCLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHdEQUFNO0FBQ3JCLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNERBQUs7QUFDekI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLDREQUFLLENBQUMscUVBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLGlCQUFpQixpRUFBVTtBQUMzQixpQkFBaUIsaUVBQVU7QUFDM0I7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxzRUFBYTtBQUM1QixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBLGlCQUFpQjtBQUNqQixLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsaUJBQWlCLDREQUFLO0FBQ3RCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL3BvaW50Lm1qcz81NGIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgUG9pbnQgaXMgdGhlIG1vc3QgYmFzaWMgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgeC95IGNvb3JkaW5hdGUuXG5cbiAgICBQb3NzaWJsZSBpbnN0YW50aWF0aW9ucyBhcmU6XG4gICAgKiBgUG9pbnQoMTAsIDIwKWBcbiAgICAqIGBuZXcgUG9pbnQoMTAsIDIwKWBcbiAgICAqIGBQb2ludCgnMTAgMjAnKWBcbiAgICAqIGBQb2ludChQb2ludCgxMCwgMjApKWBcbiovXG5pbXBvcnQgeyBub3JtYWxpemVBbmdsZSwgcmFuZG9tLCBzbmFwVG9HcmlkLCB0b0RlZywgdG9SYWQgfSBmcm9tICcuL2dlb21ldHJ5LmhlbHBlcnMubWpzJztcbmltcG9ydCB7IGJlYXJpbmcgfSBmcm9tICcuL2xpbmUuYmVhcmluZy5tanMnO1xuaW1wb3J0IHsgc3F1YXJlZExlbmd0aCB9IGZyb20gJy4vbGluZS5zcXVhcmVkTGVuZ3RoLm1qcyc7XG5pbXBvcnQgeyBsZW5ndGggfSBmcm9tICcuL2xpbmUubGVuZ3RoLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcblxuY29uc3Qge1xuICAgIGFicyxcbiAgICBjb3MsXG4gICAgc2luLFxuICAgIHNxcnQsXG4gICAgbWluLFxuICAgIG1heCxcbiAgICBhdGFuMixcbiAgICByb3VuZCxcbiAgICBwb3csXG4gICAgUElcbn0gPSBNYXRoO1xuXG5leHBvcnQgY29uc3QgUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgeHkgPSB4LnNwbGl0KHguaW5kZXhPZignQCcpID09PSAtMSA/ICcgJyA6ICdAJyk7XG4gICAgICAgIHggPSBwYXJzZUZsb2F0KHh5WzBdKTtcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoeHlbMV0pO1xuXG4gICAgfSBlbHNlIGlmIChPYmplY3QoeCkgPT09IHgpIHtcbiAgICAgICAgeSA9IHgueTtcbiAgICAgICAgeCA9IHgueDtcbiAgICB9XG5cbiAgICB0aGlzLnggPSB4ID09PSB1bmRlZmluZWQgPyAwIDogeDtcbiAgICB0aGlzLnkgPSB5ID09PSB1bmRlZmluZWQgPyAwIDogeTtcbn07XG5cbi8vIEFsdGVybmF0aXZlIGNvbnN0cnVjdG9yLCBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzLlxuLy8gQHBhcmFtIHtudW1iZXJ9IERpc3RhbmNlLlxuLy8gQHBhcmFtIHtudW1iZXJ9IEFuZ2xlIGluIHJhZGlhbnMuXG4vLyBAcGFyYW0ge3BvaW50fSBbb3B0aW9uYWxdIE9yaWdpbi5cblBvaW50LmZyb21Qb2xhciA9IGZ1bmN0aW9uKGRpc3RhbmNlLCBhbmdsZSwgb3JpZ2luKSB7XG5cbiAgICBvcmlnaW4gPSBuZXcgUG9pbnQob3JpZ2luKTtcbiAgICB2YXIgeCA9IGFicyhkaXN0YW5jZSAqIGNvcyhhbmdsZSkpO1xuICAgIHZhciB5ID0gYWJzKGRpc3RhbmNlICogc2luKGFuZ2xlKSk7XG4gICAgdmFyIGRlZyA9IG5vcm1hbGl6ZUFuZ2xlKHRvRGVnKGFuZ2xlKSk7XG5cbiAgICBpZiAoZGVnIDwgOTApIHtcbiAgICAgICAgeSA9IC15O1xuXG4gICAgfSBlbHNlIGlmIChkZWcgPCAxODApIHtcbiAgICAgICAgeCA9IC14O1xuICAgICAgICB5ID0gLXk7XG5cbiAgICB9IGVsc2UgaWYgKGRlZyA8IDI3MCkge1xuICAgICAgICB4ID0gLXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQb2ludChvcmlnaW4ueCArIHgsIG9yaWdpbi55ICsgeSk7XG59O1xuXG4vLyBDcmVhdGUgYSBwb2ludCB3aXRoIHJhbmRvbSBjb29yZGluYXRlcyB0aGF0IGZhbGwgaW50byB0aGUgcmFuZ2UgYFt4MSwgeDJdYCBhbmQgYFt5MSwgeTJdYC5cblBvaW50LnJhbmRvbSA9IGZ1bmN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG5cbiAgICByZXR1cm4gbmV3IFBvaW50KHJhbmRvbSh4MSwgeDIpLCByYW5kb20oeTEsIHkyKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUgPSB7XG5cbiAgICB0eXBlOiB0eXBlcy5Qb2ludCxcblxuICAgIGNob29zZUNsb3Nlc3Q6IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG4gPT09IDEpIHJldHVybiBuZXcgUG9pbnQocG9pbnRzWzBdKTtcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSBudWxsO1xuICAgICAgICB2YXIgbWluU3FyRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFBvaW50KHBvaW50c1tpXSk7XG4gICAgICAgICAgICB2YXIgc3FyRGlzdGFuY2UgPSB0aGlzLnNxdWFyZWREaXN0YW5jZShwKTtcbiAgICAgICAgICAgIGlmIChzcXJEaXN0YW5jZSA8IG1pblNxckRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IHA7XG4gICAgICAgICAgICAgICAgbWluU3FyRGlzdGFuY2UgPSBzcXJEaXN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuXG4gICAgLy8gSWYgcG9pbnQgbGllcyBvdXRzaWRlIHJlY3RhbmdsZSBgcmAsIHJldHVybiB0aGUgbmVhcmVzdCBwb2ludCBvbiB0aGUgYm91bmRhcnkgb2YgcmVjdCBgcmAsXG4gICAgLy8gb3RoZXJ3aXNlIHJldHVybiBwb2ludCBpdHNlbGYuXG4gICAgLy8gKHNlZSBTcXVlYWsgU21hbGx0YWxrLCBQb2ludD4+YWRoZXJlVG86KVxuICAgIGFkaGVyZVRvUmVjdDogZnVuY3Rpb24ocikge1xuXG4gICAgICAgIGlmIChyLmNvbnRhaW5zUG9pbnQodGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0gbWluKG1heCh0aGlzLngsIHIueCksIHIueCArIHIud2lkdGgpO1xuICAgICAgICB0aGlzLnkgPSBtaW4obWF4KHRoaXMueSwgci55KSwgci55ICsgci5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgYW5nbGUgYmV0d2VlbiB2ZWN0b3IgZnJvbSBtZSB0byBwMSBhbmQgdGhlIHZlY3RvciBmcm9tIG1lIHRvIHAyLlxuICAgIC8vIG9yZGVyaW5nIG9mIHBvaW50cyBwMSBhbmQgcDIgaXMgaW1wb3J0YW50IVxuICAgIC8vIHRoZXRhIGZ1bmN0aW9uJ3MgYW5nbGUgY29udmVudGlvbjpcbiAgICAvLyByZXR1cm5zIGFuZ2xlcyBiZXR3ZWVuIDAgYW5kIDE4MCB3aGVuIHRoZSBhbmdsZSBpcyBjb3VudGVyY2xvY2t3aXNlXG4gICAgLy8gcmV0dXJucyBhbmdsZXMgYmV0d2VlbiAxODAgYW5kIDM2MCB0byBjb252ZXJ0IGNsb2Nrd2lzZSBhbmdsZXMgaW50byBjb3VudGVyY2xvY2t3aXNlIG9uZXNcbiAgICAvLyByZXR1cm5zIE5hTiBpZiBhbnkgb2YgdGhlIHBvaW50cyBwMSwgcDIgaXMgY29pbmNpZGVudCB3aXRoIHRoaXMgcG9pbnRcbiAgICBhbmdsZUJldHdlZW46IGZ1bmN0aW9uKHAxLCBwMikge1xuXG4gICAgICAgIHZhciBhbmdsZUJldHdlZW4gPSAodGhpcy5lcXVhbHMocDEpIHx8IHRoaXMuZXF1YWxzKHAyKSkgPyBOYU4gOiAodGhpcy50aGV0YShwMikgLSB0aGlzLnRoZXRhKHAxKSk7XG5cbiAgICAgICAgaWYgKGFuZ2xlQmV0d2VlbiA8IDApIHtcbiAgICAgICAgICAgIGFuZ2xlQmV0d2VlbiArPSAzNjA7IC8vIGNvcnJlY3Rpb24gdG8ga2VlcCBhbmdsZUJldHdlZW4gYmV0d2VlbiAwIGFuZCAzNjBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmdsZUJldHdlZW47XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgYmVhcmluZyBiZXR3ZWVuIG1lIGFuZCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgYmVhcmluZzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGJlYXJpbmcodGhpcywgcG9pbnQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGNoYW5nZSBpbiBhbmdsZSBmcm9tIG15IHByZXZpb3VzIHBvc2l0aW9uICgtZHgsIC1keSkgdG8gbXkgbmV3IHBvc2l0aW9uXG4gICAgLy8gcmVsYXRpdmUgdG8gcmVmIHBvaW50LlxuICAgIGNoYW5nZUluQW5nbGU6IGZ1bmN0aW9uKGR4LCBkeSwgcmVmKSB7XG5cbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSB0cmFuc2xhdGlvbiBhbmQgbWVhc3VyZSB0aGUgY2hhbmdlIGluIGFuZ2xlIGFyb3VuZCB4LWF4aXMuXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkub2Zmc2V0KC1keCwgLWR5KS50aGV0YShyZWYpIC0gdGhpcy50aGV0YShyZWYpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0aGlzIHBvaW50IHJlbGF0aXZlIHRvIHR3byBvdGhlciBwb2ludHNcbiAgICAvLyB0aGlzIHBvaW50IGlzIHRoZSBjb21tb24gcG9pbnRcbiAgICAvLyBwb2ludCBwMSBsaWVzIG9uIHRoZSBmaXJzdCB2ZWN0b3IsIHBvaW50IHAyIGxpZXMgb24gdGhlIHNlY29uZCB2ZWN0b3JcbiAgICAvLyB3YXRjaCBvdXQgZm9yIHRoZSBvcmRlcmluZyBvZiBwb2ludHMgcDEgYW5kIHAyIVxuICAgIC8vIHBvc2l0aXZlIHJlc3VsdCBpbmRpY2F0ZXMgYSBjbG9ja3dpc2UgKFwicmlnaHRcIikgdHVybiBmcm9tIGZpcnN0IHRvIHNlY29uZCB2ZWN0b3JcbiAgICAvLyBuZWdhdGl2ZSByZXN1bHQgaW5kaWNhdGVzIGEgY291bnRlcmNsb2Nrd2lzZSAoXCJsZWZ0XCIpIHR1cm4gZnJvbSBmaXJzdCB0byBzZWNvbmQgdmVjdG9yXG4gICAgLy8gemVybyBpbmRpY2F0ZXMgdGhhdCB0aGUgZmlyc3QgYW5kIHNlY29uZCB2ZWN0b3IgYXJlIGNvbGxpbmVhclxuICAgIC8vIG5vdGUgdGhhdCB0aGUgYWJvdmUgZGlyZWN0aW9ucyBhcmUgcmV2ZXJzZWQgZnJvbSB0aGUgdXN1YWwgYW5zd2VyIG9uIHRoZSBJbnRlcm5ldFxuICAgIC8vIHRoYXQgaXMgYmVjYXVzZSB3ZSBhcmUgaW4gYSBsZWZ0LWhhbmRlZCBjb29yZCBzeXN0ZW0gKGJlY2F1c2UgdGhlIHktYXhpcyBwb2ludHMgZG93bndhcmQpXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKHAxLCBwMikge1xuXG4gICAgICAgIHJldHVybiAocDEgJiYgcDIpID8gKCgocDIueCAtIHRoaXMueCkgKiAocDEueSAtIHRoaXMueSkpIC0gKChwMi55IC0gdGhpcy55KSAqIChwMS54IC0gdGhpcy54KSkpIDogTmFOO1xuICAgIH0sXG5cbiAgICBkaWZmZXJlbmNlOiBmdW5jdGlvbihkeCwgZHkpIHtcblxuICAgICAgICBpZiAoKE9iamVjdChkeCkgPT09IGR4KSkge1xuICAgICAgICAgICAgZHkgPSBkeC55O1xuICAgICAgICAgICAgZHggPSBkeC54O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSAoZHggfHwgMCksIHRoaXMueSAtIChkeSB8fCAwKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZGlzdGFuY2UgYmV0d2VlbiBtZSBhbmQgcG9pbnQgYHBgLlxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGgodGhpcywgcCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgcG9pbnQgd2l0aCBnaXZlbiBvdGhlciBwb2ludFxuICAgIGRvdDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHJldHVybiBwID8gKHRoaXMueCAqIHAueCArIHRoaXMueSAqIHAueSkgOiBOYU47XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHJldHVybiAhIXAgJiZcbiAgICAgICAgICAgIHRoaXMueCA9PT0gcC54ICYmXG4gICAgICAgICAgICB0aGlzLnkgPT09IHAueTtcbiAgICB9LFxuXG4gICAgLy8gTGluZWFyIGludGVycG9sYXRpb25cbiAgICBsZXJwOiBmdW5jdGlvbihwLCB0KSB7XG5cbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KCgxIC0gdCkgKiB4ICsgdCAqIHAueCwgKDEgLSB0KSAqIHkgKyB0ICogcC55KTtcbiAgICB9LFxuXG4gICAgbWFnbml0dWRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gc3FydCgodGhpcy54ICogdGhpcy54KSArICh0aGlzLnkgKiB0aGlzLnkpKSB8fCAwLjAxO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgbWFuaGF0dGFuICh0YXhpLWNhYikgZGlzdGFuY2UgYmV0d2VlbiBtZSBhbmQgcG9pbnQgYHBgLlxuICAgIG1hbmhhdHRhbkRpc3RhbmNlOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIGFicyhwLnggLSB0aGlzLngpICsgYWJzKHAueSAtIHRoaXMueSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmUgcG9pbnQgb24gbGluZSBzdGFydGluZyBmcm9tIHJlZiBlbmRpbmcgYXQgbWUgYnlcbiAgICAvLyBkaXN0YW5jZSBkaXN0YW5jZS5cbiAgICBtb3ZlOiBmdW5jdGlvbihyZWYsIGRpc3RhbmNlKSB7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gdG9SYWQoKG5ldyBQb2ludChyZWYpKS50aGV0YSh0aGlzKSk7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldChjb3ModGhldGEpICogZGlzdGFuY2UsIC1zaW4odGhldGEpICogZGlzdGFuY2UpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG5cbiAgICAvLyBTY2FsZXMgeCBhbmQgeSBzdWNoIHRoYXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvaW50IGFuZCB0aGUgb3JpZ2luICgwLDApIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgc2NhbGUgPSAobGVuZ3RoIHx8IDEpIC8gdGhpcy5tYWduaXR1ZGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICB9LFxuXG4gICAgLy8gT2Zmc2V0IG1lIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LlxuICAgIG9mZnNldDogZnVuY3Rpb24oZHgsIGR5KSB7XG5cbiAgICAgICAgaWYgKChPYmplY3QoZHgpID09PSBkeCkpIHtcbiAgICAgICAgICAgIGR5ID0gZHgueTtcbiAgICAgICAgICAgIGR4ID0gZHgueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCArPSBkeCB8fCAwO1xuICAgICAgICB0aGlzLnkgKz0gZHkgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSByZWZsZWN0aW9uIG9mIG1lIHdpdGhcbiAgICAvLyB0aGUgY2VudGVyIG9mIGludmVyc2lvbiBpbiByZWYgcG9pbnQuXG4gICAgcmVmbGVjdGlvbjogZnVuY3Rpb24ocmVmKSB7XG5cbiAgICAgICAgcmV0dXJuIChuZXcgUG9pbnQocmVmKSkubW92ZSh0aGlzLCB0aGlzLmRpc3RhbmNlKHJlZikpO1xuICAgIH0sXG5cbiAgICAvLyBSb3RhdGUgcG9pbnQgYnkgYW5nbGUgYXJvdW5kIG9yaWdpbi5cbiAgICAvLyBBbmdsZSBpcyBmbGlwcGVkIGJlY2F1c2UgdGhpcyBpcyBhIGxlZnQtaGFuZGVkIGNvb3JkIHN5c3RlbSAoeS1heGlzIHBvaW50cyBkb3dud2FyZCkuXG4gICAgcm90YXRlOiBmdW5jdGlvbihvcmlnaW4sIGFuZ2xlKSB7XG5cbiAgICAgICAgaWYgKGFuZ2xlID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgICAgICBvcmlnaW4gPSBvcmlnaW4gfHwgbmV3IFBvaW50KDAsIDApO1xuXG4gICAgICAgIGFuZ2xlID0gdG9SYWQobm9ybWFsaXplQW5nbGUoLWFuZ2xlKSk7XG4gICAgICAgIHZhciBjb3NBbmdsZSA9IGNvcyhhbmdsZSk7XG4gICAgICAgIHZhciBzaW5BbmdsZSA9IHNpbihhbmdsZSk7XG5cbiAgICAgICAgdmFyIHggPSAoY29zQW5nbGUgKiAodGhpcy54IC0gb3JpZ2luLngpKSAtIChzaW5BbmdsZSAqICh0aGlzLnkgLSBvcmlnaW4ueSkpICsgb3JpZ2luLng7XG4gICAgICAgIHZhciB5ID0gKHNpbkFuZ2xlICogKHRoaXMueCAtIG9yaWdpbi54KSkgKyAoY29zQW5nbGUgKiAodGhpcy55IC0gb3JpZ2luLnkpKSArIG9yaWdpbi55O1xuXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgbGV0IGYgPSAxOyAvLyBjYXNlIDBcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGYgPSAxMDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBmID0gMTAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IGYgPSAxMDAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmID0gcG93KDEwLCBwcmVjaXNpb24pOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IHJvdW5kKHRoaXMueCAqIGYpIC8gZjtcbiAgICAgICAgdGhpcy55ID0gcm91bmQodGhpcy55ICogZikgLyBmO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2NhbGUgcG9pbnQgd2l0aCBvcmlnaW4uXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgb3JpZ2luKSB7XG5cbiAgICAgICAgb3JpZ2luID0gKG9yaWdpbiAmJiBuZXcgUG9pbnQob3JpZ2luKSkgfHwgbmV3IFBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLnggPSBvcmlnaW4ueCArIHN4ICogKHRoaXMueCAtIG9yaWdpbi54KTtcbiAgICAgICAgdGhpcy55ID0gb3JpZ2luLnkgKyBzeSAqICh0aGlzLnkgLSBvcmlnaW4ueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzbmFwVG9HcmlkOiBmdW5jdGlvbihneCwgZ3kpIHtcblxuICAgICAgICB0aGlzLnggPSBzbmFwVG9HcmlkKHRoaXMueCwgZ3gpO1xuICAgICAgICB0aGlzLnkgPSBzbmFwVG9HcmlkKHRoaXMueSwgZ3kgfHwgZ3gpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3F1YXJlZERpc3RhbmNlOiBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBzcXVhcmVkTGVuZ3RoKHRoaXMsIHApO1xuICAgIH0sXG5cbiAgICAvLyBDb21wdXRlIHRoZSBhbmdsZSBiZXR3ZWVuIG1lIGFuZCBgcGAgYW5kIHRoZSB4IGF4aXMuXG4gICAgLy8gKGNhcnRlc2lhbi10by1wb2xhciBjb29yZGluYXRlcyBjb252ZXJzaW9uKVxuICAgIC8vIFJldHVybiB0aGV0YSBhbmdsZSBpbiBkZWdyZWVzLlxuICAgIHRoZXRhOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcCA9IG5ldyBQb2ludChwKTtcblxuICAgICAgICAvLyBJbnZlcnQgdGhlIHktYXhpcy5cbiAgICAgICAgdmFyIHkgPSAtKHAueSAtIHRoaXMueSk7XG4gICAgICAgIHZhciB4ID0gcC54IC0gdGhpcy54O1xuICAgICAgICB2YXIgcmFkID0gYXRhbjIoeSwgeCk7IC8vIGRlZmluZWQgZm9yIGFsbCAwIGNvcm5lciBjYXNlc1xuXG4gICAgICAgIC8vIENvcnJlY3Rpb24gZm9yIElJSS4gYW5kIElWLiBxdWFkcmFudC5cbiAgICAgICAgaWYgKHJhZCA8IDApIHtcbiAgICAgICAgICAgIHJhZCA9IDIgKiBQSSArIHJhZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxODAgKiByYWQgLyBQSTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4geyB4OiB0aGlzLngsIHk6IHRoaXMueSB9O1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0cyByZWN0YW5ndWxhciB0byBwb2xhciBjb29yZGluYXRlcy5cbiAgICAvLyBBbiBvcmlnaW4gY2FuIGJlIHNwZWNpZmllZCwgb3RoZXJ3aXNlIGl0J3MgMEAwLlxuICAgIHRvUG9sYXI6IGZ1bmN0aW9uKG8pIHtcblxuICAgICAgICBvID0gKG8gJiYgbmV3IFBvaW50KG8pKSB8fCBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgdGhpcy54ID0gc3FydCgoeCAtIG8ueCkgKiAoeCAtIG8ueCkgKyAoeSAtIG8ueSkgKiAoeSAtIG8ueSkpOyAvLyByXG4gICAgICAgIHRoaXMueSA9IHRvUmFkKG8udGhldGEobmV3IFBvaW50KHgsIHkpKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueCArICdAJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICsgJywnICsgdGhpcy55O1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICBpZiAoKE9iamVjdCh4KSA9PT0geCkpIHtcbiAgICAgICAgICAgIHkgPSB4Lnk7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDb21wdXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHRoZSB2ZWN0b3IgZnJvbSAwLDAgdG8gbWUgYW5kIHRoZSB2ZWN0b3IgZnJvbSAwLDAgdG8gcC5cbiAgICAvLyBSZXR1cm5zIE5hTiBpZiBwIGlzIGF0IDAsMC5cbiAgICB2ZWN0b3JBbmdsZTogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciB6ZXJvID0gbmV3IFBvaW50KDAsIDApO1xuICAgICAgICByZXR1cm4gemVyby5hbmdsZUJldHdlZW4odGhpcywgcCk7XG4gICAgfVxufTtcblxuUG9pbnQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IFBvaW50LnByb3RvdHlwZS5vZmZzZXQ7XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTpcbmV4cG9ydCBjb25zdCBwb2ludCA9IFBvaW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/point.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/points.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/g/points.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clonePoints: () => (/* binding */ clonePoints),\n/* harmony export */   convexHull: () => (/* binding */ convexHull),\n/* harmony export */   parsePoints: () => (/* binding */ parsePoints)\n/* harmony export */ });\nfunction parsePoints(svgString) {\n\n    // Step 1: Discard surrounding spaces\n    const trimmedString = svgString.trim();\n    if (trimmedString === '') return [];\n\n    const points = [];\n\n    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n    // Note: This doesn't simplify double (or more) commas - causes empty coords\n    // This regex is used by `split()`, so it doesn't need to use /g\n    const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\n    const numCoords = coords.length;\n    for (let i = 0; i < numCoords; i += 2) {\n        // Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n    return points;\n}\n\nfunction clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nfunction convexHull(points) {\n\n    const { abs } = Math;\n\n    var i;\n    var n;\n\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for (i = 0; i < numPoints; i++) {\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n\n        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for (i = 0; i < numPoints; i++) {\n\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n            // the start point will end up at end of sorted list\n            // the start point will end up at beginning of hull points list\n        }\n\n        var entry = [points[i], i, angle];\n        sortedPointRecords.push(entry);\n    }\n\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n\n        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            // coincident points will be sorted in reverse-numerical order\n            // so the coincident points with lower original index will be considered first\n        }\n\n        return sortOutput;\n    });\n\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while (sortedPointRecords.length !== 0) {\n\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n            // this point had an incorrect turn at some previous iteration of this loop\n            // this disqualifies it from possibly being on the hull\n            continue;\n        }\n\n        var correctTurnFound = false;\n        while (!correctTurnFound) {\n\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                        // we are switching the order of the 0deg and 180deg points\n                        // correct turn not found\n                    }\n\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for (i = 0; i < n; i++) {\n\n        var currentHullIndex = hullPointRecords[i][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for (i = 0; i < n; i++) {\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return hullPoints;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9pbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVAsWUFBWSxNQUFNOztBQUVsQjtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7O0FBRS9CO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiw0REFBNEQ7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLDJDQUEyQztBQUMzQztBQUNBLGdCQUFnQixPQUFPOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9pbnRzLm1qcz9jMzI5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBwYXJzZVBvaW50cyhzdmdTdHJpbmcpIHtcblxuICAgIC8vIFN0ZXAgMTogRGlzY2FyZCBzdXJyb3VuZGluZyBzcGFjZXNcbiAgICBjb25zdCB0cmltbWVkU3RyaW5nID0gc3ZnU3RyaW5nLnRyaW0oKTtcbiAgICBpZiAodHJpbW1lZFN0cmluZyA9PT0gJycpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuXG4gICAgLy8gU3RlcCAyOiBTcGxpdCBhdCBjb21tYXMgKCsgdGhlaXIgc3Vycm91bmRpbmcgc3BhY2VzKSBvciBhdCBtdWx0aXBsZSBzcGFjZXNcbiAgICAvLyBSZURvUyBtaXRpZ2F0aW9uOiBIYXZlIGFuIGFuY2hvciBhdCB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggYWx0ZXJuYXRpb25cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3Qgc2ltcGxpZnkgZG91YmxlIChvciBtb3JlKSBjb21tYXMgLSBjYXVzZXMgZW1wdHkgY29vcmRzXG4gICAgLy8gVGhpcyByZWdleCBpcyB1c2VkIGJ5IGBzcGxpdCgpYCwgc28gaXQgZG9lc24ndCBuZWVkIHRvIHVzZSAvZ1xuICAgIGNvbnN0IGNvb3JkcyA9IHRyaW1tZWRTdHJpbmcuc3BsaXQoL1xcYlxccyosXFxzKnwsXFxzKnxcXHMrLyk7XG5cbiAgICBjb25zdCBudW1Db29yZHMgPSBjb29yZHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29vcmRzOyBpICs9IDIpIHtcbiAgICAgICAgLy8gU3RlcCAzOiBDb252ZXJ0IGVhY2ggY29vcmQgdG8gbnVtYmVyXG4gICAgICAgIC8vIE5vdGU6IElmIHRoZSBjb29yZCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgbnVtYmVyLCBpdCB3aWxsIGJlIGBOYU5gXG4gICAgICAgIC8vIE5vdGU6IElmIHRoZSBjb29yZCBpcyBlbXB0eSAoXCJcIiwgZS5nLiBmcm9tIFwiLCxcIiBpbnB1dCksIGl0IHdpbGwgYmUgYDBgXG4gICAgICAgIC8vIE5vdGU6IElmIHdlIGVuZCB1cCB3aXRoIGFuIG9kZCBudW1iZXIgb2YgY29vcmRzLCB0aGUgbGFzdCBwb2ludCdzIHNlY29uZCBjb29yZCB3aWxsIGJlIGBOYU5gXG4gICAgICAgIHBvaW50cy5wdXNoKHsgeDogK2Nvb3Jkc1tpXSwgeTogK2Nvb3Jkc1tpICsgMV0gfSk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVBvaW50cyhwb2ludHMpIHtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBbXTtcbiAgICBjb25zdCBuZXdQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldLmNsb25lKCk7XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuLy8gUmV0dXJucyBhIGNvbnZleC1odWxsIHBvbHlsaW5lIGZyb20gdGhpcyBwb2x5bGluZS5cbi8vIEltcGxlbWVudHMgdGhlIEdyYWhhbSBzY2FuIChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HcmFoYW1fc2NhbikuXG4vLyBPdXRwdXQgcG9seWxpbmUgc3RhcnRzIGF0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBvcmlnaW5hbCBwb2x5bGluZSB0aGF0IGlzIG9uIHRoZSBodWxsLCB0aGVuIGNvbnRpbnVlcyBjbG9ja3dpc2UuXG4vLyBNaW5pbWFsIHBvbHlsaW5lIGlzIGZvdW5kIChvbmx5IHZlcnRpY2VzIG9mIHRoZSBodWxsIGFyZSByZXBvcnRlZCwgbm8gY29sbGluZWFyIHBvaW50cykuXG5leHBvcnQgZnVuY3Rpb24gY29udmV4SHVsbChwb2ludHMpIHtcblxuICAgIGNvbnN0IHsgYWJzIH0gPSBNYXRoO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIG47XG5cbiAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gW107IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuXG4gICAgLy8gc3RlcCAxOiBmaW5kIHRoZSBzdGFydGluZyBwb2ludCAtIHBvaW50IHdpdGggdGhlIGxvd2VzdCB5IChpZiBlcXVhbGl0eSwgaGlnaGVzdCB4KVxuICAgIHZhciBzdGFydFBvaW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICBpZiAoc3RhcnRQb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCB3ZSBzZWUsIHNldCBpdCBhcyBzdGFydCBwb2ludFxuICAgICAgICAgICAgc3RhcnRQb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICB9IGVsc2UgaWYgKHBvaW50c1tpXS55IDwgc3RhcnRQb2ludC55KSB7XG4gICAgICAgICAgICAvLyBzdGFydCBwb2ludCBzaG91bGQgaGF2ZSBsb3dlc3QgeSBmcm9tIGFsbCBwb2ludHNcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgfSBlbHNlIGlmICgocG9pbnRzW2ldLnkgPT09IHN0YXJ0UG9pbnQueSkgJiYgKHBvaW50c1tpXS54ID4gc3RhcnRQb2ludC54KSkge1xuICAgICAgICAgICAgLy8gaWYgdHdvIHBvaW50cyBoYXZlIHRoZSBsb3dlc3QgeSwgY2hvb3NlIHRoZSBvbmUgdGhhdCBoYXMgaGlnaGVzdCB4XG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gcG9pbnRzIHRvIHRoZSByaWdodCBvZiBzdGFydFBvaW50IC0gbm8gYW1iaWd1aXR5IGFib3V0IHRoZXRhIDBcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBzZXZlcmFsIGNvaW5jaWRlbnQgc3RhcnQgcG9pbnQgY2FuZGlkYXRlcywgZmlyc3Qgb25lIGlzIHJlcG9ydGVkXG4gICAgICAgICAgICBzdGFydFBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3RlcCAyOiBzb3J0IHRoZSBsaXN0IG9mIHBvaW50c1xuICAgIC8vIHNvcnRpbmcgYnkgYW5nbGUgYmV0d2VlbiBsaW5lIGZyb20gc3RhcnRQb2ludCB0byBwb2ludCBhbmQgdGhlIHgtYXhpcyAodGhldGEpXG5cbiAgICAvLyBzdGVwIDJhOiBjcmVhdGUgdGhlIHBvaW50IHJlY29yZHMgPSBbcG9pbnQsIG9yaWdpbmFsSW5kZXgsIGFuZ2xlXVxuICAgIHZhciBzb3J0ZWRQb2ludFJlY29yZHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcblxuICAgICAgICB2YXIgYW5nbGUgPSBzdGFydFBvaW50LnRoZXRhKHBvaW50c1tpXSk7XG4gICAgICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgICAgICAgYW5nbGUgPSAzNjA7IC8vIGdpdmUgaGlnaGVzdCBhbmdsZSB0byBzdGFydCBwb2ludFxuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IHBvaW50IHdpbGwgZW5kIHVwIGF0IGVuZCBvZiBzb3J0ZWQgbGlzdFxuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IHBvaW50IHdpbGwgZW5kIHVwIGF0IGJlZ2lubmluZyBvZiBodWxsIHBvaW50cyBsaXN0XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW50cnkgPSBbcG9pbnRzW2ldLCBpLCBhbmdsZV07XG4gICAgICAgIHNvcnRlZFBvaW50UmVjb3Jkcy5wdXNoKGVudHJ5KTtcbiAgICB9XG5cbiAgICAvLyBzdGVwIDJiOiBzb3J0IHRoZSBsaXN0IGluIHBsYWNlXG4gICAgc29ydGVkUG9pbnRSZWNvcmRzLnNvcnQoZnVuY3Rpb24ocmVjb3JkMSwgcmVjb3JkMikge1xuICAgICAgICAvLyByZXR1cm5pbmcgYSBuZWdhdGl2ZSBudW1iZXIgaGVyZSBzb3J0cyByZWNvcmQxIGJlZm9yZSByZWNvcmQyXG4gICAgICAgIC8vIGlmIGZpcnN0IGFuZ2xlIGlzIHNtYWxsZXIgdGhhbiBzZWNvbmQsIGZpcnN0IGFuZ2xlIHNob3VsZCBjb21lIGJlZm9yZSBzZWNvbmRcblxuICAgICAgICB2YXIgc29ydE91dHB1dCA9IHJlY29yZDFbMl0gLSByZWNvcmQyWzJdOyAgLy8gbmVnYXRpdmUgaWYgZmlyc3QgYW5nbGUgc21hbGxlclxuICAgICAgICBpZiAoc29ydE91dHB1dCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHR3byBhbmdsZXMgYXJlIGVxdWFsLCBzb3J0IGJ5IG9yaWdpbmFsSW5kZXhcbiAgICAgICAgICAgIHNvcnRPdXRwdXQgPSByZWNvcmQyWzFdIC0gcmVjb3JkMVsxXTsgLy8gbmVnYXRpdmUgaWYgZmlyc3QgaW5kZXggbGFyZ2VyXG4gICAgICAgICAgICAvLyBjb2luY2lkZW50IHBvaW50cyB3aWxsIGJlIHNvcnRlZCBpbiByZXZlcnNlLW51bWVyaWNhbCBvcmRlclxuICAgICAgICAgICAgLy8gc28gdGhlIGNvaW5jaWRlbnQgcG9pbnRzIHdpdGggbG93ZXIgb3JpZ2luYWwgaW5kZXggd2lsbCBiZSBjb25zaWRlcmVkIGZpcnN0XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc29ydE91dHB1dDtcbiAgICB9KTtcblxuICAgIC8vIHN0ZXAgMmM6IGR1cGxpY2F0ZSBzdGFydCByZWNvcmQgZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFjayB0byB0aGUgYm90dG9tIG9mIHRoZSBzdGFja1xuICAgIGlmIChzb3J0ZWRQb2ludFJlY29yZHMubGVuZ3RoID4gMikge1xuICAgICAgICB2YXIgc3RhcnRQb2ludFJlY29yZCA9IHNvcnRlZFBvaW50UmVjb3Jkc1tzb3J0ZWRQb2ludFJlY29yZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHNvcnRlZFBvaW50UmVjb3Jkcy51bnNoaWZ0KHN0YXJ0UG9pbnRSZWNvcmQpO1xuICAgIH1cblxuICAgIC8vIHN0ZXAgM2E6IGdvIHRocm91Z2ggc29ydGVkIHBvaW50cyBpbiBvcmRlciBhbmQgZmluZCB0aG9zZSB3aXRoIHJpZ2h0IHR1cm5zXG4gICAgLy8gd2Ugd2FudCB0byBnZXQgb3VyIHJlc3VsdHMgaW4gY2xvY2t3aXNlIG9yZGVyXG4gICAgdmFyIGluc2lkZVBvaW50cyA9IHt9OyAvLyBkaWN0aW9uYXJ5IG9mIHBvaW50cyB3aXRoIGxlZnQgdHVybnMgLSBjYW5ub3QgYmUgb24gdGhlIGh1bGxcbiAgICB2YXIgaHVsbFBvaW50UmVjb3JkcyA9IFtdOyAvLyBzdGFjayBvZiByZWNvcmRzIHdpdGggcmlnaHQgdHVybnMgLSBodWxsIHBvaW50IGNhbmRpZGF0ZXNcblxuICAgIHZhciBjdXJyZW50UG9pbnRSZWNvcmQ7XG4gICAgdmFyIGN1cnJlbnRQb2ludDtcbiAgICB2YXIgbGFzdEh1bGxQb2ludFJlY29yZDtcbiAgICB2YXIgbGFzdEh1bGxQb2ludDtcbiAgICB2YXIgc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZDtcbiAgICB2YXIgc2Vjb25kTGFzdEh1bGxQb2ludDtcbiAgICB3aGlsZSAoc29ydGVkUG9pbnRSZWNvcmRzLmxlbmd0aCAhPT0gMCkge1xuXG4gICAgICAgIGN1cnJlbnRQb2ludFJlY29yZCA9IHNvcnRlZFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICAgICAgY3VycmVudFBvaW50ID0gY3VycmVudFBvaW50UmVjb3JkWzBdO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHBvaW50IGhhcyBhbHJlYWR5IGJlZW4gZGlzY2FyZGVkXG4gICAgICAgIC8vIGtleXMgZm9yIGluc2lkZVBvaW50cyBhcmUgc3RvcmVkIGluIHRoZSBmb3JtICdwb2ludC54QHBvaW50LnlAQG9yaWdpbmFsSW5kZXgnXG4gICAgICAgIGlmIChpbnNpZGVQb2ludHMuaGFzT3duUHJvcGVydHkoY3VycmVudFBvaW50UmVjb3JkWzBdICsgJ0BAJyArIGN1cnJlbnRQb2ludFJlY29yZFsxXSkpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgcG9pbnQgaGFkIGFuIGluY29ycmVjdCB0dXJuIGF0IHNvbWUgcHJldmlvdXMgaXRlcmF0aW9uIG9mIHRoaXMgbG9vcFxuICAgICAgICAgICAgLy8gdGhpcyBkaXNxdWFsaWZpZXMgaXQgZnJvbSBwb3NzaWJseSBiZWluZyBvbiB0aGUgaHVsbFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29ycmVjdFR1cm5Gb3VuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWNvcnJlY3RUdXJuRm91bmQpIHtcblxuICAgICAgICAgICAgaWYgKGh1bGxQb2ludFJlY29yZHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggcG9pbnRzIGZvciBjb21wYXJpc29uLCBqdXN0IGFkZCBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKGN1cnJlbnRQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgY29ycmVjdFR1cm5Gb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdEh1bGxQb2ludFJlY29yZCA9IGh1bGxQb2ludFJlY29yZHMucG9wKCk7XG4gICAgICAgICAgICAgICAgbGFzdEh1bGxQb2ludCA9IGxhc3RIdWxsUG9pbnRSZWNvcmRbMF07XG4gICAgICAgICAgICAgICAgc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZCA9IGh1bGxQb2ludFJlY29yZHMucG9wKCk7XG4gICAgICAgICAgICAgICAgc2Vjb25kTGFzdEh1bGxQb2ludCA9IHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmRbMF07XG5cbiAgICAgICAgICAgICAgICB2YXIgY3Jvc3NQcm9kdWN0ID0gc2Vjb25kTGFzdEh1bGxQb2ludC5jcm9zcyhsYXN0SHVsbFBvaW50LCBjdXJyZW50UG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzUHJvZHVjdCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSByaWdodCB0dXJuXG4gICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKGxhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2goY3VycmVudFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgY29ycmVjdFR1cm5Gb3VuZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzUHJvZHVjdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGhyZWUgcG9pbnRzIGFyZSBjb2xsaW5lYXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyZWUgb3B0aW9uczpcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgbWF5IGJlIGEgMTgwIG9yIDAgZGVncmVlIGFuZ2xlIGF0IGxhc3RIdWxsUG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgdHdvIG9mIHRoZSB0aHJlZSBwb2ludHMgYXJlIGNvaW5jaWRlbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIFRIUkVTSE9MRCA9IDFlLTEwOyAvLyB3ZSBoYXZlIHRvIHRha2Ugcm91bmRpbmcgZXJyb3JzIGludG8gYWNjb3VudFxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5nbGVCZXR3ZWVuID0gbGFzdEh1bGxQb2ludC5hbmdsZUJldHdlZW4oc2Vjb25kTGFzdEh1bGxQb2ludCwgY3VycmVudFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFicyhhbmdsZUJldHdlZW4gLSAxODApIDwgVEhSRVNIT0xEKSB7IC8vIHJvdW5kaW5nIGFyb3VuZCAxODAgdG8gMTgwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3Jvc3MgcHJvZHVjdCBpcyAwIGJlY2F1c2UgdGhlIGFuZ2xlIGlzIDE4MCBkZWdyZWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIGxhc3QgaHVsbCBwb2ludCAoYWRkIHRvIGluc2lkZVBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaW5zaWRlUG9pbnRzLnVuc2hpZnQobGFzdEh1bGxQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNpZGVQb2ludHNbbGFzdEh1bGxQb2ludFJlY29yZFswXSArICdAQCcgKyBsYXN0SHVsbFBvaW50UmVjb3JkWzFdXSA9IGxhc3RIdWxsUG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWVudGVyIHNlY29uZC10by1sYXN0IGh1bGwgcG9pbnQgKHdpbGwgYmUgbGFzdCBhdCBuZXh0IGl0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2goc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgZG8gYW55dGhpbmcgd2l0aCBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IHR1cm4gbm90IGZvdW5kXG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0SHVsbFBvaW50LmVxdWFscyhjdXJyZW50UG9pbnQpIHx8IHNlY29uZExhc3RIdWxsUG9pbnQuZXF1YWxzKGxhc3RIdWxsUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3Jvc3MgcHJvZHVjdCBpcyAwIGJlY2F1c2UgdHdvIHBvaW50cyBhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgbGFzdCBodWxsIHBvaW50IChhZGQgdG8gaW5zaWRlUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnNpZGVQb2ludHMudW5zaGlmdChsYXN0SHVsbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVBvaW50c1tsYXN0SHVsbFBvaW50UmVjb3JkWzBdICsgJ0BAJyArIGxhc3RIdWxsUG9pbnRSZWNvcmRbMV1dID0gbGFzdEh1bGxQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZW50ZXIgc2Vjb25kLXRvLWxhc3QgaHVsbCBwb2ludCAod2lsbCBiZSBsYXN0IGF0IG5leHQgaXRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkbyBhbnl0aGluZyB3aXRoIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdHVybiBub3QgZm91bmRcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicygoKGFuZ2xlQmV0d2VlbiArIDEpICUgMzYwKSAtIDEpIDwgVEhSRVNIT0xEKSB7IC8vIHJvdW5kaW5nIGFyb3VuZCAwIGFuZCAzNjAgdG8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNyb3NzIHByb2R1Y3QgaXMgMCBiZWNhdXNlIHRoZSBhbmdsZSBpcyAwIGRlZ3JlZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsYXN0IGh1bGwgcG9pbnQgZnJvbSBodWxsIEJVVCBkbyBub3QgZGlzY2FyZCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVlbnRlciBzZWNvbmQtdG8tbGFzdCBodWxsIHBvaW50ICh3aWxsIGJlIGxhc3QgYXQgbmV4dCBpdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHV0IGxhc3QgaHVsbCBwb2ludCBiYWNrIGludG8gdGhlIHNvcnRlZCBwb2ludCByZWNvcmRzIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFBvaW50UmVjb3Jkcy5wdXNoKGxhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIHN3aXRjaGluZyB0aGUgb3JkZXIgb2YgdGhlIDBkZWcgYW5kIDE4MGRlZyBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdHVybiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBsZWZ0IHR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBsYXN0IGh1bGwgcG9pbnQgKGFkZCB0byBpbnNpZGVQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgIC8vaW5zaWRlUG9pbnRzLnVuc2hpZnQobGFzdEh1bGxQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVBvaW50c1tsYXN0SHVsbFBvaW50UmVjb3JkWzBdICsgJ0BAJyArIGxhc3RIdWxsUG9pbnRSZWNvcmRbMV1dID0gbGFzdEh1bGxQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVlbnRlciBzZWNvbmQtdG8tbGFzdCBodWxsIHBvaW50ICh3aWxsIGJlIGxhc3QgYXQgbmV4dCBpdGVyIG9mIGxvb3ApXG4gICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRvIGFueXRoaW5nIHdpdGggY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IHR1cm4gbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGh1bGxQb2ludFJlY29yZHMgY29udGFpbnMgdGhlIG91dHB1dCBwb2ludHMgaW4gY2xvY2t3aXNlIG9yZGVyXG4gICAgLy8gdGhlIHBvaW50cyBzdGFydCB3aXRoIGxvd2VzdC15LGhpZ2hlc3QteCBzdGFydFBvaW50LCBhbmQgZW5kIGF0IHRoZSBzYW1lIHBvaW50XG5cbiAgICAvLyBzdGVwIDNiOiByZW1vdmUgZHVwbGljYXRlZCBzdGFydFBvaW50UmVjb3JkIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICBpZiAoaHVsbFBvaW50UmVjb3Jkcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIGh1bGxQb2ludFJlY29yZHMucG9wKCk7XG4gICAgfVxuXG4gICAgLy8gc3RlcCA0OiBmaW5kIHRoZSBsb3dlc3Qgb3JpZ2luYWxJbmRleCByZWNvcmQgYW5kIHB1dCBpdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGh1bGxcbiAgICB2YXIgbG93ZXN0SHVsbEluZGV4OyAvLyB0aGUgbG93ZXN0IG9yaWdpbmFsSW5kZXggb24gdGhlIGh1bGxcbiAgICB2YXIgaW5kZXhPZkxvd2VzdEh1bGxJbmRleFJlY29yZCA9IC0xOyAvLyB0aGUgaW5kZXggb2YgdGhlIHJlY29yZCB3aXRoIGxvd2VzdEh1bGxJbmRleFxuICAgIG4gPSBodWxsUG9pbnRSZWNvcmRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRIdWxsSW5kZXggPSBodWxsUG9pbnRSZWNvcmRzW2ldWzFdO1xuXG4gICAgICAgIGlmIChsb3dlc3RIdWxsSW5kZXggPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50SHVsbEluZGV4IDwgbG93ZXN0SHVsbEluZGV4KSB7XG4gICAgICAgICAgICBsb3dlc3RIdWxsSW5kZXggPSBjdXJyZW50SHVsbEluZGV4O1xuICAgICAgICAgICAgaW5kZXhPZkxvd2VzdEh1bGxJbmRleFJlY29yZCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaHVsbFBvaW50UmVjb3Jkc1Jlb3JkZXJlZCA9IFtdO1xuICAgIGlmIChpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkID4gMCkge1xuICAgICAgICB2YXIgbmV3Rmlyc3RDaHVuayA9IGh1bGxQb2ludFJlY29yZHMuc2xpY2UoaW5kZXhPZkxvd2VzdEh1bGxJbmRleFJlY29yZCk7XG4gICAgICAgIHZhciBuZXdTZWNvbmRDaHVuayA9IGh1bGxQb2ludFJlY29yZHMuc2xpY2UoMCwgaW5kZXhPZkxvd2VzdEh1bGxJbmRleFJlY29yZCk7XG4gICAgICAgIGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWQgPSBuZXdGaXJzdENodW5rLmNvbmNhdChuZXdTZWNvbmRDaHVuayk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBodWxsUG9pbnRSZWNvcmRzUmVvcmRlcmVkID0gaHVsbFBvaW50UmVjb3JkcztcbiAgICB9XG5cbiAgICB2YXIgaHVsbFBvaW50cyA9IFtdO1xuICAgIG4gPSBodWxsUG9pbnRSZWNvcmRzUmVvcmRlcmVkLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGh1bGxQb2ludHMucHVzaChodWxsUG9pbnRSZWNvcmRzUmVvcmRlcmVkW2ldWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHVsbFBvaW50cztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/points.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/polygon.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/g/polygon.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polygon: () => (/* binding */ Polygon)\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polyline.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _extend_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extend.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/extend.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _points_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./points.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/points.mjs\");\n\n\n\n\n\n\nconst Polygon = function(points) {\n\n    if (!(this instanceof Polygon)) {\n        return new Polygon(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polygon.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(_point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point) : []);\n};\n\nPolygon.parse = function(svgString) {\n    return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePoints)(svgString));\n};\n\nPolygon.fromRect = function(rect) {\n    return new Polygon([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft()\n    ]);\n};\n\nPolygon.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_2__.extend)(_polyline_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline.prototype, {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_4__.types.Polygon,\n\n    clone: function() {\n        return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.clonePoints)(this.points));\n    },\n\n    convexHull: function() {\n        return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.convexHull)(this.points));\n    },\n\n    lengthPoints: function() {\n        const { start, end, points } = this;\n        if (points.length <= 1 || start.equals(end)) return points;\n        return [...points, start.clone()];\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9seWdvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ007QUFDSjtBQUNGO0FBQ2dDOztBQUU3RDs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCw2Q0FBSztBQUMzRDs7QUFFQTtBQUNBLHVCQUF1Qix3REFBVztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtREFBTSxDQUFDLG1EQUFROztBQUVuQyxVQUFVLDZDQUFLOztBQUVmO0FBQ0EsMkJBQTJCLHdEQUFXO0FBQ3RDLEtBQUs7O0FBRUw7QUFDQSwyQkFBMkIsdURBQVU7QUFDckMsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL3BvbHlnb24ubWpzPzc2NzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4vcG9seWxpbmUubWpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vZXh0ZW5kLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcbmltcG9ydCB7IGNsb25lUG9pbnRzLCBwYXJzZVBvaW50cywgY29udmV4SHVsbCB9IGZyb20gJy4vcG9pbnRzLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBQb2x5Z29uID0gZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9seWdvbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBvaW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwb2ludHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbi5wYXJzZShwb2ludHMpO1xuICAgIH1cblxuICAgIHRoaXMucG9pbnRzID0gKEFycmF5LmlzQXJyYXkocG9pbnRzKSA/IHBvaW50cy5tYXAoUG9pbnQpIDogW10pO1xufTtcblxuUG9seWdvbi5wYXJzZSA9IGZ1bmN0aW9uKHN2Z1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUG9seWdvbihwYXJzZVBvaW50cyhzdmdTdHJpbmcpKTtcbn07XG5cblBvbHlnb24uZnJvbVJlY3QgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKFtcbiAgICAgICAgcmVjdC50b3BMZWZ0KCksXG4gICAgICAgIHJlY3QudG9wUmlnaHQoKSxcbiAgICAgICAgcmVjdC5ib3R0b21SaWdodCgpLFxuICAgICAgICByZWN0LmJvdHRvbUxlZnQoKVxuICAgIF0pO1xufTtcblxuUG9seWdvbi5wcm90b3R5cGUgPSBleHRlbmQoUG9seWxpbmUucHJvdG90eXBlLCB7XG5cbiAgICB0eXBlOiB0eXBlcy5Qb2x5Z29uLFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24oY2xvbmVQb2ludHModGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgY29udmV4SHVsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbihjb252ZXhIdWxsKHRoaXMucG9pbnRzKSk7XG4gICAgfSxcblxuICAgIGxlbmd0aFBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgcG9pbnRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAxIHx8IHN0YXJ0LmVxdWFscyhlbmQpKSByZXR1cm4gcG9pbnRzO1xuICAgICAgICByZXR1cm4gWy4uLnBvaW50cywgc3RhcnQuY2xvbmUoKV07XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/polygon.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/polyline.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@joint/core/src/g/polyline.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polyline: () => (/* binding */ Polyline)\n/* harmony export */ });\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rect.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _points_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./points.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/points.mjs\");\n\n\n\n\n\n\n\nconst Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(_point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePoints)(svgString));\n};\n\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft(),\n    ]);\n};\n\nPolyline.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Polyline,\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_3__.Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n        return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.clonePoints)(this.points));\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var ray = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var rayEnd = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n\n    lengthPoints: function() {\n        return this.points;\n    },\n\n    convexHull: function() {\n        return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.convexHull)(this.points));\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n        // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n        // because of the rounding errors that can occur when comparing distances.\n        const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9seWxpbmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrQztBQUNFO0FBQ0Y7QUFDRTtBQUNnQzs7O0FBRzdEOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELDZDQUFLO0FBQzNEOztBQUVBO0FBQ0Esd0JBQXdCLHdEQUFXO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDZDQUFLOztBQUVmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDLHdCQUF3QixlQUFlOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkNBQUk7QUFDdkIsS0FBSzs7QUFFTDtBQUNBLDRCQUE0Qix3REFBVztBQUN2QyxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTzs7QUFFL0IsMkJBQTJCLDJDQUFJO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQiwyQ0FBSTtBQUM5QixzQkFBc0IsMkNBQUk7QUFDMUIseUJBQXlCLDZD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O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBLHdCQUF3QixlQUFlOztBQUV2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0EsS0FBSztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL3BvbHlsaW5lLm1qcz8yNGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBjbG9uZVBvaW50cywgcGFyc2VQb2ludHMsIGNvbnZleEh1bGwgfSBmcm9tICcuL3BvaW50cy5tanMnO1xuXG5cbmV4cG9ydCBjb25zdCBQb2x5bGluZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvbHlsaW5lKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKHBvaW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwb2ludHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUucGFyc2UocG9pbnRzKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvaW50cyA9IChBcnJheS5pc0FycmF5KHBvaW50cykgPyBwb2ludHMubWFwKFBvaW50KSA6IFtdKTtcbn07XG5cblBvbHlsaW5lLnBhcnNlID0gZnVuY3Rpb24oc3ZnU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bGluZShwYXJzZVBvaW50cyhzdmdTdHJpbmcpKTtcbn07XG5cblBvbHlsaW5lLmZyb21SZWN0ID0gZnVuY3Rpb24ocmVjdCkge1xuICAgIHJldHVybiBuZXcgUG9seWxpbmUoW1xuICAgICAgICByZWN0LnRvcExlZnQoKSxcbiAgICAgICAgcmVjdC50b3BSaWdodCgpLFxuICAgICAgICByZWN0LmJvdHRvbVJpZ2h0KCksXG4gICAgICAgIHJlY3QuYm90dG9tTGVmdCgpLFxuICAgICAgICByZWN0LnRvcExlZnQoKSxcbiAgICBdKTtcbn07XG5cblBvbHlsaW5lLnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLlBvbHlsaW5lLFxuXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHgxID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB4MiA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIHkxID0gSW5maW5pdHk7XG4gICAgICAgIHZhciB5MiA9IC1JbmZpbml0eTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICB2YXIgeCA9IHBvaW50Lng7XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgICAgICAgICAgIGlmICh4IDwgeDEpIHgxID0geDtcbiAgICAgICAgICAgIGlmICh4ID4geDIpIHgyID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgeTEpIHkxID0geTtcbiAgICAgICAgICAgIGlmICh5ID4geTIpIHkyID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUoY2xvbmVQb2ludHModGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdExlbmd0aChjcExlbmd0aCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIDA7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gMDsgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnRcblxuICAgICAgICB2YXIgY3BMZW5ndGg7XG4gICAgICAgIHZhciBtaW5TcXJEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmUubGVuZ3RoKCk7XG5cbiAgICAgICAgICAgIHZhciBjcE5vcm1hbGl6ZWRMZW5ndGggPSBsaW5lLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCk7XG4gICAgICAgICAgICB2YXIgY3AgPSBsaW5lLnBvaW50QXQoY3BOb3JtYWxpemVkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdmFyIHNxckRpc3RhbmNlID0gY3Auc3F1YXJlZERpc3RhbmNlKHApO1xuICAgICAgICAgICAgaWYgKHNxckRpc3RhbmNlIDwgbWluU3FyRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBtaW5TcXJEaXN0YW5jZSA9IHNxckRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNwTGVuZ3RoID0gbGVuZ3RoICsgKGNwTm9ybWFsaXplZExlbmd0aCAqIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZW5ndGggKz0gbGluZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjcExlbmd0aDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBjcExlbmd0aCA9IHRoaXMuY2xvc2VzdFBvaW50TGVuZ3RoKHApO1xuICAgICAgICBpZiAoY3BMZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBzaG9ydGN1dFxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMDsgLy8gcHJldmVudHMgZGl2aXNpb24gYnkgemVyb1xuXG4gICAgICAgIHJldHVybiBjcExlbmd0aCAvIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBjcExlbmd0aCA9IHRoaXMuY2xvc2VzdFBvaW50TGVuZ3RoKHApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdExlbmd0aChjcExlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmVhIHN1cnJvdW5kZWQgYnkgdGhlIHBvbHlsaW5lIGNvbnRhaW5zIHRoZSBwb2ludCBgcGAuXG4gICAgLy8gSW1wbGVtZW50cyB0aGUgZXZlbi1vZGQgU1ZHIGFsZ29yaXRobSAoc2VsZi1pbnRlcnNlY3Rpb25zIGFyZSBcIm91dHNpZGVcIikuXG4gICAgLy8gKFVzZXMgaG9yaXpvbnRhbCByYXlzIHRvIHRoZSByaWdodCBvZiBgcGAgdG8gbG9vayBmb3IgaW50ZXJzZWN0aW9ucy4pXG4gICAgLy8gQ2xvc2VzIG9wZW4gcG9seWxpbmVzIChhbHdheXMgaW1hZ2luZXMgYSBmaW5hbCBjbG9zaW5nIHNlZ21lbnQpLlxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gZmFsc2U7IC8vIHNob3J0Y3V0ICh0aGlzIHBvbHlsaW5lIGhhcyBubyBwb2ludHMpXG5cbiAgICAgICAgdmFyIHggPSBwLng7XG4gICAgICAgIHZhciB5ID0gcC55O1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgYSBmaW5hbCBjbG9zaW5nIHNlZ21lbnQgYnkgY3JlYXRpbmcgb25lIGZyb20gbGFzdC1maXJzdCBwb2ludHMgb24gcG9seWxpbmVcbiAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBudW1Qb2ludHMgLSAxOyAvLyBzdGFydCBvZiBjdXJyZW50IHBvbHlsaW5lIHNlZ21lbnRcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gMDsgLy8gZW5kIG9mIGN1cnJlbnQgcG9seWxpbmUgc2VnbWVudFxuICAgICAgICB2YXIgbnVtSW50ZXJzZWN0aW9ucyA9IDA7XG4gICAgICAgIHZhciBzZWdtZW50ID0gbmV3IExpbmUoKTtcbiAgICAgICAgdmFyIHJheSA9IG5ldyBMaW5lKCk7XG4gICAgICAgIHZhciByYXlFbmQgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgZm9yICg7IGVuZEluZGV4IDwgbnVtUG9pbnRzOyBlbmRJbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludHNbc3RhcnRJbmRleF07XG4gICAgICAgICAgICB2YXIgZW5kID0gcG9pbnRzW2VuZEluZGV4XTtcbiAgICAgICAgICAgIGlmIChwLmVxdWFscyhzdGFydCkpIHJldHVybiB0cnVlOyAvLyBzaG9ydGN1dCAoYHBgIGlzIGEgcG9pbnQgb24gcG9seWxpbmUpXG4gICAgICAgICAgICAvLyBjdXJyZW50IHBvbHlsaW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHNlZ21lbnQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHNlZ21lbnQuZW5kID0gZW5kO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuY29udGFpbnNQb2ludChwKSkgcmV0dXJuIHRydWU7IC8vIHNob3J0Y3V0IChgcGAgbGllcyBvbiBhIHBvbHlsaW5lIHNlZ21lbnQpXG5cbiAgICAgICAgICAgIC8vIGRvIHdlIGhhdmUgYW4gaW50ZXJzZWN0aW9uP1xuICAgICAgICAgICAgaWYgKCgoeSA8PSBzdGFydC55KSAmJiAoeSA+IGVuZC55KSkgfHwgKCh5ID4gc3RhcnQueSkgJiYgKHkgPD0gZW5kLnkpKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uYWwgYnJhbmNoIElTIE5PVCBlbnRlcmVkIHdoZW4gYHNlZ21lbnRgIGlzIGNvbGxpbmVhci9jb2luY2lkZW50IHdpdGggYHJheWBcbiAgICAgICAgICAgICAgICAvLyAod2hlbiBgeSA9PT0gc3RhcnQueSA9PT0gZW5kLnlgKVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uYWwgYnJhbmNoIElTIGVudGVyZWQgd2hlbiBgc2VnbWVudGAgdG91Y2hlcyBgcmF5YCBhdCBvbmx5IG9uZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIChlLmcuIHdoZW4gYHkgPT09IHN0YXJ0LnkgIT09IGVuZC55YClcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGlzIGJyYW5jaCBpcyBlbnRlcmVkIGFnYWluIGZvciB0aGUgZm9sbG93aW5nIHNlZ21lbnQsIHRoZSB0d28gdG91Y2hlcyBjYW5jZWwgb3V0XG5cbiAgICAgICAgICAgICAgICB2YXIgeERpZmZlcmVuY2UgPSAoKChzdGFydC54IC0geCkgPiAoZW5kLnggLSB4KSkgPyAoc3RhcnQueCAtIHgpIDogKGVuZC54IC0geCkpO1xuICAgICAgICAgICAgICAgIGlmICh4RGlmZmVyZW5jZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgbGllcyBhdCBsZWFzdCBwYXJ0aWFsbHkgdG8gdGhlIHJpZ2h0IG9mIGBwYFxuICAgICAgICAgICAgICAgICAgICByYXlFbmQueCA9IHggKyB4RGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgcmF5RW5kLnkgPSB5OyAvLyByaWdodFxuICAgICAgICAgICAgICAgICAgICByYXkuc3RhcnQgPSBwO1xuICAgICAgICAgICAgICAgICAgICByYXkuZW5kID0gcmF5RW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5pbnRlcnNlY3QocmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW50ZXJzZWN0aW9uIHdhcyBkZXRlY3RlZCB0byB0aGUgcmlnaHQgb2YgYHBgXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1JbnRlcnNlY3Rpb25zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVsc2U6IGBzZWdtZW50YCBsaWVzIGNvbXBsZXRlbHkgdG8gdGhlIGxlZnQgb2YgYHBgIChpLmUuIG5vIGludGVyc2VjdGlvbiB0byB0aGUgcmlnaHQpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdG8gY2hlY2sgdGhlIG5leHQgcG9seWxpbmUgc2VnbWVudFxuICAgICAgICAgICAgc3RhcnRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJucyBgdHJ1ZWAgZm9yIG9kZCBudW1iZXJzIG9mIGludGVyc2VjdGlvbnMgKGV2ZW4tb2RkIGFsZ29yaXRobSlcbiAgICAgICAgcmV0dXJuICgobnVtSW50ZXJzZWN0aW9ucyAlIDIpID09PSAxKTtcbiAgICB9LFxuXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHBvaW50cyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiAhc3RhcnQuZXF1YWxzKGVuZCkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHN0YXJ0LmNsb25lKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsZW5ndGhQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XG4gICAgfSxcblxuICAgIGNvbnZleEh1bGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKGNvbnZleEh1bGwodGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIHBvbHlsaW5lcyBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgICAvLyBJZiBgcGAgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybnMgZmFsc2UuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgaWYgKCFwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgb3RoZXJQb2ludHMgPSBwLnBvaW50cztcblxuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG90aGVyUG9pbnRzLmxlbmd0aCAhPT0gbnVtUG9pbnRzKSByZXR1cm4gZmFsc2U7IC8vIGlmIHRoZSB0d28gcG9seWxpbmVzIGhhdmUgZGlmZmVyZW50IG51bWJlciBvZiBwb2ludHMsIHRoZXkgY2Fubm90IGJlIGVxdWFsXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICB2YXIgb3RoZXJQb2ludCA9IHAucG9pbnRzW2ldO1xuXG4gICAgICAgICAgICAvLyBhcyBzb29uIGFzIGFuIGluZXF1YWxpdHkgaXMgZm91bmQgaW4gcG9pbnRzLCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGlmICghcG9pbnQuZXF1YWxzKG90aGVyUG9pbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBpbmVxdWFsaXR5IGZvdW5kIGluIHBvaW50cywgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lOiBmdW5jdGlvbihsKSB7XG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUobCk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbDIgPSBuZXcgTGluZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGggLSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsMi5zdGFydCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGwyLmVuZCA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICB2YXIgaW50ID0gbGluZS5pbnRlcnNlY3Rpb25XaXRoTGluZShsMik7XG4gICAgICAgICAgICBpZiAoaW50KSBpbnRlcnNlY3Rpb25zLnB1c2goaW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkgPyBpbnRlcnNlY3Rpb25zIDogbnVsbDtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUoKTtcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGluZS5zdGFydCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxpbmUuZW5kID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYSBkaWZmZXJlbnRpYWJsZSBsaW5lIGlzIGZvdW5kIGJldHdlZW4gdHdvIHBvaW50cywgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIGlmIChsaW5lLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBubyBkaWZmZXJlbnRpYWJsZSBsaW5lIGlzIGZvdW5kIGJldHdlZW4gcGFpcnMgb2YgcG9pbnRzLCByZXR1cm4gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIDA7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB2YXIgbiA9IG51bVBvaW50cyAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gcG9pbnRzW2ldLmRpc3RhbmNlKHBvaW50c1tpICsgMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgcG9pbnRBdDogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5sZW5ndGhQb2ludHMoKTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMSkgcmV0dXJuIHBvaW50c1swXS5jbG9uZSgpOyAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludFxuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gcG9pbnRzWzBdLmNsb25lKCk7XG4gICAgICAgIGlmIChyYXRpbyA+PSAxKSByZXR1cm4gcG9pbnRzW251bVBvaW50cyAtIDFdLmNsb25lKCk7XG5cbiAgICAgICAgdmFyIHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBvbHlsaW5lTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdExlbmd0aChsZW5ndGgpO1xuICAgIH0sXG5cbiAgICBwb2ludEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5sZW5ndGhQb2ludHMoKTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMSkgcmV0dXJuIHBvaW50c1swXS5jbG9uZSgpOyAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludFxuXG4gICAgICAgIHZhciBmcm9tU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0ID0gZmFsc2U7IC8vIG5lZ2F0aXZlIGxlbmd0aHMgbWVhbiBzdGFydCBjYWxjdWxhdGlvbiBmcm9tIGVuZCBwb2ludFxuICAgICAgICAgICAgbGVuZ3RoID0gLWxlbmd0aDsgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKGZyb21TdGFydCA/IGkgOiAobiAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBhID0gcG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBiID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKGEsIGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhLmRpc3RhbmNlKGIpO1xuXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZS5wb2ludEF0TGVuZ3RoKChmcm9tU3RhcnQgPyAxIDogLTEpICogKGxlbmd0aCAtIGwpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVuZ3RoIHJlcXVlc3RlZCBpcyBoaWdoZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBwb2x5bGluZSwgcmV0dXJuIGxhc3QgZW5kcG9pbnRcbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IChmcm9tU3RhcnQgPyBwb2ludHNbbnVtUG9pbnRzIC0gMV0gOiBwb2ludHNbMF0pO1xuICAgICAgICByZXR1cm4gbGFzdFBvaW50LmNsb25lKCk7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50c1tpXS5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzW2ldLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaW1wbGlmeTogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gdGhpczsgLy8gd2UgbmVlZCBhdCBsZWFzdCAzIHBvaW50c1xuXG4gICAgICAgIC8vIFRPRE86IHdlIG1heSBhbHNvIGFjY2VwdCBzdGFydEluZGV4IGFuZCBlbmRJbmRleCB0byBzcGVjaWZ5IHdoZXJlIHRvIHN0YXJ0IGFuZCBlbmQgc2ltcGxpZmljYXRpb25cblxuICAgICAgICAvLyBEdWUgdG8gdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtLCB3ZSBkbyBub3QgdXNlIDAgYXMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGB0aHJlc2hvbGRgXG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIHJvdW5kaW5nIGVycm9ycyB0aGF0IGNhbiBvY2N1ciB3aGVuIGNvbXBhcmluZyBkaXN0YW5jZXMuXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdC50aHJlc2hvbGQgfHwgMWUtMTA7IC8vID0gbWF4IGRpc3RhbmNlIG9mIG1pZGRsZSBwb2ludCBmcm9tIGNob3JkIHRvIGJlIHNpbXBsaWZpZWRcblxuICAgICAgICAvLyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwb2x5bGluZSBhbmQgZ28gZm9yd2FyZFxuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgLy8gd2UgbmVlZCBhdCBsZWFzdCBvbmUgaW50ZXJtZWRpYXRlIHBvaW50ICgzIHBvaW50cykgaW4gZXZlcnkgaXRlcmF0aW9uXG4gICAgICAgIC8vIGFzIHNvb24gYXMgdGhhdCBzdG9wcyBiZWluZyB0cnVlLCB3ZSBrbm93IHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcG9seWxpbmVcbiAgICAgICAgd2hpbGUgKHBvaW50c1tjdXJyZW50SW5kZXggKyAyXSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZUluZGV4ID0gKGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gKGN1cnJlbnRJbmRleCArIDIpO1xuXG4gICAgICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gcG9pbnRzW2ZpcnN0SW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlUG9pbnQgPSBwb2ludHNbbWlkZGxlSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW2xhc3RJbmRleF07XG5cbiAgICAgICAgICAgIGNvbnN0IGNob3JkID0gbmV3IExpbmUoZmlyc3RQb2ludCwgbGFzdFBvaW50KTsgLy8gPSBjb25uZWN0aW9uIGJldHdlZW4gZmlyc3QgYW5kIGxhc3QgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludCA9IGNob3JkLmNsb3Nlc3RQb2ludChtaWRkbGVQb2ludCk7IC8vID0gY2xvc2VzdCBwb2ludCBvbiBjaG9yZCBmcm9tIG1pZGRsZSBwb2ludFxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50RGlzdGFuY2UgPSBjbG9zZXN0UG9pbnQuZGlzdGFuY2UobWlkZGxlUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RQb2ludERpc3RhbmNlIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIC8vIG1pZGRsZSBwb2ludCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIGNob3JkID0gc2ltcGxpZnlcbiAgICAgICAgICAgICAgICAvLyAxKSByZW1vdmUgbWlkZGxlIHBvaW50OlxuICAgICAgICAgICAgICAgIHBvaW50cy5zcGxpY2UobWlkZGxlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIC8vIDIpIGluIG5leHQgaXRlcmF0aW9uLCBpbnZlc3RpZ2F0ZSB0aGUgbmV3bHktY3JlYXRlZCB0cmlwbGV0IG9mIHBvaW50c1xuICAgICAgICAgICAgICAgIC8vICAgIC0gZG8gbm90IGNoYW5nZSBgY3VycmVudEluZGV4YFxuICAgICAgICAgICAgICAgIC8vICAgID0gKGZpcnN0IHBvaW50IHN0YXlzLCBwb2ludCBhZnRlciByZW1vdmVkIHBvaW50IGJlY29tZXMgbWlkZGxlIHBvaW50KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtaWRkbGUgcG9pbnQgaXMgZmFyIGZyb20gdGhlIGNob3JkXG4gICAgICAgICAgICAgICAgLy8gMSkgcHJlc2VydmUgbWlkZGxlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gMikgaW4gbmV4dCBpdGVyYXRpb24sIG1vdmUgYGN1cnJlbnRJbmRleGAgYnkgb25lIHN0ZXA6XG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgLy8gICAgPSAocG9pbnQgYWZ0ZXIgZmlyc3QgcG9pbnQgYmVjb21lcyBmaXJzdCBwb2ludClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBwb2ludHNgIGFycmF5IHdhcyBtb2RpZmllZCBpbi1wbGFjZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdGFuZ2VudEF0OiBmdW5jdGlvbihyYXRpbykge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gbnVsbDsgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnRcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICB2YXIgcG9seWxpbmVMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcG9seWxpbmVMZW5ndGggKiByYXRpbztcblxuICAgICAgICByZXR1cm4gdGhpcy50YW5nZW50QXRMZW5ndGgobGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgdGFuZ2VudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5sZW5ndGhQb2ludHMoKTtcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMSkgcmV0dXJuIG51bGw7IC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIHBvaW50XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RWYWxpZExpbmU7IC8vIGRpZmZlcmVudGlhYmxlICh3aXRoIGEgdGFuZ2VudClcbiAgICAgICAgdmFyIGwgPSAwOyAvLyBsZW5ndGggc28gZmFyXG4gICAgICAgIHZhciBuID0gbnVtUG9pbnRzIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG4gLSAxIC0gaSkpO1xuXG4gICAgICAgICAgICB2YXIgYSA9IHBvaW50c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgYiA9IHBvaW50c1tpbmRleCArIDFdO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZShhLCBiKTtcbiAgICAgICAgICAgIHZhciBkID0gYS5kaXN0YW5jZShiKTtcblxuICAgICAgICAgICAgaWYgKGxpbmUuaXNEaWZmZXJlbnRpYWJsZSgpKSB7IC8vIGhhcyBhIHRhbmdlbnQgbGluZSAobGluZSBsZW5ndGggaXMgbm90IDApXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnRhbmdlbnRBdExlbmd0aCgoZnJvbVN0YXJ0ID8gMSA6IC0xKSAqIChsZW5ndGggLSBsKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkTGluZSA9IGxpbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlbmd0aCByZXF1ZXN0ZWQgaXMgaGlnaGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcG9seWxpbmUsIHJldHVybiBsYXN0IHZhbGlkIGVuZHBvaW50XG4gICAgICAgIGlmIChsYXN0VmFsaWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSAoZnJvbVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RWYWxpZExpbmUudGFuZ2VudEF0KHJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZhbGlkIGxpbmUsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzICsgJyc7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0udHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHN2Z1N0cmluZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlY3JlYXRlIHRoaXMgbGluZS5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiAnJzsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIG91dHB1dCArPSBwb2ludC54ICsgJywnICsgcG9pbnQueSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQudHJpbSgpO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2x5bGluZS5wcm90b3R5cGUsICdzdGFydCcsIHtcbiAgICAvLyBHZXR0ZXIgZm9yIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgcG9seWxpbmUuXG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRzWzBdO1xuICAgIH0sXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbHlsaW5lLnByb3RvdHlwZSwgJ2VuZCcsIHtcbiAgICAvLyBHZXR0ZXIgZm9yIHRoZSBsYXN0IHBvaW50IG9mIHRoZSBwb2x5bGluZS5cblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHNbbnVtUG9pbnRzIC0gMV07XG4gICAgfSxcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/rect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@joint/core/src/g/rect.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   rect: () => (/* binding */ rect)\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _ellipse_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ellipse.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\n\nconst {\n    abs,\n    cos,\n    sin,\n    min,\n    max,\n    round,\n    pow\n} = Math;\n\nconst Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new _ellipse_mjs__WEBPACK_IMPORTED_MODULE_0__.Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function(...points) {\n\n    if (points.length === 0) return null;\n\n    const p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function(...rects) {\n\n    if (rects.length === 0) return null;\n\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < rects.length; i++) {\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Rect,\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toRad)(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n\n    bottomLeft: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    // @param {bool} strict If true, the point has to be strictly inside (not on the border).\n    containsPoint: function(p, opt) {\n        let x, y;\n        if (!p || (typeof p === 'string')) {\n            // Backwards compatibility: if the point is not provided,\n            // the point is considered to be the origin [0, 0].\n            ({ x, y } = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(p));\n        } else {\n            // Do not create a new Point object if the point is already a Point-like object.\n            ({ x = 0, y = 0 } = p);\n        }\n        return opt && opt.strict\n            ? (x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height)\n            : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(p);\n        var center = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, point.y);\n                case 'left':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, point.y);\n                case 'bottom':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, this.y + this.height);\n                case 'top':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        return Rect.fromRectUnion(this, rect);\n    },\n\n    update: function(x, y, w, h) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nconst rect = Rect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcmVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUErQztBQUNiO0FBQ0U7QUFDSTtBQUNKOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFSzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWUFBWSxpREFBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQiw2Q0FBSztBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSw2Q0FBSzs7QUFFZjtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLHNCQUFzQiw0REFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLG1CQUFtQiw2Q0FBSztBQUN4QixLQUFLOztBQUVMOztBQUVBLG1CQUFtQiwyQ0FBSTtBQUN2QixLQUFLOztBQUVMOztBQUVBLG1CQUFtQiw2Q0FBSztBQUN4QixLQUFLOztBQUVMOztBQUVBLG1CQUFtQiw2Q0FBSztBQUN4QixLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsTUFBTTtBQUN0QixlQUFlLE1BQU07QUFDckI7QUFD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Q2pDLGtDQUFrQztBQUNsQyxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQSxvQkFBb0IsNkNBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsaUJBQWlCO0FBQ2pCLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDJDQUFJO0FBQ3ZCLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixNQUFNO0FBQ3RCOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcmVjdC5tanM/YmRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b1JhZCB9IGZyb20gJy4vZ2VvbWV0cnkuaGVscGVycy5tanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5pbXBvcnQgeyBFbGxpcHNlIH0gZnJvbSAnLi9lbGxpcHNlLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcblxuY29uc3Qge1xuICAgIGFicyxcbiAgICBjb3MsXG4gICAgc2luLFxuICAgIG1pbixcbiAgICBtYXgsXG4gICAgcm91bmQsXG4gICAgcG93XG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IFJlY3QgPSBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgIGlmICgoT2JqZWN0KHgpID09PSB4KSkge1xuICAgICAgICB5ID0geC55O1xuICAgICAgICB3ID0geC53aWR0aDtcbiAgICAgICAgaCA9IHguaGVpZ2h0O1xuICAgICAgICB4ID0geC54O1xuICAgIH1cblxuICAgIHRoaXMueCA9IHggPT09IHVuZGVmaW5lZCA/IDAgOiB4O1xuICAgIHRoaXMueSA9IHkgPT09IHVuZGVmaW5lZCA/IDAgOiB5O1xuICAgIHRoaXMud2lkdGggPSB3ID09PSB1bmRlZmluZWQgPyAwIDogdztcbiAgICB0aGlzLmhlaWdodCA9IGggPT09IHVuZGVmaW5lZCA/IDAgOiBoO1xufTtcblxuUmVjdC5mcm9tRWxsaXBzZSA9IGZ1bmN0aW9uKGUpIHtcblxuICAgIGUgPSBuZXcgRWxsaXBzZShlKTtcbiAgICByZXR1cm4gbmV3IFJlY3QoZS54IC0gZS5hLCBlLnkgLSBlLmIsIDIgKiBlLmEsIDIgKiBlLmIpO1xufTtcblxuUmVjdC5mcm9tUG9pbnRVbmlvbiA9IGZ1bmN0aW9uKC4uLnBvaW50cykge1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCgpO1xuICAgIGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgIG1pblggPSBtaW5ZID0gSW5maW5pdHk7XG4gICAgbWF4WCA9IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwLnVwZGF0ZShwb2ludHNbaV0pO1xuICAgICAgICBjb25zdCB4ID0gcC54O1xuICAgICAgICBjb25zdCB5ID0gcC55O1xuXG4gICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWN0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG59O1xuXG5SZWN0LmZyb21SZWN0VW5pb24gPSBmdW5jdGlvbiguLi5yZWN0cykge1xuXG4gICAgaWYgKHJlY3RzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCByID0gbmV3IFJlY3QoKTtcbiAgICBsZXQgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcbiAgICBtaW5YID0gbWluWSA9IEluZmluaXR5O1xuICAgIG1heFggPSBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByLnVwZGF0ZShyZWN0c1tpXSk7XG4gICAgICAgIGNvbnN0IHggPSByLng7XG4gICAgICAgIGNvbnN0IHkgPSByLnk7XG4gICAgICAgIGNvbnN0IG1YID0geCArIHIud2lkdGg7XG4gICAgICAgIGNvbnN0IG1ZID0geSArIHIuaGVpZ2h0O1xuXG4gICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgIGlmIChtWCA+IG1heFgpIG1heFggPSBtWDtcbiAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgaWYgKG1ZID4gbWF4WSkgbWF4WSA9IG1ZO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xufTtcblxuUmVjdC5wcm90b3R5cGUgPSB7XG5cbiAgICB0eXBlOiB0eXBlcy5SZWN0LFxuXG4gICAgLy8gRmluZCBteSBib3VuZGluZyBib3ggd2hlbiBJJ20gcm90YXRlZCB3aXRoIHRoZSBjZW50ZXIgb2Ygcm90YXRpb24gaW4gdGhlIGNlbnRlciBvZiBtZS5cbiAgICAvLyBAcmV0dXJuIHIge3JlY3RhbmdsZX0gcmVwcmVzZW50aW5nIGEgYm91bmRpbmcgYm94XG4gICAgYmJveDogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5yb3RhdGVBcm91bmRDZW50ZXIoYW5nbGUpO1xuICAgIH0sXG5cbiAgICByb3RhdGVBcm91bmRDZW50ZXI6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgIGlmICghYW5nbGUpIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gdG9SYWQoYW5nbGUpO1xuICAgICAgICBjb25zdCBzdCA9IGFicyhzaW4odGhldGEpKTtcbiAgICAgICAgY29uc3QgY3QgPSBhYnMoY29zKHRoZXRhKSk7XG4gICAgICAgIGNvbnN0IHcgPSB3aWR0aCAqIGN0ICsgaGVpZ2h0ICogc3Q7XG4gICAgICAgIGNvbnN0IGggPSB3aWR0aCAqIHN0ICsgaGVpZ2h0ICogY3Q7XG4gICAgICAgIHRoaXMueCArPSAod2lkdGggLSB3KSAvIDI7XG4gICAgICAgIHRoaXMueSArPSAoaGVpZ2h0IC0gaCkgLyAyO1xuICAgICAgICB0aGlzLndpZHRoID0gdztcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYm90dG9tTGVmdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgYm90dG9tTGluZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHRoaXMuYm90dG9tTGVmdCgpLCB0aGlzLmJvdHRvbVJpZ2h0KCkpO1xuICAgIH0sXG5cbiAgICBib3R0b21NaWRkbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgY2VudGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtib29sfSB0cnVlIGlmIHBvaW50IHAgaXMgaW5zaWRlIG1lLlxuICAgIC8vIEBwYXJhbSB7Ym9vbH0gc3RyaWN0IElmIHRydWUsIHRoZSBwb2ludCBoYXMgdG8gYmUgc3RyaWN0bHkgaW5zaWRlIChub3Qgb24gdGhlIGJvcmRlcikuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocCwgb3B0KSB7XG4gICAgICAgIGxldCB4LCB5O1xuICAgICAgICBpZiAoIXAgfHwgKHR5cGVvZiBwID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiB0aGUgcG9pbnQgaXMgbm90IHByb3ZpZGVkLFxuICAgICAgICAgICAgLy8gdGhlIHBvaW50IGlzIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG9yaWdpbiBbMCwgMF0uXG4gICAgICAgICAgICAoeyB4LCB5IH0gPSBuZXcgUG9pbnQocCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRG8gbm90IGNyZWF0ZSBhIG5ldyBQb2ludCBvYmplY3QgaWYgdGhlIHBvaW50IGlzIGFscmVhZHkgYSBQb2ludC1saWtlIG9iamVjdC5cbiAgICAgICAgICAgICh7IHggPSAwLCB5ID0gMCB9ID0gcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdCAmJiBvcHQuc3RyaWN0XG4gICAgICAgICAgICA/ICh4ID4gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoICYmIHkgPiB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgOiB4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+PSB0aGlzLnkgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7Ym9vbH0gdHJ1ZSBpZiByZWN0YW5nbGUgYHJgIGlzIGluc2lkZSBtZS5cbiAgICBjb250YWluc1JlY3Q6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgICB2YXIgcjAgPSBuZXcgUmVjdCh0aGlzKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIHIxID0gbmV3IFJlY3Qocikubm9ybWFsaXplKCk7XG4gICAgICAgIHZhciB3MCA9IHIwLndpZHRoO1xuICAgICAgICB2YXIgaDAgPSByMC5oZWlnaHQ7XG4gICAgICAgIHZhciB3MSA9IHIxLndpZHRoO1xuICAgICAgICB2YXIgaDEgPSByMS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKCF3MCB8fCAhaDAgfHwgIXcxIHx8ICFoMSkge1xuICAgICAgICAgICAgLy8gQXQgbGVhc3Qgb25lIG9mIHRoZSBkaW1lbnNpb25zIGlzIDBcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MCA9IHIwLng7XG4gICAgICAgIHZhciB5MCA9IHIwLnk7XG4gICAgICAgIHZhciB4MSA9IHIxLng7XG4gICAgICAgIHZhciB5MSA9IHIxLnk7XG5cbiAgICAgICAgdzEgKz0geDE7XG4gICAgICAgIHcwICs9IHgwO1xuICAgICAgICBoMSArPSB5MTtcbiAgICAgICAgaDAgKz0geTA7XG5cbiAgICAgICAgcmV0dXJuIHgwIDw9IHgxICYmIHcxIDw9IHcwICYmIHkwIDw9IHkxICYmIGgxIDw9IGgwO1xuICAgIH0sXG5cbiAgICBjb3JuZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHJlY3RhbmdsZXMgYXJlIGVxdWFsLlxuICAgIGVxdWFsczogZnVuY3Rpb24ocikge1xuXG4gICAgICAgIHZhciBtciA9IChuZXcgUmVjdCh0aGlzKSkubm9ybWFsaXplKCk7XG4gICAgICAgIHZhciBuciA9IChuZXcgUmVjdChyKSkubm9ybWFsaXplKCk7XG4gICAgICAgIHJldHVybiBtci54ID09PSBuci54ICYmIG1yLnkgPT09IG5yLnkgJiYgbXIud2lkdGggPT09IG5yLndpZHRoICYmIG1yLmhlaWdodCA9PT0gbnIuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvLyBpbmZsYXRlIGJ5IGR4IGFuZCBkeSwgcmVjb21wdXRlIG9yaWdpbiBbeCwgeV1cbiAgICAvLyBAcGFyYW0gZHgge2RlbHRhX3h9IHJlcHJlc2VudGluZyBhZGRpdGlvbmFsIHNpemUgdG8geFxuICAgIC8vIEBwYXJhbSBkeSB7ZGVsdGFfeX0gcmVwcmVzZW50aW5nIGFkZGl0aW9uYWwgc2l6ZSB0byB5IC1cbiAgICAvLyBkeSBwYXJhbSBpcyBub3QgcmVxdWlyZWQgLT4gaW4gdGhhdCBjYXNlIHkgaXMgc2l6ZWQgYnkgZHhcbiAgICBpbmZsYXRlOiBmdW5jdGlvbihkeCwgZHkpIHtcblxuICAgICAgICBpZiAoZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR5ID0gZHg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggLT0gZHg7XG4gICAgICAgIHRoaXMueSAtPSBkeTtcbiAgICAgICAgdGhpcy53aWR0aCArPSAyICogZHg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICs9IDIgKiBkeTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7cmVjdH0gaWYgcmVjdGFuZ2xlcyBpbnRlcnNlY3QsIHtudWxsfSBpZiBub3QuXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbihyKSB7XG5cbiAgICAgICAgdmFyIG15T3JpZ2luID0gdGhpcy5vcmlnaW4oKTtcbiAgICAgICAgdmFyIG15Q29ybmVyID0gdGhpcy5jb3JuZXIoKTtcbiAgICAgICAgdmFyIHJPcmlnaW4gPSByLm9yaWdpbigpO1xuICAgICAgICB2YXIgckNvcm5lciA9IHIuY29ybmVyKCk7XG5cbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uIGZvdW5kXG4gICAgICAgIGlmIChyQ29ybmVyLnggPD0gbXlPcmlnaW4ueCB8fFxuICAgICAgICAgICAgckNvcm5lci55IDw9IG15T3JpZ2luLnkgfHxcbiAgICAgICAgICAgIHJPcmlnaW4ueCA+PSBteUNvcm5lci54IHx8XG4gICAgICAgICAgICByT3JpZ2luLnkgPj0gbXlDb3JuZXIueSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHggPSBtYXgobXlPcmlnaW4ueCwgck9yaWdpbi54KTtcbiAgICAgICAgdmFyIHkgPSBtYXgobXlPcmlnaW4ueSwgck9yaWdpbi55KTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoeCwgeSwgbWluKG15Q29ybmVyLngsIHJDb3JuZXIueCkgLSB4LCBtaW4obXlDb3JuZXIueSwgckNvcm5lci55KSAtIHkpO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZTogZnVuY3Rpb24obGluZSkge1xuXG4gICAgICAgIHZhciByID0gdGhpcztcbiAgICAgICAgdmFyIHJlY3RMaW5lcyA9IFtyLnRvcExpbmUoKSwgci5yaWdodExpbmUoKSwgci5ib3R0b21MaW5lKCksIHIubGVmdExpbmUoKV07XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIGRlZHVwZUFyciA9IFtdO1xuICAgICAgICB2YXIgcHQsIGk7XG5cbiAgICAgICAgdmFyIG4gPSByZWN0TGluZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHB0ID0gbGluZS5pbnRlcnNlY3QocmVjdExpbmVzW2ldKTtcbiAgICAgICAgICAgIGlmIChwdCAhPT0gbnVsbCAmJiBkZWR1cGVBcnIuaW5kZXhPZihwdC50b1N0cmluZygpKSA8IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwdCk7XG4gICAgICAgICAgICAgICAgZGVkdXBlQXJyLnB1c2gocHQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA+IDAgPyBwb2ludHMgOiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHBvaW50IG9uIG15IGJvdW5kYXJ5IHdoZXJlIGxpbmUgc3RhcnRpbmdcbiAgICAvLyBmcm9tIG15IGNlbnRlciBlbmRpbmcgaW4gcG9pbnQgcCBpbnRlcnNlY3RzIG1lLlxuICAgIC8vIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBJZiBhbmdsZSBpcyBzcGVjaWZpZWQsIGludGVyc2VjdGlvbiB3aXRoIHJvdGF0ZWQgcmVjdGFuZ2xlIGlzIGNvbXB1dGVkLlxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQ6IGZ1bmN0aW9uKHAsIGFuZ2xlKSB7XG5cbiAgICAgICAgcCA9IG5ldyBQb2ludChwKTtcbiAgICAgICAgdmFyIGNlbnRlciA9IG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICBpZiAoYW5nbGUpIHAucm90YXRlKGNlbnRlciwgYW5nbGUpO1xuXG4gICAgICAgIC8vIChjbG9ja3dpc2UsIHN0YXJ0aW5nIGZyb20gdGhlIHRvcCBzaWRlKVxuICAgICAgICB2YXIgc2lkZXMgPSBbXG4gICAgICAgICAgICB0aGlzLnRvcExpbmUoKSxcbiAgICAgICAgICAgIHRoaXMucmlnaHRMaW5lKCksXG4gICAgICAgICAgICB0aGlzLmJvdHRvbUxpbmUoKSxcbiAgICAgICAgICAgIHRoaXMubGVmdExpbmUoKVxuICAgICAgICBdO1xuICAgICAgICB2YXIgY29ubmVjdG9yID0gbmV3IExpbmUoY2VudGVyLCBwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gc2lkZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBzaWRlc1tpXS5pbnRlcnNlY3Rpb24oY29ubmVjdG9yKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnRlcnNlY3Rpb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCAmJiBhbmdsZSkgcmVzdWx0LnJvdGF0ZShjZW50ZXIsIC1hbmdsZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGxlZnRMaW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy50b3BMZWZ0KCksIHRoaXMuYm90dG9tTGVmdCgpKTtcbiAgICB9LFxuXG4gICAgbGVmdE1pZGRsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgfSxcblxuICAgIG1heFJlY3RTY2FsZVRvRml0OiBmdW5jdGlvbihyZWN0LCBvcmlnaW4pIHtcblxuICAgICAgICByZWN0ID0gbmV3IFJlY3QocmVjdCk7XG4gICAgICAgIG9yaWdpbiB8fCAob3JpZ2luID0gcmVjdC5jZW50ZXIoKSk7XG5cbiAgICAgICAgdmFyIHN4MSwgc3gyLCBzeDMsIHN4NCwgc3kxLCBzeTIsIHN5Mywgc3k0O1xuICAgICAgICB2YXIgb3ggPSBvcmlnaW4ueDtcbiAgICAgICAgdmFyIG95ID0gb3JpZ2luLnk7XG5cbiAgICAgICAgLy8gSGVyZSB3ZSBmaW5kIHRoZSBtYXhpbWFsIHBvc3NpYmxlIHNjYWxlIGZvciBhbGwgY29ybmVyIHBvaW50cyAoZm9yIHggYW5kIHkgYXhpcykgb2YgdGhlIHJlY3RhbmdsZSxcbiAgICAgICAgLy8gc28gd2hlbiB0aGUgc2NhbGUgaXMgYXBwbGllZCB0aGUgcG9pbnQgaXMgc3RpbGwgaW5zaWRlIHRoZSByZWN0YW5nbGUuXG5cbiAgICAgICAgc3gxID0gc3gyID0gc3gzID0gc3g0ID0gc3kxID0gc3kyID0gc3kzID0gc3k0ID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gVG9wIExlZnRcbiAgICAgICAgdmFyIHAxID0gcmVjdC50b3BMZWZ0KCk7XG4gICAgICAgIGlmIChwMS54IDwgb3gpIHtcbiAgICAgICAgICAgIHN4MSA9ICh0aGlzLnggLSBveCkgLyAocDEueCAtIG94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocDEueSA8IG95KSB7XG4gICAgICAgICAgICBzeTEgPSAodGhpcy55IC0gb3kpIC8gKHAxLnkgLSBveSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQm90dG9tIFJpZ2h0XG4gICAgICAgIHZhciBwMiA9IHJlY3QuYm90dG9tUmlnaHQoKTtcbiAgICAgICAgaWYgKHAyLnggPiBveCkge1xuICAgICAgICAgICAgc3gyID0gKHRoaXMueCArIHRoaXMud2lkdGggLSBveCkgLyAocDIueCAtIG94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocDIueSA+IG95KSB7XG4gICAgICAgICAgICBzeTIgPSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSBveSkgLyAocDIueSAtIG95KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUb3AgUmlnaHRcbiAgICAgICAgdmFyIHAzID0gcmVjdC50b3BSaWdodCgpO1xuICAgICAgICBpZiAocDMueCA+IG94KSB7XG4gICAgICAgICAgICBzeDMgPSAodGhpcy54ICsgdGhpcy53aWR0aCAtIG94KSAvIChwMy54IC0gb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwMy55IDwgb3kpIHtcbiAgICAgICAgICAgIHN5MyA9ICh0aGlzLnkgLSBveSkgLyAocDMueSAtIG95KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCb3R0b20gTGVmdFxuICAgICAgICB2YXIgcDQgPSByZWN0LmJvdHRvbUxlZnQoKTtcbiAgICAgICAgaWYgKHA0LnggPCBveCkge1xuICAgICAgICAgICAgc3g0ID0gKHRoaXMueCAtIG94KSAvIChwNC54IC0gb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwNC55ID4gb3kpIHtcbiAgICAgICAgICAgIHN5NCA9ICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIG95KSAvIChwNC55IC0gb3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN4OiBtaW4oc3gxLCBzeDIsIHN4Mywgc3g0KSxcbiAgICAgICAgICAgIHN5OiBtaW4oc3kxLCBzeTIsIHN5Mywgc3k0KVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBtYXhSZWN0VW5pZm9ybVNjYWxlVG9GaXQ6IGZ1bmN0aW9uKHJlY3QsIG9yaWdpbikge1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMubWF4UmVjdFNjYWxlVG9GaXQocmVjdCwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIG1pbihzY2FsZS5zeCwgc2NhbGUuc3kpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlIGFuZCBleHBhbmQgbWUuXG4gICAgLy8gQHBhcmFtIHIge3JlY3RhbmdsZX0gcmVwcmVzZW50aW5nIGRlbHRhc1xuICAgIG1vdmVBbmRFeHBhbmQ6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgICB0aGlzLnggKz0gci54IHx8IDA7XG4gICAgICAgIHRoaXMueSArPSByLnkgfHwgMDtcbiAgICAgICAgdGhpcy53aWR0aCArPSByLndpZHRoIHx8IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICs9IHIuaGVpZ2h0IHx8IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHJlY3RhbmdsZTsgaS5lLiwgbWFrZSBpdCBzbyB0aGF0IGl0IGhhcyBhIG5vbi1uZWdhdGl2ZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIC8vIElmIHdpZHRoIDwgMCB0aGUgZnVuY3Rpb24gc3dhcHMgdGhlIGxlZnQgYW5kIHJpZ2h0IGNvcm5lcnMsXG4gICAgLy8gYW5kIGl0IHN3YXBzIHRoZSB0b3AgYW5kIGJvdHRvbSBjb3JuZXJzIGlmIGhlaWdodCA8IDBcbiAgICAvLyBsaWtlIGluIGh0dHA6Ly9xdC1wcm9qZWN0Lm9yZy9kb2MvcXQtNC44L3FyZWN0Zi5odG1sI25vcm1hbGl6ZWRcbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBuZXd4ID0gdGhpcy54O1xuICAgICAgICB2YXIgbmV3eSA9IHRoaXMueTtcbiAgICAgICAgdmFyIG5ld3dpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgdmFyIG5ld2hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy53aWR0aCA8IDApIHtcbiAgICAgICAgICAgIG5ld3ggPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgbmV3d2lkdGggPSAtdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBuZXd5ID0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgICAgICAgICBuZXdoZWlnaHQgPSAtdGhpcy5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54ID0gbmV3eDtcbiAgICAgICAgdGhpcy55ID0gbmV3eTtcbiAgICAgICAgdGhpcy53aWR0aCA9IG5ld3dpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG5ld2hlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIE9mZnNldCBtZSBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC5cbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGR4LCBkeSkge1xuXG4gICAgICAgIC8vIHByZXRlbmQgdGhhdCB0aGlzIGlzIGEgcG9pbnQgYW5kIGNhbGwgb2Zmc2V0KClcbiAgICAgICAgLy8gcmV3cml0ZXMgeCBhbmQgeSBhY2NvcmRpbmcgdG8gZHggYW5kIGR5XG4gICAgICAgIHJldHVybiBQb2ludC5wcm90b3R5cGUub2Zmc2V0LmNhbGwodGhpcywgZHgsIGR5KTtcbiAgICB9LFxuXG4gICAgb3JpZ2luOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7cG9pbnR9IGEgcG9pbnQgb24gbXkgYm91bmRhcnkgbmVhcmVzdCB0byB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgLy8gQHNlZSBTcXVlYWsgU21hbGx0YWxrLCBSZWN0YW5nbGU+PnBvaW50TmVhcmVzdFRvOlxuICAgIHBvaW50TmVhcmVzdFRvUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQocG9pbnQpO1xuICAgICAgICBpZiAodGhpcy5jb250YWluc1BvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgdmFyIHNpZGUgPSB0aGlzLnNpZGVOZWFyZXN0VG9Qb2ludChwb2ludCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LngsIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHBvaW50LngsIHRoaXMueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50LmFkaGVyZVRvUmVjdCh0aGlzKTtcbiAgICB9LFxuXG4gICAgcmlnaHRMaW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy50b3BSaWdodCgpLCB0aGlzLmJvdHRvbVJpZ2h0KCkpO1xuICAgIH0sXG5cbiAgICByaWdodE1pZGRsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgbGV0IGYgPSAxOyAvLyBjYXNlIDBcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgc3dpdGNoIChwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGYgPSAxMDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBmID0gMTAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IGYgPSAxMDAwOyBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmID0gcG93KDEwLCBwcmVjaXNpb24pOyBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IHJvdW5kKHRoaXMueCAqIGYpIC8gZjtcbiAgICAgICAgdGhpcy55ID0gcm91bmQodGhpcy55ICogZikgLyBmO1xuICAgICAgICB0aGlzLndpZHRoID0gcm91bmQodGhpcy53aWR0aCAqIGYpIC8gZjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSByb3VuZCh0aGlzLmhlaWdodCAqIGYpIC8gZjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNjYWxlIHJlY3RhbmdsZSB3aXRoIG9yaWdpbi5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICBvcmlnaW4gPSB0aGlzLm9yaWdpbigpLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy54ID0gb3JpZ2luLng7XG4gICAgICAgIHRoaXMueSA9IG9yaWdpbi55O1xuICAgICAgICB0aGlzLndpZHRoICo9IHN4O1xuICAgICAgICB0aGlzLmhlaWdodCAqPSBzeTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3N0cmluZ30gKGxlZnR8cmlnaHR8dG9wfGJvdHRvbSkgc2lkZSB3aGljaCBpcyBuZWFyZXN0IHRvIHBvaW50XG4gICAgLy8gQHNlZSBTcXVlYWsgU21hbGx0YWxrLCBSZWN0YW5nbGU+PnNpZGVOZWFyZXN0VG86XG4gICAgc2lkZU5lYXJlc3RUb1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHBvaW50ID0gbmV3IFBvaW50KHBvaW50KTtcbiAgICAgICAgdmFyIGRpc3RUb0xlZnQgPSBwb2ludC54IC0gdGhpcy54O1xuICAgICAgICB2YXIgZGlzdFRvUmlnaHQgPSAodGhpcy54ICsgdGhpcy53aWR0aCkgLSBwb2ludC54O1xuICAgICAgICB2YXIgZGlzdFRvVG9wID0gcG9pbnQueSAtIHRoaXMueTtcbiAgICAgICAgdmFyIGRpc3RUb0JvdHRvbSA9ICh0aGlzLnkgKyB0aGlzLmhlaWdodCkgLSBwb2ludC55O1xuICAgICAgICB2YXIgY2xvc2VzdCA9IGRpc3RUb0xlZnQ7XG4gICAgICAgIHZhciBzaWRlID0gJ2xlZnQnO1xuXG4gICAgICAgIGlmIChkaXN0VG9SaWdodCA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBkaXN0VG9SaWdodDtcbiAgICAgICAgICAgIHNpZGUgPSAncmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXN0VG9Ub3AgPCBjbG9zZXN0KSB7XG4gICAgICAgICAgICBjbG9zZXN0ID0gZGlzdFRvVG9wO1xuICAgICAgICAgICAgc2lkZSA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXN0VG9Cb3R0b20gPCBjbG9zZXN0KSB7XG4gICAgICAgICAgICAvLyBjbG9zZXN0ID0gZGlzdFRvQm90dG9tO1xuICAgICAgICAgICAgc2lkZSA9ICdib3R0b20nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWRlO1xuICAgIH0sXG5cbiAgICBzbmFwVG9HcmlkOiBmdW5jdGlvbihneCwgZ3kpIHtcblxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW4oKS5zbmFwVG9HcmlkKGd4LCBneSk7XG4gICAgICAgIHZhciBjb3JuZXIgPSB0aGlzLmNvcm5lcigpLnNuYXBUb0dyaWQoZ3gsIGd5KTtcbiAgICAgICAgdGhpcy54ID0gb3JpZ2luLng7XG4gICAgICAgIHRoaXMueSA9IG9yaWdpbi55O1xuICAgICAgICB0aGlzLndpZHRoID0gY29ybmVyLnggLSBvcmlnaW4ueDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBjb3JuZXIueSAtIG9yaWdpbi55O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4geyB4OiB0aGlzLngsIHk6IHRoaXMueSwgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfTtcbiAgICB9LFxuXG4gICAgdG9wTGluZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHRoaXMudG9wTGVmdCgpLCB0aGlzLnRvcFJpZ2h0KCkpO1xuICAgIH0sXG5cbiAgICB0b3BNaWRkbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHRoaXMueSk7XG4gICAgfSxcblxuICAgIHRvcFJpZ2h0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4oKS50b1N0cmluZygpICsgJyAnICsgdGhpcy5jb3JuZXIoKS50b1N0cmluZygpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtyZWN0fSByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIGJvdGggcmVjdGFuZ2xlcy5cbiAgICB1bmlvbjogZnVuY3Rpb24ocmVjdCkge1xuXG4gICAgICAgIHJldHVybiBSZWN0LmZyb21SZWN0VW5pb24odGhpcywgcmVjdCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuXG4gICAgICAgIGlmICgoT2JqZWN0KHgpID09PSB4KSkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHcgPSB4LndpZHRoO1xuICAgICAgICAgICAgaCA9IHguaGVpZ2h0O1xuICAgICAgICAgICAgeCA9IHgueDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCA9IHggfHwgMDtcbiAgICAgICAgdGhpcy55ID0geSB8fCAwO1xuICAgICAgICB0aGlzLndpZHRoID0gdyB8fCAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGggfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuUmVjdC5wcm90b3R5cGUuYm90dG9tUmlnaHQgPSBSZWN0LnByb3RvdHlwZS5jb3JuZXI7XG5cblJlY3QucHJvdG90eXBlLnRvcExlZnQgPSBSZWN0LnByb3RvdHlwZS5vcmlnaW47XG5cblJlY3QucHJvdG90eXBlLnRyYW5zbGF0ZSA9IFJlY3QucHJvdG90eXBlLm9mZnNldDtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuZXhwb3J0IGNvbnN0IHJlY3QgPSBSZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/rect.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/g/types.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/types.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   types: () => (/* binding */ types)\n/* harmony export */ });\nconst types = {\n    Point: 1,\n    Line: 2,\n    Ellipse: 3,\n    Rect: 4,\n    Polyline: 5,\n    Polygon: 6,\n    Curve: 7,\n    Path: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvdHlwZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvdHlwZXMubWpzP2I4MmMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHR5cGVzID0ge1xuICAgIFBvaW50OiAxLFxuICAgIExpbmU6IDIsXG4gICAgRWxsaXBzZTogMyxcbiAgICBSZWN0OiA0LFxuICAgIFBvbHlsaW5lOiA1LFxuICAgIFBvbHlnb246IDYsXG4gICAgQ3VydmU6IDcsXG4gICAgUGF0aDogOFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/g/types.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/highlighters/addClass.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/addClass.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: () => (/* binding */ addClass)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\n\nconst className = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.addClassNamePrefix('highlighted');\n\nconst addClass = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_1__.HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    options: {\n        className\n    },\n\n    highlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).addClass(this.options.className);\n    },\n\n    unhighlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).removeClass(this.options.className);\n    }\n\n}, {\n    // Backwards Compatibility\n    className\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9hZGRDbGFzcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwQztBQUNYO0FBQzhCOztBQUU3RCxrQkFBa0IsK0RBQXVCOztBQUVsQyxpQkFBaUIscUVBQWU7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxRQUFRLHdEQUFDO0FBQ1QsS0FBSzs7QUFFTDtBQUNBLFFBQVEsd0RBQUM7QUFDVDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9oaWdobGlnaHRlcnMvYWRkQ2xhc3MubWpzPzRjZTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5cbmNvbnN0IGNsYXNzTmFtZSA9IHV0aWwuYWRkQ2xhc3NOYW1lUHJlZml4KCdoaWdobGlnaHRlZCcpO1xuXG5leHBvcnQgY29uc3QgYWRkQ2xhc3MgPSBIaWdobGlnaHRlclZpZXcuZXh0ZW5kKHtcblxuICAgIFVQREFUQUJMRTogZmFsc2UsXG4gICAgTU9VTlRBQkxFOiBmYWxzZSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgfSxcblxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oX2NlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIFYobm9kZSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsYXNzTmFtZSk7XG4gICAgfSxcblxuICAgIHVuaGlnaGxpZ2h0OiBmdW5jdGlvbihfY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgVihub2RlKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICB9XG5cbn0sIHtcbiAgICAvLyBCYWNrd2FyZHMgQ29tcGF0aWJpbGl0eVxuICAgIGNsYXNzTmFtZVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/highlighters/addClass.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/highlighters/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: () => (/* reexport safe */ _addClass_mjs__WEBPACK_IMPORTED_MODULE_3__.addClass),\n/* harmony export */   list: () => (/* reexport safe */ _list_mjs__WEBPACK_IMPORTED_MODULE_4__.list),\n/* harmony export */   mask: () => (/* reexport safe */ _mask_mjs__WEBPACK_IMPORTED_MODULE_1__.mask),\n/* harmony export */   opacity: () => (/* reexport safe */ _opacity_mjs__WEBPACK_IMPORTED_MODULE_2__.opacity),\n/* harmony export */   stroke: () => (/* reexport safe */ _stroke_mjs__WEBPACK_IMPORTED_MODULE_0__.stroke)\n/* harmony export */ });\n/* harmony import */ var _stroke_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stroke.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/stroke.mjs\");\n/* harmony import */ var _mask_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mask.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/mask.mjs\");\n/* harmony import */ var _opacity_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./opacity.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/opacity.mjs\");\n/* harmony import */ var _addClass_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./addClass.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/addClass.mjs\");\n/* harmony import */ var _list_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./list.mjs */ \"(ssr)/./node_modules/@joint/core/src/highlighters/list.mjs\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNGO0FBQ0c7QUFDQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL2luZGV4Lm1qcz82OTVmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vc3Ryb2tlLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL21hc2subWpzJztcbmV4cG9ydCAqIGZyb20gJy4vb3BhY2l0eS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hZGRDbGFzcy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9saXN0Lm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/highlighters/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/highlighters/list.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/list.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   list: () => (/* binding */ list)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/getRectPoint.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/getRectPoint.mjs\");\n\n\n\n\n\nconst Directions = {\n    ROW: 'row',\n    COLUMN: 'column'\n};\n\nconst list = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    tagName: 'g',\n    MOUNTABLE: true,\n    UPDATE_ATTRIBUTES: function() {\n        return [this.options.attribute];\n    },\n\n    _prevItems: null,\n\n    highlight(elementView, node) {\n        const element = elementView.model;\n        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;\n        if (!attribute) throw new Error('List: attribute is required');\n        const normalizedSize = (typeof size === 'number') ? { width: size, height: size } : size;\n        const isRowDirection = (direction === Directions.ROW);\n        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n        let items = element.get(attribute);\n        if (!Array.isArray(items)) items = [];\n        const prevItems = this._prevItems || [];\n        const comparison = items.map((item, index) => (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(prevItems[index], items[index]));\n        if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {\n            const prevEls = this.vel.children();\n            const itemsEls = items.map((item, index) => {\n                const prevEl = (index in prevEls) ? prevEls[index].node : null;\n                if (comparison[index]) return prevEl;\n                const itemEl = this.createListItem(item, normalizedSize, prevEl);\n                if (!itemEl) return null;\n                if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');\n                itemEl.dataset.index = index;\n                itemEl.dataset.attribute = attribute;\n                const offset = index * (itemWidth + gap);\n                itemEl.setAttribute('transform', (isRowDirection)\n                    ? `translate(${offset}, 0)`\n                    : `translate(0, ${offset})`\n                );\n                return itemEl;\n            });\n            this.vel.empty().append(itemsEls);\n            this._prevItems = items;\n        }\n        const itemsCount = items.length;\n        const length = (itemsCount === 0)\n            ? 0\n            : (itemsCount * itemWidth + (itemsCount - 1) * gap);\n        const listSize = (isRowDirection)\n            ? { width: length, height: normalizedSize.height }\n            : { width: normalizedSize.width, height: length };\n\n        this.position(element, listSize);\n    },\n\n    position(element, listSize) {\n        const { vel, options } = this;\n        const { margin = 5, position = 'top-left' } = options;\n        const { width, height } = element.size();\n        const { left, right, top, bottom } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeSides)(margin);\n        const bbox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Rect(left, top, width - (left + right), height - (top + bottom));\n        let { x, y } = (0,_util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.getRectPoint)(bbox, position);\n        // x\n        switch (position) {\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.CENTER:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.TOP:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM: {\n                x -= listSize.width / 2;\n                break;\n            }\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.TOP_RIGHT: {\n                x -= listSize.width;\n                break;\n            }\n        }\n        // y\n        switch (position) {\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.CENTER:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.LEFT: {\n                y -= listSize.height / 2;\n                break;\n            }\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_LEFT: {\n                y -= listSize.height;\n                break;\n            }\n        }\n        vel.attr('transform', `translate(${x}, ${y})`);\n    }\n}, {\n    Directions,\n    Positions: _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9saXN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDdUI7QUFJbEM7QUFJTzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sYUFBYSxxRUFBZTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0EsOERBQThELDRCQUE0QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdEQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7O0FBRWhCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLGdCQUFnQixvQ0FBb0M7QUFDcEQsZ0JBQWdCLGdCQUFnQjtBQUNoQyxnQkFBZ0IsMkJBQTJCLEVBQUUsK0RBQWM7QUFDM0QseUJBQXlCLDhDQUFJO0FBQzdCLGNBQWMsT0FBTyxFQUFFLG9FQUFZO0FBQ25DO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCLGlCQUFpQiw2REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCLGlCQUFpQiw2REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCLGlCQUFpQiw2REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCLGlCQUFpQiw2REFBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxFQUFFLElBQUksRUFBRTtBQUNuRDtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL2xpc3QubWpzPzVmNTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4uL2RpYS9IaWdobGlnaHRlclZpZXcubWpzJztcbmltcG9ydCB7XG4gICAgbm9ybWFsaXplU2lkZXMsXG4gICAgaXNFcXVhbCxcbn0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHtcbiAgICBQb3NpdGlvbnMsXG4gICAgZ2V0UmVjdFBvaW50LFxufSBmcm9tICcuLi91dGlsL2dldFJlY3RQb2ludC5tanMnO1xuXG5jb25zdCBEaXJlY3Rpb25zID0ge1xuICAgIFJPVzogJ3JvdycsXG4gICAgQ09MVU1OOiAnY29sdW1uJ1xufTtcblxuZXhwb3J0IGNvbnN0IGxpc3QgPSBIaWdobGlnaHRlclZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBNT1VOVEFCTEU6IHRydWUsXG4gICAgVVBEQVRFX0FUVFJJQlVURVM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMub3B0aW9ucy5hdHRyaWJ1dGVdO1xuICAgIH0sXG5cbiAgICBfcHJldkl0ZW1zOiBudWxsLFxuXG4gICAgaGlnaGxpZ2h0KGVsZW1lbnRWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50Vmlldy5tb2RlbDtcbiAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGUsIHNpemUgPSAyMCwgZ2FwID0gNSwgZGlyZWN0aW9uID0gRGlyZWN0aW9ucy5ST1cgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGUpIHRocm93IG5ldyBFcnJvcignTGlzdDogYXR0cmlidXRlIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTaXplID0gKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykgPyB7IHdpZHRoOiBzaXplLCBoZWlnaHQ6IHNpemUgfSA6IHNpemU7XG4gICAgICAgIGNvbnN0IGlzUm93RGlyZWN0aW9uID0gKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5ST1cpO1xuICAgICAgICBjb25zdCBpdGVtV2lkdGggPSBpc1Jvd0RpcmVjdGlvbiA/IG5vcm1hbGl6ZWRTaXplLndpZHRoIDogbm9ybWFsaXplZFNpemUuaGVpZ2h0O1xuICAgICAgICBsZXQgaXRlbXMgPSBlbGVtZW50LmdldChhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSBpdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBwcmV2SXRlbXMgPSB0aGlzLl9wcmV2SXRlbXMgfHwgW107XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb24gPSBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiBpc0VxdWFsKHByZXZJdGVtc1tpbmRleF0sIGl0ZW1zW2luZGV4XSkpO1xuICAgICAgICBpZiAocHJldkl0ZW1zLmxlbmd0aCAhPT0gaXRlbXMubGVuZ3RoIHx8IGNvbXBhcmlzb24uc29tZSh1bmNoYW5nZWQgPT4gIXVuY2hhbmdlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZFbHMgPSB0aGlzLnZlbC5jaGlsZHJlbigpO1xuICAgICAgICAgICAgY29uc3QgaXRlbXNFbHMgPSBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkVsID0gKGluZGV4IGluIHByZXZFbHMpID8gcHJldkVsc1tpbmRleF0ubm9kZSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmlzb25baW5kZXhdKSByZXR1cm4gcHJldkVsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1FbCA9IHRoaXMuY3JlYXRlTGlzdEl0ZW0oaXRlbSwgbm9ybWFsaXplZFNpemUsIHByZXZFbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtRWwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghKGl0ZW1FbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoJ0xpc3Q6IGl0ZW0gbXVzdCBiZSBhbiBTVkdFbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgaXRlbUVsLmRhdGFzZXQuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBpdGVtRWwuZGF0YXNldC5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiAoaXRlbVdpZHRoICsgZ2FwKTtcbiAgICAgICAgICAgICAgICBpdGVtRWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAoaXNSb3dEaXJlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgID8gYHRyYW5zbGF0ZSgke29mZnNldH0sIDApYFxuICAgICAgICAgICAgICAgICAgICA6IGB0cmFuc2xhdGUoMCwgJHtvZmZzZXR9KWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtRWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudmVsLmVtcHR5KCkuYXBwZW5kKGl0ZW1zRWxzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZJdGVtcyA9IGl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zQ291bnQgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IChpdGVtc0NvdW50ID09PSAwKVxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IChpdGVtc0NvdW50ICogaXRlbVdpZHRoICsgKGl0ZW1zQ291bnQgLSAxKSAqIGdhcCk7XG4gICAgICAgIGNvbnN0IGxpc3RTaXplID0gKGlzUm93RGlyZWN0aW9uKVxuICAgICAgICAgICAgPyB7IHdpZHRoOiBsZW5ndGgsIGhlaWdodDogbm9ybWFsaXplZFNpemUuaGVpZ2h0IH1cbiAgICAgICAgICAgIDogeyB3aWR0aDogbm9ybWFsaXplZFNpemUud2lkdGgsIGhlaWdodDogbGVuZ3RoIH07XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbihlbGVtZW50LCBsaXN0U2l6ZSk7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uKGVsZW1lbnQsIGxpc3RTaXplKSB7XG4gICAgICAgIGNvbnN0IHsgdmVsLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG1hcmdpbiA9IDUsIHBvc2l0aW9uID0gJ3RvcC1sZWZ0JyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBlbGVtZW50LnNpemUoKTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IG5vcm1hbGl6ZVNpZGVzKG1hcmdpbik7XG4gICAgICAgIGNvbnN0IGJib3ggPSBuZXcgUmVjdChsZWZ0LCB0b3AsIHdpZHRoIC0gKGxlZnQgKyByaWdodCksIGhlaWdodCAtICh0b3AgKyBib3R0b20pKTtcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gZ2V0UmVjdFBvaW50KGJib3gsIHBvc2l0aW9uKTtcbiAgICAgICAgLy8geFxuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5DRU5URVI6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5UT1A6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT006IHtcbiAgICAgICAgICAgICAgICB4IC09IGxpc3RTaXplLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLlJJR0hUOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NX1JJR0hUOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuVE9QX1JJR0hUOiB7XG4gICAgICAgICAgICAgICAgeCAtPSBsaXN0U2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB5XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkNFTlRFUjpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLlJJR0hUOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuTEVGVDoge1xuICAgICAgICAgICAgICAgIHkgLT0gbGlzdFNpemUuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTTpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTV9MRUZUOiB7XG4gICAgICAgICAgICAgICAgeSAtPSBsaXN0U2l6ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmVsLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgKTtcbiAgICB9XG59LCB7XG4gICAgRGlyZWN0aW9ucyxcbiAgICBQb3NpdGlvbnNcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/highlighters/list.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/highlighters/mask.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/mask.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mask: () => (/* binding */ mask)\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nconst mask = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray',\n        'class',\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'class',\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n        // support both `strokeWidth` and `stroke-width` attribute names\n        const strokeWidth = parseFloat((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('g').attr(attrs).attr('stroke-width'));\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const highlightMatrix = this.getNodeMatrix(cellView, node);\n        const maskEl = this.getMask(cellView, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(highlightMatrix),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9tYXNrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7QUFDOEI7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxhQUFhLHFFQUFlOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhLG9EQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFdBQVc7QUFDdEU7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQSxnQ0FBZ0Msb0RBQUM7QUFDakM7QUFDQSxvQ0FBb0Msd0RBQUM7QUFDckMsd0JBQXdCLGVBQWU7QUFDdkMsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQyxLQUFLOztBQUVMOztBQUVBLGdCQUFnQiw4QkFBOEI7QUFDOUMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLHVDQUF1Qyx3REFBQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0RBQUM7QUFDdkI7QUFDQTtBQUNBLGVBQWUsd0RBQUM7QUFDaEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLDhDQUE4QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFDO0FBQzFCLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9oaWdobGlnaHRlcnMvbWFzay5tanM/YTliZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5cbmNvbnN0IE1BU0tfQ0xJUCA9IDIwO1xuXG5mdW5jdGlvbiBmb3JFYWNoRGVzY2VuZGFudCh2ZWwsIGZuKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSB2ZWwuY2hpbGRyZW4oKTtcbiAgICB3aGlsZSAoZGVzY2VuZGFudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkZXNjZW5kYW50ID0gZGVzY2VuZGFudHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGZuKGRlc2NlbmRhbnQpKSB7XG4gICAgICAgICAgICBkZXNjZW5kYW50cy5wdXNoKC4uLmRlc2NlbmRhbnQuY2hpbGRyZW4oKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBtYXNrID0gSGlnaGxpZ2h0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgY2xhc3NOYW1lOiAnaGlnaGxpZ2h0LW1hc2snLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgfSxcblxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgbWFza0NsaXA6IE1BU0tfQ0xJUCxcbiAgICAgICAgZGVlcDogZmFsc2UsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnc3Ryb2tlJzogJyNGRUI2NjMnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDMsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAnYnV0dCcsXG4gICAgICAgICAgICAnc3Ryb2tlLWxpbmVqb2luJzogJ21pdGVyJyxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBWSVNJQkxFOiAnd2hpdGUnLFxuICAgIElOVklTSUJMRTogJ2JsYWNrJyxcblxuICAgIE1BU0tfUk9PVF9BVFRSSUJVVEVfQkxBQ0tMSVNUOiBbXG4gICAgICAgICdtYXJrZXItc3RhcnQnLFxuICAgICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAgICdtYXJrZXItbWlkJyxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICAgJ2NsYXNzJyxcbiAgICBdLFxuXG4gICAgTUFTS19DSElMRF9BVFRSSUJVVEVfQkxBQ0tMSVNUOiBbXG4gICAgICAgICdzdHJva2UnLFxuICAgICAgICAnZmlsbCcsXG4gICAgICAgICdzdHJva2Utd2lkdGgnLFxuICAgICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgICAgICdmaWxsLW9wYWNpdHknLFxuICAgICAgICAnbWFya2VyLXN0YXJ0JyxcbiAgICAgICAgJ21hcmtlci1lbmQnLFxuICAgICAgICAnbWFya2VyLW1pZCcsXG4gICAgICAgICdjbGFzcycsXG4gICAgXSxcblxuICAgIC8vIFRPRE86IGNoYW5nZSB0aGUgbGlzdCB0byBhIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAgTUFTS19SRVBMQUNFX1RBR1M6IFtcbiAgICAgICAgJ0ZPUkVJR05PQkpFQ1QnLFxuICAgICAgICAnSU1BR0UnLFxuICAgICAgICAnVVNFJyxcbiAgICAgICAgJ1RFWFQnLFxuICAgICAgICAnVFNQQU4nLFxuICAgICAgICAnVEVYVFBBVEgnXG4gICAgXSxcblxuICAgIC8vIFRPRE86IGNoYW5nZSB0aGUgbGlzdCB0byBhIGZ1bmN0aW9uIGNhbGxiYWNrXG4gICAgTUFTS19SRU1PVkVfVEFHUzogW1xuICAgICAgICAnVEVYVCcsXG4gICAgICAgICdUU1BBTicsXG4gICAgICAgICdURVhUUEFUSCdcbiAgICBdLFxuXG4gICAgdHJhbnNmb3JtTWFza0NoaWxkKGNlbGxWaWV3LCBjaGlsZEVsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIE1BU0tfQ0hJTERfQVRUUklCVVRFX0JMQUNLTElTVCxcbiAgICAgICAgICAgIE1BU0tfUkVQTEFDRV9UQUdTLFxuICAgICAgICAgICAgTUFTS19SRU1PVkVfVEFHU1xuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2hpbGRUYWdOYW1lID0gY2hpbGRFbC50YWdOYW1lKCk7XG4gICAgICAgIC8vIERvIG5vdCBpbmNsdWRlIHRoZSBlbGVtZW50IGluIHRoZSBtYXNrJ3MgaW1hZ2VcbiAgICAgICAgaWYgKCFWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KGNoaWxkRWwpIHx8IE1BU0tfUkVNT1ZFX1RBR1MuaW5jbHVkZXMoY2hpbGRUYWdOYW1lKSkge1xuICAgICAgICAgICAgY2hpbGRFbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBlbGVtZW50IHdpdGggYSByZWN0YW5nbGVcbiAgICAgICAgaWYgKE1BU0tfUkVQTEFDRV9UQUdTLmluY2x1ZGVzKGNoaWxkVGFnTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGNsb25lKCkgbWV0aG9kIGRvZXMgbm90IGNoYW5nZSB0aGUgY2hpbGRyZW4gaWRzXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbENoaWxkID0gY2VsbFZpZXcudmVsLmZpbmRPbmUoYCMke2NoaWxkRWwuaWR9YCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxDaGlsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZTogb3JpZ2luYWxOb2RlIH0gPSBvcmlnaW5hbENoaWxkO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZEJCb3ggPSBjZWxsVmlldy5nZXROb2RlQm91bmRpbmdSZWN0KG9yaWdpbmFsTm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxWaWV3Lm1vZGVsLmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IFYudHJhbnNmb3JtUmVjdChjaGlsZEJCb3gsIGNlbGxWaWV3LmdldE5vZGVNYXRyaXgob3JpZ2luYWxOb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gVigncmVjdCcsIGNoaWxkQkJveC50b0pTT04oKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiBveCwgeTogb3kgfSA9IGNoaWxkQkJveC5jZW50ZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFuZ2xlLCBjeCA9IG94LCBjeSA9IG95IH0gPSBvcmlnaW5hbENoaWxkLnJvdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChhbmdsZSkgcmVwbGFjZW1lbnQucm90YXRlKGFuZ2xlLCBjeCwgY3kpO1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGl0J3Mgbm90IGltcG9ydGFudCB0byBrZWVwIHRoZSBzYW1lIHNpYmxpbmcgaW5kZXggc2luY2UgYWxsIHN1Ym5vZGVzIGFyZSBmaWxsZWRcbiAgICAgICAgICAgICAgICBjaGlsZEVsLnBhcmVudCgpLmFwcGVuZChyZXBsYWNlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZEVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgdGhlIGVsZW1lbnQsIGJ1dCBjbGVhbiBpdCBmcm9tIGNlcnRhaW4gYXR0cmlidXRlc1xuICAgICAgICBNQVNLX0NISUxEX0FUVFJJQlVURV9CTEFDS0xJU1QuZm9yRWFjaChhdHRyTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgPT09ICdmaWxsJyAmJiBjaGlsZEVsLmF0dHIoJ2ZpbGwnKSA9PT0gJ25vbmUnKSByZXR1cm47XG4gICAgICAgICAgICBjaGlsZEVsLnJlbW92ZUF0dHIoYXR0ck5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybU1hc2tSb290KF9jZWxsVmlldywgcm9vdEVsKSB7XG4gICAgICAgIGNvbnN0IHsgTUFTS19ST09UX0FUVFJJQlVURV9CTEFDS0xJU1QgfSA9IHRoaXM7XG4gICAgICAgIE1BU0tfUk9PVF9BVFRSSUJVVEVfQkxBQ0tMSVNULmZvckVhY2goYXR0ck5hbWUgPT4ge1xuICAgICAgICAgICAgcm9vdEVsLnJlbW92ZUF0dHIoYXR0ck5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0TWFza1NoYXBlKGNlbGxWaWV3LCB2ZWwpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCBNQVNLX1JFUExBQ0VfVEFHUyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBkZWVwIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gdmVsLnRhZ05hbWUoKTtcbiAgICAgICAgbGV0IG1hc2tSb290O1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ0cnKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbWFza1Jvb3QgPSB2ZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGZvckVhY2hEZXNjZW5kYW50KG1hc2tSb290LCBtYXNrQ2hpbGQgPT4gdGhpcy50cmFuc2Zvcm1NYXNrQ2hpbGQoY2VsbFZpZXcsIG1hc2tDaGlsZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE1BU0tfUkVQTEFDRV9UQUdTLmluY2x1ZGVzKHRhZ05hbWUpKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIG1hc2tSb290ID0gdmVsLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXNrUm9vdChjZWxsVmlldywgbWFza1Jvb3QpO1xuICAgICAgICByZXR1cm4gbWFza1Jvb3Q7XG4gICAgfSxcblxuICAgIGdldE1hc2tJZCgpIHtcbiAgICAgICAgcmV0dXJuIGBoaWdobGlnaHQtbWFzay0ke3RoaXMuY2lkfWA7XG4gICAgfSxcblxuICAgIGdldE1hc2soY2VsbFZpZXcsIHZOb2RlKSB7XG5cbiAgICAgICAgY29uc3QgeyBWSVNJQkxFLCBJTlZJU0lCTEUsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGFkZGluZywgYXR0cnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHN1cHBvcnQgYm90aCBgc3Ryb2tlV2lkdGhgIGFuZCBgc3Ryb2tlLXdpZHRoYCBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBwYXJzZUZsb2F0KFYoJ2cnKS5hdHRyKGF0dHJzKS5hdHRyKCdzdHJva2Utd2lkdGgnKSk7XG4gICAgICAgIGNvbnN0IGhhc05vZGVGaWxsID0gdk5vZGUuYXR0cignZmlsbCcpICE9PSAnbm9uZSc7XG4gICAgICAgIGxldCBtYWduZXRTdHJva2VXaWR0aCA9IHBhcnNlRmxvYXQodk5vZGUuYXR0cignc3Ryb2tlLXdpZHRoJykpO1xuICAgICAgICBpZiAoaXNOYU4obWFnbmV0U3Ryb2tlV2lkdGgpKSBtYWduZXRTdHJva2VXaWR0aCA9IDE7XG4gICAgICAgIC8vIHN0cm9rZSBvZiB0aGUgaW52aXNpYmxlIHNoYXBlXG4gICAgICAgIGNvbnN0IG1pblN0cm9rZVdpZHRoID0gbWFnbmV0U3Ryb2tlV2lkdGggKyBwYWRkaW5nICogMjtcbiAgICAgICAgLy8gc3Ryb2tlIG9mIHRoZSB2aXNpYmxlIHNoYXBlXG4gICAgICAgIGNvbnN0IG1heFN0cm9rZVdpZHRoID0gbWluU3Ryb2tlV2lkdGggKyBzdHJva2VXaWR0aCAqIDI7XG4gICAgICAgIGxldCBtYXNrRWwgPSB0aGlzLmdldE1hc2tTaGFwZShjZWxsVmlldywgdk5vZGUpO1xuICAgICAgICBpZiAoIW1hc2tFbCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZUJCb3ggPSBjZWxsVmlldy5nZXROb2RlQm91bmRpbmdSZWN0KHZOb2RlLm5vZGUpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZWN0IGlzIHZpc2libGVcbiAgICAgICAgICAgIG5vZGVCQm94LmluZmxhdGUobm9kZUJCb3gud2lkdGggPyAwIDogMC41LCBub2RlQkJveC5oZWlnaHQgPyAwIDogMC41KTtcbiAgICAgICAgICAgIG1hc2tFbCA9ICBWKCdyZWN0Jywgbm9kZUJCb3gudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIG1hc2tFbC5hdHRyKGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIFYoJ21hc2snLCB7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLmdldE1hc2tJZCgpXG4gICAgICAgIH0pLmFwcGVuZChbXG4gICAgICAgICAgICBtYXNrRWwuY2xvbmUoKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbCc6IGhhc05vZGVGaWxsID8gVklTSUJMRSA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogVklTSUJMRSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogbWF4U3Ryb2tlV2lkdGhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFza0VsLmNsb25lKCkuYXR0cih7XG4gICAgICAgICAgICAgICAgJ2ZpbGwnOiBoYXNOb2RlRmlsbCA/IElOVklTSUJMRSA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogSU5WSVNJQkxFLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBtaW5TdHJva2VXaWR0aFxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSk7XG4gICAgfSxcblxuICAgIHJlbW92ZU1hc2socGFwZXIpIHtcbiAgICAgICAgY29uc3QgbWFza05vZGUgPSBwYXBlci5zdmcuZ2V0RWxlbWVudEJ5SWQodGhpcy5nZXRNYXNrSWQoKSk7XG4gICAgICAgIGlmIChtYXNrTm9kZSkge1xuICAgICAgICAgICAgcGFwZXIuZGVmcy5yZW1vdmVDaGlsZChtYXNrTm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkTWFzayhwYXBlciwgbWFza0VsKSB7XG4gICAgICAgIHBhcGVyLmRlZnMuYXBwZW5kQ2hpbGQobWFza0VsLm5vZGUpO1xuICAgIH0sXG5cbiAgICBoaWdobGlnaHQoY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCB2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGFkZGluZywgYXR0cnMsIG1hc2tDbGlwID0gTUFTS19DTElQLCBsYXllciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY29sb3IgPSAoJ3N0cm9rZScgaW4gYXR0cnMpID8gYXR0cnNbJ3N0cm9rZSddIDogJyMwMDAwMDAnO1xuICAgICAgICBpZiAoIWxheWVyICYmIG5vZGUgPT09IGNlbGxWaWV3LmVsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaGlnaGxpZ2h0ZXIgaXMgYXBwZW5kZWQgdG8gdGhlIGNlbGxWaWV3XG4gICAgICAgICAgICAvLyBhbmQgd2UgbWVhc3VyZSB0aGUgc2l6ZSBvZiB0aGUgY2VsbFZpZXcgd3JhcHBpbmcgZ3JvdXBcbiAgICAgICAgICAgIC8vIGl0J3MgbmVjZXNzYXJ5IHRvIHJlbW92ZSB0aGUgaGlnaGxpZ2h0ZXIgZmlyc3RcbiAgICAgICAgICAgIHZlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaWdobGlnaHRlckJCb3ggPSBjZWxsVmlldy5nZXROb2RlQm91bmRpbmdSZWN0KG5vZGUpLmluZmxhdGUocGFkZGluZyArIG1hc2tDbGlwKTtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0TWF0cml4ID0gdGhpcy5nZXROb2RlTWF0cml4KGNlbGxWaWV3LCBub2RlKTtcbiAgICAgICAgY29uc3QgbWFza0VsID0gdGhpcy5nZXRNYXNrKGNlbGxWaWV3LCBWKG5vZGUpKTtcbiAgICAgICAgdGhpcy5hZGRNYXNrKGNlbGxWaWV3LnBhcGVyLCBtYXNrRWwpO1xuICAgICAgICB2ZWwuYXR0cihoaWdobGlnaHRlckJCb3gudG9KU09OKCkpO1xuICAgICAgICB2ZWwuYXR0cih7XG4gICAgICAgICAgICAndHJhbnNmb3JtJzogVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyhoaWdobGlnaHRNYXRyaXgpLFxuICAgICAgICAgICAgJ21hc2snOiBgdXJsKCMke21hc2tFbC5pZH0pYCxcbiAgICAgICAgICAgICdmaWxsJzogY29sb3JcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHVuaGlnaGxpZ2h0KGNlbGxWaWV3KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTWFzayhjZWxsVmlldy5wYXBlcik7XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/highlighters/mask.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/highlighters/opacity.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/opacity.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   opacity: () => (/* binding */ opacity)\n/* harmony export */ });\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\nconst opacity = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    highlight: function(_cellView, node) {\n        const { alphaValue = 0.3 } = this.options;\n        node.style.opacity = alphaValue;\n    },\n\n    unhighlight: function(_cellView, node) {\n        node.style.opacity = '';\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9vcGFjaXR5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RDs7QUFFdEQsZ0JBQWdCLHFFQUFlOztBQUV0QztBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9oaWdobGlnaHRlcnMvb3BhY2l0eS5tanM/YmQwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBvcGFjaXR5ID0gSGlnaGxpZ2h0ZXJWaWV3LmV4dGVuZCh7XG5cbiAgICBVUERBVEFCTEU6IGZhbHNlLFxuICAgIE1PVU5UQUJMRTogZmFsc2UsXG5cbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKF9jZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IGFscGhhVmFsdWUgPSAwLjMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gYWxwaGFWYWx1ZTtcbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQ6IGZ1bmN0aW9uKF9jZWxsVmlldywgbm9kZSkge1xuICAgICAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/highlighters/opacity.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/highlighters/stroke.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/stroke.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stroke: () => (/* binding */ stroke)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\n\nconst stroke = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    tagName: 'path',\n    className: 'highlight-stroke',\n    attributes: {\n        'pointer-events': 'none',\n        'fill': 'none'\n    },\n\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            'stroke-width': 3,\n            'stroke': '#FEB663'\n        }\n    },\n\n    getPathData(cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rectToPath((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n\n    highlightConnection(cellView) {\n        this.vel.attr('d', cellView.getSerializedConnection());\n    },\n\n    highlightNode(cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = this.getNodeMatrix(cellView, node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + (nodeBBox.width / 2);\n            const cy = nodeBBox.y + (nodeBBox.height / 2);\n            nodeBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            'd': this.getPathData(cellView, node),\n            'transform': _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(highlightMatrix)\n        });\n    },\n\n    highlight(cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (options.nonScalingStroke) {\n            vel.attr('vector-effect', 'non-scaling-stroke');\n        }\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9zdHJva2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMkM7QUFDWjtBQUM4Qjs7QUFFdEQsZUFBZSxxRUFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBLDBCQUEwQix3REFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQUMsWUFBWSx1REFBTSxHQUFHO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQUM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0RBQUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9EQUFDO0FBQzFCLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL3N0cm9rZS5tanM/MWYzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBIaWdobGlnaHRlclZpZXcgfSBmcm9tICcuLi9kaWEvSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBzdHJva2UgPSBIaWdobGlnaHRlclZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICBjbGFzc05hbWU6ICdoaWdobGlnaHQtc3Ryb2tlJyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJyxcbiAgICAgICAgJ2ZpbGwnOiAnbm9uZSdcbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiAzLFxuICAgICAgICByeDogMCxcbiAgICAgICAgcnk6IDAsXG4gICAgICAgIHVzZUZpcnN0U3VicGF0aDogZmFsc2UsXG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMyxcbiAgICAgICAgICAgICdzdHJva2UnOiAnI0ZFQjY2MydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQYXRoRGF0YShjZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdXNlRmlyc3RTdWJwYXRoIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZOb2RlID0gVihub2RlKTtcbiAgICAgICAgICAgIGQgPSB2Tm9kZS5jb252ZXJ0VG9QYXRoRGF0YSgpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICh2Tm9kZS50YWdOYW1lKCkgPT09ICdQQVRIJyAmJiB1c2VGaXJzdFN1YnBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmRTdWJwYXRoSW5kZXggPSBkLnNlYXJjaCgvLk0vaSkgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChzZWNvbmRTdWJwYXRoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkLnN1YnN0cigwLCBzZWNvbmRTdWJwYXRoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEZhaWxlZCB0byBnZXQgcGF0aCBkYXRhIGZyb20gbWFnbmV0IGVsZW1lbnQuXG4gICAgICAgICAgICAvLyBEcmF3IGEgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgbm9kZSBpbnN0ZWFkLlxuICAgICAgICAgICAgY29uc3Qgbm9kZUJCb3ggPSBjZWxsVmlldy5nZXROb2RlQm91bmRpbmdSZWN0KG5vZGUpO1xuICAgICAgICAgICAgZCA9IFYucmVjdFRvUGF0aChhc3NpZ24oe30sIG9wdGlvbnMsIG5vZGVCQm94LnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodENvbm5lY3Rpb24oY2VsbFZpZXcpIHtcbiAgICAgICAgdGhpcy52ZWwuYXR0cignZCcsIGNlbGxWaWV3LmdldFNlcmlhbGl6ZWRDb25uZWN0aW9uKCkpO1xuICAgIH0sXG5cbiAgICBoaWdobGlnaHROb2RlKGNlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgdmVsLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHBhZGRpbmcsIGxheWVyIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgaGlnaGxpZ2h0TWF0cml4ID0gdGhpcy5nZXROb2RlTWF0cml4KGNlbGxWaWV3LCBub2RlKTtcbiAgICAgICAgLy8gQWRkIHBhZGRpbmcgdG8gdGhlIGhpZ2hsaWdodCBlbGVtZW50LlxuICAgICAgICBpZiAocGFkZGluZykge1xuICAgICAgICAgICAgaWYgKCFsYXllciAmJiBub2RlID09PSBjZWxsVmlldy5lbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoaWdobGlnaHRlciBpcyBhcHBlbmRlZCB0byB0aGUgY2VsbFZpZXdcbiAgICAgICAgICAgICAgICAvLyBhbmQgd2UgbWVhc3VyZSB0aGUgc2l6ZSBvZiB0aGUgY2VsbFZpZXcgd3JhcHBpbmcgZ3JvdXBcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5lY2Vzc2FyeSB0byByZW1vdmUgdGhlIGhpZ2hsaWdodGVyIGZpcnN0XG4gICAgICAgICAgICAgICAgdmVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5vZGVCQm94ID0gY2VsbFZpZXcuZ2V0Tm9kZUJvdW5kaW5nUmVjdChub2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGN4ID0gbm9kZUJCb3gueCArIChub2RlQkJveC53aWR0aCAvIDIpO1xuICAgICAgICAgICAgY29uc3QgY3kgPSBub2RlQkJveC55ICsgKG5vZGVCQm94LmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgbm9kZUJCb3ggPSBWLnRyYW5zZm9ybVJlY3Qobm9kZUJCb3gsIGhpZ2hsaWdodE1hdHJpeCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KG5vZGVCQm94LndpZHRoLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KG5vZGVCQm94LmhlaWdodCwgMSk7XG4gICAgICAgICAgICBjb25zdCBzeCA9ICh3aWR0aCArIHBhZGRpbmcpIC8gd2lkdGg7XG4gICAgICAgICAgICBjb25zdCBzeSA9IChoZWlnaHQgKyBwYWRkaW5nKSAvIGhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmdNYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCh7XG4gICAgICAgICAgICAgICAgYTogc3gsXG4gICAgICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgICAgIGQ6IHN5LFxuICAgICAgICAgICAgICAgIGU6IGN4IC0gc3ggKiBjeCxcbiAgICAgICAgICAgICAgICBmOiBjeSAtIHN5ICogY3lcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGlnaGxpZ2h0TWF0cml4ID0gaGlnaGxpZ2h0TWF0cml4Lm11bHRpcGx5KHBhZGRpbmdNYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIHZlbC5hdHRyKHtcbiAgICAgICAgICAgICdkJzogdGhpcy5nZXRQYXRoRGF0YShjZWxsVmlldywgbm9kZSksXG4gICAgICAgICAgICAndHJhbnNmb3JtJzogVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyhoaWdobGlnaHRNYXRyaXgpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBoaWdobGlnaHQoY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyB2ZWwsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHZlbC5hdHRyKG9wdGlvbnMuYXR0cnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5ub25TY2FsaW5nU3Ryb2tlKSB7XG4gICAgICAgICAgICB2ZWwuYXR0cigndmVjdG9yLWVmZmVjdCcsICdub24tc2NhbGluZy1zdHJva2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2VsbFZpZXcuaXNOb2RlQ29ubmVjdGlvbihub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb25uZWN0aW9uKGNlbGxWaWV3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0Tm9kZShjZWxsVmlldywgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/highlighters/stroke.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/layout/ports/port.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/layout/ports/port.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolute: () => (/* binding */ absolute),\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   ellipse: () => (/* binding */ ellipse),\n/* harmony export */   ellipseSpread: () => (/* binding */ ellipseSpread),\n/* harmony export */   fn: () => (/* binding */ fn),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   line: () => (/* binding */ line),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   top: () => (/* binding */ top)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/calc.mjs\");\n\n\n\nfunction portTransformAttrs(point, angle, opt) {\n\n    var trans = point.toJSON();\n\n    trans.angle = angle || 0;\n\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, trans);\n}\n\nfunction lineLayout(ports, p1, p2, elBBox) {\n    return ports.map(function(port, index, ports) {\n        var p = this.pointAt(((index + 0.5) / ports.length));\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p.offset(port.dx || 0, port.dy || 0);\n        }\n        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n    }, _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2));\n}\n\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n    var center = elBBox.center();\n    var ratio = elBBox.width / elBBox.height;\n    var p1 = elBBox.topMiddle();\n\n    var ellipse = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse.fromRect(elBBox);\n\n    return ports.map(function(port, index, ports) {\n\n        var angle = startAngle + stepFn(index, ports.length);\n        var p2 = p1.clone()\n            .rotate(center, -angle)\n            .scale(ratio, 1, center);\n\n        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p2.offset(port.dx || 0, port.dy || 0);\n        }\n\n        // `dr` delta radius option\n        if (port.dr) {\n            p2.move(center, port.dr);\n        }\n\n        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n    });\n}\n\n\nfunction argTransform(bbox, args) {\n    let { x, y, angle } = args;\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage(x)) {\n        x = parseFloat(x) / 100 * bbox.width;\n    } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression(x)) {\n        x = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression(x, bbox));\n    }\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage(y)) {\n        y = parseFloat(y) / 100 * bbox.height;\n    } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression(y)) {\n        y = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression(y, bbox));\n    }\n    return { x, y, angle };\n}\n\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n    const { x, y } = argTransform(bbox, args);\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(x || 0, y || 0);\n}\n\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst absolute = function(ports, elBBox) {\n    return ports.map(port => {\n        const transformation = argPoint(elBBox, port).round().toJSON();\n        transformation.angle = port.angle || 0;\n        return transformation;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst fn = function(ports, elBBox, opt) {\n    return opt.fn(ports, elBBox, opt);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst line = function(ports, elBBox, opt) {\n\n    var start = argPoint(elBBox, opt.start || elBBox.origin());\n    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n    return lineLayout(ports, start, end, elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst left = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst right = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst top = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst bottom = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nconst ellipseSpread = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 360 / ports.length;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n        return index * stepAngle;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nconst ellipse = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 20;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n        return (index + 0.5 - count / 2) * stepAngle;\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xheW91dC9wb3J0cy9wb3J0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDTTs7QUFFN0M7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxxREFBYSxHQUFHO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsOENBQU07QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlEQUFTOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSxVQUFVLGNBQWM7QUFDeEIsUUFBUSx5REFBaUI7QUFDekI7QUFDQSxNQUFNLFNBQVMsNkRBQXFCO0FBQ3BDLG1CQUFtQiwrREFBdUI7QUFDMUM7QUFDQSxRQUFRLHlEQUFpQjtBQUN6QjtBQUNBLE1BQU0sU0FBUyw2REFBcUI7QUFDcEMsbUJBQW1CLCtEQUF1QjtBQUMxQztBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGVBQWUsK0NBQU87QUFDdEI7OztBQUdBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xheW91dC9wb3J0cy9wb3J0Lm1qcz80MWE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIHBvcnRUcmFuc2Zvcm1BdHRycyhwb2ludCwgYW5nbGUsIG9wdCkge1xuXG4gICAgdmFyIHRyYW5zID0gcG9pbnQudG9KU09OKCk7XG5cbiAgICB0cmFucy5hbmdsZSA9IGFuZ2xlIHx8IDA7XG5cbiAgICByZXR1cm4gdXRpbC5kZWZhdWx0cyh7fSwgb3B0LCB0cmFucyk7XG59XG5cbmZ1bmN0aW9uIGxpbmVMYXlvdXQocG9ydHMsIHAxLCBwMiwgZWxCQm94KSB7XG4gICAgcmV0dXJuIHBvcnRzLm1hcChmdW5jdGlvbihwb3J0LCBpbmRleCwgcG9ydHMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBvaW50QXQoKChpbmRleCArIDAuNSkgLyBwb3J0cy5sZW5ndGgpKTtcbiAgICAgICAgLy8gYGR4YCxgZHlgIHBlciBwb3J0IG9mZnNldCBvcHRpb25cbiAgICAgICAgaWYgKHBvcnQuZHggfHwgcG9ydC5keSkge1xuICAgICAgICAgICAgcC5vZmZzZXQocG9ydC5keCB8fCAwLCBwb3J0LmR5IHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3J0VHJhbnNmb3JtQXR0cnMocC5yb3VuZCgpLCAwLCBhcmdUcmFuc2Zvcm0oZWxCQm94LCBwb3J0KSk7XG4gICAgfSwgZy5saW5lKHAxLCBwMikpO1xufVxuXG5mdW5jdGlvbiBlbGxpcHNlTGF5b3V0KHBvcnRzLCBlbEJCb3gsIHN0YXJ0QW5nbGUsIHN0ZXBGbikge1xuXG4gICAgdmFyIGNlbnRlciA9IGVsQkJveC5jZW50ZXIoKTtcbiAgICB2YXIgcmF0aW8gPSBlbEJCb3gud2lkdGggLyBlbEJCb3guaGVpZ2h0O1xuICAgIHZhciBwMSA9IGVsQkJveC50b3BNaWRkbGUoKTtcblxuICAgIHZhciBlbGxpcHNlID0gZy5FbGxpcHNlLmZyb21SZWN0KGVsQkJveCk7XG5cbiAgICByZXR1cm4gcG9ydHMubWFwKGZ1bmN0aW9uKHBvcnQsIGluZGV4LCBwb3J0cykge1xuXG4gICAgICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGUgKyBzdGVwRm4oaW5kZXgsIHBvcnRzLmxlbmd0aCk7XG4gICAgICAgIHZhciBwMiA9IHAxLmNsb25lKClcbiAgICAgICAgICAgIC5yb3RhdGUoY2VudGVyLCAtYW5nbGUpXG4gICAgICAgICAgICAuc2NhbGUocmF0aW8sIDEsIGNlbnRlcik7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gcG9ydC5jb21wZW5zYXRlUm90YXRpb24gPyAtZWxsaXBzZS50YW5nZW50VGhldGEocDIpIDogMDtcblxuICAgICAgICAvLyBgZHhgLGBkeWAgcGVyIHBvcnQgb2Zmc2V0IG9wdGlvblxuICAgICAgICBpZiAocG9ydC5keCB8fCBwb3J0LmR5KSB7XG4gICAgICAgICAgICBwMi5vZmZzZXQocG9ydC5keCB8fCAwLCBwb3J0LmR5IHx8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYGRyYCBkZWx0YSByYWRpdXMgb3B0aW9uXG4gICAgICAgIGlmIChwb3J0LmRyKSB7XG4gICAgICAgICAgICBwMi5tb3ZlKGNlbnRlciwgcG9ydC5kcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9ydFRyYW5zZm9ybUF0dHJzKHAyLnJvdW5kKCksIHRoZXRhLCBhcmdUcmFuc2Zvcm0oZWxCQm94LCBwb3J0KSk7XG4gICAgfSk7XG59XG5cblxuZnVuY3Rpb24gYXJnVHJhbnNmb3JtKGJib3gsIGFyZ3MpIHtcbiAgICBsZXQgeyB4LCB5LCBhbmdsZSB9ID0gYXJncztcbiAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoeCkpIHtcbiAgICAgICAgeCA9IHBhcnNlRmxvYXQoeCkgLyAxMDAgKiBiYm94LndpZHRoO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc0NhbGNFeHByZXNzaW9uKHgpKSB7XG4gICAgICAgIHggPSBOdW1iZXIodXRpbC5ldmFsQ2FsY0V4cHJlc3Npb24oeCwgYmJveCkpO1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoeSkpIHtcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoeSkgLyAxMDAgKiBiYm94LmhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNDYWxjRXhwcmVzc2lvbih5KSkge1xuICAgICAgICB5ID0gTnVtYmVyKHV0aWwuZXZhbENhbGNFeHByZXNzaW9uKHksIGJib3gpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgeCwgeSwgYW5nbGUgfTtcbn1cblxuLy8gQ3JlYXRlcyBhIHBvaW50IHN0b3JlZCBpbiBhcmd1bWVudHNcbmZ1bmN0aW9uIGFyZ1BvaW50KGJib3gsIGFyZ3MpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IGFyZ1RyYW5zZm9ybShiYm94LCBhcmdzKTtcbiAgICByZXR1cm4gbmV3IGcuUG9pbnQoeCB8fCAwLCB5IHx8IDApO1xufVxuXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgb3B0IEdyb3VwIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheTxnLlBvaW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFic29sdXRlID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCkge1xuICAgIHJldHVybiBwb3J0cy5tYXAocG9ydCA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gYXJnUG9pbnQoZWxCQm94LCBwb3J0KS5yb3VuZCgpLnRvSlNPTigpO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbi5hbmdsZSA9IHBvcnQuYW5nbGUgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgZm4gPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gb3B0LmZuKHBvcnRzLCBlbEJCb3gsIG9wdCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBsaW5lID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG5cbiAgICB2YXIgc3RhcnQgPSBhcmdQb2ludChlbEJCb3gsIG9wdC5zdGFydCB8fCBlbEJCb3gub3JpZ2luKCkpO1xuICAgIHZhciBlbmQgPSBhcmdQb2ludChlbEJCb3gsIG9wdC5lbmQgfHwgZWxCQm94LmNvcm5lcigpKTtcblxuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBzdGFydCwgZW5kLCBlbEJCb3gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgbGVmdCA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBlbEJCb3gub3JpZ2luKCksIGVsQkJveC5ib3R0b21MZWZ0KCksIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCByaWdodCA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBlbEJCb3gudG9wUmlnaHQoKSwgZWxCQm94LmNvcm5lcigpLCBlbEJCb3gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgdG9wID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxpbmVMYXlvdXQocG9ydHMsIGVsQkJveC5vcmlnaW4oKSwgZWxCQm94LnRvcFJpZ2h0KCksIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBib3R0b20gPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGluZUxheW91dChwb3J0cywgZWxCQm94LmJvdHRvbUxlZnQoKSwgZWxCQm94LmNvcm5lcigpLCBlbEJCb3gpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBlbGxpcHNlU3ByZWFkID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG5cbiAgICB2YXIgc3RhcnRBbmdsZSA9IG9wdC5zdGFydEFuZ2xlIHx8IDA7XG4gICAgdmFyIHN0ZXBBbmdsZSA9IG9wdC5zdGVwIHx8IDM2MCAvIHBvcnRzLmxlbmd0aDtcblxuICAgIHJldHVybiBlbGxpcHNlTGF5b3V0KHBvcnRzLCBlbEJCb3gsIHN0YXJ0QW5nbGUsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCAqIHN0ZXBBbmdsZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgZWxsaXBzZSA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuXG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBvcHQuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHZhciBzdGVwQW5nbGUgPSBvcHQuc3RlcCB8fCAyMDtcblxuICAgIHJldHVybiBlbGxpcHNlTGF5b3V0KHBvcnRzLCBlbEJCb3gsIHN0YXJ0QW5nbGUsIGZ1bmN0aW9uKGluZGV4LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gKGluZGV4ICsgMC41IC0gY291bnQgLyAyKSAqIHN0ZXBBbmdsZTtcbiAgICB9KTtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/layout/ports/port.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@joint/core/src/layout/ports/portLabel.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: () => (/* binding */ bottom),\n/* harmony export */   inside: () => (/* binding */ inside),\n/* harmony export */   insideOriented: () => (/* binding */ insideOriented),\n/* harmony export */   left: () => (/* binding */ left),\n/* harmony export */   manual: () => (/* binding */ manual),\n/* harmony export */   outside: () => (/* binding */ outside),\n/* harmony export */   outsideOriented: () => (/* binding */ outsideOriented),\n/* harmony export */   radial: () => (/* binding */ radial),\n/* harmony export */   radialOriented: () => (/* binding */ radialOriented),\n/* harmony export */   right: () => (/* binding */ right),\n/* harmony export */   top: () => (/* binding */ top)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\nfunction labelAttributes(opt1, opt2) {\n\n    // use value from `opt2` if it is missing in `opt1`\n    // use value from this object if it is missing in `opt2` as well\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep({}, opt1, opt2, {\n        x: 0,\n        y: 0,\n        angle: 0,\n        attrs: {}\n    });\n}\n\nfunction getBBoxAngles(elBBox) {\n\n    var center = elBBox.center();\n\n    var tl = center.theta(elBBox.origin());\n    var bl = center.theta(elBBox.bottomLeft());\n    var br = center.theta(elBBox.corner());\n    var tr = center.theta(elBBox.topRight());\n\n    return [tl, tr, br, bl];\n}\n\nfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, { offset: 20 });\n\n    var origin = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.point(0, 0);\n    var angle = -portCenterOffset.theta(origin);\n    var orientAngle = angle;\n    var offset = portCenterOffset.clone()\n        .move(origin, opt.offset)\n        .difference(portCenterOffset)\n        .round();\n\n    var y = '.3em';\n    var textAnchor;\n\n    if ((angle + 90) % 180 === 0) {\n        textAnchor = autoOrient ? 'end' : 'middle';\n        if (!autoOrient && angle === -270) {\n            y = '0em';\n        }\n    } else if (angle > -270 && angle < -90) {\n        textAnchor = 'start';\n        orientAngle = angle - 180;\n    } else {\n        textAnchor = 'end';\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(offset.x),\n        y: round(offset.y),\n        angle: ((autoOrient) ? orientAngle : 0),\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nconst manual = function(_portPosition, _elBBox, opt) {\n    return labelAttributes(opt);\n};\n\nconst left = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: -15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'end' }},\n    });\n};\n\nconst right = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: 15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'start' }},\n    });\n};\n\nconst top = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: -15,\n        attrs: { labelText: { y: '0', textAnchor: 'middle' }},\n    });\n};\n\nconst bottom = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: 15,\n        attrs: { labelText: { y: '.6em', textAnchor: 'middle' }},\n    });\n};\n\nconst outsideOriented = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, true, opt);\n};\n\nconst outside = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, false, opt);\n};\n\nconst insideOriented = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, true, opt);\n};\n\nconst inside = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, false, opt);\n};\n\nconst radial = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n};\n\nconst radialOriented = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xheW91dC9wb3J0cy9wb3J0TGFiZWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDTTs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBLFdBQVcseURBQWlCLEdBQUc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLHFEQUFhLEdBQUcsU0FBUyxZQUFZO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxVQUFVLHFEQUFhLEdBQUcsU0FBUyxZQUFZO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxVQUFVLHFEQUFhLEdBQUcsU0FBUyxZQUFZOztBQUUvQyxpQkFBaUIsK0NBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCLEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEsK0JBQStCO0FBQzdELEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYSxpQ0FBaUM7QUFDL0QsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixhQUFhLCtCQUErQjtBQUM3RCxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEsa0NBQWtDO0FBQ2hFLEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xheW91dC9wb3J0cy9wb3J0TGFiZWwubWpzPzA4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi8uLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uLy4uL3V0aWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gbGFiZWxBdHRyaWJ1dGVzKG9wdDEsIG9wdDIpIHtcblxuICAgIC8vIHVzZSB2YWx1ZSBmcm9tIGBvcHQyYCBpZiBpdCBpcyBtaXNzaW5nIGluIGBvcHQxYFxuICAgIC8vIHVzZSB2YWx1ZSBmcm9tIHRoaXMgb2JqZWN0IGlmIGl0IGlzIG1pc3NpbmcgaW4gYG9wdDJgIGFzIHdlbGxcbiAgICByZXR1cm4gdXRpbC5kZWZhdWx0c0RlZXAoe30sIG9wdDEsIG9wdDIsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgIGF0dHJzOiB7fVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRCQm94QW5nbGVzKGVsQkJveCkge1xuXG4gICAgdmFyIGNlbnRlciA9IGVsQkJveC5jZW50ZXIoKTtcblxuICAgIHZhciB0bCA9IGNlbnRlci50aGV0YShlbEJCb3gub3JpZ2luKCkpO1xuICAgIHZhciBibCA9IGNlbnRlci50aGV0YShlbEJCb3guYm90dG9tTGVmdCgpKTtcbiAgICB2YXIgYnIgPSBjZW50ZXIudGhldGEoZWxCQm94LmNvcm5lcigpKTtcbiAgICB2YXIgdHIgPSBjZW50ZXIudGhldGEoZWxCQm94LnRvcFJpZ2h0KCkpO1xuXG4gICAgcmV0dXJuIFt0bCwgdHIsIGJyLCBibF07XG59XG5cbmZ1bmN0aW9uIG91dHNpZGVMYXlvdXQocG9ydFBvc2l0aW9uLCBlbEJCb3gsIGF1dG9PcmllbnQsIG9wdCkge1xuXG4gICAgb3B0ID0gdXRpbC5kZWZhdWx0cyh7fSwgb3B0LCB7IG9mZnNldDogMTUgfSk7XG4gICAgdmFyIGFuZ2xlID0gZWxCQm94LmNlbnRlcigpLnRoZXRhKHBvcnRQb3NpdGlvbik7XG5cbiAgICB2YXIgdHgsIHR5LCB5LCB0ZXh0QW5jaG9yO1xuICAgIHZhciBvZmZzZXQgPSBvcHQub2Zmc2V0O1xuICAgIHZhciBvcmllbnRBbmdsZSA9IDA7XG5cbiAgICBjb25zdCBbdG9wTGVmdEFuZ2xlLCBib3R0b21MZWZ0QW5nbGUsIGJvdHRvbVJpZ2h0QW5nbGUsIHRvcFJpZ2h0QW5nbGVdID0gZ2V0QkJveEFuZ2xlcyhlbEJCb3gpO1xuICAgIGlmICgoYW5nbGUgPCBib3R0b21MZWZ0QW5nbGUpIHx8IChhbmdsZSA+IGJvdHRvbVJpZ2h0QW5nbGUpKSB7XG4gICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIHR4ID0gb2Zmc2V0O1xuICAgICAgICB0eSA9IDA7XG4gICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPCB0b3BMZWZ0QW5nbGUpIHtcbiAgICAgICAgdHggPSAwO1xuICAgICAgICB0eSA9IC1vZmZzZXQ7XG4gICAgICAgIGlmIChhdXRvT3JpZW50KSB7XG4gICAgICAgICAgICBvcmllbnRBbmdsZSA9IC05MDtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIHkgPSAnMCc7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFuZ2xlIDwgdG9wUmlnaHRBbmdsZSkge1xuICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB0eCA9IC1vZmZzZXQ7XG4gICAgICAgIHR5ID0gMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHR4ID0gMDtcbiAgICAgICAgdHkgPSBvZmZzZXQ7XG4gICAgICAgIGlmIChhdXRvT3JpZW50KSB7XG4gICAgICAgICAgICBvcmllbnRBbmdsZSA9IDkwO1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgeSA9ICcuNmVtJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeDogcm91bmQodHgpLFxuICAgICAgICB5OiByb3VuZCh0eSksXG4gICAgICAgIGFuZ2xlOiBvcmllbnRBbmdsZSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHksIHRleHRBbmNob3IgfX1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaW5zaWRlTGF5b3V0KHBvcnRQb3NpdGlvbiwgZWxCQm94LCBhdXRvT3JpZW50LCBvcHQpIHtcblxuICAgIG9wdCA9IHV0aWwuZGVmYXVsdHMoe30sIG9wdCwgeyBvZmZzZXQ6IDE1IH0pO1xuICAgIHZhciBhbmdsZSA9IGVsQkJveC5jZW50ZXIoKS50aGV0YShwb3J0UG9zaXRpb24pO1xuXG4gICAgdmFyIHR4LCB0eSwgeSwgdGV4dEFuY2hvcjtcbiAgICB2YXIgb2Zmc2V0ID0gb3B0Lm9mZnNldDtcbiAgICB2YXIgb3JpZW50QW5nbGUgPSAwO1xuXG4gICAgY29uc3QgW3RvcExlZnRBbmdsZSwgYm90dG9tTGVmdEFuZ2xlLCBib3R0b21SaWdodEFuZ2xlLCB0b3BSaWdodEFuZ2xlXSA9IGdldEJCb3hBbmdsZXMoZWxCQm94KTtcbiAgICBpZiAoKGFuZ2xlIDwgYm90dG9tTGVmdEFuZ2xlKSB8fCAoYW5nbGUgPiBib3R0b21SaWdodEFuZ2xlKSkge1xuICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB0eCA9IC1vZmZzZXQ7XG4gICAgICAgIHR5ID0gMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPCB0b3BMZWZ0QW5nbGUpIHtcbiAgICAgICAgdHggPSAwO1xuICAgICAgICB0eSA9IG9mZnNldDtcbiAgICAgICAgaWYgKGF1dG9PcmllbnQpIHtcbiAgICAgICAgICAgIG9yaWVudEFuZ2xlID0gOTA7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgICAgICB5ID0gJy42ZW0nO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChhbmdsZSA8IHRvcFJpZ2h0QW5nbGUpIHtcbiAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgdHggPSBvZmZzZXQ7XG4gICAgICAgIHR5ID0gMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHggPSAwO1xuICAgICAgICB0eSA9IC1vZmZzZXQ7XG4gICAgICAgIGlmIChhdXRvT3JpZW50KSB7XG4gICAgICAgICAgICBvcmllbnRBbmdsZSA9IC05MDtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIHkgPSAnMCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHg6IHJvdW5kKHR4KSxcbiAgICAgICAgeTogcm91bmQodHkpLFxuICAgICAgICBhbmdsZTogb3JpZW50QW5nbGUsXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5LCB0ZXh0QW5jaG9yIH19XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJhZGlhbExheW91dChwb3J0Q2VudGVyT2Zmc2V0LCBhdXRvT3JpZW50LCBvcHQpIHtcblxuICAgIG9wdCA9IHV0aWwuZGVmYXVsdHMoe30sIG9wdCwgeyBvZmZzZXQ6IDIwIH0pO1xuXG4gICAgdmFyIG9yaWdpbiA9IGcucG9pbnQoMCwgMCk7XG4gICAgdmFyIGFuZ2xlID0gLXBvcnRDZW50ZXJPZmZzZXQudGhldGEob3JpZ2luKTtcbiAgICB2YXIgb3JpZW50QW5nbGUgPSBhbmdsZTtcbiAgICB2YXIgb2Zmc2V0ID0gcG9ydENlbnRlck9mZnNldC5jbG9uZSgpXG4gICAgICAgIC5tb3ZlKG9yaWdpbiwgb3B0Lm9mZnNldClcbiAgICAgICAgLmRpZmZlcmVuY2UocG9ydENlbnRlck9mZnNldClcbiAgICAgICAgLnJvdW5kKCk7XG5cbiAgICB2YXIgeSA9ICcuM2VtJztcbiAgICB2YXIgdGV4dEFuY2hvcjtcblxuICAgIGlmICgoYW5nbGUgKyA5MCkgJSAxODAgPT09IDApIHtcbiAgICAgICAgdGV4dEFuY2hvciA9IGF1dG9PcmllbnQgPyAnZW5kJyA6ICdtaWRkbGUnO1xuICAgICAgICBpZiAoIWF1dG9PcmllbnQgJiYgYW5nbGUgPT09IC0yNzApIHtcbiAgICAgICAgICAgIHkgPSAnMGVtJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPiAtMjcwICYmIGFuZ2xlIDwgLTkwKSB7XG4gICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICBvcmllbnRBbmdsZSA9IGFuZ2xlIC0gMTgwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHRBbmNob3IgPSAnZW5kJztcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHg6IHJvdW5kKG9mZnNldC54KSxcbiAgICAgICAgeTogcm91bmQob2Zmc2V0LnkpLFxuICAgICAgICBhbmdsZTogKChhdXRvT3JpZW50KSA/IG9yaWVudEFuZ2xlIDogMCksXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5LCB0ZXh0QW5jaG9yIH19XG4gICAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBtYW51YWwgPSBmdW5jdGlvbihfcG9ydFBvc2l0aW9uLCBfZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVmdCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB4OiAtMTUsXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5OiAnLjNlbScsIHRleHRBbmNob3I6ICdlbmQnIH19LFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJpZ2h0ID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHg6IDE1LFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeTogJy4zZW0nLCB0ZXh0QW5jaG9yOiAnc3RhcnQnIH19LFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvcCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB5OiAtMTUsXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5OiAnMCcsIHRleHRBbmNob3I6ICdtaWRkbGUnIH19LFxuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGJvdHRvbSA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB5OiAxNSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHk6ICcuNmVtJywgdGV4dEFuY2hvcjogJ21pZGRsZScgfX0sXG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3Qgb3V0c2lkZU9yaWVudGVkID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBvdXRzaWRlTGF5b3V0KHBvcnRQb3NpdGlvbiwgZWxCQm94LCB0cnVlLCBvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IG91dHNpZGUgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIG91dHNpZGVMYXlvdXQocG9ydFBvc2l0aW9uLCBlbEJCb3gsIGZhbHNlLCBvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGluc2lkZU9yaWVudGVkID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBpbnNpZGVMYXlvdXQocG9ydFBvc2l0aW9uLCBlbEJCb3gsIHRydWUsIG9wdCk7XG59O1xuXG5leHBvcnQgY29uc3QgaW5zaWRlID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBpbnNpZGVMYXlvdXQocG9ydFBvc2l0aW9uLCBlbEJCb3gsIGZhbHNlLCBvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJhZGlhbCA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gcmFkaWFsTGF5b3V0KHBvcnRQb3NpdGlvbi5kaWZmZXJlbmNlKGVsQkJveC5jZW50ZXIoKSksIGZhbHNlLCBvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJhZGlhbE9yaWVudGVkID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiByYWRpYWxMYXlvdXQocG9ydFBvc2l0aW9uLmRpZmZlcmVuY2UoZWxCQm94LmNlbnRlcigpKSwgdHJ1ZSwgb3B0KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkAnchors/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkAnchors/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectionClosest: () => (/* binding */ connectionClosest),\n/* harmony export */   connectionLength: () => (/* binding */ connectionLength),\n/* harmony export */   connectionPerpendicular: () => (/* binding */ connectionPerpendicular),\n/* harmony export */   connectionRatio: () => (/* binding */ connectionRatio),\n/* harmony export */   resolveRef: () => (/* binding */ resolveRef)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n    var length = ('length' in opt) ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if ('fallbackAt' in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n    return closestPoint;\n}\n\nfunction resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\n\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage)(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n\n// joint.linkAnchors\n\nconst connectionPerpendicular = resolveRef(_connectionPerpendicular);\nconst connectionClosest = resolveRef(_connectionClosest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtBbmNob3JzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE2QztBQUNJOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBSTtBQUMvQiw2QkFBNkIsOENBQUk7QUFDakMsK0RBQStELDBDQUEwQztBQUN6RyxtRUFBbUUsMENBQTBDO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQywrQ0FBSztBQUN2QztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsK0JBQStCLCtDQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSw2REFBWTtBQUNwQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDNkM7QUFDdEM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtBbmNob3JzL2luZGV4Lm1qcz85ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmUsIFBvaW50IH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNQZXJjZW50YWdlIH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG5mdW5jdGlvbiBjb25uZWN0aW9uUmF0aW8odmlldywgX21hZ25ldCwgX3JlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciByYXRpbyA9ICgncmF0aW8nIGluIG9wdCkgPyBvcHQucmF0aW8gOiAwLjU7XG4gICAgcmV0dXJuIHZpZXcuZ2V0UG9pbnRBdFJhdGlvKHJhdGlvKTtcbn1cblxuZnVuY3Rpb24gY29ubmVjdGlvbkxlbmd0aCh2aWV3LCBfbWFnbmV0LCBfcmVmUG9pbnQsIG9wdCkge1xuXG4gICAgdmFyIGxlbmd0aCA9ICgnbGVuZ3RoJyBpbiBvcHQpID8gb3B0Lmxlbmd0aCA6IDIwO1xuICAgIHJldHVybiB2aWV3LmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gX2Nvbm5lY3Rpb25QZXJwZW5kaWN1bGFyKHZpZXcsIF9tYWduZXQsIHJlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciBPRkZTRVQgPSAxZTY7XG4gICAgdmFyIHBhdGggPSB2aWV3LmdldENvbm5lY3Rpb24oKTtcbiAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IHZpZXcuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpO1xuICAgIHZhciB2ZXJ0aWNhbExpbmUgPSBuZXcgTGluZShyZWZQb2ludC5jbG9uZSgpLm9mZnNldCgwLCBPRkZTRVQpLCByZWZQb2ludC5jbG9uZSgpLm9mZnNldCgwLCAtT0ZGU0VUKSk7XG4gICAgdmFyIGhvcml6b250YWxMaW5lID0gbmV3IExpbmUocmVmUG9pbnQuY2xvbmUoKS5vZmZzZXQoT0ZGU0VULCAwKSwgcmVmUG9pbnQuY2xvbmUoKS5vZmZzZXQoLU9GRlNFVCwgMCkpO1xuICAgIHZhciB2ZXJ0aWNhbEludGVyc2VjdGlvbnMgPSB2ZXJ0aWNhbExpbmUuaW50ZXJzZWN0KHBhdGgsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9KTtcbiAgICB2YXIgaG9yaXpvbnRhbEludGVyc2VjdGlvbnMgPSBob3Jpem9udGFsTGluZS5pbnRlcnNlY3QocGF0aCwgeyBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH0pO1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgaWYgKHZlcnRpY2FsSW50ZXJzZWN0aW9ucykgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9ucywgdmVydGljYWxJbnRlcnNlY3Rpb25zKTtcbiAgICBpZiAoaG9yaXpvbnRhbEludGVyc2VjdGlvbnMpIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGludGVyc2VjdGlvbnMsIGhvcml6b250YWxJbnRlcnNlY3Rpb25zKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSByZXR1cm4gcmVmUG9pbnQuY2hvb3NlQ2xvc2VzdChpbnRlcnNlY3Rpb25zKTtcbiAgICBpZiAoJ2ZhbGxiYWNrQXQnIGluIG9wdCkge1xuICAgICAgICByZXR1cm4gZ2V0UG9pbnRBdExpbmsodmlldywgb3B0LmZhbGxiYWNrQXQpO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvbkNsb3Nlc3QodmlldywgX21hZ25ldCwgcmVmUG9pbnQsIG9wdCk7XG59XG5cbmZ1bmN0aW9uIF9jb25uZWN0aW9uQ2xvc2VzdCh2aWV3LCBfbWFnbmV0LCByZWZQb2ludCwgX29wdCkge1xuXG4gICAgdmFyIGNsb3Nlc3RQb2ludCA9IHZpZXcuZ2V0Q2xvc2VzdFBvaW50KHJlZlBvaW50KTtcbiAgICBpZiAoIWNsb3Nlc3RQb2ludCkgcmV0dXJuIG5ldyBQb2ludCgpO1xuICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUmVmKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZpZXcsIG1hZ25ldCwgcmVmLCBvcHQpIHtcbiAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciByZWZWaWV3ID0gdGhpcy5wYXBlci5maW5kVmlldyhyZWYpO1xuICAgICAgICAgICAgdmFyIHJlZlBvaW50O1xuICAgICAgICAgICAgaWYgKHJlZlZpZXcpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmVmlldy5pc05vZGVDb25uZWN0aW9uKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gKCdmaXhlZEF0JyBpbiBvcHQpID8gb3B0LmZpeGVkQXQgOiAnNTAlJztcbiAgICAgICAgICAgICAgICAgICAgcmVmUG9pbnQgPSBnZXRQb2ludEF0TGluayhyZWZWaWV3LCBkaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmUG9pbnQgPSByZWZWaWV3LmdldE5vZGVCQm94KHJlZikuY2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgICAgICAgICAgIHJlZlBvaW50ID0gbmV3IFBvaW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB2aWV3LCBtYWduZXQsIHJlZlBvaW50LCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBvaW50QXRMaW5rKHZpZXcsIHZhbHVlKSB7XG4gICAgdmFyIHBhcnNlZFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKGlzUGVyY2VudGFnZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0UG9pbnRBdFJhdGlvKHBhcnNlZFZhbHVlIC8gMTAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmlldy5nZXRQb2ludEF0TGVuZ3RoKHBhcnNlZFZhbHVlKTtcbiAgICB9XG59XG5cbi8vIGpvaW50LmxpbmtBbmNob3JzXG5leHBvcnQgeyBjb25uZWN0aW9uUmF0aW8sIGNvbm5lY3Rpb25MZW5ndGggfTtcbmV4cG9ydCBjb25zdCBjb25uZWN0aW9uUGVycGVuZGljdWxhciA9IHJlc29sdmVSZWYoX2Nvbm5lY3Rpb25QZXJwZW5kaWN1bGFyKTtcbmV4cG9ydCBjb25zdCBjb25uZWN0aW9uQ2xvc2VzdCA9IHJlc29sdmVSZWYoX2Nvbm5lY3Rpb25DbG9zZXN0KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkAnchors/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkTools/Anchor.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Anchor.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SourceAnchor: () => (/* binding */ SourceAnchor),\n/* harmony export */   TargetAnchor: () => (/* binding */ TargetAnchor)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cellTools/helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\nconst Anchor = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    tagName: 'g',\n    type: null,\n    children: [{\n        tagName: 'circle',\n        selector: 'anchor',\n        attributes: {\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'area',\n        attributes: {\n            'pointer-events': 'none',\n            'fill': 'none',\n            'stroke': '#33334F',\n            'stroke-dasharray': '2,4',\n            'rx': 5,\n            'ry': 5\n        }\n    }],\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onPointerDblClick',\n        dbltap: 'onPointerDblClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        snap: _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.snapAnchor,\n        anchor: _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.getAnchor,\n        scale: null,\n        resetAnchor: true,\n        customAnchorAttributes: {\n            'stroke-width': 4,\n            'stroke': '#33334F',\n            'fill': '#FFFFFF',\n            'r': 5\n        },\n        defaultAnchorAttributes: {\n            'stroke-width': 2,\n            'stroke': '#FFFFFF',\n            'fill': '#33334F',\n            'r': 6\n        },\n        areaPadding: 6,\n        snapRadius: 10,\n        restrictArea: true,\n        redundancyRemoval: true\n    },\n    onRender: function() {\n        this.renderChildren();\n        this.toggleArea(false);\n        this.update();\n    },\n    update: function() {\n        var type = this.type;\n        var relatedView = this.relatedView;\n        var view = relatedView.getEndView(type);\n        if (view) {\n            this.updateAnchor();\n            this.updateArea();\n            this.el.style.display = '';\n        } else {\n            this.el.style.display = 'none';\n        }\n        return this;\n    },\n    updateAnchor: function() {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var anchorNode = childNodes.anchor;\n        if (!anchorNode) return;\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var position = relatedView.getEndAnchor(type);\n        var options = this.options;\n        var customAnchor = relatedView.model.prop([type, 'anchor']);\n        let transformString =  `translate(${position.x},${position.y})`;\n        if (options.scale) {\n            transformString += ` scale(${options.scale})`;\n        }\n        anchorNode.setAttribute('transform', transformString);\n        var anchorAttributes = (customAnchor) ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n        for (var attrName in anchorAttributes) {\n            anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n        }\n    },\n    updateArea: function() {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var areaNode = childNodes.area;\n        if (!areaNode) return;\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var view = relatedView.getEndView(type);\n        var model = view.model;\n        var magnet = relatedView.getEndMagnet(type);\n        var padding = this.options.areaPadding;\n        if (!isFinite(padding)) padding = 0;\n        var bbox, angle, center;\n        if (view.isNodeConnection(magnet)) {\n            bbox = view.getNodeBBox(magnet);\n            angle = 0;\n            center = bbox.center();\n        } else {\n            bbox = view.getNodeUnrotatedBBox(magnet);\n            angle = model.angle();\n            center = bbox.center();\n            if (angle) center.rotate(model.getBBox().center(), -angle);\n            // TODO: get the link's magnet rotation into account\n        }\n        bbox.inflate(padding);\n        areaNode.setAttribute('x', -bbox.width / 2);\n        areaNode.setAttribute('y', -bbox.height / 2);\n        areaNode.setAttribute('width', bbox.width);\n        areaNode.setAttribute('height', bbox.height);\n        areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n    },\n    toggleArea: function(visible) {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var areaNode = childNodes.area;\n        if (!areaNode) return;\n        areaNode.style.display = (visible) ? '' : 'none';\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.paper.undelegateEvents();\n        this.delegateDocumentEvents();\n        this.focus();\n        this.toggleArea(this.options.restrictArea);\n        this.relatedView.model.startBatch('anchor-move', { ui: true, tool: this.cid });\n    },\n    resetAnchor: function(anchor) {\n        var type = this.type;\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    onPointerMove: function(evt) {\n\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var view = relatedView.getEndView(type);\n        var model = view.model;\n        var magnet = relatedView.getEndMagnet(type);\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeEvent(evt);\n        var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n        var snapFn = this.options.snap;\n        if (typeof snapFn === 'function') {\n            coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n            coords = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(coords);\n        }\n\n        if (this.options.restrictArea) {\n            if (view.isNodeConnection(magnet)) {\n                // snap coords to the link's connection\n                var pointAtConnection = view.getClosestPoint(coords);\n                if (pointAtConnection) coords = pointAtConnection;\n            } else {\n                // snap coords within node bbox\n                var bbox = view.getNodeUnrotatedBBox(magnet);\n                var angle = model.angle();\n                var origin = model.getBBox().center();\n                var rotatedCoords = coords.clone().rotate(origin, angle);\n                if (!bbox.containsPoint(rotatedCoords)) {\n                    coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n                }\n            }\n        }\n\n        var anchor;\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn === 'function') {\n            anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n        }\n\n        this.resetAnchor(anchor);\n        this.update();\n    },\n\n    onPointerUp: function(evt) {\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeEvent(evt);\n        this.paper.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleArea(false);\n        var linkView = this.relatedView;\n        if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        linkView.checkMouseleave(normalizedEvent);\n        linkView.model.stopBatch('anchor-move', { ui: true, tool: this.cid });\n    },\n\n    onPointerDblClick: function() {\n        var anchor = this.options.resetAnchor;\n        if (anchor === false) return; // reset anchor disabled\n        if (anchor === true) anchor = null; // remove the current anchor\n        this.resetAnchor(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.cloneDeep(anchor));\n        this.update();\n    }\n});\n\nconst SourceAnchor = Anchor.extend({\n    name: 'source-anchor',\n    type: 'source'\n});\n\nconst TargetAnchor = Anchor.extend({\n    name: 'target-anchor',\n    type: 'target'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9BbmNob3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBb0M7QUFDTTtBQUNLO0FBQ2tCOztBQUVqRSxlQUFlLHVEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLDhEQUFVO0FBQ3hCLGdCQUFnQiw2REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVcsR0FBRyxXQUFXO0FBQ3JFO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDBCQUEwQjtBQUNyRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUFPO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdDQUFnQywyREFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRiwwQkFBMEI7QUFDL0c7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFLEtBQUs7O0FBRUw7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyw0Q0FBNEM7QUFDNUMseUJBQXlCLHNEQUFjO0FBQ3ZDO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9BbmNob3IubWpzPzIzNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFRvb2xWaWV3IH0gZnJvbSAnLi4vZGlhL1Rvb2xWaWV3Lm1qcyc7XG5pbXBvcnQgeyBnZXRBbmNob3IsIHNuYXBBbmNob3IgfSBmcm9tICcuLi9jZWxsVG9vbHMvaGVscGVycy5tanMnO1xuXG5jb25zdCBBbmNob3IgPSBUb29sVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdnJyxcbiAgICB0eXBlOiBudWxsLFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdhbmNob3InLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdhcmVhJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyMzMzMzNEYnLFxuICAgICAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnMiw0JyxcbiAgICAgICAgICAgICdyeCc6IDUsXG4gICAgICAgICAgICAncnknOiA1XG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgbW91c2Vkb3duOiAnb25Qb2ludGVyRG93bicsXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgZGJsY2xpY2s6ICdvblBvaW50ZXJEYmxDbGljaycsXG4gICAgICAgIGRibHRhcDogJ29uUG9pbnRlckRibENsaWNrJ1xuICAgIH0sXG4gICAgZG9jdW1lbnRFdmVudHM6IHtcbiAgICAgICAgbW91c2Vtb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIHRvdWNobW92ZTogJ29uUG9pbnRlck1vdmUnLFxuICAgICAgICBtb3VzZXVwOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGVuZDogJ29uUG9pbnRlclVwJyxcbiAgICAgICAgdG91Y2hjYW5jZWw6ICdvblBvaW50ZXJVcCdcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc25hcDogc25hcEFuY2hvcixcbiAgICAgICAgYW5jaG9yOiBnZXRBbmNob3IsXG4gICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICByZXNldEFuY2hvcjogdHJ1ZSxcbiAgICAgICAgY3VzdG9tQW5jaG9yQXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDQsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyMzMzMzNEYnLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAncic6IDVcbiAgICAgICAgfSxcbiAgICAgICAgZGVmYXVsdEFuY2hvckF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAgICAgJ3N0cm9rZSc6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICdmaWxsJzogJyMzMzMzNEYnLFxuICAgICAgICAgICAgJ3InOiA2XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWFQYWRkaW5nOiA2LFxuICAgICAgICBzbmFwUmFkaXVzOiAxMCxcbiAgICAgICAgcmVzdHJpY3RBcmVhOiB0cnVlLFxuICAgICAgICByZWR1bmRhbmN5UmVtb3ZhbDogdHJ1ZVxuICAgIH0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlQXJlYShmYWxzZSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHZpZXcgPSByZWxhdGVkVmlldy5nZXRFbmRWaWV3KHR5cGUpO1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmNob3IoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXJlYSgpO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB1cGRhdGVBbmNob3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKCFjaGlsZE5vZGVzKSByZXR1cm47XG4gICAgICAgIHZhciBhbmNob3JOb2RlID0gY2hpbGROb2Rlcy5hbmNob3I7XG4gICAgICAgIGlmICghYW5jaG9yTm9kZSkgcmV0dXJuO1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcmVsYXRlZFZpZXcuZ2V0RW5kQW5jaG9yKHR5cGUpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIGN1c3RvbUFuY2hvciA9IHJlbGF0ZWRWaWV3Lm1vZGVsLnByb3AoW3R5cGUsICdhbmNob3InXSk7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1TdHJpbmcgPSAgYHRyYW5zbGF0ZSgke3Bvc2l0aW9uLnh9LCR7cG9zaXRpb24ueX0pYDtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NhbGUpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVN0cmluZyArPSBgIHNjYWxlKCR7b3B0aW9ucy5zY2FsZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBhbmNob3JOb2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdHJhbnNmb3JtU3RyaW5nKTtcbiAgICAgICAgdmFyIGFuY2hvckF0dHJpYnV0ZXMgPSAoY3VzdG9tQW5jaG9yKSA/IG9wdGlvbnMuY3VzdG9tQW5jaG9yQXR0cmlidXRlcyA6IG9wdGlvbnMuZGVmYXVsdEFuY2hvckF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIGFuY2hvckF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGFuY2hvck5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhbmNob3JBdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZUFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKCFjaGlsZE5vZGVzKSByZXR1cm47XG4gICAgICAgIHZhciBhcmVhTm9kZSA9IGNoaWxkTm9kZXMuYXJlYTtcbiAgICAgICAgaWYgKCFhcmVhTm9kZSkgcmV0dXJuO1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIHZpZXcgPSByZWxhdGVkVmlldy5nZXRFbmRWaWV3KHR5cGUpO1xuICAgICAgICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICB2YXIgbWFnbmV0ID0gcmVsYXRlZFZpZXcuZ2V0RW5kTWFnbmV0KHR5cGUpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMub3B0aW9ucy5hcmVhUGFkZGluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShwYWRkaW5nKSkgcGFkZGluZyA9IDA7XG4gICAgICAgIHZhciBiYm94LCBhbmdsZSwgY2VudGVyO1xuICAgICAgICBpZiAodmlldy5pc05vZGVDb25uZWN0aW9uKG1hZ25ldCkpIHtcbiAgICAgICAgICAgIGJib3ggPSB2aWV3LmdldE5vZGVCQm94KG1hZ25ldCk7XG4gICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgICAgICBjZW50ZXIgPSBiYm94LmNlbnRlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmJveCA9IHZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobWFnbmV0KTtcbiAgICAgICAgICAgIGFuZ2xlID0gbW9kZWwuYW5nbGUoKTtcbiAgICAgICAgICAgIGNlbnRlciA9IGJib3guY2VudGVyKCk7XG4gICAgICAgICAgICBpZiAoYW5nbGUpIGNlbnRlci5yb3RhdGUobW9kZWwuZ2V0QkJveCgpLmNlbnRlcigpLCAtYW5nbGUpO1xuICAgICAgICAgICAgLy8gVE9ETzogZ2V0IHRoZSBsaW5rJ3MgbWFnbmV0IHJvdGF0aW9uIGludG8gYWNjb3VudFxuICAgICAgICB9XG4gICAgICAgIGJib3guaW5mbGF0ZShwYWRkaW5nKTtcbiAgICAgICAgYXJlYU5vZGUuc2V0QXR0cmlidXRlKCd4JywgLWJib3gud2lkdGggLyAyKTtcbiAgICAgICAgYXJlYU5vZGUuc2V0QXR0cmlidXRlKCd5JywgLWJib3guaGVpZ2h0IC8gMik7XG4gICAgICAgIGFyZWFOb2RlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBiYm94LndpZHRoKTtcbiAgICAgICAgYXJlYU5vZGUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBiYm94LmhlaWdodCk7XG4gICAgICAgIGFyZWFOb2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgY2VudGVyLnggKyAnLCcgKyBjZW50ZXIueSArICcpIHJvdGF0ZSgnICsgYW5nbGUgKyAnKScpO1xuICAgIH0sXG4gICAgdG9nZ2xlQXJlYTogZnVuY3Rpb24odmlzaWJsZSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgaWYgKCFjaGlsZE5vZGVzKSByZXR1cm47XG4gICAgICAgIHZhciBhcmVhTm9kZSA9IGNoaWxkTm9kZXMuYXJlYTtcbiAgICAgICAgaWYgKCFhcmVhTm9kZSkgcmV0dXJuO1xuICAgICAgICBhcmVhTm9kZS5zdHlsZS5kaXNwbGF5ID0gKHZpc2libGUpID8gJycgOiAnbm9uZSc7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0KSkgcmV0dXJuO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLnBhcGVyLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy50b2dnbGVBcmVhKHRoaXMub3B0aW9ucy5yZXN0cmljdEFyZWEpO1xuICAgICAgICB0aGlzLnJlbGF0ZWRWaWV3Lm1vZGVsLnN0YXJ0QmF0Y2goJ2FuY2hvci1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgfSxcbiAgICByZXNldEFuY2hvcjogZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIgcmVsYXRlZE1vZGVsID0gdGhpcy5yZWxhdGVkVmlldy5tb2RlbDtcbiAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgcmVsYXRlZE1vZGVsLnByb3AoW3R5cGUsICdhbmNob3InXSwgYW5jaG9yLCB7XG4gICAgICAgICAgICAgICAgcmV3cml0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b29sOiB0aGlzLmNpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWxhdGVkTW9kZWwucmVtb3ZlUHJvcChbdHlwZSwgJ2FuY2hvciddLCB7XG4gICAgICAgICAgICAgICAgdWk6IHRydWUsXG4gICAgICAgICAgICAgICAgdG9vbDogdGhpcy5jaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIHZpZXcgPSByZWxhdGVkVmlldy5nZXRFbmRWaWV3KHR5cGUpO1xuICAgICAgICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICB2YXIgbWFnbmV0ID0gcmVsYXRlZFZpZXcuZ2V0RW5kTWFnbmV0KHR5cGUpO1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5wYXBlci5jbGllbnRUb0xvY2FsUG9pbnQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgdmFyIHNuYXBGbiA9IHRoaXMub3B0aW9ucy5zbmFwO1xuICAgICAgICBpZiAodHlwZW9mIHNuYXBGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29vcmRzID0gc25hcEZuLmNhbGwocmVsYXRlZFZpZXcsIGNvb3JkcywgdmlldywgbWFnbmV0LCB0eXBlLCByZWxhdGVkVmlldywgdGhpcyk7XG4gICAgICAgICAgICBjb29yZHMgPSBuZXcgZy5Qb2ludChjb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXN0cmljdEFyZWEpIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlzTm9kZUNvbm5lY3Rpb24obWFnbmV0KSkge1xuICAgICAgICAgICAgICAgIC8vIHNuYXAgY29vcmRzIHRvIHRoZSBsaW5rJ3MgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIHZhciBwb2ludEF0Q29ubmVjdGlvbiA9IHZpZXcuZ2V0Q2xvc2VzdFBvaW50KGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50QXRDb25uZWN0aW9uKSBjb29yZHMgPSBwb2ludEF0Q29ubmVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc25hcCBjb29yZHMgd2l0aGluIG5vZGUgYmJveFxuICAgICAgICAgICAgICAgIHZhciBiYm94ID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IG1vZGVsLmFuZ2xlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG1vZGVsLmdldEJCb3goKS5jZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlZENvb3JkcyA9IGNvb3Jkcy5jbG9uZSgpLnJvdGF0ZShvcmlnaW4sIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJib3guY29udGFpbnNQb2ludChyb3RhdGVkQ29vcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMgPSBiYm94LnBvaW50TmVhcmVzdFRvUG9pbnQocm90YXRlZENvb3Jkcykucm90YXRlKG9yaWdpbiwgLWFuZ2xlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5jaG9yO1xuICAgICAgICB2YXIgYW5jaG9yRm4gPSB0aGlzLm9wdGlvbnMuYW5jaG9yO1xuICAgICAgICBpZiAodHlwZW9mIGFuY2hvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhbmNob3IgPSBhbmNob3JGbi5jYWxsKHJlbGF0ZWRWaWV3LCBjb29yZHMsIHZpZXcsIG1hZ25ldCwgdHlwZSwgcmVsYXRlZFZpZXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNldEFuY2hvcihhbmNob3IpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgdGhpcy5wYXBlci5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVEb2N1bWVudEV2ZW50cygpO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgdGhpcy50b2dnbGVBcmVhKGZhbHNlKTtcbiAgICAgICAgdmFyIGxpbmtWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWR1bmRhbmN5UmVtb3ZhbCkgbGlua1ZpZXcucmVtb3ZlUmVkdW5kYW50TGluZWFyVmVydGljZXMoeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIGxpbmtWaWV3LmNoZWNrTW91c2VsZWF2ZShub3JtYWxpemVkRXZlbnQpO1xuICAgICAgICBsaW5rVmlldy5tb2RlbC5zdG9wQmF0Y2goJ2FuY2hvci1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgfSxcblxuICAgIG9uUG9pbnRlckRibENsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMub3B0aW9ucy5yZXNldEFuY2hvcjtcbiAgICAgICAgaWYgKGFuY2hvciA9PT0gZmFsc2UpIHJldHVybjsgLy8gcmVzZXQgYW5jaG9yIGRpc2FibGVkXG4gICAgICAgIGlmIChhbmNob3IgPT09IHRydWUpIGFuY2hvciA9IG51bGw7IC8vIHJlbW92ZSB0aGUgY3VycmVudCBhbmNob3JcbiAgICAgICAgdGhpcy5yZXNldEFuY2hvcih1dGlsLmNsb25lRGVlcChhbmNob3IpKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IFNvdXJjZUFuY2hvciA9IEFuY2hvci5leHRlbmQoe1xuICAgIG5hbWU6ICdzb3VyY2UtYW5jaG9yJyxcbiAgICB0eXBlOiAnc291cmNlJ1xufSk7XG5cbmV4cG9ydCBjb25zdCBUYXJnZXRBbmNob3IgPSBBbmNob3IuZXh0ZW5kKHtcbiAgICBuYW1lOiAndGFyZ2V0LWFuY2hvcicsXG4gICAgdHlwZTogJ3RhcmdldCdcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkTools/Anchor.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkTools/Arrowhead.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Arrowhead.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SourceArrowhead: () => (/* binding */ SourceArrowhead),\n/* harmony export */   TargetArrowhead: () => (/* binding */ TargetArrowhead)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n\n\n\n\n\n// End Markers\nconst Arrowhead = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    tagName: 'path',\n    xAxisVector: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0),\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        scale: null\n    },\n    onRender: function() {\n        this.update();\n    },\n    update: function() {\n        var ratio = this.ratio;\n        var view = this.relatedView;\n        var tangent = view.getTangentAtRatio(ratio);\n        var position, angle;\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n        } else {\n            position = view.getPointAtRatio(ratio);\n            angle = 0;\n        }\n        if (!position) return this;\n        var matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createSVGMatrix().translate(position.x, position.y).rotate(angle);\n        const { scale } = this.options;\n        if (scale) matrix = matrix.scale(scale);\n        this.vel.transform(matrix, { absolute: true });\n        return this;\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        relatedView.model.startBatch('arrowhead-move', { ui: true, tool: this.cid });\n        relatedView.startArrowheadMove(this.arrowheadType);\n        const data = evt.data || (evt.data = {});\n        this.delegateDocumentEvents(null, data);\n        paper.undelegateEvents();\n        this.focus();\n        this.el.style.pointerEvents = 'none';\n        relatedView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onPointerMove: function(evt) {\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeEvent(evt);\n        var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n        paper.delegateEvents();\n        this.blur();\n        this.el.style.pointerEvents = '';\n        relatedView.model.stopBatch('arrowhead-move', { ui: true, tool: this.cid });\n    }\n});\n\nconst TargetArrowhead = Arrowhead.extend({\n    name: 'target-arrowhead',\n    ratio: 1,\n    arrowheadType: 'target',\n    attributes: {\n        'd': 'M -10 -8 10 0 -10 8 Z',\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move',\n        'class': 'target-arrowhead'\n    }\n});\n\nconst SourceArrowhead = Arrowhead.extend({\n    name: 'source-arrowhead',\n    ratio: 0,\n    arrowheadType: 'source',\n    attributes: {\n        'd': 'M 10 -8 -10 0 10 8 Z',\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move',\n        'class': 'source-arrowhead'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9BcnJvd2hlYWQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFvQztBQUNMO0FBQ1c7QUFDSzs7QUFFL0M7QUFDQSxrQkFBa0IsdURBQVE7QUFDMUI7QUFDQSxxQkFBcUIsK0NBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBQztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBCQUEwQjtBQUNuRjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLDJEQUFtQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDBCQUEwQjtBQUNsRjtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL0Fycm93aGVhZC5tanM/NDJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgVG9vbFZpZXcgfSBmcm9tICcuLi9kaWEvVG9vbFZpZXcubWpzJztcblxuLy8gRW5kIE1hcmtlcnNcbmNvbnN0IEFycm93aGVhZCA9IFRvb2xWaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgIHhBeGlzVmVjdG9yOiBuZXcgZy5Qb2ludCgxLCAwKSxcbiAgICBldmVudHM6IHtcbiAgICAgICAgbW91c2Vkb3duOiAnb25Qb2ludGVyRG93bicsXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdvblBvaW50ZXJEb3duJ1xuICAgIH0sXG4gICAgZG9jdW1lbnRFdmVudHM6IHtcbiAgICAgICAgbW91c2Vtb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIHRvdWNobW92ZTogJ29uUG9pbnRlck1vdmUnLFxuICAgICAgICBtb3VzZXVwOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGVuZDogJ29uUG9pbnRlclVwJyxcbiAgICAgICAgdG91Y2hjYW5jZWw6ICdvblBvaW50ZXJVcCdcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgc2NhbGU6IG51bGxcbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByYXRpbyA9IHRoaXMucmF0aW87XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHRhbmdlbnQgPSB2aWV3LmdldFRhbmdlbnRBdFJhdGlvKHJhdGlvKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uLCBhbmdsZTtcbiAgICAgICAgaWYgKHRhbmdlbnQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGFuZ2VudC5zdGFydDtcbiAgICAgICAgICAgIGFuZ2xlID0gdGFuZ2VudC52ZWN0b3IoKS52ZWN0b3JBbmdsZSh0aGlzLnhBeGlzVmVjdG9yKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB2aWV3LmdldFBvaW50QXRSYXRpbyhyYXRpbyk7XG4gICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwb3NpdGlvbikgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KS5yb3RhdGUoYW5nbGUpO1xuICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChzY2FsZSkgbWF0cml4ID0gbWF0cml4LnNjYWxlKHNjYWxlKTtcbiAgICAgICAgdGhpcy52ZWwudHJhbnNmb3JtKG1hdHJpeCwgeyBhYnNvbHV0ZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0KSkgcmV0dXJuO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgcGFwZXIgPSByZWxhdGVkVmlldy5wYXBlcjtcbiAgICAgICAgcmVsYXRlZFZpZXcubW9kZWwuc3RhcnRCYXRjaCgnYXJyb3doZWFkLW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgcmVsYXRlZFZpZXcuc3RhcnRBcnJvd2hlYWRNb3ZlKHRoaXMuYXJyb3doZWFkVHlwZSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBldnQuZGF0YSB8fCAoZXZ0LmRhdGEgPSB7fSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVEb2N1bWVudEV2ZW50cyhudWxsLCBkYXRhKTtcbiAgICAgICAgcGFwZXIudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgcmVsYXRlZFZpZXcubm90aWZ5UG9pbnRlcmRvd24oLi4ucGFwZXIuZ2V0UG9pbnRlckFyZ3MoZXZ0KSk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMucGFwZXIuc25hcFRvR3JpZChub3JtYWxpemVkRXZlbnQuY2xpZW50WCwgbm9ybWFsaXplZEV2ZW50LmNsaWVudFkpO1xuICAgICAgICB0aGlzLnJlbGF0ZWRWaWV3LnBvaW50ZXJtb3ZlKG5vcm1hbGl6ZWRFdmVudCwgY29vcmRzLngsIGNvb3Jkcy55KTtcbiAgICB9LFxuICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHBhcGVyID0gcmVsYXRlZFZpZXcucGFwZXI7XG4gICAgICAgIHZhciBub3JtYWxpemVkRXZlbnQgPSB1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIHZhciBjb29yZHMgPSBwYXBlci5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdmVudC5jbGllbnRYLCBub3JtYWxpemVkRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHJlbGF0ZWRWaWV3LnBvaW50ZXJ1cChub3JtYWxpemVkRXZlbnQsIGNvb3Jkcy54LCBjb29yZHMueSk7XG4gICAgICAgIHBhcGVyLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgICAgcmVsYXRlZFZpZXcubW9kZWwuc3RvcEJhdGNoKCdhcnJvd2hlYWQtbW92ZScsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgVGFyZ2V0QXJyb3doZWFkID0gQXJyb3doZWFkLmV4dGVuZCh7XG4gICAgbmFtZTogJ3RhcmdldC1hcnJvd2hlYWQnLFxuICAgIHJhdGlvOiAxLFxuICAgIGFycm93aGVhZFR5cGU6ICd0YXJnZXQnLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ2QnOiAnTSAtMTAgLTggMTAgMCAtMTAgOCBaJyxcbiAgICAgICAgJ2ZpbGwnOiAnIzMzMzM0RicsXG4gICAgICAgICdzdHJva2UnOiAnI0ZGRkZGRicsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAnY3Vyc29yJzogJ21vdmUnLFxuICAgICAgICAnY2xhc3MnOiAndGFyZ2V0LWFycm93aGVhZCdcbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IFNvdXJjZUFycm93aGVhZCA9IEFycm93aGVhZC5leHRlbmQoe1xuICAgIG5hbWU6ICdzb3VyY2UtYXJyb3doZWFkJyxcbiAgICByYXRpbzogMCxcbiAgICBhcnJvd2hlYWRUeXBlOiAnc291cmNlJyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdkJzogJ00gMTAgLTggLTEwIDAgMTAgOCBaJyxcbiAgICAgICAgJ2ZpbGwnOiAnIzMzMzM0RicsXG4gICAgICAgICdzdHJva2UnOiAnI0ZGRkZGRicsXG4gICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAnY3Vyc29yJzogJ21vdmUnLFxuICAgICAgICAnY2xhc3MnOiAnc291cmNlLWFycm93aGVhZCdcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkTools/Arrowhead.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkTools/RotateLabel.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/RotateLabel.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RotateLabel: () => (/* binding */ RotateLabel)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cellTools/Control.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Control.mjs\");\n\n\n\nconst RotateLabel = _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_0__.Control.extend({\n\n    xAxisVector: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0),\n\n    children() {\n        const {\n            buttonColor = '#333',\n            iconColor = '#fff',\n            outlineColor = '#fff'\n        } = this.options;\n        return [{\n            selector: 'handle',\n            tagName: 'g',\n            attributes: {\n                cursor: 'grab',\n            },\n            children: [{\n                tagName: 'circle',\n                attributes: {\n                    r: 10,\n                    fill: buttonColor,\n                    stroke: outlineColor,\n                },\n            }, {\n                tagName: 'path',\n                attributes: {\n                    d: 'M -5 0 A 5 5 0 1 1 0 5',\n                    fill: 'transparent',\n                    stroke: iconColor,\n                    strokeWidth: 2,\n                    strokeLinecap: 'round',\n                },\n            }, {\n                tagName: 'path',\n                attributes: {\n                    d: 'M -3 5 L 0 2.5 0 7.5 Z',\n                    fill: iconColor,\n                    stroke: iconColor,\n                    strokeWidth: 1,\n                    transform: 'rotate(-5, -3, 5)',\n                }\n            }]\n        }];\n    },\n\n    getPosition(view) {\n        const { offset = 0 } = this.options;\n        const { x = 0, y = 0 } = typeof offset === 'number' ? { x: 0, y: offset } : offset;\n        const label = this.getLabel();\n        const labelPosition = this.getLabelPosition(label);\n        const coords = view.getLabelCoordinates(labelPosition);\n        let { angle = 0, args = {}} = labelPosition;\n        const keepGradient = args.keepGradient;\n        if (keepGradient) {\n            const tangent = view.getTangentAtRatio(\n                view.getClosestPointRatio(coords)\n            );\n            if (tangent) {\n                // link slope angle\n                angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;\n            }\n        }\n        const matrix = new DOMMatrix()\n            .translate(coords.x, coords.y)\n            .rotate(angle)\n            .translate(x, y);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(matrix.e, matrix.f);\n    },\n\n    // Override the default `computeVisibility` method to hide the tool if the label is not present.\n    computeVisibility() {\n        const visibility = _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_0__.Control.prototype.computeVisibility.apply(this, arguments);\n        return visibility && !!this.getLabel();\n    },\n\n    setPosition(view, coordinates) {\n        const model = view.model;\n        const label = this.getLabel();\n        if (!label) return;\n        const labelPosition = this.getLabelPosition(label);\n        const position = view.getLabelCoordinates(labelPosition);\n        const angle = 90 - position.theta(coordinates);\n        const index = this.getLabelIndex();\n        model.prop(['labels', index, 'position', 'angle'], angle);\n    },\n\n    resetPosition(view) {\n        const model = view.model;\n        const index = this.getLabelIndex();\n        model.prop(['labels', index, 'position', 'angle'], 0);\n    },\n\n    getLabelIndex() {\n        return this.options.labelIndex || 0;\n    },\n\n    getLabel() {\n        return this.relatedView.model.label(this.getLabelIndex()) || null;\n    },\n\n    getLabelPosition(label) {\n        const view = this.relatedView;\n        const labelPosition = view._normalizeLabelPosition(label.position);\n        return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());\n    },\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9Sb3RhdGVMYWJlbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DO0FBQ2U7O0FBRTVDLG9CQUFvQiwyREFBTzs7QUFFbEMscUJBQXFCLCtDQUFPOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixhQUFhO0FBQzdCLGdCQUFnQixlQUFlLGlDQUFpQyxrQkFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBTztBQUMxQixLQUFLOztBQUVMO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQU87QUFDbEM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL1JvdGF0ZUxhYmVsLm1qcz85MTA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ29udHJvbCB9IGZyb20gJy4uL2NlbGxUb29scy9Db250cm9sLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBSb3RhdGVMYWJlbCA9IENvbnRyb2wuZXh0ZW5kKHtcblxuICAgIHhBeGlzVmVjdG9yOiBuZXcgZy5Qb2ludCgxLCAwKSxcblxuICAgIGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBidXR0b25Db2xvciA9ICcjMzMzJyxcbiAgICAgICAgICAgIGljb25Db2xvciA9ICcjZmZmJyxcbiAgICAgICAgICAgIG91dGxpbmVDb2xvciA9ICcjZmZmJ1xuICAgICAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnaGFuZGxlJyxcbiAgICAgICAgICAgIHRhZ05hbWU6ICdnJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdncmFiJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHI6IDEwLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBidXR0b25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBvdXRsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBkOiAnTSAtNSAwIEEgNSA1IDAgMSAxIDAgNScsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogaWNvbkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGQ6ICdNIC0zIDUgTCAwIDIuNSAwIDcuNSBaJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogaWNvbkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IGljb25Db2xvcixcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtNSwgLTMsIDUpJyxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XVxuICAgICAgICB9XTtcbiAgICB9LFxuXG4gICAgZ2V0UG9zaXRpb24odmlldykge1xuICAgICAgICBjb25zdCB7IG9mZnNldCA9IDAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgeyB4ID0gMCwgeSA9IDAgfSA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8geyB4OiAwLCB5OiBvZmZzZXQgfSA6IG9mZnNldDtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsKCk7XG4gICAgICAgIGNvbnN0IGxhYmVsUG9zaXRpb24gPSB0aGlzLmdldExhYmVsUG9zaXRpb24obGFiZWwpO1xuICAgICAgICBjb25zdCBjb29yZHMgPSB2aWV3LmdldExhYmVsQ29vcmRpbmF0ZXMobGFiZWxQb3NpdGlvbik7XG4gICAgICAgIGxldCB7IGFuZ2xlID0gMCwgYXJncyA9IHt9fSA9IGxhYmVsUG9zaXRpb247XG4gICAgICAgIGNvbnN0IGtlZXBHcmFkaWVudCA9IGFyZ3Mua2VlcEdyYWRpZW50O1xuICAgICAgICBpZiAoa2VlcEdyYWRpZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gdmlldy5nZXRUYW5nZW50QXRSYXRpbyhcbiAgICAgICAgICAgICAgICB2aWV3LmdldENsb3Nlc3RQb2ludFJhdGlvKGNvb3JkcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodGFuZ2VudCkge1xuICAgICAgICAgICAgICAgIC8vIGxpbmsgc2xvcGUgYW5nbGVcbiAgICAgICAgICAgICAgICBhbmdsZSArPSB0YW5nZW50LnZlY3RvcigpLnZlY3RvckFuZ2xlKHRoaXMueEF4aXNWZWN0b3IpIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IERPTU1hdHJpeCgpXG4gICAgICAgICAgICAudHJhbnNsYXRlKGNvb3Jkcy54LCBjb29yZHMueSlcbiAgICAgICAgICAgIC5yb3RhdGUoYW5nbGUpXG4gICAgICAgICAgICAudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICByZXR1cm4gbmV3IGcuUG9pbnQobWF0cml4LmUsIG1hdHJpeC5mKTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgYGNvbXB1dGVWaXNpYmlsaXR5YCBtZXRob2QgdG8gaGlkZSB0aGUgdG9vbCBpZiB0aGUgbGFiZWwgaXMgbm90IHByZXNlbnQuXG4gICAgY29tcHV0ZVZpc2liaWxpdHkoKSB7XG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBDb250cm9sLnByb3RvdHlwZS5jb21wdXRlVmlzaWJpbGl0eS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gdmlzaWJpbGl0eSAmJiAhIXRoaXMuZ2V0TGFiZWwoKTtcbiAgICB9LFxuXG4gICAgc2V0UG9zaXRpb24odmlldywgY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWwoKTtcbiAgICAgICAgaWYgKCFsYWJlbCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBsYWJlbFBvc2l0aW9uID0gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKGxhYmVsKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2aWV3LmdldExhYmVsQ29vcmRpbmF0ZXMobGFiZWxQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gOTAgLSBwb3NpdGlvbi50aGV0YShjb29yZGluYXRlcyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMYWJlbEluZGV4KCk7XG4gICAgICAgIG1vZGVsLnByb3AoWydsYWJlbHMnLCBpbmRleCwgJ3Bvc2l0aW9uJywgJ2FuZ2xlJ10sIGFuZ2xlKTtcbiAgICB9LFxuXG4gICAgcmVzZXRQb3NpdGlvbih2aWV3KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdmlldy5tb2RlbDtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldExhYmVsSW5kZXgoKTtcbiAgICAgICAgbW9kZWwucHJvcChbJ2xhYmVscycsIGluZGV4LCAncG9zaXRpb24nLCAnYW5nbGUnXSwgMCk7XG4gICAgfSxcblxuICAgIGdldExhYmVsSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxJbmRleCB8fCAwO1xuICAgIH0sXG5cbiAgICBnZXRMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsYXRlZFZpZXcubW9kZWwubGFiZWwodGhpcy5nZXRMYWJlbEluZGV4KCkpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldExhYmVsUG9zaXRpb24obGFiZWwpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIGNvbnN0IGxhYmVsUG9zaXRpb24gPSB2aWV3Ll9ub3JtYWxpemVMYWJlbFBvc2l0aW9uKGxhYmVsLnBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHZpZXcuX21lcmdlTGFiZWxQb3NpdGlvblByb3BlcnR5KGxhYmVsUG9zaXRpb24sIHZpZXcuX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uUHJvcGVydHkoKSk7XG4gICAgfSxcblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkTools/RotateLabel.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkTools/Segments.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Segments.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Segments: () => (/* binding */ Segments)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cellTools/helpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\n\n\nvar SegmentHandle = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: 'g',\n    svgElement: true,\n    className: 'marker-segment',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    children: [{\n        tagName: 'line',\n        selector: 'line',\n        attributes: {\n            'stroke': '#33334F',\n            'stroke-width': 2,\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'handle',\n        attributes: {\n            'width': 20,\n            'height': 8,\n            'x': -10,\n            'y': -4,\n            'rx': 4,\n            'ry': 4,\n            'fill': '#33334F',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2\n        }\n    }],\n    onRender: function() {\n        this.renderChildren();\n    },\n    position: function(x, y, angle, view) {\n        const { scale } = this.options;\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix().translate(x, y).rotate(angle);\n        if (scale) matrix = matrix.scale(scale);\n\n        var handle = this.childNodes.handle;\n        handle.setAttribute('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(matrix));\n        handle.setAttribute('cursor', (angle % 180 === 0) ? 'row-resize' : 'col-resize');\n\n        var viewPoint = view.getClosestPoint(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x, y));\n        var line = this.childNodes.line;\n        line.setAttribute('x1', x);\n        line.setAttribute('y1', y);\n        line.setAttribute('x2', viewPoint.x);\n        line.setAttribute('y2', viewPoint.y);\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        this.trigger('change:start', this, evt);\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n        this.trigger('change:end', this, evt);\n    },\n    show: function() {\n        this.el.style.display = '';\n    },\n    hide: function() {\n        this.el.style.display = 'none';\n    }\n});\n\nconst Segments = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__.ToolView.extend({\n    name: 'segments',\n    precision: .5,\n    options: {\n        handleClass: SegmentHandle,\n        segmentLengthThreshold: 40,\n        redundancyRemoval: true,\n        anchor: _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_4__.getAnchor,\n        snapRadius: 10,\n        snapHandle: true,\n        stopPropagation: true\n    },\n    handles: null,\n    onRender: function() {\n        this.resetHandles();\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        vertices.unshift(relatedView.sourcePoint);\n        vertices.push(relatedView.targetPoint);\n        for (var i = 0, n = vertices.length; i < n - 1; i++) {\n            var vertex = vertices[i];\n            var nextVertex = vertices[i + 1];\n            var handle = this.renderHandle(vertex, nextVertex);\n            this.simulateRelatedView(handle.el);\n            this.handles.push(handle);\n            handle.options.index = i;\n        }\n        return this;\n    },\n    renderHandle: function(vertex, nextVertex) {\n        var handle = new (this.options.handleClass)({\n            paper: this.paper,\n            scale: this.options.scale,\n            guard: evt => this.guard(evt)\n        });\n        handle.render();\n        this.updateHandle(handle, vertex, nextVertex);\n        handle.vel.appendTo(this.el);\n        this.startHandleListening(handle);\n        return handle;\n    },\n    update: function() {\n        this.render();\n        return this;\n    },\n    startHandleListening: function(handle) {\n        this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n        this.listenTo(handle, 'changing', this.onHandleChanging);\n        this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    shiftHandleIndexes: function(value) {\n        var handles = this.handles;\n        for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n    },\n    resetAnchor: function(type, anchor) {\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    snapHandle: function(handle, position, data) {\n\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        var link = linkView.model;\n        var vertices = link.vertices();\n        var axis = handle.options.axis;\n        var prev = vertices[index - 2] || data.sourceAnchor;\n        var next = vertices[index + 1] || data.targetAnchor;\n        var snapRadius = this.options.snapRadius;\n        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n            position[axis] = prev[axis];\n        } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n            position[axis] = next[axis];\n        }\n        return position;\n    },\n\n    onHandleChanging: function(handle, evt) {\n\n        const { options } = this;\n        var data = this.eventData(evt);\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var index = handle.options.index - 1;\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        var position = this.snapHandle(handle, coords.clone(), data);\n        var axis = handle.options.axis;\n        var offset = (this.options.snapHandle) ? 0 : (coords[axis] - position[axis]);\n        var link = relatedView.model;\n        var vertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.cloneDeep(link.vertices());\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn !== 'function') anchorFn = null;\n\n        const handleIndex = handle.options.index;\n\n        const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n        let indexOffset = 0;\n\n        // check if vertex before handle vertex exists\n        if (handleIndex - 1 >= 0) {\n            const v1 = vertexPoints[handleIndex - 1];\n            const v2 = vertexPoints[handleIndex];\n\n            const theta = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n                indexOffset++;\n                this.shiftHandleIndexes(1);\n            }\n        }\n\n        var vertex = vertices[index + indexOffset];\n        var nextVertex = vertices[index + 1 + indexOffset];\n\n        // check if vertex after handle vertex exists\n        if (handleIndex + 2 < vertexPoints.length) {\n            const v1 = vertexPoints[handleIndex + 1];\n            const v2 = vertexPoints[handleIndex + 2];\n\n            const theta = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                const isSingleVertex = data.originalVertices.length === 1;\n                const origVIndex = isSingleVertex ? 0 : handleIndex;\n                const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n                let nextVIndex = 1 + indexOffset;\n                vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n            }\n        }\n\n        // First Segment\n        var sourceView = relatedView.sourceView;\n        var sourceBBox = relatedView.sourceBBox;\n        var changeSourceAnchor = false;\n        var deleteSourceAnchor = false;\n        if (!vertex) {\n            vertex = relatedView.sourceAnchor.toJSON();\n            vertex[axis] = position[axis];\n            if (sourceBBox.containsPoint(vertex)) {\n                vertex[axis] = position[axis];\n                changeSourceAnchor = true;\n            } else {\n                // we left the area of the source magnet for the first time\n                vertices.unshift(vertex);\n                this.shiftHandleIndexes(1);\n                data.firstHandleShifted = true;\n                deleteSourceAnchor = true;\n            }\n        } else if (index === 0) {\n            if (sourceBBox.containsPoint(vertex)) {\n                vertices.shift();\n                this.shiftHandleIndexes(-1);\n                changeSourceAnchor = true;\n            } else {\n                vertex[axis] = position[axis];\n                deleteSourceAnchor = true;\n            }\n        } else {\n            vertex[axis] = position[axis];\n        }\n\n        if (anchorFn && sourceView) {\n            if (changeSourceAnchor) {\n                var sourceAnchorPosition = data.sourceAnchor.clone();\n                sourceAnchorPosition[axis] = position[axis];\n                var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n                this.resetAnchor('source', sourceAnchor);\n            }\n            if (deleteSourceAnchor) {\n                this.resetAnchor('source', data.sourceAnchorDef);\n            }\n        }\n\n        // Last segment\n        var targetView = relatedView.targetView;\n        var targetBBox = relatedView.targetBBox;\n        var changeTargetAnchor = false;\n        var deleteTargetAnchor = false;\n        if (!nextVertex) {\n            nextVertex = relatedView.targetAnchor.toJSON();\n            nextVertex[axis] = position[axis];\n            if (targetBBox.containsPoint(nextVertex)) {\n                changeTargetAnchor = true;\n            } else {\n                // we left the area of the target magnet for the first time\n                vertices.push(nextVertex);\n                deleteTargetAnchor = true;\n            }\n        } else if (index === vertices.length - 2) {\n            if (targetBBox.containsPoint(nextVertex)) {\n                vertices.pop();\n                changeTargetAnchor = true;\n            } else {\n                nextVertex[axis] = position[axis];\n                deleteTargetAnchor = true;\n            }\n        } else {\n            nextVertex[axis] = position[axis];\n        }\n\n        if (anchorFn && targetView) {\n            if (changeTargetAnchor) {\n                var targetAnchorPosition = data.targetAnchor.clone();\n                targetAnchorPosition[axis] = position[axis];\n                var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n                this.resetAnchor('target', targetAnchor);\n            }\n            if (deleteTargetAnchor) {\n                this.resetAnchor('target', data.targetAnchorDef);\n            }\n        }\n        if (vertices.some(v => !v)) {\n            // This can happen when the link is using a smart routing and the number of\n            // vertices is not the same as the number of route points.\n            throw new Error('Segments: incompatible router in use');\n        }\n        link.vertices(vertices, { ui: true, tool: this.cid });\n        this.updateHandle(handle, vertex, nextVertex, offset);\n        if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onHandleChangeStart: function(handle, evt) {\n        const { options, handles, relatedView: linkView } = this;\n        const { model, paper } = linkView;\n        var index = handle.options.index;\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            if (i !== index) handles[i].hide();\n        }\n        this.focus();\n        this.eventData(evt, {\n            sourceAnchor: linkView.sourceAnchor.clone(),\n            targetAnchor: linkView.targetAnchor.clone(),\n            sourceAnchorDef: _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.clone(model.prop(['source', 'anchor'])),\n            targetAnchorDef: _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.clone(model.prop(['target', 'anchor'])),\n            originalVertices: _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.cloneDeep(model.vertices()),\n            firstHandleShifted: false\n        });\n        model.startBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onHandleChangeEnd: function(_handle, evt) {\n        const { options, relatedView: linkView }= this;\n        const { paper, model } = linkView;\n        if (options.redundancyRemoval) {\n            linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        }\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent(evt);\n        const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.render();\n        this.blur();\n        model.stopBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n        linkView.checkMouseleave(normalizedEvent);\n    },\n    updateHandle: function(handle, vertex, nextVertex, offset) {\n        var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n        var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n        if (vertical || horizontal) {\n            var segmentLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Line(vertex, nextVertex);\n            var length = segmentLine.length();\n            if (length < this.options.segmentLengthThreshold) {\n                handle.hide();\n            } else {\n                var position = segmentLine.midpoint();\n                var axis = (vertical) ? 'x' : 'y';\n                position[axis] += offset || 0;\n                var angle = segmentLine.vector().vectorAngle(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(1, 0));\n                handle.position(position.x, position.y, angle, this.relatedView);\n                handle.show();\n                handle.options.axis = axis;\n            }\n        } else {\n            handle.hide();\n        }\n    },\n    onRemove: function() {\n        this.resetHandles();\n    }\n}, {\n    SegmentHandle: SegmentHandle // keep as class property\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9TZWdtZW50cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0w7QUFDVztBQUNGO0FBQ087QUFDTTs7QUFFckQsb0JBQW9CLGdEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixxQkFBcUIsb0RBQUM7QUFDdEI7O0FBRUE7QUFDQSx5Q0FBeUMsb0RBQUM7QUFDMUM7O0FBRUEsaURBQWlELCtDQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0saUJBQWlCLHVEQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw4Q0FBTTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsOENBQU07O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQiwwQ0FBMEM7QUFDMUQsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrREFBVTtBQUN2Qyw2QkFBNkIsa0RBQVU7QUFDdkMsOEJBQThCLHNEQUFjO0FBQzVDO0FBQ0EsU0FBUztBQUNULDJDQUEyQywwQkFBMEI7QUFDckU7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hELGdCQUFnQixlQUFlO0FBQy9CO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBLGdDQUFnQywyREFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsK0NBQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL1NlZ21lbnRzLm1qcz8zOWQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBtdmMgZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBUb29sVmlldyB9IGZyb20gJy4uL2RpYS9Ub29sVmlldy5tanMnO1xuaW1wb3J0IHsgZ2V0QW5jaG9yIH0gZnJvbSAnLi4vY2VsbFRvb2xzL2hlbHBlcnMubWpzJztcblxudmFyIFNlZ21lbnRIYW5kbGUgPSBtdmMuVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuICAgIGNsYXNzTmFtZTogJ21hcmtlci1zZWdtZW50JyxcbiAgICBldmVudHM6IHtcbiAgICAgICAgbW91c2Vkb3duOiAnb25Qb2ludGVyRG93bicsXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdvblBvaW50ZXJEb3duJ1xuICAgIH0sXG4gICAgZG9jdW1lbnRFdmVudHM6IHtcbiAgICAgICAgbW91c2Vtb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIHRvdWNobW92ZTogJ29uUG9pbnRlck1vdmUnLFxuICAgICAgICBtb3VzZXVwOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGVuZDogJ29uUG9pbnRlclVwJyxcbiAgICAgICAgdG91Y2hjYW5jZWw6ICdvblBvaW50ZXJVcCdcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0YWdOYW1lOiAnbGluZScsXG4gICAgICAgIHNlbGVjdG9yOiAnbGluZScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdzdHJva2UnOiAnIzMzMzM0RicsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdoYW5kbGUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnd2lkdGgnOiAyMCxcbiAgICAgICAgICAgICdoZWlnaHQnOiA4LFxuICAgICAgICAgICAgJ3gnOiAtMTAsXG4gICAgICAgICAgICAneSc6IC00LFxuICAgICAgICAgICAgJ3J4JzogNCxcbiAgICAgICAgICAgICdyeSc6IDQsXG4gICAgICAgICAgICAnZmlsbCc6ICcjMzMzMzRGJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMlxuICAgICAgICB9XG4gICAgfV0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oeCwgeSwgYW5nbGUsIHZpZXcpIHtcbiAgICAgICAgY29uc3QgeyBzY2FsZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBsZXQgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKS50cmFuc2xhdGUoeCwgeSkucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgaWYgKHNjYWxlKSBtYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuXG4gICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmNoaWxkTm9kZXMuaGFuZGxlO1xuICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKG1hdHJpeCkpO1xuICAgICAgICBoYW5kbGUuc2V0QXR0cmlidXRlKCdjdXJzb3InLCAoYW5nbGUgJSAxODAgPT09IDApID8gJ3Jvdy1yZXNpemUnIDogJ2NvbC1yZXNpemUnKTtcblxuICAgICAgICB2YXIgdmlld1BvaW50ID0gdmlldy5nZXRDbG9zZXN0UG9pbnQobmV3IGcuUG9pbnQoeCwgeSkpO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuY2hpbGROb2Rlcy5saW5lO1xuICAgICAgICBsaW5lLnNldEF0dHJpYnV0ZSgneDEnLCB4KTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3kxJywgeSk7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCd4MicsIHZpZXdQb2ludC54KTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3kyJywgdmlld1BvaW50LnkpO1xuICAgIH0sXG4gICAgb25Qb2ludGVyRG93bjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3VhcmQoZXZ0KSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzdGFydCcsIHRoaXMsIGV2dCk7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXBlci51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVEb2N1bWVudEV2ZW50cyhudWxsLCBldnQuZGF0YSk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2luZycsIHRoaXMsIGV2dCk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXBlci5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTplbmQnLCB0aGlzLCBldnQpO1xuICAgIH0sXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IFNlZ21lbnRzID0gVG9vbFZpZXcuZXh0ZW5kKHtcbiAgICBuYW1lOiAnc2VnbWVudHMnLFxuICAgIHByZWNpc2lvbjogLjUsXG4gICAgb3B0aW9uczoge1xuICAgICAgICBoYW5kbGVDbGFzczogU2VnbWVudEhhbmRsZSxcbiAgICAgICAgc2VnbWVudExlbmd0aFRocmVzaG9sZDogNDAsXG4gICAgICAgIHJlZHVuZGFuY3lSZW1vdmFsOiB0cnVlLFxuICAgICAgICBhbmNob3I6IGdldEFuY2hvcixcbiAgICAgICAgc25hcFJhZGl1czogMTAsXG4gICAgICAgIHNuYXBIYW5kbGU6IHRydWUsXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogdHJ1ZVxuICAgIH0sXG4gICAgaGFuZGxlczogbnVsbCxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzZXRIYW5kbGVzKCk7XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHJlbGF0ZWRWaWV3Lm1vZGVsLnZlcnRpY2VzKCk7XG4gICAgICAgIHZlcnRpY2VzLnVuc2hpZnQocmVsYXRlZFZpZXcuc291cmNlUG9pbnQpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKHJlbGF0ZWRWaWV3LnRhcmdldFBvaW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgbmV4dFZlcnRleCA9IHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLnJlbmRlckhhbmRsZSh2ZXJ0ZXgsIG5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgdGhpcy5zaW11bGF0ZVJlbGF0ZWRWaWV3KGhhbmRsZS5lbCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXMucHVzaChoYW5kbGUpO1xuICAgICAgICAgICAgaGFuZGxlLm9wdGlvbnMuaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVySGFuZGxlOiBmdW5jdGlvbih2ZXJ0ZXgsIG5leHRWZXJ0ZXgpIHtcbiAgICAgICAgdmFyIGhhbmRsZSA9IG5ldyAodGhpcy5vcHRpb25zLmhhbmRsZUNsYXNzKSh7XG4gICAgICAgICAgICBwYXBlcjogdGhpcy5wYXBlcixcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbnMuc2NhbGUsXG4gICAgICAgICAgICBndWFyZDogZXZ0ID0+IHRoaXMuZ3VhcmQoZXZ0KVxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlLnJlbmRlcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZShoYW5kbGUsIHZlcnRleCwgbmV4dFZlcnRleCk7XG4gICAgICAgIGhhbmRsZS52ZWwuYXBwZW5kVG8odGhpcy5lbCk7XG4gICAgICAgIHRoaXMuc3RhcnRIYW5kbGVMaXN0ZW5pbmcoaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnRIYW5kbGVMaXN0ZW5pbmc6IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICB0aGlzLmxpc3RlblRvKGhhbmRsZSwgJ2NoYW5nZTpzdGFydCcsIHRoaXMub25IYW5kbGVDaGFuZ2VTdGFydCk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oaGFuZGxlLCAnY2hhbmdpbmcnLCB0aGlzLm9uSGFuZGxlQ2hhbmdpbmcpO1xuICAgICAgICB0aGlzLmxpc3RlblRvKGhhbmRsZSwgJ2NoYW5nZTplbmQnLCB0aGlzLm9uSGFuZGxlQ2hhbmdlRW5kKTtcbiAgICB9LFxuICAgIHJlc2V0SGFuZGxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuICAgICAgICB0aGlzLmhhbmRsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShoYW5kbGVzKSkgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGhhbmRsZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBoYW5kbGVzW2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaGlmdEhhbmRsZUluZGV4ZXM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGhhbmRsZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSBoYW5kbGVzW2ldLm9wdGlvbnMuaW5kZXggKz0gdmFsdWU7XG4gICAgfSxcbiAgICByZXNldEFuY2hvcjogZnVuY3Rpb24odHlwZSwgYW5jaG9yKSB7XG4gICAgICAgIHZhciByZWxhdGVkTW9kZWwgPSB0aGlzLnJlbGF0ZWRWaWV3Lm1vZGVsO1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICByZWxhdGVkTW9kZWwucHJvcChbdHlwZSwgJ2FuY2hvciddLCBhbmNob3IsIHtcbiAgICAgICAgICAgICAgICByZXdyaXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvb2w6IHRoaXMuY2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbGF0ZWRNb2RlbC5yZW1vdmVQcm9wKFt0eXBlLCAnYW5jaG9yJ10sIHtcbiAgICAgICAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b29sOiB0aGlzLmNpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNuYXBIYW5kbGU6IGZ1bmN0aW9uKGhhbmRsZSwgcG9zaXRpb24sIGRhdGEpIHtcblxuICAgICAgICB2YXIgaW5kZXggPSBoYW5kbGUub3B0aW9ucy5pbmRleDtcbiAgICAgICAgdmFyIGxpbmtWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIGxpbmsgPSBsaW5rVmlldy5tb2RlbDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbGluay52ZXJ0aWNlcygpO1xuICAgICAgICB2YXIgYXhpcyA9IGhhbmRsZS5vcHRpb25zLmF4aXM7XG4gICAgICAgIHZhciBwcmV2ID0gdmVydGljZXNbaW5kZXggLSAyXSB8fCBkYXRhLnNvdXJjZUFuY2hvcjtcbiAgICAgICAgdmFyIG5leHQgPSB2ZXJ0aWNlc1tpbmRleCArIDFdIHx8IGRhdGEudGFyZ2V0QW5jaG9yO1xuICAgICAgICB2YXIgc25hcFJhZGl1cyA9IHRoaXMub3B0aW9ucy5zbmFwUmFkaXVzO1xuICAgICAgICBpZiAoTWF0aC5hYnMocG9zaXRpb25bYXhpc10gLSBwcmV2W2F4aXNdKSA8IHNuYXBSYWRpdXMpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uW2F4aXNdID0gcHJldltheGlzXTtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhwb3NpdGlvbltheGlzXSAtIG5leHRbYXhpc10pIDwgc25hcFJhZGl1cykge1xuICAgICAgICAgICAgcG9zaXRpb25bYXhpc10gPSBuZXh0W2F4aXNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgb25IYW5kbGVDaGFuZ2luZzogZnVuY3Rpb24oaGFuZGxlLCBldnQpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHBhcGVyID0gcmVsYXRlZFZpZXcucGFwZXI7XG4gICAgICAgIHZhciBpbmRleCA9IGhhbmRsZS5vcHRpb25zLmluZGV4IC0gMTtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHBhcGVyLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5zbmFwSGFuZGxlKGhhbmRsZSwgY29vcmRzLmNsb25lKCksIGRhdGEpO1xuICAgICAgICB2YXIgYXhpcyA9IGhhbmRsZS5vcHRpb25zLmF4aXM7XG4gICAgICAgIHZhciBvZmZzZXQgPSAodGhpcy5vcHRpb25zLnNuYXBIYW5kbGUpID8gMCA6IChjb29yZHNbYXhpc10gLSBwb3NpdGlvbltheGlzXSk7XG4gICAgICAgIHZhciBsaW5rID0gcmVsYXRlZFZpZXcubW9kZWw7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHV0aWwuY2xvbmVEZWVwKGxpbmsudmVydGljZXMoKSk7XG4gICAgICAgIHZhciBhbmNob3JGbiA9IHRoaXMub3B0aW9ucy5hbmNob3I7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yRm4gIT09ICdmdW5jdGlvbicpIGFuY2hvckZuID0gbnVsbDtcblxuICAgICAgICBjb25zdCBoYW5kbGVJbmRleCA9IGhhbmRsZS5vcHRpb25zLmluZGV4O1xuXG4gICAgICAgIGNvbnN0IHZlcnRleFBvaW50cyA9IFtyZWxhdGVkVmlldy5zb3VyY2VQb2ludC5jbG9uZSgpLCAuLi52ZXJ0aWNlcywgcmVsYXRlZFZpZXcudGFyZ2V0UG9pbnQuY2xvbmUoKV07XG4gICAgICAgIGxldCBpbmRleE9mZnNldCA9IDA7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdmVydGV4IGJlZm9yZSBoYW5kbGUgdmVydGV4IGV4aXN0c1xuICAgICAgICBpZiAoaGFuZGxlSW5kZXggLSAxID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHYxID0gdmVydGV4UG9pbnRzW2hhbmRsZUluZGV4IC0gMV07XG4gICAgICAgICAgICBjb25zdCB2MiA9IHZlcnRleFBvaW50c1toYW5kbGVJbmRleF07XG5cbiAgICAgICAgICAgIGNvbnN0IHRoZXRhID0gbmV3IGcuTGluZSh2MSwgdjIpLnZlY3RvcigpLnRoZXRhKCk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIG9ubHkgbm9uLW9ydGhvZ29uYWwgc2VnbWVudHNcbiAgICAgICAgICAgIGlmICh0aGV0YSAlIDkwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMuc3BsaWNlKGhhbmRsZUluZGV4IC0gMSwgMCwgZGF0YS5vcmlnaW5hbFZlcnRpY2VzW2hhbmRsZUluZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgIGluZGV4T2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGlmdEhhbmRsZUluZGV4ZXMoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaW5kZXggKyBpbmRleE9mZnNldF07XG4gICAgICAgIHZhciBuZXh0VmVydGV4ID0gdmVydGljZXNbaW5kZXggKyAxICsgaW5kZXhPZmZzZXRdO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHZlcnRleCBhZnRlciBoYW5kbGUgdmVydGV4IGV4aXN0c1xuICAgICAgICBpZiAoaGFuZGxlSW5kZXggKyAyIDwgdmVydGV4UG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdjEgPSB2ZXJ0ZXhQb2ludHNbaGFuZGxlSW5kZXggKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gdmVydGV4UG9pbnRzW2hhbmRsZUluZGV4ICsgMl07XG5cbiAgICAgICAgICAgIGNvbnN0IHRoZXRhID0gbmV3IGcuTGluZSh2MSwgdjIpLnZlY3RvcigpLnRoZXRhKCk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIG9ubHkgbm9uLW9ydGhvZ29uYWwgc2VnbWVudHNcbiAgICAgICAgICAgIGlmICh0aGV0YSAlIDkwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW5nbGVWZXJ0ZXggPSBkYXRhLm9yaWdpbmFsVmVydGljZXMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdWSW5kZXggPSBpc1NpbmdsZVZlcnRleCA/IDAgOiBoYW5kbGVJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsT2Zmc2V0ID0gZGF0YS5maXJzdEhhbmRsZVNoaWZ0ZWQgJiYgIWlzU2luZ2xlVmVydGV4ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRWSW5kZXggPSAxICsgaW5kZXhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmVydGljZXMuc3BsaWNlKGhhbmRsZUluZGV4ICsgbmV4dFZJbmRleCwgMCwgZGF0YS5vcmlnaW5hbFZlcnRpY2VzW29yaWdWSW5kZXggLSBhZGRpdGlvbmFsT2Zmc2V0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCBTZWdtZW50XG4gICAgICAgIHZhciBzb3VyY2VWaWV3ID0gcmVsYXRlZFZpZXcuc291cmNlVmlldztcbiAgICAgICAgdmFyIHNvdXJjZUJCb3ggPSByZWxhdGVkVmlldy5zb3VyY2VCQm94O1xuICAgICAgICB2YXIgY2hhbmdlU291cmNlQW5jaG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBkZWxldGVTb3VyY2VBbmNob3IgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIHZlcnRleCA9IHJlbGF0ZWRWaWV3LnNvdXJjZUFuY2hvci50b0pTT04oKTtcbiAgICAgICAgICAgIHZlcnRleFtheGlzXSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUJCb3guY29udGFpbnNQb2ludCh2ZXJ0ZXgpKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4W2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICAgICAgY2hhbmdlU291cmNlQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbGVmdCB0aGUgYXJlYSBvZiB0aGUgc291cmNlIG1hZ25ldCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy51bnNoaWZ0KHZlcnRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGlmdEhhbmRsZUluZGV4ZXMoMSk7XG4gICAgICAgICAgICAgICAgZGF0YS5maXJzdEhhbmRsZVNoaWZ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVNvdXJjZUFuY2hvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodmVydGV4KSkge1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGlmdEhhbmRsZUluZGV4ZXMoLTEpO1xuICAgICAgICAgICAgICAgIGNoYW5nZVNvdXJjZUFuY2hvciA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnRleFtheGlzXSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVNvdXJjZUFuY2hvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZXJ0ZXhbYXhpc10gPSBwb3NpdGlvbltheGlzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmNob3JGbiAmJiBzb3VyY2VWaWV3KSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlU291cmNlQW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUFuY2hvclBvc2l0aW9uID0gZGF0YS5zb3VyY2VBbmNob3IuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VBbmNob3JQb3NpdGlvbltheGlzXSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VBbmNob3IgPSBhbmNob3JGbi5jYWxsKHJlbGF0ZWRWaWV3LCBzb3VyY2VBbmNob3JQb3NpdGlvbiwgc291cmNlVmlldywgcmVsYXRlZFZpZXcuc291cmNlTWFnbmV0IHx8IHNvdXJjZVZpZXcuZWwsICdzb3VyY2UnLCByZWxhdGVkVmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFuY2hvcignc291cmNlJywgc291cmNlQW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWxldGVTb3VyY2VBbmNob3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QW5jaG9yKCdzb3VyY2UnLCBkYXRhLnNvdXJjZUFuY2hvckRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYXN0IHNlZ21lbnRcbiAgICAgICAgdmFyIHRhcmdldFZpZXcgPSByZWxhdGVkVmlldy50YXJnZXRWaWV3O1xuICAgICAgICB2YXIgdGFyZ2V0QkJveCA9IHJlbGF0ZWRWaWV3LnRhcmdldEJCb3g7XG4gICAgICAgIHZhciBjaGFuZ2VUYXJnZXRBbmNob3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlbGV0ZVRhcmdldEFuY2hvciA9IGZhbHNlO1xuICAgICAgICBpZiAoIW5leHRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIG5leHRWZXJ0ZXggPSByZWxhdGVkVmlldy50YXJnZXRBbmNob3IudG9KU09OKCk7XG4gICAgICAgICAgICBuZXh0VmVydGV4W2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICBpZiAodGFyZ2V0QkJveC5jb250YWluc1BvaW50KG5leHRWZXJ0ZXgpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVGFyZ2V0QW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgbGVmdCB0aGUgYXJlYSBvZiB0aGUgdGFyZ2V0IG1hZ25ldCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKG5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZVRhcmdldEFuY2hvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHZlcnRpY2VzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXRCQm94LmNvbnRhaW5zUG9pbnQobmV4dFZlcnRleCkpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUYXJnZXRBbmNob3IgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0VmVydGV4W2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICAgICAgZGVsZXRlVGFyZ2V0QW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRWZXJ0ZXhbYXhpc10gPSBwb3NpdGlvbltheGlzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmNob3JGbiAmJiB0YXJnZXRWaWV3KSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlVGFyZ2V0QW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEFuY2hvclBvc2l0aW9uID0gZGF0YS50YXJnZXRBbmNob3IuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3JQb3NpdGlvbltheGlzXSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRBbmNob3IgPSBhbmNob3JGbi5jYWxsKHJlbGF0ZWRWaWV3LCB0YXJnZXRBbmNob3JQb3NpdGlvbiwgdGFyZ2V0VmlldywgcmVsYXRlZFZpZXcudGFyZ2V0TWFnbmV0IHx8IHRhcmdldFZpZXcuZWwsICd0YXJnZXQnLCByZWxhdGVkVmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEFuY2hvcigndGFyZ2V0JywgdGFyZ2V0QW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWxldGVUYXJnZXRBbmNob3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QW5jaG9yKCd0YXJnZXQnLCBkYXRhLnRhcmdldEFuY2hvckRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRpY2VzLnNvbWUodiA9PiAhdikpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSBsaW5rIGlzIHVzaW5nIGEgc21hcnQgcm91dGluZyBhbmQgdGhlIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gdmVydGljZXMgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2Ygcm91dGUgcG9pbnRzLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50czogaW5jb21wYXRpYmxlIHJvdXRlciBpbiB1c2UnKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLnZlcnRpY2VzKHZlcnRpY2VzLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGUoaGFuZGxlLCB2ZXJ0ZXgsIG5leHRWZXJ0ZXgsIG9mZnNldCk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIHJlbGF0ZWRWaWV3Lm5vdGlmeVBvaW50ZXJtb3ZlKG5vcm1hbGl6ZWRFdmVudCwgY29vcmRzLngsIGNvb3Jkcy55KTtcbiAgICB9LFxuICAgIG9uSGFuZGxlQ2hhbmdlU3RhcnQ6IGZ1bmN0aW9uKGhhbmRsZSwgZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgaGFuZGxlcywgcmVsYXRlZFZpZXc6IGxpbmtWaWV3IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG1vZGVsLCBwYXBlciB9ID0gbGlua1ZpZXc7XG4gICAgICAgIHZhciBpbmRleCA9IGhhbmRsZS5vcHRpb25zLmluZGV4O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGFuZGxlcykpIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoYW5kbGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4KSBoYW5kbGVzW2ldLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwge1xuICAgICAgICAgICAgc291cmNlQW5jaG9yOiBsaW5rVmlldy5zb3VyY2VBbmNob3IuY2xvbmUoKSxcbiAgICAgICAgICAgIHRhcmdldEFuY2hvcjogbGlua1ZpZXcudGFyZ2V0QW5jaG9yLmNsb25lKCksXG4gICAgICAgICAgICBzb3VyY2VBbmNob3JEZWY6IHV0aWwuY2xvbmUobW9kZWwucHJvcChbJ3NvdXJjZScsICdhbmNob3InXSkpLFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yRGVmOiB1dGlsLmNsb25lKG1vZGVsLnByb3AoWyd0YXJnZXQnLCAnYW5jaG9yJ10pKSxcbiAgICAgICAgICAgIG9yaWdpbmFsVmVydGljZXM6IHV0aWwuY2xvbmVEZWVwKG1vZGVsLnZlcnRpY2VzKCkpLFxuICAgICAgICAgICAgZmlyc3RIYW5kbGVTaGlmdGVkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgbW9kZWwuc3RhcnRCYXRjaCgnc2VnbWVudC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIGxpbmtWaWV3Lm5vdGlmeVBvaW50ZXJkb3duKC4uLnBhcGVyLmdldFBvaW50ZXJBcmdzKGV2dCkpO1xuICAgIH0sXG4gICAgb25IYW5kbGVDaGFuZ2VFbmQ6IGZ1bmN0aW9uKF9oYW5kbGUsIGV2dCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHJlbGF0ZWRWaWV3OiBsaW5rVmlldyB9PSB0aGlzO1xuICAgICAgICBjb25zdCB7IHBhcGVyLCBtb2RlbCB9ID0gbGlua1ZpZXc7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZHVuZGFuY3lSZW1vdmFsKSB7XG4gICAgICAgICAgICBsaW5rVmlldy5yZW1vdmVSZWR1bmRhbnRMaW5lYXJWZXJ0aWNlcyh7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3JtYWxpemVkRXZlbnQgPSB1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHBhcGVyLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIG1vZGVsLnN0b3BCYXRjaCgnc2VnbWVudC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIGxpbmtWaWV3Lm5vdGlmeVBvaW50ZXJ1cChub3JtYWxpemVkRXZlbnQsIGNvb3Jkcy54LCBjb29yZHMueSk7XG4gICAgICAgIGxpbmtWaWV3LmNoZWNrTW91c2VsZWF2ZShub3JtYWxpemVkRXZlbnQpO1xuICAgIH0sXG4gICAgdXBkYXRlSGFuZGxlOiBmdW5jdGlvbihoYW5kbGUsIHZlcnRleCwgbmV4dFZlcnRleCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB2ZXJ0aWNhbCA9IE1hdGguYWJzKHZlcnRleC54IC0gbmV4dFZlcnRleC54KSA8IHRoaXMucHJlY2lzaW9uO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IE1hdGguYWJzKHZlcnRleC55IC0gbmV4dFZlcnRleC55KSA8IHRoaXMucHJlY2lzaW9uO1xuICAgICAgICBpZiAodmVydGljYWwgfHwgaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRMaW5lID0gbmV3IGcuTGluZSh2ZXJ0ZXgsIG5leHRWZXJ0ZXgpO1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNlZ21lbnRMaW5lLmxlbmd0aCgpO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IHRoaXMub3B0aW9ucy5zZWdtZW50TGVuZ3RoVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gc2VnbWVudExpbmUubWlkcG9pbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9ICh2ZXJ0aWNhbCkgPyAneCcgOiAneSc7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25bYXhpc10gKz0gb2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gc2VnbWVudExpbmUudmVjdG9yKCkudmVjdG9yQW5nbGUobmV3IGcuUG9pbnQoMSwgMCkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZS5wb3NpdGlvbihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBhbmdsZSwgdGhpcy5yZWxhdGVkVmlldyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlLnNob3coKTtcbiAgICAgICAgICAgICAgICBoYW5kbGUub3B0aW9ucy5heGlzID0gYXhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNldEhhbmRsZXMoKTtcbiAgICB9XG59LCB7XG4gICAgU2VnbWVudEhhbmRsZTogU2VnbWVudEhhbmRsZSAvLyBrZWVwIGFzIGNsYXNzIHByb3BlcnR5XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkTools/Segments.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkTools/Vertices.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Vertices.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vertices: () => (/* binding */ Vertices)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\n\n\n\n// Vertex Handles\nvar VertexHandle = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: 'circle',\n    svgElement: true,\n    className: 'marker-vertex',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onDoubleClick',\n        dbltap: 'onDoubleClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    attributes: {\n        'r': 6,\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move'\n    },\n    position: function(x, y) {\n        const { vel, options } = this;\n        const { scale } = options;\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix().translate(x, y);\n        if (scale) matrix = matrix.scale(scale);\n        vel.transform(matrix, { absolute: true });\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n        this.trigger('will-change', this, evt);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onDoubleClick: function(evt) {\n        this.trigger('remove', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.trigger('changed', this, evt);\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n    }\n});\n\nconst Vertices = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_2__.ToolView.extend({\n    name: 'vertices',\n    options: {\n        handleClass: VertexHandle,\n        snapRadius: 20,\n        redundancyRemoval: true,\n        vertexAdding: true,\n        // vertexRemoving: true,\n        // vertexMoving: true,\n        stopPropagation: true,\n        scale: null\n    },\n    children: [{\n        tagName: 'path',\n        selector: 'connection',\n        className: 'joint-vertices-path',\n        attributes: {\n            'fill': 'none',\n            'stroke': 'transparent',\n            'stroke-width': 10,\n            'cursor': 'cell'\n        }\n    }],\n    handles: null,\n    interactiveLinkNode: null,\n    events: {\n        'mousedown .joint-vertices-path': 'onPathPointerDown',\n        'touchstart .joint-vertices-path': 'onPathPointerDown'\n    },\n    linkEvents: {\n        mousedown: 'onLinkPointerDown',\n        touchstart: 'onLinkPointerDown'\n    },\n    onRender: function() {\n        const { vertexAdding } = this.options;\n        if (vertexAdding) {\n            const { interactiveLinkNode = null } = vertexAdding;\n            if (interactiveLinkNode) {\n                this.delegateLinkEvents(interactiveLinkNode);\n            } else {\n                this.renderChildren();\n                this.updatePath();\n            }\n        }\n        this.resetHandles();\n        this.renderHandles();\n        return this;\n    },\n    delegateLinkEvents: function(selector) {\n        this.undelegateLinkEvents();\n        const el = this.relatedView.findNode(selector);\n        if (!el) {\n            console.warn(`Interactive link node \"${selector}\" not found.`);\n            return;\n        }\n        el.classList.add('joint-vertices-path');\n        this.interactiveLinkNode = el;\n        this.delegateElementEvents(el, this.linkEvents);\n    },\n    undelegateLinkEvents: function() {\n        const el = this.interactiveLinkNode;\n        if (!el) return;\n        this.undelegateElementEvents(el);\n        el.classList.remove('joint-vertices-path');\n        this.interactiveLinkNode = null;\n    },\n    update: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        if (vertices.length === this.handles.length) {\n            this.updateHandles();\n        } else {\n            this.resetHandles();\n            this.renderHandles();\n        }\n        if (this.options.vertexAdding) {\n            this.updatePath();\n        }\n        return this;\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    renderHandles: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        for (var i = 0, n = vertices.length; i < n; i++) {\n            var vertex = vertices[i];\n            var handle = new (this.options.handleClass)({\n                index: i,\n                paper: this.paper,\n                scale: this.options.scale,\n                guard: evt => this.guard(evt)\n            });\n            handle.render();\n            handle.position(vertex.x, vertex.y);\n            this.simulateRelatedView(handle.el);\n            handle.vel.appendTo(this.el);\n            this.handles.push(handle);\n            this.startHandleListening(handle);\n        }\n    },\n    updateHandles: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        for (var i = 0, n = vertices.length; i < n; i++) {\n            var vertex = vertices[i];\n            var handle = this.handles[i];\n            if (!handle) return;\n            handle.position(vertex.x, vertex.y);\n        }\n    },\n    updatePath: function() {\n        if (this.interactiveLinkNode) return;\n        const connection = this.childNodes.connection;\n        if (connection) connection.setAttribute('d', this.relatedView.getSerializedConnection());\n    },\n    startHandleListening: function(handle) {\n        const { vertexRemoving = true, vertexMoving = true } = this.options;\n        if (vertexMoving) {\n            this.listenTo(handle, 'will-change', this.onHandleWillChange);\n            this.listenTo(handle, 'changing', this.onHandleChanging);\n            this.listenTo(handle, 'changed', this.onHandleChanged);\n        }\n        if (vertexRemoving) {\n            this.listenTo(handle, 'remove', this.onHandleRemove);\n        }\n    },\n    getNeighborPoints: function(index) {\n        var linkView = this.relatedView;\n        var vertices = linkView.model.vertices();\n        var prev = (index > 0) ? vertices[index - 1] : linkView.sourceAnchor;\n        var next = (index < vertices.length - 1) ? vertices[index + 1] : linkView.targetAnchor;\n        return {\n            prev: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(prev),\n            next: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(next)\n        };\n    },\n    onHandleWillChange: function(_handle, evt) {\n        this.focus();\n        const { relatedView, options } = this;\n        relatedView.model.startBatch('vertex-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));\n    },\n    onHandleChanging: function(handle, evt) {\n        const { options, relatedView: linkView } = this;\n        var index = handle.options.index;\n        var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);\n        var vertex = { x, y };\n        this.snapVertex(vertex, index);\n        linkView.model.vertex(index, vertex, { ui: true, tool: this.cid });\n        handle.position(vertex.x, vertex.y);\n        if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);\n    },\n    onHandleChanged: function(_handle, evt) {\n        const { options, relatedView: linkView } = this;\n        if (options.vertexAdding) this.updatePath();\n        if (!options.redundancyRemoval) {\n            linkView.checkMouseleave(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeEvent(evt));\n            return;\n        }\n        var verticesRemoved = linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        if (verticesRemoved) this.render();\n        this.blur();\n        linkView.model.stopBatch('vertex-move', { ui: true, tool: this.cid });\n        if (this.eventData(evt).vertexAdded) {\n            linkView.model.stopBatch('vertex-add', { ui: true, tool: this.cid });\n        }\n        var [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);\n        linkView.checkMouseleave(normalizedEvt);\n    },\n    snapVertex: function(vertex, index) {\n        var snapRadius = this.options.snapRadius;\n        if (snapRadius > 0) {\n            var neighbors = this.getNeighborPoints(index);\n            var prev = neighbors.prev;\n            var next = neighbors.next;\n            if (Math.abs(vertex.x - prev.x) < snapRadius) {\n                vertex.x = prev.x;\n            } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n                vertex.x = next.x;\n            }\n            if (Math.abs(vertex.y - prev.y) < snapRadius) {\n                vertex.y = neighbors.prev.y;\n            } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n                vertex.y = next.y;\n            }\n        }\n    },\n    onHandleRemove: function(handle, evt) {\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        linkView.model.removeVertex(index, { ui: true });\n        if (this.options.vertexAdding) this.updatePath();\n        linkView.checkMouseleave(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeEvent(evt));\n    },\n    onPathPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeEvent(evt);\n        var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n        var relatedView = this.relatedView;\n        relatedView.model.startBatch('vertex-add', { ui: true, tool: this.cid });\n        var index = relatedView.getVertexIndex(vertex.x, vertex.y);\n        this.snapVertex(vertex, index);\n        relatedView.model.insertVertex(index, vertex, { ui: true, tool: this.cid });\n        this.update();\n        var handle = this.handles[index];\n        this.eventData(normalizedEvent, { vertexAdded: true });\n        handle.onPointerDown(normalizedEvent);\n    },\n    onLinkPointerDown: function(evt) {\n        this.relatedView.preventDefaultInteraction(evt);\n        this.onPathPointerDown(evt);\n    },\n    onRemove: function() {\n        this.resetHandles();\n        this.undelegateLinkEvents();\n    }\n}, {\n    VertexHandle: VertexHandle // keep as class property\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9WZXJ0aWNlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ007QUFDRjtBQUNPO0FBQ2hCOzs7QUFHL0I7QUFDQSxtQkFBbUIsZ0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLFFBQVE7QUFDeEIscUJBQXFCLG9EQUFDO0FBQ3RCO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNLGlCQUFpQix1REFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQiw2Q0FBNkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQU87QUFDN0Isc0JBQXNCLCtDQUFPO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLHNEQUFzRCwwQkFBMEI7QUFDaEY7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwrQ0FBK0MsMEJBQTBCO0FBQ3pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQSxxQ0FBcUMsMkRBQW1CO0FBQ3hEO0FBQ0E7QUFDQSx1RUFBdUUsMEJBQTBCO0FBQ2pHO0FBQ0E7QUFDQSxrREFBa0QsMEJBQTBCO0FBQzVFO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBLGlDQUFpQywyREFBbUI7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJEQUFtQjtBQUNqRDtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0Esd0RBQXdELDBCQUEwQjtBQUNsRjtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL1ZlcnRpY2VzLm1qcz8wMGRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBtdmMgZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBUb29sVmlldyB9IGZyb20gJy4uL2RpYS9Ub29sVmlldy5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuXG5cbi8vIFZlcnRleCBIYW5kbGVzXG52YXIgVmVydGV4SGFuZGxlID0gbXZjLlZpZXcuZXh0ZW5kKHtcbiAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuICAgIGNsYXNzTmFtZTogJ21hcmtlci12ZXJ0ZXgnLFxuICAgIGV2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgdG91Y2hzdGFydDogJ29uUG9pbnRlckRvd24nLFxuICAgICAgICBkYmxjbGljazogJ29uRG91YmxlQ2xpY2snLFxuICAgICAgICBkYmx0YXA6ICdvbkRvdWJsZUNsaWNrJ1xuICAgIH0sXG4gICAgZG9jdW1lbnRFdmVudHM6IHtcbiAgICAgICAgbW91c2Vtb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIHRvdWNobW92ZTogJ29uUG9pbnRlck1vdmUnLFxuICAgICAgICBtb3VzZXVwOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGVuZDogJ29uUG9pbnRlclVwJyxcbiAgICAgICAgdG91Y2hjYW5jZWw6ICdvblBvaW50ZXJVcCdcbiAgICB9LFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ3InOiA2LFxuICAgICAgICAnZmlsbCc6ICcjMzMzMzRGJyxcbiAgICAgICAgJ3N0cm9rZSc6ICcjRkZGRkZGJyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICdjdXJzb3InOiAnbW92ZSdcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGNvbnN0IHsgdmVsLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKS50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIGlmIChzY2FsZSkgbWF0cml4ID0gbWF0cml4LnNjYWxlKHNjYWxlKTtcbiAgICAgICAgdmVsLnRyYW5zZm9ybShtYXRyaXgsIHsgYWJzb2x1dGU6IHRydWUgfSk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ndWFyZChldnQpKSByZXR1cm47XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXBlci51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVEb2N1bWVudEV2ZW50cyhudWxsLCBldnQuZGF0YSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignd2lsbC1jaGFuZ2UnLCB0aGlzLCBldnQpO1xuICAgIH0sXG4gICAgb25Qb2ludGVyTW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdpbmcnLCB0aGlzLCBldnQpO1xuICAgIH0sXG4gICAgb25Eb3VibGVDbGljazogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVtb3ZlJywgdGhpcywgZXZ0KTtcbiAgICB9LFxuICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgdGhpcywgZXZ0KTtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhcGVyLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBWZXJ0aWNlcyA9IFRvb2xWaWV3LmV4dGVuZCh7XG4gICAgbmFtZTogJ3ZlcnRpY2VzJyxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGhhbmRsZUNsYXNzOiBWZXJ0ZXhIYW5kbGUsXG4gICAgICAgIHNuYXBSYWRpdXM6IDIwLFxuICAgICAgICByZWR1bmRhbmN5UmVtb3ZhbDogdHJ1ZSxcbiAgICAgICAgdmVydGV4QWRkaW5nOiB0cnVlLFxuICAgICAgICAvLyB2ZXJ0ZXhSZW1vdmluZzogdHJ1ZSxcbiAgICAgICAgLy8gdmVydGV4TW92aW5nOiB0cnVlLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IHRydWUsXG4gICAgICAgIHNjYWxlOiBudWxsXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ2Nvbm5lY3Rpb24nLFxuICAgICAgICBjbGFzc05hbWU6ICdqb2ludC12ZXJ0aWNlcy1wYXRoJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAxMCxcbiAgICAgICAgICAgICdjdXJzb3InOiAnY2VsbCdcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIGhhbmRsZXM6IG51bGwsXG4gICAgaW50ZXJhY3RpdmVMaW5rTm9kZTogbnVsbCxcbiAgICBldmVudHM6IHtcbiAgICAgICAgJ21vdXNlZG93biAuam9pbnQtdmVydGljZXMtcGF0aCc6ICdvblBhdGhQb2ludGVyRG93bicsXG4gICAgICAgICd0b3VjaHN0YXJ0IC5qb2ludC12ZXJ0aWNlcy1wYXRoJzogJ29uUGF0aFBvaW50ZXJEb3duJ1xuICAgIH0sXG4gICAgbGlua0V2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246ICdvbkxpbmtQb2ludGVyRG93bicsXG4gICAgICAgIHRvdWNoc3RhcnQ6ICdvbkxpbmtQb2ludGVyRG93bidcbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyB2ZXJ0ZXhBZGRpbmcgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHZlcnRleEFkZGluZykge1xuICAgICAgICAgICAgY29uc3QgeyBpbnRlcmFjdGl2ZUxpbmtOb2RlID0gbnVsbCB9ID0gdmVydGV4QWRkaW5nO1xuICAgICAgICAgICAgaWYgKGludGVyYWN0aXZlTGlua05vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlTGlua0V2ZW50cyhpbnRlcmFjdGl2ZUxpbmtOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRIYW5kbGVzKCk7XG4gICAgICAgIHRoaXMucmVuZGVySGFuZGxlcygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlbGVnYXRlTGlua0V2ZW50czogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlTGlua0V2ZW50cygpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVsYXRlZFZpZXcuZmluZE5vZGUoc2VsZWN0b3IpO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludGVyYWN0aXZlIGxpbmsgbm9kZSBcIiR7c2VsZWN0b3J9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2pvaW50LXZlcnRpY2VzLXBhdGgnKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZUxpbmtOb2RlID0gZWw7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFbGVtZW50RXZlbnRzKGVsLCB0aGlzLmxpbmtFdmVudHMpO1xuICAgIH0sXG4gICAgdW5kZWxlZ2F0ZUxpbmtFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuaW50ZXJhY3RpdmVMaW5rTm9kZTtcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVFbGVtZW50RXZlbnRzKGVsKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnam9pbnQtdmVydGljZXMtcGF0aCcpO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlTGlua05vZGUgPSBudWxsO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gcmVsYXRlZFZpZXcubW9kZWwudmVydGljZXMoKTtcbiAgICAgICAgaWYgKHZlcnRpY2VzLmxlbmd0aCA9PT0gdGhpcy5oYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SGFuZGxlcygpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJIYW5kbGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0ZXhBZGRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVzZXRIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhhbmRsZXMpKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaGFuZGxlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGhhbmRsZXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdmVydGljZXMgPSByZWxhdGVkVmlldy5tb2RlbC52ZXJ0aWNlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IG5ldyAodGhpcy5vcHRpb25zLmhhbmRsZUNsYXNzKSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgcGFwZXI6IHRoaXMucGFwZXIsXG4gICAgICAgICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9ucy5zY2FsZSxcbiAgICAgICAgICAgICAgICBndWFyZDogZXZ0ID0+IHRoaXMuZ3VhcmQoZXZ0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGUucmVuZGVyKCk7XG4gICAgICAgICAgICBoYW5kbGUucG9zaXRpb24odmVydGV4LngsIHZlcnRleC55KTtcbiAgICAgICAgICAgIHRoaXMuc2ltdWxhdGVSZWxhdGVkVmlldyhoYW5kbGUuZWwpO1xuICAgICAgICAgICAgaGFuZGxlLnZlbC5hcHBlbmRUbyh0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SGFuZGxlTGlzdGVuaW5nKGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZUhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdmVydGljZXMgPSByZWxhdGVkVmlldy5tb2RlbC52ZXJ0aWNlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuaGFuZGxlc1tpXTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlKSByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGUucG9zaXRpb24odmVydGV4LngsIHZlcnRleC55KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyYWN0aXZlTGlua05vZGUpIHJldHVybjtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuY2hpbGROb2Rlcy5jb25uZWN0aW9uO1xuICAgICAgICBpZiAoY29ubmVjdGlvbikgY29ubmVjdGlvbi5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnJlbGF0ZWRWaWV3LmdldFNlcmlhbGl6ZWRDb25uZWN0aW9uKCkpO1xuICAgIH0sXG4gICAgc3RhcnRIYW5kbGVMaXN0ZW5pbmc6IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICBjb25zdCB7IHZlcnRleFJlbW92aW5nID0gdHJ1ZSwgdmVydGV4TW92aW5nID0gdHJ1ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAodmVydGV4TW92aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGhhbmRsZSwgJ3dpbGwtY2hhbmdlJywgdGhpcy5vbkhhbmRsZVdpbGxDaGFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhoYW5kbGUsICdjaGFuZ2luZycsIHRoaXMub25IYW5kbGVDaGFuZ2luZyk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGhhbmRsZSwgJ2NoYW5nZWQnLCB0aGlzLm9uSGFuZGxlQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRleFJlbW92aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGhhbmRsZSwgJ3JlbW92ZScsIHRoaXMub25IYW5kbGVSZW1vdmUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXROZWlnaGJvclBvaW50czogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGxpbmtWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gbGlua1ZpZXcubW9kZWwudmVydGljZXMoKTtcbiAgICAgICAgdmFyIHByZXYgPSAoaW5kZXggPiAwKSA/IHZlcnRpY2VzW2luZGV4IC0gMV0gOiBsaW5rVmlldy5zb3VyY2VBbmNob3I7XG4gICAgICAgIHZhciBuZXh0ID0gKGluZGV4IDwgdmVydGljZXMubGVuZ3RoIC0gMSkgPyB2ZXJ0aWNlc1tpbmRleCArIDFdIDogbGlua1ZpZXcudGFyZ2V0QW5jaG9yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJldjogbmV3IGcuUG9pbnQocHJldiksXG4gICAgICAgICAgICBuZXh0OiBuZXcgZy5Qb2ludChuZXh0KVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgb25IYW5kbGVXaWxsQ2hhbmdlOiBmdW5jdGlvbihfaGFuZGxlLCBldnQpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3LCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICByZWxhdGVkVmlldy5tb2RlbC5zdGFydEJhdGNoKCd2ZXJ0ZXgtbW92ZScsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcFByb3BhZ2F0aW9uKSByZWxhdGVkVmlldy5ub3RpZnlQb2ludGVyZG93biguLi5yZWxhdGVkVmlldy5wYXBlci5nZXRQb2ludGVyQXJncyhldnQpKTtcbiAgICB9LFxuICAgIG9uSGFuZGxlQ2hhbmdpbmc6IGZ1bmN0aW9uKGhhbmRsZSwgZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcmVsYXRlZFZpZXc6IGxpbmtWaWV3IH0gPSB0aGlzO1xuICAgICAgICB2YXIgaW5kZXggPSBoYW5kbGUub3B0aW9ucy5pbmRleDtcbiAgICAgICAgdmFyIFtub3JtYWxpemVkRXZlbnQsIHgsIHldID0gbGlua1ZpZXcucGFwZXIuZ2V0UG9pbnRlckFyZ3MoZXZ0KTtcbiAgICAgICAgdmFyIHZlcnRleCA9IHsgeCwgeSB9O1xuICAgICAgICB0aGlzLnNuYXBWZXJ0ZXgodmVydGV4LCBpbmRleCk7XG4gICAgICAgIGxpbmtWaWV3Lm1vZGVsLnZlcnRleChpbmRleCwgdmVydGV4LCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgaGFuZGxlLnBvc2l0aW9uKHZlcnRleC54LCB2ZXJ0ZXgueSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIGxpbmtWaWV3Lm5vdGlmeVBvaW50ZXJtb3ZlKG5vcm1hbGl6ZWRFdmVudCwgeCwgeSk7XG4gICAgfSxcbiAgICBvbkhhbmRsZUNoYW5nZWQ6IGZ1bmN0aW9uKF9oYW5kbGUsIGV2dCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHJlbGF0ZWRWaWV3OiBsaW5rVmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGV4QWRkaW5nKSB0aGlzLnVwZGF0ZVBhdGgoKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlZHVuZGFuY3lSZW1vdmFsKSB7XG4gICAgICAgICAgICBsaW5rVmlldy5jaGVja01vdXNlbGVhdmUodXRpbC5ub3JtYWxpemVFdmVudChldnQpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVydGljZXNSZW1vdmVkID0gbGlua1ZpZXcucmVtb3ZlUmVkdW5kYW50TGluZWFyVmVydGljZXMoeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIGlmICh2ZXJ0aWNlc1JlbW92ZWQpIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICBsaW5rVmlldy5tb2RlbC5zdG9wQmF0Y2goJ3ZlcnRleC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50RGF0YShldnQpLnZlcnRleEFkZGVkKSB7XG4gICAgICAgICAgICBsaW5rVmlldy5tb2RlbC5zdG9wQmF0Y2goJ3ZlcnRleC1hZGQnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgW25vcm1hbGl6ZWRFdnQsIHgsIHldID0gbGlua1ZpZXcucGFwZXIuZ2V0UG9pbnRlckFyZ3MoZXZ0KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0b3BQcm9wYWdhdGlvbikgbGlua1ZpZXcubm90aWZ5UG9pbnRlcnVwKG5vcm1hbGl6ZWRFdnQsIHgsIHkpO1xuICAgICAgICBsaW5rVmlldy5jaGVja01vdXNlbGVhdmUobm9ybWFsaXplZEV2dCk7XG4gICAgfSxcbiAgICBzbmFwVmVydGV4OiBmdW5jdGlvbih2ZXJ0ZXgsIGluZGV4KSB7XG4gICAgICAgIHZhciBzbmFwUmFkaXVzID0gdGhpcy5vcHRpb25zLnNuYXBSYWRpdXM7XG4gICAgICAgIGlmIChzbmFwUmFkaXVzID4gMCkge1xuICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMuZ2V0TmVpZ2hib3JQb2ludHMoaW5kZXgpO1xuICAgICAgICAgICAgdmFyIHByZXYgPSBuZWlnaGJvcnMucHJldjtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gbmVpZ2hib3JzLm5leHQ7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModmVydGV4LnggLSBwcmV2LngpIDwgc25hcFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHZlcnRleC54ID0gcHJldi54O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh2ZXJ0ZXgueCAtIG5leHQueCkgPCBzbmFwUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4LnggPSBuZXh0Lng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModmVydGV4LnkgLSBwcmV2LnkpIDwgc25hcFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHZlcnRleC55ID0gbmVpZ2hib3JzLnByZXYueTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnModmVydGV4LnkgLSBuZXh0LnkpIDwgc25hcFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHZlcnRleC55ID0gbmV4dC55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBvbkhhbmRsZVJlbW92ZTogZnVuY3Rpb24oaGFuZGxlLCBldnQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlLm9wdGlvbnMuaW5kZXg7XG4gICAgICAgIHZhciBsaW5rVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIGxpbmtWaWV3Lm1vZGVsLnJlbW92ZVZlcnRleChpbmRleCwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0ZXhBZGRpbmcpIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgICBsaW5rVmlldy5jaGVja01vdXNlbGVhdmUodXRpbC5ub3JtYWxpemVFdmVudChldnQpKTtcbiAgICB9LFxuICAgIG9uUGF0aFBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0KSkgcmV0dXJuO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICB2YXIgdmVydGV4ID0gdGhpcy5wYXBlci5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdmVudC5jbGllbnRYLCBub3JtYWxpemVkRXZlbnQuY2xpZW50WSkudG9KU09OKCk7XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHJlbGF0ZWRWaWV3Lm1vZGVsLnN0YXJ0QmF0Y2goJ3ZlcnRleC1hZGQnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVsYXRlZFZpZXcuZ2V0VmVydGV4SW5kZXgodmVydGV4LngsIHZlcnRleC55KTtcbiAgICAgICAgdGhpcy5zbmFwVmVydGV4KHZlcnRleCwgaW5kZXgpO1xuICAgICAgICByZWxhdGVkVmlldy5tb2RlbC5pbnNlcnRWZXJ0ZXgoaW5kZXgsIHZlcnRleCwgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIHZhciBoYW5kbGUgPSB0aGlzLmhhbmRsZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShub3JtYWxpemVkRXZlbnQsIHsgdmVydGV4QWRkZWQ6IHRydWUgfSk7XG4gICAgICAgIGhhbmRsZS5vblBvaW50ZXJEb3duKG5vcm1hbGl6ZWRFdmVudCk7XG4gICAgfSxcbiAgICBvbkxpbmtQb2ludGVyRG93bjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMucmVsYXRlZFZpZXcucHJldmVudERlZmF1bHRJbnRlcmFjdGlvbihldnQpO1xuICAgICAgICB0aGlzLm9uUGF0aFBvaW50ZXJEb3duKGV2dCk7XG4gICAgfSxcbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzZXRIYW5kbGVzKCk7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZUxpbmtFdmVudHMoKTtcbiAgICB9XG59LCB7XG4gICAgVmVydGV4SGFuZGxlOiBWZXJ0ZXhIYW5kbGUgLy8ga2VlcCBhcyBjbGFzcyBwcm9wZXJ0eVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkTools/Vertices.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/linkTools/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Boundary: () => (/* reexport safe */ _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_6__.Boundary),\n/* harmony export */   Button: () => (/* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_5__.Button),\n/* harmony export */   Connect: () => (/* reexport safe */ _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_7__.Connect),\n/* harmony export */   Control: () => (/* reexport safe */ _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_9__.Control),\n/* harmony export */   HoverConnect: () => (/* reexport safe */ _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_8__.HoverConnect),\n/* harmony export */   Remove: () => (/* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_5__.Remove),\n/* harmony export */   RotateLabel: () => (/* reexport safe */ _RotateLabel_mjs__WEBPACK_IMPORTED_MODULE_4__.RotateLabel),\n/* harmony export */   Segments: () => (/* reexport safe */ _Segments_mjs__WEBPACK_IMPORTED_MODULE_1__.Segments),\n/* harmony export */   SourceAnchor: () => (/* reexport safe */ _Anchor_mjs__WEBPACK_IMPORTED_MODULE_3__.SourceAnchor),\n/* harmony export */   SourceArrowhead: () => (/* reexport safe */ _Arrowhead_mjs__WEBPACK_IMPORTED_MODULE_2__.SourceArrowhead),\n/* harmony export */   TargetAnchor: () => (/* reexport safe */ _Anchor_mjs__WEBPACK_IMPORTED_MODULE_3__.TargetAnchor),\n/* harmony export */   TargetArrowhead: () => (/* reexport safe */ _Arrowhead_mjs__WEBPACK_IMPORTED_MODULE_2__.TargetArrowhead),\n/* harmony export */   Vertices: () => (/* reexport safe */ _Vertices_mjs__WEBPACK_IMPORTED_MODULE_0__.Vertices)\n/* harmony export */ });\n/* harmony import */ var _Vertices_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vertices.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/Vertices.mjs\");\n/* harmony import */ var _Segments_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Segments.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/Segments.mjs\");\n/* harmony import */ var _Arrowhead_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Arrowhead.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/Arrowhead.mjs\");\n/* harmony import */ var _Anchor_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Anchor.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/Anchor.mjs\");\n/* harmony import */ var _RotateLabel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RotateLabel.mjs */ \"(ssr)/./node_modules/@joint/core/src/linkTools/RotateLabel.mjs\");\n/* harmony import */ var _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cellTools/Button.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Button.mjs\");\n/* harmony import */ var _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cellTools/Boundary.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Boundary.mjs\");\n/* harmony import */ var _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cellTools/Connect.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Connect.mjs\");\n/* harmony import */ var _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../cellTools/HoverConnect.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs\");\n/* harmony import */ var _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cellTools/Control.mjs */ \"(ssr)/./node_modules/@joint/core/src/cellTools/Control.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2xpbmtUb29scy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNDO0FBQ0g7QUFDSzs7QUFFTTtBQUNFO0FBQ0Q7QUFDSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL2luZGV4Lm1qcz9mZjQ1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vVmVydGljZXMubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vU2VnbWVudHMubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vQXJyb3doZWFkLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0FuY2hvci5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Sb3RhdGVMYWJlbC5tanMnO1xuXG5leHBvcnQgKiBmcm9tICcuLi9jZWxsVG9vbHMvQnV0dG9uLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuLi9jZWxsVG9vbHMvQm91bmRhcnkubWpzJztcbmV4cG9ydCAqIGZyb20gJy4uL2NlbGxUb29scy9Db25uZWN0Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuLi9jZWxsVG9vbHMvSG92ZXJDb25uZWN0Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuLi9jZWxsVG9vbHMvQ29udHJvbC5tanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/linkTools/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Collection.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Collection.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collection: () => (/* binding */ Collection)\n/* harmony export */ });\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mvcUtils.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n\n\n// Collection\n// -------------------\n\n// If models tend to represent a single row of data, a Collection is\n// more analogous to a table full of data ... or a small slice or page of that\n// table, or a collection of rows that belong together for a particular reason\n// -- all of the messages in this particular folder, all of the documents\n// belonging to this particular author, and so on. Collections maintain\n// indexes of their models, both in order, and for lookup by `id`.\n\n// Create a new **Collection**, perhaps to contain a specific type of `model`.\n// If a `comparator` is specified, the Collection will maintain\n// its models in sort order, as they're added and removed.\nvar Collection = function(models, options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ silent: true }, options));\n};\n\n// Default options for `Collection#set`.\nvar setOptions = { add: true, remove: true, merge: true };\nvar addOptions = { add: true, remove: false };\n\n// Splices `insert` into `array` at index `at`.\nvar splice = function(array, insert, at) {\n    at = Math.min(Math.max(at, 0), array.length);\n    var tail = Array(array.length - at);\n    var length = insert.length;\n    var i;\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n};\n\n// Define the Collection's inheritable methods.\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(Collection.prototype, _Events_mjs__WEBPACK_IMPORTED_MODULE_1__.Events, {\n\n    // The default model for a collection is just a **Model**.\n    // This should be overridden in most cases.\n    model: _Model_mjs__WEBPACK_IMPORTED_MODULE_2__.Model,\n\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n        return this.map(function(model) { return model.toJSON(options); });\n    },\n\n    // Add a model, or list of models to the set. `models` may be\n    // Models or raw JavaScript objects to be converted to Models, or any\n    // combination of the two.\n    add: function(models, options) {\n        return this.set(models, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ merge: false }, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n        options = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);\n        var singular = !Array.isArray(models);\n        models = singular ? [models] : models.slice();\n        var removed = this._removeModels(models, options);\n        if (!options.silent && removed.length) {\n            options.changes = { added: [], merged: [], removed: removed };\n            this.trigger('update', this, options);\n        }\n        return singular ? removed[0] : removed;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n        if (models == null) return;\n\n        options = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, setOptions, options);\n\n        var singular = !Array.isArray(models);\n        models = singular ? [models] : models.slice();\n\n        var at = options.at;\n        if (at != null) at = +at;\n        if (at > this.length) at = this.length;\n        if (at < 0) at += this.length + 1;\n\n        var set = [];\n        var toAdd = [];\n        var toMerge = [];\n        var toRemove = [];\n        var modelMap = {};\n\n        var add = options.add;\n        var merge = options.merge;\n        var remove = options.remove;\n\n        var sort = false;\n        var sortable = this.comparator && at == null && options.sort !== false;\n        var sortAttr = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(this.comparator) ? this.comparator : null;\n\n        // Turn bare objects into model references, and prevent invalid models\n        // from being added.\n        var model, i;\n        for (i = 0; i < models.length; i++) {\n            model = models[i];\n\n            // If a duplicate is found, prevent it from being added and\n            // optionally merge it into the existing model.\n            var existing = this.get(model);\n            if (existing) {\n                if (merge && model !== existing) {\n                    var attrs = this._isModel(model) ? model.attributes : model;\n                    existing.set(attrs, options);\n                    toMerge.push(existing);\n                    if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n                }\n                if (!modelMap[existing.cid]) {\n                    modelMap[existing.cid] = true;\n                    set.push(existing);\n                }\n                models[i] = existing;\n\n                // If this is a new, valid model, push it to the `toAdd` list.\n            } else if (add) {\n                model = models[i] = this._prepareModel(model, options);\n                if (model) {\n                    toAdd.push(model);\n                    this._addReference(model, options);\n                    modelMap[model.cid] = true;\n                    set.push(model);\n                }\n            }\n        }\n\n        // Remove stale models.\n        if (remove) {\n            for (i = 0; i < this.length; i++) {\n                model = this.models[i];\n                if (!modelMap[model.cid]) toRemove.push(model);\n            }\n            if (toRemove.length) this._removeModels(toRemove, options);\n        }\n\n        // See if sorting is needed, update `length` and splice in new models.\n        var orderChanged = false;\n        var replace = !sortable && add && remove;\n        if (set.length && replace) {\n            orderChanged = this.length !== set.length || this.models.some(function(m, index) {\n                return m !== set[index];\n            });\n            this.models.length = 0;\n            splice(this.models, set, 0);\n            this.length = this.models.length;\n        } else if (toAdd.length) {\n            if (sortable) sort = true;\n            splice(this.models, toAdd, at == null ? this.length : at);\n            this.length = this.models.length;\n        }\n\n        // Silently sort the collection if appropriate.\n        if (sort) this.sort({ silent: true });\n\n        // Unless silenced, it's time to fire all appropriate add/sort/update events.\n        if (!options.silent) {\n            for (i = 0; i < toAdd.length; i++) {\n                if (at != null) options.index = at + i;\n                model = toAdd[i];\n                model.trigger('add', model, this, options);\n            }\n            if (sort || orderChanged) this.trigger('sort', this, options);\n            if (toAdd.length || toRemove.length || toMerge.length) {\n                options.changes = {\n                    added: toAdd,\n                    removed: toRemove,\n                    merged: toMerge\n                };\n                this.trigger('update', this, options);\n            }\n        }\n\n        // Return the added (or merged) model (or models).\n        return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n        options = options ? (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(options) : {};\n        for (var i = 0; i < this.models.length; i++) {\n            this._removeReference(this.models[i], options);\n        }\n        options.previousModels = this.models;\n        this._reset();\n        models = this.add(models, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ silent: true }, options));\n        if (!options.silent) this.trigger('reset', this, options);\n        return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n        return this.add(model, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ at: this.length }, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n        var model = this.at(this.length - 1);\n        return this.remove(model, options);\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n        return this.add(model, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ at: 0 }, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n        var model = this.at(0);\n        return this.remove(model, options);\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n        return Array.prototype.slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id, cid, model object with id or cid\n    // properties, or an attributes object that is transformed through modelId.\n    get: function(obj) {\n        if (obj == null) return void 0;\n        return this._byId[obj] ||\n        this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] ||\n        obj.cid && this._byId[obj.cid];\n    },\n\n    // Returns `true` if the model is in the collection.\n    has: function(obj) {\n        return this.get(obj) != null;\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n        if (index < 0) index += this.length;\n        return this.models[index];\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n        var comparator = this.comparator;\n        if (!comparator) throw new Error('Cannot sort a set without a comparator');\n        options || (options = {});\n\n        var length = comparator.length;\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(comparator)) comparator = comparator.bind(this);\n\n        // Run sort based on type of `comparator`.\n        if (length === 1 || (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(comparator)) {\n            this.models = this.sortBy(comparator);\n        } else {\n            this.models.sort(comparator);\n        }\n        if (!options.silent) this.trigger('sort', this, options);\n        return this;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n        return new this.constructor(this.models, {\n            model: this.model,\n            comparator: this.comparator\n        });\n    },\n\n    // Define how to uniquely identify models in the collection.\n    modelId: function(attrs, idAttribute) {\n        return attrs[idAttribute || this.model.prototype.idAttribute || 'id'];\n    },\n\n    // Get an iterator of all models in this collection.\n    values: function() {\n        return new CollectionIterator(this, ITERATOR_VALUES);\n    },\n\n    // Get an iterator of all model IDs in this collection.\n    keys: function() {\n        return new CollectionIterator(this, ITERATOR_KEYS);\n    },\n\n    // Get an iterator of all [ID, model] tuples in this collection.\n    entries: function() {\n        return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n    },\n\n    // Iterate over elements of the collection, and invoke fn for each element\n    each: function(fn, context) {\n        this.models.forEach(fn, context);\n    },\n\n    // Iterate over elements of collection, and return an array of all elements fn returns truthy for\n    filter: function(fn, context) {\n        return this.models.filter(fn, context);\n    },\n\n    find: function(fn, context) {\n        return this.models.find(fn, context);\n    },\n\n    findIndex: function(fn, context) {\n        return this.models.findIndex(fn, context);\n    },\n\n    // Return the first model of the collection\n    first: function() {\n        return this.models[0];\n    },\n\n    // Return true if value is in the collection\n    includes: function(value) {\n        return this.models.includes(value);\n    },\n\n    // Return the last model of the collection\n    last: function() {\n        return this.models[this.models.length - 1];\n    },\n\n    // Return true if collection has no elements\n    isEmpty: function() {\n        return !this.models.length;\n    },\n\n    // Create an array of values by running each element in the collection through fn\n    map: function(fn, context) {\n        return this.models.map(fn, context);\n    },\n\n    // Runs \"reducer\" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value\n    reduce: function(fn, initAcc = this.first()) {\n        return this.models.reduce(fn, initAcc);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n        this.length = 0;\n        this.models = [];\n        this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n        if (this._isModel(attrs)) {\n            if (!attrs.collection) attrs.collection = this;\n            return attrs;\n        }\n        options = options ? (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(options) : {};\n        options.collection = this;\n\n        var model;\n        if (this.model.prototype) {\n            model = new this.model(attrs, options);\n        } else {\n        // ES class methods didn't have prototype\n            model = this.model(attrs, options);\n        }\n\n        if (!model.validationError) return model;\n        this.trigger('invalid', this, model.validationError, options);\n        return false;\n    },\n\n    // Internal method called by both remove and set.\n    _removeModels: function(models, options) {\n        var removed = [];\n        for (var i = 0; i < models.length; i++) {\n            var model = this.get(models[i]);\n            if (!model) continue;\n\n            var index = this.models.indexOf(model);\n            this.models.splice(index, 1);\n            this.length--;\n\n            // Remove references before triggering 'remove' event to prevent an\n            // infinite loop. #3693\n            delete this._byId[model.cid];\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) delete this._byId[id];\n\n            if (!options.silent) {\n                options.index = index;\n                model.trigger('remove', model, this, options);\n            }\n\n            removed.push(model);\n            this._removeReference(model, options);\n        }\n        if (models.length > 0 && !options.silent) delete options.index;\n        return removed;\n    },\n\n    // Method for checking whether an object should be considered a model for\n    // the purposes of adding to the collection.\n    _isModel: function(model) {\n        return model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_2__.Model;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n        this._byId[model.cid] = model;\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) this._byId[id] = model;\n        model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n        delete this._byId[model.cid];\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) delete this._byId[id];\n        if (this === model.collection) delete model.collection;\n        model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n        if (model) {\n            if ((event === 'add' || event === 'remove') && collection !== this) return;\n            if (event === 'changeId') {\n                var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n                var id = this.modelId(model.attributes, model.idAttribute);\n                if (prevId != null) delete this._byId[prevId];\n                if (id != null) this._byId[id] = model;\n            }\n        }\n        this.trigger.apply(this, arguments);\n    }\n\n});\n\n// Defining an @@iterator method implements JavaScript's Iterable protocol.\n// In modern ES2015 browsers, this value is found at Symbol.iterator.\nvar $$iterator = typeof Symbol === 'function' && Symbol.iterator;\nif ($$iterator) {\n    Collection.prototype[$$iterator] = Collection.prototype.values;\n}\n\n// CollectionIterator\n// ------------------\n\n// A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n// use of `for of` loops in modern browsers and interoperation between\n// Collection and other JavaScript functions and third-party libraries\n// which can operate on Iterables.\nvar CollectionIterator = function(collection, kind) {\n    this._collection = collection;\n    this._kind = kind;\n    this._index = 0;\n};\n\n// This \"enum\" defines the three possible kinds of values which can be emitted\n// by a CollectionIterator that correspond to the values(), keys() and entries()\n// methods on Collection, respectively.\nvar ITERATOR_VALUES = 1;\nvar ITERATOR_KEYS = 2;\nvar ITERATOR_KEYSVALUES = 3;\n\n// All Iterators should themselves be Iterable.\nif ($$iterator) {\n    CollectionIterator.prototype[$$iterator] = function() {\n        return this;\n    };\n}\n\nCollectionIterator.prototype.next = function() {\n    if (this._collection) {\n\n        // Only continue iterating if the iterated collection is long enough.\n        if (this._index < this._collection.length) {\n            var model = this._collection.at(this._index);\n            this._index++;\n\n            // Construct a value depending on what kind of values should be iterated.\n            var value;\n            if (this._kind === ITERATOR_VALUES) {\n                value = model;\n            } else {\n                var id = this._collection.modelId(model.attributes, model.idAttribute);\n                if (this._kind === ITERATOR_KEYS) {\n                    value = id;\n                } else { // ITERATOR_KEYSVALUES\n                    value = [id, model];\n                }\n            }\n            return { value: value, done: false };\n        }\n\n        // Once exhausted, remove the reference to the collection so future\n        // calls to the next method always return done.\n        this._collection = void 0;\n    }\n\n    return { value: void 0, done: true };\n};\n\n//  Methods that we want to implement on the Collection.\nvar collectionMethods = { toArray: 1, sortBy: 3 };\n\n\n// Mix in each method as a proxy to `Collection#models`.\n\nvar config = [ Collection, collectionMethods, 'models' ];\n\nfunction addMethods(config) {\n    var Base = config[0],\n        methods = config[1],\n        attribute = config[2];\n\n    const methodsToAdd = {\n        sortBy: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy,\n        toArray: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray\n    };\n\n    (0,_mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__.addMethodsUtil)(Base, methodsToAdd, methods, attribute);\n}\n\naddMethods(config);\n\n// Set up inheritance for the collection.\nCollection.extend = _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__.extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Db2xsZWN0aW9uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzQztBQUNGO0FBQ29CO0FBUTlCOzs7QUFHMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzREFBTSxHQUFHLGNBQWM7QUFDMUQ7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixZQUFZO0FBQzVCLGdCQUFnQixpQkFBaUI7QUFDakM7O0FBRUE7QUFDQSxzREFBTSx1QkFBdUIsK0NBQU07O0FBRW5DO0FBQ0E7QUFDQSxXQUFXLDZDQUFLOzs7QUFHaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQU0sR0FBRyxjQUFjO0FBQ3ZELEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtCQUFrQixzREFBTSxHQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzREFBTSxHQUFHOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0EsMEJBQTBCOzs7QUFHMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsZUFBZTtBQUNmOztBQUVBLElBQUksNkRBQWM7QUFDbEI7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsaURBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvQ29sbGVjdGlvbi5tanM/NzhiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL0V2ZW50cy5tanMnO1xuaW1wb3J0IHsgTW9kZWwgfSBmcm9tICcuL01vZGVsLm1qcyc7XG5pbXBvcnQgeyBleHRlbmQsIGFkZE1ldGhvZHNVdGlsIH0gZnJvbSAnLi9tdmNVdGlscy5tanMnO1xuaW1wb3J0IHtcbiAgICBhc3NpZ24sXG4gICAgY2xvbmUsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZyxcbiAgICBzb3J0QnksXG4gICAgdG9BcnJheVxufSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcblxuXG4vLyBDb2xsZWN0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIElmIG1vZGVscyB0ZW5kIHRvIHJlcHJlc2VudCBhIHNpbmdsZSByb3cgb2YgZGF0YSwgYSBDb2xsZWN0aW9uIGlzXG4vLyBtb3JlIGFuYWxvZ291cyB0byBhIHRhYmxlIGZ1bGwgb2YgZGF0YSAuLi4gb3IgYSBzbWFsbCBzbGljZSBvciBwYWdlIG9mIHRoYXRcbi8vIHRhYmxlLCBvciBhIGNvbGxlY3Rpb24gb2Ygcm93cyB0aGF0IGJlbG9uZyB0b2dldGhlciBmb3IgYSBwYXJ0aWN1bGFyIHJlYXNvblxuLy8gLS0gYWxsIG9mIHRoZSBtZXNzYWdlcyBpbiB0aGlzIHBhcnRpY3VsYXIgZm9sZGVyLCBhbGwgb2YgdGhlIGRvY3VtZW50c1xuLy8gYmVsb25naW5nIHRvIHRoaXMgcGFydGljdWxhciBhdXRob3IsIGFuZCBzbyBvbi4gQ29sbGVjdGlvbnMgbWFpbnRhaW5cbi8vIGluZGV4ZXMgb2YgdGhlaXIgbW9kZWxzLCBib3RoIGluIG9yZGVyLCBhbmQgZm9yIGxvb2t1cCBieSBgaWRgLlxuXG4vLyBDcmVhdGUgYSBuZXcgKipDb2xsZWN0aW9uKiosIHBlcmhhcHMgdG8gY29udGFpbiBhIHNwZWNpZmljIHR5cGUgb2YgYG1vZGVsYC5cbi8vIElmIGEgYGNvbXBhcmF0b3JgIGlzIHNwZWNpZmllZCwgdGhlIENvbGxlY3Rpb24gd2lsbCBtYWludGFpblxuLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxuZXhwb3J0IHZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLnByZWluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbCkgdGhpcy5tb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgaWYgKG9wdGlvbnMuY29tcGFyYXRvciAhPT0gdm9pZCAwKSB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAobW9kZWxzKSB0aGlzLnJlc2V0KG1vZGVscywgYXNzaWduKHsgc2lsZW50OiB0cnVlIH0sIG9wdGlvbnMpKTtcbn07XG5cbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgYENvbGxlY3Rpb24jc2V0YC5cbnZhciBzZXRPcHRpb25zID0geyBhZGQ6IHRydWUsIHJlbW92ZTogdHJ1ZSwgbWVyZ2U6IHRydWUgfTtcbnZhciBhZGRPcHRpb25zID0geyBhZGQ6IHRydWUsIHJlbW92ZTogZmFsc2UgfTtcblxuLy8gU3BsaWNlcyBgaW5zZXJ0YCBpbnRvIGBhcnJheWAgYXQgaW5kZXggYGF0YC5cbnZhciBzcGxpY2UgPSBmdW5jdGlvbihhcnJheSwgaW5zZXJ0LCBhdCkge1xuICAgIGF0ID0gTWF0aC5taW4oTWF0aC5tYXgoYXQsIDApLCBhcnJheS5sZW5ndGgpO1xuICAgIHZhciB0YWlsID0gQXJyYXkoYXJyYXkubGVuZ3RoIC0gYXQpO1xuICAgIHZhciBsZW5ndGggPSBpbnNlcnQubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB0YWlsW2ldID0gYXJyYXlbaSArIGF0XTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFycmF5W2kgKyBhdF0gPSBpbnNlcnRbaV07XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIGFycmF5W2kgKyBsZW5ndGggKyBhdF0gPSB0YWlsW2ldO1xufTtcblxuLy8gRGVmaW5lIHRoZSBDb2xsZWN0aW9uJ3MgaW5oZXJpdGFibGUgbWV0aG9kcy5cbmFzc2lnbihDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSAqKk1vZGVsKiouXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuICAgIG1vZGVsOiBNb2RlbCxcblxuXG4gICAgLy8gcHJlaW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBZb3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggYSBmdW5jdGlvblxuICAgIC8vIG9yIG9iamVjdC4gIHByZWluaXRpYWxpemUgd2lsbCBydW4gYmVmb3JlIGFueSBpbnN0YW50aWF0aW9uIGxvZ2ljIGlzIHJ1biBpbiB0aGUgQ29sbGVjdGlvbi5cbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBObyBpbXBsZW1lbnRhdGlvbi5cbiAgICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm8gaW1wbGVtZW50YXRpb24uXG4gICAgfSxcblxuICAgIC8vIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAvLyBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCkgeyByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwsIG9yIGxpc3Qgb2YgbW9kZWxzIHRvIHRoZSBzZXQuIGBtb2RlbHNgIG1heSBiZVxuICAgIC8vIE1vZGVscyBvciByYXcgSmF2YVNjcmlwdCBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZCB0byBNb2RlbHMsIG9yIGFueVxuICAgIC8vIGNvbWJpbmF0aW9uIG9mIHRoZSB0d28uXG4gICAgYWRkOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KG1vZGVscywgYXNzaWduKHsgbWVyZ2U6IGZhbHNlIH0sIG9wdGlvbnMsIGFkZE9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwsIG9yIGEgbGlzdCBvZiBtb2RlbHMgZnJvbSB0aGUgc2V0LlxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgc2luZ3VsYXIgPSAhQXJyYXkuaXNBcnJheShtb2RlbHMpO1xuICAgICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogbW9kZWxzLnNsaWNlKCk7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlTW9kZWxzKG1vZGVscywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQgJiYgcmVtb3ZlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhbmdlcyA9IHsgYWRkZWQ6IFtdLCBtZXJnZWQ6IFtdLCByZW1vdmVkOiByZW1vdmVkIH07XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5ndWxhciA/IHJlbW92ZWRbMF0gOiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxuICAgIC8vIHJlbW92aW5nIG1vZGVscyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudCwgYW5kIG1lcmdpbmcgbW9kZWxzIHRoYXRcbiAgICAvLyBhbHJlYWR5IGV4aXN0IGluIHRoZSBjb2xsZWN0aW9uLCBhcyBuZWNlc3NhcnkuIFNpbWlsYXIgdG8gKipNb2RlbCNzZXQqKixcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cbiAgICBzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICBpZiAobW9kZWxzID09IG51bGwpIHJldHVybjtcblxuICAgICAgICBvcHRpb25zID0gYXNzaWduKHt9LCBzZXRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICB2YXIgc2luZ3VsYXIgPSAhQXJyYXkuaXNBcnJheShtb2RlbHMpO1xuICAgICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IFttb2RlbHNdIDogbW9kZWxzLnNsaWNlKCk7XG5cbiAgICAgICAgdmFyIGF0ID0gb3B0aW9ucy5hdDtcbiAgICAgICAgaWYgKGF0ICE9IG51bGwpIGF0ID0gK2F0O1xuICAgICAgICBpZiAoYXQgPiB0aGlzLmxlbmd0aCkgYXQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGF0IDwgMCkgYXQgKz0gdGhpcy5sZW5ndGggKyAxO1xuXG4gICAgICAgIHZhciBzZXQgPSBbXTtcbiAgICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICAgIHZhciB0b01lcmdlID0gW107XG4gICAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgICB2YXIgbW9kZWxNYXAgPSB7fTtcblxuICAgICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQ7XG4gICAgICAgIHZhciBtZXJnZSA9IG9wdGlvbnMubWVyZ2U7XG4gICAgICAgIHZhciByZW1vdmUgPSBvcHRpb25zLnJlbW92ZTtcblxuICAgICAgICB2YXIgc29ydCA9IGZhbHNlO1xuICAgICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgYXQgPT0gbnVsbCAmJiBvcHRpb25zLnNvcnQgIT09IGZhbHNlO1xuICAgICAgICB2YXIgc29ydEF0dHIgPSBpc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpID8gdGhpcy5jb21wYXJhdG9yIDogbnVsbDtcblxuICAgICAgICAvLyBUdXJuIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50IGludmFsaWQgbW9kZWxzXG4gICAgICAgIC8vIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICAgIHZhciBtb2RlbCwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV07XG5cbiAgICAgICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXG4gICAgICAgICAgICAvLyBvcHRpb25hbGx5IG1lcmdlIGl0IGludG8gdGhlIGV4aXN0aW5nIG1vZGVsLlxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5nZXQobW9kZWwpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlICYmIG1vZGVsICE9PSBleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9pc01vZGVsKG1vZGVsKSA/IG1vZGVsLmF0dHJpYnV0ZXMgOiBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdG9NZXJnZS5wdXNoKGV4aXN0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRhYmxlICYmICFzb3J0KSBzb3J0ID0gZXhpc3RpbmcuaGFzQ2hhbmdlZChzb3J0QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbW9kZWxNYXBbZXhpc3RpbmcuY2lkXSkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbE1hcFtleGlzdGluZy5jaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBuZXcsIHZhbGlkIG1vZGVsLCBwdXNoIGl0IHRvIHRoZSBgdG9BZGRgIGxpc3QuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9BZGQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsTWFwW21vZGVsLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHN0YWxlIG1vZGVscy5cbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbW9kZWxNYXBbbW9kZWwuY2lkXSkgdG9SZW1vdmUucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLl9yZW1vdmVNb2RlbHModG9SZW1vdmUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VlIGlmIHNvcnRpbmcgaXMgbmVlZGVkLCB1cGRhdGUgYGxlbmd0aGAgYW5kIHNwbGljZSBpbiBuZXcgbW9kZWxzLlxuICAgICAgICB2YXIgb3JkZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciByZXBsYWNlID0gIXNvcnRhYmxlICYmIGFkZCAmJiByZW1vdmU7XG4gICAgICAgIGlmIChzZXQubGVuZ3RoICYmIHJlcGxhY2UpIHtcbiAgICAgICAgICAgIG9yZGVyQ2hhbmdlZCA9IHRoaXMubGVuZ3RoICE9PSBzZXQubGVuZ3RoIHx8IHRoaXMubW9kZWxzLnNvbWUoZnVuY3Rpb24obSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbSAhPT0gc2V0W2luZGV4XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHNwbGljZSh0aGlzLm1vZGVscywgc2V0LCAwKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHRvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNvcnRhYmxlKSBzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNwbGljZSh0aGlzLm1vZGVscywgdG9BZGQsIGF0ID09IG51bGwgPyB0aGlzLmxlbmd0aCA6IGF0KTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5tb2RlbHMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7IHNpbGVudDogdHJ1ZSB9KTtcblxuICAgICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydC91cGRhdGUgZXZlbnRzLlxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXQgIT0gbnVsbCkgb3B0aW9ucy5pbmRleCA9IGF0ICsgaTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHRvQWRkW2ldO1xuICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ2FkZCcsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3J0IHx8IG9yZGVyQ2hhbmdlZCkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAodG9BZGQubGVuZ3RoIHx8IHRvUmVtb3ZlLmxlbmd0aCB8fCB0b01lcmdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhbmdlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWQ6IHRvQWRkLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkOiB0b1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkOiB0b01lcmdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBhZGRlZCAob3IgbWVyZ2VkKSBtb2RlbCAob3IgbW9kZWxzKS5cbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvLyBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgLy8gYW55IGdyYW51bGFyIGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgbW9kZWxzID0gdGhpcy5hZGQobW9kZWxzLCBhc3NpZ24oeyBzaWxlbnQ6IHRydWUgfSwgb3B0aW9ucykpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcHVzaDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBhc3NpZ24oeyBhdDogdGhpcy5sZW5ndGggfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgcG9wOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICB1bnNoaWZ0OiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIGFzc2lnbih7IGF0OiAwIH0sIG9wdGlvbnMpKTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGEgbW9kZWwgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8vIFNsaWNlIG91dCBhIHN1Yi1hcnJheSBvZiBtb2RlbHMgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICBzbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcy5tb2RlbHMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhIG1vZGVsIGZyb20gdGhlIHNldCBieSBpZCwgY2lkLCBtb2RlbCBvYmplY3Qgd2l0aCBpZCBvciBjaWRcbiAgICAvLyBwcm9wZXJ0aWVzLCBvciBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0aGF0IGlzIHRyYW5zZm9ybWVkIHRocm91Z2ggbW9kZWxJZC5cbiAgICBnZXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzLl9ieUlkW29ial0gfHxcbiAgICAgICAgdGhpcy5fYnlJZFt0aGlzLm1vZGVsSWQodGhpcy5faXNNb2RlbChvYmopID8gb2JqLmF0dHJpYnV0ZXMgOiBvYmosIG9iai5pZEF0dHJpYnV0ZSldIHx8XG4gICAgICAgIG9iai5jaWQgJiYgdGhpcy5fYnlJZFtvYmouY2lkXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1vZGVsIGlzIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgIGhhczogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChvYmopICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCArPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLy8gRm9yY2UgdGhlIGNvbGxlY3Rpb24gdG8gcmUtc29ydCBpdHNlbGYuIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgdGhpcyB1bmRlclxuICAgIC8vIG5vcm1hbCBjaXJjdW1zdGFuY2VzLCBhcyB0aGUgc2V0IHdpbGwgbWFpbnRhaW4gc29ydCBvcmRlciBhcyBlYWNoIGl0ZW1cbiAgICAvLyBpcyBhZGRlZC5cbiAgICBzb3J0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5jb21wYXJhdG9yO1xuICAgICAgICBpZiAoIWNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcbiAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gY29tcGFyYXRvci5sZW5ndGg7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbXBhcmF0b3IpKSBjb21wYXJhdG9yID0gY29tcGFyYXRvci5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxuICAgICAgICBpZiAobGVuZ3RoID09PSAxIHx8IGlzU3RyaW5nKGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KGNvbXBhcmF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb2RlbHMuc29ydChjb21wYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjb2xsZWN0aW9uIHdpdGggYW4gaWRlbnRpY2FsIGxpc3Qgb2YgbW9kZWxzIGFzIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzLCB7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbXBhcmF0b3I6IHRoaXMuY29tcGFyYXRvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRGVmaW5lIGhvdyB0byB1bmlxdWVseSBpZGVudGlmeSBtb2RlbHMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgbW9kZWxJZDogZnVuY3Rpb24oYXR0cnMsIGlkQXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1tpZEF0dHJpYnV0ZSB8fCB0aGlzLm1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG9mIGFsbCBtb2RlbHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbkl0ZXJhdG9yKHRoaXMsIElURVJBVE9SX1ZBTFVFUyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbiBpdGVyYXRvciBvZiBhbGwgbW9kZWwgSURzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAgICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlcmF0b3IodGhpcywgSVRFUkFUT1JfS0VZUyk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbiBpdGVyYXRvciBvZiBhbGwgW0lELCBtb2RlbF0gdHVwbGVzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlcmF0b3IodGhpcywgSVRFUkFUT1JfS0VZU1ZBTFVFUyk7XG4gICAgfSxcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBlbGVtZW50cyBvZiB0aGUgY29sbGVjdGlvbiwgYW5kIGludm9rZSBmbiBmb3IgZWFjaCBlbGVtZW50XG4gICAgZWFjaDogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tb2RlbHMuZm9yRWFjaChmbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBlbGVtZW50cyBvZiBjb2xsZWN0aW9uLCBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50cyBmbiByZXR1cm5zIHRydXRoeSBmb3JcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVscy5maWx0ZXIoZm4sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHMuZmluZChmbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpbmRJbmRleDogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLmZpbmRJbmRleChmbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZmlyc3QgbW9kZWwgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICBmaXJzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsc1swXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgdmFsdWUgaXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICBpbmNsdWRlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBsYXN0IG1vZGVsIG9mIHRoZSBjb2xsZWN0aW9uXG4gICAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsc1t0aGlzLm1vZGVscy5sZW5ndGggLSAxXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRydWUgaWYgY29sbGVjdGlvbiBoYXMgbm8gZWxlbWVudHNcbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gdGhlIGNvbGxlY3Rpb24gdGhyb3VnaCBmblxuICAgIG1hcDogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLm1hcChmbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJ1bnMgXCJyZWR1Y2VyXCIgZm4gb3ZlciBhbGwgZWxlbWVudHMgaW4gdGhlIGNvbGxlY3Rpb24sIGluIGFzY2VuZGluZy1pbmRleCBvcmRlciwgYW5kIGFjY3VtdWxhdGVzIHRoZW0gaW50byBhIHNpbmdsZSB2YWx1ZVxuICAgIHJlZHVjZTogZnVuY3Rpb24oZm4sIGluaXRBY2MgPSB0aGlzLmZpcnN0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLnJlZHVjZShmbiwgaW5pdEFjYyk7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgbWV0aG9kIHRvIHJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBpcyBmaXJzdCBpbml0aWFsaXplZCBvciByZXNldC5cbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgfSxcblxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXG4gICAgLy8gY29sbGVjdGlvbi5cbiAgICBfcHJlcGFyZU1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5faXNNb2RlbChhdHRycykpIHtcbiAgICAgICAgICAgIGlmICghYXR0cnMuY29sbGVjdGlvbikgYXR0cnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHt9O1xuICAgICAgICBvcHRpb25zLmNvbGxlY3Rpb24gPSB0aGlzO1xuXG4gICAgICAgIHZhciBtb2RlbDtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRVMgY2xhc3MgbWV0aG9kcyBkaWRuJ3QgaGF2ZSBwcm90b3R5cGVcbiAgICAgICAgICAgIG1vZGVsID0gdGhpcy5tb2RlbChhdHRycywgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1vZGVsLnZhbGlkYXRpb25FcnJvcikgcmV0dXJuIG1vZGVsO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBtb2RlbC52YWxpZGF0aW9uRXJyb3IsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgYnkgYm90aCByZW1vdmUgYW5kIHNldC5cbiAgICBfcmVtb3ZlTW9kZWxzOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5tb2RlbHMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXMgYmVmb3JlIHRyaWdnZXJpbmcgJ3JlbW92ZScgZXZlbnQgdG8gcHJldmVudCBhblxuICAgICAgICAgICAgLy8gaW5maW5pdGUgbG9vcC4gIzM2OTNcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcywgbW9kZWwuaWRBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlbHMubGVuZ3RoID4gMCAmJiAhb3B0aW9ucy5zaWxlbnQpIGRlbGV0ZSBvcHRpb25zLmluZGV4O1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLy8gTWV0aG9kIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhIG1vZGVsIGZvclxuICAgIC8vIHRoZSBwdXJwb3NlcyBvZiBhZGRpbmcgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgX2lzTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiBtb2RlbCBpbnN0YW5jZW9mIE1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9ieUlkW21vZGVsLmNpZF0gPSBtb2RlbDtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICAgIG1vZGVsLm9uKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gc2V2ZXIgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XG4gICAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzLCBtb2RlbC5pZEF0dHJpYnV0ZSk7XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSBkZWxldGUgdGhpcy5fYnlJZFtpZF07XG4gICAgICAgIGlmICh0aGlzID09PSBtb2RlbC5jb2xsZWN0aW9uKSBkZWxldGUgbW9kZWwuY29sbGVjdGlvbjtcbiAgICAgICAgbW9kZWwub2ZmKCdhbGwnLCB0aGlzLl9vbk1vZGVsRXZlbnQsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGV2ZXJ5IHRpbWUgYSBtb2RlbCBpbiB0aGUgc2V0IGZpcmVzIGFuIGV2ZW50LlxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcbiAgICAvLyBldmVudHMgc2ltcGx5IHByb3h5IHRocm91Z2guIFwiYWRkXCIgYW5kIFwicmVtb3ZlXCIgZXZlbnRzIHRoYXQgb3JpZ2luYXRlXG4gICAgLy8gaW4gb3RoZXIgY29sbGVjdGlvbnMgYXJlIGlnbm9yZWQuXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdyZW1vdmUnKSAmJiBjb2xsZWN0aW9uICE9PSB0aGlzKSByZXR1cm47XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09ICdjaGFuZ2VJZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldklkID0gdGhpcy5tb2RlbElkKG1vZGVsLnByZXZpb3VzQXR0cmlidXRlcygpLCBtb2RlbC5pZEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldklkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW3ByZXZJZF07XG4gICAgICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHRoaXMuX2J5SWRbaWRdID0gbW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG59KTtcblxuLy8gRGVmaW5pbmcgYW4gQEBpdGVyYXRvciBtZXRob2QgaW1wbGVtZW50cyBKYXZhU2NyaXB0J3MgSXRlcmFibGUgcHJvdG9jb2wuXG4vLyBJbiBtb2Rlcm4gRVMyMDE1IGJyb3dzZXJzLCB0aGlzIHZhbHVlIGlzIGZvdW5kIGF0IFN5bWJvbC5pdGVyYXRvci5cbnZhciAkJGl0ZXJhdG9yID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG5pZiAoJCRpdGVyYXRvcikge1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlWyQkaXRlcmF0b3JdID0gQ29sbGVjdGlvbi5wcm90b3R5cGUudmFsdWVzO1xufVxuXG4vLyBDb2xsZWN0aW9uSXRlcmF0b3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBIENvbGxlY3Rpb25JdGVyYXRvciBpbXBsZW1lbnRzIEphdmFTY3JpcHQncyBJdGVyYXRvciBwcm90b2NvbCwgYWxsb3dpbmcgdGhlXG4vLyB1c2Ugb2YgYGZvciBvZmAgbG9vcHMgaW4gbW9kZXJuIGJyb3dzZXJzIGFuZCBpbnRlcm9wZXJhdGlvbiBiZXR3ZWVuXG4vLyBDb2xsZWN0aW9uIGFuZCBvdGhlciBKYXZhU2NyaXB0IGZ1bmN0aW9ucyBhbmQgdGhpcmQtcGFydHkgbGlicmFyaWVzXG4vLyB3aGljaCBjYW4gb3BlcmF0ZSBvbiBJdGVyYWJsZXMuXG52YXIgQ29sbGVjdGlvbkl0ZXJhdG9yID0gZnVuY3Rpb24oY29sbGVjdGlvbiwga2luZCkge1xuICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbn07XG5cbi8vIFRoaXMgXCJlbnVtXCIgZGVmaW5lcyB0aGUgdGhyZWUgcG9zc2libGUga2luZHMgb2YgdmFsdWVzIHdoaWNoIGNhbiBiZSBlbWl0dGVkXG4vLyBieSBhIENvbGxlY3Rpb25JdGVyYXRvciB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHZhbHVlcygpLCBrZXlzKCkgYW5kIGVudHJpZXMoKVxuLy8gbWV0aG9kcyBvbiBDb2xsZWN0aW9uLCByZXNwZWN0aXZlbHkuXG52YXIgSVRFUkFUT1JfVkFMVUVTID0gMTtcbnZhciBJVEVSQVRPUl9LRVlTID0gMjtcbnZhciBJVEVSQVRPUl9LRVlTVkFMVUVTID0gMztcblxuLy8gQWxsIEl0ZXJhdG9ycyBzaG91bGQgdGhlbXNlbHZlcyBiZSBJdGVyYWJsZS5cbmlmICgkJGl0ZXJhdG9yKSB7XG4gICAgQ29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZVskJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG5Db2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY29sbGVjdGlvbikge1xuXG4gICAgICAgIC8vIE9ubHkgY29udGludWUgaXRlcmF0aW5nIGlmIHRoZSBpdGVyYXRlZCBjb2xsZWN0aW9uIGlzIGxvbmcgZW5vdWdoLlxuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLl9jb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5fY29sbGVjdGlvbi5hdCh0aGlzLl9pbmRleCk7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCsrO1xuXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYSB2YWx1ZSBkZXBlbmRpbmcgb24gd2hhdCBraW5kIG9mIHZhbHVlcyBzaG91bGQgYmUgaXRlcmF0ZWQuXG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fa2luZCA9PT0gSVRFUkFUT1JfVkFMVUVTKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5fY29sbGVjdGlvbi5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2luZCA9PT0gSVRFUkFUT1JfS0VZUykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGlkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIElURVJBVE9SX0tFWVNWQUxVRVNcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbaWQsIG1vZGVsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmNlIGV4aGF1c3RlZCwgcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNvbGxlY3Rpb24gc28gZnV0dXJlXG4gICAgICAgIC8vIGNhbGxzIHRvIHRoZSBuZXh0IG1ldGhvZCBhbHdheXMgcmV0dXJuIGRvbmUuXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xufTtcblxuLy8gIE1ldGhvZHMgdGhhdCB3ZSB3YW50IHRvIGltcGxlbWVudCBvbiB0aGUgQ29sbGVjdGlvbi5cbnZhciBjb2xsZWN0aW9uTWV0aG9kcyA9IHsgdG9BcnJheTogMSwgc29ydEJ5OiAzIH07XG5cblxuLy8gTWl4IGluIGVhY2ggbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cblxudmFyIGNvbmZpZyA9IFsgQ29sbGVjdGlvbiwgY29sbGVjdGlvbk1ldGhvZHMsICdtb2RlbHMnIF07XG5cbmZ1bmN0aW9uIGFkZE1ldGhvZHMoY29uZmlnKSB7XG4gICAgdmFyIEJhc2UgPSBjb25maWdbMF0sXG4gICAgICAgIG1ldGhvZHMgPSBjb25maWdbMV0sXG4gICAgICAgIGF0dHJpYnV0ZSA9IGNvbmZpZ1syXTtcblxuICAgIGNvbnN0IG1ldGhvZHNUb0FkZCA9IHtcbiAgICAgICAgc29ydEJ5LFxuICAgICAgICB0b0FycmF5XG4gICAgfTtcblxuICAgIGFkZE1ldGhvZHNVdGlsKEJhc2UsIG1ldGhvZHNUb0FkZCwgbWV0aG9kcywgYXR0cmlidXRlKTtcbn1cblxuYWRkTWV0aG9kcyhjb25maWcpO1xuXG4vLyBTZXQgdXAgaW5oZXJpdGFuY2UgZm9yIHRoZSBjb2xsZWN0aW9uLlxuQ29sbGVjdGlvbi5leHRlbmQgPSBleHRlbmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Collection.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Data.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Data.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Data {\n\n    constructor() {\n        this.map = new WeakMap();\n    }\n\n    has(obj, key) {\n        if (key === undefined) return this.map.has(obj);\n        return key in this.map.get(obj);\n    }\n\n    create(obj) {\n        if (!this.has(obj)) this.map.set(obj, Object.create(null));\n        return this.get(obj);\n    }\n\n    get(obj, key) {\n        if (!this.has(obj)) return undefined;\n        const data = this.map.get(obj);\n        if (key === undefined) return data;\n        return data[key];\n    }\n\n    set(obj, key, value) {\n        if (key === undefined) return;\n        const data = this.create(obj);\n        if (typeof key === 'string') {\n            data[key] = value;\n        } else {\n            Object.assign(data, key);\n        }\n    }\n\n    remove(obj, key) {\n        if (!this.has(obj)) return;\n        if (key === undefined) {\n            this.map.delete(obj);\n        } else {\n            const data = this.map.get(obj);\n            delete data[key];\n        }\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Data);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9EYXRhLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9EYXRhLm1qcz8xOGFhIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIERhdGEge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG5cbiAgICBoYXMob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5tYXAuaGFzKG9iaik7XG4gICAgICAgIHJldHVybiBrZXkgaW4gdGhpcy5tYXAuZ2V0KG9iaik7XG4gICAgfVxuXG4gICAgY3JlYXRlKG9iaikge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKG9iaikpIHRoaXMubWFwLnNldChvYmosIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQob2JqKTtcbiAgICB9XG5cbiAgICBnZXQob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhvYmopKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5tYXAuZ2V0KG9iaik7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgfVxuXG4gICAgc2V0KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY3JlYXRlKG9iaik7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGRhdGEsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmUob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhvYmopKSByZXR1cm47XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5tYXAuZ2V0KG9iaik7XG4gICAgICAgICAgICBkZWxldGUgZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRhO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Data.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/Dom.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ $)\n/* harmony export */ });\n/* harmony import */ var _util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/utilHelpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _vars_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vars.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\");\n/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs\");\n\n/*!\n * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-11-24T14:04Z\n */\n\n\n\n\n\nconst document = (typeof window !== 'undefined') ? window.document : null;\nconst documentElement = document && document.documentElement;\n\nconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n// Only count HTML whitespace\n// Other whitespace should count in values\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n// Define a local copy of $\nconst $ = function(selector) {\n    // The $ object is actually just the init constructor 'enhanced'\n    // Need init if $ is called (just allow error to be thrown if not included)\n    return new $.Dom(selector);\n};\n\n$.fn = $.prototype = {\n    constructor: $,\n    // The default length of a $ object is 0\n    length: 0,\n};\n\n// A global GUID counter for objects\n$.guid = 1;\n\n// User data storage\n$.data = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataUser;\n\n$.merge = function(first, second) {\n    let len = +second.length;\n    let i = first.length;\n    for (let j = 0; j < len; j++) {\n        first[i++] = second[j];\n    }\n    first.length = i;\n    return first;\n};\n\n$.parseHTML = function(string) {\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n    const context = document.implementation.createHTMLDocument();\n    // Set the base href for the created document so any parsed elements with URLs\n    // are based on the document's URL\n    const base = context.createElement('base');\n    base.href = document.location.href;\n    context.head.appendChild(base);\n\n    context.body.innerHTML = string;\n    // remove scripts\n    const scripts = context.getElementsByTagName('script');\n    for (let i = 0; i < scripts.length; i++) {\n        scripts[i].remove();\n    }\n    return Array.from(context.body.childNodes);\n};\n\nif (typeof Symbol === 'function') {\n    $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n}\n\n$.fn.toArray = function() {\n    return Array.from(this);\n};\n\n// Take an array of elements and push it onto the stack\n// (returning the new matched element set)\n$.fn.pushStack = function(elements) {\n    // Build a new $ matched element set\n    const ret = $.merge(this.constructor(), elements);\n    // Add the old object onto the stack (as a reference)\n    ret.prevObject = this;\n    // Return the newly-formed element set\n    return ret;\n};\n\n$.fn.find = function(selector) {\n    const [el] = this;\n    const ret = this.pushStack([]);\n    if (!el) return ret;\n    // Early return if context is not an element, document or document fragment\n    const { nodeType } = el;\n    if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return ret;\n    }\n    if (typeof selector !== 'string') {\n        if (el !== selector && el.contains(selector)) {\n            $.merge(ret, [selector]);\n        }\n    } else {\n        $.merge(ret, el.querySelectorAll(selector));\n    }\n    return ret;\n};\n\n$.fn.add = function(selector) {\n    const newElements = $(selector).toArray();\n    const prevElements = this.toArray();\n    const ret = this.pushStack([]);\n    $.merge(ret, (0,_util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq)(prevElements.concat(newElements)));\n    return ret;\n};\n\n$.fn.addBack = function() {\n    return this.add(this.prevObject);\n};\n\n$.fn.filter = function(selector) {\n    const matches = [];\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (!node.matches(selector)) continue;\n        matches.push(node);\n    }\n    return this.pushStack(matches);\n};\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n// Strict HTML recognition (trac-11290: must start with <)\n// Shortcut simple #id case for speed\nconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n\nfunction isObviousHtml(input) {\n    return (\n        input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3\n    );\n}\n\nconst Dom = function(selector) {\n    if (!selector) {\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        return this;\n    }\n    if (typeof selector === 'function') {\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        throw new Error('function not supported');\n    }\n    if (arguments.length > 1) {\n        throw new Error('selector with context not supported');\n    }\n    if (selector.nodeType) {\n        // HANDLE: $(DOMElement)\n        this[0] = selector;\n        this.length = 1;\n        return this;\n    }\n    let match;\n    if (isObviousHtml(selector + '')) {\n        // Handle obvious HTML strings\n        // Assume that strings that start and end with <> are HTML and skip\n        // the regex check. This also handles browser-supported HTML wrappers\n        // like TrustedHTML.\n        match = [null, selector, null];\n    } else if (typeof selector === 'string') {\n        // Handle HTML strings or selectors\n        match = rQuickExpr.exec(selector);\n    } else {\n        // Array-like\n        return $.merge(this, selector);\n    }\n    if (!match || !match[1]) {\n        // HANDLE: $(expr)\n        return $root.find(selector);\n    }\n    // Match html or make sure no context is specified for #id\n    // Note: match[1] may be a string or a TrustedHTML wrapper\n    if (match[1]) {\n        // HANDLE: $(html) -> $(array)\n        $.merge(this, $.parseHTML(match[1]));\n        return this;\n    }\n    // HANDLE: $(#id)\n    const el = document.getElementById(match[2]);\n    if (el) {\n        // Inject the element directly into the $ object\n        this[0] = el;\n        this.length = 1;\n    }\n    return this;\n};\n\n$.Dom = Dom;\n\n// Give the init function the $ prototype for later instantiation\nDom.prototype = $.fn;\n\n// Events\n\n$.Event = _Event_mjs__WEBPACK_IMPORTED_MODULE_2__.Event;\n\n$.event = {\n    special: Object.create(null),\n};\n\n$.event.has = function(elem, eventType) {\n    const events = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.get(elem, 'events');\n    if (!events) return false;\n    if (!eventType) return true;\n    return Array.isArray(events[eventType]) && events[eventType].length > 0;\n};\n\n$.event.on = function(elem, types, selector, data, fn, one) {\n\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n        // ( types-Object, selector, data )\n        if (typeof selector !== 'string') {\n            // ( types-Object, data )\n            data = data || selector;\n            selector = undefined;\n        }\n        for (let type in types) {\n            $.event.on(elem, type, selector, data, types[type], one);\n        }\n        return elem;\n    }\n\n    if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === 'string') {\n            // ( types, selector, fn )\n            fn = data;\n            data = undefined;\n        } else {\n            // ( types, data, fn )\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n    if (!fn) {\n        return elem;\n    }\n    if (one === 1) {\n        const origFn = fn;\n        fn = function(event) {\n            // Can use an empty set, since event contains the info\n            $().off(event);\n            return origFn.apply(this, arguments);\n        };\n\n        // Use same guid so caller can remove using origFn\n        fn.guid = origFn.guid || (origFn.guid = $.guid++);\n    }\n    for (let i = 0; i < elem.length; i++) {\n        $.event.add(elem[i], types, fn, data, selector);\n    }\n};\n\n$.event.add = function(elem, types, handler, data, selector) {\n    // Only attach events to objects for which we can store data\n    if (typeof elem != 'object') {\n        return;\n    }\n\n    const elemData = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.create(elem);\n\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handleObjIn;\n    if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n    }\n\n    // Ensure that invalid selectors throw exceptions at attach time\n    // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n    if (selector) {\n        documentElement.matches(selector);\n    }\n\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    if (!handler.guid) {\n        handler.guid = $.guid++;\n    }\n\n    // Init the element's event structure and main handler, if this is the first\n    let events;\n    if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n    }\n    let eventHandle;\n    if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function(e) {\n            // Discard the second event of a $.event.trigger() and\n            // when an event is called after a page has unloaded\n            return (typeof $ !== 'undefined')\n                ? $.event.dispatch.apply(elem, arguments)\n                : undefined;\n        };\n    }\n\n    // Handle multiple events separated by a space\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!origType) {\n            continue;\n        }\n\n        const namespaces = ns.split('.').sort();\n        // If event changes its type, use the special event handlers for the changed type\n        let special = $.event.special[origType];\n        // If selector defined, determine special event api type, otherwise given type\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        // Update special based on newly reset type\n        special = $.event.special[type];\n        // handleObj is passed to all event handlers\n        const handleObj = Object.assign(\n            {\n                type: type,\n                origType: origType,\n                data: data,\n                handler: handler,\n                guid: handler.guid,\n                selector: selector,\n                namespace: namespaces.join('.'),\n            },\n            handleObjIn\n        );\n\n        let handlers;\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n            handlers = events[type] = [];\n            handlers.delegateCount = 0;\n\n            // Only use addEventListener if the special events handler returns false\n            if (\n                !special || !special.setup ||\n                    special.setup.call(elem, data, namespaces, eventHandle) === false\n            ) {\n                if (elem.addEventListener) {\n                    elem.addEventListener(type, eventHandle);\n                }\n            }\n        }\n\n        if (special && special.add) {\n            special.add.call(elem, handleObj);\n            if (!handleObj.handler.guid) {\n                handleObj.handler.guid = handler.guid;\n            }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n            handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n            handlers.push(handleObj);\n        }\n    }\n};\n\n// Detach an event or set of events from an element\n$.event.remove = function(elem, types, handler, selector, mappedTypes) {\n\n    const elemData = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.get(elem);\n    if (!elemData || !elemData.events) return;\n    const events = elemData.events;\n\n    // Once for each type.namespace in types; type may be omitted\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!origType) {\n            for (const type in events) {\n                $.event.remove(\n                    elem,\n                    type + typesArr[i],\n                    handler,\n                    selector,\n                    true\n                );\n            }\n            continue;\n        }\n\n        const special = $.event.special[origType];\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        const handlers = events[type];\n        if (!handlers || handlers.length === 0) continue;\n\n        const namespaces = ns.split('.').sort();\n        const rNamespace = ns\n            ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\n            : null;\n\n        // Remove matching events\n        const origCount = handlers.length;\n        let j = origCount;\n        while (j--) {\n            const handleObj = handlers[j];\n\n            if (\n                (mappedTypes || origType === handleObj.origType) &&\n                    (!handler || handler.guid === handleObj.guid) &&\n                    (!rNamespace || rNamespace.test(handleObj.namespace)) &&\n                    (!selector ||\n                        selector === handleObj.selector ||\n                        (selector === '**' && handleObj.selector))\n            ) {\n                handlers.splice(j, 1);\n                if (handleObj.selector) {\n                    handlers.delegateCount--;\n                }\n                if (special && special.remove) {\n                    special.remove.call(elem, handleObj);\n                }\n            }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && handlers.length === 0) {\n            if (\n                !special || !special.teardown ||\n                    special.teardown.call(elem, namespaces, elemData.handle) === false\n            ) {\n                // This \"if\" is needed for plain objects\n                if (elem.removeEventListener) {\n                    elem.removeEventListener(type, elemData.handle);\n                }\n            }\n            delete events[type];\n        }\n    }\n\n    // Remove data if it's no longer used\n    if ((0,_util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(events)) {\n        _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.remove(elem, 'handle');\n        _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.remove(elem, 'events');\n    }\n};\n\n$.event.dispatch = function(nativeEvent) {\n\n    const elem = this;\n    // Make a writable $.Event from the native event object\n    const event = $.event.fix(nativeEvent);\n    event.delegateTarget = elem;\n    // Use the fix-ed $.Event rather than the (read-only) native event\n    const args = Array.from(arguments);\n    args[0] = event;\n\n    const eventsData = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.get(elem, 'events');\n    const handlers = (eventsData && eventsData[event.type]) || [];\n    const special = $.event.special[event.type];\n\n    // Call the preDispatch hook for the mapped type, and let it bail if desired\n    if (special && special.preDispatch) {\n        if (special.preDispatch.call(elem, event) === false) return;\n    }\n\n    // Determine handlers\n    const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n    // Run delegates first; they may want to stop propagation beneath us\n    let i = 0;\n    let matched;\n    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        let j = 0;\n        let handleObj;\n        while (\n            (handleObj = matched.handlers[j++]) &&\n                !event.isImmediatePropagationStopped()\n        ) {\n\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n\n            const origSpecial = $.event.special[handleObj.origType];\n            let handler;\n            if (origSpecial && origSpecial.handle) {\n                handler = origSpecial.handle;\n            } else {\n                handler = handleObj.handler;\n            }\n\n            const ret = handler.apply(matched.elem, args);\n            if (ret !== undefined) {\n                if ((event.result = ret) === false) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                }\n            }\n        }\n    }\n\n    // Call the postDispatch hook for the mapped type\n    if (special && special.postDispatch) {\n        special.postDispatch.call(elem, event);\n    }\n\n    return event.result;\n};\n\n$.event.handlers = function(event, handlers) {\n\n    const delegateCount = handlers.delegateCount;\n    const handlerQueue = [];\n\n    // Find delegate handlers\n    if (\n        delegateCount &&\n            // Support: Firefox <=42 - 66+\n            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n            // Support: IE 11+\n            // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n            !(event.type === 'click' && event.button >= 1)\n    ) {\n        for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n            // Don't check non-elements (trac-13208)\n            // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n            if (\n                cur.nodeType === 1 &&\n                    !(event.type === 'click' && cur.disabled === true)\n            ) {\n                const matchedHandlers = [];\n                const matchedSelectors = {};\n                for (let i = 0; i < delegateCount; i++) {\n                    const handleObj = handlers[i];\n                    // Don't conflict with Object.prototype properties (trac-13203)\n                    const sel = handleObj.selector + ' ';\n                    if (matchedSelectors[sel] === undefined) {\n                        matchedSelectors[sel] = cur.matches(sel);\n                    }\n                    if (matchedSelectors[sel]) {\n                        matchedHandlers.push(handleObj);\n                    }\n                }\n                if (matchedHandlers.length) {\n                    handlerQueue.push({\n                        elem: cur,\n                        handlers: matchedHandlers,\n                    });\n                }\n            }\n        }\n    }\n\n    // Add the remaining (directly-bound) handlers\n    if (delegateCount < handlers.length) {\n        handlerQueue.push({\n            elem: this,\n            handlers: handlers.slice(delegateCount),\n        });\n    }\n\n    return handlerQueue;\n};\n\n$.event.fix = function(originalEvent) {\n    return originalEvent.envelope ? originalEvent : new _Event_mjs__WEBPACK_IMPORTED_MODULE_2__.Event(originalEvent);\n};\n\n// A central reference to the root $(document)\nconst $root = $(document);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vRG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyRDtBQUNYO0FBQ1o7O0FBRXBDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVMsK0NBQVE7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUFJO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDZDQUFLOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwrQ0FBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwrQ0FBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsK0NBQVE7QUFDN0I7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSw4REFBTztBQUNmLFFBQVEsK0NBQVE7QUFDaEIsUUFBUSwrQ0FBUTtBQUNoQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QiwrQ0FBUTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsNkNBQUs7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvRG9tL0RvbS5tanM/NDhhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2NC4wLjAtcHJlK2M5ODU5N2VhLmRpcnR5XG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDIzLTExLTI0VDE0OjA0WlxuICovXG5cbmltcG9ydCB7IHVuaXEsIGlzRW1wdHkgfSBmcm9tICcuLi8uLi91dGlsL3V0aWxIZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBkYXRhUHJpdiwgZGF0YVVzZXIgfSBmcm9tICcuL3ZhcnMubWpzJztcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi9FdmVudC5tanMnO1xuXG5jb25zdCBkb2N1bWVudCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cuZG9jdW1lbnQgOiBudWxsO1xuY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5jb25zdCByVHlwZU5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbi8vIE9ubHkgY291bnQgSFRNTCB3aGl0ZXNwYWNlXG4vLyBPdGhlciB3aGl0ZXNwYWNlIHNob3VsZCBjb3VudCBpbiB2YWx1ZXNcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS13aGl0ZXNwYWNlXG5jb25zdCByTm90SHRtbFdoaXRlID0gL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nO1xuXG4vLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mICRcbmNvbnN0ICQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIC8vIFRoZSAkIG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcbiAgICAvLyBOZWVkIGluaXQgaWYgJCBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcbiAgICByZXR1cm4gbmV3ICQuRG9tKHNlbGVjdG9yKTtcbn07XG5cbiQuZm4gPSAkLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogJCxcbiAgICAvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSAkIG9iamVjdCBpcyAwXG4gICAgbGVuZ3RoOiAwLFxufTtcblxuLy8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG4kLmd1aWQgPSAxO1xuXG4vLyBVc2VyIGRhdGEgc3RvcmFnZVxuJC5kYXRhID0gZGF0YVVzZXI7XG5cbiQubWVyZ2UgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XG4gICAgbGV0IGxlbiA9ICtzZWNvbmQubGVuZ3RoO1xuICAgIGxldCBpID0gZmlyc3QubGVuZ3RoO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgZmlyc3RbaSsrXSA9IHNlY29uZFtqXTtcbiAgICB9XG4gICAgZmlyc3QubGVuZ3RoID0gaTtcbiAgICByZXR1cm4gZmlyc3Q7XG59O1xuXG4kLnBhcnNlSFRNTCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIC8vIElubGluZSBldmVudHMgd2lsbCBub3QgZXhlY3V0ZSB3aGVuIHRoZSBIVE1MIGlzIHBhcnNlZDsgdGhpcyBpbmNsdWRlcywgZm9yIGV4YW1wbGUsIHNlbmRpbmcgR0VUIHJlcXVlc3RzIGZvciBpbWFnZXMuXG4gICAgY29uc3QgY29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgpO1xuICAgIC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudCBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuICAgIC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkxcbiAgICBjb25zdCBiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgYmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcbiAgICBjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoYmFzZSk7XG5cbiAgICBjb250ZXh0LmJvZHkuaW5uZXJIVE1MID0gc3RyaW5nO1xuICAgIC8vIHJlbW92ZSBzY3JpcHRzXG4gICAgY29uc3Qgc2NyaXB0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzY3JpcHRzW2ldLnJlbW92ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjb250ZXh0LmJvZHkuY2hpbGROb2Rlcyk7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICQuZm5bU3ltYm9sLml0ZXJhdG9yXSA9IEFycmF5LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdO1xufVxuXG4kLmZuLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzKTtcbn07XG5cbi8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcbi8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuJC5mbi5wdXNoU3RhY2sgPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgIC8vIEJ1aWxkIGEgbmV3ICQgbWF0Y2hlZCBlbGVtZW50IHNldFxuICAgIGNvbnN0IHJldCA9ICQubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtZW50cyk7XG4gICAgLy8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcbiAgICByZXQucHJldk9iamVjdCA9IHRoaXM7XG4gICAgLy8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcbiAgICByZXR1cm4gcmV0O1xufTtcblxuJC5mbi5maW5kID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICBjb25zdCBbZWxdID0gdGhpcztcbiAgICBjb25zdCByZXQgPSB0aGlzLnB1c2hTdGFjayhbXSk7XG4gICAgaWYgKCFlbCkgcmV0dXJuIHJldDtcbiAgICAvLyBFYXJseSByZXR1cm4gaWYgY29udGV4dCBpcyBub3QgYW4gZWxlbWVudCwgZG9jdW1lbnQgb3IgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICBjb25zdCB7IG5vZGVUeXBlIH0gPSBlbDtcbiAgICBpZiAobm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChlbCAhPT0gc2VsZWN0b3IgJiYgZWwuY29udGFpbnMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAkLm1lcmdlKHJldCwgW3NlbGVjdG9yXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAkLm1lcmdlKHJldCwgZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuJC5mbi5hZGQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIGNvbnN0IG5ld0VsZW1lbnRzID0gJChzZWxlY3RvcikudG9BcnJheSgpO1xuICAgIGNvbnN0IHByZXZFbGVtZW50cyA9IHRoaXMudG9BcnJheSgpO1xuICAgIGNvbnN0IHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcbiAgICAkLm1lcmdlKHJldCwgdW5pcShwcmV2RWxlbWVudHMuY29uY2F0KG5ld0VsZW1lbnRzKSkpO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG4kLmZuLmFkZEJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQodGhpcy5wcmV2T2JqZWN0KTtcbn07XG5cbiQuZm4uZmlsdGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW2ldO1xuICAgICAgICBpZiAoIW5vZGUubWF0Y2hlcyhzZWxlY3RvcikpIGNvbnRpbnVlO1xuICAgICAgICBtYXRjaGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhtYXRjaGVzKTtcbn07XG5cbi8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG4vLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAodHJhYy05NTIxKVxuLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKHRyYWMtMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuLy8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuY29uc3QgclF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvO1xuXG5mdW5jdGlvbiBpc09idmlvdXNIdG1sKGlucHV0KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgaW5wdXRbMF0gPT09ICc8JyAmJiBpbnB1dFtpbnB1dC5sZW5ndGggLSAxXSA9PT0gJz4nICYmIGlucHV0Lmxlbmd0aCA+PSAzXG4gICAgKTtcbn1cblxuY29uc3QgRG9tID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Z1bmN0aW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VsZWN0b3Igd2l0aCBjb250ZXh0IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yLm5vZGVUeXBlKSB7XG4gICAgICAgIC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuICAgICAgICB0aGlzWzBdID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxldCBtYXRjaDtcbiAgICBpZiAoaXNPYnZpb3VzSHRtbChzZWxlY3RvciArICcnKSkge1xuICAgICAgICAvLyBIYW5kbGUgb2J2aW91cyBIVE1MIHN0cmluZ3NcbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcFxuICAgICAgICAvLyB0aGUgcmVnZXggY2hlY2suIFRoaXMgYWxzbyBoYW5kbGVzIGJyb3dzZXItc3VwcG9ydGVkIEhUTUwgd3JhcHBlcnNcbiAgICAgICAgLy8gbGlrZSBUcnVzdGVkSFRNTC5cbiAgICAgICAgbWF0Y2ggPSBbbnVsbCwgc2VsZWN0b3IsIG51bGxdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBIYW5kbGUgSFRNTCBzdHJpbmdzIG9yIHNlbGVjdG9yc1xuICAgICAgICBtYXRjaCA9IHJRdWlja0V4cHIuZXhlYyhzZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXJyYXktbGlrZVxuICAgICAgICByZXR1cm4gJC5tZXJnZSh0aGlzLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzFdKSB7XG4gICAgICAgIC8vIEhBTkRMRTogJChleHByKVxuICAgICAgICByZXR1cm4gJHJvb3QuZmluZChzZWxlY3Rvcik7XG4gICAgfVxuICAgIC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcbiAgICAvLyBOb3RlOiBtYXRjaFsxXSBtYXkgYmUgYSBzdHJpbmcgb3IgYSBUcnVzdGVkSFRNTCB3cmFwcGVyXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuICAgICAgICAkLm1lcmdlKHRoaXMsICQucGFyc2VIVE1MKG1hdGNoWzFdKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBIQU5ETEU6ICQoI2lkKVxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobWF0Y2hbMl0pO1xuICAgIGlmIChlbCkge1xuICAgICAgICAvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgJCBvYmplY3RcbiAgICAgICAgdGhpc1swXSA9IGVsO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuJC5Eb20gPSBEb207XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlICQgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5Eb20ucHJvdG90eXBlID0gJC5mbjtcblxuLy8gRXZlbnRzXG5cbiQuRXZlbnQgPSBFdmVudDtcblxuJC5ldmVudCA9IHtcbiAgICBzcGVjaWFsOiBPYmplY3QuY3JlYXRlKG51bGwpLFxufTtcblxuJC5ldmVudC5oYXMgPSBmdW5jdGlvbihlbGVtLCBldmVudFR5cGUpIHtcbiAgICBjb25zdCBldmVudHMgPSBkYXRhUHJpdi5nZXQoZWxlbSwgJ2V2ZW50cycpO1xuICAgIGlmICghZXZlbnRzKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFldmVudFR5cGUpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGV2ZW50c1tldmVudFR5cGVdKSAmJiBldmVudHNbZXZlbnRUeXBlXS5sZW5ndGggPiAwO1xufTtcblxuJC5ldmVudC5vbiA9IGZ1bmN0aW9uKGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSkge1xuXG4gICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG4gICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiB0eXBlcykge1xuICAgICAgICAgICAgJC5ldmVudC5vbihlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbdHlwZV0sIG9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsKSB7XG4gICAgICAgIC8vICggdHlwZXMsIGZuIClcbiAgICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcbiAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG4gICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cbiAgICBpZiAob25lID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG9yaWdGbiA9IGZuO1xuICAgICAgICBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cbiAgICAgICAgICAgICQoKS5vZmYoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG4gICAgICAgIGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAob3JpZ0ZuLmd1aWQgPSAkLmd1aWQrKyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAkLmV2ZW50LmFkZChlbGVtW2ldLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yKTtcbiAgICB9XG59O1xuXG4kLmV2ZW50LmFkZCA9IGZ1bmN0aW9uKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3Rvcikge1xuICAgIC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIGZvciB3aGljaCB3ZSBjYW4gc3RvcmUgZGF0YVxuICAgIGlmICh0eXBlb2YgZWxlbSAhPSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbURhdGEgPSBkYXRhUHJpdi5jcmVhdGUoZWxlbSk7XG5cbiAgICAvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcbiAgICBsZXQgaGFuZGxlT2JqSW47XG4gICAgaWYgKGhhbmRsZXIuaGFuZGxlcikge1xuICAgICAgICBoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuICAgICAgICBzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcbiAgICAvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgZG9jdW1lbnRFbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuICAgIGlmICghaGFuZGxlci5ndWlkKSB7XG4gICAgICAgIGhhbmRsZXIuZ3VpZCA9ICQuZ3VpZCsrO1xuICAgIH1cblxuICAgIC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICBsZXQgZXZlbnRzO1xuICAgIGlmICghKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykpIHtcbiAgICAgICAgZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgbGV0IGV2ZW50SGFuZGxlO1xuICAgIGlmICghKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSkge1xuICAgICAgICBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhICQuZXZlbnQudHJpZ2dlcigpIGFuZFxuICAgICAgICAgICAgLy8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgJCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgPyAkLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGVsZW0sIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG4gICAgY29uc3QgdHlwZXNBcnIgPSAodHlwZXMgfHwgJycpLm1hdGNoKHJOb3RIdG1sV2hpdGUpIHx8IFsnJ107XG4gICAgbGV0IGkgPSB0eXBlc0Fyci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBbLCBvcmlnVHlwZSwgbnMgPSAnJ10gPSByVHlwZU5hbWVzcGFjZS5leGVjKHR5cGVzQXJyW2ldKTtcbiAgICAgICAgLy8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG4gICAgICAgIGlmICghb3JpZ1R5cGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmFtZXNwYWNlcyA9IG5zLnNwbGl0KCcuJykuc29ydCgpO1xuICAgICAgICAvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcbiAgICAgICAgbGV0IHNwZWNpYWwgPSAkLmV2ZW50LnNwZWNpYWxbb3JpZ1R5cGVdO1xuICAgICAgICAvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcbiAgICAgICAgY29uc3QgdHlwZSA9IChzcGVjaWFsICYmIChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkpIHx8IG9yaWdUeXBlO1xuICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG4gICAgICAgIHNwZWNpYWwgPSAkLmV2ZW50LnNwZWNpYWxbdHlwZV07XG4gICAgICAgIC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGNvbnN0IGhhbmRsZU9iaiA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBvcmlnVHlwZTogb3JpZ1R5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIGd1aWQ6IGhhbmRsZXIuZ3VpZCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oJy4nKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVPYmpJblxuICAgICAgICApO1xuXG4gICAgICAgIGxldCBoYW5kbGVycztcbiAgICAgICAgLy8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3RcbiAgICAgICAgaWYgKCEoaGFuZGxlcnMgPSBldmVudHNbdHlwZV0pKSB7XG4gICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFzcGVjaWFsIHx8ICFzcGVjaWFsLnNldHVwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWwuc2V0dXAuY2FsbChlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBldmVudEhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWNpYWwgJiYgc3BlY2lhbC5hZGQpIHtcbiAgICAgICAgICAgIHNwZWNpYWwuYWRkLmNhbGwoZWxlbSwgaGFuZGxlT2JqKTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZU9iaik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcbiQuZXZlbnQucmVtb3ZlID0gZnVuY3Rpb24oZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcykge1xuXG4gICAgY29uc3QgZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoZWxlbSk7XG4gICAgaWYgKCFlbGVtRGF0YSB8fCAhZWxlbURhdGEuZXZlbnRzKSByZXR1cm47XG4gICAgY29uc3QgZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzO1xuXG4gICAgLy8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuICAgIGNvbnN0IHR5cGVzQXJyID0gKHR5cGVzIHx8ICcnKS5tYXRjaChyTm90SHRtbFdoaXRlKSB8fCBbJyddO1xuICAgIGxldCBpID0gdHlwZXNBcnIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgWywgb3JpZ1R5cGUsIG5zID0gJyddID0gclR5cGVOYW1lc3BhY2UuZXhlYyh0eXBlc0FycltpXSk7XG4gICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuICAgICAgICBpZiAoIW9yaWdUeXBlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgJC5ldmVudC5yZW1vdmUoXG4gICAgICAgICAgICAgICAgICAgIGVsZW0sXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKyB0eXBlc0FycltpXSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcGVjaWFsID0gJC5ldmVudC5zcGVjaWFsW29yaWdUeXBlXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IChzcGVjaWFsICYmIChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkpIHx8IG9yaWdUeXBlO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCBoYW5kbGVycy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBucy5zcGxpdCgnLicpLnNvcnQoKTtcbiAgICAgICAgY29uc3Qgck5hbWVzcGFjZSA9IG5zXG4gICAgICAgICAgICA/IG5ldyBSZWdFeHAoJyhefFxcXFwuKScgKyBuYW1lc3BhY2VzLmpvaW4oJ1xcXFwuKD86LipcXFxcLnwpJykgKyAnKFxcXFwufCQpJylcbiAgICAgICAgICAgIDogbnVsbDtcblxuICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG4gICAgICAgIGNvbnN0IG9yaWdDb3VudCA9IGhhbmRsZXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IGogPSBvcmlnQ291bnQ7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICghaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXJOYW1lc3BhY2UgfHwgck5hbWVzcGFjZS50ZXN0KGhhbmRsZU9iai5uYW1lc3BhY2UpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VsZWN0b3IgPT09ICcqKicgJiYgaGFuZGxlT2JqLnNlbGVjdG9yKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlT2JqLnNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwgJiYgc3BlY2lhbC5yZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5yZW1vdmUuY2FsbChlbGVtLCBoYW5kbGVPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcbiAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG4gICAgICAgIGlmIChvcmlnQ291bnQgJiYgaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNwZWNpYWwgfHwgIXNwZWNpYWwudGVhcmRvd24gfHxcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC50ZWFyZG93bi5jYWxsKGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSkgPT09IGZhbHNlXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZGF0YSBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG4gICAgaWYgKGlzRW1wdHkoZXZlbnRzKSkge1xuICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgJ2hhbmRsZScpO1xuICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWxlbSwgJ2V2ZW50cycpO1xuICAgIH1cbn07XG5cbiQuZXZlbnQuZGlzcGF0Y2ggPSBmdW5jdGlvbihuYXRpdmVFdmVudCkge1xuXG4gICAgY29uc3QgZWxlbSA9IHRoaXM7XG4gICAgLy8gTWFrZSBhIHdyaXRhYmxlICQuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgIGNvbnN0IGV2ZW50ID0gJC5ldmVudC5maXgobmF0aXZlRXZlbnQpO1xuICAgIGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gZWxlbTtcbiAgICAvLyBVc2UgdGhlIGZpeC1lZCAkLkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcbiAgICBjb25zdCBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgIGFyZ3NbMF0gPSBldmVudDtcblxuICAgIGNvbnN0IGV2ZW50c0RhdGEgPSBkYXRhUHJpdi5nZXQoZWxlbSwgJ2V2ZW50cycpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gKGV2ZW50c0RhdGEgJiYgZXZlbnRzRGF0YVtldmVudC50eXBlXSkgfHwgW107XG4gICAgY29uc3Qgc3BlY2lhbCA9ICQuZXZlbnQuc3BlY2lhbFtldmVudC50eXBlXTtcblxuICAgIC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcbiAgICBpZiAoc3BlY2lhbCAmJiBzcGVjaWFsLnByZURpc3BhdGNoKSB7XG4gICAgICAgIGlmIChzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoZWxlbSwgZXZlbnQpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBoYW5kbGVyc1xuICAgIGNvbnN0IGhhbmRsZXJRdWV1ZSA9ICQuZXZlbnQuaGFuZGxlcnMuY2FsbChlbGVtLCBldmVudCwgaGFuZGxlcnMpO1xuXG4gICAgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IG1hdGNoZWQ7XG4gICAgd2hpbGUgKChtYXRjaGVkID0gaGFuZGxlclF1ZXVlW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgbGV0IGhhbmRsZU9iajtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbaisrXSkgJiZcbiAgICAgICAgICAgICAgICAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKVxuICAgICAgICApIHtcblxuICAgICAgICAgICAgZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG4gICAgICAgICAgICBjb25zdCBvcmlnU3BlY2lhbCA9ICQuZXZlbnQuc3BlY2lhbFtoYW5kbGVPYmoub3JpZ1R5cGVdO1xuICAgICAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgICAgICBpZiAob3JpZ1NwZWNpYWwgJiYgb3JpZ1NwZWNpYWwuaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IG9yaWdTcGVjaWFsLmhhbmRsZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZU9iai5oYW5kbGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXQgPSBoYW5kbGVyLmFwcGx5KG1hdGNoZWQuZWxlbSwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGV2ZW50LnJlc3VsdCA9IHJldCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcbiAgICBpZiAoc3BlY2lhbCAmJiBzcGVjaWFsLnBvc3REaXNwYXRjaCkge1xuICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKGVsZW0sIGV2ZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnQucmVzdWx0O1xufTtcblxuJC5ldmVudC5oYW5kbGVycyA9IGZ1bmN0aW9uKGV2ZW50LCBoYW5kbGVycykge1xuXG4gICAgY29uc3QgZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQ7XG4gICAgY29uc3QgaGFuZGxlclF1ZXVlID0gW107XG5cbiAgICAvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG4gICAgaWYgKFxuICAgICAgICBkZWxlZ2F0ZUNvdW50ICYmXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDIgLSA2NitcbiAgICAgICAgICAgIC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDExK1xuICAgICAgICAgICAgLy8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuICAgICAgICAgICAgIShldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LmJ1dHRvbiA+PSAxKVxuICAgICkge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBldmVudC50YXJnZXQ7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcykge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICh0cmFjLTEzMjA4KVxuICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKHRyYWMtNjkxMSwgdHJhYy04MTY1LCB0cmFjLTExMzgyLCB0cmFjLTExNzY0KVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAhKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZU9iaiA9IGhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAodHJhYy0xMzIwMylcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTZWxlY3RvcnNbc2VsXSA9IGN1ci5tYXRjaGVzKHNlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTZWxlY3RvcnNbc2VsXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEhhbmRsZXJzLnB1c2goaGFuZGxlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtOiBjdXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG4gICAgaWYgKGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgZWxlbTogdGhpcyxcbiAgICAgICAgICAgIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZShkZWxlZ2F0ZUNvdW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXJRdWV1ZTtcbn07XG5cbiQuZXZlbnQuZml4ID0gZnVuY3Rpb24ob3JpZ2luYWxFdmVudCkge1xuICAgIHJldHVybiBvcmlnaW5hbEV2ZW50LmVudmVsb3BlID8gb3JpZ2luYWxFdmVudCA6IG5ldyBFdmVudChvcmlnaW5hbEV2ZW50KTtcbn07XG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgJChkb2N1bWVudClcbmNvbnN0ICRyb290ID0gJChkb2N1bWVudCk7XG5cbmV4cG9ydCB7ICQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/Event.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Event: () => (/* binding */ Event)\n/* harmony export */ });\nconst Event = function(src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof Event)) {\n        return new Event(src, props);\n    }\n\n    // Event object\n    if (src && src.type) {\n        this.originalEvent = src;\n        this.type = src.type;\n\n        // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n        this.isDefaultPrevented = src.defaultPrevented\n            ? returnTrue\n            : returnFalse;\n\n        // Create target properties\n        this.target = src.target;\n        this.currentTarget = src.currentTarget;\n        this.relatedTarget = src.relatedTarget;\n\n        // Event type\n    } else {\n        this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n        Object.assign(this, props);\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = (src && src.timeStamp) || Date.now();\n\n    // Mark it as fixed\n    this.envelope = true;\n};\n\n// $.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n    constructor: Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function() {\n        const evt = this.originalEvent;\n        this.isDefaultPrevented = returnTrue;\n        if (evt) {\n            evt.preventDefault();\n        }\n    },\n    stopPropagation: function() {\n        const evt = this.originalEvent;\n        this.isPropagationStopped = returnTrue;\n        if (evt) {\n            evt.stopPropagation();\n        }\n    },\n    stopImmediatePropagation: function() {\n        const evt = this.originalEvent;\n        this.isImmediatePropagationStopped = returnTrue;\n        if (evt) {\n            evt.stopImmediatePropagation();\n        }\n        this.stopPropagation();\n    },\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\n[\n    'altKey',\n    'bubbles',\n    'cancelable',\n    'changedTouches',\n    'ctrlKey',\n    'detail',\n    'eventPhase',\n    'metaKey',\n    'pageX',\n    'pageY',\n    'shiftKey',\n    'view',\n    'char',\n    'code',\n    'charCode',\n    'key',\n    'keyCode',\n    'button',\n    'buttons',\n    'clientX',\n    'clientY',\n    'offsetX',\n    'offsetY',\n    'pointerId',\n    'pointerType',\n    'screenX',\n    'screenY',\n    'targetTouches',\n    'toElement',\n    'touches',\n    'which',\n].forEach((name) => addProp(name));\n\nfunction addProp(name) {\n    Object.defineProperty(Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: function() {\n            return this.originalEvent ? this.originalEvent[name] : undefined;\n        },\n        set: function(value) {\n            Object.defineProperty(this, name, {\n                enumerable: true,\n                configurable: true,\n                writable: true,\n                value: value,\n            });\n        },\n    });\n}\n\nfunction returnTrue() {\n    return true;\n}\n\nfunction returnFalse() {\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vRXZlbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vRXZlbnQubWpzP2FiNmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IEV2ZW50ID0gZnVuY3Rpb24oc3JjLCBwcm9wcykge1xuICAgIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFdmVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudChzcmMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBFdmVudCBvYmplY3RcbiAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWRcbiAgICAgICAgICAgID8gcmV0dXJuVHJ1ZVxuICAgICAgICAgICAgOiByZXR1cm5GYWxzZTtcblxuICAgICAgICAvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy50YXJnZXQgPSBzcmMudGFyZ2V0O1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcbiAgICAgICAgdGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgLy8gRXZlbnQgdHlwZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICB9XG5cbiAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgIGlmIChwcm9wcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgIHRoaXMudGltZVN0YW1wID0gKHNyYyAmJiBzcmMudGltZVN0YW1wKSB8fCBEYXRlLm5vdygpO1xuXG4gICAgLy8gTWFyayBpdCBhcyBmaXhlZFxuICAgIHRoaXMuZW52ZWxvcGUgPSB0cnVlO1xufTtcblxuLy8gJC5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBFdmVudCxcbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBldnQgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGV2dCA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICAgIGlmIChldnQpIHtcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZXZ0ID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5bXG4gICAgJ2FsdEtleScsXG4gICAgJ2J1YmJsZXMnLFxuICAgICdjYW5jZWxhYmxlJyxcbiAgICAnY2hhbmdlZFRvdWNoZXMnLFxuICAgICdjdHJsS2V5JyxcbiAgICAnZGV0YWlsJyxcbiAgICAnZXZlbnRQaGFzZScsXG4gICAgJ21ldGFLZXknLFxuICAgICdwYWdlWCcsXG4gICAgJ3BhZ2VZJyxcbiAgICAnc2hpZnRLZXknLFxuICAgICd2aWV3JyxcbiAgICAnY2hhcicsXG4gICAgJ2NvZGUnLFxuICAgICdjaGFyQ29kZScsXG4gICAgJ2tleScsXG4gICAgJ2tleUNvZGUnLFxuICAgICdidXR0b24nLFxuICAgICdidXR0b25zJyxcbiAgICAnY2xpZW50WCcsXG4gICAgJ2NsaWVudFknLFxuICAgICdvZmZzZXRYJyxcbiAgICAnb2Zmc2V0WScsXG4gICAgJ3BvaW50ZXJJZCcsXG4gICAgJ3BvaW50ZXJUeXBlJyxcbiAgICAnc2NyZWVuWCcsXG4gICAgJ3NjcmVlblknLFxuICAgICd0YXJnZXRUb3VjaGVzJyxcbiAgICAndG9FbGVtZW50JyxcbiAgICAndG91Y2hlcycsXG4gICAgJ3doaWNoJyxcbl0uZm9yRWFjaCgobmFtZSkgPT4gYWRkUHJvcChuYW1lKSk7XG5cbmZ1bmN0aW9uIGFkZFByb3AobmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudCA/IHRoaXMub3JpZ2luYWxFdmVudFtuYW1lXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/animations.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/animations.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animate: () => (/* binding */ animate),\n/* harmony export */   stop: () => (/* binding */ stop)\n/* harmony export */ });\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dom.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n/* harmony import */ var _vars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vars.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\");\n\n\n\nconst animationKey = 'animationFrameId';\nconst cssReset = {};\n\ncssReset['transition-property'] =\ncssReset['transition-duration'] =\ncssReset['transition-delay'] =\ncssReset['transition-timing-function'] =\ncssReset['animation-name'] =\ncssReset['animation-duration'] =\ncssReset['animation-delay'] =\ncssReset['animation-timing-function'] = '';\n\nfunction animate(properties, opt = {}) {\n    this.stop();\n    for (let i = 0; i < this.length; i++) {\n        animateNode(this[i], properties, opt);\n    }\n    return this;\n}\n\nfunction animateNode(el, properties, opt = {}) {\n\n    let {\n        duration = 400,\n        easing = 'ease-in-out',\n        delay = 0,\n        complete\n    } = opt;\n\n    const delayId = setTimeout(function() {\n\n        const $el = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(el);\n        let fired = false;\n        let endEvent = 'transitionend';\n\n        // Convert milliseconds to seconds for CSS\n        duration = duration / 1000;\n        delay = delay / 1000;\n\n        // Set up CSS values for transition or keyframe animation\n        const cssValues = {};\n        if (typeof properties === 'string') {\n            // Keyframe animation\n            cssValues['animation-name'] = properties;\n            cssValues['animation-duration'] = duration + 's';\n            cssValues['animation-delay'] = delay + 's';\n            cssValues['animation-timing-function'] = easing;\n            endEvent = 'animationend';\n        } else {\n            // CSS transitions\n            const transitionProperties = [];\n            for (var key in properties) {\n                if (properties.hasOwnProperty(key)) {\n                    cssValues[key] = properties[key];\n                    transitionProperties.push(key);\n                }\n            }\n\n            if (duration > 0) {\n                cssValues['transition-property'] = transitionProperties.join(', ');\n                cssValues['transition-duration'] = duration + 's';\n                cssValues['transition-delay'] = delay + 's';\n                cssValues['transition-timing-function'] = easing;\n            }\n        }\n\n        const wrappedCallback = function(event){\n            if (event) {\n                if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from \"below\"\n                event.target.removeEventListener(endEvent, wrappedCallback);\n            } else {\n                el.removeEventListener(endEvent, wrappedCallback); // triggered by setTimeout\n            }\n            fired = true;\n            $el.css(cssReset);\n            complete && complete.call(el);\n        };\n\n        if (duration > 0){\n            el.addEventListener(endEvent, wrappedCallback);\n            // transitionEnd is not always firing on older Android phones\n            // so make sure it gets fired\n            const callbackId = setTimeout(function() {\n                if (fired) return;\n                wrappedCallback(null);\n            }, ((duration + delay) * 1000) + 25);\n\n            _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.set(el, animationKey, {\n                id: callbackId,\n                stop: () => {\n                    clearTimeout(callbackId);\n                    el.removeEventListener(endEvent, wrappedCallback);\n                }\n            });\n        }\n\n        $el.css(cssValues);\n\n        if (duration <= 0) {\n            wrappedCallback(null);\n        }\n    });\n\n    _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.set(el, animationKey, {\n        stop: () => clearTimeout(delayId)\n    });\n}\n\nfunction stop() {\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        const animation = _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.get(el, animationKey);\n        if (!animation) continue;\n        animation.stop();\n        _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.remove(el, animationKey);\n    }\n    this.css(cssReset);\n    return this;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vYW5pbWF0aW9ucy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwQjtBQUNZOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8scUNBQXFDO0FBQzVDO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBLG9CQUFvQixvREFBQztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsY0FBYztBQUNkLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYixZQUFZLCtDQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxJQUFJLCtDQUFRO0FBQ1o7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0EsMEJBQTBCLCtDQUFRO0FBQ2xDO0FBQ0E7QUFDQSxRQUFRLCtDQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9hbmltYXRpb25zLm1qcz85NzUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkIGZyb20gJy4vRG9tLm1qcyc7XG5pbXBvcnQgeyBkYXRhUHJpdiB9IGZyb20gJy4vdmFycy5tanMnO1xuXG5jb25zdCBhbmltYXRpb25LZXkgPSAnYW5pbWF0aW9uRnJhbWVJZCc7XG5jb25zdCBjc3NSZXNldCA9IHt9O1xuXG5jc3NSZXNldFsndHJhbnNpdGlvbi1wcm9wZXJ0eSddID1cbmNzc1Jlc2V0Wyd0cmFuc2l0aW9uLWR1cmF0aW9uJ10gPVxuY3NzUmVzZXRbJ3RyYW5zaXRpb24tZGVsYXknXSA9XG5jc3NSZXNldFsndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nXSA9XG5jc3NSZXNldFsnYW5pbWF0aW9uLW5hbWUnXSA9XG5jc3NSZXNldFsnYW5pbWF0aW9uLWR1cmF0aW9uJ10gPVxuY3NzUmVzZXRbJ2FuaW1hdGlvbi1kZWxheSddID1cbmNzc1Jlc2V0WydhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSAnJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFuaW1hdGUocHJvcGVydGllcywgb3B0ID0ge30pIHtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYW5pbWF0ZU5vZGUodGhpc1tpXSwgcHJvcGVydGllcywgb3B0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVOb2RlKGVsLCBwcm9wZXJ0aWVzLCBvcHQgPSB7fSkge1xuXG4gICAgbGV0IHtcbiAgICAgICAgZHVyYXRpb24gPSA0MDAsXG4gICAgICAgIGVhc2luZyA9ICdlYXNlLWluLW91dCcsXG4gICAgICAgIGRlbGF5ID0gMCxcbiAgICAgICAgY29tcGxldGVcbiAgICB9ID0gb3B0O1xuXG4gICAgY29uc3QgZGVsYXlJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc3QgJGVsID0gJChlbCk7XG4gICAgICAgIGxldCBmaXJlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG5cbiAgICAgICAgLy8gQ29udmVydCBtaWxsaXNlY29uZHMgdG8gc2Vjb25kcyBmb3IgQ1NTXG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gLyAxMDAwO1xuICAgICAgICBkZWxheSA9IGRlbGF5IC8gMTAwMDtcblxuICAgICAgICAvLyBTZXQgdXAgQ1NTIHZhbHVlcyBmb3IgdHJhbnNpdGlvbiBvciBrZXlmcmFtZSBhbmltYXRpb25cbiAgICAgICAgY29uc3QgY3NzVmFsdWVzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIEtleWZyYW1lIGFuaW1hdGlvblxuICAgICAgICAgICAgY3NzVmFsdWVzWydhbmltYXRpb24tbmFtZSddID0gcHJvcGVydGllcztcbiAgICAgICAgICAgIGNzc1ZhbHVlc1snYW5pbWF0aW9uLWR1cmF0aW9uJ10gPSBkdXJhdGlvbiArICdzJztcbiAgICAgICAgICAgIGNzc1ZhbHVlc1snYW5pbWF0aW9uLWRlbGF5J10gPSBkZWxheSArICdzJztcbiAgICAgICAgICAgIGNzc1ZhbHVlc1snYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbiddID0gZWFzaW5nO1xuICAgICAgICAgICAgZW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENTUyB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvblByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjc3NWYWx1ZXNba2V5XSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblByb3BlcnRpZXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGNzc1ZhbHVlc1sndHJhbnNpdGlvbi1wcm9wZXJ0eSddID0gdHJhbnNpdGlvblByb3BlcnRpZXMuam9pbignLCAnKTtcbiAgICAgICAgICAgICAgICBjc3NWYWx1ZXNbJ3RyYW5zaXRpb24tZHVyYXRpb24nXSA9IGR1cmF0aW9uICsgJ3MnO1xuICAgICAgICAgICAgICAgIGNzc1ZhbHVlc1sndHJhbnNpdGlvbi1kZWxheSddID0gZGVsYXkgKyAncyc7XG4gICAgICAgICAgICAgICAgY3NzVmFsdWVzWyd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddID0gZWFzaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkgcmV0dXJuOyAvLyBtYWtlcyBzdXJlIHRoZSBldmVudCBkaWRuJ3QgYnViYmxlIGZyb20gXCJiZWxvd1wiXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIHdyYXBwZWRDYWxsYmFjayk7IC8vIHRyaWdnZXJlZCBieSBzZXRUaW1lb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICAkZWwuY3NzKGNzc1Jlc2V0KTtcbiAgICAgICAgICAgIGNvbXBsZXRlICYmIGNvbXBsZXRlLmNhbGwoZWwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkdXJhdGlvbiA+IDApe1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb25FbmQgaXMgbm90IGFsd2F5cyBmaXJpbmcgb24gb2xkZXIgQW5kcm9pZCBwaG9uZXNcbiAgICAgICAgICAgIC8vIHNvIG1ha2Ugc3VyZSBpdCBnZXRzIGZpcmVkXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9LCAoKGR1cmF0aW9uICsgZGVsYXkpICogMTAwMCkgKyAyNSk7XG5cbiAgICAgICAgICAgIGRhdGFQcml2LnNldChlbCwgYW5pbWF0aW9uS2V5LCB7XG4gICAgICAgICAgICAgICAgaWQ6IGNhbGxiYWNrSWQsXG4gICAgICAgICAgICAgICAgc3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2FsbGJhY2tJZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwuY3NzKGNzc1ZhbHVlcyk7XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uIDw9IDApIHtcbiAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGF0YVByaXYuc2V0KGVsLCBhbmltYXRpb25LZXksIHtcbiAgICAgICAgc3RvcDogKCkgPT4gY2xlYXJUaW1lb3V0KGRlbGF5SWQpXG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdG9wKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGRhdGFQcml2LmdldChlbCwgYW5pbWF0aW9uS2V5KTtcbiAgICAgICAgaWYgKCFhbmltYXRpb24pIGNvbnRpbnVlO1xuICAgICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgICBkYXRhUHJpdi5yZW1vdmUoZWwsIGFuaW1hdGlvbktleSk7XG4gICAgfVxuICAgIHRoaXMuY3NzKGNzc1Jlc2V0KTtcbiAgICByZXR1cm4gdGhpcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/animations.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/events.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/events.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dom.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n// TODO: should not read config outside the mvc package\n\n\n\n\n// Special events\n\nconst special = Object.create(null);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (special);\n\nspecial.load = {\n    // Prevent triggered image.load events from bubbling to window.load\n    noBubble: true,\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in $.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n[\n    ['mouseenter', 'mouseover'],\n    ['mouseleave', 'mouseout'],\n    ['pointerenter', 'pointerover'],\n    ['pointerleave', 'pointerout'],\n].forEach(([orig, fix]) => {\n    special[orig] = {\n        delegateType: fix,\n        bindType: fix,\n        handle: function(event) {\n            const target = this;\n            const related = event.relatedTarget;\n            const handleObj = event.handleObj;\n            let ret;\n            // For mouseenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if (!related || !target.contains(related)) {\n                event.type = handleObj.origType;\n                ret = handleObj.handler.apply(target, arguments);\n                event.type = fix;\n            }\n            return ret;\n        },\n    };\n});\n\n\n// Gestures\n\nconst maxDelay = _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.doubleTapInterval;\nconst minDelay = 30;\n\nspecial.dbltap = {\n    bindType: 'touchend',\n    delegateType: 'touchend',\n    handle: function(event, ...args) {\n        const { handleObj, target } = event;\n        const targetData = _Dom_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.create(target);\n        const now = new Date().getTime();\n        const delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;\n        if (delta < maxDelay && delta > minDelay) {\n            targetData.lastTouch = null;\n            event.type = handleObj.origType;\n            // let $ handle the triggering of \"dbltap\" event handlers\n            handleObj.handler.call(this, event, ...args);\n        } else {\n            targetData.lastTouch = now;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vZXZlbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNnRDtBQUN0Qjs7O0FBRzFCOztBQUVBOztBQUVBLGlFQUFlLE9BQU8sRUFBQzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQSxpQkFBaUIscURBQU07QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDLDJCQUEyQixnREFBQztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vZXZlbnRzLm1qcz80YzEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE86IHNob3VsZCBub3QgcmVhZCBjb25maWcgb3V0c2lkZSB0aGUgbXZjIHBhY2thZ2VcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uLy4uL2NvbmZpZy9pbmRleC5tanMnO1xuaW1wb3J0ICQgZnJvbSAnLi9Eb20ubWpzJztcblxuXG4vLyBTcGVjaWFsIGV2ZW50c1xuXG5jb25zdCBzcGVjaWFsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZXhwb3J0IGRlZmF1bHQgc3BlY2lhbDtcblxuc3BlY2lhbC5sb2FkID0ge1xuICAgIC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcbiAgICBub0J1YmJsZTogdHJ1ZSxcbn07XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluICQuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuW1xuICAgIFsnbW91c2VlbnRlcicsICdtb3VzZW92ZXInXSxcbiAgICBbJ21vdXNlbGVhdmUnLCAnbW91c2VvdXQnXSxcbiAgICBbJ3BvaW50ZXJlbnRlcicsICdwb2ludGVyb3ZlciddLFxuICAgIFsncG9pbnRlcmxlYXZlJywgJ3BvaW50ZXJvdXQnXSxcbl0uZm9yRWFjaCgoW29yaWcsIGZpeF0pID0+IHtcbiAgICBzcGVjaWFsW29yaWddID0ge1xuICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcbiAgICAgICAgYmluZFR5cGU6IGZpeCxcbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuICAgICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAgIC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICAvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuICAgICAgICAgICAgaWYgKCFyZWxhdGVkIHx8ICF0YXJnZXQuY29udGFpbnMocmVsYXRlZCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBldmVudC50eXBlID0gZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG5cblxuLy8gR2VzdHVyZXNcblxuY29uc3QgbWF4RGVsYXkgPSBjb25maWcuZG91YmxlVGFwSW50ZXJ2YWw7XG5jb25zdCBtaW5EZWxheSA9IDMwO1xuXG5zcGVjaWFsLmRibHRhcCA9IHtcbiAgICBiaW5kVHlwZTogJ3RvdWNoZW5kJyxcbiAgICBkZWxlZ2F0ZVR5cGU6ICd0b3VjaGVuZCcsXG4gICAgaGFuZGxlOiBmdW5jdGlvbihldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCB7IGhhbmRsZU9iaiwgdGFyZ2V0IH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9ICQuZGF0YS5jcmVhdGUodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gJ2xhc3RUb3VjaCcgaW4gdGFyZ2V0RGF0YSA/IG5vdyAtIHRhcmdldERhdGEubGFzdFRvdWNoIDogMDtcbiAgICAgICAgaWYgKGRlbHRhIDwgbWF4RGVsYXkgJiYgZGVsdGEgPiBtaW5EZWxheSkge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YS5sYXN0VG91Y2ggPSBudWxsO1xuICAgICAgICAgICAgZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcbiAgICAgICAgICAgIC8vIGxldCAkIGhhbmRsZSB0aGUgdHJpZ2dlcmluZyBvZiBcImRibHRhcFwiIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICBoYW5kbGVPYmouaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldERhdGEubGFzdFRvdWNoID0gbm93O1xuICAgICAgICB9XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/events.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dom.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n/* harmony import */ var _methods_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/methods.mjs\");\n/* harmony import */ var _animations_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animations.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/animations.mjs\");\n/* harmony import */ var _props_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/props.mjs\");\n/* harmony import */ var _events_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/events.mjs\");\n\n\n\n\n\n\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn, _methods_mjs__WEBPACK_IMPORTED_MODULE_1__);\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn, _animations_mjs__WEBPACK_IMPORTED_MODULE_2__);\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn, _props_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.special, _events_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5QztBQUNBO0FBQ007QUFDQTtBQUNHOztBQUVsRCxjQUFjLGdEQUFDLEtBQUsseUNBQU87QUFDM0IsY0FBYyxnREFBQyxLQUFLLDRDQUFVO0FBQzlCLGNBQWMsZ0RBQUMsS0FBSyxrREFBSztBQUN6QixjQUFjLGdEQUFDLGdCQUFnQixtREFBTzs7QUFFdEMsaUVBQWUsZ0RBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vaW5kZXgubWpzPzRmNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVmYXVsdCBhcyAkIH0gZnJvbSAnLi9Eb20ubWpzJztcbmltcG9ydCAqIGFzIG1ldGhvZHMgZnJvbSAnLi9tZXRob2RzLm1qcyc7XG5pbXBvcnQgKiBhcyBhbmltYXRpb25zIGZyb20gJy4vYW5pbWF0aW9ucy5tanMnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBwcm9wcyB9IGZyb20gJy4vcHJvcHMubWpzJztcbmltcG9ydCB7IGRlZmF1bHQgYXMgc3BlY2lhbCB9IGZyb20gJy4vZXZlbnRzLm1qcyc7XG5cbk9iamVjdC5hc3NpZ24oJC5mbiwgbWV0aG9kcyk7XG5PYmplY3QuYXNzaWduKCQuZm4sIGFuaW1hdGlvbnMpO1xuT2JqZWN0LmFzc2lnbigkLmZuLCBwcm9wcyk7XG5PYmplY3QuYXNzaWduKCQuZXZlbnQuc3BlY2lhbCwgc3BlY2lhbCk7XG5cbmV4cG9ydCBkZWZhdWx0ICQ7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/methods.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/methods.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: () => (/* binding */ addClass),\n/* harmony export */   append: () => (/* binding */ append),\n/* harmony export */   appendTo: () => (/* binding */ appendTo),\n/* harmony export */   children: () => (/* binding */ children),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   closest: () => (/* binding */ closest),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   data: () => (/* binding */ data),\n/* harmony export */   detach: () => (/* binding */ detach),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   hasClass: () => (/* binding */ hasClass),\n/* harmony export */   height: () => (/* binding */ height),\n/* harmony export */   html: () => (/* binding */ html),\n/* harmony export */   off: () => (/* binding */ off),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   on: () => (/* binding */ on),\n/* harmony export */   one: () => (/* binding */ one),\n/* harmony export */   position: () => (/* binding */ position),\n/* harmony export */   prepend: () => (/* binding */ prepend),\n/* harmony export */   prependTo: () => (/* binding */ prependTo),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   removeClass: () => (/* binding */ removeClass),\n/* harmony export */   toggleClass: () => (/* binding */ toggleClass),\n/* harmony export */   width: () => (/* binding */ width)\n/* harmony export */ });\n/* harmony import */ var _util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/utilHelpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dom.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _vars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vars.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\");\n\n\n\n\n\n// Manipulation\n\nfunction cleanNodesData(nodes) {\n    let i = nodes.length;\n    while (i--) cleanNodeData(nodes[i]);\n}\n\nfunction cleanNodeData(node) {\n    _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.remove(node);\n    _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.remove(node);\n    _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataUser.remove(node);\n}\n\nfunction removeNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\n\nfunction remove() {\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        cleanNodeData(node);\n        cleanNodesData(node.getElementsByTagName('*'));\n    }\n    removeNodes(this);\n    return this;\n}\n\nfunction detach() {\n    removeNodes(this);\n    return this;\n}\n\nfunction empty() {\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (node.nodeType === 1) {\n            cleanNodesData(node.getElementsByTagName('*'));\n            // Remove any remaining nodes\n            node.textContent = '';\n        }\n    }\n    return this;\n}\n\nfunction clone() {\n    const clones = [];\n    for (let i = 0; i < this.length; i++) {\n        clones.push(this[i].cloneNode(true));\n    }\n    return this.pushStack(clones);\n}\n\nfunction html(html) {\n    const [el] = this;\n    if (!el) return null;\n    if (arguments.length === 0) return el.innerHTML;\n    if (html === undefined) return this; // do nothing\n    cleanNodesData(el.getElementsByTagName('*'));\n    if (typeof html === 'string' || typeof html === 'number') {\n        el.innerHTML = html;\n    } else {\n        el.innerHTML = '';\n        return this.append(html);\n    }\n    return this;\n}\n\nfunction append(...nodes) {\n    const [parent] = this;\n    if (!parent) return this;\n    nodes.forEach((node) => {\n        if (!node) return;\n        if (typeof node === 'string') {\n            parent.append(..._Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parseHTML(node));\n        } else if (node.toString() === '[object Object]') {\n            // $ object\n            this.append(...Array.from(node));\n        } else if (Array.isArray(node)) {\n            this.append(...node);\n        } else {\n            // DOM node\n            parent.appendChild(node);\n        }\n    });\n    return this;\n}\n\nfunction prepend(...nodes) {\n    const [parent] = this;\n    if (!parent) return this;\n    nodes.forEach((node) => {\n        if (!node) return;\n        if (typeof node === 'string') {\n            parent.prepend(..._Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parseHTML(node));\n        } else if (node.toString() === '[object Object]') {\n            // $ object\n            this.prepend(...Array.from(node));\n        } else if (Array.isArray(node)) {\n            this.prepend(...node);\n        } else {\n            // DOM node\n            parent.insertBefore(node, parent.firstChild);\n        }\n    });\n    return this;\n}\n\nfunction appendTo(parent) {\n    (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parent).append(this);\n    return this;\n}\n\nfunction prependTo(parent) {\n    (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parent).prepend(this);\n    return this;\n}\n\n// Styles and attributes\n\nconst requireUnits = {};\n[\n    'width', 'height', 'top', 'bottom', 'left', 'right',\n    'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight',\n    'margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight',\n].forEach((cssProp) => {\n    requireUnits[cssProp] = true;\n});\n\nfunction setCSSProperty(el, name, value) {\n    if (typeof value === 'number' && requireUnits[(0,_util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_2__.camelCase)(name)]) {\n        value += 'px';\n    }\n    el.style[name] = value;\n}\n\nfunction css(name, value) {\n    let styles;\n    if (typeof name === 'string') {\n        if (value === undefined) {\n            const [el] = this;\n            if (!el) return null;\n            return el.style[name];\n        } else {\n            styles = { [name]: value };\n        }\n    } else if (!name) {\n        throw new Error('no styles provided');\n    } else {\n        styles = name;\n    }\n    for (let style in styles) {\n        if (styles.hasOwnProperty(style)) {\n            for (let i = 0; i < this.length; i++) {\n                setCSSProperty(this[i], style, styles[style]);\n            }\n        }\n    }\n    return this;\n}\n\nfunction data(name, value) {\n    if (arguments.length < 2) {\n        const [el] = this;\n        if (!el) return null;\n        if (name === undefined) {\n            return el.dataset;\n        }\n        return el.dataset[name];\n    }\n    for (let i = 0; i < this.length; i++) {\n        this[i].dataset[name] = value;\n    }\n    return this;\n}\n\n// Classes\n\nfunction setNodesClass(method, nodes, args) {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype[method].apply({ node }, args);\n    }\n}\n\nfunction removeClass() {\n    setNodesClass('removeClass', this, arguments);\n    return this;\n}\n\nfunction addClass() {\n    setNodesClass('addClass', this, arguments);\n    return this;\n}\n\nfunction toggleClass() {\n    setNodesClass('toggleClass', this, arguments);\n    return this;\n}\n\nfunction hasClass() {\n    const [node] = this;\n    if (!node) return false;\n    return _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype.hasClass.apply({ node }, arguments);\n}\n\n// Traversing\n\nfunction children(selector) {\n    const matches = [];\n    for(let i = 0; i < this.length; i++) {\n        const node = this[i];\n        let children = Array.from(node.children);\n        if (typeof selector === 'string') {\n            children = children.filter(child => child.matches(selector));\n        }\n        matches.push(...children);\n    }\n    return this.pushStack(matches);\n}\n\nfunction closest(selector) {\n    const closest = [];\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        if (typeof selector === 'string') {\n            const closestEl = el.closest(selector);\n            if (closestEl) {\n                closest.push(closestEl);\n            }\n        } else {\n            const [ancestorEl] = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(selector);\n            if (ancestorEl && ancestorEl.contains(el)) {\n                closest.push(ancestorEl);\n            }\n        }\n    }\n    return this.pushStack(closest);\n}\n\n// Events\n\nfunction on(types, selector, data, fn) {\n    _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.on(this, types, selector, data, fn);\n    return this;\n}\n\nfunction one(types, selector, data, fn) {\n    _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.on(this, types, selector, data, fn, 1);\n    return this;\n}\n\nfunction off(types, selector, fn) {\n    if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched $.Event\n        const handleObj = types.handleObj;\n        (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(types.delegateTarget).off(\n            handleObj.namespace\n                ? handleObj.origType + '.' + handleObj.namespace\n                : handleObj.origType,\n            handleObj.selector,\n            handleObj.handler\n        );\n        return this;\n    }\n    if (typeof types === 'object') {\n        // ( types-object [, selector] )\n        for (let type in types) {\n            this.off(type, selector, types[type]);\n        }\n        return this;\n    }\n    if (selector === false || typeof selector === 'function') {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n    }\n    for (let i = 0; i < this.length; i++) {\n        _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.remove(this[i], types, fn, selector);\n    }\n    return this;\n}\n\n// Measurements\n\nfunction width() {\n    const [el] = this;\n    if (el === window) return el.document.documentElement.clientWidth;\n    else if (!el) return undefined;\n    const styles = window.getComputedStyle(el);\n    const height = el.offsetWidth;\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderBottomWidth = parseFloat(styles.borderBottomWidth);\n    const paddingTop = parseFloat(styles.paddingTop);\n    const paddingBottom = parseFloat(styles.paddingBottom);\n    return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;\n}\n\nfunction height() {\n    const [el] = this;\n    if (el === window) return el.document.documentElement.clientHeight;\n    if (!el) return undefined;\n    const styles = window.getComputedStyle(el);\n    const width = el.offsetHeight;\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    const borderRightWidth = parseFloat(styles.borderRightWidth);\n    const paddingLeft = parseFloat(styles.paddingLeft);\n    const paddingRight = parseFloat(styles.paddingRight);\n    return width - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;\n}\n\nfunction position() {\n    const [el] = this;\n    if (!el) return;\n    let $el = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(el);\n    let offsetParent;\n    let offset;\n    let doc;\n    let parentOffset = { top: 0, left: 0 };\n    // position:fixed elements are offset from the viewport, which itself always has zero offset\n    if ($el.css('position') === 'fixed') {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = el.getBoundingClientRect();\n    } else {\n        offset = $el.offset();\n        // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n        doc = el.ownerDocument;\n        offsetParent = el.offsetParent || doc.documentElement;\n        const isStaticallyPositioned = (el) => {\n            const { position } = getComputedStyle(el);\n            return position === 'static';\n        };\n        while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {\n            offsetParent = offsetParent.offsetParent || doc.documentElement;\n        }\n        if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {\n            // Incorporate borders into its offset, since they are outside its content origin\n            const offsetParentStyles = window.getComputedStyle(offsetParent);\n            const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;\n            const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;\n            parentOffset = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(offsetParent).offset();\n            parentOffset.top += borderTopWidth;\n            parentOffset.left += borderLeftWidth;\n        }\n    }\n    const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;\n    const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;\n    // Subtract parent offsets and element margins\n    return {\n        top: offset.top - parentOffset.top - marginTop,\n        left: offset.left - parentOffset.left - marginLeft\n    };\n}\n\nfunction offset(coordinates) {\n    const [el] = this;\n    //  Getter\n    if (coordinates === undefined) {\n        if (!el) return null;\n        if (!el.getClientRects().length) {\n            return { top: 0, left: 0 };\n        }\n        const rect = el.getBoundingClientRect();\n        return {\n            top: rect.top + window.scrollY,\n            left: rect.left + window.scrollX\n        };\n    }\n    // Setter\n    if (!el) return this;\n    const currentStyle = window.getComputedStyle(el);\n    if (currentStyle.position === 'static') {\n        this.css('position', 'relative');\n    }\n    const currentOffset = this.offset();\n    const topDifference = coordinates.top - currentOffset.top;\n    const leftDifference = coordinates.left - currentOffset.left;\n    this.css({\n        top: (parseFloat(currentStyle.top) || 0) + topDifference + 'px',\n        left: (parseFloat(currentStyle.left) || 0) + leftDifference + 'px'\n    });\n    return this;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vbWV0aG9kcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RDtBQUM3QjtBQUNRO0FBQ2M7O0FBRWhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxnREFBQztBQUNMLElBQUksK0NBQVE7QUFDWixJQUFJLCtDQUFRO0FBQ1o7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQUM7QUFDOUIsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdEQUFDO0FBQy9CLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVPO0FBQ1AsSUFBSSxvREFBQztBQUNMO0FBQ0E7O0FBRU87QUFDUCxJQUFJLG9EQUFDO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrREFBa0QsZ0VBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCO0FBQ3ZCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxRQUFRLG9EQUFDLDJCQUEyQixNQUFNO0FBQzFDO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsV0FBVyxvREFBQyw0QkFBNEIsTUFBTTtBQUM5Qzs7QUFFQTs7QUFFTztBQUNQO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlDQUFpQyxvREFBQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQLElBQUksZ0RBQUM7QUFDTDtBQUNBOztBQUVPO0FBQ1AsSUFBSSxnREFBQztBQUNMO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFDO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsUUFBUSxnREFBQztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGNBQWMsb0RBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQUM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9tZXRob2RzLm1qcz85MTMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNhbWVsQ2FzZSB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbEhlbHBlcnMubWpzJztcbmltcG9ydCAkIGZyb20gJy4vRG9tLm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi8uLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBkYXRhUHJpdiwgZGF0YVVzZXIgfSBmcm9tICcuL3ZhcnMubWpzJztcblxuLy8gTWFuaXB1bGF0aW9uXG5cbmZ1bmN0aW9uIGNsZWFuTm9kZXNEYXRhKG5vZGVzKSB7XG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgY2xlYW5Ob2RlRGF0YShub2Rlc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFuTm9kZURhdGEobm9kZSkge1xuICAgICQuZXZlbnQucmVtb3ZlKG5vZGUpO1xuICAgIGRhdGFQcml2LnJlbW92ZShub2RlKTtcbiAgICBkYXRhVXNlci5yZW1vdmUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGVzKG5vZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbaV07XG4gICAgICAgIGNsZWFuTm9kZURhdGEobm9kZSk7XG4gICAgICAgIGNsZWFuTm9kZXNEYXRhKG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgfVxuICAgIHJlbW92ZU5vZGVzKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgIHJlbW92ZU5vZGVzKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY2xlYW5Ob2Rlc0RhdGEobm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVzLnB1c2godGhpc1tpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soY2xvbmVzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh0bWwoaHRtbCkge1xuICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgIGlmICghZWwpIHJldHVybiBudWxsO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gZWwuaW5uZXJIVE1MO1xuICAgIGlmIChodG1sID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzOyAvLyBkbyBub3RoaW5nXG4gICAgY2xlYW5Ob2Rlc0RhdGEoZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSk7XG4gICAgaWYgKHR5cGVvZiBodG1sID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaHRtbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kKGh0bWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZCguLi5ub2Rlcykge1xuICAgIGNvbnN0IFtwYXJlbnRdID0gdGhpcztcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXM7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZCguLi4kLnBhcnNlSFRNTChub2RlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgLy8gJCBvYmplY3RcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKC4uLkFycmF5LmZyb20obm9kZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKC4uLm5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRE9NIG5vZGVcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGVuZCguLi5ub2Rlcykge1xuICAgIGNvbnN0IFtwYXJlbnRdID0gdGhpcztcbiAgICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXM7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyZW50LnByZXBlbmQoLi4uJC5wYXJzZUhUTUwobm9kZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIC8vICQgb2JqZWN0XG4gICAgICAgICAgICB0aGlzLnByZXBlbmQoLi4uQXJyYXkuZnJvbShub2RlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVwZW5kKC4uLm5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRE9NIG5vZGVcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgcGFyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUbyhwYXJlbnQpIHtcbiAgICAkKHBhcmVudCkuYXBwZW5kKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGVuZFRvKHBhcmVudCkge1xuICAgICQocGFyZW50KS5wcmVwZW5kKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBTdHlsZXMgYW5kIGF0dHJpYnV0ZXNcblxuY29uc3QgcmVxdWlyZVVuaXRzID0ge307XG5bXG4gICAgJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLFxuICAgICdwYWRkaW5nJywgJ3BhZGRpbmdUb3AnLCAncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLFxuICAgICdtYXJnaW4nLCAnbWFyZ2luVG9wJywgJ21hcmdpbkJvdHRvbScsICdtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0Jyxcbl0uZm9yRWFjaCgoY3NzUHJvcCkgPT4ge1xuICAgIHJlcXVpcmVVbml0c1tjc3NQcm9wXSA9IHRydWU7XG59KTtcblxuZnVuY3Rpb24gc2V0Q1NTUHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgcmVxdWlyZVVuaXRzW2NhbWVsQ2FzZShuYW1lKV0pIHtcbiAgICAgICAgdmFsdWUgKz0gJ3B4JztcbiAgICB9XG4gICAgZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzcyhuYW1lLCB2YWx1ZSkge1xuICAgIGxldCBzdHlsZXM7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWVsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBlbC5zdHlsZVtuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlcyA9IHsgW25hbWVdOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHN0eWxlcyBwcm92aWRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlcyA9IG5hbWU7XG4gICAgfVxuICAgIGZvciAobGV0IHN0eWxlIGluIHN0eWxlcykge1xuICAgICAgICBpZiAoc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q1NTUHJvcGVydHkodGhpc1tpXSwgc3R5bGUsIHN0eWxlc1tzdHlsZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGF0YShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBjb25zdCBbZWxdID0gdGhpcztcbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbC5kYXRhc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbC5kYXRhc2V0W25hbWVdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXS5kYXRhc2V0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBDbGFzc2VzXG5cbmZ1bmN0aW9uIHNldE5vZGVzQ2xhc3MobWV0aG9kLCBub2RlcywgYXJncykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBWLnByb3RvdHlwZVttZXRob2RdLmFwcGx5KHsgbm9kZSB9LCBhcmdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDbGFzcygpIHtcbiAgICBzZXROb2Rlc0NsYXNzKCdyZW1vdmVDbGFzcycsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcygpIHtcbiAgICBzZXROb2Rlc0NsYXNzKCdhZGRDbGFzcycsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVDbGFzcygpIHtcbiAgICBzZXROb2Rlc0NsYXNzKCd0b2dnbGVDbGFzcycsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzcygpIHtcbiAgICBjb25zdCBbbm9kZV0gPSB0aGlzO1xuICAgIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBWLnByb3RvdHlwZS5oYXNDbGFzcy5hcHBseSh7IG5vZGUgfSwgYXJndW1lbnRzKTtcbn1cblxuLy8gVHJhdmVyc2luZ1xuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbaV07XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IEFycmF5LmZyb20obm9kZS5jaGlsZHJlbik7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5tYXRjaGVzKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvc2VzdChzZWxlY3Rvcikge1xuICAgIGNvbnN0IGNsb3Nlc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEVsID0gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdEVsKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdC5wdXNoKGNsb3Nlc3RFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBbYW5jZXN0b3JFbF0gPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChhbmNlc3RvckVsICYmIGFuY2VzdG9yRWwuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdC5wdXNoKGFuY2VzdG9yRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhjbG9zZXN0KTtcbn1cblxuLy8gRXZlbnRzXG5cbmV4cG9ydCBmdW5jdGlvbiBvbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XG4gICAgJC5ldmVudC5vbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uZSh0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XG4gICAgJC5ldmVudC5vbih0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9mZih0eXBlcywgc2VsZWN0b3IsIGZuKSB7XG4gICAgaWYgKHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaikge1xuICAgICAgICAvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgJC5FdmVudFxuICAgICAgICBjb25zdCBoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG4gICAgICAgICQodHlwZXMuZGVsZWdhdGVUYXJnZXQpLm9mZihcbiAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgICA/IGhhbmRsZU9iai5vcmlnVHlwZSArICcuJyArIGhhbmRsZU9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU9iai5vcmlnVHlwZSxcbiAgICAgICAgICAgIGhhbmRsZU9iai5zZWxlY3RvcixcbiAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHR5cGVzKSB7XG4gICAgICAgICAgICB0aGlzLm9mZih0eXBlLCBzZWxlY3RvciwgdHlwZXNbdHlwZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXG4gICAgICAgIGZuID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJC5ldmVudC5yZW1vdmUodGhpc1tpXSwgdHlwZXMsIGZuLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBNZWFzdXJlbWVudHNcblxuZXhwb3J0IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgIGlmIChlbCA9PT0gd2luZG93KSByZXR1cm4gZWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGVsc2UgaWYgKCFlbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gICAgY29uc3QgYm9yZGVyQm90dG9tV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgY29uc3QgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLnBhZGRpbmdUb3ApO1xuICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlcy5wYWRkaW5nQm90dG9tKTtcbiAgICByZXR1cm4gaGVpZ2h0IC0gYm9yZGVyQm90dG9tV2lkdGggLSBib3JkZXJUb3BXaWR0aCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgIGlmIChlbCA9PT0gd2luZG93KSByZXR1cm4gZWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBpZiAoIWVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBjb25zdCB3aWR0aCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICBjb25zdCBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgIGNvbnN0IGJvcmRlclJpZ2h0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJSaWdodFdpZHRoKTtcbiAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLnBhZGRpbmdMZWZ0KTtcbiAgICBjb25zdCBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlcy5wYWRkaW5nUmlnaHQpO1xuICAgIHJldHVybiB3aWR0aCAtIGJvcmRlckxlZnRXaWR0aCAtIGJvcmRlclJpZ2h0V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBsZXQgJGVsID0gJChlbCk7XG4gICAgbGV0IG9mZnNldFBhcmVudDtcbiAgICBsZXQgb2Zmc2V0O1xuICAgIGxldCBkb2M7XG4gICAgbGV0IHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgLy8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcbiAgICBpZiAoJGVsLmNzcygncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIG9mZnNldCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRlbC5vZmZzZXQoKTtcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcbiAgICAgICAgLy8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcbiAgICAgICAgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gZWwub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGlzU3RhdGljYWxseVBvc2l0aW9uZWQgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAnc3RhdGljJztcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGRvYy5kb2N1bWVudEVsZW1lbnQgJiYgaXNTdGF0aWNhbGx5UG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSAmJiAhaXNTdGF0aWNhbGx5UG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFBhcmVudFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQob2Zmc2V0UGFyZW50U3R5bGVzLmJvcmRlclRvcFdpZHRoKSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnRTdHlsZXMuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gJChvZmZzZXRQYXJlbnQpLm9mZnNldCgpO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0LnRvcCArPSBib3JkZXJUb3BXaWR0aDtcbiAgICAgICAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IGJvcmRlckxlZnRXaWR0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5tYXJnaW5Ub3ApIHx8IDA7XG4gICAgY29uc3QgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLm1hcmdpbkxlZnQpIHx8IDA7XG4gICAgLy8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBtYXJnaW5Ub3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBtYXJnaW5MZWZ0XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9mZnNldChjb29yZGluYXRlcykge1xuICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgIC8vICBHZXR0ZXJcbiAgICBpZiAoY29vcmRpbmF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWVsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luZG93LnNjcm9sbFhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2V0dGVyXG4gICAgaWYgKCFlbCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgY3VycmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGlmIChjdXJyZW50U3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcbiAgICBjb25zdCB0b3BEaWZmZXJlbmNlID0gY29vcmRpbmF0ZXMudG9wIC0gY3VycmVudE9mZnNldC50b3A7XG4gICAgY29uc3QgbGVmdERpZmZlcmVuY2UgPSBjb29yZGluYXRlcy5sZWZ0IC0gY3VycmVudE9mZnNldC5sZWZ0O1xuICAgIHRoaXMuY3NzKHtcbiAgICAgICAgdG9wOiAocGFyc2VGbG9hdChjdXJyZW50U3R5bGUudG9wKSB8fCAwKSArIHRvcERpZmZlcmVuY2UgKyAncHgnLFxuICAgICAgICBsZWZ0OiAocGFyc2VGbG9hdChjdXJyZW50U3R5bGUubGVmdCkgfHwgMCkgKyBsZWZ0RGlmZmVyZW5jZSArICdweCdcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/methods.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/props.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/props.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst propertySetters = {\n    outerWidth: 'offsetWidth',\n    outerHeight: 'offsetHeight',\n    innerWidth: 'clientWidth',\n    innerHeight: 'clientHeight',\n    scrollLeft: 'scrollLeft',\n    scrollTop: 'scrollTop',\n    val: 'value',\n    text: 'textContent',\n};\n\nconst propertiesMap = {\n    disabled: 'disabled',\n    value: 'value',\n    text: 'textContent',\n};\n\nfunction prop(name, value) {\n    if (!name) throw new Error('no property provided');\n    if (arguments.length === 1) {\n        const [el] = this;\n        if (!el) return null;\n        return el[name];\n    }\n    if (value === undefined) return this;\n    for (let i = 0; i < this.length; i++) {\n        this[i][name] = value;\n    }\n    return this;\n}\n\nfunction attr(name, value) {\n    let attributes;\n    if (typeof name === 'string') {\n        if (value === undefined) {\n            const [el] = this;\n            if (!el) return null;\n            return el.getAttribute(name);\n        } else {\n            attributes = { [name]: value };\n        }\n    } else if (!name) {\n        throw new Error('no attributes provided');\n    } else {\n        attributes = name;\n    }\n    for (let attr in attributes) {\n        if (attributes.hasOwnProperty(attr)) {\n            const value = attributes[attr];\n            if (propertiesMap[attr]) {\n                this.prop(propertiesMap[attr], value);\n                continue;\n            }\n            for (let i = 0; i < this.length; i++) {\n                if (value === null) {\n                    this[i].removeAttribute(attr);\n                } else {\n                    this[i].setAttribute(attr, value);\n                }\n            }\n        }\n    }\n    return this;\n}\n\nconst methods = {\n    prop,\n    attr\n};\n\nObject.keys(propertySetters).forEach(methodName => {\n    methods[methodName] = function(...args) {\n        return this.prop(propertySetters[methodName], ...args);\n    };\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (methods);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vcHJvcHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGlFQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vcHJvcHMubWpzPzk4ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJvcGVydHlTZXR0ZXJzID0ge1xuICAgIG91dGVyV2lkdGg6ICdvZmZzZXRXaWR0aCcsXG4gICAgb3V0ZXJIZWlnaHQ6ICdvZmZzZXRIZWlnaHQnLFxuICAgIGlubmVyV2lkdGg6ICdjbGllbnRXaWR0aCcsXG4gICAgaW5uZXJIZWlnaHQ6ICdjbGllbnRIZWlnaHQnLFxuICAgIHNjcm9sbExlZnQ6ICdzY3JvbGxMZWZ0JyxcbiAgICBzY3JvbGxUb3A6ICdzY3JvbGxUb3AnLFxuICAgIHZhbDogJ3ZhbHVlJyxcbiAgICB0ZXh0OiAndGV4dENvbnRlbnQnLFxufTtcblxuY29uc3QgcHJvcGVydGllc01hcCA9IHtcbiAgICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgICB2YWx1ZTogJ3ZhbHVlJyxcbiAgICB0ZXh0OiAndGV4dENvbnRlbnQnLFxufTtcblxuZnVuY3Rpb24gcHJvcChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdubyBwcm9wZXJ0eSBwcm92aWRlZCcpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGVsW25hbWVdO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV1bbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUpIHtcbiAgICBsZXQgYXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBbZWxdID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZWwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSB7IFtuYW1lXTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBhdHRyaWJ1dGVzIHByb3ZpZGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IG5hbWU7XG4gICAgfVxuICAgIGZvciAobGV0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNNYXBbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3AocHJvcGVydGllc01hcFthdHRyXSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbaV0uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmNvbnN0IG1ldGhvZHMgPSB7XG4gICAgcHJvcCxcbiAgICBhdHRyXG59O1xuXG5PYmplY3Qua2V5cyhwcm9wZXJ0eVNldHRlcnMpLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcChwcm9wZXJ0eVNldHRlcnNbbWV0aG9kTmFtZV0sIC4uLmFyZ3MpO1xuICAgIH07XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWV0aG9kcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/props.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/vars.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataPriv: () => (/* binding */ dataPriv),\n/* harmony export */   dataUser: () => (/* binding */ dataUser)\n/* harmony export */ });\n/* harmony import */ var _Data_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Data.mjs\");\n\n\nconst dataPriv = new _Data_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\nconst dataUser = new _Data_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vdmFycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCOztBQUV4QixxQkFBcUIsaURBQUk7O0FBRXpCLHFCQUFxQixpREFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vdmFycy5tanM/YTE4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRGF0YSBmcm9tICcuLi9EYXRhLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbmV4cG9ydCBjb25zdCBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Events.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Events: () => (/* binding */ Events)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n// Events\n// ---------------\n\n// A module that can be mixed in to *any object* in order to provide it with\n// a custom event channel. You may bind a callback to an event with `on` or\n// remove with `off`; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     const object = {};\n//     assign(object, Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nvar Events = {};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// A private global variable to share between listeners and listenees.\nvar _listening;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n    // Handle event maps.\n        if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n        for (names = Object.keys(name); i < names.length ; i++) {\n            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n        }\n    } else if (name && eventSplitter.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n        for (names = name.split(eventSplitter); i < names.length; i++) {\n            events = iteratee(events, names[i], callback, opts);\n        }\n    } else {\n    // Finally, standard events.\n        events = iteratee(events, name, callback, opts);\n    }\n    return events;\n};\n\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\n// the callback to all events fired.\nEvents.on = function(name, callback, context) {\n    this._events = eventsApi(onApi, this._events || {}, name, callback, {\n        context: context,\n        ctx: this,\n        listening: _listening\n    });\n\n    if (_listening) {\n        var listeners = this._listeners || (this._listeners = {});\n        listeners[_listening.id] = _listening;\n        // Allow the listening to use a counter, instead of tracking\n        // callbacks for library interop\n        _listening.interop = false;\n    }\n\n    return this;\n};\n\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\n// an event in another object... keeping track of what it's listening to\n// for easier unbinding later.\nEvents.listenTo = function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = _listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n        this._listenId || (this._listenId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('l'));\n        listening = _listening = listeningTo[id] = new Listening(this, obj);\n    }\n\n    // Bind callbacks on obj.\n    var error = tryCatchOn(obj, name, callback, this);\n    _listening = void 0;\n\n    if (error) throw error;\n    // If the target obj is not Events, track events manually.\n    if (listening.interop) listening.on(name, callback);\n\n    return this;\n};\n\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function(events, name, callback, options) {\n    if (callback) {\n        var handlers = events[name] || (events[name] = []);\n        var context = options.context, ctx = options.ctx, listening = options.listening;\n        if (listening) listening.count++;\n\n        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n    }\n    return events;\n};\n\n// An try-catch guarded #on function, to prevent poisoning the global\n// `_listening` variable.\nvar tryCatchOn = function(obj, name, callback, context) {\n    try {\n        obj.on(name, callback, context);\n    } catch (e) {\n        return e;\n    }\n};\n\n// Remove one or many callbacks. If `context` is null, removes all\n// callbacks with that function. If `callback` is null, removes all\n// callbacks for the event. If `name` is null, removes all bound\n// callbacks for all events.\nEvents.off = function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n    });\n\n    return this;\n};\n\n// Tell this object to stop listening to either specific events ... or\n// to every object it's currently listening to.\nEvents.stopListening = function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n    for (var i = 0; i < ids.length; i++) {\n        var listening = listeningTo[ids[i]];\n\n        // If listening doesn't exist, this object is not currently\n        // listening to obj. Break out early.\n        if (!listening) break;\n\n        listening.obj.off(name, callback, this);\n        if (listening.interop) listening.off(name, callback);\n    }\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(listeningTo)) this._listeningTo = void 0;\n\n    return this;\n};\n\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var context = options.context, listeners = options.listeners;\n    var i = 0, names;\n\n    // Delete all event listeners and \"drop\" events.\n    if (!name && !context && !callback) {\n        if(listeners != null) {\n            for (names = Object.keys(listeners); i < names.length; i++) {\n                listeners[names[i]].cleanup();\n            }\n        }\n        return;\n    }\n    names = name ? [name] : Object.keys(events);\n    for (; i < names.length; i++) {\n        name = names[i];\n        var handlers = events[name];\n\n        // Bail out if there are no events stored.\n        if (!handlers) break;\n\n        // Find any remaining events.\n        var remaining = [];\n        for (var j = 0; j < handlers.length; j++) {\n            var handler = handlers[j];\n            if (\n                callback && callback !== handler.callback &&\n        callback !== handler.callback._callback ||\n          context && context !== handler.context\n            ) {\n                remaining.push(handler);\n            } else {\n                var listening = handler.listening;\n                if (listening) listening.off(name, callback);\n            }\n        }\n\n        // Replace events if there are any remaining.  Otherwise, clean up.\n        if (remaining.length) {\n            events[name] = remaining;\n        } else {\n            delete events[name];\n        }\n    }\n\n    return events;\n};\n\n// Bind an event to only be triggered a single time. After the first time\n// the callback is invoked, its listener will be removed. If multiple events\n// are passed in using the space-separated syntax, the handler will fire\n// once for each event, not once for a combination of all events.\nEvents.once = function(name, callback, context) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n    if (typeof name === 'string' && context == null) callback = void 0;\n    return this.on(events, callback, context);\n};\n\n// Inversion-of-control versions of `once`.\nEvents.listenToOnce = function(obj, name, callback) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n    return this.listenTo(obj, events);\n};\n\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n// `offer` unbinds the `onceWrapper` after it has been called.\nvar onceMap = function(map, name, callback, offer) {\n    if (callback) {\n        var once = map[name] = onceInvoke(function() {\n            offer(name, once);\n            callback.apply(this, arguments);\n        });\n        once._callback = callback;\n    }\n    return map;\n};\n\n// Creates a function that is restricted to invoking 'func' once.\n// Repeat calls to the function return the value of the first invocation.\nvar onceInvoke = function(func) {\n    var result;\n    if (typeof func != 'function') {\n        throw new TypeError('Expected a function');\n    }\n    var n = 2;\n    return function() {\n        if (--n > 0) {\n            result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n            func = undefined;\n        }\n        return result;\n    };\n};\n\n// Trigger one or many events, firing all bound callbacks. Callbacks are\n// passed the same arguments as `trigger` is, apart from the event name\n// (unless you're listening on `\"all\"`, which will cause your callback to\n// receive the true name of the event as the first argument).\nEvents.trigger = function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n};\n\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function(objEvents, name, callback, args) {\n    if (objEvents) {\n        var events = objEvents[name];\n        var allEvents = objEvents.all;\n        if (events && allEvents) allEvents = allEvents.slice();\n        if (events) triggerEvents(events, args);\n        if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// events have 3 arguments).\nvar triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n};\n\n// A listening class that tracks and cleans up memory bindings\n// when all callbacks have been offed.\nvar Listening = function(listener, obj) {\n    this.id = listener._listenId;\n    this.listener = listener;\n    this.obj = obj;\n    this.interop = true;\n    this.count = 0;\n    this._events = void 0;\n};\n\nListening.prototype.on = Events.on;\n\n// Offs a callback (or several).\n// Uses an optimized counter if the listenee uses Events.\n// Otherwise, falls back to manual tracking to support events\n// library interop.\nListening.prototype.off = function(name, callback) {\n    var cleanup;\n    if (this.interop) {\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: void 0,\n            listeners: void 0\n        });\n        cleanup = !this._events;\n    } else {\n        this.count--;\n        cleanup = this.count === 0;\n    }\n    if (cleanup) this.cleanup();\n};\n\n// Cleans up memory bindings between the listener and the listenee.\nListening.prototype.cleanup = function() {\n    delete this.listener._listeningTo[this.obj._listenId];\n    if (!this.interop) delete this.obj._listeners[this.id];\n};\n\n// Aliases for backwards compatibility.\nEvents.bind   = Events.on;\nEvents.unbind = Events.off;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9FdmVudHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRzBCOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnREFBZ0Qsa0JBQWtCO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3REFBUTtBQUN2RCxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdEQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaUZBQWlGO0FBQ3pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQU87O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBOztBQUVBLCtDQUErQyxtQkFBbUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixZQUFZOztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLGdGQUFnRjtBQUNoRixvRkFBb0Y7QUFDcEYsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9FdmVudHMubWpzPzkyYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBpc0VtcHR5LFxuICAgIHVuaXF1ZUlkIFxufSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcblxuLy8gRXZlbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS1cblxuLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuLy8gYSBjdXN0b20gZXZlbnQgY2hhbm5lbC4gWW91IG1heSBiaW5kIGEgY2FsbGJhY2sgdG8gYW4gZXZlbnQgd2l0aCBgb25gIG9yXG4vLyByZW1vdmUgd2l0aCBgb2ZmYDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4vLyBzdWNjZXNzaW9uLlxuLy9cbi8vICAgICBjb25zdCBvYmplY3QgPSB7fTtcbi8vICAgICBhc3NpZ24ob2JqZWN0LCBFdmVudHMpO1xuLy8gICAgIG9iamVjdC5vbignZXhwYW5kJywgZnVuY3Rpb24oKXsgYWxlcnQoJ2V4cGFuZGVkJyk7IH0pO1xuLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbi8vXG5leHBvcnQgdmFyIEV2ZW50cyA9IHt9O1xuXG4vLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxudmFyIGV2ZW50U3BsaXR0ZXIgPSAvXFxzKy87XG5cbi8vIEEgcHJpdmF0ZSBnbG9iYWwgdmFyaWFibGUgdG8gc2hhcmUgYmV0d2VlbiBsaXN0ZW5lcnMgYW5kIGxpc3RlbmVlcy5cbnZhciBfbGlzdGVuaW5nO1xuXG4vLyBJdGVyYXRlcyBvdmVyIHRoZSBzdGFuZGFyZCBgZXZlbnQsIGNhbGxiYWNrYCAoYXMgd2VsbCBhcyB0aGUgZmFuY3kgbXVsdGlwbGVcbi8vIHNwYWNlLXNlcGFyYXRlZCBldmVudHMgYFwiY2hhbmdlIGJsdXJcIiwgY2FsbGJhY2tgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnRcbi8vIG1hcHMgYHtldmVudDogY2FsbGJhY2t9YCkuXG52YXIgZXZlbnRzQXBpID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICB2YXIgaSA9IDAsIG5hbWVzO1xuICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IHZvaWQgMCAmJiAnY29udGV4dCcgaW4gb3B0cyAmJiBvcHRzLmNvbnRleHQgPT09IHZvaWQgMCkgb3B0cy5jb250ZXh0ID0gY2FsbGJhY2s7XG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhuYW1lKTsgaSA8IG5hbWVzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzQXBpKGl0ZXJhdGVlLCBldmVudHMsIG5hbWVzW2ldLCBuYW1lW25hbWVzW2ldXSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWUgJiYgZXZlbnRTcGxpdHRlci50ZXN0KG5hbWUpKSB7XG4gICAgLy8gSGFuZGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lcyBieSBkZWxlZ2F0aW5nIHRoZW0gaW5kaXZpZHVhbGx5LlxuICAgICAgICBmb3IgKG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWVzW2ldLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIC8vIEZpbmFsbHksIHN0YW5kYXJkIGV2ZW50cy5cbiAgICAgICAgZXZlbnRzID0gaXRlcmF0ZWUoZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG59O1xuXG4vLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXG4vLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cbkV2ZW50cy5vbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzQXBpKG9uQXBpLCB0aGlzLl9ldmVudHMgfHwge30sIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIGN0eDogdGhpcyxcbiAgICAgICAgbGlzdGVuaW5nOiBfbGlzdGVuaW5nXG4gICAgfSk7XG5cbiAgICBpZiAoX2xpc3RlbmluZykge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSB7fSk7XG4gICAgICAgIGxpc3RlbmVyc1tfbGlzdGVuaW5nLmlkXSA9IF9saXN0ZW5pbmc7XG4gICAgICAgIC8vIEFsbG93IHRoZSBsaXN0ZW5pbmcgdG8gdXNlIGEgY291bnRlciwgaW5zdGVhZCBvZiB0cmFja2luZ1xuICAgICAgICAvLyBjYWxsYmFja3MgZm9yIGxpYnJhcnkgaW50ZXJvcFxuICAgICAgICBfbGlzdGVuaW5nLmludGVyb3AgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmAuIFRlbGwgKnRoaXMqIG9iamVjdCB0byBsaXN0ZW4gdG9cbi8vIGFuIGV2ZW50IGluIGFub3RoZXIgb2JqZWN0Li4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzIGxpc3RlbmluZyB0b1xuLy8gZm9yIGVhc2llciB1bmJpbmRpbmcgbGF0ZXIuXG5FdmVudHMubGlzdGVuVG8gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiB0aGlzO1xuICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSB1bmlxdWVJZCgnbCcpKTtcbiAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSk7XG4gICAgdmFyIGxpc3RlbmluZyA9IF9saXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZF07XG5cbiAgICAvLyBUaGlzIG9iamVjdCBpcyBub3QgbGlzdGVuaW5nIHRvIGFueSBvdGhlciBldmVudHMgb24gYG9iamAgeWV0LlxuICAgIC8vIFNldHVwIHRoZSBuZWNlc3NhcnkgcmVmZXJlbmNlcyB0byB0cmFjayB0aGUgbGlzdGVuaW5nIGNhbGxiYWNrcy5cbiAgICBpZiAoIWxpc3RlbmluZykge1xuICAgICAgICB0aGlzLl9saXN0ZW5JZCB8fCAodGhpcy5fbGlzdGVuSWQgPSB1bmlxdWVJZCgnbCcpKTtcbiAgICAgICAgbGlzdGVuaW5nID0gX2xpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXSA9IG5ldyBMaXN0ZW5pbmcodGhpcywgb2JqKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIGNhbGxiYWNrcyBvbiBvYmouXG4gICAgdmFyIGVycm9yID0gdHJ5Q2F0Y2hPbihvYmosIG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICBfbGlzdGVuaW5nID0gdm9pZCAwO1xuXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAvLyBJZiB0aGUgdGFyZ2V0IG9iaiBpcyBub3QgRXZlbnRzLCB0cmFjayBldmVudHMgbWFudWFsbHkuXG4gICAgaWYgKGxpc3RlbmluZy5pbnRlcm9wKSBsaXN0ZW5pbmcub24obmFtZSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUaGUgcmVkdWNpbmcgQVBJIHRoYXQgYWRkcyBhIGNhbGxiYWNrIHRvIHRoZSBgZXZlbnRzYCBvYmplY3QuXG52YXIgb25BcGkgPSBmdW5jdGlvbihldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXSB8fCAoZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgY3R4ID0gb3B0aW9ucy5jdHgsIGxpc3RlbmluZyA9IG9wdGlvbnMubGlzdGVuaW5nO1xuICAgICAgICBpZiAobGlzdGVuaW5nKSBsaXN0ZW5pbmcuY291bnQrKztcblxuICAgICAgICBoYW5kbGVycy5wdXNoKHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBjdHg6IGNvbnRleHQgfHwgY3R4LCBsaXN0ZW5pbmc6IGxpc3RlbmluZyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbn07XG5cbi8vIEFuIHRyeS1jYXRjaCBndWFyZGVkICNvbiBmdW5jdGlvbiwgdG8gcHJldmVudCBwb2lzb25pbmcgdGhlIGdsb2JhbFxuLy8gYF9saXN0ZW5pbmdgIHZhcmlhYmxlLlxudmFyIHRyeUNhdGNoT24gPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqLm9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbn07XG5cbi8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuLy8gY2FsbGJhY2tzIHdpdGggdGhhdCBmdW5jdGlvbi4gSWYgYGNhbGxiYWNrYCBpcyBudWxsLCByZW1vdmVzIGFsbFxuLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxuLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuRXZlbnRzLm9mZiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgbGlzdGVuZXJzOiB0aGlzLl9saXN0ZW5lcnNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGVsbCB0aGlzIG9iamVjdCB0byBzdG9wIGxpc3RlbmluZyB0byBlaXRoZXIgc3BlY2lmaWMgZXZlbnRzIC4uLiBvclxuLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbkV2ZW50cy5zdG9wTGlzdGVuaW5nID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvO1xuICAgIGlmICghbGlzdGVuaW5nVG8pIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGlkcyA9IG9iaiA/IFtvYmouX2xpc3RlbklkXSA6IE9iamVjdC5rZXlzKGxpc3RlbmluZ1RvKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRzW2ldXTtcblxuICAgICAgICAvLyBJZiBsaXN0ZW5pbmcgZG9lc24ndCBleGlzdCwgdGhpcyBvYmplY3QgaXMgbm90IGN1cnJlbnRseVxuICAgICAgICAvLyBsaXN0ZW5pbmcgdG8gb2JqLiBCcmVhayBvdXQgZWFybHkuXG4gICAgICAgIGlmICghbGlzdGVuaW5nKSBicmVhaztcblxuICAgICAgICBsaXN0ZW5pbmcub2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XG4gICAgICAgIGlmIChsaXN0ZW5pbmcuaW50ZXJvcCkgbGlzdGVuaW5nLm9mZihuYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmIChpc0VtcHR5KGxpc3RlbmluZ1RvKSkgdGhpcy5fbGlzdGVuaW5nVG8gPSB2b2lkIDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCByZW1vdmVzIGEgY2FsbGJhY2sgZnJvbSB0aGUgYGV2ZW50c2Agb2JqZWN0LlxudmFyIG9mZkFwaSA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoIWV2ZW50cykgcmV0dXJuO1xuXG4gICAgdmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQsIGxpc3RlbmVycyA9IG9wdGlvbnMubGlzdGVuZXJzO1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG5cbiAgICAvLyBEZWxldGUgYWxsIGV2ZW50IGxpc3RlbmVycyBhbmQgXCJkcm9wXCIgZXZlbnRzLlxuICAgIGlmICghbmFtZSAmJiAhY29udGV4dCAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgaWYobGlzdGVuZXJzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhsaXN0ZW5lcnMpOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbbmFtZXNbaV1dLmNsZWFudXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgZm9yICg7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcblxuICAgICAgICAvLyBCYWlsIG91dCBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIHN0b3JlZC5cbiAgICAgICAgaWYgKCFoYW5kbGVycykgYnJlYWs7XG5cbiAgICAgICAgLy8gRmluZCBhbnkgcmVtYWluaW5nIGV2ZW50cy5cbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2pdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrICYmXG4gICAgICAgIGNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrLl9jYWxsYmFjayB8fFxuICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dCAhPT0gaGFuZGxlci5jb250ZXh0XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmluZyA9IGhhbmRsZXIubGlzdGVuaW5nO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5pbmcpIGxpc3RlbmluZy5vZmYobmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwbGFjZSBldmVudHMgaWYgdGhlcmUgYXJlIGFueSByZW1haW5pbmcuICBPdGhlcndpc2UsIGNsZWFuIHVwLlxuICAgICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgZXZlbnRzW25hbWVdID0gcmVtYWluaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudHM7XG59O1xuXG4vLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4vLyB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZCwgaXRzIGxpc3RlbmVyIHdpbGwgYmUgcmVtb3ZlZC4gSWYgbXVsdGlwbGUgZXZlbnRzXG4vLyBhcmUgcGFzc2VkIGluIHVzaW5nIHRoZSBzcGFjZS1zZXBhcmF0ZWQgc3ludGF4LCB0aGUgaGFuZGxlciB3aWxsIGZpcmVcbi8vIG9uY2UgZm9yIGVhY2ggZXZlbnQsIG5vdCBvbmNlIGZvciBhIGNvbWJpbmF0aW9uIG9mIGFsbCBldmVudHMuXG5FdmVudHMub25jZSA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4vLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCB0aGlzLm9mZi5iaW5kKHRoaXMpKTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIGNvbnRleHQgPT0gbnVsbCkgY2FsbGJhY2sgPSB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCBjYWxsYmFjaywgY29udGV4dCk7XG59O1xuXG4vLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25jZWAuXG5FdmVudHMubGlzdGVuVG9PbmNlID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xuLy8gTWFwIHRoZSBldmVudCBpbnRvIGEgYHtldmVudDogb25jZX1gIG9iamVjdC5cbiAgICB2YXIgZXZlbnRzID0gZXZlbnRzQXBpKG9uY2VNYXAsIHt9LCBuYW1lLCBjYWxsYmFjaywgdGhpcy5zdG9wTGlzdGVuaW5nLmJpbmQodGhpcywgb2JqKSk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuVG8ob2JqLCBldmVudHMpO1xufTtcblxuLy8gUmVkdWNlcyB0aGUgZXZlbnQgY2FsbGJhY2tzIGludG8gYSBtYXAgb2YgYHtldmVudDogb25jZVdyYXBwZXJ9YC5cbi8vIGBvZmZlcmAgdW5iaW5kcyB0aGUgYG9uY2VXcmFwcGVyYCBhZnRlciBpdCBoYXMgYmVlbiBjYWxsZWQuXG52YXIgb25jZU1hcCA9IGZ1bmN0aW9uKG1hcCwgbmFtZSwgY2FsbGJhY2ssIG9mZmVyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvbmNlID0gbWFwW25hbWVdID0gb25jZUludm9rZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG9mZmVyKG5hbWUsIG9uY2UpO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uY2UuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59O1xuXG4vLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nICdmdW5jJyBvbmNlLlxuLy8gUmVwZWF0IGNhbGxzIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLlxudmFyIG9uY2VJbnZva2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBuID0gMjtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59O1xuXG4vLyBUcmlnZ2VyIG9uZSBvciBtYW55IGV2ZW50cywgZmlyaW5nIGFsbCBib3VuZCBjYWxsYmFja3MuIENhbGxiYWNrcyBhcmVcbi8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4vLyAodW5sZXNzIHlvdSdyZSBsaXN0ZW5pbmcgb24gYFwiYWxsXCJgLCB3aGljaCB3aWxsIGNhdXNlIHlvdXIgY2FsbGJhY2sgdG9cbi8vIHJlY2VpdmUgdGhlIHRydWUgbmFtZSBvZiB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50KS5cbkV2ZW50cy50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heCgwLCBhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuXG4gICAgZXZlbnRzQXBpKHRyaWdnZXJBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgdm9pZCAwLCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIEhhbmRsZXMgdHJpZ2dlcmluZyB0aGUgYXBwcm9wcmlhdGUgZXZlbnQgY2FsbGJhY2tzLlxudmFyIHRyaWdnZXJBcGkgPSBmdW5jdGlvbihvYmpFdmVudHMsIG5hbWUsIGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgaWYgKG9iakV2ZW50cykge1xuICAgICAgICB2YXIgZXZlbnRzID0gb2JqRXZlbnRzW25hbWVdO1xuICAgICAgICB2YXIgYWxsRXZlbnRzID0gb2JqRXZlbnRzLmFsbDtcbiAgICAgICAgaWYgKGV2ZW50cyAmJiBhbGxFdmVudHMpIGFsbEV2ZW50cyA9IGFsbEV2ZW50cy5zbGljZSgpO1xuICAgICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICAgIGlmIChhbGxFdmVudHMpIHRyaWdnZXJFdmVudHMoYWxsRXZlbnRzLCBbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iakV2ZW50cztcbn07XG5cbi8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4vLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXG4vLyBldmVudHMgaGF2ZSAzIGFyZ3VtZW50cykuXG52YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XG4gICAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xuICAgICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcbiAgICB9XG59O1xuXG4vLyBBIGxpc3RlbmluZyBjbGFzcyB0aGF0IHRyYWNrcyBhbmQgY2xlYW5zIHVwIG1lbW9yeSBiaW5kaW5nc1xuLy8gd2hlbiBhbGwgY2FsbGJhY2tzIGhhdmUgYmVlbiBvZmZlZC5cbnZhciBMaXN0ZW5pbmcgPSBmdW5jdGlvbihsaXN0ZW5lciwgb2JqKSB7XG4gICAgdGhpcy5pZCA9IGxpc3RlbmVyLl9saXN0ZW5JZDtcbiAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgdGhpcy5vYmogPSBvYmo7XG4gICAgdGhpcy5pbnRlcm9wID0gdHJ1ZTtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB0aGlzLl9ldmVudHMgPSB2b2lkIDA7XG59O1xuXG5MaXN0ZW5pbmcucHJvdG90eXBlLm9uID0gRXZlbnRzLm9uO1xuXG4vLyBPZmZzIGEgY2FsbGJhY2sgKG9yIHNldmVyYWwpLlxuLy8gVXNlcyBhbiBvcHRpbWl6ZWQgY291bnRlciBpZiB0aGUgbGlzdGVuZWUgdXNlcyBFdmVudHMuXG4vLyBPdGhlcndpc2UsIGZhbGxzIGJhY2sgdG8gbWFudWFsIHRyYWNraW5nIHRvIHN1cHBvcnQgZXZlbnRzXG4vLyBsaWJyYXJ5IGludGVyb3AuXG5MaXN0ZW5pbmcucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNsZWFudXA7XG4gICAgaWYgKHRoaXMuaW50ZXJvcCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBldmVudHNBcGkob2ZmQXBpLCB0aGlzLl9ldmVudHMsIG5hbWUsIGNhbGxiYWNrLCB7XG4gICAgICAgICAgICBjb250ZXh0OiB2b2lkIDAsXG4gICAgICAgICAgICBsaXN0ZW5lcnM6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY2xlYW51cCA9ICF0aGlzLl9ldmVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICBjbGVhbnVwID0gdGhpcy5jb3VudCA9PT0gMDtcbiAgICB9XG4gICAgaWYgKGNsZWFudXApIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLy8gQ2xlYW5zIHVwIG1lbW9yeSBiaW5kaW5ncyBiZXR3ZWVuIHRoZSBsaXN0ZW5lciBhbmQgdGhlIGxpc3RlbmVlLlxuTGlzdGVuaW5nLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXMubGlzdGVuZXIuX2xpc3RlbmluZ1RvW3RoaXMub2JqLl9saXN0ZW5JZF07XG4gICAgaWYgKCF0aGlzLmludGVyb3ApIGRlbGV0ZSB0aGlzLm9iai5fbGlzdGVuZXJzW3RoaXMuaWRdO1xufTtcblxuLy8gQWxpYXNlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5FdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuRXZlbnRzLnVuYmluZCA9IEV2ZW50cy5vZmY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Listener.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Listener.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Listener: () => (/* binding */ Listener)\n/* harmony export */ });\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Events.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n\n\nclass Listener {\n    constructor(...callbackArguments) {\n        this.callbackArguments = callbackArguments;\n    }\n\n    listenTo(object, evt, ...args) {\n        const { callbackArguments } = this;\n        // signature 1 - (object, eventHashMap, context)\n        if (evt && typeof evt === 'object') {\n            const [context = null] = args;\n            Object.entries(evt).forEach(([eventName, cb]) => {\n                if (typeof cb !== 'function') return;\n                // Invoke the callback with callbackArguments passed first\n                if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n                _Events_mjs__WEBPACK_IMPORTED_MODULE_0__.Events.listenTo.call(this, object, eventName, cb);\n            });\n        }\n        // signature 2 - (object, event, callback, context)\n        else if (typeof evt === 'string' && typeof args[0] === 'function') {\n            let [cb, context = null] = args;\n            // Invoke the callback with callbackArguments passed first\n            if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n            _Events_mjs__WEBPACK_IMPORTED_MODULE_0__.Events.listenTo.call(this, object, evt, cb);\n        }\n    }\n\n    stopListening() {\n        _Events_mjs__WEBPACK_IMPORTED_MODULE_0__.Events.stopListening.call(this);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9MaXN0ZW5lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7O0FBRS9CO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBTTtBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsUUFBUSwrQ0FBTTtBQUNkO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvTGlzdGVuZXIubWpzP2Y1NmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi9FdmVudHMubWpzJztcblxuZXhwb3J0IGNsYXNzIExpc3RlbmVyIHtcbiAgICBjb25zdHJ1Y3RvciguLi5jYWxsYmFja0FyZ3VtZW50cykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrQXJndW1lbnRzID0gY2FsbGJhY2tBcmd1bWVudHM7XG4gICAgfVxuXG4gICAgbGlzdGVuVG8ob2JqZWN0LCBldnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja0FyZ3VtZW50cyB9ID0gdGhpcztcbiAgICAgICAgLy8gc2lnbmF0dXJlIDEgLSAob2JqZWN0LCBldmVudEhhc2hNYXAsIGNvbnRleHQpXG4gICAgICAgIGlmIChldnQgJiYgdHlwZW9mIGV2dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb250ZXh0ID0gbnVsbF0gPSBhcmdzO1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoZXZ0KS5mb3JFYWNoKChbZXZlbnROYW1lLCBjYl0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGNhbGxiYWNrQXJndW1lbnRzIHBhc3NlZCBmaXJzdFxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0IHx8IGNhbGxiYWNrQXJndW1lbnRzLmxlbmd0aCA+IDApIGNiID0gY2IuYmluZChjb250ZXh0LCAuLi5jYWxsYmFja0FyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgRXZlbnRzLmxpc3RlblRvLmNhbGwodGhpcywgb2JqZWN0LCBldmVudE5hbWUsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpZ25hdHVyZSAyIC0gKG9iamVjdCwgZXZlbnQsIGNhbGxiYWNrLCBjb250ZXh0KVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXZ0ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGV0IFtjYiwgY29udGV4dCA9IG51bGxdID0gYXJncztcbiAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBjYWxsYmFja0FyZ3VtZW50cyBwYXNzZWQgZmlyc3RcbiAgICAgICAgICAgIGlmIChjb250ZXh0IHx8IGNhbGxiYWNrQXJndW1lbnRzLmxlbmd0aCA+IDApIGNiID0gY2IuYmluZChjb250ZXh0LCAuLi5jYWxsYmFja0FyZ3VtZW50cyk7XG4gICAgICAgICAgICBFdmVudHMubGlzdGVuVG8uY2FsbCh0aGlzLCBvYmplY3QsIGV2dCwgY2IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcExpc3RlbmluZygpIHtcbiAgICAgICAgRXZlbnRzLnN0b3BMaXN0ZW5pbmcuY2FsbCh0aGlzKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Listener.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/Model.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Model.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mvcUtils.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n// Model\n// --------------\n\n// **Models** are the basic data object in the framework --\n// frequently representing a row in a table in a database on your server.\n// A discrete chunk of data and a bunch of useful, related methods for\n// performing computations and transformations on that data.\n\n// Create a new model with the specified attributes. A client id (`cid`)\n// is automatically generated and assigned for you.\n\nvar Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)(this.cidPrefix);\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    var attributeDefaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'defaults');\n\n    // Just _.defaults would work fine, but the additional _.extends\n    // is in there for historical reasons. See #3843.\n    attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults)((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, attributeDefaults, attrs), attributeDefaults);\n\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n};\n\n// Attach all inheritable methods to the Model prototype.\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(Model.prototype, _Events_mjs__WEBPACK_IMPORTED_MODULE_1__.Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // The prefix is used to create the client id which is used to identify models locally.\n    // You may want to override this if you're experiencing name clashes with model ids.\n    cidPrefix: 'c',\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Model.\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this.attributes);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n        return this.attributes[attr];\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n        return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n        if (key == null) return this;\n\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\n        var attrs;\n        if (typeof key === 'object') {\n            attrs = key;\n            options = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        options || (options = {});\n\n        // Run validation.\n        if (!this._validate(attrs, options)) return false;\n\n        // Extract attributes and options.\n        var unset      = options.unset;\n        var silent     = options.silent;\n        var changes    = [];\n        var changing   = this._changing;\n        this._changing = true;\n\n        if (!changing) {\n            this._previousAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this.attributes);\n            this.changed = {};\n        }\n\n        var current = this.attributes;\n        var changed = this.changed;\n        var prev    = this._previousAttributes;\n\n        // For each `set` attribute, update or delete the current value.\n        for (var attr in attrs) {\n            val = attrs[attr];\n            if (!(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(current[attr], val)) changes.push(attr);\n            if (!(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(prev[attr], val)) {\n                changed[attr] = val;\n            } else {\n                delete changed[attr];\n            }\n            unset ? delete current[attr] : current[attr] = val;\n        }\n\n        // Update the `id`.\n        if (this.idAttribute in attrs) {\n            var prevId = this.id;\n            this.id = this.get(this.idAttribute);\n            this.trigger('changeId', this, prevId, options);\n        }\n\n        // Trigger all relevant attribute changes.\n        if (!silent) {\n            if (changes.length) this._pending = options;\n            for (var i = 0; i < changes.length; i++) {\n                this.trigger('change:' + changes[i], this, current[changes[i]], options);\n            }\n        }\n\n        // You might be wondering why there's a `while` loop here. Changes can\n        // be recursively nested within `\"change\"` events.\n        if (changing) return this;\n        if (!silent) {\n            while (this._pending) {\n                options = this._pending;\n                this._pending = false;\n                this.trigger('change', this, options);\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n        return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n        return this.set(attr, void 0, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, { unset: true }));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n        var attrs = {};\n        for (var key in this.attributes) attrs[key] = void 0;\n        return this.set(attrs, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, { unset: true }));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n        if (attr == null) return !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.changed);\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.has)(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n        if (!diff) return this.hasChanged() ? (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this.changed) : false;\n        var old = this._changing ? this._previousAttributes : this.attributes;\n        var changed = {};\n        var hasChanged;\n        for (var attr in diff) {\n            var val = diff[attr];\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(old[attr], val)) continue;\n            changed[attr] = val;\n            hasChanged = true;\n        }\n        return hasChanged ? changed : false;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n        if (attr == null || !this._previousAttributes) return null;\n        return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this._previousAttributes);\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n        return new this.constructor(this.attributes);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n        return this._validate({}, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n        if (!options.validate || !this.validate) return true;\n        attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this.attributes, attrs);\n        var error = this.validationError = this.validate(attrs, options) || null;\n        if (!error) return true;\n        this.trigger('invalid', this, error, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(options, { validationError: error }));\n        return false;\n    }\n\n});\n\n// Set up inheritance for the model.\nModel.extend = _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_2__.extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Nb2RlbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUNFO0FBVWQ7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsZUFBZSx3REFBUTtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFNOztBQUVsQztBQUNBO0FBQ0EsWUFBWSx3REFBUSxDQUFDLHNEQUFNLEdBQUc7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQU0sa0JBQWtCLCtDQUFNOztBQUU5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLHFEQUFLO0FBQ3BCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUI7QUFDdkI7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxxREFBSztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdURBQU87QUFDeEIsaUJBQWlCLHVEQUFPO0FBQ3hCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFNLEdBQUcsYUFBYSxhQUFhO0FBQ3pFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0RBQU0sR0FBRyxhQUFhLGFBQWE7QUFDbEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdURBQU87QUFDekMsZUFBZSxtREFBRztBQUNsQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFEQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQUs7QUFDcEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxzREFBTSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3hFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQU0sR0FBRztBQUN6QjtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFNLFlBQVksd0JBQXdCO0FBQ3ZGO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBLGVBQWUsaURBQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvTW9kZWwubWpzP2M0MjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRzIH0gZnJvbSAnLi9FdmVudHMubWpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vbXZjVXRpbHMubWpzJztcbmltcG9ydCB7XG4gICAgYXNzaWduLFxuICAgIGNsb25lLFxuICAgIGRlZmF1bHRzLFxuICAgIGhhcyxcbiAgICBpc0VxdWFsLFxuICAgIGlzRW1wdHksXG4gICAgcmVzdWx0LFxuICAgIHVuaXF1ZUlkXG59IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuXG4vLyBNb2RlbFxuLy8gLS0tLS0tLS0tLS0tLS1cblxuLy8gKipNb2RlbHMqKiBhcmUgdGhlIGJhc2ljIGRhdGEgb2JqZWN0IGluIHRoZSBmcmFtZXdvcmsgLS1cbi8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cbi8vIEEgZGlzY3JldGUgY2h1bmsgb2YgZGF0YSBhbmQgYSBidW5jaCBvZiB1c2VmdWwsIHJlbGF0ZWQgbWV0aG9kcyBmb3Jcbi8vIHBlcmZvcm1pbmcgY29tcHV0YXRpb25zIGFuZCB0cmFuc2Zvcm1hdGlvbnMgb24gdGhhdCBkYXRhLlxuXG4vLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChgY2lkYClcbi8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuXG5leHBvcnQgdmFyIE1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBhdHRycyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICB0aGlzLnByZWluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmNpZCA9IHVuaXF1ZUlkKHRoaXMuY2lkUHJlZml4KTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jb2xsZWN0aW9uKSB0aGlzLmNvbGxlY3Rpb24gPSBvcHRpb25zLmNvbGxlY3Rpb247XG4gICAgdmFyIGF0dHJpYnV0ZURlZmF1bHRzID0gcmVzdWx0KHRoaXMsICdkZWZhdWx0cycpO1xuXG4gICAgLy8gSnVzdCBfLmRlZmF1bHRzIHdvdWxkIHdvcmsgZmluZSwgYnV0IHRoZSBhZGRpdGlvbmFsIF8uZXh0ZW5kc1xuICAgIC8vIGlzIGluIHRoZXJlIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuIFNlZSAjMzg0My5cbiAgICBhdHRycyA9IGRlZmF1bHRzKGFzc2lnbih7fSwgYXR0cmlidXRlRGVmYXVsdHMsIGF0dHJzKSwgYXR0cmlidXRlRGVmYXVsdHMpO1xuXG4gICAgdGhpcy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gQXR0YWNoIGFsbCBpbmhlcml0YWJsZSBtZXRob2RzIHRvIHRoZSBNb2RlbCBwcm90b3R5cGUuXG5hc3NpZ24oTW9kZWwucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIEEgaGFzaCBvZiBhdHRyaWJ1dGVzIHdob3NlIGN1cnJlbnQgYW5kIHByZXZpb3VzIHZhbHVlIGRpZmZlci5cbiAgICBjaGFuZ2VkOiBudWxsLFxuXG4gICAgLy8gVGhlIHZhbHVlIHJldHVybmVkIGR1cmluZyB0aGUgbGFzdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICB2YWxpZGF0aW9uRXJyb3I6IG51bGwsXG5cbiAgICAvLyBUaGUgZGVmYXVsdCBuYW1lIGZvciB0aGUgSlNPTiBgaWRgIGF0dHJpYnV0ZSBpcyBgXCJpZFwiYC4gTW9uZ29EQiBhbmRcbiAgICAvLyBDb3VjaERCIHVzZXJzIG1heSB3YW50IHRvIHNldCB0aGlzIHRvIGBcIl9pZFwiYC5cbiAgICBpZEF0dHJpYnV0ZTogJ2lkJyxcblxuICAgIC8vIFRoZSBwcmVmaXggaXMgdXNlZCB0byBjcmVhdGUgdGhlIGNsaWVudCBpZCB3aGljaCBpcyB1c2VkIHRvIGlkZW50aWZ5IG1vZGVscyBsb2NhbGx5LlxuICAgIC8vIFlvdSBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGlmIHlvdSdyZSBleHBlcmllbmNpbmcgbmFtZSBjbGFzaGVzIHdpdGggbW9kZWwgaWRzLlxuICAgIGNpZFByZWZpeDogJ2MnLFxuXG4gICAgLy8gcHJlaW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBZb3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggYSBmdW5jdGlvblxuICAgIC8vIG9yIG9iamVjdC4gIHByZWluaXRpYWxpemUgd2lsbCBydW4gYmVmb3JlIGFueSBpbnN0YW50aWF0aW9uIGxvZ2ljIGlzIHJ1biBpbiB0aGUgTW9kZWwuXG4gICAgcHJlaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm8gaW1wbGVtZW50YXRpb24uXG4gICAgfSxcblxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIE5vIGltcGxlbWVudGF0aW9uLlxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBtb2RlbCdzIGBhdHRyaWJ1dGVzYCBvYmplY3QuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICBnZXQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGF0dHJpYnV0ZSBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IG51bGxcbiAgICAvLyBvciB1bmRlZmluZWQuXG4gICAgaGFzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gVGhpcyBpc1xuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xuICAgIC8vIGFueW9uZSB3aG8gbmVlZHMgdG8ga25vdyBhYm91dCB0aGUgY2hhbmdlIGluIHN0YXRlLiBUaGUgaGVhcnQgb2YgdGhlIGJlYXN0LlxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gdGhpcztcblxuICAgICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxuICAgICAgICB2YXIgYXR0cnM7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICBvcHRpb25zID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAgIC8vIFJ1biB2YWxpZGF0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgYXR0cmlidXRlcyBhbmQgb3B0aW9ucy5cbiAgICAgICAgdmFyIHVuc2V0ICAgICAgPSBvcHRpb25zLnVuc2V0O1xuICAgICAgICB2YXIgc2lsZW50ICAgICA9IG9wdGlvbnMuc2lsZW50O1xuICAgICAgICB2YXIgY2hhbmdlcyAgICA9IFtdO1xuICAgICAgICB2YXIgY2hhbmdpbmcgICA9IHRoaXMuX2NoYW5naW5nO1xuICAgICAgICB0aGlzLl9jaGFuZ2luZyA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFjaGFuZ2luZykge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBjaGFuZ2VkID0gdGhpcy5jaGFuZ2VkO1xuICAgICAgICB2YXIgcHJldiAgICA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcztcblxuICAgICAgICAvLyBGb3IgZWFjaCBgc2V0YCBhdHRyaWJ1dGUsIHVwZGF0ZSBvciBkZWxldGUgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIHZhbCA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKGN1cnJlbnRbYXR0cl0sIHZhbCkpIGNoYW5nZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChwcmV2W2F0dHJdLCB2YWwpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFthdHRyXSA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNoYW5nZWRbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnNldCA/IGRlbGV0ZSBjdXJyZW50W2F0dHJdIDogY3VycmVudFthdHRyXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYGlkYC5cbiAgICAgICAgaWYgKHRoaXMuaWRBdHRyaWJ1dGUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBwcmV2SWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0KHRoaXMuaWRBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2VJZCcsIHRoaXMsIHByZXZJZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmlnZ2VyIGFsbCByZWxldmFudCBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCkgdGhpcy5fcGVuZGluZyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXG4gICAgICAgIC8vIGJlIHJlY3Vyc2l2ZWx5IG5lc3RlZCB3aXRoaW4gYFwiY2hhbmdlXCJgIGV2ZW50cy5cbiAgICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBtb2RlbCwgZmlyaW5nIGBcImNoYW5nZVwiYC4gYHVuc2V0YCBpcyBhIG5vb3BcbiAgICAvLyBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3QgZXhpc3QuXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgYXNzaWduKHt9LCBvcHRpb25zLCB7IHVuc2V0OiB0cnVlIH0pKTtcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSBhdHRyc1trZXldID0gdm9pZCAwO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cnMsIGFzc2lnbih7fSwgb3B0aW9ucywgeyB1bnNldDogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbW9kZWwgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIC8vIElmIHlvdSBzcGVjaWZ5IGFuIGF0dHJpYnV0ZSBuYW1lLCBkZXRlcm1pbmUgaWYgdGhhdCBhdHRyaWJ1dGUgaGFzIGNoYW5nZWQuXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBpZiAoYXR0ciA9PSBudWxsKSByZXR1cm4gIWlzRW1wdHkodGhpcy5jaGFuZ2VkKTtcbiAgICAgICAgcmV0dXJuIGhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgaGF2ZSBjaGFuZ2VkLCBvclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxuICAgIC8vIHBhcnRzIG9mIGEgdmlldyBuZWVkIHRvIGJlIHVwZGF0ZWQgYW5kL29yIHdoYXQgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAgLy8gcGVyc2lzdGVkIHRvIHRoZSBzZXJ2ZXIuIFVuc2V0IGF0dHJpYnV0ZXMgd2lsbCBiZSBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXG4gICAgLy8gZGV0ZXJtaW5pbmcgaWYgdGhlcmUgKndvdWxkIGJlKiBhIGNoYW5nZS5cbiAgICBjaGFuZ2VkQXR0cmlidXRlczogZnVuY3Rpb24oZGlmZikge1xuICAgICAgICBpZiAoIWRpZmYpIHJldHVybiB0aGlzLmhhc0NoYW5nZWQoKSA/IGNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuX2NoYW5naW5nID8gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzIDogdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuICAgICAgICB2YXIgaGFzQ2hhbmdlZDtcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBkaWZmKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gZGlmZlthdHRyXTtcbiAgICAgICAgICAgIGlmIChpc0VxdWFsKG9sZFthdHRyXSwgdmFsKSkgY29udGludWU7XG4gICAgICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhc0NoYW5nZWQgPyBjaGFuZ2VkIDogZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxuICAgIC8vIGBcImNoYW5nZVwiYCBldmVudCB3YXMgZmlyZWQuXG4gICAgcHJldmlvdXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHIgPT0gbnVsbCB8fCAhdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgbW9kZWwgaXMgY3VycmVudGx5IGluIGEgdmFsaWQgc3RhdGUuXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUoe30sIGFzc2lnbih7fSwgb3B0aW9ucywgeyB2YWxpZGF0ZTogdHJ1ZSB9KSk7XG4gICAgfSxcblxuICAgIC8vIFJ1biB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIG5leHQgY29tcGxldGUgc2V0IG9mIG1vZGVsIGF0dHJpYnV0ZXMsXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMudmFsaWRhdGUgfHwgIXRoaXMudmFsaWRhdGUpIHJldHVybiB0cnVlO1xuICAgICAgICBhdHRycyA9IGFzc2lnbih7fSwgdGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMudmFsaWRhdGlvbkVycm9yID0gdGhpcy52YWxpZGF0ZShhdHRycywgb3B0aW9ucykgfHwgbnVsbDtcbiAgICAgICAgaWYgKCFlcnJvcikgcmV0dXJuIHRydWU7XG4gICAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIGVycm9yLCBhc3NpZ24ob3B0aW9ucywgeyB2YWxpZGF0aW9uRXJyb3I6IGVycm9yIH0pKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxufSk7XG5cbi8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLlxuTW9kZWwuZXh0ZW5kID0gZXh0ZW5kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/Model.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/View.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/View.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   View: () => (/* binding */ View),\n/* harmony export */   views: () => (/* binding */ views)\n/* harmony export */ });\n/* harmony import */ var _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewBase.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/config/index.mjs\");\n\n\n\n\n\n\nconst views = {};\n\nconst View = _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.extend({\n\n    options: {},\n    theme: null,\n    themeClassNamePrefix: _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix('theme-'),\n    requireSetThemeOverride: false,\n    defaultTheme: _config_index_mjs__WEBPACK_IMPORTED_MODULE_2__.config.defaultTheme,\n    children: null,\n    childNodes: null,\n\n    DETACHABLE: true,\n    UPDATE_PRIORITY: 2,\n    FLAG_INSERT: 1<<30,\n    FLAG_REMOVE: 1<<29,\n    FLAG_INIT: 1<<28,\n\n    constructor: function(options) {\n\n        this.requireSetThemeOverride = options && !!options.theme;\n        this.options = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, this.options, options);\n\n        _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.call(this, options);\n    },\n\n    initialize: function() {\n\n        views[this.cid] = this;\n\n        this.setTheme(this.options.theme || this.defaultTheme);\n        this.init();\n    },\n\n    unmount: function() {\n        if (this.svgElement) {\n            this.vel.remove();\n        } else {\n            this.$el.remove();\n        }\n    },\n\n    isMounted: function() {\n        return this.el.parentNode !== null;\n    },\n\n    renderChildren: function(children) {\n        children || (children = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'children'));\n        if (children) {\n            var isSVG = this.svgElement;\n            var namespace = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].namespace[isSVG ? 'svg' : 'xhtml'];\n            var doc = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.parseDOMJSON(children, namespace);\n            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n            this.childNodes = doc.selectors;\n        }\n        return this;\n    },\n\n    findAttributeNode: function(attributeName, node) {\n        let currentNode = node;\n        while (currentNode && currentNode.nodeType === 1) {\n            // attribute found\n            // (empty value does not count as attribute found)\n            if (currentNode.getAttribute(attributeName)) return currentNode;\n            // do not climb up the DOM\n            if (currentNode === this.el) return null;\n            // try parent node\n            currentNode = currentNode.parentNode;\n        }\n        return null;\n    },\n\n    findAttribute: function(attributeName, node) {\n        const matchedNode = this.findAttributeNode(attributeName, node);\n        return matchedNode && matchedNode.getAttribute(attributeName);\n    },\n\n    // Override the mvc ViewBase `_ensureElement()` method in order to create an\n    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n    // Expose class name setter as a separate method.\n    _ensureElement: function() {\n        if (!this.el) {\n            var tagName = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'tagName');\n            var attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'attributes'));\n            var style = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'style'));\n            if (this.id) attrs.id = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'id');\n            this.setElement(this._createElement(tagName));\n            this._setAttributes(attrs);\n            this._setStyle(style);\n        } else {\n            this.setElement(_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'el'));\n        }\n        this._ensureElClassName();\n    },\n\n    _setAttributes: function(attrs) {\n        if (this.svgElement) {\n            this.vel.attr(attrs);\n        } else {\n            this.$el.attr(attrs);\n        }\n    },\n\n    _setStyle: function(style) {\n        this.$el.css(style);\n    },\n\n    _createElement: function(tagName) {\n        if (this.svgElement) {\n            return document.createElementNS(_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].namespace.svg, tagName);\n        } else {\n            return document.createElement(tagName);\n        }\n    },\n\n    // Utilize an alternative DOM manipulation API by\n    // adding an element reference wrapped in Vectorizer.\n    _setElement: function(el) {\n        this.$el = el instanceof _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"] ? el : (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(el);\n        this.el = this.$el[0];\n        if (this.svgElement) this.vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.el);\n    },\n\n    _ensureElClassName: function() {\n        var className = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'className');\n        if (!className) return;\n        var prefixedClassName = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix(className);\n        // Note: className removal here kept for backwards compatibility only\n        if (this.svgElement) {\n            this.vel.removeClass(className).addClass(prefixedClassName);\n        } else {\n            this.$el.removeClass(className).addClass(prefixedClassName);\n        }\n    },\n\n    init: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    onRender: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    confirmUpdate: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        return 0;\n    },\n\n    setTheme: function(theme, opt) {\n\n        opt = opt || {};\n\n        // Theme is already set, override is required, and override has not been set.\n        // Don't set the theme.\n        if (this.theme && this.requireSetThemeOverride && !opt.override) {\n            return this;\n        }\n\n        this.removeThemeClassName();\n        this.addThemeClassName(theme);\n        this.onSetTheme(this.theme/* oldTheme */, theme/* newTheme */);\n        this.theme = theme;\n\n        return this;\n    },\n\n    addThemeClassName: function(theme) {\n\n        theme = theme || this.theme;\n        if (!theme) return this;\n\n        var className = this.themeClassNamePrefix + theme;\n\n        if (this.svgElement) {\n            this.vel.addClass(className);\n        } else {\n            this.$el.addClass(className);\n        }\n\n        return this;\n    },\n\n    removeThemeClassName: function(theme) {\n\n        theme = theme || this.theme;\n\n        var className = this.themeClassNamePrefix + theme;\n\n        if (this.svgElement) {\n            this.vel.removeClass(className);\n        } else {\n            this.$el.removeClass(className);\n        }\n\n        return this;\n    },\n\n    onSetTheme: function(oldTheme, newTheme) {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    remove: function() {\n\n        this.onRemove();\n        this.undelegateDocumentEvents();\n\n        views[this.cid] = null;\n\n        _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.prototype.remove.apply(this, arguments);\n\n        return this;\n    },\n\n    onRemove: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    getEventNamespace: function() {\n        // Returns a per-session unique namespace\n        return '.joint-event-ns-' + this.cid;\n    },\n\n    delegateElementEvents: function(element, events, data) {\n        if (!events) return this;\n        data || (data = {});\n        var eventNS = this.getEventNamespace();\n        for (var eventName in events) {\n            var method = events[eventName];\n            if (typeof method !== 'function') method = this[method];\n            if (!method) continue;\n            (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element).on(eventName + eventNS, data, method.bind(this));\n        }\n        return this;\n    },\n\n    undelegateElementEvents: function(element) {\n        (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element).off(this.getEventNamespace());\n        return this;\n    },\n\n    delegateDocumentEvents: function(events, data) {\n        events || (events = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'documentEvents'));\n        return this.delegateElementEvents(document, events, data);\n    },\n\n    undelegateDocumentEvents: function() {\n        return this.undelegateElementEvents(document);\n    },\n\n    eventData: function(evt, data) {\n        if (!evt) throw new Error('eventData(): event object required.');\n        var currentData = evt.data;\n        var key = '__' + this.cid + '__';\n        if (data === undefined) {\n            if (!currentData) return {};\n            return currentData[key] || {};\n        }\n        currentData || (currentData = evt.data = {});\n        currentData[key] || (currentData[key] = {});\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign(currentData[key], data);\n        return this;\n    },\n\n    stopPropagation: function(evt) {\n        this.eventData(evt, { propagationStopped: true });\n        return this;\n    },\n\n    isPropagationStopped: function(evt) {\n        return !!this.eventData(evt).propagationStopped;\n    }\n\n}, {\n\n    extend: function() {\n\n        var args = Array.from(arguments);\n\n        // Deep clone the prototype and static properties objects.\n        // This prevents unexpected behavior where some properties are overwritten outside of this function.\n        var protoProps = args[0] && _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, args[0]) || {};\n        var staticProps = args[1] && _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, args[1]) || {};\n\n        // Need the real render method so that we can wrap it and call it later.\n        var renderFn = protoProps.render || (this.prototype && this.prototype.render) || null;\n\n        /*\n            Wrap the real render method so that:\n                .. `onRender` is always called.\n                .. `this` is always returned.\n        */\n        protoProps.render = function() {\n\n            if (typeof renderFn === 'function') {\n                // Call the original render method.\n                renderFn.apply(this, arguments);\n            }\n\n            if (this.render.__render__ === renderFn) {\n                // Should always call onRender() method.\n                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n                this.onRender();\n            }\n\n            // Should always return itself.\n            return this;\n        };\n\n        protoProps.render.__render__ = renderFn;\n\n        return _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.extend.call(this, protoProps, staticProps);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9WaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFnQztBQUNVO0FBQ1g7QUFDVztBQUNHOztBQUV0Qzs7QUFFQSxhQUFhLG1EQUFROztBQUU1QixlQUFlO0FBQ2Y7QUFDQSwwQkFBMEIsK0RBQXVCO0FBQ2pEO0FBQ0Esa0JBQWtCLHFEQUFNO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixtREFBVyxHQUFHOztBQUVyQyxRQUFRLG1EQUFRO0FBQ2hCLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0NBQWdDLG1EQUFXO0FBQzNDO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQUM7QUFDN0Isc0JBQXNCLHlEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbURBQVc7QUFDckMsd0JBQXdCLG1EQUFXLEdBQUcsRUFBRSxtREFBVztBQUNuRCx3QkFBd0IsbURBQVcsR0FBRyxFQUFFLG1EQUFXO0FBQ25ELG9DQUFvQyxtREFBVztBQUMvQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLG1EQUFXO0FBQ3ZDO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsNENBQTRDLG9EQUFDO0FBQzdDLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQUMsUUFBUSwwREFBQztBQUMzQztBQUNBLHdDQUF3Qyx3REFBQztBQUN6QyxLQUFLOztBQUVMO0FBQ0Esd0JBQXdCLG1EQUFXO0FBQ25DO0FBQ0EsZ0NBQWdDLCtEQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxtREFBUTs7QUFFaEI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFDO0FBQ2I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxRQUFRLDBEQUFDO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsNEJBQTRCLG1EQUFXO0FBQ3ZDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELGtEQUFrRDtBQUNsRCxRQUFRLG1EQUFXO0FBQ25CO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQVcsR0FBRztBQUNsRCxxQ0FBcUMsbURBQVcsR0FBRzs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxtREFBUTtBQUN2QjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvVmlldy5tanM/ZDYxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICcuL0RvbS9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBWaWV3QmFzZSB9IGZyb20gJy4vVmlld0Jhc2UubWpzJztcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3Qgdmlld3MgPSB7fTtcblxuZXhwb3J0IGNvbnN0IFZpZXcgPSBWaWV3QmFzZS5leHRlbmQoe1xuXG4gICAgb3B0aW9uczoge30sXG4gICAgdGhlbWU6IG51bGwsXG4gICAgdGhlbWVDbGFzc05hbWVQcmVmaXg6IHV0aWwuYWRkQ2xhc3NOYW1lUHJlZml4KCd0aGVtZS0nKSxcbiAgICByZXF1aXJlU2V0VGhlbWVPdmVycmlkZTogZmFsc2UsXG4gICAgZGVmYXVsdFRoZW1lOiBjb25maWcuZGVmYXVsdFRoZW1lLFxuICAgIGNoaWxkcmVuOiBudWxsLFxuICAgIGNoaWxkTm9kZXM6IG51bGwsXG5cbiAgICBERVRBQ0hBQkxFOiB0cnVlLFxuICAgIFVQREFURV9QUklPUklUWTogMixcbiAgICBGTEFHX0lOU0VSVDogMTw8MzAsXG4gICAgRkxBR19SRU1PVkU6IDE8PDI5LFxuICAgIEZMQUdfSU5JVDogMTw8MjgsXG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVxdWlyZVNldFRoZW1lT3ZlcnJpZGUgPSBvcHRpb25zICYmICEhb3B0aW9ucy50aGVtZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdXRpbC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgVmlld0Jhc2UuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmlld3NbdGhpcy5jaWRdID0gdGhpcztcblxuICAgICAgICB0aGlzLnNldFRoZW1lKHRoaXMub3B0aW9ucy50aGVtZSB8fCB0aGlzLmRlZmF1bHRUaGVtZSk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH0sXG5cbiAgICB1bm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52ZWwucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5wYXJlbnROb2RlICE9PSBudWxsO1xuICAgIH0sXG5cbiAgICByZW5kZXJDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgICAgY2hpbGRyZW4gfHwgKGNoaWxkcmVuID0gdXRpbC5yZXN1bHQodGhpcywgJ2NoaWxkcmVuJykpO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBpc1NWRyA9IHRoaXMuc3ZnRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBWLm5hbWVzcGFjZVtpc1NWRyA/ICdzdmcnIDogJ3hodG1sJ107XG4gICAgICAgICAgICB2YXIgZG9jID0gdXRpbC5wYXJzZURPTUpTT04oY2hpbGRyZW4sIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAoaXNTVkcgPyB0aGlzLnZlbCA6IHRoaXMuJGVsKS5lbXB0eSgpLmFwcGVuZChkb2MuZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmluZEF0dHJpYnV0ZU5vZGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUsIG5vZGUpIHtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGUgZm91bmRcbiAgICAgICAgICAgIC8vIChlbXB0eSB2YWx1ZSBkb2VzIG5vdCBjb3VudCBhcyBhdHRyaWJ1dGUgZm91bmQpXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAvLyBkbyBub3QgY2xpbWIgdXAgdGhlIERPTVxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlID09PSB0aGlzLmVsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIC8vIHRyeSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBmaW5kQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGVOYW1lLCBub2RlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWROb2RlID0gdGhpcy5maW5kQXR0cmlidXRlTm9kZShhdHRyaWJ1dGVOYW1lLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWROb2RlICYmIG1hdGNoZWROb2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gT3ZlcnJpZGUgdGhlIG12YyBWaWV3QmFzZSBgX2Vuc3VyZUVsZW1lbnQoKWAgbWV0aG9kIGluIG9yZGVyIHRvIGNyZWF0ZSBhblxuICAgIC8vIHN2ZyBlbGVtZW50IChlLmcuLCBgPGc+YCkgbm9kZSB0aGF0IHdyYXBzIGFsbCB0aGUgbm9kZXMgb2YgdGhlIENlbGwgdmlldy5cbiAgICAvLyBFeHBvc2UgY2xhc3MgbmFtZSBzZXR0ZXIgYXMgYSBzZXBhcmF0ZSBtZXRob2QuXG4gICAgX2Vuc3VyZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gdXRpbC5yZXN1bHQodGhpcywgJ3RhZ05hbWUnKTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHV0aWwuYXNzaWduKHt9LCB1dGlsLnJlc3VsdCh0aGlzLCAnYXR0cmlidXRlcycpKTtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHV0aWwuYXNzaWduKHt9LCB1dGlsLnJlc3VsdCh0aGlzLCAnc3R5bGUnKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSB1dGlsLnJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCh0aGlzLl9jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHV0aWwucmVzdWx0KHRoaXMsICdlbCcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbnN1cmVFbENsYXNzTmFtZSgpO1xuICAgIH0sXG5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52ZWwuYXR0cihhdHRycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5hdHRyKGF0dHJzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfc2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgIHRoaXMuJGVsLmNzcyhzdHlsZSk7XG4gICAgfSxcblxuICAgIF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoVi5uYW1lc3BhY2Uuc3ZnLCB0YWdOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFV0aWxpemUgYW4gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkgYnlcbiAgICAvLyBhZGRpbmcgYW4gZWxlbWVudCByZWZlcmVuY2Ugd3JhcHBlZCBpbiBWZWN0b3JpemVyLlxuICAgIF9zZXRFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB0aGlzLiRlbCA9IGVsIGluc3RhbmNlb2YgJCA/IGVsIDogJChlbCk7XG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkgdGhpcy52ZWwgPSBWKHRoaXMuZWwpO1xuICAgIH0sXG5cbiAgICBfZW5zdXJlRWxDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdXRpbC5yZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICBpZiAoIWNsYXNzTmFtZSkgcmV0dXJuO1xuICAgICAgICB2YXIgcHJlZml4ZWRDbGFzc05hbWUgPSB1dGlsLmFkZENsYXNzTmFtZVByZWZpeChjbGFzc05hbWUpO1xuICAgICAgICAvLyBOb3RlOiBjbGFzc05hbWUgcmVtb3ZhbCBoZXJlIGtlcHQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52ZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKS5hZGRDbGFzcyhwcmVmaXhlZENsYXNzTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpLmFkZENsYXNzKHByZWZpeGVkQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAgICB9LFxuXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5LlxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuLlxuICAgIH0sXG5cbiAgICBjb25maXJtVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIHNldFRoZW1lOiBmdW5jdGlvbih0aGVtZSwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIC8vIFRoZW1lIGlzIGFscmVhZHkgc2V0LCBvdmVycmlkZSBpcyByZXF1aXJlZCwgYW5kIG92ZXJyaWRlIGhhcyBub3QgYmVlbiBzZXQuXG4gICAgICAgIC8vIERvbid0IHNldCB0aGUgdGhlbWUuXG4gICAgICAgIGlmICh0aGlzLnRoZW1lICYmIHRoaXMucmVxdWlyZVNldFRoZW1lT3ZlcnJpZGUgJiYgIW9wdC5vdmVycmlkZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbW92ZVRoZW1lQ2xhc3NOYW1lKCk7XG4gICAgICAgIHRoaXMuYWRkVGhlbWVDbGFzc05hbWUodGhlbWUpO1xuICAgICAgICB0aGlzLm9uU2V0VGhlbWUodGhpcy50aGVtZS8qIG9sZFRoZW1lICovLCB0aGVtZS8qIG5ld1RoZW1lICovKTtcbiAgICAgICAgdGhpcy50aGVtZSA9IHRoZW1lO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRUaGVtZUNsYXNzTmFtZTogZnVuY3Rpb24odGhlbWUpIHtcblxuICAgICAgICB0aGVtZSA9IHRoZW1lIHx8IHRoaXMudGhlbWU7XG4gICAgICAgIGlmICghdGhlbWUpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnRoZW1lQ2xhc3NOYW1lUHJlZml4ICsgdGhlbWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52ZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlVGhlbWVDbGFzc05hbWU6IGZ1bmN0aW9uKHRoZW1lKSB7XG5cbiAgICAgICAgdGhlbWUgPSB0aGVtZSB8fCB0aGlzLnRoZW1lO1xuXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnRoZW1lQ2xhc3NOYW1lUHJlZml4ICsgdGhlbWU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52ZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25TZXRUaGVtZTogZnVuY3Rpb24ob2xkVGhlbWUsIG5ld1RoZW1lKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHkuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4uXG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5vblJlbW92ZSgpO1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVEb2N1bWVudEV2ZW50cygpO1xuXG4gICAgICAgIHZpZXdzW3RoaXMuY2lkXSA9IG51bGw7XG5cbiAgICAgICAgVmlld0Jhc2UucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHkuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4uXG4gICAgfSxcblxuICAgIGdldEV2ZW50TmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmV0dXJucyBhIHBlci1zZXNzaW9uIHVuaXF1ZSBuYW1lc3BhY2VcbiAgICAgICAgcmV0dXJuICcuam9pbnQtZXZlbnQtbnMtJyArIHRoaXMuY2lkO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZUVsZW1lbnRFdmVudHM6IGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50cywgZGF0YSkge1xuICAgICAgICBpZiAoIWV2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGRhdGEgfHwgKGRhdGEgPSB7fSk7XG4gICAgICAgIHZhciBldmVudE5TID0gdGhpcy5nZXRFdmVudE5hbWVzcGFjZSgpO1xuICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykgbWV0aG9kID0gdGhpc1ttZXRob2RdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgJChlbGVtZW50KS5vbihldmVudE5hbWUgKyBldmVudE5TLCBkYXRhLCBtZXRob2QuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVuZGVsZWdhdGVFbGVtZW50RXZlbnRzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICQoZWxlbWVudCkub2ZmKHRoaXMuZ2V0RXZlbnROYW1lc3BhY2UoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZURvY3VtZW50RXZlbnRzOiBmdW5jdGlvbihldmVudHMsIGRhdGEpIHtcbiAgICAgICAgZXZlbnRzIHx8IChldmVudHMgPSB1dGlsLnJlc3VsdCh0aGlzLCAnZG9jdW1lbnRFdmVudHMnKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlRWxlbWVudEV2ZW50cyhkb2N1bWVudCwgZXZlbnRzLCBkYXRhKTtcbiAgICB9LFxuXG4gICAgdW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kZWxlZ2F0ZUVsZW1lbnRFdmVudHMoZG9jdW1lbnQpO1xuICAgIH0sXG5cbiAgICBldmVudERhdGE6IGZ1bmN0aW9uKGV2dCwgZGF0YSkge1xuICAgICAgICBpZiAoIWV2dCkgdGhyb3cgbmV3IEVycm9yKCdldmVudERhdGEoKTogZXZlbnQgb2JqZWN0IHJlcXVpcmVkLicpO1xuICAgICAgICB2YXIgY3VycmVudERhdGEgPSBldnQuZGF0YTtcbiAgICAgICAgdmFyIGtleSA9ICdfXycgKyB0aGlzLmNpZCArICdfXyc7XG4gICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudERhdGEpIHJldHVybiB7fTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0YVtrZXldIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnREYXRhIHx8IChjdXJyZW50RGF0YSA9IGV2dC5kYXRhID0ge30pO1xuICAgICAgICBjdXJyZW50RGF0YVtrZXldIHx8IChjdXJyZW50RGF0YVtrZXldID0ge30pO1xuICAgICAgICB1dGlsLmFzc2lnbihjdXJyZW50RGF0YVtrZXldLCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBwcm9wYWdhdGlvblN0b3BwZWQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZXZlbnREYXRhKGV2dCkucHJvcGFnYXRpb25TdG9wcGVkO1xuICAgIH1cblxufSwge1xuXG4gICAgZXh0ZW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcblxuICAgICAgICAvLyBEZWVwIGNsb25lIHRoZSBwcm90b3R5cGUgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9iamVjdHMuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgdW5leHBlY3RlZCBiZWhhdmlvciB3aGVyZSBzb21lIHByb3BlcnRpZXMgYXJlIG92ZXJ3cml0dGVuIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgdmFyIHByb3RvUHJvcHMgPSBhcmdzWzBdICYmIHV0aWwuYXNzaWduKHt9LCBhcmdzWzBdKSB8fCB7fTtcbiAgICAgICAgdmFyIHN0YXRpY1Byb3BzID0gYXJnc1sxXSAmJiB1dGlsLmFzc2lnbih7fSwgYXJnc1sxXSkgfHwge307XG5cbiAgICAgICAgLy8gTmVlZCB0aGUgcmVhbCByZW5kZXIgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIHdyYXAgaXQgYW5kIGNhbGwgaXQgbGF0ZXIuXG4gICAgICAgIHZhciByZW5kZXJGbiA9IHByb3RvUHJvcHMucmVuZGVyIHx8ICh0aGlzLnByb3RvdHlwZSAmJiB0aGlzLnByb3RvdHlwZS5yZW5kZXIpIHx8IG51bGw7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFdyYXAgdGhlIHJlYWwgcmVuZGVyIG1ldGhvZCBzbyB0aGF0OlxuICAgICAgICAgICAgICAgIC4uIGBvblJlbmRlcmAgaXMgYWx3YXlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAuLiBgdGhpc2AgaXMgYWx3YXlzIHJldHVybmVkLlxuICAgICAgICAqL1xuICAgICAgICBwcm90b1Byb3BzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlbmRlckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgb3JpZ2luYWwgcmVuZGVyIG1ldGhvZC5cbiAgICAgICAgICAgICAgICByZW5kZXJGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXIuX19yZW5kZXJfXyA9PT0gcmVuZGVyRm4pIHtcbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYWx3YXlzIGNhbGwgb25SZW5kZXIoKSBtZXRob2QuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGNhbGwgaXQgb25seSBvbmNlIHdoZW4gcmVuZGVyRm4gaXMgYWN0dWFsIHByb3RvdHlwZSBtZXRob2QgaS5lLiBub3QgdGhlIHdyYXBwZXJcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHByb3RvUHJvcHMucmVuZGVyLl9fcmVuZGVyX18gPSByZW5kZXJGbjtcblxuICAgICAgICByZXR1cm4gVmlld0Jhc2UuZXh0ZW5kLmNhbGwodGhpcywgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/ViewBase.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/ViewBase.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ViewBase: () => (/* binding */ ViewBase)\n/* harmony export */ });\n/* harmony import */ var _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mvcUtils.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n\n\n// ViewBase\n// -------------\n\n// ViewBases are almost more convention than they are actual code. A View\n// is simply a JavaScript object that represents a logical chunk of UI in the\n// DOM. This might be a single item, an entire list, a sidebar or panel, or\n// even the surrounding frame which wraps your whole app. Defining a chunk of\n// UI as a **View** allows you to define your DOM events declaratively, without\n// having to worry about render order ... and makes it easy for the view to\n// react to specific changes in the state of your models.\n\n// Creating a ViewBase creates its initial element outside of the DOM,\n// if an existing element is not provided...\nvar ViewBase = function(options) {\n    this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('view');\n    this.preinitialize.apply(this, arguments);\n    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(this, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.pick)(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n};\n\n// Cached regex to split keys for `delegate`.\nvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n// List of view options to be set as properties.\n// TODO: `style` attribute is not supported in ViewBase class yet, but only in View class that extends ViewBase.\nvar viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events', 'style'];\n\n// Set up all inheritable **ViewBase** properties and methods.\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(ViewBase.prototype, _Events_mjs__WEBPACK_IMPORTED_MODULE_1__.Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // mvc.$ delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n        return this.$el.find(selector);\n    },\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the View\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n        return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Events listeners.\n    remove: function() {\n        this._removeElement();\n        this.stopListening();\n        return this;\n    },\n\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function() {\n        this.$el.remove();\n    },\n\n    // Change the view's element (`this.el` property) and re-delegate the\n    // view's events on the new element.\n    setElement: function(element) {\n        this.undelegateEvents();\n        this._setElement(element);\n        this.delegateEvents();\n        return this;\n    },\n\n    // Creates the `this.el` and `this.$el` references for this view using the\n    // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$\n    // context or an element. Subclasses can override this to utilize an\n    // alternative DOM manipulation API and are only required to set the\n    // `this.el` property.\n    _setElement: function(el) {\n        this.$el = el instanceof _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? el : (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el);\n        this.el = this.$el[0];\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    delegateEvents: function(events) {\n        events || (events = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'events'));\n        if (!events) return this;\n        this.undelegateEvents();\n        for (var key in events) {\n            var method = events[key];\n            if (!(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(method)) method = this[method];\n            if (!method) continue;\n            var match = key.match(delegateEventSplitter);\n            this.delegate(match[1], match[2], method.bind(this));\n        }\n        return this;\n    },\n\n    // Add a single event listener to the view's element (or a child element\n    // using `selector`). This only works for delegate-able events: not `focus`,\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n    delegate: function(eventName, selector, listener) {\n        this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n        return this;\n    },\n\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // viewbases attached to the same DOM element.\n    undelegateEvents: function() {\n        if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n        return this;\n    },\n\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\n    // `selector` and `listener` are both optional.\n    undelegate: function(eventName, selector, listener) {\n        this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n        return this;\n    },\n\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function(tagName) {\n        return document.createElement(tagName);\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n        if (!this.el) {\n            var attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'attributes'));\n            if (this.id) attrs.id = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'id');\n            if (this.className) attrs['class'] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'className');\n            this.setElement(this._createElement((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'tagName')));\n            this._setAttributes(attrs);\n        } else {\n            this.setElement((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'el'));\n        }\n    },\n\n    // Set attributes from a hash on this view's element.  Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _setAttributes: function(attributes) {\n        this.$el.attr(attributes);\n    }\n\n});\n\n// Set up inheritance for the view.\nViewBase.extend = _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__.extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9WaWV3QmFzZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0M7O0FBRU07QUFDRTtBQU9kOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQLGVBQWUsd0RBQVE7QUFDdkI7QUFDQSxJQUFJLHNEQUFNLE9BQU8sb0RBQUk7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQU0scUJBQXFCLCtDQUFNOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBQyxRQUFRLDBEQUFDO0FBQzNDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNEQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFNLEdBQUcsRUFBRSxzREFBTTtBQUN6QyxvQ0FBb0Msc0RBQU07QUFDMUMsaURBQWlELHNEQUFNO0FBQ3ZELGdEQUFnRCxzREFBTTtBQUN0RDtBQUNBLFVBQVU7QUFDViw0QkFBNEIsc0RBQU07QUFDbEM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBLGtCQUFrQixpREFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9WaWV3QmFzZS5tanM/NzU2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICcuL0RvbS9pbmRleC5tanMnO1xuXG5pbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL0V2ZW50cy5tanMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi9tdmNVdGlscy5tanMnO1xuaW1wb3J0IHtcbiAgICBhc3NpZ24sXG4gICAgaXNGdW5jdGlvbixcbiAgICBwaWNrLFxuICAgIHJlc3VsdCxcbiAgICB1bmlxdWVJZFxufSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcblxuLy8gVmlld0Jhc2Vcbi8vIC0tLS0tLS0tLS0tLS1cblxuLy8gVmlld0Jhc2VzIGFyZSBhbG1vc3QgbW9yZSBjb252ZW50aW9uIHRoYW4gdGhleSBhcmUgYWN0dWFsIGNvZGUuIEEgVmlld1xuLy8gaXMgc2ltcGx5IGEgSmF2YVNjcmlwdCBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgbG9naWNhbCBjaHVuayBvZiBVSSBpbiB0aGVcbi8vIERPTS4gVGhpcyBtaWdodCBiZSBhIHNpbmdsZSBpdGVtLCBhbiBlbnRpcmUgbGlzdCwgYSBzaWRlYmFyIG9yIHBhbmVsLCBvclxuLy8gZXZlbiB0aGUgc3Vycm91bmRpbmcgZnJhbWUgd2hpY2ggd3JhcHMgeW91ciB3aG9sZSBhcHAuIERlZmluaW5nIGEgY2h1bmsgb2Zcbi8vIFVJIGFzIGEgKipWaWV3KiogYWxsb3dzIHlvdSB0byBkZWZpbmUgeW91ciBET00gZXZlbnRzIGRlY2xhcmF0aXZlbHksIHdpdGhvdXRcbi8vIGhhdmluZyB0byB3b3JyeSBhYm91dCByZW5kZXIgb3JkZXIgLi4uIGFuZCBtYWtlcyBpdCBlYXN5IGZvciB0aGUgdmlldyB0b1xuLy8gcmVhY3QgdG8gc3BlY2lmaWMgY2hhbmdlcyBpbiB0aGUgc3RhdGUgb2YgeW91ciBtb2RlbHMuXG5cbi8vIENyZWF0aW5nIGEgVmlld0Jhc2UgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbi8vIGlmIGFuIGV4aXN0aW5nIGVsZW1lbnQgaXMgbm90IHByb3ZpZGVkLi4uXG5leHBvcnQgdmFyIFZpZXdCYXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuY2lkID0gdW5pcXVlSWQoJ3ZpZXcnKTtcbiAgICB0aGlzLnByZWluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBhc3NpZ24odGhpcywgcGljayhvcHRpb25zLCB2aWV3T3B0aW9ucykpO1xuICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8vIENhY2hlZCByZWdleCB0byBzcGxpdCBrZXlzIGZvciBgZGVsZWdhdGVgLlxudmFyIGRlbGVnYXRlRXZlbnRTcGxpdHRlciA9IC9eKFxcUyspXFxzKiguKikkLztcblxuLy8gTGlzdCBvZiB2aWV3IG9wdGlvbnMgdG8gYmUgc2V0IGFzIHByb3BlcnRpZXMuXG4vLyBUT0RPOiBgc3R5bGVgIGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIGluIFZpZXdCYXNlIGNsYXNzIHlldCwgYnV0IG9ubHkgaW4gVmlldyBjbGFzcyB0aGF0IGV4dGVuZHMgVmlld0Jhc2UuXG52YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnLCAnc3R5bGUnXTtcblxuLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKlZpZXdCYXNlKiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbmFzc2lnbihWaWV3QmFzZS5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgYHRhZ05hbWVgIG9mIGEgVmlldydzIGVsZW1lbnQgaXMgYFwiZGl2XCJgLlxuICAgIHRhZ05hbWU6ICdkaXYnLFxuXG4gICAgLy8gbXZjLiQgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAvLyBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcnJlZCB0byBnbG9iYWwgbG9va3VwcyB3aGVyZSBwb3NzaWJsZS5cbiAgICAkOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8vIHByZWluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gWW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIGEgZnVuY3Rpb25cbiAgICAvLyBvciBvYmplY3QuICBwcmVpbml0aWFsaXplIHdpbGwgcnVuIGJlZm9yZSBhbnkgaW5zdGFudGlhdGlvbiBsb2dpYyBpcyBydW4gaW4gdGhlIFZpZXdcbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBObyBpbXBsZW1lbnRhdGlvbi5cbiAgICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm8gaW1wbGVtZW50YXRpb24uXG4gICAgfSxcblxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxuICAgIC8vIHRvIHBvcHVsYXRlIGl0cyBlbGVtZW50IChgdGhpcy5lbGApLCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBIVE1MLiBUaGVcbiAgICAvLyBjb252ZW50aW9uIGlzIGZvciAqKnJlbmRlcioqIHRvIGFsd2F5cyByZXR1cm4gYHRoaXNgLlxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhpcyB2aWV3IGJ5IHRha2luZyB0aGUgZWxlbWVudCBvdXQgb2YgdGhlIERPTSwgYW5kIHJlbW92aW5nIGFueVxuICAgIC8vIGFwcGxpY2FibGUgRXZlbnRzIGxpc3RlbmVycy5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoaXMgdmlldydzIGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQgYW5kIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgICAvLyBhdHRhY2hlZCB0byBpdC4gRXhwb3NlZCBmb3Igc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET01cbiAgICAvLyBtYW5pcHVsYXRpb24gQVBJLlxuICAgIF9yZW1vdmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgfSxcblxuICAgIC8vIENoYW5nZSB0aGUgdmlldydzIGVsZW1lbnQgKGB0aGlzLmVsYCBwcm9wZXJ0eSkgYW5kIHJlLWRlbGVnYXRlIHRoZVxuICAgIC8vIHZpZXcncyBldmVudHMgb24gdGhlIG5ldyBlbGVtZW50LlxuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgdGhlIGB0aGlzLmVsYCBhbmQgYHRoaXMuJGVsYCByZWZlcmVuY2VzIGZvciB0aGlzIHZpZXcgdXNpbmcgdGhlXG4gICAgLy8gZ2l2ZW4gYGVsYC4gYGVsYCBjYW4gYmUgYSBDU1Mgc2VsZWN0b3Igb3IgYW4gSFRNTCBzdHJpbmcsIGEgbXZjLiRcbiAgICAvLyBjb250ZXh0IG9yIGFuIGVsZW1lbnQuIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gdXRpbGl6ZSBhblxuICAgIC8vIGFsdGVybmF0aXZlIERPTSBtYW5pcHVsYXRpb24gQVBJIGFuZCBhcmUgb25seSByZXF1aXJlZCB0byBzZXQgdGhlXG4gICAgLy8gYHRoaXMuZWxgIHByb3BlcnR5LlxuICAgIF9zZXRFbGVtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgICB0aGlzLiRlbCA9IGVsIGluc3RhbmNlb2YgJCA/IGVsIDogJChlbCk7XG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLiRlbFswXTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGNhbGxiYWNrcywgd2hlcmUgYHRoaXMuZXZlbnRzYCBpcyBhIGhhc2ggb2ZcbiAgICAvL1xuICAgIC8vICp7XCJldmVudCBzZWxlY3RvclwiOiBcImNhbGxiYWNrXCJ9KlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAnbW91c2Vkb3duIC50aXRsZSc6ICAnZWRpdCcsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5idXR0b24nOiAgICAgJ3NhdmUnLFxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cbiAgICAvLyAgICAgfVxuICAgIC8vXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXG4gICAgLy8gVXNlcyBldmVudCBkZWxlZ2F0aW9uIGZvciBlZmZpY2llbmN5LlxuICAgIC8vIE9taXR0aW5nIHRoZSBzZWxlY3RvciBiaW5kcyB0aGUgZXZlbnQgdG8gYHRoaXMuZWxgLlxuICAgIGRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICAgICAgZXZlbnRzIHx8IChldmVudHMgPSByZXN1bHQodGhpcywgJ2V2ZW50cycpKTtcbiAgICAgICAgaWYgKCFldmVudHMpIHJldHVybiB0aGlzO1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1trZXldO1xuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKG1ldGhvZCkpIG1ldGhvZCA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgICAgIGlmICghbWV0aG9kKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZShtYXRjaFsxXSwgbWF0Y2hbMl0sIG1ldGhvZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSB2aWV3J3MgZWxlbWVudCAob3IgYSBjaGlsZCBlbGVtZW50XG4gICAgLy8gdXNpbmcgYHNlbGVjdG9yYCkuIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLFxuICAgIC8vIGBibHVyYCwgYW5kIG5vdCBgY2hhbmdlYCwgYHN1Ym1pdGAsIGFuZCBgcmVzZXRgIGluIEludGVybmV0IEV4cGxvcmVyLlxuICAgIGRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ2xlYXJzIGFsbCBjYWxsYmFja3MgcHJldmlvdXNseSBib3VuZCB0byB0aGUgdmlldyBieSBgZGVsZWdhdGVFdmVudHNgLlxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxuICAgIC8vIHZpZXdiYXNlcyBhdHRhY2hlZCB0byB0aGUgc2FtZSBET00gZWxlbWVudC5cbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsKSB0aGlzLiRlbC5vZmYoJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBIGZpbmVyLWdyYWluZWQgYHVuZGVsZWdhdGVFdmVudHNgIGZvciByZW1vdmluZyBhIHNpbmdsZSBkZWxlZ2F0ZWQgZXZlbnQuXG4gICAgLy8gYHNlbGVjdG9yYCBhbmQgYGxpc3RlbmVyYCBhcmUgYm90aCBvcHRpb25hbC5cbiAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbihldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLiRlbC5vZmYoZXZlbnROYW1lICsgJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCwgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFByb2R1Y2VzIGEgRE9NIGVsZW1lbnQgdG8gYmUgYXNzaWduZWQgdG8geW91ciB2aWV3LiBFeHBvc2VkIGZvclxuICAgIC8vIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfSxcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBWaWV3IGhhcyBhIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgIC8vIElmIGB0aGlzLmVsYCBpcyBhIHN0cmluZywgcGFzcyBpdCB0aHJvdWdoIGAkKClgLCB0YWtlIHRoZSBmaXJzdFxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcbiAgICAvLyBhbiBlbGVtZW50IGZyb20gdGhlIGBpZGAsIGBjbGFzc05hbWVgIGFuZCBgdGFnTmFtZWAgcHJvcGVydGllcy5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gYXNzaWduKHt9LCByZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pZCkgYXR0cnMuaWQgPSByZXN1bHQodGhpcywgJ2lkJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIGF0dHJzWydjbGFzcyddID0gcmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudCh0aGlzLl9jcmVhdGVFbGVtZW50KHJlc3VsdCh0aGlzLCAndGFnTmFtZScpKSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RWxlbWVudChyZXN1bHQodGhpcywgJ2VsJykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCBhdHRyaWJ1dGVzIGZyb20gYSBoYXNoIG9uIHRoaXMgdmlldydzIGVsZW1lbnQuICBFeHBvc2VkIGZvclxuICAgIC8vIHN1YmNsYXNzZXMgdXNpbmcgYW4gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX3NldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy4kZWwuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICB9XG5cbn0pO1xuXG4vLyBTZXQgdXAgaW5oZXJpdGFuY2UgZm9yIHRoZSB2aWV3LlxuVmlld0Jhc2UuZXh0ZW5kID0gZXh0ZW5kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* reexport safe */ _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   Collection: () => (/* reexport safe */ _Collection_mjs__WEBPACK_IMPORTED_MODULE_3__.Collection),\n/* harmony export */   Data: () => (/* reexport safe */ _Data_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   Event: () => (/* reexport safe */ _Dom_Event_mjs__WEBPACK_IMPORTED_MODULE_8__.Event),\n/* harmony export */   Events: () => (/* reexport safe */ _Events_mjs__WEBPACK_IMPORTED_MODULE_2__.Events),\n/* harmony export */   Listener: () => (/* reexport safe */ _Listener_mjs__WEBPACK_IMPORTED_MODULE_1__.Listener),\n/* harmony export */   Model: () => (/* reexport safe */ _Model_mjs__WEBPACK_IMPORTED_MODULE_4__.Model),\n/* harmony export */   View: () => (/* reexport safe */ _View_mjs__WEBPACK_IMPORTED_MODULE_0__.View),\n/* harmony export */   ViewBase: () => (/* reexport safe */ _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_5__.ViewBase),\n/* harmony export */   views: () => (/* reexport safe */ _View_mjs__WEBPACK_IMPORTED_MODULE_0__.views)\n/* harmony export */ });\n/* harmony import */ var _View_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _Listener_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Listener.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Listener.mjs\");\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Events.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _Collection_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Collection.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Collection.mjs\");\n/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Model.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewBase.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\");\n/* harmony import */ var _Data_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Data.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Data.mjs\");\n/* harmony import */ var _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _Dom_Event_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Dom/Event.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEyQjtBQUNJO0FBQ0Y7QUFDSTtBQUNMO0FBQ0c7QUFDYztBQUNFO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvaW5kZXgubWpzPzMyMmQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9WaWV3Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0xpc3RlbmVyLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0V2ZW50cy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9Db2xsZWN0aW9uLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL01vZGVsLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL1ZpZXdCYXNlLm1qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIERhdGEgfSBmcm9tICcuL0RhdGEubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgJCB9IGZyb20gJy4vRG9tL2luZGV4Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0RvbS9FdmVudC5tanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/mvcUtils.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMethodsUtil: () => (/* binding */ addMethodsUtil),\n/* harmony export */   extend: () => (/* binding */ extend)\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/utilHelpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n// Helpers\n// -------\n\n// Helper function to correctly set up the prototype chain for subclasses.\n// Similar to `goog.inherits`, but uses a hash of prototype properties and\n// class properties to be extended.\nvar extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent constructor.\n    if (protoProps && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.has)(protoProps, 'constructor')) {\n        child = protoProps.constructor;\n    } else {\n        child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function and add the prototype properties.\n    child.prototype = Object.assign(Object.create(parent.prototype), protoProps);\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n};\n\n// Proxy class methods to functions, wrapping the model's\n// `attributes` object or collection's `models` array behind the scenes.\n//\n// `Function#apply` can be slow so we use the method's arg count, if we know it.\nvar addMethod = function(base, length, method, attribute) {\n    switch (length) {\n        case 1: return function() {\n            return base[method](this[attribute]);\n        };\n        case 2: return function(value) {\n            return base[method](this[attribute], value);\n        };\n        case 3: return function(iteratee, context) {\n            return base[method](this[attribute], cb(iteratee, this), context);\n        };\n        case 4: return function(iteratee, defaultVal, context) {\n            return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n        };\n        default: return function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(this[attribute]);\n            return base[method].apply(base, args);\n        };\n    }\n};\n\nvar addMethodsUtil = function(Class, base, methods, attribute) {\n    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.forIn)(methods, function(length, method) {\n        if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n    });\n};\n\n// Support `collection.sortBy('attr')`.\nvar cb = function(iteratee, instance) {\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(iteratee)) return iteratee;\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n};\n\nvar modelMatcher = function(attrs) {\n    var matcher = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.matches)(attrs);\n    return function(model) {\n        return matcher(model.attributes);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9tdmNVdGlscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTzBCO0FBQ3dCOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQUc7QUFDekI7QUFDQSxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0EsSUFBSSxzREFBTTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLElBQUkscURBQUs7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsUUFBUSwwREFBVTtBQUNsQixRQUFRLHdEQUFRO0FBQ2hCLFFBQVEsd0RBQVEscUNBQXFDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdURBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvbXZjVXRpbHMubWpzPzVmMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBhc3NpZ24sXG4gICAgZm9ySW4sXG4gICAgaGFzLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNPYmplY3QsXG4gICAgaXNTdHJpbmdcbn0gZnJvbSAnLi4vdXRpbC91dGlsLm1qcyc7XG5pbXBvcnQgeyBtYXRjaGVzIH0gZnJvbSAnLi4vdXRpbC91dGlsSGVscGVycy5tanMnO1xuXG4vLyBIZWxwZXJzXG4vLyAtLS0tLS0tXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4gZm9yIHN1YmNsYXNzZXMuXG4vLyBTaW1pbGFyIHRvIGBnb29nLmluaGVyaXRzYCwgYnV0IHVzZXMgYSBoYXNoIG9mIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFuZFxuLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cbmV4cG9ydCB2YXIgZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICB2YXIgY2hpbGQ7XG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG4gICAgLy8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG4gICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3Rvci5cbiAgICBpZiAocHJvdG9Qcm9wcyAmJiBoYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgICAgY2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICAgIH1cblxuICAgIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICAgIGFzc2lnbihjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XG5cbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBpbmhlcml0IGZyb20gYHBhcmVudGAsIHdpdGhvdXQgY2FsbGluZ1xuICAgIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24gYW5kIGFkZCB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpLCBwcm90b1Byb3BzKTtcbiAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpcyBuZWVkZWRcbiAgICAvLyBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xufTtcblxuLy8gUHJveHkgY2xhc3MgbWV0aG9kcyB0byBmdW5jdGlvbnMsIHdyYXBwaW5nIHRoZSBtb2RlbCdzXG4vLyBgYXR0cmlidXRlc2Agb2JqZWN0IG9yIGNvbGxlY3Rpb24ncyBgbW9kZWxzYCBhcnJheSBiZWhpbmQgdGhlIHNjZW5lcy5cbi8vXG4vLyBgRnVuY3Rpb24jYXBwbHlgIGNhbiBiZSBzbG93IHNvIHdlIHVzZSB0aGUgbWV0aG9kJ3MgYXJnIGNvdW50LCBpZiB3ZSBrbm93IGl0LlxudmFyIGFkZE1ldGhvZCA9IGZ1bmN0aW9uKGJhc2UsIGxlbmd0aCwgbWV0aG9kLCBhdHRyaWJ1dGUpIHtcbiAgICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVttZXRob2RdKHRoaXNbYXR0cmlidXRlXSwgY2IoaXRlcmF0ZWUsIHRoaXMpLCBjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oaXRlcmF0ZWUsIGRlZmF1bHRWYWwsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCBjYihpdGVyYXRlZSwgdGhpcyksIGRlZmF1bHRWYWwsIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQodGhpc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0uYXBwbHkoYmFzZSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IHZhciBhZGRNZXRob2RzVXRpbCA9IGZ1bmN0aW9uKENsYXNzLCBiYXNlLCBtZXRob2RzLCBhdHRyaWJ1dGUpIHtcbiAgICBmb3JJbihtZXRob2RzLCBmdW5jdGlvbihsZW5ndGgsIG1ldGhvZCkge1xuICAgICAgICBpZiAoYmFzZVttZXRob2RdKSBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGFkZE1ldGhvZChiYXNlLCBsZW5ndGgsIG1ldGhvZCwgYXR0cmlidXRlKTtcbiAgICB9KTtcbn07XG5cbi8vIFN1cHBvcnQgYGNvbGxlY3Rpb24uc29ydEJ5KCdhdHRyJylgLlxudmFyIGNiID0gZnVuY3Rpb24oaXRlcmF0ZWUsIGluc3RhbmNlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oaXRlcmF0ZWUpKSByZXR1cm4gaXRlcmF0ZWU7XG4gICAgaWYgKGlzT2JqZWN0KGl0ZXJhdGVlKSAmJiAhaW5zdGFuY2UuX2lzTW9kZWwoaXRlcmF0ZWUpKSByZXR1cm4gbW9kZWxNYXRjaGVyKGl0ZXJhdGVlKTtcbiAgICBpZiAoaXNTdHJpbmcoaXRlcmF0ZWUpKSByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLmdldChpdGVyYXRlZSk7IH07XG4gICAgcmV0dXJuIGl0ZXJhdGVlO1xufTtcblxudmFyIG1vZGVsTWF0Y2hlciA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVzKGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXIobW9kZWwuYXR0cmlidXRlcyk7XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattan: () => (/* reexport safe */ _manhattan_mjs__WEBPACK_IMPORTED_MODULE_3__.manhattan),\n/* harmony export */   metro: () => (/* reexport safe */ _metro_mjs__WEBPACK_IMPORTED_MODULE_4__.metro),\n/* harmony export */   normal: () => (/* reexport safe */ _normal_mjs__WEBPACK_IMPORTED_MODULE_0__.normal),\n/* harmony export */   oneSide: () => (/* reexport safe */ _oneSide_mjs__WEBPACK_IMPORTED_MODULE_1__.oneSide),\n/* harmony export */   orthogonal: () => (/* reexport safe */ _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_2__.orthogonal),\n/* harmony export */   rightAngle: () => (/* reexport safe */ _rightAngle_mjs__WEBPACK_IMPORTED_MODULE_5__.rightAngle)\n/* harmony export */ });\n/* harmony import */ var _normal_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/normal.mjs\");\n/* harmony import */ var _oneSide_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./oneSide.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/oneSide.mjs\");\n/* harmony import */ var _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orthogonal.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/orthogonal.mjs\");\n/* harmony import */ var _manhattan_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manhattan.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/manhattan.mjs\");\n/* harmony import */ var _metro_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./metro.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/metro.mjs\");\n/* harmony import */ var _rightAngle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rightAngle.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/rightAngle.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNDO0FBQ0c7QUFDRDtBQUNKO0FBQ0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9yb3V0ZXJzL2luZGV4Lm1qcz9iYWZmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vbm9ybWFsLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL29uZVNpZGUubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vb3J0aG9nb25hbC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9tYW5oYXR0YW4ubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vbWV0cm8ubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcmlnaHRBbmdsZS5tanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/manhattan.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/manhattan.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattan: () => (/* binding */ manhattan)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orthogonal.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/orthogonal.mjs\");\n\n\n\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: [],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(_orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__.orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return (0,_orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__.orthogonal)(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(p => !isPointObstacle(p));\n    endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for (var j = 0; j < startPoints.length; j++) {\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'directions');\n    opt.penalties = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'penalties');\n    opt.paddingBox = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'paddingBox');\n    opt.padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(0, 0);\n        var point2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === 'function') {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point) => !map.isPointAccessible(point);\n    }\n\n    var oldVertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(vertices).map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nconst manhattan = function(vertices, opt, linkView) {\n    return router(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, config, opt), linkView);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvbWFuaGF0dGFuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUNNO0FBQ0k7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsaUJBQWlCLFlBQVk7QUFDN0Isa0JBQWtCLFlBQVk7QUFDOUIsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVDQUF1QztBQUNyRCxjQUFjLHdDQUF3QztBQUN0RCxjQUFjLHVDQUF1QztBQUNyRCxjQUFjO0FBQ2Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLHVEQUFlLENBQUMsdURBQVU7QUFDdkM7QUFDQTs7QUFFQSxlQUFlLDJEQUFVLFdBQVcsbURBQVcsR0FBRztBQUNsRCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLEtBQUs7O0FBRUw7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixvREFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixrREFBVTtBQUN0QztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGtEQUFVO0FBQ3RDO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkIsb0RBQVk7QUFDekM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUMsZUFBZTtBQUNsRCx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxvREFBWTtBQUN2QjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLHdEQUFnQjtBQUNoQztBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFnQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLCtDQUFPO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsSUFBSSxvREFBWTs7QUFFaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsb0RBQVk7QUFDL0IsbUJBQW1CLG9EQUFZOztBQUUvQixlQUFlLCtDQUFPO0FBQ3RCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0NBQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxxREFBYTtBQUM1QixrQkFBa0Isb0RBQVk7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLCtDQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4Q0FBTTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3QkFBd0IsOENBQU0sSUFBSTtBQUNsQztBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHNCQUFzQiw4Q0FBTSxJQUFJO0FBQ2hDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsb0JBQW9CO0FBQ3BCLGdDQUFnQzs7QUFFaEM7QUFDQSx3QkFBd0IsOENBQU0sSUFBSTtBQUNsQztBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsOENBQU0sSUFBSTtBQUNoQztBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzRUFBc0U7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLG9EQUFZO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0VBQWtFO0FBQ2xFLHNEQUFzRDs7QUFFdEQ7QUFDQSxzSUFBc0k7QUFDdEksNkZBQTZGO0FBQzdGLDBIQUEwSDtBQUMxSCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEOztBQUUvRCxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvRkFBb0Y7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsbURBQVc7QUFDaEMsb0JBQW9CLG1EQUFXO0FBQy9CLHFCQUFxQixtREFBVztBQUNoQyxrQkFBa0IsbURBQVc7O0FBRTdCO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksb0RBQVk7O0FBRWhCLHlCQUF5QiwrQ0FBTztBQUNoQyx5QkFBeUIsK0NBQU87O0FBRWhDLDBCQUEwQix3REFBZ0I7QUFDMUMsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG9EQUFZLGVBQWUsK0NBQU87QUFDeEQ7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsVUFBVTs7QUFFeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHVEQUFlO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ087QUFDUCw0QkFBNEIsbURBQVcsR0FBRztBQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvbWFuaGF0dGFuLm1qcz80MzY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBvcnRob2dvbmFsIH0gZnJvbSAnLi9vcnRob2dvbmFsLm1qcyc7XG5cbnZhciBjb25maWcgPSB7XG5cbiAgICAvLyBzaXplIG9mIHRoZSBzdGVwIHRvIGZpbmQgYSByb3V0ZSAodGhlIGdyaWQgb2YgdGhlIG1hbmhhdHRhbiBwYXRoZmluZGVyKVxuICAgIHN0ZXA6IDEwLFxuXG4gICAgLy8gdGhlIG51bWJlciBvZiByb3V0ZSBmaW5kaW5nIGxvb3BzIHRoYXQgY2F1c2UgdGhlIHJvdXRlciB0byBhYm9ydFxuICAgIC8vIHJldHVybnMgZmFsbGJhY2sgcm91dGUgaW5zdGVhZFxuICAgIG1heGltdW1Mb29wczogMjAwMCxcblxuICAgIC8vIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgZmxvYXRpbmcgcG9pbnQgY29vcmRpbmF0ZXNcbiAgICBwcmVjaXNpb246IDEsXG5cbiAgICAvLyBtYXhpbXVtIGNoYW5nZSBvZiBkaXJlY3Rpb25cbiAgICBtYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlOiA5MCxcblxuICAgIC8vIHNob3VsZCB0aGUgcm91dGVyIHVzZSBwZXJwZW5kaWN1bGFyIGxpbmtWaWV3IG9wdGlvbj9cbiAgICAvLyBkb2VzIG5vdCBjb25uZWN0IGFuY2hvciBvZiBlbGVtZW50IGJ1dCByYXRoZXIgYSBwb2ludCBjbG9zZS1ieSB0aGF0IGlzIG9ydGhvZ29uYWxcbiAgICAvLyB0aGlzIGxvb2tzIG11Y2ggYmV0dGVyXG4gICAgcGVycGVuZGljdWxhcjogdHJ1ZSxcblxuICAgIC8vIHNob3VsZCB0aGUgc291cmNlIGFuZC9vciB0YXJnZXQgbm90IGJlIGNvbnNpZGVyZWQgYXMgb2JzdGFjbGVzP1xuICAgIGV4Y2x1ZGVFbmRzOiBbXSwgLy8gJ3NvdXJjZScsICd0YXJnZXQnXG5cbiAgICAvLyBzaG91bGQgY2VydGFpbiB0eXBlcyBvZiBlbGVtZW50cyBub3QgYmUgY29uc2lkZXJlZCBhcyBvYnN0YWNsZXM/XG4gICAgZXhjbHVkZVR5cGVzOiBbXSxcblxuICAgIC8vIHBvc3NpYmxlIHN0YXJ0aW5nIGRpcmVjdGlvbnMgZnJvbSBhbiBlbGVtZW50XG4gICAgc3RhcnREaXJlY3Rpb25zOiBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxuXG4gICAgLy8gcG9zc2libGUgZW5kaW5nIGRpcmVjdGlvbnMgdG8gYW4gZWxlbWVudFxuICAgIGVuZERpcmVjdGlvbnM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG5cbiAgICAvLyBzcGVjaWZ5IHRoZSBkaXJlY3Rpb25zIHVzZWQgYWJvdmUgYW5kIHdoYXQgdGhleSBtZWFuXG4gICAgZGlyZWN0aW9uTWFwOiB7XG4gICAgICAgIHRvcDogeyB4OiAwLCB5OiAtMSB9LFxuICAgICAgICByaWdodDogeyB4OiAxLCB5OiAwIH0sXG4gICAgICAgIGJvdHRvbTogeyB4OiAwLCB5OiAxIH0sXG4gICAgICAgIGxlZnQ6IHsgeDogLTEsIHk6IDAgfVxuICAgIH0sXG5cbiAgICAvLyBjb3N0IG9mIGFuIG9ydGhvZ29uYWwgc3RlcFxuICAgIGNvc3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXA7XG4gICAgfSxcblxuICAgIC8vIGFuIGFycmF5IG9mIGRpcmVjdGlvbnMgdG8gZmluZCBuZXh0IHBvaW50cyBvbiB0aGUgcm91dGVcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSBzdGFydC9lbmQgZGlyZWN0aW9uc1xuICAgIGRpcmVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuICAgICAgICB2YXIgY29zdCA9IHRoaXMuY29zdCgpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAsIG9mZnNldFk6IDAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAsIG9mZnNldFk6IDAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogc3RlcCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAtc3RlcCwgY29zdDogY29zdCB9XG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIC8vIGEgcGVuYWx0eSByZWNlaXZlZCBmb3IgZGlyZWN0aW9uIGNoYW5nZVxuICAgIHBlbmFsdGllczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIDA6IDAsXG4gICAgICAgICAgICA0NTogdGhpcy5zdGVwIC8gMixcbiAgICAgICAgICAgIDkwOiB0aGlzLnN0ZXAgLyAyXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIHBhZGRpbmcgYXBwbGllZCBvbiB0aGUgZWxlbWVudCBib3VuZGluZyBib3hlc1xuICAgIHBhZGRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5zdGVwO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiAtc3RlcCxcbiAgICAgICAgICAgIHk6IC1zdGVwLFxuICAgICAgICAgICAgd2lkdGg6IDIgKiBzdGVwLFxuICAgICAgICAgICAgaGVpZ2h0OiAyICogc3RlcFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIGEgZ2l2ZW4gcG9pbnQgaXMgYW4gb2JzdGFjbGUgb3Igbm90LlxuICAgIC8vIElmIHVzZWQsIHRoZSBgcGFkZGluZ2AsIGBleGNsdWRlRW5kc2BhbmQgYGV4Y2x1ZGVUeXBlc2Agb3B0aW9ucyBhcmUgaWdub3JlZC5cbiAgICAvLyAocG9pbnQ6IGRpYS5Qb2ludCkgPT4gYm9vbGVhbjtcbiAgICBpc1BvaW50T2JzdGFjbGU6IG51bGwsXG5cbiAgICAvLyBhIHJvdXRlciB0byB1c2Ugd2hlbiB0aGUgbWFuaGF0dGFuIHJvdXRlciBmYWlsc1xuICAgIC8vIChvbmUgb2YgdGhlIHBhcnRpYWwgcm91dGVzIHJldHVybnMgbnVsbClcbiAgICBmYWxsYmFja1JvdXRlcjogZnVuY3Rpb24odmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgICAgICBpZiAoIXV0aWwuaXNGdW5jdGlvbihvcnRob2dvbmFsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYW5oYXR0YW4gcmVxdWlyZXMgdGhlIG9ydGhvZ29uYWwgcm91dGVyIGFzIGRlZmF1bHQgZmFsbGJhY2suJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3J0aG9nb25hbCh2ZXJ0aWNlcywgdXRpbC5hc3NpZ24oe30sIGNvbmZpZywgb3B0KSwgbGlua1ZpZXcpO1xuICAgIH0sXG5cbiAgICAvKiBEZXByZWNhdGVkICovXG4gICAgLy8gYSBzaW1wbGUgcm91dGUgdXNlZCBpbiBzaXR1YXRpb25zIHdoZW4gbWFpbiByb3V0aW5nIG1ldGhvZCBmYWlsc1xuICAgIC8vIChleGNlZWQgbWF4IG51bWJlciBvZiBsb29wIGl0ZXJhdGlvbnMsIGluYWNjZXNzaWJsZSlcbiAgICBmYWxsYmFja1JvdXRlOiBmdW5jdGlvbihmcm9tLCB0bywgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIG51bGwgcmVzdWx0IHdpbGwgdHJpZ2dlciB0aGUgZmFsbGJhY2tSb3V0ZXJcblxuICAgICAgICAvLyBsZWZ0IGZvciByZWZlcmVuY2U6XG4gICAgICAgIC8qLy8gRmluZCBhbiBvcnRob2dvbmFsIHJvdXRlIGlnbm9yaW5nIG9ic3RhY2xlcy5cblxuICAgICAgICB2YXIgcG9pbnQgPSAoKG9wdC5wcmV2aW91c0RpckFuZ2xlIHx8IDApICUgMTgwID09PSAwKVxuICAgICAgICAgICAgICAgID8gbmV3IGcuUG9pbnQoZnJvbS54LCB0by55KVxuICAgICAgICAgICAgICAgIDogbmV3IGcuUG9pbnQodG8ueCwgZnJvbS55KTtcblxuICAgICAgICByZXR1cm4gW3BvaW50XTsqL1xuICAgIH0sXG5cbiAgICAvLyBpZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCdzIHVzZWQgdG8gcm91dGUgdGhlIGxpbmsgd2hpbGUgZHJhZ2dpbmcgYW4gZW5kXG4gICAgLy8gaS5lLiBmdW5jdGlvbihmcm9tLCB0bywgb3B0KSB7IHJldHVybiBbXTsgfVxuICAgIGRyYWdnaW5nUm91dGU6IG51bGxcbn07XG5cbi8vIEhFTFBFUiBDTEFTU0VTIC8vXG5cbi8vIE1hcCBvZiBvYnN0YWNsZXNcbi8vIEhlbHBlciBzdHJ1Y3R1cmUgdG8gaWRlbnRpZnkgd2hldGhlciBhIHBvaW50IGxpZXMgaW5zaWRlIGFuIG9ic3RhY2xlLlxuZnVuY3Rpb24gT2JzdGFjbGVNYXAob3B0KSB7XG5cbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdDtcbiAgICAvLyB0ZWxscyBob3cgdG8gZGl2aWRlIHRoZSBwYXBlciB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50cyBtYXBcbiAgICB0aGlzLm1hcEdyaWRTaXplID0gMTAwO1xufVxuXG5PYnN0YWNsZU1hcC5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihncmFwaCwgbGluaykge1xuXG4gICAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAgIC8vIHNvdXJjZSBvciB0YXJnZXQgZWxlbWVudCBjb3VsZCBiZSBleGNsdWRlZCBmcm9tIHNldCBvZiBvYnN0YWNsZXNcbiAgICB2YXIgZXhjbHVkZWRFbmRzID0gdXRpbC50b0FycmF5KG9wdC5leGNsdWRlRW5kcykucmVkdWNlKGZ1bmN0aW9uKHJlcywgaXRlbSkge1xuXG4gICAgICAgIHZhciBlbmQgPSBsaW5rLmdldChpdGVtKTtcbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBncmFwaC5nZXRDZWxsKGVuZC5pZCk7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBFeGNsdWRlIGFueSBlbWJlZGRlZCBlbGVtZW50cyBmcm9tIHRoZSBzb3VyY2UgYW5kIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICB2YXIgZXhjbHVkZWRBbmNlc3RvcnMgPSBbXTtcblxuICAgIHZhciBzb3VyY2UgPSBncmFwaC5nZXRDZWxsKGxpbmsuZ2V0KCdzb3VyY2UnKS5pZCk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBleGNsdWRlZEFuY2VzdG9ycyA9IHV0aWwudW5pb24oZXhjbHVkZWRBbmNlc3RvcnMsIHNvdXJjZS5nZXRBbmNlc3RvcnMoKS5tYXAoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuaWQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ3JhcGguZ2V0Q2VsbChsaW5rLmdldCgndGFyZ2V0JykuaWQpO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgZXhjbHVkZWRBbmNlc3RvcnMgPSB1dGlsLnVuaW9uKGV4Y2x1ZGVkQW5jZXN0b3JzLCB0YXJnZXQuZ2V0QW5jZXN0b3JzKCkubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmlkO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGRzIGEgbWFwIG9mIGFsbCBlbGVtZW50cyBmb3IgcXVpY2tlciBvYnN0YWNsZSBxdWVyaWVzIChpLmUuIGlzIGEgcG9pbnQgY29udGFpbmVkXG4gICAgLy8gaW4gYW55IG9ic3RhY2xlPykgKGEgc2ltcGxpZmllZCBncmlkIHNlYXJjaCkuXG4gICAgLy8gVGhlIHBhcGVyIGlzIGRpdmlkZWQgaW50byBzbWFsbGVyIGNlbGxzLCB3aGVyZSBlYWNoIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IHdoaWNoXG4gICAgLy8gZWxlbWVudHMgYmVsb25nIHRvIGl0LiBXaGVuIHdlIHF1ZXJ5IHdoZXRoZXIgYSBwb2ludCBsaWVzIGluc2lkZSBhbiBvYnN0YWNsZSB3ZVxuICAgIC8vIGRvbid0IG5lZWQgdG8gZ28gdGhyb3VnaCBhbGwgb2JzdGFjbGVzLCB3ZSBjaGVjayBvbmx5IHRob3NlIGluIGEgcGFydGljdWxhciBjZWxsLlxuICAgIHZhciBtYXBHcmlkU2l6ZSA9IHRoaXMubWFwR3JpZFNpemU7XG5cbiAgICBncmFwaC5nZXRFbGVtZW50cygpLnJlZHVjZShmdW5jdGlvbihtYXAsIGVsZW1lbnQpIHtcblxuICAgICAgICB2YXIgaXNFeGNsdWRlZFR5cGUgPSB1dGlsLnRvQXJyYXkob3B0LmV4Y2x1ZGVUeXBlcykuaW5jbHVkZXMoZWxlbWVudC5nZXQoJ3R5cGUnKSk7XG4gICAgICAgIHZhciBpc0V4Y2x1ZGVkRW5kID0gZXhjbHVkZWRFbmRzLmZpbmQoZnVuY3Rpb24oZXhjbHVkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5pZCA9PT0gZWxlbWVudC5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0V4Y2x1ZGVkQW5jZXN0b3IgPSBleGNsdWRlZEFuY2VzdG9ycy5pbmNsdWRlcyhlbGVtZW50LmlkKTtcblxuICAgICAgICB2YXIgaXNFeGNsdWRlZCA9IGlzRXhjbHVkZWRUeXBlIHx8IGlzRXhjbHVkZWRFbmQgfHwgaXNFeGNsdWRlZEFuY2VzdG9yO1xuICAgICAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gZWxlbWVudC5nZXRCQm94KCkubW92ZUFuZEV4cGFuZChvcHQucGFkZGluZ0JveCk7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBiYm94Lm9yaWdpbigpLnNuYXBUb0dyaWQobWFwR3JpZFNpemUpO1xuICAgICAgICAgICAgdmFyIGNvcm5lciA9IGJib3guY29ybmVyKCkuc25hcFRvR3JpZChtYXBHcmlkU2l6ZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHggPSBvcmlnaW4ueDsgeCA8PSBjb3JuZXIueDsgeCArPSBtYXBHcmlkU2l6ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSBvcmlnaW4ueTsgeSA8PSBjb3JuZXIueTsgeSArPSBtYXBHcmlkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JpZEtleSA9IHggKyAnQCcgKyB5O1xuICAgICAgICAgICAgICAgICAgICBtYXBbZ3JpZEtleV0gPSBtYXBbZ3JpZEtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIG1hcFtncmlkS2V5XS5wdXNoKGJib3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgdGhpcy5tYXApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYnN0YWNsZU1hcC5wcm90b3R5cGUuaXNQb2ludEFjY2Vzc2libGUgPSBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgdmFyIG1hcEtleSA9IHBvaW50LmNsb25lKCkuc25hcFRvR3JpZCh0aGlzLm1hcEdyaWRTaXplKS50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIHV0aWwudG9BcnJheSh0aGlzLm1hcFttYXBLZXldKS5ldmVyeShmdW5jdGlvbihvYnN0YWNsZSkge1xuICAgICAgICByZXR1cm4gIW9ic3RhY2xlLmNvbnRhaW5zUG9pbnQocG9pbnQpO1xuICAgIH0pO1xufTtcblxuLy8gU29ydGVkIFNldFxuLy8gU2V0IG9mIGl0ZW1zIHNvcnRlZCBieSBnaXZlbiB2YWx1ZS5cbmZ1bmN0aW9uIFNvcnRlZFNldCgpIHtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgdGhpcy5oYXNoID0ge307XG4gICAgdGhpcy52YWx1ZXMgPSB7fTtcbiAgICB0aGlzLk9QRU4gPSAxO1xuICAgIHRoaXMuQ0xPU0UgPSAyO1xufVxuXG5Tb3J0ZWRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cbiAgICBpZiAodGhpcy5oYXNoW2l0ZW1dKSB7XG4gICAgICAgIC8vIGl0ZW0gcmVtb3ZhbFxuICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFzaFtpdGVtXSA9IHRoaXMuT1BFTjtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlc1tpdGVtXSA9IHZhbHVlO1xuXG4gICAgdmFyIGluZGV4ID0gdXRpbC5zb3J0ZWRJbmRleCh0aGlzLml0ZW1zLCBpdGVtLCBmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xufTtcblxuU29ydGVkU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgICB0aGlzLmhhc2hbaXRlbV0gPSB0aGlzLkNMT1NFO1xufTtcblxuU29ydGVkU2V0LnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgICByZXR1cm4gdGhpcy5oYXNoW2l0ZW1dID09PSB0aGlzLk9QRU47XG59O1xuXG5Tb3J0ZWRTZXQucHJvdG90eXBlLmlzQ2xvc2UgPSBmdW5jdGlvbihpdGVtKSB7XG5cbiAgICByZXR1cm4gdGhpcy5oYXNoW2l0ZW1dID09PSB0aGlzLkNMT1NFO1xufTtcblxuU29ydGVkU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPT09IDA7XG59O1xuXG5Tb3J0ZWRTZXQucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgcmV0dXJuIGl0ZW07XG59O1xuXG4vLyBIRUxQRVJTIC8vXG5cbi8vIHJldHVybiBzb3VyY2UgYmJveFxuZnVuY3Rpb24gZ2V0U291cmNlQkJveChsaW5rVmlldywgb3B0KSB7XG5cbiAgICAvLyBleHBhbmQgYnkgcGFkZGluZyBib3hcbiAgICBpZiAob3B0ICYmIG9wdC5wYWRkaW5nQm94KSByZXR1cm4gbGlua1ZpZXcuc291cmNlQkJveC5jbG9uZSgpLm1vdmVBbmRFeHBhbmQob3B0LnBhZGRpbmdCb3gpO1xuXG4gICAgcmV0dXJuIGxpbmtWaWV3LnNvdXJjZUJCb3guY2xvbmUoKTtcbn1cblxuLy8gcmV0dXJuIHRhcmdldCBiYm94XG5mdW5jdGlvbiBnZXRUYXJnZXRCQm94KGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIC8vIGV4cGFuZCBieSBwYWRkaW5nIGJveFxuICAgIGlmIChvcHQgJiYgb3B0LnBhZGRpbmdCb3gpIHJldHVybiBsaW5rVmlldy50YXJnZXRCQm94LmNsb25lKCkubW92ZUFuZEV4cGFuZChvcHQucGFkZGluZ0JveCk7XG5cbiAgICByZXR1cm4gbGlua1ZpZXcudGFyZ2V0QkJveC5jbG9uZSgpO1xufVxuXG4vLyByZXR1cm4gc291cmNlIGFuY2hvclxuZnVuY3Rpb24gZ2V0U291cmNlQW5jaG9yKGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIGlmIChsaW5rVmlldy5zb3VyY2VBbmNob3IpIHJldHVybiBsaW5rVmlldy5zb3VyY2VBbmNob3I7XG5cbiAgICAvLyBmYWxsYmFjazogY2VudGVyIG9mIGJib3hcbiAgICB2YXIgc291cmNlQkJveCA9IGdldFNvdXJjZUJCb3gobGlua1ZpZXcsIG9wdCk7XG4gICAgcmV0dXJuIHNvdXJjZUJCb3guY2VudGVyKCk7XG59XG5cbi8vIHJldHVybiB0YXJnZXQgYW5jaG9yXG5mdW5jdGlvbiBnZXRUYXJnZXRBbmNob3IobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgaWYgKGxpbmtWaWV3LnRhcmdldEFuY2hvcikgcmV0dXJuIGxpbmtWaWV3LnRhcmdldEFuY2hvcjtcblxuICAgIC8vIGZhbGxiYWNrOiBjZW50ZXIgb2YgYmJveFxuICAgIHZhciB0YXJnZXRCQm94ID0gZ2V0VGFyZ2V0QkJveChsaW5rVmlldywgb3B0KTtcbiAgICByZXR1cm4gdGFyZ2V0QkJveC5jZW50ZXIoKTsgLy8gZGVmYXVsdFxufVxuXG4vLyByZXR1cm5zIGEgZGlyZWN0aW9uIGluZGV4IGZyb20gc3RhcnQgcG9pbnQgdG8gZW5kIHBvaW50XG4vLyBjb3JyZWN0cyBmb3IgZ3JpZCBkZWZvcm1hdGlvbiBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcbmZ1bmN0aW9uIGdldERpcmVjdGlvbkFuZ2xlKHN0YXJ0LCBlbmQsIG51bURpcmVjdGlvbnMsIGdyaWQsIG9wdCkge1xuXG4gICAgdmFyIHF1YWRyYW50ID0gMzYwIC8gbnVtRGlyZWN0aW9ucztcbiAgICB2YXIgYW5nbGVUaGV0YSA9IHN0YXJ0LnRoZXRhKGZpeEFuZ2xlRW5kKHN0YXJ0LCBlbmQsIGdyaWQsIG9wdCkpO1xuICAgIHZhciBub3JtYWxpemVkQW5nbGUgPSBnLm5vcm1hbGl6ZUFuZ2xlKGFuZ2xlVGhldGEgKyAocXVhZHJhbnQgLyAyKSk7XG4gICAgcmV0dXJuIHF1YWRyYW50ICogTWF0aC5mbG9vcihub3JtYWxpemVkQW5nbGUgLyBxdWFkcmFudCk7XG59XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0RGlyZWN0aW9uQW5nbGUoKVxuLy8gY29ycmVjdHMgZm9yIGdyaWQgZGVmb3JtYXRpb25cbi8vIChpZiBhIHBvaW50IGlzIG9uZSBncmlkIHN0ZXBzIGF3YXkgZnJvbSBhbm90aGVyIGluIGJvdGggZGltZW5zaW9ucyxcbi8vIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgNDUgZGVncmVlcyBhd2F5LCBldmVuIGlmIHRoZSByZWFsIGFuZ2xlIGlzIGRpZmZlcmVudClcbi8vIHRoaXMgY2F1c2VzIHZpc2libGUgYW5nbGUgZGlzY3JlcGFuY2llcyBpZiBgb3B0LnN0ZXBgIGlzIG11Y2ggbGFyZ2VyIHRoYW4gYHBhcGVyLmdyaWRTaXplYFxuZnVuY3Rpb24gZml4QW5nbGVFbmQoc3RhcnQsIGVuZCwgZ3JpZCwgb3B0KSB7XG5cbiAgICB2YXIgc3RlcCA9IG9wdC5zdGVwO1xuXG4gICAgdmFyIGRpZmZYID0gZW5kLnggLSBzdGFydC54O1xuICAgIHZhciBkaWZmWSA9IGVuZC55IC0gc3RhcnQueTtcblxuICAgIHZhciBncmlkU3RlcHNYID0gZGlmZlggLyBncmlkLng7XG4gICAgdmFyIGdyaWRTdGVwc1kgPSBkaWZmWSAvIGdyaWQueTtcblxuICAgIHZhciBkaXN0YW5jZVggPSBncmlkU3RlcHNYICogc3RlcDtcbiAgICB2YXIgZGlzdGFuY2VZID0gZ3JpZFN0ZXBzWSAqIHN0ZXA7XG5cbiAgICByZXR1cm4gbmV3IGcuUG9pbnQoc3RhcnQueCArIGRpc3RhbmNlWCwgc3RhcnQueSArIGRpc3RhbmNlWSk7XG59XG5cbi8vIHJldHVybiB0aGUgY2hhbmdlIGluIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBkaXJlY3Rpb24gYW5nbGVzXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25DaGFuZ2UoYW5nbGUxLCBhbmdsZTIpIHtcblxuICAgIHZhciBkaXJlY3Rpb25DaGFuZ2UgPSBNYXRoLmFicyhhbmdsZTEgLSBhbmdsZTIpO1xuICAgIHJldHVybiAoZGlyZWN0aW9uQ2hhbmdlID4gMTgwKSA/ICgzNjAgLSBkaXJlY3Rpb25DaGFuZ2UpIDogZGlyZWN0aW9uQ2hhbmdlO1xufVxuXG4vLyBmaXggZGlyZWN0aW9uIG9mZnNldHMgYWNjb3JkaW5nIHRvIGN1cnJlbnQgZ3JpZFxuZnVuY3Rpb24gZ2V0R3JpZE9mZnNldHMoZGlyZWN0aW9ucywgZ3JpZCwgb3B0KSB7XG5cbiAgICB2YXIgc3RlcCA9IG9wdC5zdGVwO1xuXG4gICAgdXRpbC50b0FycmF5KG9wdC5kaXJlY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuXG4gICAgICAgIGRpcmVjdGlvbi5ncmlkT2Zmc2V0WCA9IChkaXJlY3Rpb24ub2Zmc2V0WCAvIHN0ZXApICogZ3JpZC54O1xuICAgICAgICBkaXJlY3Rpb24uZ3JpZE9mZnNldFkgPSAoZGlyZWN0aW9uLm9mZnNldFkgLyBzdGVwKSAqIGdyaWQueTtcbiAgICB9KTtcbn1cblxuLy8gZ2V0IGdyaWQgc2l6ZSBpbiB4IGFuZCB5IGRpbWVuc2lvbnMsIGFkYXB0ZWQgdG8gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG5mdW5jdGlvbiBnZXRHcmlkKHN0ZXAsIHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZS5jbG9uZSgpLFxuICAgICAgICB4OiBnZXRHcmlkRGltZW5zaW9uKHRhcmdldC54IC0gc291cmNlLngsIHN0ZXApLFxuICAgICAgICB5OiBnZXRHcmlkRGltZW5zaW9uKHRhcmdldC55IC0gc291cmNlLnksIHN0ZXApXG4gICAgfTtcbn1cblxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBnZXRHcmlkKClcbmZ1bmN0aW9uIGdldEdyaWREaW1lbnNpb24oZGlmZiwgc3RlcCkge1xuXG4gICAgLy8gcmV0dXJuIHN0ZXAgaWYgZGlmZiA9IDBcbiAgICBpZiAoIWRpZmYpIHJldHVybiBzdGVwO1xuXG4gICAgdmFyIGFic0RpZmYgPSBNYXRoLmFicyhkaWZmKTtcbiAgICB2YXIgbnVtU3RlcHMgPSBNYXRoLnJvdW5kKGFic0RpZmYgLyBzdGVwKTtcblxuICAgIC8vIHJldHVybiBhYnNEaWZmIGlmIGxlc3MgdGhhbiBvbmUgc3RlcCBhcGFydFxuICAgIGlmICghbnVtU3RlcHMpIHJldHVybiBhYnNEaWZmO1xuXG4gICAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gY29ycmVjdGVkIHN0ZXBcbiAgICB2YXIgcm91bmRlZERpZmYgPSBudW1TdGVwcyAqIHN0ZXA7XG4gICAgdmFyIHJlbWFpbmRlciA9IGFic0RpZmYgLSByb3VuZGVkRGlmZjtcbiAgICB2YXIgc3RlcENvcnJlY3Rpb24gPSByZW1haW5kZXIgLyBudW1TdGVwcztcblxuICAgIHJldHVybiBzdGVwICsgc3RlcENvcnJlY3Rpb247XG59XG5cbi8vIHJldHVybiBhIGNsb25lIG9mIHBvaW50IHNuYXBwZWQgdG8gZ3JpZFxuZnVuY3Rpb24gc25hcFRvR3JpZChwb2ludCwgZ3JpZCkge1xuXG4gICAgdmFyIHNvdXJjZSA9IGdyaWQuc291cmNlO1xuXG4gICAgdmFyIHNuYXBwZWRYID0gZy5zbmFwVG9HcmlkKHBvaW50LnggLSBzb3VyY2UueCwgZ3JpZC54KSArIHNvdXJjZS54O1xuICAgIHZhciBzbmFwcGVkWSA9IGcuc25hcFRvR3JpZChwb2ludC55IC0gc291cmNlLnksIGdyaWQueSkgKyBzb3VyY2UueTtcblxuICAgIHJldHVybiBuZXcgZy5Qb2ludChzbmFwcGVkWCwgc25hcHBlZFkpO1xufVxuXG4vLyByb3VuZCB0aGUgcG9pbnQgdG8gb3B0LnByZWNpc2lvblxuZnVuY3Rpb24gcm91bmQocG9pbnQsIHByZWNpc2lvbikge1xuXG4gICAgcmV0dXJuIHBvaW50LnJvdW5kKHByZWNpc2lvbik7XG59XG5cbi8vIHNuYXAgdG8gZ3JpZCBhbmQgdGhlbiByb3VuZCB0aGUgcG9pbnRcbmZ1bmN0aW9uIGFsaWduKHBvaW50LCBncmlkLCBwcmVjaXNpb24pIHtcblxuICAgIHJldHVybiByb3VuZChzbmFwVG9HcmlkKHBvaW50LmNsb25lKCksIGdyaWQpLCBwcmVjaXNpb24pO1xufVxuXG4vLyByZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwb2ludFxuLy8gc3RyaW5nIGlzIHJvdW5kZWQgaW4gYm90aCBkaW1lbnNpb25zXG5mdW5jdGlvbiBnZXRLZXkocG9pbnQpIHtcblxuICAgIHJldHVybiBwb2ludC5jbG9uZSgpLnRvU3RyaW5nKCk7XG59XG5cbi8vIHJldHVybiBhIG5vcm1hbGl6ZWQgdmVjdG9yIGZyb20gZ2l2ZW4gcG9pbnRcbi8vIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb24gb2YgYSBkaWZmZXJlbmNlIG9mIHR3byBwb2ludHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvaW50KHBvaW50KSB7XG5cbiAgICByZXR1cm4gbmV3IGcuUG9pbnQoXG4gICAgICAgIHBvaW50LnggPT09IDAgPyAwIDogTWF0aC5hYnMocG9pbnQueCkgLyBwb2ludC54LFxuICAgICAgICBwb2ludC55ID09PSAwID8gMCA6IE1hdGguYWJzKHBvaW50LnkpIC8gcG9pbnQueVxuICAgICk7XG59XG5cbi8vIFBBVEhGSU5ESU5HIC8vXG5cbi8vIHJlY29uc3RydWN0cyBhIHJvdXRlIGJ5IGNvbmNhdGVuYXRpbmcgcG9pbnRzIHdpdGggdGhlaXIgcGFyZW50c1xuZnVuY3Rpb24gcmVjb25zdHJ1Y3RSb3V0ZShwYXJlbnRzLCBwb2ludHMsIHRhaWxQb2ludCwgZnJvbSwgdG8sIGdyaWQsIG9wdCkge1xuXG4gICAgdmFyIHJvdXRlID0gW107XG5cbiAgICB2YXIgcHJldkRpZmYgPSBub3JtYWxpemVQb2ludCh0by5kaWZmZXJlbmNlKHRhaWxQb2ludCkpO1xuXG4gICAgLy8gdGFpbFBvaW50IGlzIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCBhbHJlYWR5XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBnZXRLZXkodGFpbFBvaW50KTtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tjdXJyZW50S2V5XTtcblxuICAgIHZhciBwb2ludDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG5cbiAgICAgICAgLy8gcG9pbnQgaXMgYXNzdW1lZCB0byBiZSBhbGlnbmVkIGFscmVhZHlcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbY3VycmVudEtleV07XG5cbiAgICAgICAgdmFyIGRpZmYgPSBub3JtYWxpemVQb2ludChwb2ludC5kaWZmZXJlbmNlKHBhcmVudCkpO1xuICAgICAgICBpZiAoIWRpZmYuZXF1YWxzKHByZXZEaWZmKSkge1xuICAgICAgICAgICAgcm91dGUudW5zaGlmdChwb2ludCk7XG4gICAgICAgICAgICBwcmV2RGlmZiA9IGRpZmY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXJlbnQgaXMgYXNzdW1lZCB0byBiZSBhbGlnbmVkIGFscmVhZHlcbiAgICAgICAgY3VycmVudEtleSA9IGdldEtleShwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnRzW2N1cnJlbnRLZXldO1xuICAgIH1cblxuICAgIC8vIGxlYWRQb2ludCBpcyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgYWxyZWFkeVxuICAgIHZhciBsZWFkUG9pbnQgPSBwb2ludHNbY3VycmVudEtleV07XG5cbiAgICB2YXIgZnJvbURpZmYgPSBub3JtYWxpemVQb2ludChsZWFkUG9pbnQuZGlmZmVyZW5jZShmcm9tKSk7XG4gICAgaWYgKCFmcm9tRGlmZi5lcXVhbHMocHJldkRpZmYpKSB7XG4gICAgICAgIHJvdXRlLnVuc2hpZnQobGVhZFBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGU7XG59XG5cbi8vIGhldXJpc3RpYyBtZXRob2QgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbmZ1bmN0aW9uIGVzdGltYXRlQ29zdChmcm9tLCBlbmRQb2ludHMpIHtcblxuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbmRQb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNvc3QgPSBmcm9tLm1hbmhhdHRhbkRpc3RhbmNlKGVuZFBvaW50c1tpXSk7XG4gICAgICAgIGlmIChjb3N0IDwgbWluKSBtaW4gPSBjb3N0O1xuICAgIH1cblxuICAgIHJldHVybiBtaW47XG59XG5cbi8vIGZpbmQgcG9pbnRzIGFyb3VuZCB0aGUgYmJveCB0YWtpbmcgZ2l2ZW4gZGlyZWN0aW9ucyBpbnRvIGFjY291bnRcbi8vIGxpbmVzIGFyZSBkcmF3biBmcm9tIGFuY2hvciBpbiBnaXZlbiBkaXJlY3Rpb25zLCBpbnRlcnNlY3Rpb25zIHJlY29yZGVkXG4vLyBpZiBhbmNob3IgaXMgb3V0c2lkZSBiYm94LCBvbmx5IHRob3NlIGRpcmVjdGlvbnMgdGhhdCBpbnRlcnNlY3QgZ2V0IGEgcmVjdCBwb2ludFxuLy8gdGhlIGFuY2hvciBpdHNlbGYgaXMgcmV0dXJuZWQgYXMgcmVjdCBwb2ludCAocmVwcmVzZW50aW5nIHNvbWUgZGlyZWN0aW9ucylcbi8vIChzaW5jZSB0aG9zZSBkaXJlY3Rpb25zIGFyZSB1bm9ic3RydWN0ZWQgYnkgdGhlIGJib3gpXG5mdW5jdGlvbiBnZXRSZWN0UG9pbnRzKGFuY2hvciwgYmJveCwgZGlyZWN0aW9uTGlzdCwgZ3JpZCwgb3B0KSB7XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gb3B0LnByZWNpc2lvbjtcbiAgICB2YXIgZGlyZWN0aW9uTWFwID0gb3B0LmRpcmVjdGlvbk1hcDtcblxuICAgIHZhciBhbmNob3JDZW50ZXJWZWN0b3IgPSBhbmNob3IuZGlmZmVyZW5jZShiYm94LmNlbnRlcigpKTtcblxuICAgIHZhciBrZXlzID0gdXRpbC5pc09iamVjdChkaXJlY3Rpb25NYXApID8gT2JqZWN0LmtleXMoZGlyZWN0aW9uTWFwKSA6IFtdO1xuICAgIHZhciBkaXJMaXN0ID0gdXRpbC50b0FycmF5KGRpcmVjdGlvbkxpc3QpO1xuICAgIHZhciByZWN0UG9pbnRzID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBrZXkpIHtcblxuICAgICAgICBpZiAoZGlyTGlzdC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uTWFwW2tleV07XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGxpbmUgdGhhdCBpcyBndWFyYW50ZWVkIHRvIGludGVyc2VjdCB0aGUgYmJveCBpZiBiYm94IGlzIGluIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgYW5jaG9yIGxpZXMgb3V0c2lkZSBvZiBiYm94XG4gICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSBuZXcgZy5Qb2ludChcbiAgICAgICAgICAgICAgICBhbmNob3IueCArIGRpcmVjdGlvbi54ICogKE1hdGguYWJzKGFuY2hvckNlbnRlclZlY3Rvci54KSArIGJib3gud2lkdGgpLFxuICAgICAgICAgICAgICAgIGFuY2hvci55ICsgZGlyZWN0aW9uLnkgKiAoTWF0aC5hYnMoYW5jaG9yQ2VudGVyVmVjdG9yLnkpICsgYmJveC5oZWlnaHQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbkxpbmUgPSBuZXcgZy5MaW5lKGFuY2hvciwgZW5kcG9pbnQpO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGZhcnRoZXIgaW50ZXJzZWN0aW9uLCBpbiBjYXNlIHRoZXJlIGFyZSB0d29cbiAgICAgICAgICAgIC8vICh0aGF0IGhhcHBlbnMgaWYgYW5jaG9yIGxpZXMgbmV4dCB0byBiYm94KVxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25MaW5lLmludGVyc2VjdChiYm94KSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBudW1JbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZmFydGhlc3RJbnRlcnNlY3Rpb25EaXN0YW5jZTtcbiAgICAgICAgICAgIHZhciBmYXJ0aGVzdEludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUludGVyc2VjdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBhbmNob3Iuc3F1YXJlZERpc3RhbmNlKGN1cnJlbnRJbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICgoZmFydGhlc3RJbnRlcnNlY3Rpb25EaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB8fCAoZGlzdGFuY2UgPiBmYXJ0aGVzdEludGVyc2VjdGlvbkRpc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBmYXJ0aGVzdEludGVyc2VjdGlvbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGZhcnRoZXN0SW50ZXJzZWN0aW9uID0gY3VycmVudEludGVyc2VjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGFuIGludGVyc2VjdGlvbiB3YXMgZm91bmQgaW4gdGhpcyBkaXJlY3Rpb24sIGl0IGlzIG91ciByZWN0UG9pbnRcbiAgICAgICAgICAgIGlmIChmYXJ0aGVzdEludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGFsaWduKGZhcnRoZXN0SW50ZXJzZWN0aW9uLCBncmlkLCBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlY3RQb2ludCBsaWVzIGluc2lkZSB0aGUgYmJveCwgb2Zmc2V0IGl0IGJ5IG9uZSBtb3JlIHN0ZXBcbiAgICAgICAgICAgICAgICBpZiAoYmJveC5jb250YWluc1BvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGFsaWduKHBvaW50Lm9mZnNldChkaXJlY3Rpb24ueCAqIGdyaWQueCwgZGlyZWN0aW9uLnkgKiBncmlkLnkpLCBncmlkLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRoZW4gYWRkIHRoZSBwb2ludCB0byB0aGUgcmVzdWx0IGFycmF5XG4gICAgICAgICAgICAgICAgLy8gYWxpZ25lZFxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gaWYgYW5jaG9yIGxpZXMgb3V0c2lkZSBvZiBiYm94LCBhZGQgaXQgdG8gdGhlIGFycmF5IG9mIHBvaW50c1xuICAgIGlmICghYmJveC5jb250YWluc1BvaW50KGFuY2hvcikpIHtcbiAgICAgICAgLy8gYWxpZ25lZFxuICAgICAgICByZWN0UG9pbnRzLnB1c2goYWxpZ24oYW5jaG9yLCBncmlkLCBwcmVjaXNpb24pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjdFBvaW50cztcbn1cblxuLy8gZmluZHMgdGhlIHJvdXRlIGJldHdlZW4gdHdvIHBvaW50cy9yZWN0YW5nbGVzIChgZnJvbWAsIGB0b2ApIGltcGxlbWVudGluZyBBKiBhbGdvcml0aG1cbi8vIHJlY3RhbmdsZXMgZ2V0IHJlY3QgcG9pbnRzIGFzc2lnbmVkIGJ5IGdldFJlY3RQb2ludHMoKVxuZnVuY3Rpb24gZmluZFJvdXRlKGZyb20sIHRvLCBpc1BvaW50T2JzdGFjbGUsIG9wdCkge1xuXG4gICAgdmFyIHByZWNpc2lvbiA9IG9wdC5wcmVjaXNpb247XG5cbiAgICAvLyBHZXQgZ3JpZCBmb3IgdGhpcyByb3V0ZS5cblxuICAgIHZhciBzb3VyY2VBbmNob3IsIHRhcmdldEFuY2hvcjtcblxuICAgIGlmIChmcm9tIGluc3RhbmNlb2YgZy5SZWN0KSB7IC8vIGBmcm9tYCBpcyBzb3VyY2VCQm94XG4gICAgICAgIHNvdXJjZUFuY2hvciA9IHJvdW5kKGdldFNvdXJjZUFuY2hvcih0aGlzLCBvcHQpLmNsb25lKCksIHByZWNpc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlQW5jaG9yID0gcm91bmQoZnJvbS5jbG9uZSgpLCBwcmVjaXNpb24pO1xuICAgIH1cblxuICAgIGlmICh0byBpbnN0YW5jZW9mIGcuUmVjdCkgeyAvLyBgdG9gIGlzIHRhcmdldEJCb3hcbiAgICAgICAgdGFyZ2V0QW5jaG9yID0gcm91bmQoZ2V0VGFyZ2V0QW5jaG9yKHRoaXMsIG9wdCkuY2xvbmUoKSwgcHJlY2lzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRBbmNob3IgPSByb3VuZCh0by5jbG9uZSgpLCBwcmVjaXNpb24pO1xuICAgIH1cblxuICAgIHZhciBncmlkID0gZ2V0R3JpZChvcHQuc3RlcCwgc291cmNlQW5jaG9yLCB0YXJnZXRBbmNob3IpO1xuXG4gICAgLy8gR2V0IHBhdGhmaW5kaW5nIHBvaW50cy5cblxuICAgIHZhciBzdGFydCwgZW5kOyAvLyBhbGlnbmVkIHdpdGggZ3JpZCBieSBkZWZpbml0aW9uXG4gICAgdmFyIHN0YXJ0UG9pbnRzLCBlbmRQb2ludHM7IC8vIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCB3aXRoIGdyaWQgYWxyZWFkeVxuXG4gICAgLy8gc2V0IG9mIHBvaW50cyB3ZSBzdGFydCBwYXRoZmluZGluZyBmcm9tXG4gICAgaWYgKGZyb20gaW5zdGFuY2VvZiBnLlJlY3QpIHsgLy8gYGZyb21gIGlzIHNvdXJjZUJCb3hcbiAgICAgICAgc3RhcnQgPSBzb3VyY2VBbmNob3I7XG4gICAgICAgIHN0YXJ0UG9pbnRzID0gZ2V0UmVjdFBvaW50cyhzdGFydCwgZnJvbSwgb3B0LnN0YXJ0RGlyZWN0aW9ucywgZ3JpZCwgb3B0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc291cmNlQW5jaG9yO1xuICAgICAgICBzdGFydFBvaW50cyA9IFtzdGFydF07XG4gICAgfVxuXG4gICAgLy8gc2V0IG9mIHBvaW50cyB3ZSB3YW50IHRoZSBwYXRoZmluZGluZyB0byBmaW5pc2ggYXRcbiAgICBpZiAodG8gaW5zdGFuY2VvZiBnLlJlY3QpIHsgLy8gYHRvYCBpcyB0YXJnZXRCQm94XG4gICAgICAgIGVuZCA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgZW5kUG9pbnRzID0gZ2V0UmVjdFBvaW50cyh0YXJnZXRBbmNob3IsIHRvLCBvcHQuZW5kRGlyZWN0aW9ucywgZ3JpZCwgb3B0KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRhcmdldEFuY2hvcjtcbiAgICAgICAgZW5kUG9pbnRzID0gW2VuZF07XG4gICAgfVxuXG4gICAgLy8gdGFrZSBpbnRvIGFjY291bnQgb25seSBhY2Nlc3NpYmxlIHJlY3QgcG9pbnRzICh0aG9zZSBub3QgdW5kZXIgb2JzdGFjbGVzKVxuICAgIHN0YXJ0UG9pbnRzID0gc3RhcnRQb2ludHMuZmlsdGVyKHAgPT4gIWlzUG9pbnRPYnN0YWNsZShwKSk7XG4gICAgZW5kUG9pbnRzID0gZW5kUG9pbnRzLmZpbHRlcihwID0+ICFpc1BvaW50T2JzdGFjbGUocCkpO1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGVyZSBpcyBhbiBhY2Nlc3NpYmxlIHJvdXRlIHBvaW50IG9uIGJvdGggc2lkZXMuXG4gICAgLy8gT3RoZXJ3aXNlLCB1c2UgZmFsbGJhY2tSb3V0ZSgpLlxuICAgIGlmIChzdGFydFBvaW50cy5sZW5ndGggPiAwICYmIGVuZFBvaW50cy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgLy8gVGhlIHNldCBvZiB0ZW50YXRpdmUgcG9pbnRzIHRvIGJlIGV2YWx1YXRlZCwgaW5pdGlhbGx5IGNvbnRhaW5pbmcgdGhlIHN0YXJ0IHBvaW50cy5cbiAgICAgICAgLy8gUm91bmRlZCB0byBuZWFyZXN0IGludGVnZXIgZm9yIHNpbXBsaWNpdHkuXG4gICAgICAgIHZhciBvcGVuU2V0ID0gbmV3IFNvcnRlZFNldCgpO1xuICAgICAgICAvLyBLZWVwcyByZWZlcmVuY2UgdG8gYWN0dWFsIHBvaW50cyBmb3IgZ2l2ZW4gZWxlbWVudHMgb2YgdGhlIG9wZW4gc2V0LlxuICAgICAgICB2YXIgcG9pbnRzID0ge307XG4gICAgICAgIC8vIEtlZXBzIHJlZmVyZW5jZSB0byBhIHBvaW50IHRoYXQgaXMgaW1tZWRpYXRlIHByZWRlY2Vzc29yIG9mIGdpdmVuIGVsZW1lbnQuXG4gICAgICAgIHZhciBwYXJlbnRzID0ge307XG4gICAgICAgIC8vIENvc3QgZnJvbSBzdGFydCB0byBhIHBvaW50IGFsb25nIGJlc3Qga25vd24gcGF0aC5cbiAgICAgICAgdmFyIGNvc3RzID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzdGFydFBvaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0UG9pbnQgaXMgYXNzdW1lZCB0byBiZSBhbGlnbmVkIGFscmVhZHlcbiAgICAgICAgICAgIHZhciBzdGFydFBvaW50ID0gc3RhcnRQb2ludHNbaV07XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXkoc3RhcnRQb2ludCk7XG5cbiAgICAgICAgICAgIG9wZW5TZXQuYWRkKGtleSwgZXN0aW1hdGVDb3N0KHN0YXJ0UG9pbnQsIGVuZFBvaW50cykpO1xuICAgICAgICAgICAgcG9pbnRzW2tleV0gPSBzdGFydFBvaW50O1xuICAgICAgICAgICAgY29zdHNba2V5XSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldmlvdXNSb3V0ZURpcmVjdGlvbkFuZ2xlID0gb3B0LnByZXZpb3VzRGlyZWN0aW9uQW5nbGU7IC8vIHVuZGVmaW5lZCBmb3IgZmlyc3Qgcm91dGVcbiAgICAgICAgdmFyIGlzUGF0aEJlZ2lubmluZyA9IChwcmV2aW91c1JvdXRlRGlyZWN0aW9uQW5nbGUgPT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy8gZGlyZWN0aW9uc1xuICAgICAgICB2YXIgZGlyZWN0aW9uLCBkaXJlY3Rpb25DaGFuZ2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb25zID0gb3B0LmRpcmVjdGlvbnM7XG4gICAgICAgIGdldEdyaWRPZmZzZXRzKGRpcmVjdGlvbnMsIGdyaWQsIG9wdCk7XG5cbiAgICAgICAgdmFyIG51bURpcmVjdGlvbnMgPSBkaXJlY3Rpb25zLmxlbmd0aDtcblxuICAgICAgICB2YXIgZW5kUG9pbnRzS2V5cyA9IHV0aWwudG9BcnJheShlbmRQb2ludHMpLnJlZHVjZShmdW5jdGlvbihyZXMsIGVuZFBvaW50KSB7XG4gICAgICAgICAgICAvLyBlbmRQb2ludCBpcyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgYWxyZWFkeVxuXG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0S2V5KGVuZFBvaW50KTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgLy8gbWFpbiByb3V0ZSBmaW5kaW5nIGxvb3BcbiAgICAgICAgdmFyIGxvb3BzUmVtYWluaW5nID0gb3B0Lm1heGltdW1Mb29wcztcbiAgICAgICAgd2hpbGUgKCFvcGVuU2V0LmlzRW1wdHkoKSAmJiBsb29wc1JlbWFpbmluZyA+IDApIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgZnJvbSB0aGUgb3BlbiBsaXN0XG4gICAgICAgICAgICB2YXIgY3VycmVudEtleSA9IG9wZW5TZXQucG9wKCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFBvaW50ID0gcG9pbnRzW2N1cnJlbnRLZXldO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRzW2N1cnJlbnRLZXldO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRDb3N0ID0gY29zdHNbY3VycmVudEtleV07XG5cbiAgICAgICAgICAgIHZhciBpc1JvdXRlQmVnaW5uaW5nID0gKGN1cnJlbnRQYXJlbnQgPT09IHVuZGVmaW5lZCk7IC8vIHVuZGVmaW5lZCBmb3Igcm91dGUgc3RhcnRzXG4gICAgICAgICAgICB2YXIgaXNTdGFydCA9IGN1cnJlbnRQb2ludC5lcXVhbHMoc3RhcnQpOyAvLyAoaXMgc291cmNlIGFuY2hvciBvciBgZnJvbWAgcG9pbnQpID0gY2FuIGxlYXZlIGluIGFueSBkaXJlY3Rpb25cblxuICAgICAgICAgICAgdmFyIHByZXZpb3VzRGlyZWN0aW9uQW5nbGU7XG4gICAgICAgICAgICBpZiAoIWlzUm91dGVCZWdpbm5pbmcpIHByZXZpb3VzRGlyZWN0aW9uQW5nbGUgPSBnZXREaXJlY3Rpb25BbmdsZShjdXJyZW50UGFyZW50LCBjdXJyZW50UG9pbnQsIG51bURpcmVjdGlvbnMsIGdyaWQsIG9wdCk7IC8vIGEgdmVydGV4IG9uIHRoZSByb3V0ZVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzUGF0aEJlZ2lubmluZykgcHJldmlvdXNEaXJlY3Rpb25BbmdsZSA9IHByZXZpb3VzUm91dGVEaXJlY3Rpb25BbmdsZTsgLy8gYmVnaW5uaW5nIG9mIHJvdXRlIG9uIHRoZSBwYXRoXG4gICAgICAgICAgICBlbHNlIGlmICghaXNTdGFydCkgcHJldmlvdXNEaXJlY3Rpb25BbmdsZSA9IGdldERpcmVjdGlvbkFuZ2xlKHN0YXJ0LCBjdXJyZW50UG9pbnQsIG51bURpcmVjdGlvbnMsIGdyaWQsIG9wdCk7IC8vIGJlZ2lubmluZyBvZiBwYXRoLCBzdGFydCByZWN0IHBvaW50XG4gICAgICAgICAgICBlbHNlIHByZXZpb3VzRGlyZWN0aW9uQW5nbGUgPSBudWxsOyAvLyBiZWdpbm5pbmcgb2YgcGF0aCwgc291cmNlIGFuY2hvciBvciBgZnJvbWAgcG9pbnRcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgcmVhY2hlZCBhbnkgZW5kcG9pbnRcbiAgICAgICAgICAgIHZhciBzYW1lUG9pbnRzID0gc3RhcnRQb2ludHMubGVuZ3RoID09PSBlbmRQb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNhbWVQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0YXJ0UG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhcnRQb2ludHNbal0uZXF1YWxzKGVuZFBvaW50c1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbWVQb2ludHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNraXBFbmRDaGVjayA9IChpc1JvdXRlQmVnaW5uaW5nICYmIHNhbWVQb2ludHMpO1xuICAgICAgICAgICAgaWYgKCFza2lwRW5kQ2hlY2sgJiYgKGVuZFBvaW50c0tleXMuaW5kZXhPZihjdXJyZW50S2V5KSA+PSAwKSkge1xuICAgICAgICAgICAgICAgIG9wdC5wcmV2aW91c0RpcmVjdGlvbkFuZ2xlID0gcHJldmlvdXNEaXJlY3Rpb25BbmdsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RSb3V0ZShwYXJlbnRzLCBwb2ludHMsIGN1cnJlbnRQb2ludCwgc3RhcnQsIGVuZCwgZ3JpZCwgb3B0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZ28gb3ZlciBhbGwgcG9zc2libGUgZGlyZWN0aW9ucyBhbmQgZmluZCBuZWlnaGJvcnNcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1EaXJlY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkFuZ2xlID0gZGlyZWN0aW9uLmFuZ2xlO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbkNoYW5nZSA9IGdldERpcmVjdGlvbkNoYW5nZShwcmV2aW91c0RpcmVjdGlvbkFuZ2xlLCBkaXJlY3Rpb25BbmdsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZGlyZWN0aW9uIGNoYW5nZWQgcmFwaWRseSwgZG9uJ3QgdXNlIHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBhbnkgZGlyZWN0aW9uIGlzIGFsbG93ZWQgZm9yIHN0YXJ0aW5nIHBvaW50c1xuICAgICAgICAgICAgICAgIGlmICghKGlzUGF0aEJlZ2lubmluZyAmJiBpc1N0YXJ0KSAmJiBkaXJlY3Rpb25DaGFuZ2UgPiBvcHQubWF4QWxsb3dlZERpcmVjdGlvbkNoYW5nZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JQb2ludCA9IGFsaWduKGN1cnJlbnRQb2ludC5jbG9uZSgpLm9mZnNldChkaXJlY3Rpb24uZ3JpZE9mZnNldFgsIGRpcmVjdGlvbi5ncmlkT2Zmc2V0WSksIGdyaWQsIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yS2V5ID0gZ2V0S2V5KG5laWdoYm9yUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xvc2VkIHBvaW50cyBmcm9tIHRoZSBvcGVuU2V0IHdlcmUgYWxyZWFkeSBldmFsdWF0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKG9wZW5TZXQuaXNDbG9zZShuZWlnaGJvcktleSkgfHwgaXNQb2ludE9ic3RhY2xlKG5laWdoYm9yUG9pbnQpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGVudGVyIGVuZCBwb2ludHMgYXQgYW4gYWNjZXB0YWJsZSBhbmdsZS5cbiAgICAgICAgICAgICAgICBpZiAoZW5kUG9pbnRzS2V5cy5pbmRleE9mKG5laWdoYm9yS2V5KSA+PSAwKSB7IC8vIG5laWdoYm9yIGlzIGFuIGVuZCBwb2ludFxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05laWdoYm9yRW5kID0gbmVpZ2hib3JQb2ludC5lcXVhbHMoZW5kKTsgLy8gKGlzIHRhcmdldCBhbmNob3Igb3IgYHRvYCBwb2ludCkgPSBjYW4gYmUgZW50ZXJlZCBpbiBhbnkgZGlyZWN0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05laWdoYm9yRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRGlyZWN0aW9uQW5nbGUgPSBnZXREaXJlY3Rpb25BbmdsZShuZWlnaGJvclBvaW50LCBlbmQsIG51bURpcmVjdGlvbnMsIGdyaWQsIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kRGlyZWN0aW9uQ2hhbmdlID0gZ2V0RGlyZWN0aW9uQ2hhbmdlKGRpcmVjdGlvbkFuZ2xlLCBlbmREaXJlY3Rpb25BbmdsZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmREaXJlY3Rpb25DaGFuZ2UgPiBvcHQubWF4QWxsb3dlZERpcmVjdGlvbkNoYW5nZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBkaXJlY3Rpb24gaXMgb2suXG5cbiAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JDb3N0ID0gZGlyZWN0aW9uLmNvc3Q7XG4gICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yUGVuYWx0eSA9IGlzU3RhcnQgPyAwIDogb3B0LnBlbmFsdGllc1tkaXJlY3Rpb25DaGFuZ2VdOyAvLyBubyBwZW5hbHRpZXMgZm9yIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgdmFyIGNvc3RGcm9tU3RhcnQgPSBjdXJyZW50Q29zdCArIG5laWdoYm9yQ29zdCArIG5laWdoYm9yUGVuYWx0eTtcblxuICAgICAgICAgICAgICAgIGlmICghb3BlblNldC5pc09wZW4obmVpZ2hib3JLZXkpIHx8IChjb3N0RnJvbVN0YXJ0IDwgY29zdHNbbmVpZ2hib3JLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBuZWlnaGJvciBwb2ludCBoYXMgbm90IGJlZW4gcHJvY2Vzc2VkIHlldFxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0aGUgY29zdCBvZiB0aGUgcGF0aCBmcm9tIHN0YXJ0IGlzIGxvd2VyIHRoYW4gcHJldmlvdXNseSBjYWxjdWxhdGVkXG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzW25laWdoYm9yS2V5XSA9IG5laWdoYm9yUG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHNbbmVpZ2hib3JLZXldID0gY3VycmVudFBvaW50O1xuICAgICAgICAgICAgICAgICAgICBjb3N0c1tuZWlnaGJvcktleV0gPSBjb3N0RnJvbVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBvcGVuU2V0LmFkZChuZWlnaGJvcktleSwgY29zdEZyb21TdGFydCArIGVzdGltYXRlQ29zdChuZWlnaGJvclBvaW50LCBlbmRQb2ludHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvb3BzUmVtYWluaW5nLS07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBubyByb3V0ZSBmb3VuZCAoYHRvYCBwb2ludCBlaXRoZXIgd2Fzbid0IGFjY2Vzc2libGUgb3IgZmluZGluZyByb3V0ZSB0b29rXG4gICAgLy8gd2F5IHRvbyBtdWNoIGNhbGN1bGF0aW9uKVxuICAgIHJldHVybiBvcHQuZmFsbGJhY2tSb3V0ZS5jYWxsKHRoaXMsIHN0YXJ0LCBlbmQsIG9wdCk7XG59XG5cbi8vIHJlc29sdmUgc29tZSBvZiB0aGUgb3B0aW9uc1xuZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbnMob3B0KSB7XG5cbiAgICBvcHQuZGlyZWN0aW9ucyA9IHV0aWwucmVzdWx0KG9wdCwgJ2RpcmVjdGlvbnMnKTtcbiAgICBvcHQucGVuYWx0aWVzID0gdXRpbC5yZXN1bHQob3B0LCAncGVuYWx0aWVzJyk7XG4gICAgb3B0LnBhZGRpbmdCb3ggPSB1dGlsLnJlc3VsdChvcHQsICdwYWRkaW5nQm94Jyk7XG4gICAgb3B0LnBhZGRpbmcgPSB1dGlsLnJlc3VsdChvcHQsICdwYWRkaW5nJyk7XG5cbiAgICBpZiAob3B0LnBhZGRpbmcpIHtcbiAgICAgICAgLy8gaWYgYm90aCBwcm92aWRlZCwgb3B0LnBhZGRpbmcgd2lucyBvdmVyIG9wdC5wYWRkaW5nQm94XG4gICAgICAgIHZhciBzaWRlcyA9IHV0aWwubm9ybWFsaXplU2lkZXMob3B0LnBhZGRpbmcpO1xuICAgICAgICBvcHQucGFkZGluZ0JveCA9IHtcbiAgICAgICAgICAgIHg6IC1zaWRlcy5sZWZ0LFxuICAgICAgICAgICAgeTogLXNpZGVzLnRvcCxcbiAgICAgICAgICAgIHdpZHRoOiBzaWRlcy5sZWZ0ICsgc2lkZXMucmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IHNpZGVzLnRvcCArIHNpZGVzLmJvdHRvbVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHV0aWwudG9BcnJheShvcHQuZGlyZWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbihkaXJlY3Rpb24pIHtcblxuICAgICAgICB2YXIgcG9pbnQxID0gbmV3IGcuUG9pbnQoMCwgMCk7XG4gICAgICAgIHZhciBwb2ludDIgPSBuZXcgZy5Qb2ludChkaXJlY3Rpb24ub2Zmc2V0WCwgZGlyZWN0aW9uLm9mZnNldFkpO1xuXG4gICAgICAgIGRpcmVjdGlvbi5hbmdsZSA9IGcubm9ybWFsaXplQW5nbGUocG9pbnQxLnRoZXRhKHBvaW50MikpO1xuICAgIH0pO1xufVxuXG4vLyBpbml0aWFsaXphdGlvbiBvZiB0aGUgcm91dGUgZmluZGluZ1xuZnVuY3Rpb24gcm91dGVyKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG5cbiAgICByZXNvbHZlT3B0aW9ucyhvcHQpO1xuXG4gICAgLy8gZW5hYmxlL2Rpc2FibGUgbGlua1ZpZXcgcGVycGVuZGljdWxhciBvcHRpb25cbiAgICBsaW5rVmlldy5vcHRpb25zLnBlcnBlbmRpY3VsYXIgPSAhIW9wdC5wZXJwZW5kaWN1bGFyO1xuXG4gICAgdmFyIHNvdXJjZUJCb3ggPSBnZXRTb3VyY2VCQm94KGxpbmtWaWV3LCBvcHQpO1xuICAgIHZhciB0YXJnZXRCQm94ID0gZ2V0VGFyZ2V0QkJveChsaW5rVmlldywgb3B0KTtcblxuICAgIHZhciBzb3VyY2VBbmNob3IgPSBnZXRTb3VyY2VBbmNob3IobGlua1ZpZXcsIG9wdCk7XG4gICAgLy92YXIgdGFyZ2V0QW5jaG9yID0gZ2V0VGFyZ2V0QW5jaG9yKGxpbmtWaWV3LCBvcHQpO1xuXG4gICAgLy8gcGF0aGZpbmRpbmdcbiAgICBsZXQgaXNQb2ludE9ic3RhY2xlO1xuICAgIGlmICh0eXBlb2Ygb3B0LmlzUG9pbnRPYnN0YWNsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpc1BvaW50T2JzdGFjbGUgPSBvcHQuaXNQb2ludE9ic3RhY2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBPYnN0YWNsZU1hcChvcHQpO1xuICAgICAgICBtYXAuYnVpbGQobGlua1ZpZXcucGFwZXIubW9kZWwsIGxpbmtWaWV3Lm1vZGVsKTtcbiAgICAgICAgaXNQb2ludE9ic3RhY2xlID0gKHBvaW50KSA9PiAhbWFwLmlzUG9pbnRBY2Nlc3NpYmxlKHBvaW50KTtcbiAgICB9XG5cbiAgICB2YXIgb2xkVmVydGljZXMgPSB1dGlsLnRvQXJyYXkodmVydGljZXMpLm1hcChnLlBvaW50KTtcbiAgICB2YXIgbmV3VmVydGljZXMgPSBbXTtcbiAgICB2YXIgdGFpbFBvaW50ID0gc291cmNlQW5jaG9yOyAvLyB0aGUgb3JpZ2luIG9mIGZpcnN0IHJvdXRlJ3MgZ3JpZCwgZG9lcyBub3QgbmVlZCBzbmFwcGluZ1xuXG4gICAgLy8gZmluZCBhIHJvdXRlIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHBhcnRpYWwgcm91dGVzIChyb3V0ZXMgbmVlZCB0byBwYXNzIHRocm91Z2ggdmVydGljZXMpXG4gICAgLy8gc291cmNlIC0+IHZlcnRleFsxXSAtPiAuLi4gLT4gdmVydGV4W25dIC0+IHRhcmdldFxuICAgIHZhciB0bywgZnJvbTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvbGRWZXJ0aWNlcy5sZW5ndGg7IGkgPD0gbGVuOyBpKyspIHtcblxuICAgICAgICB2YXIgcGFydGlhbFJvdXRlID0gbnVsbDtcblxuICAgICAgICBmcm9tID0gdG8gfHwgc291cmNlQkJveDtcbiAgICAgICAgdG8gPSBvbGRWZXJ0aWNlc1tpXTtcblxuICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBsYXN0IGl0ZXJhdGlvblxuICAgICAgICAgICAgLy8gd2UgcmFuIHRocm91Z2ggYWxsIHZlcnRpY2VzIGluIG9sZFZlcnRpY2VzXG4gICAgICAgICAgICAvLyAndG8nIGlzIG5vdCBhIHZlcnRleC5cblxuICAgICAgICAgICAgdG8gPSB0YXJnZXRCQm94O1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcG9pbnQgKGkuZS4gaXQncyBub3QgYW4gZWxlbWVudCksIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgdXNlIGRyYWdnaW5nIHJvdXRlIGluc3RlYWQgb2YgbWFpbiByb3V0aW5nIG1ldGhvZCBpZiBpdCBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICAgICAgICAgIHZhciBpc0VuZGluZ0F0UG9pbnQgPSAhbGlua1ZpZXcubW9kZWwuZ2V0KCdzb3VyY2UnKS5pZCB8fCAhbGlua1ZpZXcubW9kZWwuZ2V0KCd0YXJnZXQnKS5pZDtcblxuICAgICAgICAgICAgaWYgKGlzRW5kaW5nQXRQb2ludCAmJiB1dGlsLmlzRnVuY3Rpb24ob3B0LmRyYWdnaW5nUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSBwYXNzaW5nIHBvaW50cyBvbmx5IChub3QgcmVjdHMpLlxuICAgICAgICAgICAgICAgIHZhciBkcmFnRnJvbSA9IChmcm9tID09PSBzb3VyY2VCQm94KSA/IHNvdXJjZUFuY2hvciA6IGZyb207XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdUbyA9IHRvLm9yaWdpbigpO1xuXG4gICAgICAgICAgICAgICAgcGFydGlhbFJvdXRlID0gb3B0LmRyYWdnaW5nUm91dGUuY2FsbChsaW5rVmlldywgZHJhZ0Zyb20sIGRyYWdUbywgb3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHBhcnRpYWwgcm91dGUgaGFzIG5vdCBiZWVuIGNhbGN1bGF0ZWQgeWV0IHVzZSB0aGUgbWFpbiByb3V0aW5nIG1ldGhvZCB0byBmaW5kIG9uZVxuICAgICAgICBwYXJ0aWFsUm91dGUgPSBwYXJ0aWFsUm91dGUgfHwgZmluZFJvdXRlLmNhbGwobGlua1ZpZXcsIGZyb20sIHRvLCBpc1BvaW50T2JzdGFjbGUsIG9wdCk7XG5cbiAgICAgICAgaWYgKHBhcnRpYWxSb3V0ZSA9PT0gbnVsbCkgeyAvLyB0aGUgcGFydGlhbCByb3V0ZSBjYW5ub3QgYmUgZm91bmRcbiAgICAgICAgICAgIHJldHVybiBvcHQuZmFsbGJhY2tSb3V0ZXIodmVydGljZXMsIG9wdCwgbGlua1ZpZXcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlYWRQb2ludCA9IHBhcnRpYWxSb3V0ZVswXTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGZpcnN0IHBvaW50IGlmIHRoZSBwcmV2aW91cyBwYXJ0aWFsIHJvdXRlIGhhZCB0aGUgc2FtZSBwb2ludCBhcyBsYXN0XG4gICAgICAgIGlmIChsZWFkUG9pbnQgJiYgbGVhZFBvaW50LmVxdWFscyh0YWlsUG9pbnQpKSBwYXJ0aWFsUm91dGUuc2hpZnQoKTtcblxuICAgICAgICAvLyBzYXZlIHRhaWxQb2ludCBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgdGFpbFBvaW50ID0gcGFydGlhbFJvdXRlW3BhcnRpYWxSb3V0ZS5sZW5ndGggLSAxXSB8fCB0YWlsUG9pbnQ7XG5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobmV3VmVydGljZXMsIHBhcnRpYWxSb3V0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1ZlcnRpY2VzO1xufVxuXG4vLyBwdWJsaWMgZnVuY3Rpb25cbmV4cG9ydCBjb25zdCBtYW5oYXR0YW4gPSBmdW5jdGlvbih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuICAgIHJldHVybiByb3V0ZXIodmVydGljZXMsIHV0aWwuYXNzaWduKHt9LCBjb25maWcsIG9wdCksIGxpbmtWaWV3KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/manhattan.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/metro.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/metro.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   metro: () => (/* binding */ metro)\n/* harmony export */ });\n/* harmony import */ var _manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./manhattan.mjs */ \"(ssr)/./node_modules/@joint/core/src/routers/manhattan.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n\n\n\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(l1.squaredLength(), _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toRad(alpha + 135), p1);\n        var l2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nconst metro = function(vertices, opt, linkView) {\n\n    if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction(_manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__.manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return (0,_manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__.manhattan)(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, config, opt), linkView);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvbWV0cm8ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE0QztBQUNGO0FBQ047O0FBRXBDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsa0RBQWtEO0FBQ2hFLGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsbURBQW1EO0FBQ2pFLGNBQWMsd0NBQXdDO0FBQ3RELGNBQWMsb0RBQW9EO0FBQ2xFLGNBQWMsd0NBQXdDO0FBQ3RELGNBQWM7QUFDZDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjtBQUNsQixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsOENBQU07O0FBRTNCOztBQUVBLGlCQUFpQiwrQ0FBTywrQkFBK0IsK0NBQU87QUFDOUQscUJBQXFCLDhDQUFNOztBQUUzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsd0RBQWdCO0FBQzlDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ087O0FBRVAsU0FBUyx1REFBZSxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7O0FBRUEsV0FBVyx5REFBUyxXQUFXLG1EQUFXLEdBQUc7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9yb3V0ZXJzL21ldHJvLm1qcz9hMzcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1hbmhhdHRhbiB9IGZyb20gJy4vbWFuaGF0dGFuLm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG52YXIgY29uZmlnID0ge1xuXG4gICAgbWF4QWxsb3dlZERpcmVjdGlvbkNoYW5nZTogNDUsXG5cbiAgICAvLyBjb3N0IG9mIGEgZGlhZ29uYWwgc3RlcFxuICAgIGRpYWdvbmFsQ29zdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5zcXJ0KHN0ZXAgKiBzdGVwIDw8IDEpKTtcbiAgICB9LFxuXG4gICAgLy8gYW4gYXJyYXkgb2YgZGlyZWN0aW9ucyB0byBmaW5kIG5leHQgcG9pbnRzIG9uIHRoZSByb3V0ZVxuICAgIC8vIGRpZmZlcmVudCBmcm9tIHN0YXJ0L2VuZCBkaXJlY3Rpb25zXG4gICAgZGlyZWN0aW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgICAgIHZhciBjb3N0ID0gdGhpcy5jb3N0KCk7XG4gICAgICAgIHZhciBkaWFnb25hbENvc3QgPSB0aGlzLmRpYWdvbmFsQ29zdCgpO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAsIG9mZnNldFk6IDAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogc3RlcCwgb2Zmc2V0WTogc3RlcCwgY29zdDogZGlhZ29uYWxDb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IDAsIG9mZnNldFk6IHN0ZXAsIGNvc3Q6IGNvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogLXN0ZXAsIG9mZnNldFk6IHN0ZXAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAtc3RlcCwgb2Zmc2V0WTogMCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAtc3RlcCwgb2Zmc2V0WTogLXN0ZXAsIGNvc3Q6IGRpYWdvbmFsQ29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAwLCBvZmZzZXRZOiAtc3RlcCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwLCBvZmZzZXRZOiAtc3RlcCwgY29zdDogZGlhZ29uYWxDb3N0IH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLy8gYSBzaW1wbGUgcm91dGUgdXNlZCBpbiBzaXR1YXRpb25zIHdoZW4gbWFpbiByb3V0aW5nIG1ldGhvZCBmYWlsc1xuICAgIC8vIChleGNlZWQgbWF4IG51bWJlciBvZiBsb29wIGl0ZXJhdGlvbnMsIGluYWNjZXNzaWJsZSlcbiAgICBmYWxsYmFja1JvdXRlOiBmdW5jdGlvbihmcm9tLCB0bywgb3B0KSB7XG5cbiAgICAgICAgLy8gRmluZCBhIHJvdXRlIHdoaWNoIGJyZWFrcyBieSA0NSBkZWdyZWVzIGlnbm9yaW5nIGFsbCBvYnN0YWNsZXMuXG5cbiAgICAgICAgdmFyIHRoZXRhID0gZnJvbS50aGV0YSh0byk7XG5cbiAgICAgICAgdmFyIHJvdXRlID0gW107XG5cbiAgICAgICAgdmFyIGEgPSB7IHg6IHRvLngsIHk6IGZyb20ueSB9O1xuICAgICAgICB2YXIgYiA9IHsgeDogZnJvbS54LCB5OiB0by55IH07XG5cbiAgICAgICAgaWYgKHRoZXRhICUgMTgwID4gOTApIHtcbiAgICAgICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgYiA9IHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcDEgPSAodGhldGEgJSA5MCkgPCA0NSA/IGEgOiBiO1xuICAgICAgICB2YXIgbDEgPSBuZXcgZy5MaW5lKGZyb20sIHAxKTtcblxuICAgICAgICB2YXIgYWxwaGEgPSA5MCAqIE1hdGguY2VpbCh0aGV0YSAvIDkwKTtcblxuICAgICAgICB2YXIgcDIgPSBnLlBvaW50LmZyb21Qb2xhcihsMS5zcXVhcmVkTGVuZ3RoKCksIGcudG9SYWQoYWxwaGEgKyAxMzUpLCBwMSk7XG4gICAgICAgIHZhciBsMiA9IG5ldyBnLkxpbmUodG8sIHAyKTtcblxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBsMS5pbnRlcnNlY3Rpb24obDIpO1xuICAgICAgICB2YXIgcG9pbnQgPSBpbnRlcnNlY3Rpb25Qb2ludCA/IGludGVyc2VjdGlvblBvaW50IDogdG87XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbkZyb20gPSBpbnRlcnNlY3Rpb25Qb2ludCA/IHBvaW50IDogZnJvbTtcblxuICAgICAgICB2YXIgcXVhZHJhbnQgPSAzNjAgLyBvcHQuZGlyZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBhbmdsZVRoZXRhID0gZGlyZWN0aW9uRnJvbS50aGV0YSh0byk7XG4gICAgICAgIHZhciBub3JtYWxpemVkQW5nbGUgPSBnLm5vcm1hbGl6ZUFuZ2xlKGFuZ2xlVGhldGEgKyAocXVhZHJhbnQgLyAyKSk7XG4gICAgICAgIHZhciBkaXJlY3Rpb25BbmdsZSA9IHF1YWRyYW50ICogTWF0aC5mbG9vcihub3JtYWxpemVkQW5nbGUgLyBxdWFkcmFudCk7XG5cbiAgICAgICAgb3B0LnByZXZpb3VzRGlyZWN0aW9uQW5nbGUgPSBkaXJlY3Rpb25BbmdsZTtcblxuICAgICAgICBpZiAocG9pbnQpIHJvdXRlLnB1c2gocG9pbnQucm91bmQoKSk7XG4gICAgICAgIHJvdXRlLnB1c2godG8pO1xuXG4gICAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9XG59O1xuXG4vLyBwdWJsaWMgZnVuY3Rpb25cbmV4cG9ydCBjb25zdCBtZXRybyA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG5cbiAgICBpZiAoIXV0aWwuaXNGdW5jdGlvbihtYW5oYXR0YW4pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0cm8gcmVxdWlyZXMgdGhlIG1hbmhhdHRhbiByb3V0ZXIuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hbmhhdHRhbih2ZXJ0aWNlcywgdXRpbC5hc3NpZ24oe30sIGNvbmZpZywgb3B0KSwgbGlua1ZpZXcpO1xufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/metro.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/normal.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/normal.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: () => (/* binding */ normal)\n/* harmony export */ });\n// Does not make any changes to vertices.\n// Returns the arguments that are passed to it, unchanged.\nconst normal = function(vertices, opt, linkView) {\n\n    return vertices;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvbm9ybWFsLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNPOztBQUVQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9yb3V0ZXJzL25vcm1hbC5tanM/ZGYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEb2VzIG5vdCBtYWtlIGFueSBjaGFuZ2VzIHRvIHZlcnRpY2VzLlxuLy8gUmV0dXJucyB0aGUgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZCB0byBpdCwgdW5jaGFuZ2VkLlxuZXhwb3J0IGNvbnN0IG5vcm1hbCA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG5cbiAgICByZXR1cm4gdmVydGljZXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/normal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/oneSide.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/oneSide.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   oneSide: () => (/* binding */ oneSide)\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nconst oneSide = function(vertices, opt, linkView) {\n\n    var side = opt.side || 'bottom';\n    var padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeSides(opt.padding || 40);\n\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n\n    var coordinate, dimension, direction;\n\n    switch (side) {\n        case 'bottom':\n            direction = 1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'top':\n            direction = -1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'left':\n            direction = -1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        case 'right':\n            direction = 1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        default:\n            throw new Error('Router: invalid side');\n    }\n\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n    // make link orthogonal (at least the first and last vertex).\n    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n\n    return [sourcePoint].concat(vertices, targetPoint);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvb25lU2lkZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0Esa0JBQWtCLDJEQUFtQjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvb25lU2lkZS5tanM/ZWFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuLy8gUm91dGVzIHRoZSBsaW5rIGFsd2F5cyB0by9mcm9tIGEgY2VydGFpbiBzaWRlXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gICBwYWRkaW5nIC4uLiBnYXAgYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgdGhlIGZpcnN0IHZlcnRleC4gOjogRGVmYXVsdCA0MC5cbi8vICAgc2lkZSAuLi4gJ2xlZnQnIHwgJ3JpZ2h0JyB8ICd0b3AnIHwgJ2JvdHRvbScgOjogRGVmYXVsdCAnYm90dG9tJy5cbi8vXG5leHBvcnQgY29uc3Qgb25lU2lkZSA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG5cbiAgICB2YXIgc2lkZSA9IG9wdC5zaWRlIHx8ICdib3R0b20nO1xuICAgIHZhciBwYWRkaW5nID0gdXRpbC5ub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyB8fCA0MCk7XG5cbiAgICAvLyBMaW5rVmlldyBjb250YWlucyBjYWNoZWQgc291cmNlIGFuIHRhcmdldCBiYm94ZXMuXG4gICAgLy8gTm90ZSB0aGF0IHRob3NlIGFyZSBHZW9tZXRyeSByZWN0YW5nbGUgb2JqZWN0cy5cbiAgICB2YXIgc291cmNlQkJveCA9IGxpbmtWaWV3LnNvdXJjZUJCb3g7XG4gICAgdmFyIHRhcmdldEJCb3ggPSBsaW5rVmlldy50YXJnZXRCQm94O1xuICAgIHZhciBzb3VyY2VQb2ludCA9IHNvdXJjZUJCb3guY2VudGVyKCk7XG4gICAgdmFyIHRhcmdldFBvaW50ID0gdGFyZ2V0QkJveC5jZW50ZXIoKTtcblxuICAgIHZhciBjb29yZGluYXRlLCBkaW1lbnNpb24sIGRpcmVjdGlvbjtcblxuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneSc7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnaGVpZ2h0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3knO1xuICAgICAgICAgICAgZGltZW5zaW9uID0gJ2hlaWdodCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneCc7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnd2lkdGgnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3gnO1xuICAgICAgICAgICAgZGltZW5zaW9uID0gJ3dpZHRoJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZXI6IGludmFsaWQgc2lkZScpO1xuICAgIH1cblxuICAgIC8vIG1vdmUgdGhlIHBvaW50cyBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgdG8gb3V0c2lkZSBvZiBpdC5cbiAgICBzb3VyY2VQb2ludFtjb29yZGluYXRlXSArPSBkaXJlY3Rpb24gKiAoc291cmNlQkJveFtkaW1lbnNpb25dIC8gMiArIHBhZGRpbmdbc2lkZV0pO1xuICAgIHRhcmdldFBvaW50W2Nvb3JkaW5hdGVdICs9IGRpcmVjdGlvbiAqICh0YXJnZXRCQm94W2RpbWVuc2lvbl0gLyAyICsgcGFkZGluZ1tzaWRlXSk7XG5cbiAgICAvLyBtYWtlIGxpbmsgb3J0aG9nb25hbCAoYXQgbGVhc3QgdGhlIGZpcnN0IGFuZCBsYXN0IHZlcnRleCkuXG4gICAgaWYgKChkaXJlY3Rpb24gKiAoc291cmNlUG9pbnRbY29vcmRpbmF0ZV0gLSB0YXJnZXRQb2ludFtjb29yZGluYXRlXSkpID4gMCkge1xuICAgICAgICB0YXJnZXRQb2ludFtjb29yZGluYXRlXSA9IHNvdXJjZVBvaW50W2Nvb3JkaW5hdGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVBvaW50W2Nvb3JkaW5hdGVdID0gdGFyZ2V0UG9pbnRbY29vcmRpbmF0ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzb3VyY2VQb2ludF0uY29uY2F0KHZlcnRpY2VzLCB0YXJnZXRQb2ludCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/oneSide.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/orthogonal.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/orthogonal.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orthogonal: () => (/* binding */ orthogonal)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n\n    var p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n\n    return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n\n    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n\n    if (from.x === to.x) return (from.y > to.y) ? 'N' : 'S';\n    if (from.y === to.y) return (from.x > to.x) ? 'W' : 'E';\n    return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeSides(opt.padding || opt.elementPadding || 20);\n\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n\n    var p1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from.x, to.y);\n    var p2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n\n    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n\n    var p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n\n    var route = {};\n\n    var points = [new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from.x, to.y), new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to.x, from.y)];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n\n        route.points = [p];\n        route.direction = getBearing(p, to);\n\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n\n        p = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.difference(points, freePoints)[0];\n\n        var p2 = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n\n        route.points = [p1, p2];\n        route.direction = getBearing(p2, to);\n    }\n\n    return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n\n        if (toBBox.containsPoint(p2)) {\n\n            var fromBorder = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(fromBorder, toBorder)).midpoint();\n\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n            route.points = [startRoute.points[0], endRoute.points[0]];\n            route.direction = endRoute.direction;\n        }\n    }\n\n    return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n\n    var p1, p2, p3;\n\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n\n    if (p1.round().equals(p2.round())) {\n        p2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(boundary.width + boundary.height, _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n    } else {\n        route.points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n    return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nfunction orthogonal(vertices, opt, linkView) {\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n    vertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray(vertices).map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n\n    var bearing; // bearing of previous route segment\n\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n        var route = null;\n\n        var from = vertices[i];\n        var to = vertices[i + 1];\n\n        var isOrthogonal = !!getBearing(from, to);\n\n        if (i === 0) { // source\n\n            if (i + 1 === max) { // route source -> target\n\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n\n            } else { // route source -> vertex\n\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n\n        } else if (i + 1 === max) { // route vertex -> target\n\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n\n        } else if (!isOrthogonal) { // route vertex -> vertex\n            route = vertexVertex(from, to, bearing);\n        }\n\n        // applicable to all routes:\n\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n\n    return orthogonalVertices;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvb3J0aG9nb25hbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvQztBQUNNOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLCtDQUFPO0FBQ3ZCLHVDQUF1QywrQ0FBTztBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLDhDQUFNO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLDJEQUFtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTs7QUFFQTs7QUFFQSxpQkFBaUIsK0NBQU87QUFDeEIsaUJBQWlCLCtDQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7O0FBRUEsYUFBYTtBQUNiOztBQUVBOztBQUVBOztBQUVBLHNCQUFzQiwrQ0FBTyxvQkFBb0IsK0NBQU87QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSx1REFBZTs7QUFFM0Isc0JBQXNCLCtDQUFPO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQ0FBa0MsK0NBQU87QUFDekMsZ0NBQWdDLCtDQUFPO0FBQ3ZDLDJCQUEyQiw4Q0FBTTs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBTztBQUNwQjs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsK0NBQU8sNkNBQTZDLCtDQUFPO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsb0RBQVksZUFBZSwrQ0FBTztBQUNqRDtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakIsaUNBQWlDO0FBQ2pDLCtDQUErQyxTQUFTOztBQUV4RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1Qjs7QUFFdkIsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSxjQUFjLE9BQU87O0FBRXJCO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDBCQUEwQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFVBQVUsMEJBQTBCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9yb3V0ZXJzL29ydGhvZ29uYWwubWpzPzhmZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuLy8gYmVhcmluZyAtPiBvcHBvc2l0ZSBiZWFyaW5nXG52YXIgb3Bwb3NpdGVzID0ge1xuICAgIE46ICdTJyxcbiAgICBTOiAnTicsXG4gICAgRTogJ1cnLFxuICAgIFc6ICdFJ1xufTtcblxuLy8gYmVhcmluZyAtPiByYWRpYW5zXG52YXIgcmFkaWFucyA9IHtcbiAgICBOOiAtTWF0aC5QSSAvIDIgKiAzLFxuICAgIFM6IC1NYXRoLlBJIC8gMixcbiAgICBFOiAwLFxuICAgIFc6IE1hdGguUElcbn07XG5cbi8vIEhFTFBFUlMgLy9cblxuLy8gcmV0dXJucyBhIHBvaW50IGBwYCB3aGVyZSBsaW5lcyBwLHAxIGFuZCBwLHAyIGFyZSBwZXJwZW5kaWN1bGFyIGFuZCBwIGlzIG5vdCBjb250YWluZWRcbi8vIGluIHRoZSBnaXZlbiBib3hcbmZ1bmN0aW9uIGZyZWVKb2luKHAxLCBwMiwgYmJveCkge1xuXG4gICAgdmFyIHAgPSBuZXcgZy5Qb2ludChwMS54LCBwMi55KTtcbiAgICBpZiAoYmJveC5jb250YWluc1BvaW50KHApKSBwID0gbmV3IGcuUG9pbnQocDIueCwgcDEueSk7XG4gICAgLy8ga2VwdCBmb3IgcmVmZXJlbmNlXG4gICAgLy8gaWYgKGJib3guY29udGFpbnNQb2ludChwKSkgcCA9IG51bGw7XG5cbiAgICByZXR1cm4gcDtcbn1cblxuLy8gcmV0dXJucyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG9mIGEgYmJveCBiYXNlZCBvbiB0aGUgZ2l2ZW4gYmVhcmluZ1xuZnVuY3Rpb24gZ2V0QkJveFNpemUoYmJveCwgYmVhcmluZykge1xuXG4gICAgcmV0dXJuIGJib3hbKGJlYXJpbmcgPT09ICdXJyB8fCBiZWFyaW5nID09PSAnRScpID8gJ3dpZHRoJyA6ICdoZWlnaHQnXTtcbn1cblxuLy8gc2ltcGxlIGJlYXJpbmcgbWV0aG9kIChjYWxjdWxhdGVzIG9ubHkgb3J0aG9nb25hbCBjYXJkaW5hbHMpXG5mdW5jdGlvbiBnZXRCZWFyaW5nKGZyb20sIHRvKSB7XG5cbiAgICBpZiAoZnJvbS54ID09PSB0by54KSByZXR1cm4gKGZyb20ueSA+IHRvLnkpID8gJ04nIDogJ1MnO1xuICAgIGlmIChmcm9tLnkgPT09IHRvLnkpIHJldHVybiAoZnJvbS54ID4gdG8ueCkgPyAnVycgOiAnRSc7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHRyYW5zZm9ybSBwb2ludCB0byBhIHJlY3RcbmZ1bmN0aW9uIGdldFBvaW50Qm94KHApIHtcblxuICAgIHJldHVybiBuZXcgZy5SZWN0KHAueCwgcC55LCAwLCAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFkZGluZ0JveChvcHQpIHtcblxuICAgIC8vIGlmIGJvdGggcHJvdmlkZWQsIG9wdC5wYWRkaW5nIHdpbnMgb3ZlciBvcHQuZWxlbWVudFBhZGRpbmdcbiAgICB2YXIgc2lkZXMgPSB1dGlsLm5vcm1hbGl6ZVNpZGVzKG9wdC5wYWRkaW5nIHx8IG9wdC5lbGVtZW50UGFkZGluZyB8fCAyMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAtc2lkZXMubGVmdCxcbiAgICAgICAgeTogLXNpZGVzLnRvcCxcbiAgICAgICAgd2lkdGg6IHNpZGVzLmxlZnQgKyBzaWRlcy5yaWdodCxcbiAgICAgICAgaGVpZ2h0OiBzaWRlcy50b3AgKyBzaWRlcy5ib3R0b21cbiAgICB9O1xufVxuXG4vLyByZXR1cm4gc291cmNlIGJib3hcbmZ1bmN0aW9uIGdldFNvdXJjZUJCb3gobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgcmV0dXJuIGxpbmtWaWV3LnNvdXJjZUJCb3guY2xvbmUoKS5tb3ZlQW5kRXhwYW5kKGdldFBhZGRpbmdCb3gob3B0KSk7XG59XG5cbi8vIHJldHVybiB0YXJnZXQgYmJveFxuZnVuY3Rpb24gZ2V0VGFyZ2V0QkJveChsaW5rVmlldywgb3B0KSB7XG5cbiAgICByZXR1cm4gbGlua1ZpZXcudGFyZ2V0QkJveC5jbG9uZSgpLm1vdmVBbmRFeHBhbmQoZ2V0UGFkZGluZ0JveChvcHQpKTtcbn1cblxuLy8gcmV0dXJuIHNvdXJjZSBhbmNob3JcbmZ1bmN0aW9uIGdldFNvdXJjZUFuY2hvcihsaW5rVmlldywgb3B0KSB7XG5cbiAgICBpZiAobGlua1ZpZXcuc291cmNlQW5jaG9yKSByZXR1cm4gbGlua1ZpZXcuc291cmNlQW5jaG9yO1xuXG4gICAgLy8gZmFsbGJhY2s6IGNlbnRlciBvZiBiYm94XG4gICAgdmFyIHNvdXJjZUJCb3ggPSBnZXRTb3VyY2VCQm94KGxpbmtWaWV3LCBvcHQpO1xuICAgIHJldHVybiBzb3VyY2VCQm94LmNlbnRlcigpO1xufVxuXG4vLyByZXR1cm4gdGFyZ2V0IGFuY2hvclxuZnVuY3Rpb24gZ2V0VGFyZ2V0QW5jaG9yKGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIGlmIChsaW5rVmlldy50YXJnZXRBbmNob3IpIHJldHVybiBsaW5rVmlldy50YXJnZXRBbmNob3I7XG5cbiAgICAvLyBmYWxsYmFjazogY2VudGVyIG9mIGJib3hcbiAgICB2YXIgdGFyZ2V0QkJveCA9IGdldFRhcmdldEJCb3gobGlua1ZpZXcsIG9wdCk7XG4gICAgcmV0dXJuIHRhcmdldEJCb3guY2VudGVyKCk7IC8vIGRlZmF1bHRcbn1cblxuLy8gUEFSVElBTCBST1VURVJTIC8vXG5cbmZ1bmN0aW9uIHZlcnRleFZlcnRleChmcm9tLCB0bywgYmVhcmluZykge1xuXG4gICAgdmFyIHAxID0gbmV3IGcuUG9pbnQoZnJvbS54LCB0by55KTtcbiAgICB2YXIgcDIgPSBuZXcgZy5Qb2ludCh0by54LCBmcm9tLnkpO1xuICAgIHZhciBkMSA9IGdldEJlYXJpbmcoZnJvbSwgcDEpO1xuICAgIHZhciBkMiA9IGdldEJlYXJpbmcoZnJvbSwgcDIpO1xuICAgIHZhciBvcHBvc2l0ZSA9IG9wcG9zaXRlc1tiZWFyaW5nXTtcblxuICAgIHZhciBwID0gKGQxID09PSBiZWFyaW5nIHx8IChkMSAhPT0gb3Bwb3NpdGUgJiYgKGQyID09PSBvcHBvc2l0ZSB8fCBkMiAhPT0gYmVhcmluZykpKSA/IHAxIDogcDI7XG5cbiAgICByZXR1cm4geyBwb2ludHM6IFtwXSwgZGlyZWN0aW9uOiBnZXRCZWFyaW5nKHAsIHRvKSB9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50VmVydGV4KGZyb20sIHRvLCBmcm9tQkJveCkge1xuXG4gICAgdmFyIHAgPSBmcmVlSm9pbihmcm9tLCB0bywgZnJvbUJCb3gpO1xuXG4gICAgcmV0dXJuIHsgcG9pbnRzOiBbcF0sIGRpcmVjdGlvbjogZ2V0QmVhcmluZyhwLCB0bykgfTtcbn1cblxuZnVuY3Rpb24gdmVydGV4RWxlbWVudChmcm9tLCB0bywgdG9CQm94LCBiZWFyaW5nKSB7XG5cbiAgICB2YXIgcm91dGUgPSB7fTtcblxuICAgIHZhciBwb2ludHMgPSBbbmV3IGcuUG9pbnQoZnJvbS54LCB0by55KSwgbmV3IGcuUG9pbnQodG8ueCwgZnJvbS55KV07XG4gICAgdmFyIGZyZWVQb2ludHMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG4gICAgICAgIHJldHVybiAhdG9CQm94LmNvbnRhaW5zUG9pbnQocHQpO1xuICAgIH0pO1xuICAgIHZhciBmcmVlQmVhcmluZ1BvaW50cyA9IGZyZWVQb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG4gICAgICAgIHJldHVybiBnZXRCZWFyaW5nKHB0LCBmcm9tKSAhPT0gYmVhcmluZztcbiAgICB9KTtcblxuICAgIHZhciBwO1xuXG4gICAgaWYgKGZyZWVCZWFyaW5nUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVHJ5IHRvIHBpY2sgYSBwb2ludCB3aGljaCBiZWFycyB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhlIHByZXZpb3VzIHNlZ21lbnQuXG5cbiAgICAgICAgcCA9IGZyZWVCZWFyaW5nUG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJlYXJpbmcoZnJvbSwgcHQpID09PSBiZWFyaW5nO1xuICAgICAgICB9KS5wb3AoKTtcbiAgICAgICAgcCA9IHAgfHwgZnJlZUJlYXJpbmdQb2ludHNbMF07XG5cbiAgICAgICAgcm91dGUucG9pbnRzID0gW3BdO1xuICAgICAgICByb3V0ZS5kaXJlY3Rpb24gPSBnZXRCZWFyaW5nKHAsIHRvKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhlcmUgd2UgZm91bmQgb25seSBwb2ludHMgd2hpY2ggYXJlIGVpdGhlciBjb250YWluZWQgaW4gdGhlIGVsZW1lbnQgb3IgdGhleSB3b3VsZCBjcmVhdGVcbiAgICAgICAgLy8gYSBsaW5rIHNlZ21lbnQgZ29pbmcgaW4gb3Bwb3NpdGUgZGlyZWN0aW9uIGZyb20gdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgLy8gV2UgdGFrZSB0aGUgcG9pbnQgaW5zaWRlIGVsZW1lbnQgYW5kIG1vdmUgaXQgb3V0c2lkZSB0aGUgZWxlbWVudCBpbiB0aGUgZGlyZWN0aW9uIHRoZVxuICAgICAgICAvLyByb3V0ZSBpcyBnb2luZy4gTm93IHdlIGNhbiBqb2luIHRoaXMgcG9pbnQgd2l0aCB0aGUgY3VycmVudCBlbmQgKHVzaW5nIGZyZWVKb2luKS5cblxuICAgICAgICBwID0gdXRpbC5kaWZmZXJlbmNlKHBvaW50cywgZnJlZVBvaW50cylbMF07XG5cbiAgICAgICAgdmFyIHAyID0gKG5ldyBnLlBvaW50KHRvKSkubW92ZShwLCAtZ2V0QkJveFNpemUodG9CQm94LCBiZWFyaW5nKSAvIDIpO1xuICAgICAgICB2YXIgcDEgPSBmcmVlSm9pbihwMiwgZnJvbSwgdG9CQm94KTtcblxuICAgICAgICByb3V0ZS5wb2ludHMgPSBbcDEsIHAyXTtcbiAgICAgICAgcm91dGUuZGlyZWN0aW9uID0gZ2V0QmVhcmluZyhwMiwgdG8pO1xuICAgIH1cblxuICAgIHJldHVybiByb3V0ZTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudEVsZW1lbnQoZnJvbSwgdG8sIGZyb21CQm94LCB0b0JCb3gpIHtcblxuICAgIHZhciByb3V0ZSA9IGVsZW1lbnRWZXJ0ZXgodG8sIGZyb20sIHRvQkJveCk7XG4gICAgdmFyIHAxID0gcm91dGUucG9pbnRzWzBdO1xuXG4gICAgaWYgKGZyb21CQm94LmNvbnRhaW5zUG9pbnQocDEpKSB7XG5cbiAgICAgICAgcm91dGUgPSBlbGVtZW50VmVydGV4KGZyb20sIHRvLCBmcm9tQkJveCk7XG4gICAgICAgIHZhciBwMiA9IHJvdXRlLnBvaW50c1swXTtcblxuICAgICAgICBpZiAodG9CQm94LmNvbnRhaW5zUG9pbnQocDIpKSB7XG5cbiAgICAgICAgICAgIHZhciBmcm9tQm9yZGVyID0gKG5ldyBnLlBvaW50KGZyb20pKS5tb3ZlKHAyLCAtZ2V0QkJveFNpemUoZnJvbUJCb3gsIGdldEJlYXJpbmcoZnJvbSwgcDIpKSAvIDIpO1xuICAgICAgICAgICAgdmFyIHRvQm9yZGVyID0gKG5ldyBnLlBvaW50KHRvKSkubW92ZShwMSwgLWdldEJCb3hTaXplKHRvQkJveCwgZ2V0QmVhcmluZyh0bywgcDEpKSAvIDIpO1xuICAgICAgICAgICAgdmFyIG1pZCA9IChuZXcgZy5MaW5lKGZyb21Cb3JkZXIsIHRvQm9yZGVyKSkubWlkcG9pbnQoKTtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0Um91dGUgPSBlbGVtZW50VmVydGV4KGZyb20sIG1pZCwgZnJvbUJCb3gpO1xuICAgICAgICAgICAgdmFyIGVuZFJvdXRlID0gdmVydGV4VmVydGV4KG1pZCwgdG8sIHN0YXJ0Um91dGUuZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgcm91dGUucG9pbnRzID0gW3N0YXJ0Um91dGUucG9pbnRzWzBdLCBlbmRSb3V0ZS5wb2ludHNbMF1dO1xuICAgICAgICAgICAgcm91dGUuZGlyZWN0aW9uID0gZW5kUm91dGUuZGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlO1xufVxuXG4vLyBGaW5kcyByb3V0ZSBmb3Igc2l0dWF0aW9ucyB3aGVyZSBvbmUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIG90aGVyLlxuLy8gVHlwaWNhbGx5IHRoZSByb3V0ZSBpcyBkaXJlY3RlZCBvdXRzaWRlIHRoZSBvdXRlciBlbGVtZW50IGZpcnN0IGFuZFxuLy8gdGhlbiBiYWNrIHRvd2FyZHMgdGhlIGlubmVyIGVsZW1lbnQuXG5mdW5jdGlvbiBpbnNpZGVFbGVtZW50KGZyb20sIHRvLCBmcm9tQkJveCwgdG9CQm94LCBiZWFyaW5nKSB7XG5cbiAgICB2YXIgcm91dGUgPSB7fTtcbiAgICB2YXIgYm91bmRhcnkgPSBmcm9tQkJveC51bmlvbih0b0JCb3gpLmluZmxhdGUoMSk7XG5cbiAgICAvLyBzdGFydCBmcm9tIHRoZSBwb2ludCB3aGljaCBpcyBjbG9zZXIgdG8gdGhlIGJvdW5kYXJ5XG4gICAgdmFyIHJldmVyc2VkID0gYm91bmRhcnkuY2VudGVyKCkuZGlzdGFuY2UodG8pID4gYm91bmRhcnkuY2VudGVyKCkuZGlzdGFuY2UoZnJvbSk7XG4gICAgdmFyIHN0YXJ0ID0gcmV2ZXJzZWQgPyB0byA6IGZyb207XG4gICAgdmFyIGVuZCA9IHJldmVyc2VkID8gZnJvbSA6IHRvO1xuXG4gICAgdmFyIHAxLCBwMiwgcDM7XG5cbiAgICBpZiAoYmVhcmluZykge1xuICAgICAgICAvLyBQb2ludHMgb24gY2lyY2xlIHdpdGggcmFkaXVzIGVxdWFscyAnVyArIEhgIGFyZSBhbHdheXMgb3V0c2lkZSB0aGUgcmVjdGFuZ2xlXG4gICAgICAgIC8vIHdpdGggd2lkdGggVyBhbmQgaGVpZ2h0IEggaWYgdGhlIGNlbnRlciBvZiB0aGF0IGNpcmNsZSBpcyB0aGUgY2VudGVyIG9mIHRoYXQgcmVjdGFuZ2xlLlxuICAgICAgICBwMSA9IGcuUG9pbnQuZnJvbVBvbGFyKGJvdW5kYXJ5LndpZHRoICsgYm91bmRhcnkuaGVpZ2h0LCByYWRpYW5zW2JlYXJpbmddLCBzdGFydCk7XG4gICAgICAgIHAxID0gYm91bmRhcnkucG9pbnROZWFyZXN0VG9Qb2ludChwMSkubW92ZShwMSwgLTEpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcDEgPSBib3VuZGFyeS5wb2ludE5lYXJlc3RUb1BvaW50KHN0YXJ0KS5tb3ZlKHN0YXJ0LCAxKTtcbiAgICB9XG5cbiAgICBwMiA9IGZyZWVKb2luKHAxLCBlbmQsIGJvdW5kYXJ5KTtcblxuICAgIGlmIChwMS5yb3VuZCgpLmVxdWFscyhwMi5yb3VuZCgpKSkge1xuICAgICAgICBwMiA9IGcuUG9pbnQuZnJvbVBvbGFyKGJvdW5kYXJ5LndpZHRoICsgYm91bmRhcnkuaGVpZ2h0LCBnLnRvUmFkKHAxLnRoZXRhKHN0YXJ0KSkgKyBNYXRoLlBJIC8gMiwgZW5kKTtcbiAgICAgICAgcDIgPSBib3VuZGFyeS5wb2ludE5lYXJlc3RUb1BvaW50KHAyKS5tb3ZlKGVuZCwgMSkucm91bmQoKTtcbiAgICAgICAgcDMgPSBmcmVlSm9pbihwMSwgcDIsIGJvdW5kYXJ5KTtcbiAgICAgICAgcm91dGUucG9pbnRzID0gcmV2ZXJzZWQgPyBbcDIsIHAzLCBwMV0gOiBbcDEsIHAzLCBwMl07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZS5wb2ludHMgPSByZXZlcnNlZCA/IFtwMiwgcDFdIDogW3AxLCBwMl07XG4gICAgfVxuXG4gICAgcm91dGUuZGlyZWN0aW9uID0gcmV2ZXJzZWQgPyBnZXRCZWFyaW5nKHAxLCB0bykgOiBnZXRCZWFyaW5nKHAyLCB0byk7XG5cbiAgICByZXR1cm4gcm91dGU7XG59XG5cbi8vIE1BSU4gUk9VVEVSIC8vXG5cbi8vIFJldHVybiBwb2ludHMgdGhyb3VnaCB3aGljaCBhIGNvbm5lY3Rpb24gbmVlZHMgdG8gYmUgZHJhd24gaW4gb3JkZXIgdG8gb2J0YWluIGFuIG9ydGhvZ29uYWwgbGlua1xuLy8gcm91dGluZyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgZ29pbmcgdGhyb3VnaCBgdmVydGljZXNgLlxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvZ29uYWwodmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgIHZhciBzb3VyY2VCQm94ID0gZ2V0U291cmNlQkJveChsaW5rVmlldywgb3B0KTtcbiAgICB2YXIgdGFyZ2V0QkJveCA9IGdldFRhcmdldEJCb3gobGlua1ZpZXcsIG9wdCk7XG5cbiAgICB2YXIgc291cmNlQW5jaG9yID0gZ2V0U291cmNlQW5jaG9yKGxpbmtWaWV3LCBvcHQpO1xuICAgIHZhciB0YXJnZXRBbmNob3IgPSBnZXRUYXJnZXRBbmNob3IobGlua1ZpZXcsIG9wdCk7XG5cbiAgICAvLyBpZiBhbmNob3IgbGllcyBvdXRzaWRlIG9mIGJib3gsIHRoZSBiYm94IGV4cGFuZHMgdG8gaW5jbHVkZSBpdFxuICAgIHNvdXJjZUJCb3ggPSBzb3VyY2VCQm94LnVuaW9uKGdldFBvaW50Qm94KHNvdXJjZUFuY2hvcikpO1xuICAgIHRhcmdldEJCb3ggPSB0YXJnZXRCQm94LnVuaW9uKGdldFBvaW50Qm94KHRhcmdldEFuY2hvcikpO1xuXG4gICAgdmVydGljZXMgPSB1dGlsLnRvQXJyYXkodmVydGljZXMpLm1hcChnLlBvaW50KTtcbiAgICB2ZXJ0aWNlcy51bnNoaWZ0KHNvdXJjZUFuY2hvcik7XG4gICAgdmVydGljZXMucHVzaCh0YXJnZXRBbmNob3IpO1xuXG4gICAgdmFyIGJlYXJpbmc7IC8vIGJlYXJpbmcgb2YgcHJldmlvdXMgcm91dGUgc2VnbWVudFxuXG4gICAgdmFyIG9ydGhvZ29uYWxWZXJ0aWNlcyA9IFtdOyAvLyB0aGUgYXJyYXkgb2YgZm91bmQgb3J0aG9nb25hbCB2ZXJ0aWNlcyB0byBiZSByZXR1cm5lZFxuICAgIGZvciAodmFyIGkgPSAwLCBtYXggPSB2ZXJ0aWNlcy5sZW5ndGggLSAxOyBpIDwgbWF4OyBpKyspIHtcblxuICAgICAgICB2YXIgcm91dGUgPSBudWxsO1xuXG4gICAgICAgIHZhciBmcm9tID0gdmVydGljZXNbaV07XG4gICAgICAgIHZhciB0byA9IHZlcnRpY2VzW2kgKyAxXTtcblxuICAgICAgICB2YXIgaXNPcnRob2dvbmFsID0gISFnZXRCZWFyaW5nKGZyb20sIHRvKTtcblxuICAgICAgICBpZiAoaSA9PT0gMCkgeyAvLyBzb3VyY2VcblxuICAgICAgICAgICAgaWYgKGkgKyAxID09PSBtYXgpIHsgLy8gcm91dGUgc291cmNlIC0+IHRhcmdldFxuXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIG9uZSBvZiB0aGUgZWxlbWVudHMgYnkgMXB4IHRvIGRldGVjdCBzaXR1YXRpb25zIHdoZW4gdGhlIHR3b1xuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzIGFyZSBwb3NpdGlvbmVkIG5leHQgdG8gZWFjaCBvdGhlciB3aXRoIG5vIGdhcCBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VCQm94LmludGVyc2VjdCh0YXJnZXRCQm94LmNsb25lKCkuaW5mbGF0ZSgxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBpbnNpZGVFbGVtZW50KGZyb20sIHRvLCBzb3VyY2VCQm94LCB0YXJnZXRCQm94KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT3J0aG9nb25hbCkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IGVsZW1lbnRFbGVtZW50KGZyb20sIHRvLCBzb3VyY2VCQm94LCB0YXJnZXRCQm94KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHJvdXRlIHNvdXJjZSAtPiB2ZXJ0ZXhcblxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gaW5zaWRlRWxlbWVudChmcm9tLCB0bywgc291cmNlQkJveCwgZ2V0UG9pbnRCb3godG8pLm1vdmVBbmRFeHBhbmQoZ2V0UGFkZGluZ0JveChvcHQpKSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09ydGhvZ29uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBlbGVtZW50VmVydGV4KGZyb20sIHRvLCBzb3VyY2VCQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbWF4KSB7IC8vIHJvdXRlIHZlcnRleCAtPiB0YXJnZXRcblxuICAgICAgICAgICAgLy8gcHJldmVudCBvdmVybGFwcyB3aXRoIHByZXZpb3VzIGxpbmUgc2VnbWVudFxuICAgICAgICAgICAgdmFyIGlzT3J0aG9nb25hbExvb3AgPSBpc09ydGhvZ29uYWwgJiYgZ2V0QmVhcmluZyh0bywgZnJvbSkgPT09IGJlYXJpbmc7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRCQm94LmNvbnRhaW5zUG9pbnQoZnJvbSkgfHwgaXNPcnRob2dvbmFsTG9vcCkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gaW5zaWRlRWxlbWVudChmcm9tLCB0bywgZ2V0UG9pbnRCb3goZnJvbSkubW92ZUFuZEV4cGFuZChnZXRQYWRkaW5nQm94KG9wdCkpLCB0YXJnZXRCQm94LCBiZWFyaW5nKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNPcnRob2dvbmFsKSB7XG4gICAgICAgICAgICAgICAgcm91dGUgPSB2ZXJ0ZXhFbGVtZW50KGZyb20sIHRvLCB0YXJnZXRCQm94LCBiZWFyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKCFpc09ydGhvZ29uYWwpIHsgLy8gcm91dGUgdmVydGV4IC0+IHZlcnRleFxuICAgICAgICAgICAgcm91dGUgPSB2ZXJ0ZXhWZXJ0ZXgoZnJvbSwgdG8sIGJlYXJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwbGljYWJsZSB0byBhbGwgcm91dGVzOlxuXG4gICAgICAgIC8vIHNldCBiZWFyaW5nIGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG9ydGhvZ29uYWxWZXJ0aWNlcywgcm91dGUucG9pbnRzKTtcbiAgICAgICAgICAgIGJlYXJpbmcgPSByb3V0ZS5kaXJlY3Rpb247XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9ydGhvZ29uYWwgcm91dGUgYW5kIG5vdCBsb29wZWRcbiAgICAgICAgICAgIGJlYXJpbmcgPSBnZXRCZWFyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHB1c2ggYHRvYCBwb2ludCB0byBpZGVudGlmaWVkIG9ydGhvZ29uYWwgdmVydGljZXMgYXJyYXlcbiAgICAgICAgaWYgKGkgKyAxIDwgbWF4KSB7XG4gICAgICAgICAgICBvcnRob2dvbmFsVmVydGljZXMucHVzaCh0byk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3J0aG9nb25hbFZlcnRpY2VzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/orthogonal.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/routers/rightAngle.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/rightAngle.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rightAngle: () => (/* binding */ rightAngle)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/index.mjs\");\n\n\nconst Directions = {\n    AUTO: 'auto',\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    ANCHOR_SIDE: 'anchor-side',\n    MAGNET_SIDE: 'magnet-side'\n};\n\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\n\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\n\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\n\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Polyline(points).simplify({ threshold: 1 }).points;\n}\n\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n\n    let sourceSide;\n\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n\n    let targetSide;\n\n    if (!targetView) {\n        const targetLinkAnchorBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n\n    return [sourceSide, targetSide];\n}\n\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty > smy0) return Directions.TOP;\n    if (tx > smx1 && ty > smy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.BOTTOM;\n}\n\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty < smy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty < smy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.TOP;\n}\n\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= smx0 && ty < smy0) return Directions.LEFT;\n    if (tx >= smx0 && ty > smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.RIGHT;\n}\n\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= smx1 && ty < smy0) return Directions.RIGHT;\n    if (tx <= smx1 && ty > smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.LEFT;\n}\n\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n\n    switch (sourceSide) {\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\n\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n\n    switch (roundedAngle) {\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\n\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n\n    const isElement = view && view.model.isElement();\n\n    const {\n        x: x0,\n        y: y0,\n        width = 0,\n        height = 0\n    } = isElement ? _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\n\nfunction pointDataFromVertex({ x, y }) {\n    const point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x, y);\n\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\n\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n\n    const { x0, y0, width, height } = pointData;\n\n    switch (side) {\n        case 'left':\n            outsidePoint.x = x0 - margin;\n            break;\n        case 'right':\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case 'top':\n            outsidePoint.y = y0 - margin;\n            break;\n        case 'bottom':\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n\n    return outsidePoint;\n}\n\nfunction createLoop(from, to, { dx = 0, dy = 0 }) {\n    const p1 = { x: from.point.x + dx, y: from.point.y + dy };\n    const p2 = { x: to.point.x + dx, y: to.point.y + dy };\n\n    return [from.point, p1, p2, to.point];\n}\n\nfunction loopSegment(from, to, connectionSegmentAngle, margin) {\n    // Find out the loop coordinates.\n    const angle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeAngle(connectionSegmentAngle - 90);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (angle === 90) {\n        dy = -margin;\n    } else if (angle === 180) {\n        dx = -margin;\n    } else if (angle === 270) {\n        dy = margin;\n    } else if (angle === 0) {\n        dx = margin;\n    }\n\n    const loopRoute = createLoop(from, to, { dx, dy });\n\n    const secondCreatedPoint = loopRoute[2];\n    const loopEndSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(to.point, secondCreatedPoint);\n    // The direction in which the loop should continue.\n    const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\n    return {\n        loopRoute,\n        continueDirection\n    };\n}\n\n// Calculates the distances along the horizontal axis for the left and right route.\nfunction getHorizontalDistance(source, target) {\n\n    const { x0: sx0, x1: sx1, outsidePoint: sourcePoint } = source;\n    const { x0: tx0, x1: tx1, outsidePoint: targetPoint } = target;\n\n    // Furthest left boundary\n    let leftBoundary = Math.min(sx0, tx0);\n    // Furthest right boundary\n    let rightBoundary = Math.max(sx1, tx1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const aboveShape = source.y0 < target.y0 ? source : target;\n        const belowShape = aboveShape === source ? target : source;\n\n        // The source and target anchors are on the top => then the `aboveShape` defines the boundary.\n        // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;\n\n        leftBoundary = boundaryDefiningShape.x0;\n        rightBoundary = boundaryDefiningShape.x1;\n    }\n\n    const { x: sox } = sourcePoint;\n    const { x: tox } = targetPoint;\n\n    // Calculate the distances for the left route\n    const leftDistance1 = Math.abs(sox - leftBoundary);\n    const leftDistance2 = Math.abs(tox - leftBoundary);\n    const leftD = leftDistance1 + leftDistance2;\n\n    // Calculate the distances for the right route\n    const rightDistance1 = Math.abs(sox - rightBoundary);\n    const rightDistance2 = Math.abs(tox - rightBoundary);\n    const rightD = rightDistance1 + rightDistance2;\n\n    return [leftD, rightD];\n}\n\n// Calculates the distances along the vertical axis for the top and bottom route.\nfunction getVerticalDistance(source, target) {\n\n    const { y0: sy0, y1: sy1, outsidePoint: sourcePoint } = source;\n    const { y0: ty0, y1: ty1, outsidePoint: targetPoint } = target;\n\n    // Furthest top boundary\n    let topBoundary = Math.min(sy0, ty0);\n    // Furthest bottom boundary\n    let bottomBoundary = Math.max(sy1, ty1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const leftShape = source.x0 < target.x0 ? source : target;\n        const rightShape = leftShape === source ? target : source;\n\n        // The source and target anchors are on the left => then the `leftShape` defines the boundary.\n        // The source and target anchors are on the right => then the `rightShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;\n\n        topBoundary = boundaryDefiningShape.y0;\n        bottomBoundary = boundaryDefiningShape.y1;  \n    }\n\n    const { y: soy } = sourcePoint;\n    const { y: toy } = targetPoint;\n\n    // Calculate the distances for the top route\n    const topDistance1 = Math.abs(soy - topBoundary);\n    const topDistance2 = Math.abs(toy - topBoundary);\n    const topD = topDistance1 + topDistance2;\n\n    // Calculate the distances for the bottom route\n    const bottomDistance1 = Math.abs(soy - bottomBoundary);\n    const bottomDistance2 = Math.abs(toy - bottomBoundary);\n    const bottomD = bottomDistance1 + bottomDistance2;\n\n    return [topD, bottomD];\n}\n\n// Inflate bbox in 3 directions depending on the direction of the anchor\n// don't inflate in the opposite direction of the anchor\nfunction moveAndExpandBBox(bbox, direction, margin) {\n    switch (direction) {\n        case Directions.LEFT:\n            bbox.inflate(0, margin).moveAndExpand({ x: -margin, width: margin });\n            break;\n        case Directions.RIGHT:\n            bbox.inflate(0, margin).moveAndExpand({ width: margin });\n            break;\n        case Directions.TOP:\n            bbox.inflate(margin, 0).moveAndExpand({ y: -margin, height: margin });\n            break;\n        case Directions.BOTTOM:\n            bbox.inflate(margin, 0).moveAndExpand({ height: margin });\n            break;\n    }\n\n    return bbox;\n}\n\nfunction routeBetweenPoints(source, target, opt = {}) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n    const { targetInSourceBBox = false } = opt;\n\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n\n    const [sourceSide, targetSide] = resolveSides(source, target);\n\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight }, targetMargin);\n\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n    const sourceBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(sx0, sy0, sourceWidth, sourceHeight);\n    const targetBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(tx0, ty0, targetWidth, targetHeight);\n    const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n    const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\n    const sourceForDistance = Object.assign({}, source, { x1: sx1, y1: sy1, outsidePoint: sourceOutsidePoint, direction: sourceSide });\n    const targetForDistance = Object.assign({}, target, { x1: tx1, y1: ty1, outsidePoint: targetOutsidePoint, direction: targetSide });\n\n    // Distances used to determine the shortest route along the connections on horizontal sides for\n    // bottom => bottom\n    // top => bottom\n    // bottom => top\n    // top => top\n    const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);\n\n    // Distances used to determine the shortest route along the connection on vertical sides for\n    // left => left\n    // left => right\n    // right => right\n    // right => left\n    const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);\n\n    // All possible combinations of source and target sides\n    if (sourceSide === 'left' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx0 < tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.min(sox, tmx0);\n                x2 = Math.max(tox, smx1);\n            \n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on minimal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on maximal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy },\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx1 > tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.max(sox, tmx1);\n                x2 = Math.min(tox, smx0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on maximal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on minimal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy0 < toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n\n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.min(soy, tmy0);\n                y2 = Math.max(toy, smy1);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on minimal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on maximal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy1 > toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n            \n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.max(soy, tmy1);\n                y2 = Math.min(toy, smy0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on maximal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on minimal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'top') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox)) ||\n            (soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.min(soy, toy) },\n                { x: tox, y: Math.min(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n\n        if (toy < soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox)) ||\n            (soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.max(soy, toy) },\n                { x: tox, y: Math.max(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n\n        if (toy > soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'left') {\n        const useUShapeConnection = \n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy)) ||\n            (sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.min(sox, tox), y: soy },\n                { x: Math.min(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n\n        if (tox > sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'right') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy)) ||\n            (sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.max(sox, tox), y: soy },\n                { x: Math.max(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n\n        if (tox <= sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox < tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox > tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }];\n        }\n\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox < tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox > tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x < smx1 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.min(smx0, tmx0);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy < toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const y = Math.min(soy - sourceMargin, toy);\n                const x = Math.min(smx0, tmx0);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Add the `sourceMargin` since the source anchor is above the target anchor\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy > toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.min(smy0, tmy0);\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.min(soy - sourceMargin, toy);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y }, // Path adjustment for right side start\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Adjust sourceMargin calculation since the source anchor is now on the right\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy > toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.min(smy0, tmy0);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy < toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    }\n}\n\nfunction getLoopCoordinates(direction, angle, margin) {\n    const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;\n\n    let dx = 0;\n    let dy = 0;\n\n    switch (_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeAngle(Math.round(angle))) {\n        case 0:\n        case 90:\n            dx = isHorizontal ? 0 : margin;\n            dy = isHorizontal ? margin : 0;\n            break;\n        case 180:\n        case 270:\n            dx = isHorizontal ? 0 : -margin;\n            dy = isHorizontal ? -margin : 0;\n            break;\n    }\n\n    return { dx, dy };\n}\n\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\n    let resultVertices = [];\n\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n\n    const verticesData = vertices.map((v) => pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n\n    const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);\n    const isElement = sourcePoint.view && sourcePoint.view.model.isElement();\n    const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;\n    const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;\n\n    if (isVertexInside) {\n        const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);\n        const firstPointOverlap = outsidePoint.equals(firstVertex.point);\n\n        const alignsVertically = sourcePoint.point.x === firstVertex.point.x;\n        const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;\n\n        const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);\n        const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);\n\n        const firstSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(sourcePoint.point, outsidePoint);\n        const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);\n\n        const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);\n\n        \n\n        if (firstPointOverlap) {\n            resultVertices.push(sourcePoint.point, firstVertex.point);\n            // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex\n            firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];\n        } else if (isVertexOnSegment || isVertexAlignedAndInside) {\n            // Case where there is a need to create a loop\n            const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(sourcePoint.point, firstVertex.point));\n            const { dx, dy } = getLoopCoordinates(resolvedSourceDirection, angle, margin);\n\n            const loop = createLoop({ point: outsidePoint }, firstVertex, { dx, dy });\n            const secondCreatedPoint = loop[2];\n            const loopEndSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(firstVertex.point, secondCreatedPoint);\n\n            const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n            firstVertex.direction = accessDirection;\n            resultVertices.push(...loop);\n        } else {\n            // No need to create a route, use the `routeBetweenPoints` to construct a route\n            firstVertex.direction = resolvedSourceDirection;\n            firstVertex.margin = margin;\n            resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, { targetInSourceBBox: true }), firstVertex.point);\n        }\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n\n    for (let i = 0; i < verticesData.length - 1; i++) {\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n\n        const connectionSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);\n            // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);\n            // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n            // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];\n            // console.log(accessDirection);\n            // console.log(accessDirection2);\n            // if (accessDirection !== accessDirection2) {\n            //     console.log('error');\n            // }\n            // console.log('------------------');\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly\n                resultVertices.push(from.point, to.point);\n                const [, toDirection] = resolveSides(from, to);\n                to.direction = toDirection;\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute, continueDirection } = loopSegment(from, to, connectionSegmentAngle, margin);\n                to.direction = continueDirection;\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n\n            continue;\n        }\n\n        // Vertices are not aligned vertically nor horizontally\n        // so we need to route between them\n\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n\n        from.direction = fromDirection;\n        to.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n\n    const lastVertex = verticesData[verticesData.length - 1];\n\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);\n        const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);\n\n        // the last point of `simplified` array is the last defined vertex\n        // this will ensure that the last segment continues in a straight line\n        const simplified = simplifyPoints([...resultVertices, lastVertex.point]);\n        const simplifiedSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);\n        const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));\n        const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];\n\n        const lastPointOverlap = outsidePoint.equals(lastVertex.point);\n\n        if (!lastPointOverlap || (lastPointOverlap && definedDirection === resolvedTargetDirection)) {\n\n            lastVertex.direction = definedDirection;\n\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\n            const lastSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\n            const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);\n\n            const alignsVertically = lastVertex.point.x === targetPoint.point.x;\n            const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;\n            const isVertexInside = targetBBox.containsPoint(lastVertex.point);\n\n            const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);\n            const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);\n\n            \n            if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {\n                // Handle special cases when the last vertex is inside the target element\n                // and in is aligned with the connection point => construct a loop\n                const { dx, dy } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);\n                lastSegmentRoute = createLoop(lastVertex, { point: outsidePoint }, { dx, dy });\n            } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {\n                lastVertex.margin = margin;\n                lastVertex.direction = resolvedTargetDirection;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const from = lastVertex;\n        const to = targetPoint;\n\n        const connectionSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints(resultVertices);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly by adding the first point\n                // the target point is handled separately\n                resultVertices.push(from.point);\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute } = loopSegment(from, to, connectionSegmentAngle, margin);\n                // Remove the last point since it is the target that is handled separately\n                loopRoute.pop();\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n        } else {\n            // The last vertex and the target are not aligned vertically nor horizontally\n            // so we need to route between them\n            const [fromDirection, toDirection] = resolveDirection(from, to);\n\n            from.direction = fromDirection;\n            to.direction = toDirection;\n\n            resultVertices.push(...routeBetweenPoints(from, to));\n        }\n    }\n\n    return simplifyPoints(resultVertices);\n}\n\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n\n    return [sourceDirection, targetDirection];\n}\n\nrightAngleRouter.Directions = Directions;\n\nconst rightAngle = rightAngleRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvcmlnaHRBbmdsZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBVSxvQkFBb0IsY0FBYztBQUMzRDs7QUFFQTtBQUNBLFlBQVksdUdBQXVHO0FBQ25ILFlBQVksdUdBQXVHOztBQUVuSDs7QUFFQTtBQUNBLHlDQUF5Qyw4Q0FBTTtBQUMvQztBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUNBQXlDLDhDQUFNO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVkseURBQXlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRO0FBQ3BCLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHlEQUF5RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksUUFBUTtBQUNwQixZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFTyIsInNvdXJjZXMiOlsid2VicGFjazovL2dyYXBoLXZpc3VhbGl6ZXIvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvcmlnaHRBbmdsZS5tanM/M2UxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgRGlyZWN0aW9ucyA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIFRPUDogJ3RvcCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBBTkNIT1JfU0lERTogJ2FuY2hvci1zaWRlJyxcbiAgICBNQUdORVRfU0lERTogJ21hZ25ldC1zaWRlJ1xufTtcblxuY29uc3QgREVGSU5FRF9ESVJFQ1RJT05TID0gW0RpcmVjdGlvbnMuTEVGVCwgRGlyZWN0aW9ucy5SSUdIVCwgRGlyZWN0aW9ucy5UT1AsIERpcmVjdGlvbnMuQk9UVE9NXTtcblxuY29uc3QgT1BQT1NJVEVfRElSRUNUSU9OUyA9IHtcbiAgICBbRGlyZWN0aW9ucy5MRUZUXTogRGlyZWN0aW9ucy5SSUdIVCxcbiAgICBbRGlyZWN0aW9ucy5SSUdIVF06IERpcmVjdGlvbnMuTEVGVCxcbiAgICBbRGlyZWN0aW9ucy5UT1BdOiBEaXJlY3Rpb25zLkJPVFRPTSxcbiAgICBbRGlyZWN0aW9ucy5CT1RUT01dOiBEaXJlY3Rpb25zLlRPUFxufTtcblxuY29uc3QgVkVSVElDQUxfRElSRUNUSU9OUyA9IFtEaXJlY3Rpb25zLlRPUCwgRGlyZWN0aW9ucy5CT1RUT01dO1xuXG5jb25zdCBBTkdMRV9ESVJFQ1RJT05fTUFQID0ge1xuICAgIDA6IERpcmVjdGlvbnMuUklHSFQsXG4gICAgMTgwOiBEaXJlY3Rpb25zLkxFRlQsXG4gICAgMjcwOiBEaXJlY3Rpb25zLlRPUCxcbiAgICA5MDogRGlyZWN0aW9ucy5CT1RUT01cbn07XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnRBbmdsZShsaW5lKSB7XG4gICAgLy8gVE9ETzogdGhlIGFuZ2xlKCkgbWV0aG9kIGlzIGdlbmVyYWwgYW5kIHRoZXJlZm9yZSB1bm5lY2Vzc2FyaWx5IGhlYXZ5IGZvciBvcnRob2dvbmFsIGxpbmtzXG4gICAgcmV0dXJuIGxpbmUuYW5nbGUoKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlQb2ludHMocG9pbnRzKSB7XG4gICAgLy8gVE9ETzogdXNlIG93biBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiAoZmlsdGVyIHBvaW50cyB0aGF0IGRvIG5vdCBjaGFuZ2UgZGlyZWN0aW9uKS5cbiAgICAvLyBUbyBzaW1wbGlmeSBzZWdtZW50cyB0aGF0IGFyZSBhbG1vc3QgYWxpZ25lZCAoc3RhcnQgYW5kIGVuZCBwb2ludHMgZGlmZmVyIGJ5IGUuZy4gMC41cHgpLCB1c2UgYSB0aHJlc2hvbGQgb2YgMS5cbiAgICByZXR1cm4gbmV3IGcuUG9seWxpbmUocG9pbnRzKS5zaW1wbGlmeSh7IHRocmVzaG9sZDogMSB9KS5wb2ludHM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTaWRlcyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGNvbnN0IHsgcG9pbnQ6IHNvdXJjZVBvaW50LCB4MDogc3gwLCB5MDogc3kwLCB2aWV3OiBzb3VyY2VWaWV3LCBiYm94OiBzb3VyY2VCQm94LCBkaXJlY3Rpb246IHNvdXJjZURpcmVjdGlvbiB9ID0gc291cmNlO1xuICAgIGNvbnN0IHsgcG9pbnQ6IHRhcmdldFBvaW50LCB4MDogdHgwLCB5MDogdHkwLCB2aWV3OiB0YXJnZXRWaWV3LCBiYm94OiB0YXJnZXRCQm94LCBkaXJlY3Rpb246IHRhcmdldERpcmVjdGlvbiB9ID0gdGFyZ2V0O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG5cbiAgICBpZiAoIXNvdXJjZVZpZXcpIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGlua0FuY2hvckJCb3ggPSBuZXcgZy5SZWN0KHN4MCwgc3kwLCAwLCAwKTtcbiAgICAgICAgc291cmNlU2lkZSA9IERFRklORURfRElSRUNUSU9OUy5pbmNsdWRlcyhzb3VyY2VEaXJlY3Rpb24pID8gc291cmNlRGlyZWN0aW9uIDogc291cmNlTGlua0FuY2hvckJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVZpZXcubW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgc291cmNlU2lkZSA9IGdldERpcmVjdGlvbkZvckxpbmtDb25uZWN0aW9uKHRhcmdldFBvaW50LCBzb3VyY2VQb2ludCwgc291cmNlVmlldyk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VEaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuQU5DSE9SX1NJREUpIHtcbiAgICAgICAgc291cmNlU2lkZSA9IHNvdXJjZUJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5NQUdORVRfU0lERSkge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlVmlldy5tb2RlbC5nZXRCQm94KCkuc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlRGlyZWN0aW9uO1xuICAgIH1cblxuICAgIGxldCB0YXJnZXRTaWRlO1xuXG4gICAgaWYgKCF0YXJnZXRWaWV3KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldExpbmtBbmNob3JCQm94ID0gbmV3IGcuUmVjdCh0eDAsIHR5MCwgMCwgMCk7XG4gICAgICAgIHRhcmdldFNpZGUgPSBERUZJTkVEX0RJUkVDVElPTlMuaW5jbHVkZXModGFyZ2V0RGlyZWN0aW9uKSA/IHRhcmdldERpcmVjdGlvbiA6IHRhcmdldExpbmtBbmNob3JCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRWaWV3Lm1vZGVsLmlzTGluaygpKSB7XG4gICAgICAgIHRhcmdldFNpZGUgPSBnZXREaXJlY3Rpb25Gb3JMaW5rQ29ubmVjdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHRhcmdldFZpZXcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0RGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkFOQ0hPUl9TSURFKSB7XG4gICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludCh0YXJnZXRQb2ludCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXREaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuTUFHTkVUX1NJREUpIHtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldFZpZXcubW9kZWwuZ2V0QkJveCgpLnNpZGVOZWFyZXN0VG9Qb2ludCh0YXJnZXRQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldERpcmVjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NvdXJjZVNpZGUsIHRhcmdldFNpZGVdO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRm9yVG9wU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IHsgeDA6IHN4MCwgeTA6IHN5MCwgd2lkdGgsIGhlaWdodCwgcG9pbnQ6IGFuY2hvciwgbWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgd2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgaGVpZ2h0O1xuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBtYXJnaW47XG4gICAgY29uc3Qgc214MSA9IHN4MSArIG1hcmdpbjtcbiAgICBjb25zdCBzbXkwID0gc3kwIC0gbWFyZ2luO1xuXG4gICAgY29uc3QgeyB4OiBheCB9ID0gYW5jaG9yO1xuICAgIGNvbnN0IHsgeDA6IHR4LCB5MDogdHkgfSA9IHRhcmdldDtcblxuICAgIGlmICh0eCA9PT0gYXggJiYgdHkgPCBzeTApIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPCBheCAmJiB0eSA8IHNteTApIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueCA9PT0gYXgpIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgfVxuICAgIGlmICh0eCA+IGF4ICYmIHR5IDwgc215MCkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54ID09PSBheCkgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIH1cbiAgICBpZiAodHggPCBzbXgwICYmIHR5ID4gc215MCkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIGlmICh0eCA+IHNteDEgJiYgdHkgPiBzbXkwKSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4ID49IHNteDAgJiYgdHggPD0gYXggJiYgdHkgPiBzeTEpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueCA8IHR4KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIH1cbiAgICBpZiAodHggPD0gc214MSAmJiB0eCA+PSBheCAmJiB0eSA+IHN5MSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54IDwgdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRm9yQm90dG9tU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IHsgeDA6IHN4MCwgeTA6IHN5MCwgd2lkdGgsIGhlaWdodCwgcG9pbnQ6IGFuY2hvciwgbWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgd2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgaGVpZ2h0O1xuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBtYXJnaW47XG4gICAgY29uc3Qgc214MSA9IHN4MSArIG1hcmdpbjtcbiAgICBjb25zdCBzbXkxID0gc3kxICsgbWFyZ2luO1xuXG4gICAgY29uc3QgeyB4OiBheCB9ID0gYW5jaG9yO1xuICAgIGNvbnN0IHsgeDA6IHR4LCB5MDogdHkgfSA9IHRhcmdldDtcblxuICAgIGlmICh0eCA9PT0gYXggJiYgdHkgPiBzeTEpIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICBpZiAodHggPCBheCAmJiB0eSA+IHNteTEpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueCA9PT0gYXgpIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgfVxuICAgIGlmICh0eCA+IGF4ICYmIHR5ID4gc215MSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54ID09PSBheCkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIH1cbiAgICBpZiAodHggPCBzbXgwICYmIHR5IDwgc215MSkgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgIGlmICh0eCA+IHNteDEgJiYgdHkgPCBzbXkxKSByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgaWYgKHR4ID49IHNteDAgJiYgdHggPD0gYXggJiYgdHkgPCBzeTApIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueCA8IHR4KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIH1cbiAgICBpZiAodHggPD0gc214MSAmJiB0eCA+PSBheCAmJiB0eSA8IHN5MCkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54IDwgdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRm9yTGVmdFNvdXJjZVNpZGUoc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpIHtcbiAgICBjb25zdCB7IHkwOiBzeTAsIHgwOiBzeDAsIHdpZHRoLCBoZWlnaHQsIHBvaW50OiBhbmNob3IsIG1hcmdpbiB9ID0gc291cmNlO1xuICAgIGNvbnN0IHN4MSA9IHN4MCArIHdpZHRoO1xuICAgIGNvbnN0IHN5MSA9IHN5MCArIGhlaWdodDtcbiAgICBjb25zdCBzbXgwID0gc3gwIC0gbWFyZ2luO1xuICAgIGNvbnN0IHNteTAgPSBzeTAgLSBtYXJnaW47XG4gICAgY29uc3Qgc215MSA9IHN5MSArIG1hcmdpbjtcblxuICAgIGNvbnN0IHsgeDogYXgsIHk6IGF5IH0gPSBhbmNob3I7XG4gICAgY29uc3QgeyB4MDogdHgsIHkwOiB0eSB9ID0gdGFyZ2V0O1xuXG4gICAgaWYgKHR4IDwgYXggJiYgdHkgPT09IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICBpZiAodHggPD0gc214MCAmJiB0eSA8IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgaWYgKHR4IDw9IHNteDAgJiYgdHkgPiBheSkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIGlmICh0eCA+PSBzbXgwICYmIHR5IDwgc215MCkgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICBpZiAodHggPj0gc214MCAmJiB0eSA+IHNteTEpIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgaWYgKHR4ID4gc3gxICYmIHR5ID49IHNteTAgJiYgdHkgPD0gYXkpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueSA8IHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgfVxuICAgIGlmICh0eCA+IHN4MSAmJiB0eSA8PSBzbXkxICYmIHR5ID49IGF5KSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnkgPCB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIH1cblxuICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRm9yUmlnaHRTb3VyY2VTaWRlKHNvdXJjZSwgdGFyZ2V0LCBuZXh0SW5MaW5lKSB7XG4gICAgY29uc3QgeyB5MDogc3kwLCB4MDogc3gwLCB3aWR0aCwgaGVpZ2h0LCBwb2ludDogYW5jaG9yLCBtYXJnaW4gfSA9IHNvdXJjZTtcbiAgICBjb25zdCBzeDEgPSBzeDAgKyB3aWR0aDtcbiAgICBjb25zdCBzeTEgPSBzeTAgKyBoZWlnaHQ7XG4gICAgY29uc3Qgc214MSA9IHN4MSArIG1hcmdpbjtcbiAgICBjb25zdCBzbXkwID0gc3kwIC0gbWFyZ2luO1xuICAgIGNvbnN0IHNteTEgPSBzeTEgKyBtYXJnaW47XG5cbiAgICBjb25zdCB7IHg6IGF4LCB5OiBheSB9ID0gYW5jaG9yO1xuICAgIGNvbnN0IHsgeDA6IHR4LCB5MDogdHkgfSA9IHRhcmdldDtcblxuICAgIGlmICh0eCA+IGF4ICYmIHR5ID09PSBheSkgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICBpZiAodHggPj0gc214MSAmJiB0eSA8IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgaWYgKHR4ID49IHNteDEgJiYgdHkgPiBheSkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIGlmICh0eCA8PSBzbXgxICYmIHR5IDwgc215MCkgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgaWYgKHR4IDw9IHNteDEgJiYgdHkgPiBzbXkxKSByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICBpZiAodHggPCBzeDAgJiYgdHkgPj0gc215MCAmJiB0eSA8PSBheSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC55IDwgdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICB9XG4gICAgaWYgKHR4IDwgc3gwICYmIHR5IDw9IHNteTEgJiYgdHkgPj0gYXkpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueSA8IHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgfVxuXG4gICAgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluaXRpYWxEaXJlY3Rpb24oc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpIHtcbiAgICBjb25zdCBbc291cmNlU2lkZV0gPSByZXNvbHZlU2lkZXMoc291cmNlLCB0YXJnZXQpO1xuXG4gICAgc3dpdGNoIChzb3VyY2VTaWRlKSB7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5UT1A6XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUZvclRvcFNvdXJjZVNpZGUoc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuUklHSFQ6XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUZvclJpZ2h0U291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5CT1RUT006XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUZvckJvdHRvbVNvdXJjZVNpZGUoc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuTEVGVDpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yTGVmdFNvdXJjZVNpZGUoc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uRm9yTGlua0Nvbm5lY3Rpb24obGlua09yaWdpbiwgY29ubmVjdGlvblBvaW50LCBsaW5rVmlldykge1xuICAgIGNvbnN0IHRhbmdlbnQgPSBsaW5rVmlldy5nZXRUYW5nZW50QXRMZW5ndGgobGlua1ZpZXcuZ2V0Q2xvc2VzdFBvaW50TGVuZ3RoKGNvbm5lY3Rpb25Qb2ludCkpO1xuICAgIGNvbnN0IHJvdW5kZWRBbmdsZSA9IE1hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKHRhbmdlbnQpIC8gOTApICogOTA7XG5cbiAgICBpZiAocm91bmRlZEFuZ2xlICUgMTgwID09PSAwICYmIGxpbmtPcmlnaW4ueSA9PT0gY29ubmVjdGlvblBvaW50LnkpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtPcmlnaW4ueCA8IGNvbm5lY3Rpb25Qb2ludC54ID8gRGlyZWN0aW9ucy5MRUZUIDogRGlyZWN0aW9ucy5SSUdIVDtcbiAgICB9IGVsc2UgaWYgKGxpbmtPcmlnaW4ueCA9PT0gY29ubmVjdGlvblBvaW50LngpIHtcbiAgICAgICAgcmV0dXJuIGxpbmtPcmlnaW4ueSA8IGNvbm5lY3Rpb25Qb2ludC55ID8gRGlyZWN0aW9ucy5UT1AgOiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJvdW5kZWRBbmdsZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICBjYXNlIDM2MDpcbiAgICAgICAgICAgIHJldHVybiBsaW5rT3JpZ2luLnkgPCBjb25uZWN0aW9uUG9pbnQueSA/IERpcmVjdGlvbnMuVE9QIDogRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgcmV0dXJuIGxpbmtPcmlnaW4ueCA8IGNvbm5lY3Rpb25Qb2ludC54ID8gRGlyZWN0aW9ucy5MRUZUIDogRGlyZWN0aW9ucy5SSUdIVDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50RGF0YUZyb21BbmNob3IodmlldywgcG9pbnQsIGJib3gsIGRpcmVjdGlvbiwgaXNQb3J0LCBmYWxsQmFja0FuY2hvciwgbWFyZ2luKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5BVVRPKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IGlzUG9ydCA/IERpcmVjdGlvbnMuTUFHTkVUX1NJREUgOiBEaXJlY3Rpb25zLkFOQ0hPUl9TSURFO1xuICAgIH1cblxuICAgIGNvbnN0IGlzRWxlbWVudCA9IHZpZXcgJiYgdmlldy5tb2RlbC5pc0VsZW1lbnQoKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgeDogeDAsXG4gICAgICAgIHk6IHkwLFxuICAgICAgICB3aWR0aCA9IDAsXG4gICAgICAgIGhlaWdodCA9IDBcbiAgICB9ID0gaXNFbGVtZW50ID8gZy5SZWN0LmZyb21SZWN0VW5pb24oYmJveCwgdmlldy5tb2RlbC5nZXRCQm94KCkpIDogZmFsbEJhY2tBbmNob3I7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludCxcbiAgICAgICAgeDAsXG4gICAgICAgIHkwLFxuICAgICAgICB2aWV3LFxuICAgICAgICBiYm94LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIG1hcmdpbjogaXNFbGVtZW50ID8gbWFyZ2luIDogMFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHBvaW50RGF0YUZyb21WZXJ0ZXgoeyB4LCB5IH0pIHtcbiAgICBjb25zdCBwb2ludCA9IG5ldyBnLlBvaW50KHgsIHkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHgwOiBwb2ludC54LFxuICAgICAgICB5MDogcG9pbnQueSxcbiAgICAgICAgdmlldzogbnVsbCxcbiAgICAgICAgYmJveDogbmV3IGcuUmVjdCh4LCB5LCAwLCAwKSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgZGlyZWN0aW9uOiBudWxsLFxuICAgICAgICBtYXJnaW46IDBcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPdXRzaWRlUG9pbnQoc2lkZSwgcG9pbnREYXRhLCBtYXJnaW4pIHtcbiAgICBjb25zdCBvdXRzaWRlUG9pbnQgPSBwb2ludERhdGEucG9pbnQuY2xvbmUoKTtcblxuICAgIGNvbnN0IHsgeDAsIHkwLCB3aWR0aCwgaGVpZ2h0IH0gPSBwb2ludERhdGE7XG5cbiAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBvdXRzaWRlUG9pbnQueCA9IHgwIC0gbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIG91dHNpZGVQb2ludC54ID0geDAgKyB3aWR0aCArIG1hcmdpbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgb3V0c2lkZVBvaW50LnkgPSB5MCAtIG1hcmdpbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgb3V0c2lkZVBvaW50LnkgPSB5MCArIGhlaWdodCArIG1hcmdpbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRzaWRlUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvb3AoZnJvbSwgdG8sIHsgZHggPSAwLCBkeSA9IDAgfSkge1xuICAgIGNvbnN0IHAxID0geyB4OiBmcm9tLnBvaW50LnggKyBkeCwgeTogZnJvbS5wb2ludC55ICsgZHkgfTtcbiAgICBjb25zdCBwMiA9IHsgeDogdG8ucG9pbnQueCArIGR4LCB5OiB0by5wb2ludC55ICsgZHkgfTtcblxuICAgIHJldHVybiBbZnJvbS5wb2ludCwgcDEsIHAyLCB0by5wb2ludF07XG59XG5cbmZ1bmN0aW9uIGxvb3BTZWdtZW50KGZyb20sIHRvLCBjb25uZWN0aW9uU2VnbWVudEFuZ2xlLCBtYXJnaW4pIHtcbiAgICAvLyBGaW5kIG91dCB0aGUgbG9vcCBjb29yZGluYXRlcy5cbiAgICBjb25zdCBhbmdsZSA9IGcubm9ybWFsaXplQW5nbGUoY29ubmVjdGlvblNlZ21lbnRBbmdsZSAtIDkwKTtcblxuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcblxuICAgIGlmIChhbmdsZSA9PT0gOTApIHtcbiAgICAgICAgZHkgPSAtbWFyZ2luO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPT09IDE4MCkge1xuICAgICAgICBkeCA9IC1tYXJnaW47XG4gICAgfSBlbHNlIGlmIChhbmdsZSA9PT0gMjcwKSB7XG4gICAgICAgIGR5ID0gbWFyZ2luO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgZHggPSBtYXJnaW47XG4gICAgfVxuXG4gICAgY29uc3QgbG9vcFJvdXRlID0gY3JlYXRlTG9vcChmcm9tLCB0bywgeyBkeCwgZHkgfSk7XG5cbiAgICBjb25zdCBzZWNvbmRDcmVhdGVkUG9pbnQgPSBsb29wUm91dGVbMl07XG4gICAgY29uc3QgbG9vcEVuZFNlZ21lbnQgPSBuZXcgZy5MaW5lKHRvLnBvaW50LCBzZWNvbmRDcmVhdGVkUG9pbnQpO1xuICAgIC8vIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGxvb3Agc2hvdWxkIGNvbnRpbnVlLlxuICAgIGNvbnN0IGNvbnRpbnVlRGlyZWN0aW9uID0gQU5HTEVfRElSRUNUSU9OX01BUFtnZXRTZWdtZW50QW5nbGUobG9vcEVuZFNlZ21lbnQpXTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxvb3BSb3V0ZSxcbiAgICAgICAgY29udGludWVEaXJlY3Rpb25cbiAgICB9O1xufVxuXG4vLyBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZXMgYWxvbmcgdGhlIGhvcml6b250YWwgYXhpcyBmb3IgdGhlIGxlZnQgYW5kIHJpZ2h0IHJvdXRlLlxuZnVuY3Rpb24gZ2V0SG9yaXpvbnRhbERpc3RhbmNlKHNvdXJjZSwgdGFyZ2V0KSB7XG5cbiAgICBjb25zdCB7IHgwOiBzeDAsIHgxOiBzeDEsIG91dHNpZGVQb2ludDogc291cmNlUG9pbnQgfSA9IHNvdXJjZTtcbiAgICBjb25zdCB7IHgwOiB0eDAsIHgxOiB0eDEsIG91dHNpZGVQb2ludDogdGFyZ2V0UG9pbnQgfSA9IHRhcmdldDtcblxuICAgIC8vIEZ1cnRoZXN0IGxlZnQgYm91bmRhcnlcbiAgICBsZXQgbGVmdEJvdW5kYXJ5ID0gTWF0aC5taW4oc3gwLCB0eDApO1xuICAgIC8vIEZ1cnRoZXN0IHJpZ2h0IGJvdW5kYXJ5XG4gICAgbGV0IHJpZ2h0Qm91bmRhcnkgPSBNYXRoLm1heChzeDEsIHR4MSk7XG5cbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudHMgYXJlIG9uIHRoZSBzYW1lIHNpZGUsIHdlIG5lZWQgdG8gZmlndXJlIG91dCB3aGF0IHNoYXBlIGRlZmluZXMgdGhlIGJvdW5kYXJ5LlxuICAgIGlmIChzb3VyY2UuZGlyZWN0aW9uID09PSB0YXJnZXQuZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgY29uc3QgYWJvdmVTaGFwZSA9IHNvdXJjZS55MCA8IHRhcmdldC55MCA/IHNvdXJjZSA6IHRhcmdldDtcbiAgICAgICAgY29uc3QgYmVsb3dTaGFwZSA9IGFib3ZlU2hhcGUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHNvdXJjZTtcblxuICAgICAgICAvLyBUaGUgc291cmNlIGFuZCB0YXJnZXQgYW5jaG9ycyBhcmUgb24gdGhlIHRvcCA9PiB0aGVuIHRoZSBgYWJvdmVTaGFwZWAgZGVmaW5lcyB0aGUgYm91bmRhcnkuXG4gICAgICAgIC8vIFRoZSBzb3VyY2UgYW5kIHRhcmdldCBhbmNob3JzIGFyZSBvbiB0aGUgYm90dG9tID0+IHRoZW4gdGhlIGBiZWxvd1NoYXBlYCBkZWZpbmVzIHRoZSBib3VuZGFyeS5cbiAgICAgICAgY29uc3QgYm91bmRhcnlEZWZpbmluZ1NoYXBlID0gc291cmNlLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5UT1AgPyBhYm92ZVNoYXBlIDogYmVsb3dTaGFwZTtcblxuICAgICAgICBsZWZ0Qm91bmRhcnkgPSBib3VuZGFyeURlZmluaW5nU2hhcGUueDA7XG4gICAgICAgIHJpZ2h0Qm91bmRhcnkgPSBib3VuZGFyeURlZmluaW5nU2hhcGUueDE7XG4gICAgfVxuXG4gICAgY29uc3QgeyB4OiBzb3ggfSA9IHNvdXJjZVBvaW50O1xuICAgIGNvbnN0IHsgeDogdG94IH0gPSB0YXJnZXRQb2ludDtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2VzIGZvciB0aGUgbGVmdCByb3V0ZVxuICAgIGNvbnN0IGxlZnREaXN0YW5jZTEgPSBNYXRoLmFicyhzb3ggLSBsZWZ0Qm91bmRhcnkpO1xuICAgIGNvbnN0IGxlZnREaXN0YW5jZTIgPSBNYXRoLmFicyh0b3ggLSBsZWZ0Qm91bmRhcnkpO1xuICAgIGNvbnN0IGxlZnREID0gbGVmdERpc3RhbmNlMSArIGxlZnREaXN0YW5jZTI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlcyBmb3IgdGhlIHJpZ2h0IHJvdXRlXG4gICAgY29uc3QgcmlnaHREaXN0YW5jZTEgPSBNYXRoLmFicyhzb3ggLSByaWdodEJvdW5kYXJ5KTtcbiAgICBjb25zdCByaWdodERpc3RhbmNlMiA9IE1hdGguYWJzKHRveCAtIHJpZ2h0Qm91bmRhcnkpO1xuICAgIGNvbnN0IHJpZ2h0RCA9IHJpZ2h0RGlzdGFuY2UxICsgcmlnaHREaXN0YW5jZTI7XG5cbiAgICByZXR1cm4gW2xlZnRELCByaWdodERdO1xufVxuXG4vLyBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZXMgYWxvbmcgdGhlIHZlcnRpY2FsIGF4aXMgZm9yIHRoZSB0b3AgYW5kIGJvdHRvbSByb3V0ZS5cbmZ1bmN0aW9uIGdldFZlcnRpY2FsRGlzdGFuY2Uoc291cmNlLCB0YXJnZXQpIHtcblxuICAgIGNvbnN0IHsgeTA6IHN5MCwgeTE6IHN5MSwgb3V0c2lkZVBvaW50OiBzb3VyY2VQb2ludCB9ID0gc291cmNlO1xuICAgIGNvbnN0IHsgeTA6IHR5MCwgeTE6IHR5MSwgb3V0c2lkZVBvaW50OiB0YXJnZXRQb2ludCB9ID0gdGFyZ2V0O1xuXG4gICAgLy8gRnVydGhlc3QgdG9wIGJvdW5kYXJ5XG4gICAgbGV0IHRvcEJvdW5kYXJ5ID0gTWF0aC5taW4oc3kwLCB0eTApO1xuICAgIC8vIEZ1cnRoZXN0IGJvdHRvbSBib3VuZGFyeVxuICAgIGxldCBib3R0b21Cb3VuZGFyeSA9IE1hdGgubWF4KHN5MSwgdHkxKTtcblxuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBhcmUgb24gdGhlIHNhbWUgc2lkZSwgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHdoYXQgc2hhcGUgZGVmaW5lcyB0aGUgYm91bmRhcnkuXG4gICAgaWYgKHNvdXJjZS5kaXJlY3Rpb24gPT09IHRhcmdldC5kaXJlY3Rpb24pIHtcblxuICAgICAgICBjb25zdCBsZWZ0U2hhcGUgPSBzb3VyY2UueDAgPCB0YXJnZXQueDAgPyBzb3VyY2UgOiB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0U2hhcGUgPSBsZWZ0U2hhcGUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHNvdXJjZTtcblxuICAgICAgICAvLyBUaGUgc291cmNlIGFuZCB0YXJnZXQgYW5jaG9ycyBhcmUgb24gdGhlIGxlZnQgPT4gdGhlbiB0aGUgYGxlZnRTaGFwZWAgZGVmaW5lcyB0aGUgYm91bmRhcnkuXG4gICAgICAgIC8vIFRoZSBzb3VyY2UgYW5kIHRhcmdldCBhbmNob3JzIGFyZSBvbiB0aGUgcmlnaHQgPT4gdGhlbiB0aGUgYHJpZ2h0U2hhcGVgIGRlZmluZXMgdGhlIGJvdW5kYXJ5LlxuICAgICAgICBjb25zdCBib3VuZGFyeURlZmluaW5nU2hhcGUgPSBzb3VyY2UuZGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkxFRlQgPyBsZWZ0U2hhcGUgOiByaWdodFNoYXBlO1xuXG4gICAgICAgIHRvcEJvdW5kYXJ5ID0gYm91bmRhcnlEZWZpbmluZ1NoYXBlLnkwO1xuICAgICAgICBib3R0b21Cb3VuZGFyeSA9IGJvdW5kYXJ5RGVmaW5pbmdTaGFwZS55MTsgIFxuICAgIH1cblxuICAgIGNvbnN0IHsgeTogc295IH0gPSBzb3VyY2VQb2ludDtcbiAgICBjb25zdCB7IHk6IHRveSB9ID0gdGFyZ2V0UG9pbnQ7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlcyBmb3IgdGhlIHRvcCByb3V0ZVxuICAgIGNvbnN0IHRvcERpc3RhbmNlMSA9IE1hdGguYWJzKHNveSAtIHRvcEJvdW5kYXJ5KTtcbiAgICBjb25zdCB0b3BEaXN0YW5jZTIgPSBNYXRoLmFicyh0b3kgLSB0b3BCb3VuZGFyeSk7XG4gICAgY29uc3QgdG9wRCA9IHRvcERpc3RhbmNlMSArIHRvcERpc3RhbmNlMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2VzIGZvciB0aGUgYm90dG9tIHJvdXRlXG4gICAgY29uc3QgYm90dG9tRGlzdGFuY2UxID0gTWF0aC5hYnMoc295IC0gYm90dG9tQm91bmRhcnkpO1xuICAgIGNvbnN0IGJvdHRvbURpc3RhbmNlMiA9IE1hdGguYWJzKHRveSAtIGJvdHRvbUJvdW5kYXJ5KTtcbiAgICBjb25zdCBib3R0b21EID0gYm90dG9tRGlzdGFuY2UxICsgYm90dG9tRGlzdGFuY2UyO1xuXG4gICAgcmV0dXJuIFt0b3BELCBib3R0b21EXTtcbn1cblxuLy8gSW5mbGF0ZSBiYm94IGluIDMgZGlyZWN0aW9ucyBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgYW5jaG9yXG4vLyBkb24ndCBpbmZsYXRlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2YgdGhlIGFuY2hvclxuZnVuY3Rpb24gbW92ZUFuZEV4cGFuZEJCb3goYmJveCwgZGlyZWN0aW9uLCBtYXJnaW4pIHtcbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuTEVGVDpcbiAgICAgICAgICAgIGJib3guaW5mbGF0ZSgwLCBtYXJnaW4pLm1vdmVBbmRFeHBhbmQoeyB4OiAtbWFyZ2luLCB3aWR0aDogbWFyZ2luIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgIGJib3guaW5mbGF0ZSgwLCBtYXJnaW4pLm1vdmVBbmRFeHBhbmQoeyB3aWR0aDogbWFyZ2luIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5UT1A6XG4gICAgICAgICAgICBiYm94LmluZmxhdGUobWFyZ2luLCAwKS5tb3ZlQW5kRXhwYW5kKHsgeTogLW1hcmdpbiwgaGVpZ2h0OiBtYXJnaW4gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkJPVFRPTTpcbiAgICAgICAgICAgIGJib3guaW5mbGF0ZShtYXJnaW4sIDApLm1vdmVBbmRFeHBhbmQoeyBoZWlnaHQ6IG1hcmdpbiB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBiYm94O1xufVxuXG5mdW5jdGlvbiByb3V0ZUJldHdlZW5Qb2ludHMoc291cmNlLCB0YXJnZXQsIG9wdCA9IHt9KSB7XG4gICAgY29uc3QgeyBwb2ludDogc291cmNlUG9pbnQsIHgwOiBzeDAsIHkwOiBzeTAsIHdpZHRoOiBzb3VyY2VXaWR0aCwgaGVpZ2h0OiBzb3VyY2VIZWlnaHQsIG1hcmdpbjogc291cmNlTWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3QgeyBwb2ludDogdGFyZ2V0UG9pbnQsIHgwOiB0eDAsIHkwOiB0eTAsIHdpZHRoOiB0YXJnZXRXaWR0aCwgaGVpZ2h0OiB0YXJnZXRIZWlnaHQsIG1hcmdpbjogdGFyZ2V0TWFyZ2luIH0gPSB0YXJnZXQ7XG4gICAgY29uc3QgeyB0YXJnZXRJblNvdXJjZUJCb3ggPSBmYWxzZSB9ID0gb3B0O1xuXG4gICAgY29uc3QgdHgxID0gdHgwICsgdGFyZ2V0V2lkdGg7XG4gICAgY29uc3QgdHkxID0gdHkwICsgdGFyZ2V0SGVpZ2h0O1xuICAgIGNvbnN0IHN4MSA9IHN4MCArIHNvdXJjZVdpZHRoO1xuICAgIGNvbnN0IHN5MSA9IHN5MCArIHNvdXJjZUhlaWdodDtcblxuICAgIC8vIEtleSBjb29yZGluYXRlcyBpbmNsdWRpbmcgdGhlIG1hcmdpblxuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBzb3VyY2VNYXJnaW47XG4gICAgY29uc3Qgc214MSA9IHN4MSArIHNvdXJjZU1hcmdpbjtcbiAgICBjb25zdCBzbXkwID0gc3kwIC0gc291cmNlTWFyZ2luO1xuICAgIGNvbnN0IHNteTEgPSBzeTEgKyBzb3VyY2VNYXJnaW47XG5cbiAgICBjb25zdCB0bXgwID0gdHgwIC0gdGFyZ2V0TWFyZ2luO1xuICAgIGNvbnN0IHRteDEgPSB0eDEgKyB0YXJnZXRNYXJnaW47XG4gICAgY29uc3QgdG15MCA9IHR5MCAtIHRhcmdldE1hcmdpbjtcbiAgICBjb25zdCB0bXkxID0gdHkxICsgdGFyZ2V0TWFyZ2luO1xuXG4gICAgY29uc3QgW3NvdXJjZVNpZGUsIHRhcmdldFNpZGVdID0gcmVzb2x2ZVNpZGVzKHNvdXJjZSwgdGFyZ2V0KTtcblxuICAgIGNvbnN0IHNvdXJjZU91dHNpZGVQb2ludCA9IGdldE91dHNpZGVQb2ludChzb3VyY2VTaWRlLCB7IHBvaW50OiBzb3VyY2VQb2ludCwgeDA6IHN4MCwgeTA6IHN5MCwgd2lkdGg6IHNvdXJjZVdpZHRoLCBoZWlnaHQ6IHNvdXJjZUhlaWdodCB9LCBzb3VyY2VNYXJnaW4pO1xuICAgIGNvbnN0IHRhcmdldE91dHNpZGVQb2ludCA9IGdldE91dHNpZGVQb2ludCh0YXJnZXRTaWRlLCB7IHBvaW50OiB0YXJnZXRQb2ludCwgeDA6IHR4MCwgeTA6IHR5MCwgd2lkdGg6IHRhcmdldFdpZHRoLCBoZWlnaHQ6IHRhcmdldEhlaWdodCB9LCB0YXJnZXRNYXJnaW4pO1xuXG4gICAgY29uc3QgeyB4OiBzb3gsIHk6IHNveSB9ID0gc291cmNlT3V0c2lkZVBvaW50O1xuICAgIGNvbnN0IHsgeDogdG94LCB5OiB0b3kgfSA9IHRhcmdldE91dHNpZGVQb2ludDtcbiAgICBjb25zdCB0Y3ggPSAodHgwICsgdHgxKSAvIDI7XG4gICAgY29uc3QgdGN5ID0gKHR5MCArIHR5MSkgLyAyO1xuICAgIGNvbnN0IHNjeCA9IChzeDAgKyBzeDEpIC8gMjtcbiAgICBjb25zdCBzY3kgPSAoc3kwICsgc3kxKSAvIDI7XG4gICAgY29uc3QgbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzID0gKHNjeCA8IHRjeCA/IChzeDEgKyB0eDApIDogKHR4MSArIHN4MCkpIC8gMjtcbiAgICBjb25zdCBtaWRkbGVPZkhvcml6b250YWxTaWRlcyA9IChzY3kgPCB0Y3kgPyAoc3kxICsgdHkwKSA6ICh0eTEgKyBzeTApKSAvIDI7XG5cbiAgICBjb25zdCBzb3VyY2VCQm94ID0gbmV3IGcuUmVjdChzeDAsIHN5MCwgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCk7XG4gICAgY29uc3QgdGFyZ2V0QkJveCA9IG5ldyBnLlJlY3QodHgwLCB0eTAsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xuICAgIGNvbnN0IGluZmxhdGVkU291cmNlQkJveCA9IHNvdXJjZUJCb3guY2xvbmUoKS5pbmZsYXRlKHNvdXJjZU1hcmdpbik7XG4gICAgY29uc3QgaW5mbGF0ZWRUYXJnZXRCQm94ID0gdGFyZ2V0QkJveC5jbG9uZSgpLmluZmxhdGUodGFyZ2V0TWFyZ2luKTtcblxuICAgIGNvbnN0IHNvdXJjZUZvckRpc3RhbmNlID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLCB7IHgxOiBzeDEsIHkxOiBzeTEsIG91dHNpZGVQb2ludDogc291cmNlT3V0c2lkZVBvaW50LCBkaXJlY3Rpb246IHNvdXJjZVNpZGUgfSk7XG4gICAgY29uc3QgdGFyZ2V0Rm9yRGlzdGFuY2UgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIHsgeDE6IHR4MSwgeTE6IHR5MSwgb3V0c2lkZVBvaW50OiB0YXJnZXRPdXRzaWRlUG9pbnQsIGRpcmVjdGlvbjogdGFyZ2V0U2lkZSB9KTtcblxuICAgIC8vIERpc3RhbmNlcyB1c2VkIHRvIGRldGVybWluZSB0aGUgc2hvcnRlc3Qgcm91dGUgYWxvbmcgdGhlIGNvbm5lY3Rpb25zIG9uIGhvcml6b250YWwgc2lkZXMgZm9yXG4gICAgLy8gYm90dG9tID0+IGJvdHRvbVxuICAgIC8vIHRvcCA9PiBib3R0b21cbiAgICAvLyBib3R0b20gPT4gdG9wXG4gICAgLy8gdG9wID0+IHRvcFxuICAgIGNvbnN0IFtsZWZ0RCwgcmlnaHREXSA9IGdldEhvcml6b250YWxEaXN0YW5jZShzb3VyY2VGb3JEaXN0YW5jZSwgdGFyZ2V0Rm9yRGlzdGFuY2UpO1xuXG4gICAgLy8gRGlzdGFuY2VzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaG9ydGVzdCByb3V0ZSBhbG9uZyB0aGUgY29ubmVjdGlvbiBvbiB2ZXJ0aWNhbCBzaWRlcyBmb3JcbiAgICAvLyBsZWZ0ID0+IGxlZnRcbiAgICAvLyBsZWZ0ID0+IHJpZ2h0XG4gICAgLy8gcmlnaHQgPT4gcmlnaHRcbiAgICAvLyByaWdodCA9PiBsZWZ0XG4gICAgY29uc3QgW3RvcEQsIGJvdHRvbURdID0gZ2V0VmVydGljYWxEaXN0YW5jZShzb3VyY2VGb3JEaXN0YW5jZSwgdGFyZ2V0Rm9yRGlzdGFuY2UpO1xuXG4gICAgLy8gQWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiBzb3VyY2UgYW5kIHRhcmdldCBzaWRlc1xuICAgIGlmIChzb3VyY2VTaWRlID09PSAnbGVmdCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0T3V0c2lkZVBvaW50KTtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVRhcmdldCA9IGluZmxhdGVkVGFyZ2V0QkJveC5jb250YWluc1BvaW50KHNvdXJjZU91dHNpZGVQb2ludCk7XG5cbiAgICAgICAgLy8gVXNlIFMtc2hhcGVkIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UgfHwgaXNQb2ludEluc2lkZVRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlT2ZBbmNob3JzID0gKHNveSArIHRveSkgLyAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogbWlkZGxlT2ZBbmNob3JzIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IG1pZGRsZU9mQW5jaG9ycyB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXgwIDwgdG94KSB7XG4gICAgICAgICAgICBsZXQgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuICAgICAgICAgICAgbGV0IHgxID0gc294O1xuICAgICAgICAgICAgbGV0IHgyID0gdG94O1xuXG4gICAgICAgICAgICBjb25zdCBpc1Vwd2FyZHNTaG9ydGVyID0gdG9wRCA8IGJvdHRvbUQ7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBvdmVybGFwLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgLy8gZ29lcyBhcm91bmQgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKCh5ID49IHNteTAgJiYgeSA8PSBzbXkxKSB8fCAoeSA+PSB0bXkwICYmIHkgPD0gdG15MSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc215MSA+PSB0bXkwICYmIGlzVXB3YXJkc1Nob3J0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHRteTAsIHNteTApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc215MCA8PSB0bXkxICYmICFpc1Vwd2FyZHNTaG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCh0bXkxLCBzbXkxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudHMgb3ZlcmxhcCBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB4MSA9IE1hdGgubWluKHNveCwgdG14MCk7XG4gICAgICAgICAgICAgICAgeDIgPSBNYXRoLm1heCh0b3gsIHNteDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBlZGdlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgaW50ZXJzZWN0IGFuZFxuICAgICAgICAgICAgICAgIGlmICgoaXNVcHdhcmRzU2hvcnRlciAmJiBzb3kgPCB0eTApIHx8ICghaXNVcHdhcmRzU2hvcnRlciAmJiBzb3kgPiB0eTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXRoIHNob3VsZCBubyBsb25nZXIgcmVseSBvbiBtaW5pbWFsIHggYm91bmRhcnkgaW4gYHgxYFxuICAgICAgICAgICAgICAgICAgICB4MSA9IHNveDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChpc1Vwd2FyZHNTaG9ydGVyICYmIHRveSA8IHN5MCkgfHwgKCFpc1Vwd2FyZHNTaG9ydGVyICYmIHRveSA+IHN5MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGggc2hvdWxkIG5vIGxvbmdlciByZWx5IG9uIG1heGltYWwgeCBib3VuZGFyeSBpbiBgeDJgXG4gICAgICAgICAgICAgICAgICAgIHgyID0gdG94O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHgxLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgxLCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB4MiwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogeDIsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IChzb3ggKyB0b3gpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9LFxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3JpZ2h0JyAmJiB0YXJnZXRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldE91dHNpZGVQb2ludCk7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVUYXJnZXQgPSBpbmZsYXRlZFRhcmdldEJCb3guY29udGFpbnNQb2ludChzb3VyY2VPdXRzaWRlUG9pbnQpO1xuXG4gICAgICAgIC8vIFVzZSBTLXNoYXBlZCBjb25uZWN0aW9uXG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlIHx8IGlzUG9pbnRJbnNpZGVUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZU9mQW5jaG9ycyA9IChzb3kgKyB0b3kpIC8gMjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IG1pZGRsZU9mQW5jaG9ycyB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBtaWRkbGVPZkFuY2hvcnMgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc214MSA+IHRveCkge1xuICAgICAgICAgICAgbGV0IHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcbiAgICAgICAgICAgIGxldCB4MSA9IHNveDtcbiAgICAgICAgICAgIGxldCB4MiA9IHRveDtcblxuICAgICAgICAgICAgY29uc3QgaXNVcHdhcmRzU2hvcnRlciA9IHRvcEQgPCBib3R0b21EO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudHMgb3ZlcmxhcCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIC8vIGdvZXMgYXJvdW5kIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICAgIGlmICgoeSA+PSBzbXkwICYmIHkgPD0gc215MSkgfHwgKHkgPj0gdG15MCAmJiB5IDw9IHRteTEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNteTEgPj0gdG15MCAmJiBpc1Vwd2FyZHNTaG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbih0bXkwLCBzbXkwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNteTAgPD0gdG15MSAmJiAhaXNVcHdhcmRzU2hvcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgodG15MSwgc215MSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzIG92ZXJsYXAgYXMgd2VsbCBhc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBjYXNlIHdoZW4gdGhlIHNvdXJjZSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgeDEgPSBNYXRoLm1heChzb3gsIHRteDEpO1xuICAgICAgICAgICAgICAgIHgyID0gTWF0aC5taW4odG94LCBzbXgwKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZWRnZSBjYXNlIHdoZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGludGVyc2VjdCBhbmRcbiAgICAgICAgICAgICAgICBpZiAoKGlzVXB3YXJkc1Nob3J0ZXIgJiYgc295IDwgdHkwKSB8fCAoIWlzVXB3YXJkc1Nob3J0ZXIgJiYgc295ID4gdHkxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0aCBzaG91bGQgbm8gbG9uZ2VyIHJlbHkgb24gbWF4aW1hbCB4IGJvdW5kYXJ5IGluIGB4MWBcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBzb3g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoaXNVcHdhcmRzU2hvcnRlciAmJiB0b3kgPCBzeTApIHx8ICghaXNVcHdhcmRzU2hvcnRlciAmJiB0b3kgPiBzeTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXRoIHNob3VsZCBubyBsb25nZXIgcmVseSBvbiBtaW5pbWFsIHggYm91bmRhcnkgaW4gYHgyYFxuICAgICAgICAgICAgICAgICAgICB4MiA9IHRveDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiB4MSwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB4MSwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogeDIsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgyLCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSAoc294ICsgdG94KSAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3RvcCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldE91dHNpZGVQb2ludCk7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVUYXJnZXQgPSBpbmZsYXRlZFRhcmdldEJCb3guY29udGFpbnNQb2ludChzb3VyY2VPdXRzaWRlUG9pbnQpO1xuXG4gICAgICAgIC8vIFVzZSBTLXNoYXBlZCBjb25uZWN0aW9uXG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlIHx8IGlzUG9pbnRJbnNpZGVUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZU9mQW5jaG9ycyA9IChzb3ggKyB0b3gpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBtaWRkbGVPZkFuY2hvcnMsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogbWlkZGxlT2ZBbmNob3JzLCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc215MCA8IHRveSkge1xuICAgICAgICAgICAgbGV0IHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG4gICAgICAgICAgICBsZXQgeTEgPSBzb3k7XG4gICAgICAgICAgICBsZXQgeTIgPSB0b3k7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzTGVmdFNob3J0ZXIgPSBsZWZ0RCA8IHJpZ2h0RDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzIG92ZXJsYXAsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBnb2VzIGFyb3VuZCB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoKHggPj0gc214MCAmJiB4IDw9IHNteDEpIHx8ICh4ID49IHRteDAgJiYgeCA8PSB0bXgxKSkge1xuICAgICAgICAgICAgICAgIGlmIChzbXgxID49IHRteDAgJiYgaXNMZWZ0U2hvcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4odG14MCwgc214MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbXgwIDw9IHRteDEgJiYgIWlzTGVmdFNob3J0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHRteDEsIHNteDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBvdmVybGFwIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FzZSB3aGVuIHRoZSBzb3VyY2UgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHkxID0gTWF0aC5taW4oc295LCB0bXkwKTtcbiAgICAgICAgICAgICAgICB5MiA9IE1hdGgubWF4KHRveSwgc215MSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVkZ2UgY2FzZSB3aGVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBpbnRlcnNlY3QgYW5kXG4gICAgICAgICAgICAgICAgaWYgKChpc0xlZnRTaG9ydGVyICYmIHNveCA8IHR4MCkgfHwgKCFpc0xlZnRTaG9ydGVyICYmIHNveCA+IHR4MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGggc2hvdWxkIG5vIGxvbmdlciByZWx5IG9uIG1pbmltYWwgeSBib3VuZGFyeSBpbiBgeTFgXG4gICAgICAgICAgICAgICAgICAgIHkxID0gc295O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGlzTGVmdFNob3J0ZXIgJiYgdG94IDwgc3gwKSB8fCAoIWlzTGVmdFNob3J0ZXIgJiYgdG94ID4gc3gxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0aCBzaG91bGQgbm8gbG9uZ2VyIHJlbHkgb24gbWF4aW1hbCB5IGJvdW5kYXJ5IGluIGB5MmBcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB0b3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiB5MSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogeTEgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHkyIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHkyIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB5ID0gKHNveSArIHRveSkgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdib3R0b20nICYmIHRhcmdldFNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRPdXRzaWRlUG9pbnQpO1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlVGFyZ2V0ID0gaW5mbGF0ZWRUYXJnZXRCQm94LmNvbnRhaW5zUG9pbnQoc291cmNlT3V0c2lkZVBvaW50KTtcblxuICAgICAgICAvLyBVc2UgUy1zaGFwZWQgY29ubmVjdGlvblxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSB8fCBpc1BvaW50SW5zaWRlVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtaWRkbGVPZkFuY2hvcnMgPSAoc294ICsgdG94KSAvIDI7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogbWlkZGxlT2ZBbmNob3JzLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IG1pZGRsZU9mQW5jaG9ycywgeTogdG95IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteTEgPiB0b3kpIHtcbiAgICAgICAgICAgIGxldCB4ID0gbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzO1xuICAgICAgICAgICAgbGV0IHkxID0gc295O1xuICAgICAgICAgICAgbGV0IHkyID0gdG95O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBpc0xlZnRTaG9ydGVyID0gbGVmdEQgPCByaWdodEQ7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBvdmVybGFwLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgLy8gZ29lcyBhcm91bmQgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKCh4ID49IHNteDAgJiYgeCA8PSBzbXgxKSB8fCAoeCA+PSB0bXgwICYmIHggPD0gdG14MSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc214MSA+PSB0bXgwICYmIGlzTGVmdFNob3J0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGgubWluKHRteDAsIHNteDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc214MCA8PSB0bXgxICYmICFpc0xlZnRTaG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heCh0bXgxLCBzbXgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudHMgb3ZlcmxhcCBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB5MSA9IE1hdGgubWF4KHNveSwgdG15MSk7XG4gICAgICAgICAgICAgICAgeTIgPSBNYXRoLm1pbih0b3ksIHNteTApO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBlZGdlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgaW50ZXJzZWN0IGFuZFxuICAgICAgICAgICAgICAgIGlmICgoaXNMZWZ0U2hvcnRlciAmJiBzb3ggPCB0eDApIHx8ICghaXNMZWZ0U2hvcnRlciAmJiBzb3ggPiB0eDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXRoIHNob3VsZCBubyBsb25nZXIgcmVseSBvbiBtYXhpbWFsIHkgYm91bmRhcnkgaW4gYHkxYFxuICAgICAgICAgICAgICAgICAgICB5MSA9IHNveTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChpc0xlZnRTaG9ydGVyICYmIHRveCA8IHN4MCkgfHwgKCFpc0xlZnRTaG9ydGVyICYmIHRveCA+IHN4MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGggc2hvdWxkIG5vIGxvbmdlciByZWx5IG9uIG1pbmltYWwgeSBib3VuZGFyeSBpbiBgeTJgXG4gICAgICAgICAgICAgICAgICAgIHkyID0gdG95O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogeTEgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHkxIH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB5MiB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB5MiB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeSA9IChzb3kgKyB0b3kpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAndG9wJyAmJiB0YXJnZXRTaWRlID09PSAndG9wJykge1xuICAgICAgICBjb25zdCB1c2VVU2hhcGVDb25uZWN0aW9uID1cbiAgICAgICAgICAgIHRhcmdldEluU291cmNlQkJveCB8fFxuICAgICAgICAgICAgZy5pbnRlcnNlY3Rpb24ucmVjdFdpdGhSZWN0KGluZmxhdGVkU291cmNlQkJveCwgdGFyZ2V0QkJveCkgfHxcbiAgICAgICAgICAgIChzb3kgPD0gdHkwICYmIChpbmZsYXRlZFNvdXJjZUJCb3guYm90dG9tUmlnaHQoKS54IDw9IHRveCB8fCBpbmZsYXRlZFNvdXJjZUJCb3guYm90dG9tTGVmdCgpLnggPj0gdG94KSkgfHxcbiAgICAgICAgICAgIChzb3kgPj0gdHkwICYmIChpbmZsYXRlZFRhcmdldEJCb3guYm90dG9tUmlnaHQoKS54IDw9IHNveCB8fCBpbmZsYXRlZFRhcmdldEJCb3guYm90dG9tTGVmdCgpLnggPj0gc294KSk7XG5cbiAgICAgICAgLy8gVS1zaGFwZSBjb25uZWN0aW9uIGlzIGEgc3RyYWlnaHQgbGluZSBpZiBgc294YCBhbmQgYHRveGAgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmICh1c2VVU2hhcGVDb25uZWN0aW9uICYmIHNveCAhPT0gdG94KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBNYXRoLm1pbihzb3ksIHRveSkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogTWF0aC5taW4oc295LCB0b3kpIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHkxID0gTWF0aC5taW4oKHN5MSArIHR5MCkgLyAyLCB0b3kpO1xuICAgICAgICBsZXQgeTIgPSBNYXRoLm1pbigoc3kwICsgdHkxKSAvIDIsIHNveSk7XG5cbiAgICAgICAgaWYgKHRveSA8IHNveSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBzaG9ydGVzdCBwYXRoIGFsb25nIHRoZSBjb25uZWN0aW9ucyBvbiBob3Jpem9udGFsIHNpZGVzXG4gICAgICAgICAgICBpZiAocmlnaHREID4gbGVmdEQpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4oc294LCB0bXgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHNveCwgdG14MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmlnaHREID4gbGVmdEQpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4odG94LCBzbXgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHRveCwgc214MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHkyIH0sXG4gICAgICAgICAgICB7IHgsIHk6IHkyIH0sXG4gICAgICAgICAgICB7IHgsIHk6IHkxIH0sXG4gICAgICAgICAgICB7IHg6IHRveCwgeTogeTEgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2JvdHRvbScgJiYgdGFyZ2V0U2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgY29uc3QgdXNlVVNoYXBlQ29ubmVjdGlvbiA9XG4gICAgICAgICAgICB0YXJnZXRJblNvdXJjZUJCb3ggfHxcbiAgICAgICAgICAgIGcuaW50ZXJzZWN0aW9uLnJlY3RXaXRoUmVjdChpbmZsYXRlZFNvdXJjZUJCb3gsIHRhcmdldEJCb3gpIHx8XG4gICAgICAgICAgICAoc295ID49IHRveSAmJiAoaW5mbGF0ZWRTb3VyY2VCQm94LnRvcFJpZ2h0KCkueCA8PSB0b3ggfHwgaW5mbGF0ZWRTb3VyY2VCQm94LnRvcExlZnQoKS54ID49IHRveCkpIHx8XG4gICAgICAgICAgICAoc295IDw9IHRveSAmJiAoaW5mbGF0ZWRUYXJnZXRCQm94LnRvcFJpZ2h0KCkueCA8PSBzb3ggfHwgaW5mbGF0ZWRUYXJnZXRCQm94LnRvcExlZnQoKS54ID49IHNveCkpO1xuXG4gICAgICAgIC8vIFUtc2hhcGUgY29ubmVjdGlvbiBpcyBhIHN0cmFpZ2h0IGxpbmUgaWYgYHNveGAgYW5kIGB0b3hgIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAodXNlVVNoYXBlQ29ubmVjdGlvbiAmJiBzb3ggIT09IHRveCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogTWF0aC5tYXgoc295LCB0b3kpIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IE1hdGgubWF4KHNveSwgdG95KSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5MSA9IE1hdGgubWF4KChzeTAgKyB0eTEpIC8gMiwgdG95KTtcbiAgICAgICAgbGV0IHkyID0gTWF0aC5tYXgoKHN5MSArIHR5MCkgLyAyLCBzb3kpO1xuXG4gICAgICAgIGlmICh0b3kgPiBzb3kpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc2hvcnRlc3QgcGF0aCBhbG9uZyB0aGUgY29ubmVjdGlvbnMgb24gaG9yaXpvbnRhbCBzaWRlc1xuICAgICAgICAgICAgaWYgKHJpZ2h0RCA+IGxlZnREKSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWluKHNveCwgdG14MCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heChzb3gsIHRteDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJpZ2h0RCA+IGxlZnREKSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWluKHRveCwgc214MCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1heCh0b3gsIHNteDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiB5MiB9LFxuICAgICAgICAgICAgeyB4LCB5OiB5MiB9LFxuICAgICAgICAgICAgeyB4LCB5OiB5MSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHkxIH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdsZWZ0JyAmJiB0YXJnZXRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgY29uc3QgdXNlVVNoYXBlQ29ubmVjdGlvbiA9IFxuICAgICAgICAgICAgdGFyZ2V0SW5Tb3VyY2VCQm94IHx8XG4gICAgICAgICAgICBnLmludGVyc2VjdGlvbi5yZWN0V2l0aFJlY3QoaW5mbGF0ZWRTb3VyY2VCQm94LCB0YXJnZXRCQm94KSB8fFxuICAgICAgICAgICAgKHNveCA8PSB0b3ggJiYgKGluZmxhdGVkU291cmNlQkJveC5ib3R0b21SaWdodCgpLnkgPD0gdG95IHx8IGluZmxhdGVkU291cmNlQkJveC50b3BSaWdodCgpLnkgPj0gdG95KSkgfHxcbiAgICAgICAgICAgIChzb3ggPj0gdG94ICYmIChpbmZsYXRlZFRhcmdldEJCb3guYm90dG9tUmlnaHQoKS55IDw9IHNveSB8fCBpbmZsYXRlZFRhcmdldEJCb3gudG9wUmlnaHQoKS55ID49IHNveSkpO1xuXG4gICAgICAgIC8vIFUtc2hhcGUgY29ubmVjdGlvbiBpcyBhIHN0cmFpZ2h0IGxpbmUgaWYgYHNveWAgYW5kIGB0b3lgIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAodXNlVVNoYXBlQ29ubmVjdGlvbiAmJiBzb3kgIT09IHRveSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IE1hdGgubWluKHNveCwgdG94KSwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBNYXRoLm1pbihzb3gsIHRveCksIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCB4MSA9IE1hdGgubWluKChzeDEgKyB0eDApIC8gMiwgdG94KTtcbiAgICAgICAgbGV0IHgyID0gTWF0aC5taW4oKHN4MCArIHR4MSkgLyAyLCBzb3gpO1xuXG4gICAgICAgIGlmICh0b3ggPiBzb3gpIHtcbiAgICAgICAgICAgIGlmICh0b3BEIDw9IGJvdHRvbUQpIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4oc215MCwgdG95KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHNteTEsIHRveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9wRCA8PSBib3R0b21EKSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHRteTAsIHNveSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCh0bXkxLCBzb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogeDIsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiB4MiwgeSB9LFxuICAgICAgICAgICAgeyB4OiB4MSwgeSB9LFxuICAgICAgICAgICAgeyB4OiB4MSwgeTogdG95IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdyaWdodCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBjb25zdCB1c2VVU2hhcGVDb25uZWN0aW9uID1cbiAgICAgICAgICAgIHRhcmdldEluU291cmNlQkJveCB8fFxuICAgICAgICAgICAgZy5pbnRlcnNlY3Rpb24ucmVjdFdpdGhSZWN0KGluZmxhdGVkU291cmNlQkJveCwgdGFyZ2V0QkJveCkgfHxcbiAgICAgICAgICAgIChzb3ggPj0gdG94ICYmIChpbmZsYXRlZFNvdXJjZUJCb3guYm90dG9tTGVmdCgpLnkgPD0gdG95IHx8IGluZmxhdGVkU291cmNlQkJveC50b3BMZWZ0KCkueSA+PSB0b3kpKSB8fFxuICAgICAgICAgICAgKHNveCA8PSB0b3ggJiYgKGluZmxhdGVkVGFyZ2V0QkJveC5ib3R0b21MZWZ0KCkueSA8PSBzb3kgfHwgaW5mbGF0ZWRUYXJnZXRCQm94LnRvcExlZnQoKS55ID49IHNveSkpO1xuXG4gICAgICAgIC8vIFUtc2hhcGUgY29ubmVjdGlvbiBpcyBhIHN0cmFpZ2h0IGxpbmUgaWYgYHNveWAgYW5kIGB0b3lgIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAodXNlVVNoYXBlQ29ubmVjdGlvbiAmJiBzb3kgIT09IHRveSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IE1hdGgubWF4KHNveCwgdG94KSwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBNYXRoLm1heChzb3gsIHRveCksIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCB4MSA9IE1hdGgubWF4KChzeDAgKyB0eDEpIC8gMiwgdG94KTtcbiAgICAgICAgbGV0IHgyID0gTWF0aC5tYXgoKHN4MSArIHR4MCkgLyAyLCBzb3gpO1xuXG4gICAgICAgIGlmICh0b3ggPD0gc294KSB7XG4gICAgICAgICAgICBpZiAodG9wRCA8PSBib3R0b21EKSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHNteTAsIHRveSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heChzbXkxLCB0b3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRvcEQgPD0gYm90dG9tRCkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbih0bXkwLCBzb3kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgodG15MSwgc295KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHgyLCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeDogeDIsIHkgfSxcbiAgICAgICAgICAgIHsgeDogeDEsIHkgfSxcbiAgICAgICAgICAgIHsgeDogeDEsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAndG9wJyAmJiB0YXJnZXRTaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc294IDw9IHRteDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc294ICsgc291cmNlTWFyZ2luLCB0b3gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzbXkwLCB0bXkwKTtcblxuICAgICAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHgsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIGBzb3VyY2VNYXJnaW5gIHNpbmNlIHRoZSBzb3VyY2UgYW5jaG9yIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVYID0gKHNveCAtIHNvdXJjZU1hcmdpbiArIHRveCkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGFuY2hvck1pZGRsZVgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogYW5jaG9yTWlkZGxlWCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc215MCA+IHRveSkge1xuICAgICAgICAgICAgaWYgKHNveCA8IHRveCkge1xuICAgICAgICAgICAgICAgIGxldCB5ID0gdG15MDtcblxuICAgICAgICAgICAgICAgIGlmICh0bXkxIDw9IHNteTAgJiYgdG14MSA+PSBzb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbeyB4OiBzb3gsIHk6IHRveSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChtaWRkbGVPZlZlcnRpY2FsU2lkZXMsIHRteDEpO1xuXG4gICAgICAgIGlmIChzb3ggPiB0b3ggJiYgc3kxID49IHRveSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPiBzbXgwICYmIHNveSA8IHR5MSkge1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHNteTAsIHRteTApO1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHNteDEsIHRteDEpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICd0b3AnICYmIHRhcmdldFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0UG9pbnQpO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNveCA+PSB0bXgwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHNveCAtIHNvdXJjZU1hcmdpbiwgdG94KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc215MCwgdG15MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHgsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYHNvdXJjZU1hcmdpbmAgc2luY2UgdGhlIHNvdXJjZSBhbmNob3IgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdGFyZ2V0IGFuY2hvclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWCA9IChzb3ggKyBzb3VyY2VNYXJnaW4gKyB0b3gpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBhbmNob3JNaWRkbGVYLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGFuY2hvck1pZGRsZVgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteTAgPiB0b3kpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPiB0b3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHRteTA7XG5cbiAgICAgICAgICAgICAgICBpZiAodG15MSA8PSBzbXkwICYmIHRteDAgPD0gc294KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogc294LCB5OiB0b3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4odG14MCwgbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc294IDwgdG94ICYmIHN5MSA+PSB0b3kpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IHNteDEgJiYgc295IDwgdHkxKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc215MCwgdG15MCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc214MCwgdG14MCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2JvdHRvbScgJiYgdGFyZ2V0U2lkZSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0UG9pbnQpO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNveCA8PSB0bXgxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHNveCArIHNvdXJjZU1hcmdpbiwgdG94KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc215MSwgdG15MSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHRoZSBgc291cmNlTWFyZ2luYCBzaW5jZSB0aGUgc291cmNlIGFuY2hvciBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgdGFyZ2V0IGFuY2hvclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWCA9IChzb3ggLSBzb3VyY2VNYXJnaW4gKyB0b3gpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBhbmNob3JNaWRkbGVYLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGFuY2hvck1pZGRsZVgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteTEgPCB0b3kpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPCB0b3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHRteTE7XG5cbiAgICAgICAgICAgICAgICBpZiAodG15MCA+PSBzbXkxICYmIHRteDEgPj0gc294KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogc294LCB5OiB0b3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgobWlkZGxlT2ZWZXJ0aWNhbFNpZGVzLCB0bXgxKTtcblxuICAgICAgICBpZiAoc294ID4gdG94ICYmIHN5MCA8PSB0b3kpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4ID4gc214MCAmJiBzb3kgPiB0eTApIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChzbXgxLCB0bXgxKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAnYm90dG9tJyAmJiB0YXJnZXRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldFBvaW50KTtcblxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBvaW50IGlzIGluc2lkZSB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPj0gdG14MCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzb3ggLSBzb3VyY2VNYXJnaW4sIHRveCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHNteTEsIHRteTEpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGBzb3VyY2VNYXJnaW5gIHNpbmNlIHRoZSBzb3VyY2UgYW5jaG9yIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRhcmdldCBhbmNob3JcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvck1pZGRsZVggPSAoc294ICsgc291cmNlTWFyZ2luICsgdG94KSAvIDI7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogYW5jaG9yTWlkZGxlWCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBhbmNob3JNaWRkbGVYLCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXkxIDwgdG95KSB7XG4gICAgICAgICAgICBpZiAoc294ID4gdG94KSB7XG4gICAgICAgICAgICAgICAgbGV0IHkgPSB0bXkxO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRteTAgPj0gc215MSAmJiB0bXgwIDw9IHNveCkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHNveCwgeTogdG95IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHRteDAsIG1pZGRsZU9mVmVydGljYWxTaWRlcyk7XG5cbiAgICAgICAgaWYgKHNveCA8IHRveCAmJiBzeTAgPD0gdG95KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IHNteDEgJiYgc295ID4gdHkwKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc215MSwgdG15MSk7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc214MCwgdG14MCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2xlZnQnICYmIHRhcmdldFNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc295IDw9IHRteTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc214MCwgdG14MCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHNveSArIHNvdXJjZU1hcmdpbiwgdG95KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBhYm92ZSB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWSA9IChzb3kgLSBzb3VyY2VNYXJnaW4gKyB0b3kpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IGFuY2hvck1pZGRsZVkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogYW5jaG9yTWlkZGxlWSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteDAgPiB0b3gpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPCB0b3kpIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHRteDA7XG5cbiAgICAgICAgICAgICAgICBpZiAodG14MSA8PSBzbXgwICYmIHRteTEgPj0gc295KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHRteTEsIG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc295ID4gdG95ICYmIHN4MSA+PSB0b3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5ID4gc215MCAmJiBzb3ggPCB0eDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzbXgwLCB0bXgwKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdsZWZ0JyAmJiB0YXJnZXRTaWRlID09PSAndG9wJykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0UG9pbnQpO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNveSA+PSB0bXkwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHNveSAtIHNvdXJjZU1hcmdpbiwgdG95KTtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc214MCwgdG14MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSB0b3Agc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBiZWxvdyB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBgc291cmNlTWFyZ2luYCBzaW5jZSB0aGUgc291cmNlIGFuY2hvciBpcyBhYm92ZSB0aGUgdGFyZ2V0IGFuY2hvclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWSA9IChzb3kgKyBzb3VyY2VNYXJnaW4gKyB0b3kpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IGFuY2hvck1pZGRsZVkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogYW5jaG9yTWlkZGxlWSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteDAgPiB0b3gpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPiB0b3kpIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHRteDA7XG5cbiAgICAgICAgICAgICAgICBpZiAodG14MSA8PSBzbXgwICYmIHRteTAgPD0gc295KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHRteTAsIG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc295IDwgdG95ICYmIHN4MSA+PSB0b3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA8IHNteTEgJiYgc294IDwgdHgxKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc214MCwgdG14MCk7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc215MCwgdG15MCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3JpZ2h0JyAmJiB0YXJnZXRTaWRlID09PSAndG9wJykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0UG9pbnQpO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNveSA+PSB0bXkwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHNteDEsIHRteDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzb3kgLSBzb3VyY2VNYXJnaW4sIHRveSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSB0b3Agc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9LCAvLyBQYXRoIGFkanVzdG1lbnQgZm9yIHJpZ2h0IHNpZGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgYmVsb3cgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgIC8vIEFkanVzdCBzb3VyY2VNYXJnaW4gY2FsY3VsYXRpb24gc2luY2UgdGhlIHNvdXJjZSBhbmNob3IgaXMgbm93IG9uIHRoZSByaWdodFxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWSA9IChzb3kgKyBzb3VyY2VNYXJnaW4gKyB0b3kpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IGFuY2hvck1pZGRsZVkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogYW5jaG9yTWlkZGxlWSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteDEgPCB0b3gpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPiB0b3kpIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHRteDE7XG5cbiAgICAgICAgICAgICAgICBpZiAodG14MCA+PSBzbXgxICYmIHRteTAgPD0gc295KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHRteTAsIG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc295IDwgdG95ICYmIHN4MCA8PSB0b3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA8IHNteTEgJiYgc294ID4gdHgwKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc214MSwgdG14MSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc215MCwgdG15MCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAncmlnaHQnICYmIHRhcmdldFNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc295IDw9IHRteTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc214MSwgdG14MSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHNveSArIHNvdXJjZU1hcmdpbiwgdG95KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBhYm92ZSB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWSA9IChzb3kgLSBzb3VyY2VNYXJnaW4gKyB0b3kpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IGFuY2hvck1pZGRsZVkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogYW5jaG9yTWlkZGxlWSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteDEgPCB0b3gpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPCB0b3kpIHtcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHRteDE7XG5cbiAgICAgICAgICAgICAgICBpZiAodG14MCA+PSBzbXgxICYmIHRteTEgPj0gc295KSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHRveCwgeTogc295IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHRteTEsIG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc295ID4gdG95ICYmIHN4MCA8PSB0b3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5ID4gc215MCAmJiBzb3ggPiB0eDApIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChzbXgxLCB0bXgxKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldExvb3BDb29yZGluYXRlcyhkaXJlY3Rpb24sIGFuZ2xlLCBtYXJnaW4pIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuTEVGVCB8fCBkaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuUklHSFQ7XG5cbiAgICBsZXQgZHggPSAwO1xuICAgIGxldCBkeSA9IDA7XG5cbiAgICBzd2l0Y2ggKGcubm9ybWFsaXplQW5nbGUoTWF0aC5yb3VuZChhbmdsZSkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIGR4ID0gaXNIb3Jpem9udGFsID8gMCA6IG1hcmdpbjtcbiAgICAgICAgICAgIGR5ID0gaXNIb3Jpem9udGFsID8gbWFyZ2luIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBkeCA9IGlzSG9yaXpvbnRhbCA/IDAgOiAtbWFyZ2luO1xuICAgICAgICAgICAgZHkgPSBpc0hvcml6b250YWwgPyAtbWFyZ2luIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7IGR4LCBkeSB9O1xufVxuXG5mdW5jdGlvbiByaWdodEFuZ2xlUm91dGVyKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG4gICAgY29uc3QgeyBzb3VyY2VEaXJlY3Rpb24gPSBEaXJlY3Rpb25zLkFVVE8sIHRhcmdldERpcmVjdGlvbiA9IERpcmVjdGlvbnMuQVVUTyB9ID0gb3B0O1xuICAgIGNvbnN0IG1hcmdpbiA9IG9wdC5tYXJnaW4gfHwgMjA7XG4gICAgY29uc3QgdXNlVmVydGljZXMgPSBvcHQudXNlVmVydGljZXMgfHwgZmFsc2U7XG5cbiAgICBjb25zdCBpc1NvdXJjZVBvcnQgPSAhIWxpbmtWaWV3Lm1vZGVsLnNvdXJjZSgpLnBvcnQ7XG4gICAgY29uc3Qgc291cmNlUG9pbnQgPSBwb2ludERhdGFGcm9tQW5jaG9yKGxpbmtWaWV3LnNvdXJjZVZpZXcsIGxpbmtWaWV3LnNvdXJjZUFuY2hvciwgbGlua1ZpZXcuc291cmNlQkJveCwgc291cmNlRGlyZWN0aW9uLCBpc1NvdXJjZVBvcnQsIGxpbmtWaWV3LnNvdXJjZUFuY2hvciwgbWFyZ2luKTtcblxuICAgIGNvbnN0IGlzVGFyZ2V0UG9ydCA9ICEhbGlua1ZpZXcubW9kZWwudGFyZ2V0KCkucG9ydDtcbiAgICBjb25zdCB0YXJnZXRQb2ludCA9IHBvaW50RGF0YUZyb21BbmNob3IobGlua1ZpZXcudGFyZ2V0VmlldywgbGlua1ZpZXcudGFyZ2V0QW5jaG9yLCBsaW5rVmlldy50YXJnZXRCQm94LCB0YXJnZXREaXJlY3Rpb24sIGlzVGFyZ2V0UG9ydCwgbGlua1ZpZXcudGFyZ2V0QW5jaG9yLCBtYXJnaW4pO1xuXG4gICAgbGV0IHJlc3VsdFZlcnRpY2VzID0gW107XG5cbiAgICBpZiAoIXVzZVZlcnRpY2VzIHx8IHZlcnRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2ltcGxpZnlQb2ludHMocm91dGVCZXR3ZWVuUG9pbnRzKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCkpO1xuICAgIH1cblxuICAgIGNvbnN0IHZlcnRpY2VzRGF0YSA9IHZlcnRpY2VzLm1hcCgodikgPT4gcG9pbnREYXRhRnJvbVZlcnRleCh2KSk7XG4gICAgY29uc3QgW2ZpcnN0VmVydGV4XSA9IHZlcnRpY2VzRGF0YTtcblxuICAgIGNvbnN0IFtyZXNvbHZlZFNvdXJjZURpcmVjdGlvbl0gPSByZXNvbHZlU2lkZXMoc291cmNlUG9pbnQsIGZpcnN0VmVydGV4KTtcbiAgICBjb25zdCBpc0VsZW1lbnQgPSBzb3VyY2VQb2ludC52aWV3ICYmIHNvdXJjZVBvaW50LnZpZXcubW9kZWwuaXNFbGVtZW50KCk7XG4gICAgY29uc3Qgc291cmNlQkJveCA9IGlzRWxlbWVudCA/IG1vdmVBbmRFeHBhbmRCQm94KHNvdXJjZVBvaW50LnZpZXcubW9kZWwuZ2V0QkJveCgpLCByZXNvbHZlZFNvdXJjZURpcmVjdGlvbiwgbWFyZ2luKSA6IG51bGw7XG4gICAgY29uc3QgaXNWZXJ0ZXhJbnNpZGUgPSBpc0VsZW1lbnQgPyBzb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQoZmlyc3RWZXJ0ZXgucG9pbnQpIDogZmFsc2U7XG5cbiAgICBpZiAoaXNWZXJ0ZXhJbnNpZGUpIHtcbiAgICAgICAgY29uc3Qgb3V0c2lkZVBvaW50ID0gZ2V0T3V0c2lkZVBvaW50KHJlc29sdmVkU291cmNlRGlyZWN0aW9uLCBzb3VyY2VQb2ludCwgbWFyZ2luKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludE92ZXJsYXAgPSBvdXRzaWRlUG9pbnQuZXF1YWxzKGZpcnN0VmVydGV4LnBvaW50KTtcblxuICAgICAgICBjb25zdCBhbGlnbnNWZXJ0aWNhbGx5ID0gc291cmNlUG9pbnQucG9pbnQueCA9PT0gZmlyc3RWZXJ0ZXgucG9pbnQueDtcbiAgICAgICAgY29uc3QgYWxpZ25zSG9yaXpvbnRhbGx5ID0gc291cmNlUG9pbnQucG9pbnQueSA9PT0gZmlyc3RWZXJ0ZXgucG9pbnQueTtcblxuICAgICAgICBjb25zdCBpc1ZlcnRpY2FsQW5kQWxpZ25zID0gYWxpZ25zVmVydGljYWxseSAmJiAocmVzb2x2ZWRTb3VyY2VEaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuVE9QIHx8IHJlc29sdmVkU291cmNlRGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkJPVFRPTSk7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbEFuZEFsaWducyA9IGFsaWduc0hvcml6b250YWxseSAmJiAocmVzb2x2ZWRTb3VyY2VEaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuTEVGVCB8fCByZXNvbHZlZFNvdXJjZURpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5SSUdIVCk7XG5cbiAgICAgICAgY29uc3QgZmlyc3RTZWdtZW50ID0gbmV3IGcuTGluZShzb3VyY2VQb2ludC5wb2ludCwgb3V0c2lkZVBvaW50KTtcbiAgICAgICAgY29uc3QgaXNWZXJ0ZXhPblNlZ21lbnQgPSBmaXJzdFNlZ21lbnQuY29udGFpbnNQb2ludChmaXJzdFZlcnRleC5wb2ludCk7XG5cbiAgICAgICAgY29uc3QgaXNWZXJ0ZXhBbGlnbmVkQW5kSW5zaWRlID0gaXNWZXJ0ZXhJbnNpZGUgJiYgKGlzSG9yaXpvbnRhbEFuZEFsaWducyB8fCBpc1ZlcnRpY2FsQW5kQWxpZ25zKTtcblxuICAgICAgICBcblxuICAgICAgICBpZiAoZmlyc3RQb2ludE92ZXJsYXApIHtcbiAgICAgICAgICAgIHJlc3VsdFZlcnRpY2VzLnB1c2goc291cmNlUG9pbnQucG9pbnQsIGZpcnN0VmVydGV4LnBvaW50KTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgYWNjZXNzIGRpcmVjdGlvbiBhcyB0aGUgb3Bwb3NpdGUgb2YgdGhlIHNvdXJjZSBkaXJlY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29ubmVjdCB0aGUgcm91dGUgd2l0aCB0aGUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgICAgIGZpcnN0VmVydGV4LmRpcmVjdGlvbiA9IE9QUE9TSVRFX0RJUkVDVElPTlNbcmVzb2x2ZWRTb3VyY2VEaXJlY3Rpb25dO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVmVydGV4T25TZWdtZW50IHx8IGlzVmVydGV4QWxpZ25lZEFuZEluc2lkZSkge1xuICAgICAgICAgICAgLy8gQ2FzZSB3aGVyZSB0aGVyZSBpcyBhIG5lZWQgdG8gY3JlYXRlIGEgbG9vcFxuICAgICAgICAgICAgY29uc3QgYW5nbGUgPSBnZXRTZWdtZW50QW5nbGUoaXNWZXJ0ZXhPblNlZ21lbnQgPyBmaXJzdFNlZ21lbnQgOiBuZXcgZy5MaW5lKHNvdXJjZVBvaW50LnBvaW50LCBmaXJzdFZlcnRleC5wb2ludCkpO1xuICAgICAgICAgICAgY29uc3QgeyBkeCwgZHkgfSA9IGdldExvb3BDb29yZGluYXRlcyhyZXNvbHZlZFNvdXJjZURpcmVjdGlvbiwgYW5nbGUsIG1hcmdpbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSBjcmVhdGVMb29wKHsgcG9pbnQ6IG91dHNpZGVQb2ludCB9LCBmaXJzdFZlcnRleCwgeyBkeCwgZHkgfSk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRDcmVhdGVkUG9pbnQgPSBsb29wWzJdO1xuICAgICAgICAgICAgY29uc3QgbG9vcEVuZFNlZ21lbnQgPSBuZXcgZy5MaW5lKGZpcnN0VmVydGV4LnBvaW50LCBzZWNvbmRDcmVhdGVkUG9pbnQpO1xuXG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NEaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW2dldFNlZ21lbnRBbmdsZShsb29wRW5kU2VnbWVudCldO1xuICAgICAgICAgICAgZmlyc3RWZXJ0ZXguZGlyZWN0aW9uID0gYWNjZXNzRGlyZWN0aW9uO1xuICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5sb29wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY3JlYXRlIGEgcm91dGUsIHVzZSB0aGUgYHJvdXRlQmV0d2VlblBvaW50c2AgdG8gY29uc3RydWN0IGEgcm91dGVcbiAgICAgICAgICAgIGZpcnN0VmVydGV4LmRpcmVjdGlvbiA9IHJlc29sdmVkU291cmNlRGlyZWN0aW9uO1xuICAgICAgICAgICAgZmlyc3RWZXJ0ZXgubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5yb3V0ZUJldHdlZW5Qb2ludHMoc291cmNlUG9pbnQsIGZpcnN0VmVydGV4LCB7IHRhcmdldEluU291cmNlQkJveDogdHJ1ZSB9KSwgZmlyc3RWZXJ0ZXgucG9pbnQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBvaW50IHJlc3BvbnNpYmxlIGZvciB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gb2YgdGhlIHJvdXRlXG4gICAgICAgIGNvbnN0IG5leHQgPSB2ZXJ0aWNlc0RhdGFbMV0gfHwgdGFyZ2V0UG9pbnQ7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHJlc29sdmVJbml0aWFsRGlyZWN0aW9uKHNvdXJjZVBvaW50LCBmaXJzdFZlcnRleCwgbmV4dCk7XG4gICAgICAgIGZpcnN0VmVydGV4LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblxuICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhzb3VyY2VQb2ludCwgZmlyc3RWZXJ0ZXgpLCBmaXJzdFZlcnRleC5wb2ludCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0aWNlc0RhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB2ZXJ0aWNlc0RhdGFbaV07XG4gICAgICAgIGNvbnN0IHRvID0gdmVydGljZXNEYXRhW2kgKyAxXTtcblxuICAgICAgICBjb25zdCBjb25uZWN0aW9uU2VnbWVudCA9IG5ldyBnLkxpbmUoZnJvbS5wb2ludCwgdG8ucG9pbnQpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uU2VnbWVudEFuZ2xlID0gZ2V0U2VnbWVudEFuZ2xlKGNvbm5lY3Rpb25TZWdtZW50KTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TZWdtZW50QW5nbGUgJSA5MCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gU2VnbWVudCBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRGlyZWN0aW9uID0gQU5HTEVfRElSRUNUSU9OX01BUFtjb25uZWN0aW9uU2VnbWVudEFuZ2xlXTtcblxuICAgICAgICAgICAgY29uc3Qgc2ltcGxpZmllZFJvdXRlID0gc2ltcGxpZnlQb2ludHMoWy4uLnJlc3VsdFZlcnRpY2VzLCBmcm9tLnBvaW50XSk7XG4gICAgICAgICAgICAvLyBjb25zdCBzaW1wbGlmaWVkUm91dGUyID0gc2ltcGxpZnlQb2ludHMoW2Zyb20ucG9pbnQsIC4uLnJlc3VsdFZlcnRpY2VzXSk7XG4gICAgICAgICAgICAvLyBGaW5kIG91dCB0aGUgZGlyZWN0aW9uIHRoYXQgaXMgdXNlZCB0byBjb25uZWN0IHRoZSBjdXJyZW50IHJvdXRlIHdpdGggdGhlIG5leHQgdmVydGV4XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NTZWdtZW50ID0gbmV3IGcuTGluZShzaW1wbGlmaWVkUm91dGVbc2ltcGxpZmllZFJvdXRlLmxlbmd0aCAtIDJdLCBzaW1wbGlmaWVkUm91dGVbc2ltcGxpZmllZFJvdXRlLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGFjY2Vzc1NlZ21lbnQyID0gbmV3IGcuTGluZShzaW1wbGlmaWVkUm91dGUyW3NpbXBsaWZpZWRSb3V0ZTIubGVuZ3RoIC0gMl0sIHNpbXBsaWZpZWRSb3V0ZTJbc2ltcGxpZmllZFJvdXRlMi5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NEaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW01hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKGFjY2Vzc1NlZ21lbnQpKV07XG4gICAgICAgICAgICAvLyBjb25zdCBhY2Nlc3NEaXJlY3Rpb24yID0gQU5HTEVfRElSRUNUSU9OX01BUFtNYXRoLnJvdW5kKGdldFNlZ21lbnRBbmdsZShhY2Nlc3NTZWdtZW50MikpXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGFjY2Vzc0RpcmVjdGlvbik7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhY2Nlc3NEaXJlY3Rpb24yKTtcbiAgICAgICAgICAgIC8vIGlmIChhY2Nlc3NEaXJlY3Rpb24gIT09IGFjY2Vzc0RpcmVjdGlvbjIpIHtcbiAgICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnZXJyb3InKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0nKTtcblxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25EaXJlY3Rpb24gIT09IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkaXJlY3Rpb25zIGFyZSBub3Qgb3Bwb3NpdGUsIHNvIHdlIGNhbiBjb25uZWN0IHRoZSB2ZXJ0aWNlcyBkaXJlY3RseVxuICAgICAgICAgICAgICAgIHJlc3VsdFZlcnRpY2VzLnB1c2goZnJvbS5wb2ludCwgdG8ucG9pbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFssIHRvRGlyZWN0aW9uXSA9IHJlc29sdmVTaWRlcyhmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgdG8uZGlyZWN0aW9uID0gdG9EaXJlY3Rpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkaXJlY3Rpb25zIGFyZSBvdmVybGFwcGluZywgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBsb29wXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsb29wUm91dGUsIGNvbnRpbnVlRGlyZWN0aW9uIH0gPSBsb29wU2VnbWVudChmcm9tLCB0bywgY29ubmVjdGlvblNlZ21lbnRBbmdsZSwgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICB0by5kaXJlY3Rpb24gPSBjb250aW51ZURpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3RpbmcgYSBsb29wXG4gICAgICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5sb29wUm91dGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZlcnRpY2VzIGFyZSBub3QgYWxpZ25lZCB2ZXJ0aWNhbGx5IG5vciBob3Jpem9udGFsbHlcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byByb3V0ZSBiZXR3ZWVuIHRoZW1cblxuICAgICAgICBjb25zdCBbZnJvbURpcmVjdGlvbiwgdG9EaXJlY3Rpb25dID0gcmVzb2x2ZURpcmVjdGlvbihmcm9tLCB0byk7XG5cbiAgICAgICAgZnJvbS5kaXJlY3Rpb24gPSBmcm9tRGlyZWN0aW9uO1xuICAgICAgICB0by5kaXJlY3Rpb24gPSB0b0RpcmVjdGlvbjtcblxuICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhmcm9tLCB0byksIHRvLnBvaW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0VmVydGV4ID0gdmVydGljZXNEYXRhW3ZlcnRpY2VzRGF0YS5sZW5ndGggLSAxXTtcblxuICAgIGlmICh0YXJnZXRQb2ludC52aWV3ICYmIHRhcmdldFBvaW50LnZpZXcubW9kZWwuaXNFbGVtZW50KCkpIHtcbiAgICAgICAgY29uc3QgWywgcmVzb2x2ZWRUYXJnZXREaXJlY3Rpb25dID0gcmVzb2x2ZVNpZGVzKGxhc3RWZXJ0ZXgsIHRhcmdldFBvaW50KTtcbiAgICAgICAgY29uc3Qgb3V0c2lkZVBvaW50ID0gZ2V0T3V0c2lkZVBvaW50KHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uLCB0YXJnZXRQb2ludCwgbWFyZ2luKTtcblxuICAgICAgICAvLyB0aGUgbGFzdCBwb2ludCBvZiBgc2ltcGxpZmllZGAgYXJyYXkgaXMgdGhlIGxhc3QgZGVmaW5lZCB2ZXJ0ZXhcbiAgICAgICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBsYXN0IHNlZ21lbnQgY29udGludWVzIGluIGEgc3RyYWlnaHQgbGluZVxuICAgICAgICBjb25zdCBzaW1wbGlmaWVkID0gc2ltcGxpZnlQb2ludHMoWy4uLnJlc3VsdFZlcnRpY2VzLCBsYXN0VmVydGV4LnBvaW50XSk7XG4gICAgICAgIGNvbnN0IHNpbXBsaWZpZWRTZWdtZW50ID0gbmV3IGcuTGluZShzaW1wbGlmaWVkW3NpbXBsaWZpZWQubGVuZ3RoIC0gMl0sIHNpbXBsaWZpZWRbc2ltcGxpZmllZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGNvbnN0IHNpbXBsaWZpZWRTZWdtZW50QW5nbGUgPSBNYXRoLnJvdW5kKGdldFNlZ21lbnRBbmdsZShzaW1wbGlmaWVkU2VnbWVudCkpO1xuICAgICAgICBjb25zdCBkZWZpbmVkRGlyZWN0aW9uID0gQU5HTEVfRElSRUNUSU9OX01BUFtzaW1wbGlmaWVkU2VnbWVudEFuZ2xlXTtcblxuICAgICAgICBjb25zdCBsYXN0UG9pbnRPdmVybGFwID0gb3V0c2lkZVBvaW50LmVxdWFscyhsYXN0VmVydGV4LnBvaW50KTtcblxuICAgICAgICBpZiAoIWxhc3RQb2ludE92ZXJsYXAgfHwgKGxhc3RQb2ludE92ZXJsYXAgJiYgZGVmaW5lZERpcmVjdGlvbiA9PT0gcmVzb2x2ZWRUYXJnZXREaXJlY3Rpb24pKSB7XG5cbiAgICAgICAgICAgIGxhc3RWZXJ0ZXguZGlyZWN0aW9uID0gZGVmaW5lZERpcmVjdGlvbjtcblxuICAgICAgICAgICAgbGV0IGxhc3RTZWdtZW50Um91dGUgPSByb3V0ZUJldHdlZW5Qb2ludHMobGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgW3AxLCBwMl0gPSBzaW1wbGlmeVBvaW50cyhbLi4ubGFzdFNlZ21lbnRSb3V0ZSwgdGFyZ2V0UG9pbnQucG9pbnRdKTtcblxuICAgICAgICAgICAgY29uc3QgbGFzdFNlZ21lbnQgPSBuZXcgZy5MaW5lKHAxLCBwMik7XG4gICAgICAgICAgICBjb25zdCByb3VuZGVkTGFzdFNlZ21lbnRBbmdsZSA9IE1hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKGxhc3RTZWdtZW50KSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0U2VnbWVudERpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbcm91bmRlZExhc3RTZWdtZW50QW5nbGVdO1xuXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRCQm94ID0gbW92ZUFuZEV4cGFuZEJCb3godGFyZ2V0UG9pbnQudmlldy5tb2RlbC5nZXRCQm94KCksIHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBjb25zdCBhbGlnbnNWZXJ0aWNhbGx5ID0gbGFzdFZlcnRleC5wb2ludC54ID09PSB0YXJnZXRQb2ludC5wb2ludC54O1xuICAgICAgICAgICAgY29uc3QgYWxpZ25zSG9yaXpvbnRhbGx5ID0gbGFzdFZlcnRleC5wb2ludC55ID09PSB0YXJnZXRQb2ludC5wb2ludC55O1xuICAgICAgICAgICAgY29uc3QgaXNWZXJ0ZXhJbnNpZGUgPSB0YXJnZXRCQm94LmNvbnRhaW5zUG9pbnQobGFzdFZlcnRleC5wb2ludCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzVmVydGljYWxBbmRBbGlnbnMgPSBhbGlnbnNWZXJ0aWNhbGx5ICYmIChyZXNvbHZlZFRhcmdldERpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5UT1AgfHwgcmVzb2x2ZWRUYXJnZXREaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuQk9UVE9NKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbEFuZEFsaWducyA9IGFsaWduc0hvcml6b250YWxseSAmJiAocmVzb2x2ZWRUYXJnZXREaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuTEVGVCB8fCByZXNvbHZlZFRhcmdldERpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5SSUdIVCk7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFsYXN0UG9pbnRPdmVybGFwICYmIGlzVmVydGV4SW5zaWRlICYmIChpc0hvcml6b250YWxBbmRBbGlnbnMgfHwgaXNWZXJ0aWNhbEFuZEFsaWducykpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlcyB3aGVuIHRoZSBsYXN0IHZlcnRleCBpcyBpbnNpZGUgdGhlIHRhcmdldCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gYW5kIGluIGlzIGFsaWduZWQgd2l0aCB0aGUgY29ubmVjdGlvbiBwb2ludCA9PiBjb25zdHJ1Y3QgYSBsb29wXG4gICAgICAgICAgICAgICAgY29uc3QgeyBkeCwgZHkgfSA9IGdldExvb3BDb29yZGluYXRlcyhyZXNvbHZlZFRhcmdldERpcmVjdGlvbiwgc2ltcGxpZmllZFNlZ21lbnRBbmdsZSwgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudFJvdXRlID0gY3JlYXRlTG9vcChsYXN0VmVydGV4LCB7IHBvaW50OiBvdXRzaWRlUG9pbnQgfSwgeyBkeCwgZHkgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzVmVydGV4SW5zaWRlICYmIHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uICE9PSBPUFBPU0lURV9ESVJFQ1RJT05TW2RlZmluZWREaXJlY3Rpb25dKSB7XG4gICAgICAgICAgICAgICAgbGFzdFZlcnRleC5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgICAgICAgICAgbGFzdFZlcnRleC5kaXJlY3Rpb24gPSByZXNvbHZlZFRhcmdldERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudFJvdXRlID0gcm91dGVCZXR3ZWVuUG9pbnRzKGxhc3RWZXJ0ZXgsIHRhcmdldFBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFNlZ21lbnREaXJlY3Rpb24gIT09IGRlZmluZWREaXJlY3Rpb24gJiYgZGVmaW5lZERpcmVjdGlvbiA9PT0gT1BQT1NJVEVfRElSRUNUSU9OU1tsYXN0U2VnbWVudERpcmVjdGlvbl0pIHtcbiAgICAgICAgICAgICAgICBsYXN0VmVydGV4Lm1hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICBsYXN0U2VnbWVudFJvdXRlID0gcm91dGVCZXR3ZWVuUG9pbnRzKGxhc3RWZXJ0ZXgsIHRhcmdldFBvaW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5sYXN0U2VnbWVudFJvdXRlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNpbmNlIHRoZSB0YXJnZXQgaXMgb25seSBhIHBvaW50IHdlIGNhbiBhcHBseSB0aGUgc2FtZSBsb2dpYyBhcyBpZiB3ZSBjb25uZWN0ZWQgdHdvIHZlcnRpY2VzRGF0YVxuICAgICAgICBjb25zdCBmcm9tID0gbGFzdFZlcnRleDtcbiAgICAgICAgY29uc3QgdG8gPSB0YXJnZXRQb2ludDtcblxuICAgICAgICBjb25zdCBjb25uZWN0aW9uU2VnbWVudCA9IG5ldyBnLkxpbmUoZnJvbS5wb2ludCwgdG8ucG9pbnQpO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uU2VnbWVudEFuZ2xlID0gZ2V0U2VnbWVudEFuZ2xlKGNvbm5lY3Rpb25TZWdtZW50KTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TZWdtZW50QW5nbGUgJSA5MCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gU2VnbWVudCBpcyBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uRGlyZWN0aW9uID0gQU5HTEVfRElSRUNUSU9OX01BUFtjb25uZWN0aW9uU2VnbWVudEFuZ2xlXTtcblxuICAgICAgICAgICAgY29uc3Qgc2ltcGxpZmllZFJvdXRlID0gc2ltcGxpZnlQb2ludHMocmVzdWx0VmVydGljZXMpO1xuICAgICAgICAgICAgLy8gRmluZCBvdXQgdGhlIGRpcmVjdGlvbiB0aGF0IGlzIHVzZWQgdG8gY29ubmVjdCB0aGUgY3VycmVudCByb3V0ZSB3aXRoIHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgY29uc3QgYWNjZXNzU2VnbWVudCA9IG5ldyBnLkxpbmUoc2ltcGxpZmllZFJvdXRlW3NpbXBsaWZpZWRSb3V0ZS5sZW5ndGggLSAyXSwgZnJvbS5wb2ludCk7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NEaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW01hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKGFjY2Vzc1NlZ21lbnQpKV07XG5cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uRGlyZWN0aW9uICE9PSBPUFBPU0lURV9ESVJFQ1RJT05TW2FjY2Vzc0RpcmVjdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGlyZWN0aW9ucyBhcmUgbm90IG9wcG9zaXRlLCBzbyB3ZSBjYW4gY29ubmVjdCB0aGUgdmVydGljZXMgZGlyZWN0bHkgYnkgYWRkaW5nIHRoZSBmaXJzdCBwb2ludFxuICAgICAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgcG9pbnQgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaChmcm9tLnBvaW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRpcmVjdGlvbnMgYXJlIG92ZXJsYXBwaW5nLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGxvb3BcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxvb3BSb3V0ZSB9ID0gbG9vcFNlZ21lbnQoZnJvbSwgdG8sIGNvbm5lY3Rpb25TZWdtZW50QW5nbGUsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IHBvaW50IHNpbmNlIGl0IGlzIHRoZSB0YXJnZXQgdGhhdCBpcyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAgICAgICAgICAgICBsb29wUm91dGUucG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0aW5nIGEgbG9vcFxuICAgICAgICAgICAgICAgIHJlc3VsdFZlcnRpY2VzLnB1c2goLi4ubG9vcFJvdXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBsYXN0IHZlcnRleCBhbmQgdGhlIHRhcmdldCBhcmUgbm90IGFsaWduZWQgdmVydGljYWxseSBub3IgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJvdXRlIGJldHdlZW4gdGhlbVxuICAgICAgICAgICAgY29uc3QgW2Zyb21EaXJlY3Rpb24sIHRvRGlyZWN0aW9uXSA9IHJlc29sdmVEaXJlY3Rpb24oZnJvbSwgdG8pO1xuXG4gICAgICAgICAgICBmcm9tLmRpcmVjdGlvbiA9IGZyb21EaXJlY3Rpb247XG4gICAgICAgICAgICB0by5kaXJlY3Rpb24gPSB0b0RpcmVjdGlvbjtcblxuICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5yb3V0ZUJldHdlZW5Qb2ludHMoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaW1wbGlmeVBvaW50cyhyZXN1bHRWZXJ0aWNlcyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXJlY3Rpb24oZnJvbSwgdG8pIHtcbiAgICBjb25zdCBhY2Nlc3NEaXJlY3Rpb24gPSBmcm9tLmRpcmVjdGlvbjtcbiAgICBjb25zdCBpc0RpcmVjdGlvblZlcnRpY2FsID0gVkVSVElDQUxfRElSRUNUSU9OUy5pbmNsdWRlcyhhY2Nlc3NEaXJlY3Rpb24pO1xuXG4gICAgbGV0IHNvdXJjZURpcmVjdGlvbiA9IGZyb20uZGlyZWN0aW9uO1xuICAgIGxldCB0YXJnZXREaXJlY3Rpb24gPSB0by5kaXJlY3Rpb247XG5cbiAgICBpZiAoaXNEaXJlY3Rpb25WZXJ0aWNhbCkge1xuICAgICAgICBjb25zdCBpc1RvQWJvdmUgPSBmcm9tLnBvaW50LnkgPiB0by5wb2ludC55O1xuICAgICAgICBjb25zdCBkeCA9IHRvLnBvaW50LnggLSBmcm9tLnBvaW50Lng7XG5cbiAgICAgICAgaWYgKGFjY2Vzc0RpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5CT1RUT00pIHtcbiAgICAgICAgICAgIC8vIElmIGlzVG9BYm92ZSA9PT0gZmFsc2UgYW5kIHdlIG5lZWQgZmlndXJlIG91dCBpZiB0byBnbyBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAgICBzb3VyY2VEaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBPUFBPU0lURV9ESVJFQ1RJT05TW2FjY2Vzc0RpcmVjdGlvbl0gOiBkeCA+PSAwID8gRGlyZWN0aW9ucy5SSUdIVCA6IERpcmVjdGlvbnMuTEVGVDtcblxuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IERpcmVjdGlvbnMuTEVGVCA6IERpcmVjdGlvbnMuVE9QO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBEaXJlY3Rpb25zLlJJR0hUIDogRGlyZWN0aW9ucy5UT1A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpc1RvQWJvdmUgPT09IHRydWUgYW5kIHdlIG5lZWQgZmlndXJlIG91dCBpZiB0byBnbyBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgICAgICBzb3VyY2VEaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBkeCA+PSAwID8gRGlyZWN0aW9ucy5SSUdIVCA6IERpcmVjdGlvbnMuTEVGVCA6IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXTtcblxuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5MRUZUO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvQWJvdmUgPyBEaXJlY3Rpb25zLkJPVFRPTSA6IERpcmVjdGlvbnMuUklHSFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc1RvTGVmdCA9IGZyb20ucG9pbnQueCA+IHRvLnBvaW50Lng7XG4gICAgICAgIGNvbnN0IGR5ID0gdG8ucG9pbnQueSAtIGZyb20ucG9pbnQueTtcblxuICAgICAgICBpZiAoYWNjZXNzRGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlJJR0hUKSB7XG4gICAgICAgICAgICBzb3VyY2VEaXJlY3Rpb24gPSBpc1RvTGVmdCA/IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXSA6IGR5ID49IDAgPyBEaXJlY3Rpb25zLkJPVFRPTSA6IERpcmVjdGlvbnMuVE9QO1xuXG4gICAgICAgICAgICBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0xlZnQgPyBEaXJlY3Rpb25zLlRPUCA6IERpcmVjdGlvbnMuTEVGVDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0xlZnQgPyBEaXJlY3Rpb25zLkJPVFRPTSA6IERpcmVjdGlvbnMuTEVGVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZURpcmVjdGlvbiA9IGlzVG9MZWZ0ID8gZHkgPj0gMCA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5UT1AgOiBPUFBPU0lURV9ESVJFQ1RJT05TW2FjY2Vzc0RpcmVjdGlvbl07XG5cbiAgICAgICAgICAgIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvTGVmdCA/IERpcmVjdGlvbnMuUklHSFQgOiBEaXJlY3Rpb25zLlRPUDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0xlZnQgPyBEaXJlY3Rpb25zLlJJR0hUIDogRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3NvdXJjZURpcmVjdGlvbiwgdGFyZ2V0RGlyZWN0aW9uXTtcbn1cblxucmlnaHRBbmdsZVJvdXRlci5EaXJlY3Rpb25zID0gRGlyZWN0aW9ucztcblxuZXhwb3J0IGNvbnN0IHJpZ2h0QW5nbGUgPSByaWdodEFuZ2xlUm91dGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/routers/rightAngle.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/shapes/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/shapes/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   standard: () => (/* reexport module object */ _standard_mjs__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _standard_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./standard.mjs */ \"(ssr)/./node_modules/@joint/core/src/shapes/standard.mjs\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3NoYXBlcy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkM7O0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvc2hhcGVzL2luZGV4Lm1qcz9mMDBlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHN0YW5kYXJkIGZyb20gJy4vc3RhbmRhcmQubWpzJztcblxuZXhwb3J0IHsgc3RhbmRhcmQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/shapes/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/shapes/standard.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/shapes/standard.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderedImage: () => (/* binding */ BorderedImage),\n/* harmony export */   Circle: () => (/* binding */ Circle),\n/* harmony export */   Cylinder: () => (/* binding */ Cylinder),\n/* harmony export */   DoubleLink: () => (/* binding */ DoubleLink),\n/* harmony export */   Ellipse: () => (/* binding */ Ellipse),\n/* harmony export */   EmbeddedImage: () => (/* binding */ EmbeddedImage),\n/* harmony export */   HeaderedRectangle: () => (/* binding */ HeaderedRectangle),\n/* harmony export */   Image: () => (/* binding */ Image),\n/* harmony export */   InscribedImage: () => (/* binding */ InscribedImage),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   Polygon: () => (/* binding */ Polygon),\n/* harmony export */   Polyline: () => (/* binding */ Polyline),\n/* harmony export */   Rectangle: () => (/* binding */ Rectangle),\n/* harmony export */   ShadowLink: () => (/* binding */ ShadowLink),\n/* harmony export */   TextBlock: () => (/* binding */ TextBlock)\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/Element.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Element.mjs\");\n/* harmony import */ var _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dia/Link.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Link.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _dia_attributes_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dia/attributes/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/attributes/index.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/env/index.mjs\");\n\n\n\n\n\n\n\n\n// ELEMENTS\n\nconst Rectangle = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Rectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body',\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Circle = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Circle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(s/2)',\n            cy: 'calc(s/2)',\n            r: 'calc(s/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'circle',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Ellipse = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Ellipse', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Path = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Path', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            d: 'M 0 0 H calc(w) V calc(h) H 0 Z',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Polygon = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Polygon', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polygon',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Polyline = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Polyline', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polyline',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Image = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Image', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        image: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst BorderedImage = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.BorderedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5,\n            fill: '#FFFFFF'\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'background',\n        attributes: {\n            'stroke': 'none'\n        }\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'rect',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst EmbeddedImage = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.EmbeddedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#FFFFFF',\n            strokeWidth: 2\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(0.3*w)',\n            height: 'calc(h-20)',\n            x: 10,\n            y: 10,\n            preserveAspectRatio: 'xMidYMin'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'left',\n            x: 'calc(0.3*w+20)', // 10 + 10\n            y: 10,\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst InscribedImage = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.InscribedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            fill: '#FFFFFF'\n        },\n        image: {\n            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n            width: 'calc(0.68*w)',\n            height: 'calc(0.68*h)',\n            // The image offset is calculated as (100% - 68%) / 2\n            x: 'calc(0.16*w)',\n            y: 'calc(0.16*h)',\n            preserveAspectRatio: 'xMidYMid'\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'background'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'ellipse',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst HeaderedRectangle = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.HeaderedRectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        header: {\n            width: 'calc(w)',\n            height: 30,\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        headerText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 15,\n            fontSize: 16,\n            fill: '#333333'\n        },\n        bodyText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'rect',\n        selector: 'header'\n    }, {\n        tagName: 'text',\n        selector: 'headerText'\n    }, {\n        tagName: 'text',\n        selector: 'bodyText'\n    }]\n});\n\nvar CYLINDER_TILT = 10;\n\nconst Cylinder = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Cylinder', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            lateralArea: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        top: {\n            cx: 'calc(w/2)',\n            cy: CYLINDER_TILT,\n            rx: 'calc(w/2)',\n            ry: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'ellipse',\n        selector: 'top'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }],\n\n    topRy: function(t, opt) {\n        // getter\n        if (t === undefined) return this.attr('body/lateralArea');\n\n        // setter\n        var bodyAttrs = { lateralArea: t };\n\n        var isPercentageSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(t);\n        var ty = (isPercentageSetter) ? `calc(${parseFloat(t) / 100}*h)` : t;\n        var topAttrs = { cy: ty, ry: ty };\n\n        return this.attr({ body: bodyAttrs, top: topAttrs }, opt);\n    }\n\n}, {\n    attributes: {\n        'lateral-area': {\n            set: function(t, refBBox) {\n                var isPercentageSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(t);\n                if (isPercentageSetter) t = parseFloat(t) / 100;\n\n                var x = refBBox.x;\n                var y = refBBox.y;\n                var w = refBBox.width;\n                var h = refBBox.height;\n\n                // curve control point variables\n                var rx = w / 2;\n                var ry = isPercentageSetter ? (h * t) : t;\n\n                var kappa = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].KAPPA;\n                var cx = kappa * rx;\n                var cy = kappa * (isPercentageSetter ? (h * t) : t);\n\n                // shape variables\n                var xLeft = x;\n                var xCenter = x + (w / 2);\n                var xRight = x + w;\n\n                var ySideTop = y + ry;\n                var yCurveTop = ySideTop - ry;\n                var ySideBottom = y + h - ry;\n                var yCurveBottom = y + h;\n\n                // return calculated shape\n                var data = [\n                    'M', xLeft, ySideTop,\n                    'L', xLeft, ySideBottom,\n                    'C', x, (ySideBottom + cy), (xCenter - cx), yCurveBottom, xCenter, yCurveBottom,\n                    'C', (xCenter + cx), yCurveBottom, xRight, (ySideBottom + cy), xRight, ySideBottom,\n                    'L', xRight, ySideTop,\n                    'C', xRight, (ySideTop - cy), (xCenter + cx), yCurveTop, xCenter, yCurveTop,\n                    'C', (xCenter - cx), yCurveTop, xLeft, (ySideTop - cy), xLeft, ySideTop,\n                    'Z'\n                ];\n                return { d: data.join(' ') };\n            },\n            unset: 'd'\n        }\n    }\n});\n\nvar foLabelMarkup = {\n    tagName: 'foreignObject',\n    selector: 'foreignObject',\n    attributes: {\n        'overflow': 'hidden'\n    },\n    children: [{\n        tagName: 'div',\n        namespaceURI: 'http://www.w3.org/1999/xhtml',\n        selector: 'label',\n        style: {\n            width: '100%',\n            height: '100%',\n            position: 'static',\n            backgroundColor: 'transparent',\n            textAlign: 'center',\n            margin: 0,\n            padding: '0px 5px',\n            boxSizing: 'border-box',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center'\n        }\n    }]\n};\n\nvar svgLabelMarkup = {\n    tagName: 'text',\n    selector: 'label',\n    attributes: {\n        'text-anchor': 'middle'\n    }\n};\n\nvar labelMarkup = (_env_index_mjs__WEBPACK_IMPORTED_MODULE_3__.env.test('svgforeignobject')) ? foLabelMarkup : svgLabelMarkup;\n\nconst TextBlock = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.TextBlock', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#ffffff',\n            strokeWidth: 2\n        },\n        foreignObject: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n        },\n        label: {\n            style: {\n                fontSize: 14\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, labelMarkup]\n}, {\n    attributes: {\n        text: {\n            set: function(text, refBBox, node, attrs) {\n                if (node instanceof HTMLElement) {\n                    node.textContent = text;\n                } else {\n                    // No foreign object\n                    var style = attrs['style'] || {};\n                    var wrapValue = { text, width: -5, height: '100%' };\n                    var wrapAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)({ 'text-vertical-anchor': 'middle' }, style);\n                    _dia_attributes_index_mjs__WEBPACK_IMPORTED_MODULE_5__.attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);\n                    return { fill: style.color || null };\n                }\n            },\n            unset: function(node) {\n                node.textContent = '';\n                if (node instanceof SVGElement) {\n                    return 'fill';\n                }\n            },\n            position: function(text, refBBox, node) {\n                // No foreign object\n                if (node instanceof SVGElement) return refBBox.center();\n            }\n        }\n    }\n});\n\n// LINKS\n\nconst Link = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__.Link.define('standard.Link', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#333333',\n            strokeWidth: 2,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 10 -5 0 0 10 5 z'\n            }\n        },\n        wrapper: {\n            connection: true,\n            strokeWidth: 10,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'wrapper',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer',\n            'stroke': 'transparent',\n            'stroke-linecap': 'round'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nconst DoubleLink = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__.Link.define('standard.DoubleLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#DDDDDD',\n            strokeWidth: 4,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                type: 'path',\n                stroke: '#000000',\n                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n            }\n        },\n        outline: {\n            connection: true,\n            stroke: '#000000',\n            strokeWidth: 6,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'outline',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nconst ShadowLink = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__.Link.define('standard.ShadowLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#FF0000',\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M 0 -10 -10 0 0 10 z'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        },\n        shadow: {\n            connection: true,\n            transform: 'translate(3,6)',\n            stroke: '#000000',\n            strokeOpacity: 0.2,\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 0 -10 -10 0 0 10 z',\n                'stroke': 'none'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'shadow',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3NoYXBlcy9zdGFuZGFyZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDYztBQUNNO0FBQ007QUFDQTtBQUNsQjs7O0FBR3ZDOztBQUVPLGtCQUFrQixxREFBTztBQUNoQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLGVBQWUscURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLGdCQUFnQixxREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFTSxhQUFhLHFEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLGdCQUFnQixxREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFTSxpQkFBaUIscURBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sY0FBYyxxREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sc0JBQXNCLHFEQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLHNCQUFzQixxREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sdUJBQXVCLHFEQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFTSwwQkFBMEIscURBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9zaGFwZXMvc3RhbmRhcmQubWpzPzUzZjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL2RpYS9FbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBMaW5rIGFzIExpbmtCYXNlIH0gZnJvbSAnLi4vZGlhL0xpbmsubWpzJztcbmltcG9ydCB7IGlzUGVyY2VudGFnZSwgYXNzaWduIH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgYXR0cmlidXRlcyB9IGZyb20gJy4uL2RpYS9hdHRyaWJ1dGVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYvaW5kZXgubWpzJztcblxuXG4vLyBFTEVNRU5UU1xuXG5leHBvcnQgY29uc3QgUmVjdGFuZ2xlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLlJlY3RhbmdsZScsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICB3aWR0aDogJ2NhbGModyknLFxuICAgICAgICAgICAgaGVpZ2h0OiAnY2FsYyhoKScsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHk6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keScsXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgQ2lyY2xlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLkNpcmNsZScsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBjeDogJ2NhbGMocy8yKScsXG4gICAgICAgICAgICBjeTogJ2NhbGMocy8yKScsXG4gICAgICAgICAgICByOiAnY2FsYyhzLzIpJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgRWxsaXBzZSA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5FbGxpcHNlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGN4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIGN5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIHJ4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHJ5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdlbGxpcHNlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5J1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsJ1xuICAgIH1dXG59KTtcblxuZXhwb3J0IGNvbnN0IFBhdGggPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuUGF0aCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBkOiAnTSAwIDAgSCBjYWxjKHcpIFYgY2FsYyhoKSBIIDAgWicsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHk6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBQb2x5Z29uID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLlBvbHlnb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcG9pbnRzOiAnMCAwIGNhbGModykgMCBjYWxjKHcpIGNhbGMoaCkgMCBjYWxjKGgpJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdwb2x5Z29uJyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5J1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsJ1xuICAgIH1dXG59KTtcblxuZXhwb3J0IGNvbnN0IFBvbHlsaW5lID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLlBvbHlsaW5lJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHBvaW50czogJzAgMCBjYWxjKHcpIDAgY2FsYyh3KSBjYWxjKGgpIDAgY2FsYyhoKScsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHk6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncG9seWxpbmUnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuSW1hZ2UnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgpJyxcbiAgICAgICAgICAgIC8vIHhsaW5rSHJlZjogJ1tVUkxdJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAndG9wJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoKzEwKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdpbWFnZScsXG4gICAgICAgIHNlbGVjdG9yOiAnaW1hZ2UnXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgQm9yZGVyZWRJbWFnZSA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5Cb3JkZXJlZEltYWdlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKHcpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaCknLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICB3aWR0aDogJ2NhbGMody0xKScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgtMSknLFxuICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgeTogMC41LFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAvLyB4bGlua0hyZWY6ICdbVVJMXSdcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3LTEpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaC0xKScsXG4gICAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgICB5OiAwLjVcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ3RvcCcsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaCsxMCknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYmFja2dyb3VuZCcsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdzdHJva2UnOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ2ltYWdlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdpbWFnZSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdib3JkZXInLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgRW1iZWRkZWRJbWFnZSA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5FbWJlZGRlZEltYWdlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgpJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIC8vIHhsaW5rSHJlZjogJ1tVUkxdJ1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKDAuMyp3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgtMjApJyxcbiAgICAgICAgICAgIHg6IDEwLFxuICAgICAgICAgICAgeTogMTAsXG4gICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaW4nXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICd0b3AnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ2xlZnQnLFxuICAgICAgICAgICAgeDogJ2NhbGMoMC4zKncrMjApJywgLy8gMTAgKyAxMFxuICAgICAgICAgICAgeTogMTAsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5J1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ2ltYWdlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdpbWFnZSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBJbnNjcmliZWRJbWFnZSA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5JbnNjcmliZWRJbWFnZScsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib3JkZXI6IHtcbiAgICAgICAgICAgIHJ4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHJ5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIGN4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIGN5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgICAgcng6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgcnk6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgY3g6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgY3k6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAvLyBUaGUgaW1hZ2UgY29ybmVycyB0b3VjaCB0aGUgYm9yZGVyIHdoZW4gaXRzIHNpemUgaXMgTWF0aC5zcXJ0KDIpIC8gMiA9IDAuNzA3Li4gfj0gNzAlXG4gICAgICAgICAgICB3aWR0aDogJ2NhbGMoMC42OCp3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKDAuNjgqaCknLFxuICAgICAgICAgICAgLy8gVGhlIGltYWdlIG9mZnNldCBpcyBjYWxjdWxhdGVkIGFzICgxMDAlIC0gNjglKSAvIDJcbiAgICAgICAgICAgIHg6ICdjYWxjKDAuMTYqdyknLFxuICAgICAgICAgICAgeTogJ2NhbGMoMC4xNipoKScsXG4gICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQnXG4gICAgICAgICAgICAvLyB4bGlua0hyZWY6ICdbVVJMXSdcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ3RvcCcsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaCsxMCknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAnZWxsaXBzZScsXG4gICAgICAgIHNlbGVjdG9yOiAnYmFja2dyb3VuZCdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdpbWFnZScsXG4gICAgICAgIHNlbGVjdG9yOiAnaW1hZ2UnXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAnZWxsaXBzZScsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9yZGVyJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsJ1xuICAgIH1dXG59KTtcblxuZXhwb3J0IGNvbnN0IEhlYWRlcmVkUmVjdGFuZ2xlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLkhlYWRlcmVkUmVjdGFuZ2xlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgpJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgICB3aWR0aDogJ2NhbGModyknLFxuICAgICAgICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyVGV4dDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAxNSxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNixcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5VGV4dDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoLzIrMTUpJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgIHNlbGVjdG9yOiAnaGVhZGVyJ1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ2hlYWRlclRleHQnXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keVRleHQnXG4gICAgfV1cbn0pO1xuXG52YXIgQ1lMSU5ERVJfVElMVCA9IDEwO1xuXG5leHBvcnQgY29uc3QgQ3lsaW5kZXIgPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuQ3lsaW5kZXInLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgbGF0ZXJhbEFyZWE6IENZTElOREVSX1RJTFQsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIHRvcDoge1xuICAgICAgICAgICAgY3g6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgY3k6IENZTElOREVSX1RJTFQsXG4gICAgICAgICAgICByeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICByeTogQ1lMSU5ERVJfVElMVCxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaCsxNSknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdlbGxpcHNlJyxcbiAgICAgICAgc2VsZWN0b3I6ICd0b3AnXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV0sXG5cbiAgICB0b3BSeTogZnVuY3Rpb24odCwgb3B0KSB7XG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5hdHRyKCdib2R5L2xhdGVyYWxBcmVhJyk7XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHZhciBib2R5QXR0cnMgPSB7IGxhdGVyYWxBcmVhOiB0IH07XG5cbiAgICAgICAgdmFyIGlzUGVyY2VudGFnZVNldHRlciA9IGlzUGVyY2VudGFnZSh0KTtcbiAgICAgICAgdmFyIHR5ID0gKGlzUGVyY2VudGFnZVNldHRlcikgPyBgY2FsYygke3BhcnNlRmxvYXQodCkgLyAxMDB9KmgpYCA6IHQ7XG4gICAgICAgIHZhciB0b3BBdHRycyA9IHsgY3k6IHR5LCByeTogdHkgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKHsgYm9keTogYm9keUF0dHJzLCB0b3A6IHRvcEF0dHJzIH0sIG9wdCk7XG4gICAgfVxuXG59LCB7XG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAnbGF0ZXJhbC1hcmVhJzoge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih0LCByZWZCQm94KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzUGVyY2VudGFnZVNldHRlciA9IGlzUGVyY2VudGFnZSh0KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQZXJjZW50YWdlU2V0dGVyKSB0ID0gcGFyc2VGbG9hdCh0KSAvIDEwMDtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gcmVmQkJveC54O1xuICAgICAgICAgICAgICAgIHZhciB5ID0gcmVmQkJveC55O1xuICAgICAgICAgICAgICAgIHZhciB3ID0gcmVmQkJveC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHJlZkJCb3guaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gY3VydmUgY29udHJvbCBwb2ludCB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICB2YXIgcnggPSB3IC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgcnkgPSBpc1BlcmNlbnRhZ2VTZXR0ZXIgPyAoaCAqIHQpIDogdDtcblxuICAgICAgICAgICAgICAgIHZhciBrYXBwYSA9IFYuS0FQUEE7XG4gICAgICAgICAgICAgICAgdmFyIGN4ID0ga2FwcGEgKiByeDtcbiAgICAgICAgICAgICAgICB2YXIgY3kgPSBrYXBwYSAqIChpc1BlcmNlbnRhZ2VTZXR0ZXIgPyAoaCAqIHQpIDogdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzaGFwZSB2YXJpYWJsZXNcbiAgICAgICAgICAgICAgICB2YXIgeExlZnQgPSB4O1xuICAgICAgICAgICAgICAgIHZhciB4Q2VudGVyID0geCArICh3IC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIHhSaWdodCA9IHggKyB3O1xuXG4gICAgICAgICAgICAgICAgdmFyIHlTaWRlVG9wID0geSArIHJ5O1xuICAgICAgICAgICAgICAgIHZhciB5Q3VydmVUb3AgPSB5U2lkZVRvcCAtIHJ5O1xuICAgICAgICAgICAgICAgIHZhciB5U2lkZUJvdHRvbSA9IHkgKyBoIC0gcnk7XG4gICAgICAgICAgICAgICAgdmFyIHlDdXJ2ZUJvdHRvbSA9IHkgKyBoO1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGNhbGN1bGF0ZWQgc2hhcGVcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ00nLCB4TGVmdCwgeVNpZGVUb3AsXG4gICAgICAgICAgICAgICAgICAgICdMJywgeExlZnQsIHlTaWRlQm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAnQycsIHgsICh5U2lkZUJvdHRvbSArIGN5KSwgKHhDZW50ZXIgLSBjeCksIHlDdXJ2ZUJvdHRvbSwgeENlbnRlciwgeUN1cnZlQm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAnQycsICh4Q2VudGVyICsgY3gpLCB5Q3VydmVCb3R0b20sIHhSaWdodCwgKHlTaWRlQm90dG9tICsgY3kpLCB4UmlnaHQsIHlTaWRlQm90dG9tLFxuICAgICAgICAgICAgICAgICAgICAnTCcsIHhSaWdodCwgeVNpZGVUb3AsXG4gICAgICAgICAgICAgICAgICAgICdDJywgeFJpZ2h0LCAoeVNpZGVUb3AgLSBjeSksICh4Q2VudGVyICsgY3gpLCB5Q3VydmVUb3AsIHhDZW50ZXIsIHlDdXJ2ZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgJ0MnLCAoeENlbnRlciAtIGN4KSwgeUN1cnZlVG9wLCB4TGVmdCwgKHlTaWRlVG9wIC0gY3kpLCB4TGVmdCwgeVNpZGVUb3AsXG4gICAgICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZDogZGF0YS5qb2luKCcgJykgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldDogJ2QnXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIGZvTGFiZWxNYXJrdXAgPSB7XG4gICAgdGFnTmFtZTogJ2ZvcmVpZ25PYmplY3QnLFxuICAgIHNlbGVjdG9yOiAnZm9yZWlnbk9iamVjdCcsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJ1xuICAgIH0sXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgICAgICBuYW1lc3BhY2VVUkk6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCcsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXRpYycsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogJzBweCA1cHgnLFxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICAgICAgICB9XG4gICAgfV1cbn07XG5cbnZhciBzdmdMYWJlbE1hcmt1cCA9IHtcbiAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgc2VsZWN0b3I6ICdsYWJlbCcsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJ1xuICAgIH1cbn07XG5cbnZhciBsYWJlbE1hcmt1cCA9IChlbnYudGVzdCgnc3ZnZm9yZWlnbm9iamVjdCcpKSA/IGZvTGFiZWxNYXJrdXAgOiBzdmdMYWJlbE1hcmt1cDtcblxuZXhwb3J0IGNvbnN0IFRleHRCbG9jayA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5UZXh0QmxvY2snLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKHcpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaCknLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBmb3JlaWduT2JqZWN0OiB7XG4gICAgICAgICAgICB3aWR0aDogJ2NhbGModyknLFxuICAgICAgICAgICAgaGVpZ2h0OiAnY2FsYyhoKScsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxNFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwgbGFiZWxNYXJrdXBdXG59LCB7XG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHRleHQsIHJlZkJCb3gsIG5vZGUsIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBmb3JlaWduIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBhdHRyc1snc3R5bGUnXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBWYWx1ZSA9IHsgdGV4dCwgd2lkdGg6IC01LCBoZWlnaHQ6ICcxMDAlJyB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcEF0dHJzID0gYXNzaWduKHsgJ3RleHQtdmVydGljYWwtYW5jaG9yJzogJ21pZGRsZScgfSwgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzWyd0ZXh0LXdyYXAnXS5zZXQuY2FsbCh0aGlzLCB3cmFwVmFsdWUsIHJlZkJCb3gsIG5vZGUsIHdyYXBBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZpbGw6IHN0eWxlLmNvbG9yIHx8IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmlsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbih0ZXh0LCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gZm9yZWlnbiBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHJldHVybiByZWZCQm94LmNlbnRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8vIExJTktTXG5cbmV4cG9ydCBjb25zdCBMaW5rID0gTGlua0Jhc2UuZGVmaW5lKCdzdGFuZGFyZC5MaW5rJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICB0YXJnZXRNYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICAnZCc6ICdNIDEwIC01IDAgMCAxMCA1IHonXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdyYXBwZXI6IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMTAsXG4gICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ3dyYXBwZXInLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdjdXJzb3InOiAncG9pbnRlcicsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICdzdHJva2UtbGluZWNhcCc6ICdyb3VuZCdcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ2xpbmUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgRG91YmxlTGluayA9IExpbmtCYXNlLmRlZmluZSgnc3RhbmRhcmQuRG91YmxlTGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgc3Ryb2tlOiAnI0RERERERCcsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogNCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxuICAgICAgICAgICAgdGFyZ2V0TWFya2VyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIGQ6ICdNIDEwIC0zIDEwIC0xMCAtMiAwIDEwIDEwIDEwIDMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG91dGxpbmU6IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiA2LFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCdcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdvdXRsaW5lJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdsaW5lJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH1dXG59KTtcblxuZXhwb3J0IGNvbnN0IFNoYWRvd0xpbmsgPSBMaW5rQmFzZS5kZWZpbmUoJ3N0YW5kYXJkLlNoYWRvd0xpbmsnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN0cm9rZTogJyNGRjAwMDAnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIwLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICB0YXJnZXRNYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICdkJzogJ00gMCAtMTAgLTEwIDAgMCAxMCB6J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZU1hcmtlcjoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJ2QnOiAnTSAtMTAgLTEwIDAgMCAtMTAgMTAgMCAxMCAwIC0xMCB6J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFkb3c6IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMyw2KScsXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuMixcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyMCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxuICAgICAgICAgICAgdGFyZ2V0TWFya2VyOiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgJ2QnOiAnTSAwIC0xMCAtMTAgMCAwIDEwIHonLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2VNYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICdkJzogJ00gLTEwIC0xMCAwIDAgLTEwIDEwIDAgMTAgMCAtMTAgeidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdzaGFkb3cnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGluZScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJ1xuICAgICAgICB9XG4gICAgfV1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/shapes/standard.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/calc.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/util/calc.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalCalcExpression: () => (/* binding */ evalCalcExpression),\n/* harmony export */   evalCalcFormula: () => (/* binding */ evalCalcFormula),\n/* harmony export */   isCalcExpression: () => (/* binding */ isCalcExpression)\n/* harmony export */ });\nconst props = {\n    x: 'x',\n    y: 'y',\n    width: 'w',\n    height: 'h',\n    minimum: 's',\n    maximum: 'l',\n    diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseFormulaRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\n\nfunction throwInvalid(expression) {\n    throw new Error(`Invalid calc() expression: ${expression}`);\n}\n\n/*\n* Evaluate the given calc formula.\n* e.g. 'w + 10' in a rect 100x100 -> 110\n*/\nfunction evalCalcFormula(formula, rect) {\n    const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ''));\n    if (!match) throwInvalid(formula);\n    parseFormulaRegExp.lastIndex = 0; // reset regex results for the next run\n    const [,multiply, property, divide, add] = match;\n    const { x, y, width, height } = rect;\n    let value = 0;\n    switch (property) {\n        case props.width: {\n            value = width;\n            break;\n        }\n        case props.height: {\n            value = height;\n            break;\n        }\n        case props.x: {\n            value = x;\n            break;\n        }\n        case props.y: {\n            value = y;\n            break;\n        }\n        case props.minimum: {\n            value = Math.min(height, width);\n            break;\n        }\n        case props.maximum: {\n            value = Math.max(height, width);\n            break;\n        }\n        case props.diagonal: {\n            value = Math.sqrt((height * height) + (width * width));\n            break;\n        }\n    }\n    if (multiply) {\n        // e.g \"2*\"\n        value *= parseFloat(multiply);\n    }\n    if (divide) {\n        // e.g \"/2\"\n        value /= parseFloat(divide.slice(1));\n    }\n    if (add) {\n        value += evalAddExpression(add);\n    }\n    return value;\n}\n\nfunction evalAddExpression(addExpression) {\n    if (!addExpression) return 0;\n    const [sign] = addExpression;\n    switch (sign) {\n        case '+': {\n            return parseFloat(addExpression.substr(1));\n        }\n        case '-': {\n            return -parseFloat(addExpression.substr(1));\n        }\n    }\n    return parseFloat(addExpression);\n}\n\n/*\n* Check if the given value is a calc expression.\n* e.g. 'calc(10 + 100)' -> true\n*/\nfunction isCalcExpression(value) {\n    return typeof value === 'string' && value.includes('calc');\n}\n\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\n\n/*\n* Evaluate all calc formulas in the given expression.\n* e.g. 'calc(w + 10)' in rect 100x100 -> '110'\n*/\nfunction evalCalcExpression(expression, rect) {\n    let value = expression;\n    let startSearchIndex = 0;\n    do {\n        let calcIndex = value.indexOf(calcStart, startSearchIndex);\n        if (calcIndex === -1) return value;\n        let calcEndIndex = calcIndex + calcStartOffset;\n        let brackets = 1;\n        findClosingBracket: do {\n            switch (value[calcEndIndex]) {\n                case '(': {\n                    brackets++;\n                    break;\n                }\n                case ')': {\n                    brackets--;\n                    if (brackets === 0) break findClosingBracket;\n                    break;\n                }\n                case undefined: {\n                    // Could not find the closing bracket.\n                    throwInvalid(value);\n                }\n            }\n            calcEndIndex++;\n        } while (true);\n        // Get the calc() expression without nested calcs (recursion)\n        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n        if (isCalcExpression(expression)) {\n            expression = evalCalcExpression(expression, rect);\n        }\n        // Eval the calc() expression without nested calcs.\n        const calcValue = String(evalCalcFormula(expression, rect));\n        // Replace the calc() expression and continue search\n        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n        startSearchIndex = calcIndex + calcValue.length;\n    } while (true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvY2FsYy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWMsU0FBUyxVQUFVLE1BQU0sY0FBYyxRQUFRLElBQUksRUFBRSxjQUFjOztBQUU1SDtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL2NhbGMubWpzP2VhZTkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcHJvcHMgPSB7XG4gICAgeDogJ3gnLFxuICAgIHk6ICd5JyxcbiAgICB3aWR0aDogJ3cnLFxuICAgIGhlaWdodDogJ2gnLFxuICAgIG1pbmltdW06ICdzJyxcbiAgICBtYXhpbXVtOiAnbCcsXG4gICAgZGlhZ29uYWw6ICdkJ1xufTtcbmNvbnN0IHByb3BzTGlzdCA9IE9iamVjdC5rZXlzKHByb3BzKS5tYXAoa2V5ID0+IHByb3BzW2tleV0pLmpvaW4oJycpO1xuY29uc3QgbnVtYmVyUGF0dGVybiA9ICdbLStdP1swLTldKlxcXFwuP1swLTldKyg/OltlRV1bLStdP1swLTldKyk/JztcbmNvbnN0IGZpbmRTcGFjZXNSZWdleCA9IC9cXHMvZztcbmNvbnN0IHBhcnNlRm9ybXVsYVJlZ0V4cCA9IG5ldyBSZWdFeHAoYF4oJHtudW1iZXJQYXR0ZXJufVxcXFwqKT8oWyR7cHJvcHNMaXN0fV0pKC8ke251bWJlclBhdHRlcm59KT8oWy0rXXsxLDJ9JHtudW1iZXJQYXR0ZXJufSk/JGAsICdnJyk7XG5cbmZ1bmN0aW9uIHRocm93SW52YWxpZChleHByZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNhbGMoKSBleHByZXNzaW9uOiAke2V4cHJlc3Npb259YCk7XG59XG5cbi8qXG4qIEV2YWx1YXRlIHRoZSBnaXZlbiBjYWxjIGZvcm11bGEuXG4qIGUuZy4gJ3cgKyAxMCcgaW4gYSByZWN0IDEwMHgxMDAgLT4gMTEwXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGV2YWxDYWxjRm9ybXVsYShmb3JtdWxhLCByZWN0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBwYXJzZUZvcm11bGFSZWdFeHAuZXhlYyhmb3JtdWxhLnJlcGxhY2UoZmluZFNwYWNlc1JlZ2V4LCAnJykpO1xuICAgIGlmICghbWF0Y2gpIHRocm93SW52YWxpZChmb3JtdWxhKTtcbiAgICBwYXJzZUZvcm11bGFSZWdFeHAubGFzdEluZGV4ID0gMDsgLy8gcmVzZXQgcmVnZXggcmVzdWx0cyBmb3IgdGhlIG5leHQgcnVuXG4gICAgY29uc3QgWyxtdWx0aXBseSwgcHJvcGVydHksIGRpdmlkZSwgYWRkXSA9IG1hdGNoO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgY2FzZSBwcm9wcy53aWR0aDoge1xuICAgICAgICAgICAgdmFsdWUgPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMuaGVpZ2h0OiB7XG4gICAgICAgICAgICB2YWx1ZSA9IGhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMueDoge1xuICAgICAgICAgICAgdmFsdWUgPSB4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBwcm9wcy55OiB7XG4gICAgICAgICAgICB2YWx1ZSA9IHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHByb3BzLm1pbmltdW06IHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4oaGVpZ2h0LCB3aWR0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHByb3BzLm1heGltdW06IHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5tYXgoaGVpZ2h0LCB3aWR0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHByb3BzLmRpYWdvbmFsOiB7XG4gICAgICAgICAgICB2YWx1ZSA9IE1hdGguc3FydCgoaGVpZ2h0ICogaGVpZ2h0KSArICh3aWR0aCAqIHdpZHRoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobXVsdGlwbHkpIHtcbiAgICAgICAgLy8gZS5nIFwiMipcIlxuICAgICAgICB2YWx1ZSAqPSBwYXJzZUZsb2F0KG11bHRpcGx5KTtcbiAgICB9XG4gICAgaWYgKGRpdmlkZSkge1xuICAgICAgICAvLyBlLmcgXCIvMlwiXG4gICAgICAgIHZhbHVlIC89IHBhcnNlRmxvYXQoZGl2aWRlLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgaWYgKGFkZCkge1xuICAgICAgICB2YWx1ZSArPSBldmFsQWRkRXhwcmVzc2lvbihhZGQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGV2YWxBZGRFeHByZXNzaW9uKGFkZEV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWFkZEV4cHJlc3Npb24pIHJldHVybiAwO1xuICAgIGNvbnN0IFtzaWduXSA9IGFkZEV4cHJlc3Npb247XG4gICAgc3dpdGNoIChzaWduKSB7XG4gICAgICAgIGNhc2UgJysnOiB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChhZGRFeHByZXNzaW9uLnN1YnN0cigxKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnLSc6IHtcbiAgICAgICAgICAgIHJldHVybiAtcGFyc2VGbG9hdChhZGRFeHByZXNzaW9uLnN1YnN0cigxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoYWRkRXhwcmVzc2lvbik7XG59XG5cbi8qXG4qIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGNhbGMgZXhwcmVzc2lvbi5cbiogZS5nLiAnY2FsYygxMCArIDEwMCknIC0+IHRydWVcbiovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxjRXhwcmVzc2lvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmluY2x1ZGVzKCdjYWxjJyk7XG59XG5cbmNvbnN0IGNhbGNTdGFydCA9ICdjYWxjKCc7XG5jb25zdCBjYWxjU3RhcnRPZmZzZXQgPSBjYWxjU3RhcnQubGVuZ3RoO1xuXG4vKlxuKiBFdmFsdWF0ZSBhbGwgY2FsYyBmb3JtdWxhcyBpbiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbi5cbiogZS5nLiAnY2FsYyh3ICsgMTApJyBpbiByZWN0IDEwMHgxMDAgLT4gJzExMCdcbiovXG5leHBvcnQgZnVuY3Rpb24gZXZhbENhbGNFeHByZXNzaW9uKGV4cHJlc3Npb24sIHJlY3QpIHtcbiAgICBsZXQgdmFsdWUgPSBleHByZXNzaW9uO1xuICAgIGxldCBzdGFydFNlYXJjaEluZGV4ID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGxldCBjYWxjSW5kZXggPSB2YWx1ZS5pbmRleE9mKGNhbGNTdGFydCwgc3RhcnRTZWFyY2hJbmRleCk7XG4gICAgICAgIGlmIChjYWxjSW5kZXggPT09IC0xKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGxldCBjYWxjRW5kSW5kZXggPSBjYWxjSW5kZXggKyBjYWxjU3RhcnRPZmZzZXQ7XG4gICAgICAgIGxldCBicmFja2V0cyA9IDE7XG4gICAgICAgIGZpbmRDbG9zaW5nQnJhY2tldDogZG8ge1xuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZVtjYWxjRW5kSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldHMrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJyknOiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNrZXRzLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFja2V0cyA9PT0gMCkgYnJlYWsgZmluZENsb3NpbmdCcmFja2V0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgbm90IGZpbmQgdGhlIGNsb3NpbmcgYnJhY2tldC5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJbnZhbGlkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxjRW5kSW5kZXgrKztcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIC8vIEdldCB0aGUgY2FsYygpIGV4cHJlc3Npb24gd2l0aG91dCBuZXN0ZWQgY2FsY3MgKHJlY3Vyc2lvbilcbiAgICAgICAgbGV0IGV4cHJlc3Npb24gPSB2YWx1ZS5zbGljZShjYWxjSW5kZXggKyBjYWxjU3RhcnRPZmZzZXQsIGNhbGNFbmRJbmRleCk7XG4gICAgICAgIGlmIChpc0NhbGNFeHByZXNzaW9uKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gZXZhbENhbGNFeHByZXNzaW9uKGV4cHJlc3Npb24sIHJlY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2YWwgdGhlIGNhbGMoKSBleHByZXNzaW9uIHdpdGhvdXQgbmVzdGVkIGNhbGNzLlxuICAgICAgICBjb25zdCBjYWxjVmFsdWUgPSBTdHJpbmcoZXZhbENhbGNGb3JtdWxhKGV4cHJlc3Npb24sIHJlY3QpKTtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgY2FsYygpIGV4cHJlc3Npb24gYW5kIGNvbnRpbnVlIHNlYXJjaFxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGNhbGNJbmRleCkgKyBjYWxjVmFsdWUgKyB2YWx1ZS5zbGljZShjYWxjRW5kSW5kZXggKyAxKTtcbiAgICAgICAgc3RhcnRTZWFyY2hJbmRleCA9IGNhbGNJbmRleCArIGNhbGNWYWx1ZS5sZW5ndGg7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/calc.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/cloneCells.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/util/cloneCells.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneCells: () => (/* binding */ cloneCells)\n/* harmony export */ });\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nfunction cloneCells(cells) {\n\n    cells = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(cells);\n\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n\n    (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cells).forEach(function(cell) {\n\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop('source/id', cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop('target/id', cloneMap[target.id].id);\n            }\n        }\n\n        // Find the parent of the original cell\n        const parent = cell.get('parent');\n        if (parent && cloneMap[parent]) {\n            clone.set('parent', cloneMap[parent].id);\n        }\n\n        // Find the embeds of the original cell\n        const embeds = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n\n        if (!(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(embeds)) {\n            clone.set('embeds', embeds);\n        }\n    });\n\n    return cloneMap;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvY2xvbmVDZWxscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQLFlBQVksK0NBQUk7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrREFBTztBQUM1QjtBQUNBO0FBQ0EsS0FBSyxJQUFJOztBQUVULElBQUksa0RBQU87O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsa0RBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxhQUFhLGtEQUFPO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL2Nsb25lQ2VsbHMubWpzPzdkMzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdW5pcSwgdG9BcnJheSwgaXNFbXB0eSB9IGZyb20gJy4vdXRpbC5tanMnO1xuXG4vLyBDbG9uZSBgY2VsbHNgIHJldHVybmluZyBhbiBvYmplY3QgdGhhdCBtYXBzIHRoZSBvcmlnaW5hbCBjZWxsIElEIHRvIHRoZSBjbG9uZS4gVGhlIG51bWJlclxuLy8gb2YgY2xvbmVzIGlzIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIGBjZWxscy5sZW5ndGhgLlxuLy8gVGhpcyBmdW5jdGlvbiBzaW1wbHkgY2xvbmVzIGFsbCB0aGUgYGNlbGxzYC4gSG93ZXZlciwgaXQgYWxzbyByZWNvbnN0cnVjdHNcbi8vIGFsbCB0aGUgYHNvdXJjZS90YXJnZXRgIGFuZCBgcGFyZW50L2VtYmVkYCByZWZlcmVuY2VzIHdpdGhpbiB0aGUgYGNlbGxzYC5cbi8vIFRoaXMgaXMgdGhlIG1haW4gZGlmZmVyZW5jZSBmcm9tIHRoZSBgY2VsbC5jbG9uZSgpYCBtZXRob2QuIFRoZVxuLy8gYGNlbGwuY2xvbmUoKWAgbWV0aG9kIHdvcmtzIG9uIG9uZSBzaW5nbGUgY2VsbCBvbmx5LlxuLy8gRm9yIGV4YW1wbGUsIGZvciBhIGdyYXBoOiBgQSAtLS0gTCAtLS0+IEJgLCBgY2xvbmVDZWxscyhbQSwgTCwgQl0pYFxuLy8gcmV0dXJucyBgW0EyLCBMMiwgQjJdYCByZXN1bHRpbmcgdG8gYSBncmFwaDogYEEyIC0tLSBMMiAtLS0+IEIyYCwgaS5lLlxuLy8gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG9mIHRoZSBsaW5rIGBMMmAgaXMgY2hhbmdlZCB0byBwb2ludCB0byBgQTJgIGFuZCBgQjJgLlxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQ2VsbHMoY2VsbHMpIHtcblxuICAgIGNlbGxzID0gdW5pcShjZWxscyk7XG5cbiAgICAvLyBBIG1hcCBvZiB0aGUgZm9ybSBbb3JpZ2luYWwgY2VsbCBJRF0gLT4gW2Nsb25lXSBoZWxwaW5nXG4gICAgLy8gdXMgdG8gcmVjb25zdHJ1Y3QgcmVmZXJlbmNlcyBmb3Igc291cmNlL3RhcmdldCBhbmQgcGFyZW50L2VtYmVkcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gdGhlIHJldHVybmVkIHZhbHVlLlxuICAgIGNvbnN0IGNsb25lTWFwID0gdG9BcnJheShjZWxscykucmVkdWNlKGZ1bmN0aW9uKG1hcCwgY2VsbCkge1xuICAgICAgICBtYXBbY2VsbC5pZF0gPSBjZWxsLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuXG4gICAgdG9BcnJheShjZWxscykuZm9yRWFjaChmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgY29uc3QgY2xvbmUgPSBjbG9uZU1hcFtjZWxsLmlkXTtcbiAgICAgICAgLy8gYXNzZXJ0KGNsb25lIGV4aXN0cylcblxuICAgICAgICBpZiAoY2xvbmUuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGNsb25lLnNvdXJjZSgpO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gY2xvbmUudGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAoc291cmNlLmlkICYmIGNsb25lTWFwW3NvdXJjZS5pZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBTb3VyY2UgcG9pbnRzIHRvIGFuIGVsZW1lbnQgYW5kIHRoZSBlbGVtZW50IGlzIGFtb25nIHRoZSBjbG9uZXMuXG4gICAgICAgICAgICAgICAgLy8gPT4gVXBkYXRlIHRoZSBzb3VyY2Ugb2YgdGhlIGNsb25lZCBsaW5rLlxuICAgICAgICAgICAgICAgIGNsb25lLnByb3AoJ3NvdXJjZS9pZCcsIGNsb25lTWFwW3NvdXJjZS5pZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5pZCAmJiBjbG9uZU1hcFt0YXJnZXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgLy8gVGFyZ2V0IHBvaW50cyB0byBhbiBlbGVtZW50IGFuZCB0aGUgZWxlbWVudCBpcyBhbW9uZyB0aGUgY2xvbmVzLlxuICAgICAgICAgICAgICAgIC8vID0+IFVwZGF0ZSB0aGUgdGFyZ2V0IG9mIHRoZSBjbG9uZWQgbGluay5cbiAgICAgICAgICAgICAgICBjbG9uZS5wcm9wKCd0YXJnZXQvaWQnLCBjbG9uZU1hcFt0YXJnZXQuaWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgY2VsbFxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjZWxsLmdldCgncGFyZW50Jyk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgY2xvbmVNYXBbcGFyZW50XSkge1xuICAgICAgICAgICAgY2xvbmUuc2V0KCdwYXJlbnQnLCBjbG9uZU1hcFtwYXJlbnRdLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGVtYmVkcyBvZiB0aGUgb3JpZ2luYWwgY2VsbFxuICAgICAgICBjb25zdCBlbWJlZHMgPSB0b0FycmF5KGNlbGwuZ2V0KCdlbWJlZHMnKSkucmVkdWNlKGZ1bmN0aW9uKG5ld0VtYmVkcywgZW1iZWQpIHtcbiAgICAgICAgICAgIC8vIEVtYmVkZGVkIGNlbGxzIHRoYXQgYXJlIG5vdCBiZWluZyBjbG9uZWQgY2FuIG5vdCBiZSBjYXJyaWVkXG4gICAgICAgICAgICAvLyBvdmVyIHdpdGggb3RoZXIgZW1iZWRkZWQgY2VsbHMuXG4gICAgICAgICAgICBpZiAoY2xvbmVNYXBbZW1iZWRdKSB7XG4gICAgICAgICAgICAgICAgbmV3RW1iZWRzLnB1c2goY2xvbmVNYXBbZW1iZWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdFbWJlZHM7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAoIWlzRW1wdHkoZW1iZWRzKSkge1xuICAgICAgICAgICAgY2xvbmUuc2V0KCdlbWJlZHMnLCBlbWJlZHMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2xvbmVNYXA7XG59XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/cloneCells.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/getRectPoint.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/util/getRectPoint.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Positions: () => (/* binding */ Positions),\n/* harmony export */   getRectPoint: () => (/* binding */ getRectPoint)\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/g/rect.mjs\");\n\n\nconst Positions = {\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right',\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    CENTER: 'center',\n};\n\nfunction getRectPoint(rect, position) {\n    const r = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(rect);\n    switch (position) {\n        case undefined:\n            throw new Error('Position required');\n\n        // Middle Points\n        case Positions.LEFT:\n        case 'leftMiddle':\n            return r.leftMiddle();\n\n        case Positions.RIGHT:\n        case 'rightMiddle':\n            return r.rightMiddle();\n\n        case Positions.TOP:\n        case 'topMiddle':\n            return r.topMiddle();\n\n        case Positions.BOTTOM:\n        case 'bottomMiddle':\n            return r.bottomMiddle();\n\n        // Corners\n        case Positions.TOP_LEFT:\n        case 'topLeft':\n        case 'origin':\n            return r.topLeft();\n\n        case Positions.TOP_RIGHT:\n        case 'topRight':\n            return r.topRight();\n\n        case Positions.BOTTOM_LEFT:\n        case 'bottomLeft':\n            return r.bottomLeft();\n\n        case Positions.BOTTOM_RIGHT:\n        case 'bottomRight':\n        case 'corner':\n            return r.bottomRight();\n\n        // Center\n        case Positions.CENTER:\n            return r.center();\n\n        // TODO: calc(), percentage etc.\n        default:\n            throw new Error(`Unknown position: ${position}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvZ2V0UmVjdFBvaW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7O0FBRTdCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxrQkFBa0IsOENBQU07QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL2dldFJlY3RQb2ludC5tanM/YzJlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IFBvc2l0aW9ucyA9IHtcbiAgICBUT1A6ICd0b3AnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIEJPVFRPTTogJ2JvdHRvbScsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFRPUF9MRUZUOiAndG9wLWxlZnQnLFxuICAgIFRPUF9SSUdIVDogJ3RvcC1yaWdodCcsXG4gICAgQk9UVE9NX0xFRlQ6ICdib3R0b20tbGVmdCcsXG4gICAgQk9UVE9NX1JJR0hUOiAnYm90dG9tLXJpZ2h0JyxcbiAgICBDRU5URVI6ICdjZW50ZXInLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY3RQb2ludChyZWN0LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHIgPSBuZXcgZy5SZWN0KHJlY3QpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIHJlcXVpcmVkJyk7XG5cbiAgICAgICAgLy8gTWlkZGxlIFBvaW50c1xuICAgICAgICBjYXNlIFBvc2l0aW9ucy5MRUZUOlxuICAgICAgICBjYXNlICdsZWZ0TWlkZGxlJzpcbiAgICAgICAgICAgIHJldHVybiByLmxlZnRNaWRkbGUoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5SSUdIVDpcbiAgICAgICAgY2FzZSAncmlnaHRNaWRkbGUnOlxuICAgICAgICAgICAgcmV0dXJuIHIucmlnaHRNaWRkbGUoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5UT1A6XG4gICAgICAgIGNhc2UgJ3RvcE1pZGRsZSc6XG4gICAgICAgICAgICByZXR1cm4gci50b3BNaWRkbGUoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT006XG4gICAgICAgIGNhc2UgJ2JvdHRvbU1pZGRsZSc6XG4gICAgICAgICAgICByZXR1cm4gci5ib3R0b21NaWRkbGUoKTtcblxuICAgICAgICAvLyBDb3JuZXJzXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLlRPUF9MRUZUOlxuICAgICAgICBjYXNlICd0b3BMZWZ0JzpcbiAgICAgICAgY2FzZSAnb3JpZ2luJzpcbiAgICAgICAgICAgIHJldHVybiByLnRvcExlZnQoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5UT1BfUklHSFQ6XG4gICAgICAgIGNhc2UgJ3RvcFJpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiByLnRvcFJpZ2h0KCk7XG5cbiAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NX0xFRlQ6XG4gICAgICAgIGNhc2UgJ2JvdHRvbUxlZnQnOlxuICAgICAgICAgICAgcmV0dXJuIHIuYm90dG9tTGVmdCgpO1xuXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgY2FzZSAnYm90dG9tUmlnaHQnOlxuICAgICAgICBjYXNlICdjb3JuZXInOlxuICAgICAgICAgICAgcmV0dXJuIHIuYm90dG9tUmlnaHQoKTtcblxuICAgICAgICAvLyBDZW50ZXJcbiAgICAgICAgY2FzZSBQb3NpdGlvbnMuQ0VOVEVSOlxuICAgICAgICAgICAgcmV0dXJuIHIuY2VudGVyKCk7XG5cbiAgICAgICAgLy8gVE9ETzogY2FsYygpLCBwZXJjZW50YWdlIGV0Yy5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwb3NpdGlvbjogJHtwb3NpdGlvbn1gKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/getRectPoint.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@joint/core/src/util/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClassNamePrefix: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix),\n/* harmony export */   assign: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign),\n/* harmony export */   bindAll: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.bindAll),\n/* harmony export */   breakText: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.breakText),\n/* harmony export */   camelCase: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.camelCase),\n/* harmony export */   cancelFrame: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.cancelFrame),\n/* harmony export */   cap: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.cap),\n/* harmony export */   clone: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.clone),\n/* harmony export */   cloneCells: () => (/* reexport safe */ _cloneCells_mjs__WEBPACK_IMPORTED_MODULE_2__.cloneCells),\n/* harmony export */   cloneDeep: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.cloneDeep),\n/* harmony export */   dataUriToBlob: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dataUriToBlob),\n/* harmony export */   debounce: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.debounce),\n/* harmony export */   deepMixin: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.deepMixin),\n/* harmony export */   deepSupplement: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.deepSupplement),\n/* harmony export */   defaults: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaults),\n/* harmony export */   defaultsDeep: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultsDeep),\n/* harmony export */   difference: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.difference),\n/* harmony export */   downloadBlob: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.downloadBlob),\n/* harmony export */   downloadDataUri: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.downloadDataUri),\n/* harmony export */   evalCalcExpression: () => (/* reexport safe */ _calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression),\n/* harmony export */   evalCalcFormula: () => (/* reexport safe */ _calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcFormula),\n/* harmony export */   filter: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.filter),\n/* harmony export */   flattenDeep: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenDeep),\n/* harmony export */   flattenObject: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenObject),\n/* harmony export */   forIn: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn),\n/* harmony export */   format: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.format),\n/* harmony export */   getByPath: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.getByPath),\n/* harmony export */   getElementBBox: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.getElementBBox),\n/* harmony export */   getRectPoint: () => (/* reexport safe */ _getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_5__.getRectPoint),\n/* harmony export */   groupBy: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.groupBy),\n/* harmony export */   guid: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.guid),\n/* harmony export */   has: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.has),\n/* harmony export */   hashCode: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.hashCode),\n/* harmony export */   imageToDataUri: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.imageToDataUri),\n/* harmony export */   interpolate: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.interpolate),\n/* harmony export */   intersection: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.intersection),\n/* harmony export */   invoke: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke),\n/* harmony export */   invokeProperty: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.invokeProperty),\n/* harmony export */   isBoolean: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isBoolean),\n/* harmony export */   isCalcExpression: () => (/* reexport safe */ _calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression),\n/* harmony export */   isEmpty: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty),\n/* harmony export */   isEqual: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual),\n/* harmony export */   isFunction: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumber: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber),\n/* harmony export */   isObject: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject),\n/* harmony export */   isPercentage: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject),\n/* harmony export */   isString: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isString),\n/* harmony export */   merge: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.merge),\n/* harmony export */   mixin: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.mixin),\n/* harmony export */   nextFrame: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.nextFrame),\n/* harmony export */   noop: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   normalizeEvent: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent),\n/* harmony export */   normalizeSides: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeSides),\n/* harmony export */   normalizeWheel: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeWheel),\n/* harmony export */   objectDifference: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.objectDifference),\n/* harmony export */   omit: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.omit),\n/* harmony export */   parseCssNumeric: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.parseCssNumeric),\n/* harmony export */   parseDOMJSON: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.parseDOMJSON),\n/* harmony export */   pick: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.pick),\n/* harmony export */   removeClassNamePrefix: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.removeClassNamePrefix),\n/* harmony export */   result: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.result),\n/* harmony export */   sanitizeHTML: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sanitizeHTML),\n/* harmony export */   setAttributesBySelector: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.setAttributesBySelector),\n/* harmony export */   setByPath: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.setByPath),\n/* harmony export */   sortBy: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortBy),\n/* harmony export */   sortElements: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortElements),\n/* harmony export */   sortedIndex: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortedIndex),\n/* harmony export */   supplement: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.supplement),\n/* harmony export */   svg: () => (/* reexport safe */ _svgTagTemplate_mjs__WEBPACK_IMPORTED_MODULE_3__.svg),\n/* harmony export */   template: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.template),\n/* harmony export */   timing: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.timing),\n/* harmony export */   toArray: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray),\n/* harmony export */   toKebabCase: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.toKebabCase),\n/* harmony export */   toggleFullScreen: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.toggleFullScreen),\n/* harmony export */   union: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.union),\n/* harmony export */   uniq: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq),\n/* harmony export */   uniqueId: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.uniqueId),\n/* harmony export */   unsetByPath: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.unsetByPath),\n/* harmony export */   uuid: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.uuid),\n/* harmony export */   without: () => (/* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.without),\n/* harmony export */   wrapWith: () => (/* reexport safe */ _wrappers_mjs__WEBPACK_IMPORTED_MODULE_0__.wrapWith),\n/* harmony export */   wrappers: () => (/* reexport safe */ _wrappers_mjs__WEBPACK_IMPORTED_MODULE_0__.wrappers)\n/* harmony export */ });\n/* harmony import */ var _wrappers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrappers.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/wrappers.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _cloneCells_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cloneCells.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/cloneCells.mjs\");\n/* harmony import */ var _svgTagTemplate_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./svgTagTemplate.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/svgTagTemplate.mjs\");\n/* harmony import */ var _calc_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calc.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getRectPoint.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/getRectPoint.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0o7QUFDTTtBQUNJO0FBQ1Y7QUFDdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL2luZGV4Lm1qcz8xYTRmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vd3JhcHBlcnMubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jbG9uZUNlbGxzLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL3N2Z1RhZ1RlbXBsYXRlLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NhbGMubWpzJztcbmV4cG9ydCB7IGdldFJlY3RQb2ludCB9IGZyb20gJy4vZ2V0UmVjdFBvaW50Lm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/svgTagTemplate.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/util/svgTagTemplate.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   svg: () => (/* binding */ svg)\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\nfunction svg(strings, ...expressions) {\n    const svgParts = [];\n    strings.forEach((part, index) => {\n        svgParts.push(part);\n        if (index in expressions) {\n            svgParts.push(expressions[index]);\n        }\n    });\n    const markup = parseFromSVGString(svgParts.join(''));\n    return markup;\n}\n\nfunction parseFromSVGString(str) {\n    const parser = new DOMParser();\n    const markupString = `<svg>${str.trim()}</svg>`;\n    const xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');\n    if (xmldocument.getElementsByTagName('parsererror')[0]) {\n        throw new Error('Invalid SVG markup');\n    }\n    const document = parser.parseFromString(markupString, 'text/html');\n    const svg = document.querySelector('svg');\n    return build(svg);\n}\n\nfunction buildNode(node) {\n    const markupNode = {};\n    const { tagName, attributes, namespaceURI, style, childNodes } = node;\n\n    markupNode.namespaceURI = namespaceURI;\n    markupNode.tagName = (namespaceURI === _V_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].namespace.xhtml)\n        // XHTML documents must use lower case for all HTML element and attribute names.\n        // The tagName property returns upper case value for HTML elements.\n        // e.g. <DIV> vs.<div/>\n        ? tagName.toLowerCase()\n        : tagName;\n\n    const stylesObject = {};\n    for (var i = style.length; i--;) {\n        var nameString = style[i];\n        stylesObject[nameString] = style.getPropertyValue(nameString);\n    }\n    markupNode.style = stylesObject;\n\n    // selector fallbacks to tagName\n    const selectorAttribute = attributes.getNamedItem('@selector');\n    if (selectorAttribute) {\n        markupNode.selector = selectorAttribute.value;\n        attributes.removeNamedItem('@selector');\n    }\n\n    const groupSelectorAttribute = attributes.getNamedItem('@group-selector');\n    if (groupSelectorAttribute) {\n        const groupSelectors = groupSelectorAttribute.value.split(',');\n        markupNode.groupSelector = groupSelectors.map(s => s.trim());\n\n        attributes.removeNamedItem('@group-selector');\n    }\n\n    const className = attributes.getNamedItem('class');\n    if (className) {\n        markupNode.className = className.value;\n    }\n\n    const children = [];\n    childNodes.forEach(node => {\n        switch (node.nodeType) {\n            case Node.TEXT_NODE: {\n                const trimmedText = node.data.replace(/\\s\\s+/g, ' ');\n                if (trimmedText.trim()) {\n                    children.push(trimmedText);\n                }\n                break;\n            }\n            case Node.ELEMENT_NODE: {\n                children.push(buildNode(node));\n                break;\n            }\n            default:\n                break;\n        }\n    });\n    if (children.length) {\n        markupNode.children = children;\n    }\n\n    const nodeAttrs = {};\n\n    Array.from(attributes).forEach(nodeAttribute => {\n        const { name, value } = nodeAttribute;\n        nodeAttrs[name] = value;\n    });\n\n    if (Object.keys(nodeAttrs).length > 0) {\n        markupNode.attributes = nodeAttrs;\n    }\n\n    return markupNode;\n}\n\nfunction build(root) {\n    const markup = [];\n\n    Array.from(root.children).forEach(node => {\n        markup.push(buildNode(node));\n    });\n\n    return markup;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvc3ZnVGFnVGVtcGxhdGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStCOztBQUV4QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksdURBQXVEOztBQUVuRTtBQUNBLDJDQUEyQyxvREFBQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC9zdmdUYWdUZW1wbGF0ZS5tanM/ZGY0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdmcoc3RyaW5ncywgLi4uZXhwcmVzc2lvbnMpIHtcbiAgICBjb25zdCBzdmdQYXJ0cyA9IFtdO1xuICAgIHN0cmluZ3MuZm9yRWFjaCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgc3ZnUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgaWYgKGluZGV4IGluIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICBzdmdQYXJ0cy5wdXNoKGV4cHJlc3Npb25zW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBtYXJrdXAgPSBwYXJzZUZyb21TVkdTdHJpbmcoc3ZnUGFydHMuam9pbignJykpO1xuICAgIHJldHVybiBtYXJrdXA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnJvbVNWR1N0cmluZyhzdHIpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgbWFya3VwU3RyaW5nID0gYDxzdmc+JHtzdHIudHJpbSgpfTwvc3ZnPmA7XG4gICAgY29uc3QgeG1sZG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKG1hcmt1cFN0cmluZy5yZXBsYWNlKC9AL2csICcnKSwgJ2FwcGxpY2F0aW9uL3htbCcpO1xuICAgIGlmICh4bWxkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKVswXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU1ZHIG1hcmt1cCcpO1xuICAgIH1cbiAgICBjb25zdCBkb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcobWFya3VwU3RyaW5nLCAndGV4dC9odG1sJyk7XG4gICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgcmV0dXJuIGJ1aWxkKHN2Zyk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTm9kZShub2RlKSB7XG4gICAgY29uc3QgbWFya3VwTm9kZSA9IHt9O1xuICAgIGNvbnN0IHsgdGFnTmFtZSwgYXR0cmlidXRlcywgbmFtZXNwYWNlVVJJLCBzdHlsZSwgY2hpbGROb2RlcyB9ID0gbm9kZTtcblxuICAgIG1hcmt1cE5vZGUubmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuICAgIG1hcmt1cE5vZGUudGFnTmFtZSA9IChuYW1lc3BhY2VVUkkgPT09IFYubmFtZXNwYWNlLnhodG1sKVxuICAgICAgICAvLyBYSFRNTCBkb2N1bWVudHMgbXVzdCB1c2UgbG93ZXIgY2FzZSBmb3IgYWxsIEhUTUwgZWxlbWVudCBhbmQgYXR0cmlidXRlIG5hbWVzLlxuICAgICAgICAvLyBUaGUgdGFnTmFtZSBwcm9wZXJ0eSByZXR1cm5zIHVwcGVyIGNhc2UgdmFsdWUgZm9yIEhUTUwgZWxlbWVudHMuXG4gICAgICAgIC8vIGUuZy4gPERJVj4gdnMuPGRpdi8+XG4gICAgICAgID8gdGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIDogdGFnTmFtZTtcblxuICAgIGNvbnN0IHN0eWxlc09iamVjdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSBzdHlsZS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIG5hbWVTdHJpbmcgPSBzdHlsZVtpXTtcbiAgICAgICAgc3R5bGVzT2JqZWN0W25hbWVTdHJpbmddID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lU3RyaW5nKTtcbiAgICB9XG4gICAgbWFya3VwTm9kZS5zdHlsZSA9IHN0eWxlc09iamVjdDtcblxuICAgIC8vIHNlbGVjdG9yIGZhbGxiYWNrcyB0byB0YWdOYW1lXG4gICAgY29uc3Qgc2VsZWN0b3JBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnQHNlbGVjdG9yJyk7XG4gICAgaWYgKHNlbGVjdG9yQXR0cmlidXRlKSB7XG4gICAgICAgIG1hcmt1cE5vZGUuc2VsZWN0b3IgPSBzZWxlY3RvckF0dHJpYnV0ZS52YWx1ZTtcbiAgICAgICAgYXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW0oJ0BzZWxlY3RvcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyb3VwU2VsZWN0b3JBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnQGdyb3VwLXNlbGVjdG9yJyk7XG4gICAgaWYgKGdyb3VwU2VsZWN0b3JBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBTZWxlY3RvcnMgPSBncm91cFNlbGVjdG9yQXR0cmlidXRlLnZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgIG1hcmt1cE5vZGUuZ3JvdXBTZWxlY3RvciA9IGdyb3VwU2VsZWN0b3JzLm1hcChzID0+IHMudHJpbSgpKTtcblxuICAgICAgICBhdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbSgnQGdyb3VwLXNlbGVjdG9yJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2NsYXNzJyk7XG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBtYXJrdXBOb2RlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZS52YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGUuVEVYVF9OT0RFOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRleHQgPSBub2RlLmRhdGEucmVwbGFjZSgvXFxzXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkVGV4dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0cmltbWVkVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERToge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGROb2RlKG5vZGUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG1hcmt1cE5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlQXR0cnMgPSB7fTtcblxuICAgIEFycmF5LmZyb20oYXR0cmlidXRlcykuZm9yRWFjaChub2RlQXR0cmlidXRlID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCB2YWx1ZSB9ID0gbm9kZUF0dHJpYnV0ZTtcbiAgICAgICAgbm9kZUF0dHJzW25hbWVdID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMobm9kZUF0dHJzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1hcmt1cE5vZGUuYXR0cmlidXRlcyA9IG5vZGVBdHRycztcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwTm9kZTtcbn1cblxuZnVuY3Rpb24gYnVpbGQocm9vdCkge1xuICAgIGNvbnN0IG1hcmt1cCA9IFtdO1xuXG4gICAgQXJyYXkuZnJvbShyb290LmNoaWxkcmVuKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBtYXJrdXAucHVzaChidWlsZE5vZGUobm9kZSkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hcmt1cDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/svgTagTemplate.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/util.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/util/util.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClassNamePrefix: () => (/* binding */ addClassNamePrefix),\n/* harmony export */   assign: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.assign),\n/* harmony export */   bindAll: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.bindAll),\n/* harmony export */   breakText: () => (/* binding */ breakText),\n/* harmony export */   camelCase: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.camelCase),\n/* harmony export */   cancelFrame: () => (/* binding */ cancelFrame),\n/* harmony export */   cap: () => (/* binding */ cap),\n/* harmony export */   clone: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.clone),\n/* harmony export */   cloneDeep: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.cloneDeep),\n/* harmony export */   dataUriToBlob: () => (/* binding */ dataUriToBlob),\n/* harmony export */   debounce: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.debounce),\n/* harmony export */   deepMixin: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.deepMixin),\n/* harmony export */   deepSupplement: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.deepSupplement),\n/* harmony export */   defaults: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.defaults),\n/* harmony export */   defaultsDeep: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultsDeep),\n/* harmony export */   difference: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.difference),\n/* harmony export */   downloadBlob: () => (/* binding */ downloadBlob),\n/* harmony export */   downloadDataUri: () => (/* binding */ downloadDataUri),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   flattenDeep: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.flattenDeep),\n/* harmony export */   flattenObject: () => (/* binding */ flattenObject),\n/* harmony export */   forIn: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.forIn),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   getByPath: () => (/* binding */ getByPath),\n/* harmony export */   getElementBBox: () => (/* binding */ getElementBBox),\n/* harmony export */   groupBy: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.groupBy),\n/* harmony export */   guid: () => (/* binding */ guid),\n/* harmony export */   has: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.has),\n/* harmony export */   hashCode: () => (/* binding */ hashCode),\n/* harmony export */   imageToDataUri: () => (/* binding */ imageToDataUri),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   intersection: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.intersection),\n/* harmony export */   invoke: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.invoke),\n/* harmony export */   invokeProperty: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.invokeProperty),\n/* harmony export */   isBoolean: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isBoolean),\n/* harmony export */   isEmpty: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEmpty),\n/* harmony export */   isEqual: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEqual),\n/* harmony export */   isFunction: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction),\n/* harmony export */   isNumber: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumber),\n/* harmony export */   isObject: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject),\n/* harmony export */   isPercentage: () => (/* binding */ isPercentage),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isPlainObject),\n/* harmony export */   isString: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString),\n/* harmony export */   merge: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.merge),\n/* harmony export */   mixin: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.mixin),\n/* harmony export */   nextFrame: () => (/* binding */ nextFrame),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   normalizeEvent: () => (/* binding */ normalizeEvent),\n/* harmony export */   normalizeSides: () => (/* binding */ normalizeSides),\n/* harmony export */   normalizeWheel: () => (/* binding */ normalizeWheel),\n/* harmony export */   objectDifference: () => (/* binding */ objectDifference),\n/* harmony export */   omit: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.omit),\n/* harmony export */   parseCssNumeric: () => (/* binding */ parseCssNumeric),\n/* harmony export */   parseDOMJSON: () => (/* binding */ parseDOMJSON),\n/* harmony export */   pick: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.pick),\n/* harmony export */   removeClassNamePrefix: () => (/* binding */ removeClassNamePrefix),\n/* harmony export */   result: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.result),\n/* harmony export */   sanitizeHTML: () => (/* binding */ sanitizeHTML),\n/* harmony export */   setAttributesBySelector: () => (/* binding */ setAttributesBySelector),\n/* harmony export */   setByPath: () => (/* binding */ setByPath),\n/* harmony export */   sortBy: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortBy),\n/* harmony export */   sortElements: () => (/* binding */ sortElements),\n/* harmony export */   sortedIndex: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortedIndex),\n/* harmony export */   supplement: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.supplement),\n/* harmony export */   template: () => (/* binding */ template),\n/* harmony export */   timing: () => (/* binding */ timing),\n/* harmony export */   toArray: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray),\n/* harmony export */   toKebabCase: () => (/* binding */ toKebabCase),\n/* harmony export */   toggleFullScreen: () => (/* binding */ toggleFullScreen),\n/* harmony export */   union: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.union),\n/* harmony export */   uniq: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uniq),\n/* harmony export */   uniqueId: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uniqueId),\n/* harmony export */   unsetByPath: () => (/* binding */ unsetByPath),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   without: () => (/* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.without)\n/* harmony export */ });\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/index.mjs */ \"(ssr)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utilHelpers.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n\nconst addClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix.length) !== _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix) {\n            _className = _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix + _className;\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nconst removeClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix.length) === _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix) {\n            _className = _className.substr(_config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix.length);\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nconst parseDOMJSON = function(json, namespace) {\n\n    const selectors = {};\n    const groupSelectors = {};\n    const svgNamespace = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].namespace.svg;\n\n    const initialNS = namespace || svgNamespace;\n    const fragment = document.createDocumentFragment();\n\n    const parseNode = function(siblingsDef, parentNode, parentNS) {\n        for (let i = 0; i < siblingsDef.length; i++) {\n            const nodeDef = siblingsDef[i];\n\n            // Text node\n            if (typeof nodeDef === 'string') {\n                const textNode = document.createTextNode(nodeDef);\n                parentNode.appendChild(textNode);\n                continue;\n            }\n\n            // TagName\n            if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n            const tagName = nodeDef.tagName;\n\n            let node;\n\n            // Namespace URI\n            const ns = (nodeDef.hasOwnProperty('namespaceURI')) ? nodeDef.namespaceURI : parentNS;\n            node = document.createElementNS(ns, tagName);\n            const svg = (ns === svgNamespace);\n\n            const wrapperNode = (svg) ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node) : (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node);\n            // Attributes\n            const attributes = nodeDef.attributes;\n            if (attributes) wrapperNode.attr(attributes);\n            // Style\n            const style = nodeDef.style;\n            if (style) (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).css(style);\n            // ClassName\n            if (nodeDef.hasOwnProperty('className')) {\n                const className = nodeDef.className;\n                if (svg) {\n                    node.className.baseVal = className;\n                } else {\n                    node.className = className;\n                }\n            }\n            // TextContent\n            if (nodeDef.hasOwnProperty('textContent')) {\n                node.textContent = nodeDef.textContent;\n            }\n            // Selector\n            if (nodeDef.hasOwnProperty('selector')) {\n                const nodeSelector = nodeDef.selector;\n                if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n                selectors[nodeSelector] = node;\n                wrapperNode.attr('joint-selector', nodeSelector);\n            }\n            // Groups\n            if (nodeDef.hasOwnProperty('groupSelector')) {\n                let nodeGroups = nodeDef.groupSelector;\n                if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n                for (let j = 0; j < nodeGroups.length; j++) {\n                    const nodeGroup = nodeGroups[j];\n                    let group = groupSelectors[nodeGroup];\n                    if (!group) group = groupSelectors[nodeGroup] = [];\n                    group.push(node);\n                }\n            }\n\n            parentNode.appendChild(node);\n\n            // Children\n            const childrenDef = nodeDef.children;\n            if (Array.isArray(childrenDef)) {\n                parseNode(childrenDef, node, ns);\n            }\n        }\n    };\n    parseNode(json, fragment, initialNS);\n    return {\n        fragment: fragment,\n        selectors: selectors,\n        groupSelectors: groupSelectors\n    };\n};\n\n// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\nconst hashCode = function(str) {\n\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + c;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\n\nconst getByPath = function(obj, path, delimiter) {\n\n    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    var key;\n    var i = 0;\n    var length = keys.length;\n    while (i < length) {\n        key = keys[i++];\n        if (Object(obj) === obj && key in obj) {\n            obj = obj[key];\n        } else {\n            return undefined;\n        }\n    }\n    return obj;\n};\n\nconst isGetSafe = function(obj, key) {\n    // Prevent prototype pollution\n    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n    if (typeof key !== 'string' && typeof key !== 'number') {\n        key = String(key);\n    }\n    if (key === 'constructor' && typeof obj[key] === 'function') {\n        return false;\n    }\n    if (key === '__proto__') {\n        return false;\n    }\n    return true;\n};\n\nconst setByPath = function(obj, path, value, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        // diver creates an empty object if there is no nested object under such a key.\n        // This means that one can populate an empty nested object with setByPath().\n        diver = value || (diver[key] = {});\n    }\n\n    diver[keys[last]] = value;\n\n    return obj;\n};\n\nconst unsetByPath = function(obj, path, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        if (!value) return obj;\n        diver = value;\n    }\n\n    delete diver[keys[last]];\n\n    return obj;\n};\n\nconst flattenObject = function(obj, delim, stop) {\n\n    delim = delim || '/';\n    var ret = {};\n\n    for (var key in obj) {\n\n        if (!obj.hasOwnProperty(key)) continue;\n\n        var shouldGoDeeper = typeof obj[key] === 'object';\n        if (shouldGoDeeper && stop && stop(obj[key])) {\n            shouldGoDeeper = false;\n        }\n\n        if (shouldGoDeeper) {\n\n            var flatObject = flattenObject(obj[key], delim, stop);\n\n            for (var flatKey in flatObject) {\n                if (!flatObject.hasOwnProperty(flatKey)) continue;\n                ret[key + delim + flatKey] = flatObject[flatKey];\n            }\n\n        } else {\n\n            ret[key] = obj[key];\n        }\n    }\n\n    return ret;\n};\n\nconst uuid = function() {\n\n    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0;\n        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n};\n\n// Generates global unique id and stores it as a property of the object, if provided.\nconst guid = function(obj) {\n\n    guid.id = guid.id || 1;\n\n    if (obj === undefined) {\n        return 'j_' + guid.id++;\n    }\n\n    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n    return obj.id;\n};\n\nconst toKebabCase = function(string) {\n\n    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\nconst normalizeEvent = function(evt) {\n\n    if (evt.normalized) return evt;\n\n    const { originalEvent, target } = evt;\n\n    // If the event is a touch event, normalize it to a mouse event.\n    const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n    if (touch) {\n        for (let property in touch) {\n            // copy all the properties from the first touch that are not\n            // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n            if (evt[property] === undefined) {\n                evt[property] = touch[property];\n            }\n        }\n    }\n    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n    if (target) {\n        const useElement = target.correspondingUseElement;\n        if (useElement) evt.target = useElement;\n    }\n\n    evt.normalized = true;\n\n    return evt;\n};\n\nconst normalizeWheel = function(evt) {\n    // Sane values derived empirically\n    const PIXEL_STEP  = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0, sY = 0, pX = 0, pY = 0;\n\n    // Legacy\n    if ('detail'      in evt) { sY = evt.detail; }\n    if ('wheelDelta'  in evt) { sY = -evt.wheelDelta / 120; }\n    if ('wheelDeltaY' in evt) { sY = -evt.wheelDeltaY / 120; }\n    if ('wheelDeltaX' in evt) { sX = -evt.wheelDeltaX / 120; }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ( 'axis' in evt && evt.axis === evt.HORIZONTAL_AXIS ) {\n        sX = sY;\n        sY = 0;\n    }\n\n    pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;\n    pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;\n\n    if ((pX || pY) && evt.deltaMode) {\n        if (evt.deltaMode == 1) {\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n        } else {\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n        }\n    }\n\n    // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n    if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n        pX = pY;\n        pY = 0;\n        sX = sY;\n        sY = 0;\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n    if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n    return {\n        spinX  : sX,\n        spinY  : sY,\n        deltaX : pX,\n        deltaY : pY,\n    };\n};\n\nconst cap = function(val, max) {\n    return val > max ? max : val < -max ? -max : val;\n};\n\nconst nextFrame = (function() {\n\n    var raf;\n\n    if (typeof window !== 'undefined') {\n\n        raf = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame;\n    }\n\n    if (!raf) {\n\n        var lastTime = 0;\n\n        raf = function(callback) {\n\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n\n            lastTime = currTime + timeToCall;\n\n            return id;\n        };\n    }\n\n    return function(callback, context, ...rest) {\n        return (context !== undefined)\n            ? raf(callback.bind(context, ...rest))\n            : raf(callback);\n    };\n\n})();\n\nconst cancelFrame = (function() {\n\n    var caf;\n    var client = typeof window != 'undefined';\n\n    if (client) {\n\n        caf = window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.webkitCancelRequestAnimationFrame ||\n            window.msCancelAnimationFrame ||\n            window.msCancelRequestAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            window.oCancelRequestAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.mozCancelRequestAnimationFrame;\n    }\n\n    caf = caf || clearTimeout;\n\n    return client ? caf.bind(window) : caf;\n\n})();\n\nconst isPercentage = function(val) {\n\n    return (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString)(val) && val.slice(-1) === '%';\n};\n\nconst parseCssNumeric = function(val, restrictUnits) {\n\n    function getUnit(validUnitExp) {\n\n        // one or more numbers, followed by\n        // any number of (\n        //  `.`, followed by\n        //  one or more numbers\n        // ), followed by\n        // `validUnitExp`, followed by\n        // end of string\n        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n        if (!matches) return null;\n        return matches[1];\n    }\n\n    var number = parseFloat(val);\n\n    // if `val` cannot be parsed as a number, return `null`\n    if (Number.isNaN(number)) return null;\n\n    // else: we know `output.value`\n    var output = {};\n    output.value = number;\n\n    // determine the unit\n    var validUnitExp;\n    if (restrictUnits == null) {\n        // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = '[A-Za-z]*';\n\n    } else if (Array.isArray(restrictUnits)) {\n        // if this is an empty array, top restriction - return `null`\n        if (restrictUnits.length === 0) return null;\n\n        // else: restriction - an array of valid unit strings\n        validUnitExp = restrictUnits.join('|');\n\n    } else if ((0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString)(restrictUnits)) {\n        // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n    }\n    var unit = getUnit(validUnitExp);\n\n    // if we found no matches for `restrictUnits`, return `null`\n    if (unit === null) return null;\n\n    // else: we know the unit\n    output.unit = unit;\n    return output;\n};\n\nconst NO_SPACE = 0;\n\nfunction splitWordWithEOL(word, eol) {\n    const eolWords = word.split(eol);\n    let n = 1;\n    for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {\n        const replacement = [];\n        if (j > 0 || eolWords[0] !== '') replacement.push(NO_SPACE);\n        replacement.push(eol);\n        if (j < jl - 1 || eolWords[jl] !== '') replacement.push(NO_SPACE);\n        eolWords.splice(n, 0, ...replacement);\n        n += replacement.length + 1;\n    }\n    return eolWords.filter(word => word !== '');\n}\n\n\nfunction getLineHeight(heightValue, textElement) {\n    if (heightValue === null) {\n        // Default 1em lineHeight\n        return textElement.getBBox().height;\n    }\n\n    switch (heightValue.unit) {\n        case 'em':\n            return textElement.getBBox().height * heightValue.value;\n        case 'px':\n        case '':\n            return heightValue.value;\n    }\n}\n\nconst breakText = function(text, size, styles = {}, opt = {}) {\n\n    var width = size.width;\n    var height = size.height;\n\n    var svgDocument = opt.svgDocument || (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('svg').node;\n    var textSpan = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('tspan').node;\n    var textElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('text').attr(styles).append(textSpan).node;\n    var textNode = document.createTextNode('');\n\n    // Prevent flickering\n    textElement.style.opacity = 0;\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    textElement.style.display = 'block';\n    textSpan.style.display = 'block';\n\n    textSpan.appendChild(textNode);\n    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n    if (!opt.svgDocument) {\n\n        document.body.appendChild(svgDocument);\n    }\n\n    const preserveSpaces = opt.preserveSpaces;\n    const space = ' ';\n    const separator = (opt.separator || opt.separator === '') ? opt.separator : space;\n    // If separator is a RegExp, we use the space character to join words together again (not ideal)\n    const separatorChar = (typeof separator === 'string') ? separator : space;\n    var eol = opt.eol || '\\n';\n    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d\\u00C0-\\u1FFF\\u2800-\\uFFFD]/;\n    var maxLineCount = opt.maxLineCount;\n    if (!(0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumber)(maxLineCount)) maxLineCount = Infinity;\n\n    var words = text.split(separator);\n    var full = [];\n    var lines = [];\n    var p, h;\n    var lineHeight;\n\n    if (preserveSpaces) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(textSpan).attr('xml:space', 'preserve');\n    }\n\n    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n        var word = words[i];\n\n        if (!word && !preserveSpaces) continue;\n        if (typeof word !== 'string') continue;\n\n        var isEol = false;\n        if (eol && word.indexOf(eol) >= 0) {\n            // word contains end-of-line character\n            if (word.length > 1) {\n                // separate word and continue cycle\n                const eolWords = splitWordWithEOL(words[i], eol);\n                words.splice(i, 1, ...eolWords);\n                i--;\n                len = words.length;\n                continue;\n            } else {\n                // creates a new line\n                if (preserveSpaces && typeof words[i - 1] === 'string' ) {\n                    words.splice(i, NO_SPACE, '', NO_SPACE);\n                    len += 2;\n                    i--;\n                    continue;\n                }\n                lines[++l] = (!preserveSpaces || typeof words[i + 1] === 'string') ? '' : undefined;\n                isEol = true;\n            }\n        }\n\n        if (!isEol) {\n\n            let data;\n            if (preserveSpaces) {\n                data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;\n            } else {\n                data = lines[l] ? lines[l] + separatorChar + word : word;\n            }\n\n            textNode.data = data;\n\n            if (textSpan.getComputedTextLength() <= width) {\n\n                // the current line fits\n                lines[l] = data;\n\n                if (p || h) {\n                    // We were partitioning. Put rest of the word onto next line\n                    full[l++] = true;\n\n                    // cancel partitioning and splitting by hyphens\n                    p = 0;\n                    h = 0;\n                }\n\n            } else {\n\n                if (!lines[l] || p) {\n\n                    var partition = !!p;\n\n                    p = word.length - 1;\n\n                    if (partition || !p) {\n\n                        // word has only one character.\n                        if (!p) {\n\n                            if (!lines[l]) {\n\n                                // we won't fit this text within our rect\n                                lines = [];\n\n                                break;\n                            }\n\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n\n                            // cancel partitions created\n                            words.splice(i, 2, word + words[i + 1]);\n\n                            // adjust word length\n                            len--;\n\n                            full[l++] = true;\n                            i--;\n\n                            continue;\n                        }\n\n                        // move last letter to the beginning of the next word\n                        words[i] = word.substring(0, p);\n                        const nextWord = words[i + 1];\n                        words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? '' : nextWord);\n\n                    } else {\n\n                        if (h) {\n                        // cancel splitting and put the words together again\n                            words.splice(i, 2, words[i] + words[i + 1]);\n                            h = 0;\n                        } else {\n                            var hyphenIndex = word.search(hyphen);\n                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                h = hyphenIndex + 1;\n                                p = 0;\n                            }\n\n                            // We initiate partitioning or splitting\n                            // split the long word into two words\n                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n                            // adjust words length\n                            len++;\n\n                        }\n\n                        if (l && !full[l - 1]) {\n                        // if the previous line is not full, try to fit max part of\n                        // the current word there\n                            l--;\n                        }\n                    }\n\n                    if (!preserveSpaces || lines[l] !== '') {\n                        i--;\n                    }\n\n                    continue;\n                }\n\n                l++;\n                i--;\n            }\n        }\n        var lastL = null;\n\n        if (lines.length > maxLineCount) {\n\n            lastL = maxLineCount - 1;\n\n        } else if (height !== undefined) {\n\n            // if size.height is defined we have to check whether the height of the entire\n            // text exceeds the rect height\n\n            if (lineHeight === undefined && textNode.data !== '') {\n\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === 'auto') {\n                    lineHeight = getLineHeight({ value: 1.5, unit: 'em' }, textElement);\n                } else {\n                    const parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);\n\n                    lineHeight = getLineHeight(parsed, textElement);\n                }\n            }\n\n            if (lineHeight * lines.length > height) {\n                // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n        }\n\n        if (lastL !== null) {\n\n            lines.splice(lastL + 1);\n\n            // add ellipsis\n            var ellipsis = opt.ellipsis;\n            if (!ellipsis || lastL < 0) break;\n            if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\n            var lastLine = lines[lastL];\n            if (!lastLine && !isEol) break;\n            var k = lastLine.length;\n            var lastLineWithOmission, lastChar;\n            do {\n                lastChar = lastLine[k];\n                lastLineWithOmission = lastLine.substring(0, k);\n                if (!lastChar) {\n                    lastLineWithOmission += separatorChar;\n                } else if (lastChar.match(separator)) {\n                    lastLineWithOmission += lastChar;\n                }\n                lastLineWithOmission += ellipsis;\n                textNode.data = lastLineWithOmission;\n                if (textSpan.getComputedTextLength() <= width) {\n                    lines[lastL] = lastLineWithOmission;\n                    break;\n                }\n                k--;\n            } while (k >= 0);\n            break;\n        }\n    }\n\n    if (opt.svgDocument) {\n\n        // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n\n    } else {\n\n        // clean svg document\n        document.body.removeChild(svgDocument);\n    }\n\n    return lines.join(eol);\n};\n\n// Sanitize HTML\n// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n// Parses a string into an array of DOM nodes.\n// Then outputs it back as a string.\nconst sanitizeHTML = function(html) {\n\n    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n    const [outputEl] = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseHTML('<div>' + html + '</div>');\n\n    Array.from(outputEl.getElementsByTagName('*')).forEach(function(node) { // for all nodes\n        const names = node.getAttributeNames();\n        names.forEach(function(name) {\n            const value = node.getAttribute(name);\n            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n            if (name.startsWith('on') || value.startsWith('javascript:' || 0 || 0)) {\n                node.removeAttribute(name);\n            }\n        });\n    });\n\n    return outputEl.innerHTML;\n};\n\n// Download `blob` as file with `fileName`.\n// Does not work in IE9.\nconst downloadBlob = function(blob, fileName) {\n\n    if (window.navigator.msSaveBlob) { // requires IE 10+\n        // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n\n    } else { // other browsers\n        // downloads directly in Chrome and Safari\n\n        // presents a save/open dialog in Firefox\n        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement('a');\n\n        link.href = url;\n        link.download = fileName;\n        document.body.appendChild(link);\n\n        link.click();\n\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n    }\n};\n\n// Download `dataUri` as file with `fileName`.\n// Does not work in IE9.\nconst downloadDataUri = function(dataUri, fileName) {\n\n    const blob = dataUriToBlob(dataUri);\n    downloadBlob(blob, fileName);\n};\n\n// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\nconst dataUriToBlob = function(dataUri) {\n\n    // first, make sure there are no newlines in the data uri\n    dataUri = dataUri.replace(/\\s/g, '');\n    dataUri = decodeURIComponent(dataUri);\n\n    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n    var data = dataUri.slice(firstCommaIndex + 1);\n    var decodedString;\n    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n        decodedString = atob(data); // decode data\n    } else {\n        // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    var ia = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n        ia[i] = decodedString.charCodeAt(i);\n    }\n\n    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n};\n\n// Read an image at `url` and return it as base64-encoded data uri.\n// The mime type of the image is inferred from the `url` file extension.\n// If data uri is provided as `url`, it is returned back unchanged.\n// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n// Works with IE9.\nconst imageToDataUri = function(url, callback) {\n\n    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n        // No need to convert to data uri if it is already in data uri.\n\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n    }\n\n    // chrome, IE10+\n    var modernHandler = function(xhr, callback) {\n\n        if (xhr.status === 200) {\n\n            var reader = new FileReader();\n\n            reader.onload = function(evt) {\n                var dataUri = evt.target.result;\n                callback(null, dataUri);\n            };\n\n            reader.onerror = function() {\n                callback(new Error('Failed to load image ' + url));\n            };\n\n            reader.readAsDataURL(xhr.response);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var legacyHandler = function(xhr, callback) {\n\n        var Uint8ToString = function(u8a) {\n            var CHUNK_SZ = 0x8000;\n            var c = [];\n            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n            }\n            return c.join('');\n        };\n\n        if (xhr.status === 200) {\n\n            var bytes = new Uint8Array(xhr.response);\n\n            var suffix = (url.split('.').pop()) || 'png';\n            var map = {\n                'svg': 'svg+xml'\n            };\n            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n            var b64encoded = meta + btoa(Uint8ToString(bytes));\n            callback(null, b64encoded);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', function() {\n        callback(new Error('Failed to load image ' + url));\n    });\n\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n    xhr.addEventListener('load', function() {\n        if (window.FileReader) {\n            modernHandler(xhr, callback);\n        } else {\n            legacyHandler(xhr, callback);\n        }\n    });\n\n    xhr.send();\n};\n\nconst getElementBBox = function(el) {\n\n    var $el = (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el);\n    if ($el.length === 0) {\n        throw new Error('Element not found');\n    }\n\n    var element = $el[0];\n    var doc = element.ownerDocument;\n    var clientBBox = element.getBoundingClientRect();\n\n    var strokeWidthX = 0;\n    var strokeWidthY = 0;\n\n    // Firefox correction\n    if (element.ownerSVGElement) {\n\n        var vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n        var bbox = vel.getBBox({ target: vel.svg() });\n\n        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n        strokeWidthX = (clientBBox.width - bbox.width);\n        strokeWidthY = (clientBBox.height - bbox.height);\n    }\n\n    return {\n        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n        width: clientBBox.width - strokeWidthX,\n        height: clientBBox.height - strokeWidthY\n    };\n};\n\n\n// Highly inspired by the jquery.sortElements plugin by Padolsey.\n// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\nconst sortElements = function(elements, comparator) {\n\n    elements = (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(elements).toArray();\n    var placements = elements.map(function(sortElement) {\n\n        var parentNode = sortElement.parentNode;\n        // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n        return function() {\n\n            if (parentNode === this) {\n                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n            }\n\n            // Insert before flag:\n            parentNode.insertBefore(this, nextSibling);\n            // Remove flag:\n            parentNode.removeChild(nextSibling);\n        };\n    });\n\n    elements.sort(comparator);\n    for (var i = 0; i < placements.length; i++) {\n        placements[i].call(elements[i]);\n    }\n    return elements;\n};\n\n// Sets attributes on the given element and its descendants based on the selector.\n// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\nconst setAttributesBySelector = function(element, attrs) {\n\n    var $element = (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element);\n\n    (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.forIn)(attrs, function(attrs, selector) {\n        var $elements = $element.find(selector).addBack().filter(selector);\n        // Make a special case for setting classes.\n        // We do not want to overwrite any existing class.\n        if ((0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.has)(attrs, 'class')) {\n            $elements.addClass(attrs['class']);\n            attrs = (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.omit)(attrs, 'class');\n        }\n        $elements.attr(attrs);\n    });\n};\n\n// Return a new object with all four sides (top, right, bottom, left) in it.\n// Value of each side is taken from the given argument (either number or object).\n// Default value for a side is 0.\n// Examples:\n// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\nconst normalizeSides = function(box) {\n\n    if (Object(box) !== box) { // `box` is not an object\n        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n        return { top: val, right: val, bottom: val, left: val };\n    }\n\n    // `box` is an object\n    var top, right, bottom, left;\n    top = right = bottom = left = 0;\n\n    if (isFinite(box.vertical)) top = bottom = +box.vertical;\n    if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\n    if (isFinite(box.top)) top = +box.top; // overwrite vertical\n    if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n    if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n    return { top: top, right: right, bottom: bottom, left: left };\n};\n\nconst timing = {\n\n    linear: function(t) {\n        return t;\n    },\n\n    quad: function(t) {\n        return t * t;\n    },\n\n    cubic: function(t) {\n        return t * t * t;\n    },\n\n    inout: function(t) {\n        if (t <= 0) return 0;\n        if (t >= 1) return 1;\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n    },\n\n    exponential: function(t) {\n        return Math.pow(2, 10 * (t - 1));\n    },\n\n    bounce: function(t) {\n        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n            if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        }\n    },\n\n    reverse: function(f) {\n        return function(t) {\n            return 1 - f(1 - t);\n        };\n    },\n\n    reflect: function(f) {\n        return function(t) {\n            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n        };\n    },\n\n    clamp: function(f, n, x) {\n        n = n || 0;\n        x = x || 1;\n        return function(t) {\n            var r = f(t);\n            return r < n ? n : r > x ? x : r;\n        };\n    },\n\n    back: function(s) {\n        if (!s) s = 1.70158;\n        return function(t) {\n            return t * t * ((s + 1) * t - s);\n        };\n    },\n\n    elastic: function(x) {\n        if (!x) x = 1.5;\n        return function(t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n        };\n    }\n};\n\nconst interpolate = {\n\n    number: function(a, b) {\n        var d = b - a;\n        return function(t) {\n            return a + d * t;\n        };\n    },\n\n    object: function(a, b) {\n        var s = Object.keys(a);\n        return function(t) {\n            var i, p;\n            var r = {};\n            for (i = s.length - 1; i != -1; i--) {\n                p = s[i];\n                r[p] = a[p] + (b[p] - a[p]) * t;\n            }\n            return r;\n        };\n    },\n\n    hexColor: function(a, b) {\n\n        var ca = parseInt(a.slice(1), 16);\n        var cb = parseInt(b.slice(1), 16);\n        var ra = ca & 0x0000ff;\n        var rd = (cb & 0x0000ff) - ra;\n        var ga = ca & 0x00ff00;\n        var gd = (cb & 0x00ff00) - ga;\n        var ba = ca & 0xff0000;\n        var bd = (cb & 0xff0000) - ba;\n\n        return function(t) {\n\n            var r = (ra + rd * t) & 0x000000ff;\n            var g = (ga + gd * t) & 0x0000ff00;\n            var b = (ba + bd * t) & 0x00ff0000;\n\n            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n        };\n    },\n\n    unit: function(a, b) {\n\n        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n        var ma = r.exec(a);\n        var mb = r.exec(b);\n        var p = mb[1].indexOf('.');\n        var f = p > 0 ? mb[1].length - p - 1 : 0;\n        a = +ma[1];\n        var d = +mb[1] - a;\n        var u = ma[2];\n\n        return function(t) {\n            return (a + d * t).toFixed(f) + u;\n        };\n    }\n};\n\n// SVG filters.\n// (values in parentheses are default values)\nconst filter = {\n\n    // `color` ... outline color ('blue')\n    // `width`... outline width (1)\n    // `opacity` ... outline opacity (1)\n    // `margin` ... gap between outline and the element (2)\n    outline: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n        var width = Number.isFinite(args.width) ? args.width : 1;\n\n        return template(tpl)({\n            color: args.color || 'blue',\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            outerRadius: margin + width,\n            innerRadius: margin\n        });\n    },\n\n    // `color` ... color ('red')\n    // `width`... width (1)\n    // `blur` ... blur (0)\n    // `opacity` ... opacity (1)\n    highlight: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n        return template(tpl)({\n            color: args.color || 'red',\n            width: Number.isFinite(args.width) ? args.width : 1,\n            blur: Number.isFinite(args.blur) ? args.blur : 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n        });\n    },\n\n    // `x` ... horizontal blur (2)\n    // `y` ... vertical blur (optional)\n    blur: function(args) {\n\n        var x = Number.isFinite(args.x) ? args.x : 2;\n\n        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n        });\n    },\n\n    // `dx` ... horizontal shift (0)\n    // `dy` ... vertical shift (0)\n    // `blur` ... blur (4)\n    // `color` ... color ('black')\n    // `opacity` ... opacity (1)\n    dropShadow: function(args) {\n\n        var tpl = 'SVGFEDropShadowElement' in window\n            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        return template(tpl)({\n            dx: args.dx || 0,\n            dy: args.dy || 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            color: args.color || 'black',\n            blur: Number.isFinite(args.blur) ? args.blur : 4\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n    grayscale: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n    sepia: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n    saturate: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - amount\n        });\n    },\n\n    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n    hueRotate: function(args) {\n\n        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: args.angle || 0\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n    invert: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: 1 - amount\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    brightness: function(args) {\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(args.amount) ? args.amount : 1\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    contrast: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    }\n};\n\nconst format = {\n\n    // Formatting numbers via the Python Format Specification Mini-language.\n    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n    // Heavilly inspired by the D3.js library implementation.\n    number: function(specifier, value, locale) {\n\n        locale = locale || {\n\n            currency: ['$', ''],\n            decimal: '.',\n            thousands: ',',\n            grouping: [3]\n        };\n\n        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n        var match = re.exec(specifier);\n        var fill = match[1] || ' ';\n        var align = match[2] || '>';\n        var sign = match[3] || '';\n        var symbol = match[4] || '';\n        var zfill = match[5];\n        var width = +match[6];\n        var comma = match[7];\n        var precision = match[8];\n        var type = match[9];\n        var scale = 1;\n        var prefix = '';\n        var suffix = '';\n        var integer = false;\n\n        if (precision) precision = +precision.substring(1);\n\n        if (zfill || fill === '0' && align === '=') {\n            zfill = fill = '0';\n            align = '=';\n            if (comma) width -= Math.floor((width - 1) / 4);\n        }\n\n        switch (type) {\n            case 'n':\n                comma = true;\n                type = 'g';\n                break;\n            case '%':\n                scale = 100;\n                suffix = '%';\n                type = 'f';\n                break;\n            case 'p':\n                scale = 100;\n                suffix = '%';\n                type = 'r';\n                break;\n            case 'b':\n            case 'o':\n            case 'x':\n            case 'X':\n                if (symbol === '#') prefix = '0' + type.toLowerCase();\n                break;\n            case 'c':\n            case 'd':\n                integer = true;\n                precision = 0;\n                break;\n            case 's':\n                scale = -1;\n                type = 'r';\n                break;\n        }\n\n        if (symbol === '$') {\n            prefix = locale.currency[0];\n            suffix = locale.currency[1];\n        }\n\n        // If no precision is specified for `'r'`, fallback to general notation.\n        if (type == 'r' && !precision) type = 'g';\n\n        // Ensure that the requested precision is in the supported range.\n        if (precision != null) {\n            if (type == 'g') precision = Math.max(1, Math.min(21, precision));\n            else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n        }\n\n        var zcomma = zfill && comma;\n\n        // Return the empty string for floats formatted as ints.\n        if (integer && (value % 1)) return '';\n\n        // Convert negative to positive, and record the sign prefix.\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n        var fullSuffix = suffix;\n\n        // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n        if (scale < 0) {\n            var unit = this.prefix(value, precision);\n            value = unit.scale(value);\n            fullSuffix = unit.symbol + suffix;\n        } else {\n            value *= scale;\n        }\n\n        // Convert to the desired precision.\n        value = this.convert(type, value, precision);\n\n        // Break the value into the integer part (before) and decimal part (after).\n        var i = value.lastIndexOf('.');\n        var before = i < 0 ? value : value.substring(0, i);\n        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n        function formatGroup(value) {\n\n            var i = value.length;\n            var t = [];\n            var j = 0;\n            var g = locale.grouping[0];\n            while (i > 0 && g > 0) {\n                t.push(value.substring(i -= g, i + g));\n                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n            }\n            return t.reverse().join(locale.thousands);\n        }\n\n        // If the fill character is not `'0'`, grouping is applied before padding.\n        if (!zfill && comma && locale.grouping) {\n\n            before = formatGroup(before);\n        }\n\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n        // If the fill character is `'0'`, grouping is applied after padding.\n        if (zcomma) before = formatGroup(padding + before);\n\n        // Apply prefix.\n        negative += prefix;\n\n        // Rejoin integer and decimal parts.\n        value = before + after;\n\n        return (align === '<' ? negative + value + padding\n            : align === '>' ? padding + negative + value\n                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n    },\n\n    // Formatting string via the Python Format string.\n    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n    string: function(formatString, value) {\n\n        var fieldDelimiterIndex;\n        var fieldDelimiter = '{';\n        var endPlaceholder = false;\n        var formattedStringArray = [];\n\n        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n            var pieceFormattedString, formatSpec, fieldName;\n\n            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n            if (endPlaceholder) {\n                formatSpec = pieceFormattedString.split(':');\n                fieldName = formatSpec.shift().split('.');\n                pieceFormattedString = value;\n\n                for (var i = 0; i < fieldName.length; i++)\n                    pieceFormattedString = pieceFormattedString[fieldName[i]];\n\n                if (formatSpec.length)\n                    pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n            }\n\n            formattedStringArray.push(pieceFormattedString);\n\n            formatString = formatString.slice(fieldDelimiterIndex + 1);\n            endPlaceholder = !endPlaceholder;\n            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n        }\n        formattedStringArray.push(formatString);\n\n        return formattedStringArray.join('');\n    },\n\n    convert: function(type, value, precision) {\n\n        switch (type) {\n            case 'b':\n                return value.toString(2);\n            case 'c':\n                return String.fromCharCode(value);\n            case 'o':\n                return value.toString(8);\n            case 'x':\n                return value.toString(16);\n            case 'X':\n                return value.toString(16).toUpperCase();\n            case 'g':\n                return value.toPrecision(precision);\n            case 'e':\n                return value.toExponential(precision);\n            case 'f':\n                return value.toFixed(precision);\n            case 'r':\n                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n            default:\n                return value + '';\n        }\n    },\n\n    round: function(value, precision) {\n\n        return precision\n            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n            : Math.round(value);\n    },\n\n    precision: function(value, precision) {\n\n        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n    },\n\n    prefix: function(value, precision) {\n\n        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n            var k = Math.pow(10, Math.abs(8 - i) * 3);\n            return {\n                scale: i > 8 ? function(d) {\n                    return d / k;\n                } : function(d) {\n                    return d * k;\n                },\n                symbol: d\n            };\n        });\n\n        var i = 0;\n        if (value) {\n            if (value < 0) value *= -1;\n            if (precision) value = this.round(value, this.precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n        }\n        return prefixes[8 + i / 3];\n    }\n};\n\n/*\n    Pre-compile the HTML to be used as a template.\n*/\nconst template = function(html) {\n\n    /*\n        Must support the variation in templating syntax found here:\n        https://lodash.com/docs#template\n    */\n    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n    return function(data) {\n\n        data = data || {};\n\n        return html.replace(regex, function(match) {\n\n            var args = Array.from(arguments);\n            var attr = args.slice(1, 4).find(function(_attr) {\n                return !!_attr;\n            });\n\n            var attrArray = attr.split('.');\n            var value = data[attrArray.shift()];\n\n            while (value !== undefined && attrArray.length) {\n                value = value[attrArray.shift()];\n            }\n\n            return value !== undefined ? value : '';\n        });\n    };\n};\n\n/**\n * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n */\nconst toggleFullScreen = function(el) {\n\n    var topDocument = window.top.document;\n    el = el || topDocument.body;\n\n    function prefixedResult(el, prop) {\n\n        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n        for (var i = 0; i < prefixes.length; i++) {\n            var prefix = prefixes[i];\n            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n            if (el[propName] !== undefined) {\n                return (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n    }\n\n    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n    } else {\n        prefixedResult(el, 'RequestFullscreen') || // Spec.\n        prefixedResult(el, 'RequestFullScreen'); // Firefox\n    }\n};\n\nfunction findDifference(obj, baseObj, currentDepth, maxDepth) {\n\n    if (currentDepth === maxDepth) {\n        return {};\n    }\n\n    const diff = {};\n\n    Object.keys(obj).forEach((key) => {\n\n        const objValue = obj[key];\n        const baseValue = baseObj[key];\n\n        if (!Array.isArray(objValue) && !Array.isArray(baseValue) && (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject)(objValue) && (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject)(baseValue)) {\n\n            const nestedDepth = currentDepth + 1;\n            const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);\n\n            if (Object.keys(nestedDiff).length > 0) {\n                diff[key] = nestedDiff;\n            } else if ((currentDepth === 0 || nestedDepth === maxDepth)) {\n                diff[key] = {};\n            }\n\n        } else if (!(0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEqual)(objValue, baseValue)) {\n            diff[key] = objValue;\n        }\n    });\n\n    return diff;\n}\n\nfunction objectDifference(object, base, opt) {\n\n    const { maxDepth = Number.POSITIVE_INFINITY } = opt || {};\n\n    return findDifference(object, base, 0, maxDepth);\n}\n\n\n\nconst noop = function() {\n    // Do nothing.\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvdXRpbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNOO0FBQ2M7QUF5Q2xCOztBQUVwQjs7QUFFUDs7QUFFQTs7QUFFQSxpQ0FBaUMscURBQU0sNkJBQTZCLHFEQUFNO0FBQzFFLHlCQUF5QixxREFBTTtBQUMvQjs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUEsaUNBQWlDLHFEQUFNLDZCQUE2QixxREFBTTtBQUMxRSwyQ0FBMkMscURBQU07QUFDakQ7O0FBRUE7O0FBRUEsS0FBSztBQUNMOztBQUVPOztBQUVQO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQUM7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLHdEQUFDLFNBQVMsOERBQUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBQztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTzs7QUFFUDtBQUNBO0FBQ0Esb0JBQW9C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O0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQVU7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsTUFBTTtBQUNOO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEscUVBQXFFLDBEQUFRLGNBQWMsMERBQVE7O0FBRW5HO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFVBQVUsVUFBVSx5REFBTztBQUMzQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVPOztBQUVQLFlBQVksc0NBQXNDOztBQUVsRDtBQUNBOztBQTBDRTs7QUFFSztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ncmFwaC12aXN1YWxpemVyLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL3V0aWwubWpzPzRkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQgZnJvbSAnLi4vbXZjL0RvbS9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2luZGV4Lm1qcyc7XG5pbXBvcnQge1xuICAgIGlzQm9vbGVhbixcbiAgICBpc09iamVjdCxcbiAgICBpc051bWJlcixcbiAgICBpc1N0cmluZyxcbiAgICBtaXhpbixcbiAgICBkZWVwTWl4aW4sXG4gICAgc3VwcGxlbWVudCxcbiAgICBkZWZhdWx0cyxcbiAgICBkZWZhdWx0c0RlZXAsXG4gICAgZGVlcFN1cHBsZW1lbnQsXG4gICAgYXNzaWduLFxuICAgIGludm9rZSxcbiAgICBpbnZva2VQcm9wZXJ0eSxcbiAgICBzb3J0ZWRJbmRleCxcbiAgICB1bmlxLFxuICAgIGNsb25lLFxuICAgIGNsb25lRGVlcCxcbiAgICBpc0VtcHR5LFxuICAgIGlzRXF1YWwsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1BsYWluT2JqZWN0LFxuICAgIHRvQXJyYXksXG4gICAgZGVib3VuY2UsXG4gICAgZ3JvdXBCeSxcbiAgICBzb3J0QnksXG4gICAgZmxhdHRlbkRlZXAsXG4gICAgd2l0aG91dCxcbiAgICBkaWZmZXJlbmNlLFxuICAgIGludGVyc2VjdGlvbixcbiAgICB1bmlvbixcbiAgICBoYXMsXG4gICAgcmVzdWx0LFxuICAgIG9taXQsXG4gICAgcGljayxcbiAgICBiaW5kQWxsLFxuICAgIGZvckluLFxuICAgIGNhbWVsQ2FzZSxcbiAgICB1bmlxdWVJZCxcbiAgICBtZXJnZVxufSBmcm9tICcuL3V0aWxIZWxwZXJzLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBhZGRDbGFzc05hbWVQcmVmaXggPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcblxuICAgIGlmICghY2xhc3NOYW1lKSByZXR1cm4gY2xhc3NOYW1lO1xuXG4gICAgcmV0dXJuIGNsYXNzTmFtZS50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKF9jbGFzc05hbWUpIHtcblxuICAgICAgICBpZiAoX2NsYXNzTmFtZS5zdWJzdHIoMCwgY29uZmlnLmNsYXNzTmFtZVByZWZpeC5sZW5ndGgpICE9PSBjb25maWcuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgICAgICBfY2xhc3NOYW1lID0gY29uZmlnLmNsYXNzTmFtZVByZWZpeCArIF9jbGFzc05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NsYXNzTmFtZTtcblxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVDbGFzc05hbWVQcmVmaXggPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcblxuICAgIGlmICghY2xhc3NOYW1lKSByZXR1cm4gY2xhc3NOYW1lO1xuXG4gICAgcmV0dXJuIGNsYXNzTmFtZS50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKF9jbGFzc05hbWUpIHtcblxuICAgICAgICBpZiAoX2NsYXNzTmFtZS5zdWJzdHIoMCwgY29uZmlnLmNsYXNzTmFtZVByZWZpeC5sZW5ndGgpID09PSBjb25maWcuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgICAgICBfY2xhc3NOYW1lID0gX2NsYXNzTmFtZS5zdWJzdHIoY29uZmlnLmNsYXNzTmFtZVByZWZpeC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jbGFzc05hbWU7XG5cbiAgICB9KS5qb2luKCcgJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VET01KU09OID0gZnVuY3Rpb24oanNvbiwgbmFtZXNwYWNlKSB7XG5cbiAgICBjb25zdCBzZWxlY3RvcnMgPSB7fTtcbiAgICBjb25zdCBncm91cFNlbGVjdG9ycyA9IHt9O1xuICAgIGNvbnN0IHN2Z05hbWVzcGFjZSA9IFYubmFtZXNwYWNlLnN2ZztcblxuICAgIGNvbnN0IGluaXRpYWxOUyA9IG5hbWVzcGFjZSB8fCBzdmdOYW1lc3BhY2U7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBjb25zdCBwYXJzZU5vZGUgPSBmdW5jdGlvbihzaWJsaW5nc0RlZiwgcGFyZW50Tm9kZSwgcGFyZW50TlMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWJsaW5nc0RlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZURlZiA9IHNpYmxpbmdzRGVmW2ldO1xuXG4gICAgICAgICAgICAvLyBUZXh0IG5vZGVcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZURlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGVEZWYpO1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUYWdOYW1lXG4gICAgICAgICAgICBpZiAoIW5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ3RhZ05hbWUnKSkgdGhyb3cgbmV3IEVycm9yKCdqc29uLWRvbS1wYXJzZXI6IG1pc3NpbmcgdGFnTmFtZScpO1xuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IG5vZGVEZWYudGFnTmFtZTtcblxuICAgICAgICAgICAgbGV0IG5vZGU7XG5cbiAgICAgICAgICAgIC8vIE5hbWVzcGFjZSBVUklcbiAgICAgICAgICAgIGNvbnN0IG5zID0gKG5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ25hbWVzcGFjZVVSSScpKSA/IG5vZGVEZWYubmFtZXNwYWNlVVJJIDogcGFyZW50TlM7XG4gICAgICAgICAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWdOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHN2ZyA9IChucyA9PT0gc3ZnTmFtZXNwYWNlKTtcblxuICAgICAgICAgICAgY29uc3Qgd3JhcHBlck5vZGUgPSAoc3ZnKSA/IFYobm9kZSkgOiAkKG5vZGUpO1xuICAgICAgICAgICAgLy8gQXR0cmlidXRlc1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGVEZWYuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB3cmFwcGVyTm9kZS5hdHRyKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgLy8gU3R5bGVcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbm9kZURlZi5zdHlsZTtcbiAgICAgICAgICAgIGlmIChzdHlsZSkgJChub2RlKS5jc3Moc3R5bGUpO1xuICAgICAgICAgICAgLy8gQ2xhc3NOYW1lXG4gICAgICAgICAgICBpZiAobm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgnY2xhc3NOYW1lJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBub2RlRGVmLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lLmJhc2VWYWwgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGV4dENvbnRlbnRcbiAgICAgICAgICAgIGlmIChub2RlRGVmLmhhc093blByb3BlcnR5KCd0ZXh0Q29udGVudCcpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IG5vZGVEZWYudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZWxlY3RvclxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ3NlbGVjdG9yJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlU2VsZWN0b3IgPSBub2RlRGVmLnNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnNbbm9kZVNlbGVjdG9yXSkgdGhyb3cgbmV3IEVycm9yKCdqc29uLWRvbS1wYXJzZXI6IHNlbGVjdG9yIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzW25vZGVTZWxlY3Rvcl0gPSBub2RlO1xuICAgICAgICAgICAgICAgIHdyYXBwZXJOb2RlLmF0dHIoJ2pvaW50LXNlbGVjdG9yJywgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3Vwc1xuICAgICAgICAgICAgaWYgKG5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ2dyb3VwU2VsZWN0b3InKSkge1xuICAgICAgICAgICAgICAgIGxldCBub2RlR3JvdXBzID0gbm9kZURlZi5ncm91cFNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlR3JvdXBzKSkgbm9kZUdyb3VwcyA9IFtub2RlR3JvdXBzXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGVHcm91cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUdyb3VwID0gbm9kZUdyb3Vwc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gZ3JvdXBTZWxlY3RvcnNbbm9kZUdyb3VwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFncm91cCkgZ3JvdXAgPSBncm91cFNlbGVjdG9yc1tub2RlR3JvdXBdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBDaGlsZHJlblxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5EZWYgPSBub2RlRGVmLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5EZWYpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VOb2RlKGNoaWxkcmVuRGVmLCBub2RlLCBucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBhcnNlTm9kZShqc29uLCBmcmFnbWVudCwgaW5pdGlhbE5TKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgIHNlbGVjdG9yczogc2VsZWN0b3JzLFxuICAgICAgICBncm91cFNlbGVjdG9yczogZ3JvdXBTZWxlY3RvcnNcbiAgICB9O1xufTtcblxuLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggY29kZSBmcm9tIGEgc3RyaW5nLiBTZWUgaHR0cDovL3dlcnhsdGQuY29tL3dwLzIwMTAvMDUvMTMvamF2YXNjcmlwdC1pbXBsZW1lbnRhdGlvbi1vZi1qYXZhcy1zdHJpbmctaGFzaGNvZGUtbWV0aG9kLy5cbmV4cG9ydCBjb25zdCBoYXNoQ29kZSA9IGZ1bmN0aW9uKHN0cikge1xuXG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSByZXR1cm4gaGFzaDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGM7XG4gICAgICAgIGhhc2ggPSBoYXNoICYgaGFzaDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEJ5UGF0aCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZGVsaW1pdGVyKSB7XG5cbiAgICB2YXIga2V5cyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChkZWxpbWl0ZXIgfHwgJy8nKTtcbiAgICB2YXIga2V5O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgICBpZiAoT2JqZWN0KG9iaikgPT09IG9iaiAmJiBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmNvbnN0IGlzR2V0U2FmZSA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgLy8gUHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgLy8gaHR0cHM6Ly9zbnlrLmlvL3Z1bG4vU05ZSy1KUy1KU09OOE1FUkdFUEFUQ0gtMTAzODM5OVxuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Yga2V5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IHNldEJ5UGF0aCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgdmFsdWUsIGRlbGltaXRlcikge1xuXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChkZWxpbWl0ZXIgfHwgJy8nKTtcbiAgICBjb25zdCBsYXN0ID0ga2V5cy5sZW5ndGggLSAxO1xuICAgIGxldCBkaXZlciA9IG9iajtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWlzR2V0U2FmZShkaXZlciwga2V5KSkgcmV0dXJuIG9iajtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkaXZlcltrZXldO1xuICAgICAgICAvLyBkaXZlciBjcmVhdGVzIGFuIGVtcHR5IG9iamVjdCBpZiB0aGVyZSBpcyBubyBuZXN0ZWQgb2JqZWN0IHVuZGVyIHN1Y2ggYSBrZXkuXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBvbmUgY2FuIHBvcHVsYXRlIGFuIGVtcHR5IG5lc3RlZCBvYmplY3Qgd2l0aCBzZXRCeVBhdGgoKS5cbiAgICAgICAgZGl2ZXIgPSB2YWx1ZSB8fCAoZGl2ZXJba2V5XSA9IHt9KTtcbiAgICB9XG5cbiAgICBkaXZlcltrZXlzW2xhc3RdXSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydCBjb25zdCB1bnNldEJ5UGF0aCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZGVsaW1pdGVyKSB7XG5cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KGRlbGltaXRlciB8fCAnLycpO1xuICAgIGNvbnN0IGxhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGRpdmVyID0gb2JqO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghaXNHZXRTYWZlKGRpdmVyLCBrZXkpKSByZXR1cm4gb2JqO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRpdmVyW2tleV07XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiBvYmo7XG4gICAgICAgIGRpdmVyID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZGVsZXRlIGRpdmVyW2tleXNbbGFzdF1dO1xuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBkZWxpbSwgc3RvcCkge1xuXG4gICAgZGVsaW0gPSBkZWxpbSB8fCAnLyc7XG4gICAgdmFyIHJldCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXG4gICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBzaG91bGRHb0RlZXBlciA9IHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCc7XG4gICAgICAgIGlmIChzaG91bGRHb0RlZXBlciAmJiBzdG9wICYmIHN0b3Aob2JqW2tleV0pKSB7XG4gICAgICAgICAgICBzaG91bGRHb0RlZXBlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEdvRGVlcGVyKSB7XG5cbiAgICAgICAgICAgIHZhciBmbGF0T2JqZWN0ID0gZmxhdHRlbk9iamVjdChvYmpba2V5XSwgZGVsaW0sIHN0b3ApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBmbGF0S2V5IGluIGZsYXRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZsYXRPYmplY3QuaGFzT3duUHJvcGVydHkoZmxhdEtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJldFtrZXkgKyBkZWxpbSArIGZsYXRLZXldID0gZmxhdE9iamVjdFtmbGF0S2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydCBjb25zdCB1dWlkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBjcmVkaXQ6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9wb3N0cy8yMTE3NTIzL3JldmlzaW9uc1xuXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMDtcbiAgICAgICAgdmFyIHYgPSAoYyA9PT0gJ3gnKSA/IHIgOiAociAmIDB4MyB8IDB4OCk7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn07XG5cbi8vIEdlbmVyYXRlcyBnbG9iYWwgdW5pcXVlIGlkIGFuZCBzdG9yZXMgaXQgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0LCBpZiBwcm92aWRlZC5cbmV4cG9ydCBjb25zdCBndWlkID0gZnVuY3Rpb24ob2JqKSB7XG5cbiAgICBndWlkLmlkID0gZ3VpZC5pZCB8fCAxO1xuXG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAnal8nICsgZ3VpZC5pZCsrO1xuICAgIH1cblxuICAgIG9iai5pZCA9IChvYmouaWQgPT09IHVuZGVmaW5lZCA/ICdqXycgKyBndWlkLmlkKysgOiBvYmouaWQpO1xuICAgIHJldHVybiBvYmouaWQ7XG59O1xuXG5leHBvcnQgY29uc3QgdG9LZWJhYkNhc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW0EtWl0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcblxuICAgIGlmIChldnQubm9ybWFsaXplZCkgcmV0dXJuIGV2dDtcblxuICAgIGNvbnN0IHsgb3JpZ2luYWxFdmVudCwgdGFyZ2V0IH0gPSBldnQ7XG5cbiAgICAvLyBJZiB0aGUgZXZlbnQgaXMgYSB0b3VjaCBldmVudCwgbm9ybWFsaXplIGl0IHRvIGEgbW91c2UgZXZlbnQuXG4gICAgY29uc3QgdG91Y2ggPSBvcmlnaW5hbEV2ZW50ICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBpZiAodG91Y2gpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gdG91Y2gpIHtcbiAgICAgICAgICAgIC8vIGNvcHkgYWxsIHRoZSBwcm9wZXJ0aWVzIGZyb20gdGhlIGZpcnN0IHRvdWNoIHRoYXQgYXJlIG5vdFxuICAgICAgICAgICAgLy8gZGVmaW5lZCBvbiBUb3VjaEV2ZW50IChjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVksIHNjcmVlblgsIHNjcmVlblksIGlkZW50aWZpZXIsIC4uLilcbiAgICAgICAgICAgIGlmIChldnRbcHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBldnRbcHJvcGVydHldID0gdG91Y2hbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElFOiBldnQudGFyZ2V0IGNvdWxkIGJlIHNldCB0byBTVkdFbGVtZW50SW5zdGFuY2UgZm9yIFNWR1VzZUVsZW1lbnRcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHVzZUVsZW1lbnQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gICAgICAgIGlmICh1c2VFbGVtZW50KSBldnQudGFyZ2V0ID0gdXNlRWxlbWVudDtcbiAgICB9XG5cbiAgICBldnQubm9ybWFsaXplZCA9IHRydWU7XG5cbiAgICByZXR1cm4gZXZ0O1xufTtcblxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVdoZWVsID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgLy8gU2FuZSB2YWx1ZXMgZGVyaXZlZCBlbXBpcmljYWxseVxuICAgIGNvbnN0IFBJWEVMX1NURVAgID0gMTA7XG4gICAgY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbiAgICBjb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcblxuICAgIGxldCBzWCA9IDAsIHNZID0gMCwgcFggPSAwLCBwWSA9IDA7XG5cbiAgICAvLyBMZWdhY3lcbiAgICBpZiAoJ2RldGFpbCcgICAgICBpbiBldnQpIHsgc1kgPSBldnQuZGV0YWlsOyB9XG4gICAgaWYgKCd3aGVlbERlbHRhJyAgaW4gZXZ0KSB7IHNZID0gLWV2dC53aGVlbERlbHRhIC8gMTIwOyB9XG4gICAgaWYgKCd3aGVlbERlbHRhWScgaW4gZXZ0KSB7IHNZID0gLWV2dC53aGVlbERlbHRhWSAvIDEyMDsgfVxuICAgIGlmICgnd2hlZWxEZWx0YVgnIGluIGV2dCkgeyBzWCA9IC1ldnQud2hlZWxEZWx0YVggLyAxMjA7IH1cblxuICAgIC8vIHNpZGUgc2Nyb2xsaW5nIG9uIEZGIHdpdGggRE9NTW91c2VTY3JvbGxcbiAgICBpZiAoICdheGlzJyBpbiBldnQgJiYgZXZ0LmF4aXMgPT09IGV2dC5IT1JJWk9OVEFMX0FYSVMgKSB7XG4gICAgICAgIHNYID0gc1k7XG4gICAgICAgIHNZID0gMDtcbiAgICB9XG5cbiAgICBwWCA9ICdkZWx0YVgnIGluIGV2dCA/IGV2dC5kZWx0YVggOiBzWCAqIFBJWEVMX1NURVA7XG4gICAgcFkgPSAnZGVsdGFZJyBpbiBldnQgPyBldnQuZGVsdGFZIDogc1kgKiBQSVhFTF9TVEVQO1xuXG4gICAgaWYgKChwWCB8fCBwWSkgJiYgZXZ0LmRlbHRhTW9kZSkge1xuICAgICAgICBpZiAoZXZ0LmRlbHRhTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICBwWCAqPSBMSU5FX0hFSUdIVDtcbiAgICAgICAgICAgIHBZICo9IExJTkVfSEVJR0hUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcFggKj0gUEFHRV9IRUlHSFQ7XG4gICAgICAgICAgICBwWSAqPSBQQUdFX0hFSUdIVDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hY09TIHN3aXRjaGVzIGRlbHRhWCBhbmQgZGVsdGFZIGF1dG9tYXRpY2FsbHkgd2hlbiBzY3JvbGxpbmcgd2l0aCBzaGlmdCBrZXksIHNvIHRoaXMgaXMgbmVlZGVkIGluIG90aGVyIGNhc2VzXG4gICAgaWYgKGV2dC5kZWx0YVggPT09IDAgJiYgZXZ0LmRlbHRhWSAhPT0gMCAmJiBldnQuc2hpZnRLZXkpIHtcbiAgICAgICAgcFggPSBwWTtcbiAgICAgICAgcFkgPSAwO1xuICAgICAgICBzWCA9IHNZO1xuICAgICAgICBzWSA9IDA7XG4gICAgfVxuXG4gICAgLy8gRmFsbC1iYWNrIGlmIHNwaW4gY2Fubm90IGJlIGRldGVybWluZWRcbiAgICBpZiAocFggJiYgIXNYKSB7IHNYID0gKHBYIDwgMSkgPyAtMSA6IDE7IH1cbiAgICBpZiAocFkgJiYgIXNZKSB7IHNZID0gKHBZIDwgMSkgPyAtMSA6IDE7IH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNwaW5YICA6IHNYLFxuICAgICAgICBzcGluWSAgOiBzWSxcbiAgICAgICAgZGVsdGFYIDogcFgsXG4gICAgICAgIGRlbHRhWSA6IHBZLFxuICAgIH07XG59O1xuXG5leHBvcnQgY29uc3QgY2FwID0gZnVuY3Rpb24odmFsLCBtYXgpIHtcbiAgICByZXR1cm4gdmFsID4gbWF4ID8gbWF4IDogdmFsIDwgLW1heCA/IC1tYXggOiB2YWw7XG59O1xuXG5leHBvcnQgY29uc3QgbmV4dEZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHJhZjtcblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgaWYgKCFyYWYpIHtcblxuICAgICAgICB2YXIgbGFzdFRpbWUgPSAwO1xuXG4gICAgICAgIHJhZiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgICAgICB2YXIgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgICB9LCB0aW1lVG9DYWxsKTtcblxuICAgICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQsIC4uLnJlc3QpIHtcbiAgICAgICAgcmV0dXJuIChjb250ZXh0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICA/IHJhZihjYWxsYmFjay5iaW5kKGNvbnRleHQsIC4uLnJlc3QpKVxuICAgICAgICAgICAgOiByYWYoY2FsbGJhY2spO1xuICAgIH07XG5cbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBjYW5jZWxGcmFtZSA9IChmdW5jdGlvbigpIHtcblxuICAgIHZhciBjYWY7XG4gICAgdmFyIGNsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICBpZiAoY2xpZW50KSB7XG5cbiAgICAgICAgY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubXNDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5vQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgfVxuXG4gICAgY2FmID0gY2FmIHx8IGNsZWFyVGltZW91dDtcblxuICAgIHJldHVybiBjbGllbnQgPyBjYWYuYmluZCh3aW5kb3cpIDogY2FmO1xuXG59KSgpO1xuXG5leHBvcnQgY29uc3QgaXNQZXJjZW50YWdlID0gZnVuY3Rpb24odmFsKSB7XG5cbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKSAmJiB2YWwuc2xpY2UoLTEpID09PSAnJSc7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDc3NOdW1lcmljID0gZnVuY3Rpb24odmFsLCByZXN0cmljdFVuaXRzKSB7XG5cbiAgICBmdW5jdGlvbiBnZXRVbml0KHZhbGlkVW5pdEV4cCkge1xuXG4gICAgICAgIC8vIG9uZSBvciBtb3JlIG51bWJlcnMsIGZvbGxvd2VkIGJ5XG4gICAgICAgIC8vIGFueSBudW1iZXIgb2YgKFxuICAgICAgICAvLyAgYC5gLCBmb2xsb3dlZCBieVxuICAgICAgICAvLyAgb25lIG9yIG1vcmUgbnVtYmVyc1xuICAgICAgICAvLyApLCBmb2xsb3dlZCBieVxuICAgICAgICAvLyBgdmFsaWRVbml0RXhwYCwgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gZW5kIG9mIHN0cmluZ1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoJyg/OlxcXFxkKyg/OlxcXFwuXFxcXGQrKSopKCcgKyB2YWxpZFVuaXRFeHAgKyAnKSQnKS5leGVjKHZhbCk7XG5cbiAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgfVxuXG4gICAgdmFyIG51bWJlciA9IHBhcnNlRmxvYXQodmFsKTtcblxuICAgIC8vIGlmIGB2YWxgIGNhbm5vdCBiZSBwYXJzZWQgYXMgYSBudW1iZXIsIHJldHVybiBgbnVsbGBcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG51bWJlcikpIHJldHVybiBudWxsO1xuXG4gICAgLy8gZWxzZTogd2Uga25vdyBgb3V0cHV0LnZhbHVlYFxuICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICBvdXRwdXQudmFsdWUgPSBudW1iZXI7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIHVuaXRcbiAgICB2YXIgdmFsaWRVbml0RXhwO1xuICAgIGlmIChyZXN0cmljdFVuaXRzID09IG51bGwpIHtcbiAgICAgICAgLy8gbm8gcmVzdHJpY3Rpb25cbiAgICAgICAgLy8gYWNjZXB0IGFueSB1bml0LCBhcyB3ZWxsIGFzIG5vIHVuaXRcbiAgICAgICAgdmFsaWRVbml0RXhwID0gJ1tBLVphLXpdKic7XG5cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdHJpY3RVbml0cykpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBlbXB0eSBhcnJheSwgdG9wIHJlc3RyaWN0aW9uIC0gcmV0dXJuIGBudWxsYFxuICAgICAgICBpZiAocmVzdHJpY3RVbml0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIC8vIGVsc2U6IHJlc3RyaWN0aW9uIC0gYW4gYXJyYXkgb2YgdmFsaWQgdW5pdCBzdHJpbmdzXG4gICAgICAgIHZhbGlkVW5pdEV4cCA9IHJlc3RyaWN0VW5pdHMuam9pbignfCcpO1xuXG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhyZXN0cmljdFVuaXRzKSkge1xuICAgICAgICAvLyByZXN0cmljdGlvbiAtIGEgc2luZ2xlIHZhbGlkIHVuaXQgc3RyaW5nXG4gICAgICAgIHZhbGlkVW5pdEV4cCA9IHJlc3RyaWN0VW5pdHM7XG4gICAgfVxuICAgIHZhciB1bml0ID0gZ2V0VW5pdCh2YWxpZFVuaXRFeHApO1xuXG4gICAgLy8gaWYgd2UgZm91bmQgbm8gbWF0Y2hlcyBmb3IgYHJlc3RyaWN0VW5pdHNgLCByZXR1cm4gYG51bGxgXG4gICAgaWYgKHVuaXQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgLy8gZWxzZTogd2Uga25vdyB0aGUgdW5pdFxuICAgIG91dHB1dC51bml0ID0gdW5pdDtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgTk9fU1BBQ0UgPSAwO1xuXG5mdW5jdGlvbiBzcGxpdFdvcmRXaXRoRU9MKHdvcmQsIGVvbCkge1xuICAgIGNvbnN0IGVvbFdvcmRzID0gd29yZC5zcGxpdChlb2wpO1xuICAgIGxldCBuID0gMTtcbiAgICBmb3IgKGxldCBqID0gMCwgamwgPSBlb2xXb3Jkcy5sZW5ndGggLSAxOyBqIDwgamw7IGorKykge1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IFtdO1xuICAgICAgICBpZiAoaiA+IDAgfHwgZW9sV29yZHNbMF0gIT09ICcnKSByZXBsYWNlbWVudC5wdXNoKE5PX1NQQUNFKTtcbiAgICAgICAgcmVwbGFjZW1lbnQucHVzaChlb2wpO1xuICAgICAgICBpZiAoaiA8IGpsIC0gMSB8fCBlb2xXb3Jkc1tqbF0gIT09ICcnKSByZXBsYWNlbWVudC5wdXNoKE5PX1NQQUNFKTtcbiAgICAgICAgZW9sV29yZHMuc3BsaWNlKG4sIDAsIC4uLnJlcGxhY2VtZW50KTtcbiAgICAgICAgbiArPSByZXBsYWNlbWVudC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICByZXR1cm4gZW9sV29yZHMuZmlsdGVyKHdvcmQgPT4gd29yZCAhPT0gJycpO1xufVxuXG5cbmZ1bmN0aW9uIGdldExpbmVIZWlnaHQoaGVpZ2h0VmFsdWUsIHRleHRFbGVtZW50KSB7XG4gICAgaWYgKGhlaWdodFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIC8vIERlZmF1bHQgMWVtIGxpbmVIZWlnaHRcbiAgICAgICAgcmV0dXJuIHRleHRFbGVtZW50LmdldEJCb3goKS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgc3dpdGNoIChoZWlnaHRWYWx1ZS51bml0KSB7XG4gICAgICAgIGNhc2UgJ2VtJzpcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RWxlbWVudC5nZXRCQm94KCkuaGVpZ2h0ICogaGVpZ2h0VmFsdWUudmFsdWU7XG4gICAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgIHJldHVybiBoZWlnaHRWYWx1ZS52YWx1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBicmVha1RleHQgPSBmdW5jdGlvbih0ZXh0LCBzaXplLCBzdHlsZXMgPSB7fSwgb3B0ID0ge30pIHtcblxuICAgIHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgdmFyIHN2Z0RvY3VtZW50ID0gb3B0LnN2Z0RvY3VtZW50IHx8IFYoJ3N2ZycpLm5vZGU7XG4gICAgdmFyIHRleHRTcGFuID0gVigndHNwYW4nKS5ub2RlO1xuICAgIHZhciB0ZXh0RWxlbWVudCA9IFYoJ3RleHQnKS5hdHRyKHN0eWxlcykuYXBwZW5kKHRleHRTcGFuKS5ub2RlO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblxuICAgIC8vIFByZXZlbnQgZmxpY2tlcmluZ1xuICAgIHRleHRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIC8vIFByZXZlbnQgRkYgZnJvbSB0aHJvd2luZyBhbiB1bmNhdWdodCBleGNlcHRpb24gd2hlbiBgZ2V0QkJveCgpYFxuICAgIC8vIGNhbGxlZCBvbiBlbGVtZW50IHRoYXQgaXMgbm90IGluIHRoZSByZW5kZXIgdHJlZSAoaXMgbm90IG1lYXN1cmFibGUpLlxuICAgIC8vIDx0c3Bhbj4uZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgcmV0dXJucyBhbHdheXMgMCBpbiB0aGlzIGNhc2UuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBgdGV4dEVsZW1lbnRgIHJlc3AuIGB0ZXh0U3BhbmAgY2FuIGJlY29tZSBoaWRkZW5cbiAgICAvLyB3aGVuIGl0J3MgYXBwZW5kZWQgdG8gdGhlIERPTSBhbmQgYSBgZGlzcGxheTogbm9uZWAgQ1NTIHN0eWxlc2hlZXRcbiAgICAvLyBydWxlIGdldHMgYXBwbGllZC5cbiAgICB0ZXh0RWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0ZXh0U3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRleHRTcGFuLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICBzdmdEb2N1bWVudC5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudCk7IC8vIGxndG0gW2pzL3hzcy10aHJvdWdoLWRvbV1cblxuICAgIGlmICghb3B0LnN2Z0RvY3VtZW50KSB7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmdEb2N1bWVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlc2VydmVTcGFjZXMgPSBvcHQucHJlc2VydmVTcGFjZXM7XG4gICAgY29uc3Qgc3BhY2UgPSAnICc7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gKG9wdC5zZXBhcmF0b3IgfHwgb3B0LnNlcGFyYXRvciA9PT0gJycpID8gb3B0LnNlcGFyYXRvciA6IHNwYWNlO1xuICAgIC8vIElmIHNlcGFyYXRvciBpcyBhIFJlZ0V4cCwgd2UgdXNlIHRoZSBzcGFjZSBjaGFyYWN0ZXIgdG8gam9pbiB3b3JkcyB0b2dldGhlciBhZ2FpbiAobm90IGlkZWFsKVxuICAgIGNvbnN0IHNlcGFyYXRvckNoYXIgPSAodHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycpID8gc2VwYXJhdG9yIDogc3BhY2U7XG4gICAgdmFyIGVvbCA9IG9wdC5lb2wgfHwgJ1xcbic7XG4gICAgdmFyIGh5cGhlbiA9IG9wdC5oeXBoZW4gPyBuZXcgUmVnRXhwKG9wdC5oeXBoZW4pIDogL1teXFx3XFxkXFx1MDBDMC1cXHUxRkZGXFx1MjgwMC1cXHVGRkZEXS87XG4gICAgdmFyIG1heExpbmVDb3VudCA9IG9wdC5tYXhMaW5lQ291bnQ7XG4gICAgaWYgKCFpc051bWJlcihtYXhMaW5lQ291bnQpKSBtYXhMaW5lQ291bnQgPSBJbmZpbml0eTtcblxuICAgIHZhciB3b3JkcyA9IHRleHQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICB2YXIgZnVsbCA9IFtdO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBwLCBoO1xuICAgIHZhciBsaW5lSGVpZ2h0O1xuXG4gICAgaWYgKHByZXNlcnZlU3BhY2VzKSB7XG4gICAgICAgIFYodGV4dFNwYW4pLmF0dHIoJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gMCwgbGVuID0gd29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICB2YXIgd29yZCA9IHdvcmRzW2ldO1xuXG4gICAgICAgIGlmICghd29yZCAmJiAhcHJlc2VydmVTcGFjZXMpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodHlwZW9mIHdvcmQgIT09ICdzdHJpbmcnKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaXNFb2wgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVvbCAmJiB3b3JkLmluZGV4T2YoZW9sKSA+PSAwKSB7XG4gICAgICAgICAgICAvLyB3b3JkIGNvbnRhaW5zIGVuZC1vZi1saW5lIGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKHdvcmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlIHdvcmQgYW5kIGNvbnRpbnVlIGN5Y2xlXG4gICAgICAgICAgICAgICAgY29uc3QgZW9sV29yZHMgPSBzcGxpdFdvcmRXaXRoRU9MKHdvcmRzW2ldLCBlb2wpO1xuICAgICAgICAgICAgICAgIHdvcmRzLnNwbGljZShpLCAxLCAuLi5lb2xXb3Jkcyk7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGxlbiA9IHdvcmRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlcyBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlU3BhY2VzICYmIHR5cGVvZiB3b3Jkc1tpIC0gMV0gPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSwgTk9fU1BBQ0UsICcnLCBOT19TUEFDRSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbiArPSAyO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lc1srK2xdID0gKCFwcmVzZXJ2ZVNwYWNlcyB8fCB0eXBlb2Ygd29yZHNbaSArIDFdID09PSAnc3RyaW5nJykgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpc0VvbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRW9sKSB7XG5cbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlU3BhY2VzKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxpbmVzW2xdICE9PSB1bmRlZmluZWQgPyBsaW5lc1tsXSArIHNlcGFyYXRvckNoYXIgKyB3b3JkIDogd29yZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxpbmVzW2xdID8gbGluZXNbbF0gKyBzZXBhcmF0b3JDaGFyICsgd29yZCA6IHdvcmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHROb2RlLmRhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICBpZiAodGV4dFNwYW4uZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgPD0gd2lkdGgpIHtcblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGxpbmUgZml0c1xuICAgICAgICAgICAgICAgIGxpbmVzW2xdID0gZGF0YTtcblxuICAgICAgICAgICAgICAgIGlmIChwIHx8IGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSBwYXJ0aXRpb25pbmcuIFB1dCByZXN0IG9mIHRoZSB3b3JkIG9udG8gbmV4dCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxbbCsrXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsIHBhcnRpdGlvbmluZyBhbmQgc3BsaXR0aW5nIGJ5IGh5cGhlbnNcbiAgICAgICAgICAgICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGggPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmICghbGluZXNbbF0gfHwgcCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0aXRpb24gPSAhIXA7XG5cbiAgICAgICAgICAgICAgICAgICAgcCA9IHdvcmQubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydGl0aW9uIHx8ICFwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmQgaGFzIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaW5lc1tsXSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdvbid0IGZpdCB0aGlzIHRleHQgd2l0aGluIG91ciByZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFydGl0aW9uaW5nIGRpZG4ndCBoZWxwIG9uIHRoZSBub24tZW1wdHkgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSBhZ2FpbiwgYnV0IHRoaXMgdGltZSBzdGFydCB3aXRoIGEgbmV3IGxpbmVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBwYXJ0aXRpb25zIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSwgMiwgd29yZCArIHdvcmRzW2kgKyAxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3Qgd29yZCBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4tLTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxbbCsrXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgbGFzdCBsZXR0ZXIgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpXSA9IHdvcmQuc3Vic3RyaW5nKDAsIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFdvcmQgPSB3b3Jkc1tpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpICsgMV0gPSB3b3JkLnN1YnN0cmluZyhwKSArIChuZXh0V29yZCA9PT0gdW5kZWZpbmVkIHx8IG5leHRXb3JkID09PSBOT19TUEFDRSA/ICcnIDogbmV4dFdvcmQpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWwgc3BsaXR0aW5nIGFuZCBwdXQgdGhlIHdvcmRzIHRvZ2V0aGVyIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGksIDIsIHdvcmRzW2ldICsgd29yZHNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGh5cGhlbkluZGV4ID0gd29yZC5zZWFyY2goaHlwaGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHlwaGVuSW5kZXggPiAtMSAmJiBoeXBoZW5JbmRleCAhPT0gd29yZC5sZW5ndGggLSAxICYmIGh5cGhlbkluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBoeXBoZW5JbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGluaXRpYXRlIHBhcnRpdGlvbmluZyBvciBzcGxpdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB0aGUgbG9uZyB3b3JkIGludG8gdHdvIHdvcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGksIDEsIHdvcmQuc3Vic3RyaW5nKDAsIGggfHwgcCksIHdvcmQuc3Vic3RyaW5nKGh8fCBwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRqdXN0IHdvcmRzIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbisrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsICYmICFmdWxsW2wgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIGxpbmUgaXMgbm90IGZ1bGwsIHRyeSB0byBmaXQgbWF4IHBhcnQgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHdvcmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlcnZlU3BhY2VzIHx8IGxpbmVzW2xdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbCsrO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdEwgPSBudWxsO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiBtYXhMaW5lQ291bnQpIHtcblxuICAgICAgICAgICAgbGFzdEwgPSBtYXhMaW5lQ291bnQgLSAxO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgLy8gaWYgc2l6ZS5oZWlnaHQgaXMgZGVmaW5lZCB3ZSBoYXZlIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGhlaWdodCBvZiB0aGUgZW50aXJlXG4gICAgICAgICAgICAvLyB0ZXh0IGV4Y2VlZHMgdGhlIHJlY3QgaGVpZ2h0XG5cbiAgICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID09PSB1bmRlZmluZWQgJiYgdGV4dE5vZGUuZGF0YSAhPT0gJycpIHtcblxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgc2FtZSBkZWZhdWx0cyBhcyBpbiBWLnByb3RvdHlwZS50ZXh0XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlcy5saW5lSGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQoeyB2YWx1ZTogMS41LCB1bml0OiAnZW0nIH0sIHRleHRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNzc051bWVyaWMoc3R5bGVzLmxpbmVIZWlnaHQsIFsnZW0nLCAncHgnLCAnJ10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBnZXRMaW5lSGVpZ2h0KHBhcnNlZCwgdGV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmVIZWlnaHQgKiBsaW5lcy5sZW5ndGggPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3ZlcmZsb3dpbmcgbGluZXNcbiAgICAgICAgICAgICAgICBsYXN0TCA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gbGluZUhlaWdodCkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RMICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIGxpbmVzLnNwbGljZShsYXN0TCArIDEpO1xuXG4gICAgICAgICAgICAvLyBhZGQgZWxsaXBzaXNcbiAgICAgICAgICAgIHZhciBlbGxpcHNpcyA9IG9wdC5lbGxpcHNpcztcbiAgICAgICAgICAgIGlmICghZWxsaXBzaXMgfHwgbGFzdEwgPCAwKSBicmVhaztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxsaXBzaXMgIT09ICdzdHJpbmcnKSBlbGxpcHNpcyA9ICdcXHUyMDI2JztcblxuICAgICAgICAgICAgdmFyIGxhc3RMaW5lID0gbGluZXNbbGFzdExdO1xuICAgICAgICAgICAgaWYgKCFsYXN0TGluZSAmJiAhaXNFb2wpIGJyZWFrO1xuICAgICAgICAgICAgdmFyIGsgPSBsYXN0TGluZS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbGFzdExpbmVXaXRoT21pc3Npb24sIGxhc3RDaGFyO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxhc3RDaGFyID0gbGFzdExpbmVba107XG4gICAgICAgICAgICAgICAgbGFzdExpbmVXaXRoT21pc3Npb24gPSBsYXN0TGluZS5zdWJzdHJpbmcoMCwgayk7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0Q2hhcikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZVdpdGhPbWlzc2lvbiArPSBzZXBhcmF0b3JDaGFyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFzdENoYXIubWF0Y2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGluZVdpdGhPbWlzc2lvbiArPSBsYXN0Q2hhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdExpbmVXaXRoT21pc3Npb24gKz0gZWxsaXBzaXM7XG4gICAgICAgICAgICAgICAgdGV4dE5vZGUuZGF0YSA9IGxhc3RMaW5lV2l0aE9taXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3Bhbi5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA8PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lc1tsYXN0TF0gPSBsYXN0TGluZVdpdGhPbWlzc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGsgPj0gMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHQuc3ZnRG9jdW1lbnQpIHtcblxuICAgICAgICAvLyBzdmcgZG9jdW1lbnQgd2FzIHByb3ZpZGVkLCByZW1vdmUgdGhlIHRleHQgZWxlbWVudCBvbmx5XG4gICAgICAgIHN2Z0RvY3VtZW50LnJlbW92ZUNoaWxkKHRleHRFbGVtZW50KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gY2xlYW4gc3ZnIGRvY3VtZW50XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc3ZnRG9jdW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKGVvbCk7XG59O1xuXG4vLyBTYW5pdGl6ZSBIVE1MXG4vLyBCYXNlZCBvbiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS91Zm9sb2dpc3QvNWEwZGE1MWIyYjllZjFiODYxYzMwMjU0MTcyYWMzYzlcbi8vIFBhcnNlcyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIERPTSBub2Rlcy5cbi8vIFRoZW4gb3V0cHV0cyBpdCBiYWNrIGFzIGEgc3RyaW5nLlxuZXhwb3J0IGNvbnN0IHNhbml0aXplSFRNTCA9IGZ1bmN0aW9uKGh0bWwpIHtcblxuICAgIC8vIElnbm9yZXMgdGFncyB0aGF0IGFyZSBpbnZhbGlkIGluc2lkZSBhIDxkaXY+IHRhZyAoZS5nLiA8Ym9keT4sIDxoZWFkPilcbiAgICBjb25zdCBbb3V0cHV0RWxdID0gJC5wYXJzZUhUTUwoJzxkaXY+JyArIGh0bWwgKyAnPC9kaXY+Jyk7XG5cbiAgICBBcnJheS5mcm9tKG91dHB1dEVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpLmZvckVhY2goZnVuY3Rpb24obm9kZSkgeyAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICAgIGNvbnN0IG5hbWVzID0gbm9kZS5nZXRBdHRyaWJ1dGVOYW1lcygpO1xuICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYXR0cmlidXRlIG5hbWVzIHRoYXQgc3RhcnQgd2l0aCBcIm9uXCIgKGUuZy4gb25sb2FkLCBvbmVycm9yLi4uKS5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgc3RhcnQgd2l0aCBcImphdmFzY3JpcHQ6XCIgcHNldWRvIHByb3RvY29sIChlLmcuIGBocmVmPVwiamF2YXNjcmlwdDphbGVydCgxKVwiYCkuXG4gICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdvbicpIHx8IHZhbHVlLnN0YXJ0c1dpdGgoJ2phdmFzY3JpcHQ6JyB8fCB2YWx1ZS5zdGFydHNXaXRoKCdkYXRhOicpIHx8IHZhbHVlLnN0YXJ0c1dpdGgoJ3Zic2NyaXB0OicpKSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXRFbC5pbm5lckhUTUw7XG59O1xuXG4vLyBEb3dubG9hZCBgYmxvYmAgYXMgZmlsZSB3aXRoIGBmaWxlTmFtZWAuXG4vLyBEb2VzIG5vdCB3b3JrIGluIElFOS5cbmV4cG9ydCBjb25zdCBkb3dubG9hZEJsb2IgPSBmdW5jdGlvbihibG9iLCBmaWxlTmFtZSkge1xuXG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYikgeyAvLyByZXF1aXJlcyBJRSAxMCtcbiAgICAgICAgLy8gcHVsbHMgdXAgYSBzYXZlIGRpYWxvZ1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgZmlsZU5hbWUpO1xuXG4gICAgfSBlbHNlIHsgLy8gb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgLy8gZG93bmxvYWRzIGRpcmVjdGx5IGluIENocm9tZSBhbmQgU2FmYXJpXG5cbiAgICAgICAgLy8gcHJlc2VudHMgYSBzYXZlL29wZW4gZGlhbG9nIGluIEZpcmVmb3hcbiAgICAgICAgLy8gRmlyZWZveCBidWc6IGBmcm9tYCBmaWVsZCBpbiBzYXZlIGRpYWxvZyBhbHdheXMgc2hvd3MgYGZyb206YmxvYjpgXG4gICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwNTMzMjdcblxuICAgICAgICB2YXIgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuXG4gICAgICAgIGxpbmsuY2xpY2soKTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpOyAvLyBtYXJrIHRoZSB1cmwgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cbn07XG5cbi8vIERvd25sb2FkIGBkYXRhVXJpYCBhcyBmaWxlIHdpdGggYGZpbGVOYW1lYC5cbi8vIERvZXMgbm90IHdvcmsgaW4gSUU5LlxuZXhwb3J0IGNvbnN0IGRvd25sb2FkRGF0YVVyaSA9IGZ1bmN0aW9uKGRhdGFVcmksIGZpbGVOYW1lKSB7XG5cbiAgICBjb25zdCBibG9iID0gZGF0YVVyaVRvQmxvYihkYXRhVXJpKTtcbiAgICBkb3dubG9hZEJsb2IoYmxvYiwgZmlsZU5hbWUpO1xufTtcblxuLy8gQ29udmVydCBhbiB1cmktZW5jb2RlZCBkYXRhIGNvbXBvbmVudCAocG9zc2libHkgYWxzbyBiYXNlNjQtZW5jb2RlZCkgdG8gYSBibG9iLlxuZXhwb3J0IGNvbnN0IGRhdGFVcmlUb0Jsb2IgPSBmdW5jdGlvbihkYXRhVXJpKSB7XG5cbiAgICAvLyBmaXJzdCwgbWFrZSBzdXJlIHRoZXJlIGFyZSBubyBuZXdsaW5lcyBpbiB0aGUgZGF0YSB1cmlcbiAgICBkYXRhVXJpID0gZGF0YVVyaS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGRhdGFVcmkgPSBkZWNvZGVVUklDb21wb25lbnQoZGF0YVVyaSk7XG5cbiAgICB2YXIgZmlyc3RDb21tYUluZGV4ID0gZGF0YVVyaS5pbmRleE9mKCcsJyk7IC8vIHNwbGl0IGRhdGFVcmkgYXMgYGRhdGFUeXBlU3RyaW5nYCxgZGF0YWBcblxuICAgIHZhciBkYXRhVHlwZVN0cmluZyA9IGRhdGFVcmkuc2xpY2UoMCwgZmlyc3RDb21tYUluZGV4KTsgLy8gZS5nLiAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCdcbiAgICB2YXIgbWltZVN0cmluZyA9IGRhdGFUeXBlU3RyaW5nLnNwbGl0KCc6JylbMV0uc3BsaXQoJzsnKVswXTsgLy8gZS5nLiAnaW1hZ2UvanBlZydcblxuICAgIHZhciBkYXRhID0gZGF0YVVyaS5zbGljZShmaXJzdENvbW1hSW5kZXggKyAxKTtcbiAgICB2YXIgZGVjb2RlZFN0cmluZztcbiAgICBpZiAoZGF0YVR5cGVTdHJpbmcuaW5kZXhPZignYmFzZTY0JykgPj0gMCkgeyAvLyBkYXRhIG1heSBiZSBlbmNvZGVkIGluIGJhc2U2NFxuICAgICAgICBkZWNvZGVkU3RyaW5nID0gYXRvYihkYXRhKTsgLy8gZGVjb2RlIGRhdGFcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBkZWNvZGVkIHN0cmluZyB0byBVVEYtOFxuICAgICAgICBkZWNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdGhlIGJ5dGVzIG9mIHRoZSBzdHJpbmcgdG8gYSB0eXBlZCBhcnJheVxuICAgIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGRlY29kZWRTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kZWRTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWFbaV0gPSBkZWNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtpYV0sIHsgdHlwZTogbWltZVN0cmluZyB9KTsgLy8gcmV0dXJuIHRoZSB0eXBlZCBhcnJheSBhcyBCbG9iXG59O1xuXG4vLyBSZWFkIGFuIGltYWdlIGF0IGB1cmxgIGFuZCByZXR1cm4gaXQgYXMgYmFzZTY0LWVuY29kZWQgZGF0YSB1cmkuXG4vLyBUaGUgbWltZSB0eXBlIG9mIHRoZSBpbWFnZSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBgdXJsYCBmaWxlIGV4dGVuc2lvbi5cbi8vIElmIGRhdGEgdXJpIGlzIHByb3ZpZGVkIGFzIGB1cmxgLCBpdCBpcyByZXR1cm5lZCBiYWNrIHVuY2hhbmdlZC5cbi8vIGBjYWxsYmFja2AgaXMgYSBtZXRob2Qgd2l0aCBgZXJyYCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgYGRhdGFVcmlgIGFzIHNlY29uZCBhcmd1bWVudC5cbi8vIFdvcmtzIHdpdGggSUU5LlxuZXhwb3J0IGNvbnN0IGltYWdlVG9EYXRhVXJpID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCF1cmwgfHwgdXJsLnN1YnN0cigwLCAnZGF0YTonLmxlbmd0aCkgPT09ICdkYXRhOicpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjb252ZXJ0IHRvIGRhdGEgdXJpIGlmIGl0IGlzIGFscmVhZHkgaW4gZGF0YSB1cmkuXG5cbiAgICAgICAgLy8gVGhpcyBub3Qgb25seSBjb252ZW5pZW50IGJ1dCBkZXNpcmVkLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gSUUgdGhyb3dzIGEgc2VjdXJpdHkgZXJyb3IgaWYgZGF0YTppbWFnZS9zdmcreG1sIGlzIHVzZWQgdG8gcmVuZGVyXG4gICAgICAgIC8vIGFuIGltYWdlIHRvIHRoZSBjYW52YXMgYW5kIGFuIGF0dGVtcHQgaXMgbWFkZSB0byByZWFkIG91dCBkYXRhIHVyaS5cbiAgICAgICAgLy8gTm93IGlmIG91ciBpbWFnZSBpcyBhbHJlYWR5IGluIGRhdGEgdXJpLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJlbmRlciBpdCB0byB0aGUgY2FudmFzXG4gICAgICAgIC8vIGFuZCBzbyB3ZSBjYW4gYnlwYXNzIHRoaXMgZXJyb3IuXG5cbiAgICAgICAgLy8gS2VlcCB0aGUgYXN5bmMgbmF0dXJlIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB1cmwpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvLyBjaHJvbWUsIElFMTArXG4gICAgdmFyIG1vZGVybkhhbmRsZXIgPSBmdW5jdGlvbih4aHIsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuXG4gICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhVXJpID0gZXZ0LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YVVyaSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgJyArIHVybCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgJyArIHVybCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsZWdhY3lIYW5kbGVyID0gZnVuY3Rpb24oeGhyLCBjYWxsYmFjaykge1xuXG4gICAgICAgIHZhciBVaW50OFRvU3RyaW5nID0gZnVuY3Rpb24odThhKSB7XG4gICAgICAgICAgICB2YXIgQ0hVTktfU1ogPSAweDgwMDA7XG4gICAgICAgICAgICB2YXIgYyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1OGEubGVuZ3RoOyBpICs9IENIVU5LX1NaKSB7XG4gICAgICAgICAgICAgICAgYy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdThhLnN1YmFycmF5KGksIGkgKyBDSFVOS19TWikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjLmpvaW4oJycpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcblxuICAgICAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcblxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9ICh1cmwuc3BsaXQoJy4nKS5wb3AoKSkgfHwgJ3BuZyc7XG4gICAgICAgICAgICB2YXIgbWFwID0ge1xuICAgICAgICAgICAgICAgICdzdmcnOiAnc3ZnK3htbCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbWV0YSA9ICdkYXRhOmltYWdlLycgKyAobWFwW3N1ZmZpeF0gfHwgc3VmZml4KSArICc7YmFzZTY0LCc7XG4gICAgICAgICAgICB2YXIgYjY0ZW5jb2RlZCA9IG1ldGEgKyBidG9hKFVpbnQ4VG9TdHJpbmcoYnl0ZXMpKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGI2NGVuY29kZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSAnICsgdXJsKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgaW1hZ2UgJyArIHVybCkpO1xuICAgIH0pO1xuXG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHdpbmRvdy5GaWxlUmVhZGVyID8gJ2Jsb2InIDogJ2FycmF5YnVmZmVyJztcblxuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3cuRmlsZVJlYWRlcikge1xuICAgICAgICAgICAgbW9kZXJuSGFuZGxlcih4aHIsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2FjeUhhbmRsZXIoeGhyLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHhoci5zZW5kKCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RWxlbWVudEJCb3ggPSBmdW5jdGlvbihlbCkge1xuXG4gICAgdmFyICRlbCA9ICQoZWwpO1xuICAgIGlmICgkZWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9ICRlbFswXTtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgIHZhciBjbGllbnRCQm94ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciBzdHJva2VXaWR0aFggPSAwO1xuICAgIHZhciBzdHJva2VXaWR0aFkgPSAwO1xuXG4gICAgLy8gRmlyZWZveCBjb3JyZWN0aW9uXG4gICAgaWYgKGVsZW1lbnQub3duZXJTVkdFbGVtZW50KSB7XG5cbiAgICAgICAgdmFyIHZlbCA9IFYoZWxlbWVudCk7XG4gICAgICAgIHZhciBiYm94ID0gdmVsLmdldEJCb3goeyB0YXJnZXQ6IHZlbC5zdmcoKSB9KTtcblxuICAgICAgICAvLyBpZiBGRiBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaW5jbHVkZXMgc3Ryb2tlLXdpZHRoLCBnZXRCQm94IGRvZXNuJ3QuXG4gICAgICAgIC8vIFRvIHVuaWZ5IHRoaXMgYWNyb3NzIGFsbCBicm93c2VycyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgZmluYWwgYkJveCB3aXRoIGBzdHJva2Utd2lkdGhgIHZhbHVlLlxuICAgICAgICBzdHJva2VXaWR0aFggPSAoY2xpZW50QkJveC53aWR0aCAtIGJib3gud2lkdGgpO1xuICAgICAgICBzdHJva2VXaWR0aFkgPSAoY2xpZW50QkJveC5oZWlnaHQgLSBiYm94LmhlaWdodCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2xpZW50QkJveC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0IC0gZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRMZWZ0ICsgc3Ryb2tlV2lkdGhYIC8gMixcbiAgICAgICAgeTogY2xpZW50QkJveC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQgLSBkb2MuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFRvcCArIHN0cm9rZVdpZHRoWSAvIDIsXG4gICAgICAgIHdpZHRoOiBjbGllbnRCQm94LndpZHRoIC0gc3Ryb2tlV2lkdGhYLFxuICAgICAgICBoZWlnaHQ6IGNsaWVudEJCb3guaGVpZ2h0IC0gc3Ryb2tlV2lkdGhZXG4gICAgfTtcbn07XG5cblxuLy8gSGlnaGx5IGluc3BpcmVkIGJ5IHRoZSBqcXVlcnkuc29ydEVsZW1lbnRzIHBsdWdpbiBieSBQYWRvbHNleS5cbi8vIFNlZSBodHRwOi8vamFtZXMucGFkb2xzZXkuY29tL2phdmFzY3JpcHQvc29ydGluZy1lbGVtZW50cy13aXRoLWpxdWVyeS8uXG5leHBvcnQgY29uc3Qgc29ydEVsZW1lbnRzID0gZnVuY3Rpb24oZWxlbWVudHMsIGNvbXBhcmF0b3IpIHtcblxuICAgIGVsZW1lbnRzID0gJChlbGVtZW50cykudG9BcnJheSgpO1xuICAgIHZhciBwbGFjZW1lbnRzID0gZWxlbWVudHMubWFwKGZ1bmN0aW9uKHNvcnRFbGVtZW50KSB7XG5cbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBzb3J0RWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAvLyBTaW5jZSB0aGUgZWxlbWVudCBpdHNlbGYgd2lsbCBjaGFuZ2UgcG9zaXRpb24sIHdlIGhhdmVcbiAgICAgICAgLy8gdG8gaGF2ZSBzb21lIHdheSBvZiBzdG9yaW5nIGl0J3Mgb3JpZ2luYWwgcG9zaXRpb24gaW5cbiAgICAgICAgLy8gdGhlIERPTS4gVGhlIGVhc2llc3Qgd2F5IGlzIHRvIGhhdmUgYSAnZmxhZycgbm9kZTpcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpLCBzb3J0RWxlbWVudC5uZXh0U2libGluZyk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhblxcJ3Qgc29ydCBlbGVtZW50cyBpZiBhbnkgb25lIGlzIGEgZGVzY2VuZGFudCBvZiBhbm90aGVyLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnNlcnQgYmVmb3JlIGZsYWc6XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZmxhZzpcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV4dFNpYmxpbmcpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZWxlbWVudHMuc29ydChjb21wYXJhdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGxhY2VtZW50c1tpXS5jYWxsKGVsZW1lbnRzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufTtcblxuLy8gU2V0cyBhdHRyaWJ1dGVzIG9uIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZGVzY2VuZGFudHMgYmFzZWQgb24gdGhlIHNlbGVjdG9yLlxuLy8gYGF0dHJzYCBvYmplY3Q6IHsgW1NFTEVDVE9SMV06IHsgYXR0cnMxIH0sIFtTRUxFQ1RPUjJdOiB7IGF0dHJzMn0sIC4uLiB9IGUuZy4geyAnaW5wdXQnOiB7IGNvbG9yIDogJ3JlZCcgfX1cbmV4cG9ydCBjb25zdCBzZXRBdHRyaWJ1dGVzQnlTZWxlY3RvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG5cbiAgICB2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXG4gICAgZm9ySW4oYXR0cnMsIGZ1bmN0aW9uKGF0dHJzLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgJGVsZW1lbnRzID0gJGVsZW1lbnQuZmluZChzZWxlY3RvcikuYWRkQmFjaygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICAgIC8vIE1ha2UgYSBzcGVjaWFsIGNhc2UgZm9yIHNldHRpbmcgY2xhc3Nlcy5cbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gb3ZlcndyaXRlIGFueSBleGlzdGluZyBjbGFzcy5cbiAgICAgICAgaWYgKGhhcyhhdHRycywgJ2NsYXNzJykpIHtcbiAgICAgICAgICAgICRlbGVtZW50cy5hZGRDbGFzcyhhdHRyc1snY2xhc3MnXSk7XG4gICAgICAgICAgICBhdHRycyA9IG9taXQoYXR0cnMsICdjbGFzcycpO1xuICAgICAgICB9XG4gICAgICAgICRlbGVtZW50cy5hdHRyKGF0dHJzKTtcbiAgICB9KTtcbn07XG5cbi8vIFJldHVybiBhIG5ldyBvYmplY3Qgd2l0aCBhbGwgZm91ciBzaWRlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KSBpbiBpdC5cbi8vIFZhbHVlIG9mIGVhY2ggc2lkZSBpcyB0YWtlbiBmcm9tIHRoZSBnaXZlbiBhcmd1bWVudCAoZWl0aGVyIG51bWJlciBvciBvYmplY3QpLlxuLy8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBzaWRlIGlzIDAuXG4vLyBFeGFtcGxlczpcbi8vIG5vcm1hbGl6ZVNpZGVzKDUpIC0tPiB7IHRvcDogNSwgcmlnaHQ6IDUsIGJvdHRvbTogNSwgbGVmdDogNSB9XG4vLyBub3JtYWxpemVTaWRlcyh7IGhvcml6b250YWw6IDUgfSkgLS0+IHsgdG9wOiAwLCByaWdodDogNSwgYm90dG9tOiAwLCBsZWZ0OiA1IH1cbi8vIG5vcm1hbGl6ZVNpZGVzKHsgbGVmdDogNSB9KSAtLT4geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDUgfVxuLy8gbm9ybWFsaXplU2lkZXMoeyBob3Jpem9udGFsOiAxMCwgbGVmdDogNSB9KSAtLT4geyB0b3A6IDAsIHJpZ2h0OiAxMCwgYm90dG9tOiAwLCBsZWZ0OiA1IH1cbi8vIG5vcm1hbGl6ZVNpZGVzKHsgaG9yaXpvbnRhbDogMCwgbGVmdDogNSB9KSAtLT4geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDUgfVxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVNpZGVzID0gZnVuY3Rpb24oYm94KSB7XG5cbiAgICBpZiAoT2JqZWN0KGJveCkgIT09IGJveCkgeyAvLyBgYm94YCBpcyBub3QgYW4gb2JqZWN0XG4gICAgICAgIHZhciB2YWwgPSAwOyAvLyBgdmFsYCBsZWZ0IGFzIDAgaWYgYGJveGAgY2Fubm90IGJlIHVuZGVyc3Rvb2QgYXMgZmluaXRlIG51bWJlclxuICAgICAgICBpZiAoaXNGaW5pdGUoYm94KSkgdmFsID0gK2JveDsgLy8gYWN0dWFsbHkgYWxzbyBhY2NlcHRzIHN0cmluZyBudW1iZXJzIChlLmcuICcxMDAnKVxuXG4gICAgICAgIHJldHVybiB7IHRvcDogdmFsLCByaWdodDogdmFsLCBib3R0b206IHZhbCwgbGVmdDogdmFsIH07XG4gICAgfVxuXG4gICAgLy8gYGJveGAgaXMgYW4gb2JqZWN0XG4gICAgdmFyIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdDtcbiAgICB0b3AgPSByaWdodCA9IGJvdHRvbSA9IGxlZnQgPSAwO1xuXG4gICAgaWYgKGlzRmluaXRlKGJveC52ZXJ0aWNhbCkpIHRvcCA9IGJvdHRvbSA9ICtib3gudmVydGljYWw7XG4gICAgaWYgKGlzRmluaXRlKGJveC5ob3Jpem9udGFsKSkgcmlnaHQgPSBsZWZ0ID0gK2JveC5ob3Jpem9udGFsO1xuXG4gICAgaWYgKGlzRmluaXRlKGJveC50b3ApKSB0b3AgPSArYm94LnRvcDsgLy8gb3ZlcndyaXRlIHZlcnRpY2FsXG4gICAgaWYgKGlzRmluaXRlKGJveC5yaWdodCkpIHJpZ2h0ID0gK2JveC5yaWdodDsgLy8gb3ZlcndyaXRlIGhvcml6b250YWxcbiAgICBpZiAoaXNGaW5pdGUoYm94LmJvdHRvbSkpIGJvdHRvbSA9ICtib3guYm90dG9tOyAvLyBvdmVyd3JpdGUgdmVydGljYWxcbiAgICBpZiAoaXNGaW5pdGUoYm94LmxlZnQpKSBsZWZ0ID0gK2JveC5sZWZ0OyAvLyBvdmVyd3JpdGUgaG9yaXpvbnRhbFxuXG4gICAgcmV0dXJuIHsgdG9wOiB0b3AsIHJpZ2h0OiByaWdodCwgYm90dG9tOiBib3R0b20sIGxlZnQ6IGxlZnQgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB0aW1pbmcgPSB7XG5cbiAgICBsaW5lYXI6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcblxuICAgIHF1YWQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQgKiB0O1xuICAgIH0sXG5cbiAgICBjdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCAqIHQgKiB0O1xuICAgIH0sXG5cbiAgICBpbm91dDogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgICAgIHZhciB0MiA9IHQgKiB0O1xuICAgICAgICB2YXIgdDMgPSB0MiAqIHQ7XG4gICAgICAgIHJldHVybiA0ICogKHQgPCAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAuNzUpO1xuICAgIH0sXG5cbiAgICBleHBvbmVudGlhbDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgICB9LFxuXG4gICAgYm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIGEgPSAwLCBiID0gMTsgMTsgYSArPSBiLCBiIC89IDIpIHtcbiAgICAgICAgICAgIGlmICh0ID49ICg3IC0gNCAqIGEpIC8gMTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9ICgxMSAtIDYgKiBhIC0gMTEgKiB0KSAvIDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1xICogcSArIGIgKiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gZigxIC0gdCk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlZmxlY3Q6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHJldHVybiAuNSAqICh0IDwgLjUgPyBmKDIgKiB0KSA6ICgyIC0gZigyIC0gMiAqIHQpKSk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNsYW1wOiBmdW5jdGlvbihmLCBuLCB4KSB7XG4gICAgICAgIG4gPSBuIHx8IDA7XG4gICAgICAgIHggPSB4IHx8IDE7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB2YXIgciA9IGYodCk7XG4gICAgICAgICAgICByZXR1cm4gciA8IG4gPyBuIDogciA+IHggPyB4IDogcjtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYmFjazogZnVuY3Rpb24ocykge1xuICAgICAgICBpZiAoIXMpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGVsYXN0aWM6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKCF4KSB4ID0gMS41O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSkgKiBNYXRoLmNvcygyMCAqIE1hdGguUEkgKiB4IC8gMyAqIHQpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbnRlcnBvbGF0ZSA9IHtcblxuICAgIG51bWJlcjogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB2YXIgZCA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIGEgKyBkICogdDtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb2JqZWN0OiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHZhciBzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICB2YXIgaSwgcDtcbiAgICAgICAgICAgIHZhciByID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSBzLmxlbmd0aCAtIDE7IGkgIT0gLTE7IGktLSkge1xuICAgICAgICAgICAgICAgIHAgPSBzW2ldO1xuICAgICAgICAgICAgICAgIHJbcF0gPSBhW3BdICsgKGJbcF0gLSBhW3BdKSAqIHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgaGV4Q29sb3I6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgICB2YXIgY2EgPSBwYXJzZUludChhLnNsaWNlKDEpLCAxNik7XG4gICAgICAgIHZhciBjYiA9IHBhcnNlSW50KGIuc2xpY2UoMSksIDE2KTtcbiAgICAgICAgdmFyIHJhID0gY2EgJiAweDAwMDBmZjtcbiAgICAgICAgdmFyIHJkID0gKGNiICYgMHgwMDAwZmYpIC0gcmE7XG4gICAgICAgIHZhciBnYSA9IGNhICYgMHgwMGZmMDA7XG4gICAgICAgIHZhciBnZCA9IChjYiAmIDB4MDBmZjAwKSAtIGdhO1xuICAgICAgICB2YXIgYmEgPSBjYSAmIDB4ZmYwMDAwO1xuICAgICAgICB2YXIgYmQgPSAoY2IgJiAweGZmMDAwMCkgLSBiYTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuXG4gICAgICAgICAgICB2YXIgciA9IChyYSArIHJkICogdCkgJiAweDAwMDAwMGZmO1xuICAgICAgICAgICAgdmFyIGcgPSAoZ2EgKyBnZCAqIHQpICYgMHgwMDAwZmYwMDtcbiAgICAgICAgICAgIHZhciBiID0gKGJhICsgYmQgKiB0KSAmIDB4MDBmZjAwMDA7XG5cbiAgICAgICAgICAgIHJldHVybiAnIycgKyAoMSA8PCAyNCB8IHIgfCBnIHwgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICB1bml0OiBmdW5jdGlvbihhLCBiKSB7XG5cbiAgICAgICAgdmFyIHIgPSAvKC0/WzAtOV0qLlswLTldKikocHh8ZW18Y218bW18aW58cHR8cGN8JSkvO1xuICAgICAgICB2YXIgbWEgPSByLmV4ZWMoYSk7XG4gICAgICAgIHZhciBtYiA9IHIuZXhlYyhiKTtcbiAgICAgICAgdmFyIHAgPSBtYlsxXS5pbmRleE9mKCcuJyk7XG4gICAgICAgIHZhciBmID0gcCA+IDAgPyBtYlsxXS5sZW5ndGggLSBwIC0gMSA6IDA7XG4gICAgICAgIGEgPSArbWFbMV07XG4gICAgICAgIHZhciBkID0gK21iWzFdIC0gYTtcbiAgICAgICAgdmFyIHUgPSBtYVsyXTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIChhICsgZCAqIHQpLnRvRml4ZWQoZikgKyB1O1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8vIFNWRyBmaWx0ZXJzLlxuLy8gKHZhbHVlcyBpbiBwYXJlbnRoZXNlcyBhcmUgZGVmYXVsdCB2YWx1ZXMpXG5leHBvcnQgY29uc3QgZmlsdGVyID0ge1xuXG4gICAgLy8gYGNvbG9yYCAuLi4gb3V0bGluZSBjb2xvciAoJ2JsdWUnKVxuICAgIC8vIGB3aWR0aGAuLi4gb3V0bGluZSB3aWR0aCAoMSlcbiAgICAvLyBgb3BhY2l0eWAgLi4uIG91dGxpbmUgb3BhY2l0eSAoMSlcbiAgICAvLyBgbWFyZ2luYCAuLi4gZ2FwIGJldHdlZW4gb3V0bGluZSBhbmQgdGhlIGVsZW1lbnQgKDIpXG4gICAgb3V0bGluZTogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciB0cGwgPSAnPGZpbHRlcj48ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIgZmxvb2Qtb3BhY2l0eT1cIiR7b3BhY2l0eX1cIiByZXN1bHQ9XCJjb2xvcmVkXCIvPjxmZU1vcnBob2xvZ3kgaW49XCJTb3VyY2VBbHBoYVwiIHJlc3VsdD1cIm1vcnBoZWRPdXRlclwiIG9wZXJhdG9yPVwiZGlsYXRlXCIgcmFkaXVzPVwiJHtvdXRlclJhZGl1c31cIiAvPjxmZU1vcnBob2xvZ3kgaW49XCJTb3VyY2VBbHBoYVwiIHJlc3VsdD1cIm1vcnBoZWRJbm5lclwiIG9wZXJhdG9yPVwiZGlsYXRlXCIgcmFkaXVzPVwiJHtpbm5lclJhZGl1c31cIiAvPjxmZUNvbXBvc2l0ZSByZXN1bHQ9XCJtb3JwaGVkT3V0ZXJDb2xvcmVkXCIgaW49XCJjb2xvcmVkXCIgaW4yPVwibW9ycGhlZE91dGVyXCIgb3BlcmF0b3I9XCJpblwiLz48ZmVDb21wb3NpdGUgb3BlcmF0b3I9XCJ4b3JcIiBpbj1cIm1vcnBoZWRPdXRlckNvbG9yZWRcIiBpbjI9XCJtb3JwaGVkSW5uZXJcIiByZXN1bHQ9XCJvdXRsaW5lXCIvPjxmZU1lcmdlPjxmZU1lcmdlTm9kZSBpbj1cIm91dGxpbmVcIi8+PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiLz48L2ZlTWVyZ2U+PC9maWx0ZXI+JztcblxuICAgICAgICB2YXIgbWFyZ2luID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MubWFyZ2luKSA/IGFyZ3MubWFyZ2luIDogMjtcbiAgICAgICAgdmFyIHdpZHRoID0gTnVtYmVyLmlzRmluaXRlKGFyZ3Mud2lkdGgpID8gYXJncy53aWR0aCA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHRwbCkoe1xuICAgICAgICAgICAgY29sb3I6IGFyZ3MuY29sb3IgfHwgJ2JsdWUnLFxuICAgICAgICAgICAgb3BhY2l0eTogTnVtYmVyLmlzRmluaXRlKGFyZ3Mub3BhY2l0eSkgPyBhcmdzLm9wYWNpdHkgOiAxLFxuICAgICAgICAgICAgb3V0ZXJSYWRpdXM6IG1hcmdpbiArIHdpZHRoLFxuICAgICAgICAgICAgaW5uZXJSYWRpdXM6IG1hcmdpblxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGNvbG9yYCAuLi4gY29sb3IgKCdyZWQnKVxuICAgIC8vIGB3aWR0aGAuLi4gd2lkdGggKDEpXG4gICAgLy8gYGJsdXJgIC4uLiBibHVyICgwKVxuICAgIC8vIGBvcGFjaXR5YCAuLi4gb3BhY2l0eSAoMSlcbiAgICBoaWdobGlnaHQ6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgdHBsID0gJzxmaWx0ZXI+PGZlRmxvb2QgZmxvb2QtY29sb3I9XCIke2NvbG9yfVwiIGZsb29kLW9wYWNpdHk9XCIke29wYWNpdHl9XCIgcmVzdWx0PVwiY29sb3JlZFwiLz48ZmVNb3JwaG9sb2d5IHJlc3VsdD1cIm1vcnBoZWRcIiBpbj1cIlNvdXJjZUdyYXBoaWNcIiBvcGVyYXRvcj1cImRpbGF0ZVwiIHJhZGl1cz1cIiR7d2lkdGh9XCIvPjxmZUNvbXBvc2l0ZSByZXN1bHQ9XCJjb21wb3NlZFwiIGluPVwiY29sb3JlZFwiIGluMj1cIm1vcnBoZWRcIiBvcGVyYXRvcj1cImluXCIvPjxmZUdhdXNzaWFuQmx1ciByZXN1bHQ9XCJibHVyZWRcIiBpbj1cImNvbXBvc2VkXCIgc3RkRGV2aWF0aW9uPVwiJHtibHVyfVwiLz48ZmVCbGVuZCBpbj1cIlNvdXJjZUdyYXBoaWNcIiBpbjI9XCJibHVyZWRcIiBtb2RlPVwibm9ybWFsXCIvPjwvZmlsdGVyPic7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHRwbCkoe1xuICAgICAgICAgICAgY29sb3I6IGFyZ3MuY29sb3IgfHwgJ3JlZCcsXG4gICAgICAgICAgICB3aWR0aDogTnVtYmVyLmlzRmluaXRlKGFyZ3Mud2lkdGgpID8gYXJncy53aWR0aCA6IDEsXG4gICAgICAgICAgICBibHVyOiBOdW1iZXIuaXNGaW5pdGUoYXJncy5ibHVyKSA/IGFyZ3MuYmx1ciA6IDAsXG4gICAgICAgICAgICBvcGFjaXR5OiBOdW1iZXIuaXNGaW5pdGUoYXJncy5vcGFjaXR5KSA/IGFyZ3Mub3BhY2l0eSA6IDFcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGB4YCAuLi4gaG9yaXpvbnRhbCBibHVyICgyKVxuICAgIC8vIGB5YCAuLi4gdmVydGljYWwgYmx1ciAob3B0aW9uYWwpXG4gICAgYmx1cjogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciB4ID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MueCkgPyBhcmdzLnggOiAyO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPVwiJHtzdGREZXZpYXRpb259XCIvPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIHN0ZERldmlhdGlvbjogTnVtYmVyLmlzRmluaXRlKGFyZ3MueSkgPyBbeCwgYXJncy55XSA6IHhcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBkeGAgLi4uIGhvcml6b250YWwgc2hpZnQgKDApXG4gICAgLy8gYGR5YCAuLi4gdmVydGljYWwgc2hpZnQgKDApXG4gICAgLy8gYGJsdXJgIC4uLiBibHVyICg0KVxuICAgIC8vIGBjb2xvcmAgLi4uIGNvbG9yICgnYmxhY2snKVxuICAgIC8vIGBvcGFjaXR5YCAuLi4gb3BhY2l0eSAoMSlcbiAgICBkcm9wU2hhZG93OiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIHRwbCA9ICdTVkdGRURyb3BTaGFkb3dFbGVtZW50JyBpbiB3aW5kb3dcbiAgICAgICAgICAgID8gJzxmaWx0ZXI+PGZlRHJvcFNoYWRvdyBzdGREZXZpYXRpb249XCIke2JsdXJ9XCIgZHg9XCIke2R4fVwiIGR5PVwiJHtkeX1cIiBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIgZmxvb2Qtb3BhY2l0eT1cIiR7b3BhY2l0eX1cIi8+PC9maWx0ZXI+J1xuICAgICAgICAgICAgOiAnPGZpbHRlcj48ZmVHYXVzc2lhbkJsdXIgaW49XCJTb3VyY2VBbHBoYVwiIHN0ZERldmlhdGlvbj1cIiR7Ymx1cn1cIi8+PGZlT2Zmc2V0IGR4PVwiJHtkeH1cIiBkeT1cIiR7ZHl9XCIgcmVzdWx0PVwib2Zmc2V0Ymx1clwiLz48ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIvPjxmZUNvbXBvc2l0ZSBpbjI9XCJvZmZzZXRibHVyXCIgb3BlcmF0b3I9XCJpblwiLz48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jQSB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke29wYWNpdHl9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVNZXJnZT48ZmVNZXJnZU5vZGUvPjxmZU1lcmdlTm9kZSBpbj1cIlNvdXJjZUdyYXBoaWNcIi8+PC9mZU1lcmdlPjwvZmlsdGVyPic7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHRwbCkoe1xuICAgICAgICAgICAgZHg6IGFyZ3MuZHggfHwgMCxcbiAgICAgICAgICAgIGR5OiBhcmdzLmR5IHx8IDAsXG4gICAgICAgICAgICBvcGFjaXR5OiBOdW1iZXIuaXNGaW5pdGUoYXJncy5vcGFjaXR5KSA/IGFyZ3Mub3BhY2l0eSA6IDEsXG4gICAgICAgICAgICBjb2xvcjogYXJncy5jb2xvciB8fCAnYmxhY2snLFxuICAgICAgICAgICAgYmx1cjogTnVtYmVyLmlzRmluaXRlKGFyZ3MuYmx1cikgPyBhcmdzLmJsdXIgOiA0XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW1vdW50YCAuLi4gdGhlIHByb3BvcnRpb24gb2YgdGhlIGNvbnZlcnNpb24gKDEpLiBBIHZhbHVlIG9mIDEgKGRlZmF1bHQpIGlzIGNvbXBsZXRlbHkgZ3JheXNjYWxlLiBBIHZhbHVlIG9mIDAgbGVhdmVzIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gICAgZ3JheXNjYWxlOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIGFtb3VudCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLmFtb3VudCkgPyBhcmdzLmFtb3VudCA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCIke2F9ICR7Yn0gJHtjfSAwIDAgJHtkfSAke2V9ICR7Zn0gMCAwICR7Z30gJHtifSAke2h9IDAgMCAwIDAgMCAxIDBcIi8+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYTogMC4yMTI2ICsgMC43ODc0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYjogMC43MTUyIC0gMC43MTUyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZTogMC43MTUyICsgMC4yODQ4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4wNzIyIC0gMC4wNzIyICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yMTI2IC0gMC4yMTI2ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaDogMC4wNzIyICsgMC45Mjc4ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW1vdW50YCAuLi4gdGhlIHByb3BvcnRpb24gb2YgdGhlIGNvbnZlcnNpb24gKDEpLiBBIHZhbHVlIG9mIDEgKGRlZmF1bHQpIGlzIGNvbXBsZXRlbHkgc2VwaWEuIEEgdmFsdWUgb2YgMCBsZWF2ZXMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgICBzZXBpYTogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciBhbW91bnQgPSBOdW1iZXIuaXNGaW5pdGUoYXJncy5hbW91bnQpID8gYXJncy5hbW91bnQgOiAxO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb2xvck1hdHJpeCB0eXBlPVwibWF0cml4XCIgdmFsdWVzPVwiJHthfSAke2J9ICR7Y30gMCAwICR7ZH0gJHtlfSAke2Z9IDAgMCAke2d9ICR7aH0gJHtpfSAwIDAgMCAwIDAgMSAwXCIvPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGE6IDAuMzkzICsgMC42MDcgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBiOiAwLjc2OSAtIDAuNzY5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgYzogMC4xODkgLSAwLjE4OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGQ6IDAuMzQ5IC0gMC4zNDkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBlOiAwLjY4NiArIDAuMzE0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZjogMC4xNjggLSAwLjE2OCAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGc6IDAuMjcyIC0gMC4yNzIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBoOiAwLjUzNCAtIDAuNTM0ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgaTogMC4xMzEgKyAwLjg2OSAqICgxIC0gYW1vdW50KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFtb3VudGAgLi4uIHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBjb252ZXJzaW9uICgxKS4gQSB2YWx1ZSBvZiAwIGlzIGNvbXBsZXRlbHkgdW4tc2F0dXJhdGVkLiBBIHZhbHVlIG9mIDEgKGRlZmF1bHQpIGxlYXZlcyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgIHNhdHVyYXRlOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIGFtb3VudCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLmFtb3VudCkgPyBhcmdzLmFtb3VudCA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbG9yTWF0cml4IHR5cGU9XCJzYXR1cmF0ZVwiIHZhbHVlcz1cIiR7YW1vdW50fVwiLz48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhbW91bnQ6IDEgLSBhbW91bnRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbmdsZWAgLi4uICB0aGUgbnVtYmVyIG9mIGRlZ3JlZXMgYXJvdW5kIHRoZSBjb2xvciBjaXJjbGUgdGhlIGlucHV0IHNhbXBsZXMgd2lsbCBiZSBhZGp1c3RlZCAoMCkuXG4gICAgaHVlUm90YXRlOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbG9yTWF0cml4IHR5cGU9XCJodWVSb3RhdGVcIiB2YWx1ZXM9XCIke2FuZ2xlfVwiLz48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhbmdsZTogYXJncy5hbmdsZSB8fCAwXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW1vdW50YCAuLi4gdGhlIHByb3BvcnRpb24gb2YgdGhlIGNvbnZlcnNpb24gKDEpLiBBIHZhbHVlIG9mIDEgKGRlZmF1bHQpIGlzIGNvbXBsZXRlbHkgaW52ZXJ0ZWQuIEEgdmFsdWUgb2YgMCBsZWF2ZXMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgICBpbnZlcnQ6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgYW1vdW50ID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MuYW1vdW50KSA/IGFyZ3MuYW1vdW50IDogMTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cInRhYmxlXCIgdGFibGVWYWx1ZXM9XCIke2Ftb3VudH0gJHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cIiR7YW1vdW50fSAke2Ftb3VudDJ9XCIvPjxmZUZ1bmNCIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwiJHthbW91bnR9ICR7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogMSAtIGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFtb3VudGAgLi4uIHByb3BvcnRpb24gb2YgdGhlIGNvbnZlcnNpb24gKDEpLiBBIHZhbHVlIG9mIDAgd2lsbCBjcmVhdGUgYW4gaW1hZ2UgdGhhdCBpcyBjb21wbGV0ZWx5IGJsYWNrLiBBIHZhbHVlIG9mIDEgKGRlZmF1bHQpIGxlYXZlcyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgIGJyaWdodG5lc3M6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHthbW91bnR9XCIvPjxmZUZ1bmNHIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7YW1vdW50fVwiLz48ZmVGdW5jQiB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke2Ftb3VudH1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGFtb3VudDogTnVtYmVyLmlzRmluaXRlKGFyZ3MuYW1vdW50KSA/IGFyZ3MuYW1vdW50IDogMVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFtb3VudGAgLi4uIHByb3BvcnRpb24gb2YgdGhlIGNvbnZlcnNpb24gKDEpLiBBIHZhbHVlIG9mIDAgd2lsbCBjcmVhdGUgYW4gaW1hZ2UgdGhhdCBpcyBjb21wbGV0ZWx5IGJsYWNrLiBBIHZhbHVlIG9mIDEgKGRlZmF1bHQpIGxlYXZlcyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgIGNvbnRyYXN0OiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIGFtb3VudCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLmFtb3VudCkgPyBhcmdzLmFtb3VudCA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNSIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7YW1vdW50fVwiIGludGVyY2VwdD1cIiR7YW1vdW50Mn1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHthbW91bnR9XCIgaW50ZXJjZXB0PVwiJHthbW91bnQyfVwiLz48ZmVGdW5jQiB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCIke2Ftb3VudDJ9XCIvPjwvZmVDb21wb25lbnRUcmFuc2Zlcj48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgICAgICAgIGFtb3VudDI6IC41IC0gYW1vdW50IC8gMlxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZm9ybWF0ID0ge1xuXG4gICAgLy8gRm9ybWF0dGluZyBudW1iZXJzIHZpYSB0aGUgUHl0aG9uIEZvcm1hdCBTcGVjaWZpY2F0aW9uIE1pbmktbGFuZ3VhZ2UuXG4gICAgLy8gU2VlIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvcmVsZWFzZS8zLjEuMy9saWJyYXJ5L3N0cmluZy5odG1sI2Zvcm1hdC1zcGVjaWZpY2F0aW9uLW1pbmktbGFuZ3VhZ2UuXG4gICAgLy8gSGVhdmlsbHkgaW5zcGlyZWQgYnkgdGhlIEQzLmpzIGxpYnJhcnkgaW1wbGVtZW50YXRpb24uXG4gICAgbnVtYmVyOiBmdW5jdGlvbihzcGVjaWZpZXIsIHZhbHVlLCBsb2NhbGUpIHtcblxuICAgICAgICBsb2NhbGUgPSBsb2NhbGUgfHwge1xuXG4gICAgICAgICAgICBjdXJyZW5jeTogWyckJywgJyddLFxuICAgICAgICAgICAgZGVjaW1hbDogJy4nLFxuICAgICAgICAgICAgdGhvdXNhbmRzOiAnLCcsXG4gICAgICAgICAgICBncm91cGluZzogWzNdXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2VlIFB5dGhvbiBmb3JtYXQgc3BlY2lmaWNhdGlvbiBtaW5pLWxhbmd1YWdlOiBodHRwOi8vZG9jcy5weXRob24ub3JnL3JlbGVhc2UvMy4xLjMvbGlicmFyeS9zdHJpbmcuaHRtbCNmb3JtYXQtc3BlY2lmaWNhdGlvbi1taW5pLWxhbmd1YWdlLlxuICAgICAgICAvLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW3R5cGVdXG4gICAgICAgIHZhciByZSA9IC8oPzooW157XSk/KFs8Pj1eXSkpPyhbK1xcLSBdKT8oWyQjXSk/KDApPyhcXGQrKT8oLCk/KFxcLi0/XFxkKyk/KFthLXolXSk/L2k7XG5cbiAgICAgICAgdmFyIG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpO1xuICAgICAgICB2YXIgZmlsbCA9IG1hdGNoWzFdIHx8ICcgJztcbiAgICAgICAgdmFyIGFsaWduID0gbWF0Y2hbMl0gfHwgJz4nO1xuICAgICAgICB2YXIgc2lnbiA9IG1hdGNoWzNdIHx8ICcnO1xuICAgICAgICB2YXIgc3ltYm9sID0gbWF0Y2hbNF0gfHwgJyc7XG4gICAgICAgIHZhciB6ZmlsbCA9IG1hdGNoWzVdO1xuICAgICAgICB2YXIgd2lkdGggPSArbWF0Y2hbNl07XG4gICAgICAgIHZhciBjb21tYSA9IG1hdGNoWzddO1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gbWF0Y2hbOF07XG4gICAgICAgIHZhciB0eXBlID0gbWF0Y2hbOV07XG4gICAgICAgIHZhciBzY2FsZSA9IDE7XG4gICAgICAgIHZhciBwcmVmaXggPSAnJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICcnO1xuICAgICAgICB2YXIgaW50ZWdlciA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwcmVjaXNpb24pIHByZWNpc2lvbiA9ICtwcmVjaXNpb24uc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgIGlmICh6ZmlsbCB8fCBmaWxsID09PSAnMCcgJiYgYWxpZ24gPT09ICc9Jykge1xuICAgICAgICAgICAgemZpbGwgPSBmaWxsID0gJzAnO1xuICAgICAgICAgICAgYWxpZ24gPSAnPSc7XG4gICAgICAgICAgICBpZiAoY29tbWEpIHdpZHRoIC09IE1hdGguZmxvb3IoKHdpZHRoIC0gMSkgLyA0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgY29tbWEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBzY2FsZSA9IDEwMDtcbiAgICAgICAgICAgICAgICBzdWZmaXggPSAnJSc7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICclJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3InO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gJyMnKSBwcmVmaXggPSAnMCcgKyB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIGludGVnZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICBzY2FsZSA9IC0xO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAncic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ltYm9sID09PSAnJCcpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeVswXTtcbiAgICAgICAgICAgIHN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIG5vIHByZWNpc2lvbiBpcyBzcGVjaWZpZWQgZm9yIGAncidgLCBmYWxsYmFjayB0byBnZW5lcmFsIG5vdGF0aW9uLlxuICAgICAgICBpZiAodHlwZSA9PSAncicgJiYgIXByZWNpc2lvbikgdHlwZSA9ICdnJztcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcmVxdWVzdGVkIHByZWNpc2lvbiBpcyBpbiB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgICAgICBpZiAocHJlY2lzaW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09ICdnJykgcHJlY2lzaW9uID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAnZScgfHwgdHlwZSA9PSAnZicpIHByZWNpc2lvbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB6Y29tbWEgPSB6ZmlsbCAmJiBjb21tYTtcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBmb3IgZmxvYXRzIGZvcm1hdHRlZCBhcyBpbnRzLlxuICAgICAgICBpZiAoaW50ZWdlciAmJiAodmFsdWUgJSAxKSkgcmV0dXJuICcnO1xuXG4gICAgICAgIC8vIENvbnZlcnQgbmVnYXRpdmUgdG8gcG9zaXRpdmUsIGFuZCByZWNvcmQgdGhlIHNpZ24gcHJlZml4LlxuICAgICAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZSA8IDAgfHwgdmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCA/ICh2YWx1ZSA9IC12YWx1ZSwgJy0nKSA6IHNpZ247XG5cbiAgICAgICAgdmFyIGZ1bGxTdWZmaXggPSBzdWZmaXg7XG5cbiAgICAgICAgLy8gQXBwbHkgdGhlIHNjYWxlLCBjb21wdXRpbmcgaXQgZnJvbSB0aGUgdmFsdWUncyBleHBvbmVudCBmb3Igc2kgZm9ybWF0LlxuICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgZXhpc3Rpbmcgc3VmZml4LCBpZiBhbnksIHN1Y2ggYXMgdGhlIGN1cnJlbmN5IHN5bWJvbC5cbiAgICAgICAgaWYgKHNjYWxlIDwgMCkge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSB0aGlzLnByZWZpeCh2YWx1ZSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIHZhbHVlID0gdW5pdC5zY2FsZSh2YWx1ZSk7XG4gICAgICAgICAgICBmdWxsU3VmZml4ID0gdW5pdC5zeW1ib2wgKyBzdWZmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAqPSBzY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgdG8gdGhlIGRlc2lyZWQgcHJlY2lzaW9uLlxuICAgICAgICB2YWx1ZSA9IHRoaXMuY29udmVydCh0eXBlLCB2YWx1ZSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgdmFsdWUgaW50byB0aGUgaW50ZWdlciBwYXJ0IChiZWZvcmUpIGFuZCBkZWNpbWFsIHBhcnQgKGFmdGVyKS5cbiAgICAgICAgdmFyIGkgPSB2YWx1ZS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICB2YXIgYmVmb3JlID0gaSA8IDAgPyB2YWx1ZSA6IHZhbHVlLnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgdmFyIGFmdGVyID0gaSA8IDAgPyAnJyA6IGxvY2FsZS5kZWNpbWFsICsgdmFsdWUuc3Vic3RyaW5nKGkgKyAxKTtcblxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRHcm91cCh2YWx1ZSkge1xuXG4gICAgICAgICAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciB0ID0gW107XG4gICAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgICB2YXIgZyA9IGxvY2FsZS5ncm91cGluZ1swXTtcbiAgICAgICAgICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgICAgICAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgICAgICAgICAgIGcgPSBsb2NhbGUuZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBsb2NhbGUuZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKGxvY2FsZS50aG91c2FuZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIGZpbGwgY2hhcmFjdGVyIGlzIG5vdCBgJzAnYCwgZ3JvdXBpbmcgaXMgYXBwbGllZCBiZWZvcmUgcGFkZGluZy5cbiAgICAgICAgaWYgKCF6ZmlsbCAmJiBjb21tYSAmJiBsb2NhbGUuZ3JvdXBpbmcpIHtcblxuICAgICAgICAgICAgYmVmb3JlID0gZm9ybWF0R3JvdXAoYmVmb3JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgYmVmb3JlLmxlbmd0aCArIGFmdGVyLmxlbmd0aCArICh6Y29tbWEgPyAwIDogbmVnYXRpdmUubGVuZ3RoKTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheShsZW5ndGggPSB3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiAnJztcblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgYCcwJ2AsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgICAgaWYgKHpjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAocGFkZGluZyArIGJlZm9yZSk7XG5cbiAgICAgICAgLy8gQXBwbHkgcHJlZml4LlxuICAgICAgICBuZWdhdGl2ZSArPSBwcmVmaXg7XG5cbiAgICAgICAgLy8gUmVqb2luIGludGVnZXIgYW5kIGRlY2ltYWwgcGFydHMuXG4gICAgICAgIHZhbHVlID0gYmVmb3JlICsgYWZ0ZXI7XG5cbiAgICAgICAgcmV0dXJuIChhbGlnbiA9PT0gJzwnID8gbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmdcbiAgICAgICAgICAgIDogYWxpZ24gPT09ICc+JyA/IHBhZGRpbmcgKyBuZWdhdGl2ZSArIHZhbHVlXG4gICAgICAgICAgICAgICAgOiBhbGlnbiA9PT0gJ14nID8gcGFkZGluZy5zdWJzdHJpbmcoMCwgbGVuZ3RoID4+PSAxKSArIG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nLnN1YnN0cmluZyhsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIDogbmVnYXRpdmUgKyAoemNvbW1hID8gdmFsdWUgOiBwYWRkaW5nICsgdmFsdWUpKSArIGZ1bGxTdWZmaXg7XG4gICAgfSxcblxuICAgIC8vIEZvcm1hdHRpbmcgc3RyaW5nIHZpYSB0aGUgUHl0aG9uIEZvcm1hdCBzdHJpbmcuXG4gICAgLy8gU2VlIGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS9zdHJpbmcuaHRtbCNmb3JtYXQtc3RyaW5nLXN5bnRheClcbiAgICBzdHJpbmc6IGZ1bmN0aW9uKGZvcm1hdFN0cmluZywgdmFsdWUpIHtcblxuICAgICAgICB2YXIgZmllbGREZWxpbWl0ZXJJbmRleDtcbiAgICAgICAgdmFyIGZpZWxkRGVsaW1pdGVyID0gJ3snO1xuICAgICAgICB2YXIgZW5kUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFN0cmluZ0FycmF5ID0gW107XG5cbiAgICAgICAgd2hpbGUgKChmaWVsZERlbGltaXRlckluZGV4ID0gZm9ybWF0U3RyaW5nLmluZGV4T2YoZmllbGREZWxpbWl0ZXIpKSAhPT0gLTEpIHtcblxuICAgICAgICAgICAgdmFyIHBpZWNlRm9ybWF0dGVkU3RyaW5nLCBmb3JtYXRTcGVjLCBmaWVsZE5hbWU7XG5cbiAgICAgICAgICAgIHBpZWNlRm9ybWF0dGVkU3RyaW5nID0gZm9ybWF0U3RyaW5nLnNsaWNlKDAsIGZpZWxkRGVsaW1pdGVySW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAoZW5kUGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRTcGVjID0gcGllY2VGb3JtYXR0ZWRTdHJpbmcuc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmb3JtYXRTcGVjLnNoaWZ0KCkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICBwaWVjZUZvcm1hdHRlZFN0cmluZyA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlRm9ybWF0dGVkU3RyaW5nID0gcGllY2VGb3JtYXR0ZWRTdHJpbmdbZmllbGROYW1lW2ldXTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRTcGVjLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcGllY2VGb3JtYXR0ZWRTdHJpbmcgPSB0aGlzLm51bWJlcihmb3JtYXRTcGVjLCBwaWVjZUZvcm1hdHRlZFN0cmluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdHRlZFN0cmluZ0FycmF5LnB1c2gocGllY2VGb3JtYXR0ZWRTdHJpbmcpO1xuXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcuc2xpY2UoZmllbGREZWxpbWl0ZXJJbmRleCArIDEpO1xuICAgICAgICAgICAgZW5kUGxhY2Vob2xkZXIgPSAhZW5kUGxhY2Vob2xkZXI7XG4gICAgICAgICAgICBmaWVsZERlbGltaXRlciA9IChlbmRQbGFjZWhvbGRlcikgPyAnfScgOiAneyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0dGVkU3RyaW5nQXJyYXkucHVzaChmb3JtYXRTdHJpbmcpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdHJpbmdBcnJheS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgY29udmVydDogZnVuY3Rpb24odHlwZSwgdmFsdWUsIHByZWNpc2lvbikge1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKDIpO1xuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKDgpO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1ByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlID0gdGhpcy5yb3VuZCh2YWx1ZSwgdGhpcy5wcmVjaXNpb24odmFsdWUsIHByZWNpc2lvbikpKS50b0ZpeGVkKE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCB0aGlzLnByZWNpc2lvbih2YWx1ZSAqICgxICsgMWUtMTUpLCBwcmVjaXNpb24pKSkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuXG4gICAgICAgIHJldHVybiBwcmVjaXNpb25cbiAgICAgICAgICAgID8gTWF0aC5yb3VuZCh2YWx1ZSAqIChwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSkpIC8gcHJlY2lzaW9uXG4gICAgICAgICAgICA6IE1hdGgucm91bmQodmFsdWUpO1xuICAgIH0sXG5cbiAgICBwcmVjaXNpb246IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcblxuICAgICAgICByZXR1cm4gcHJlY2lzaW9uIC0gKHZhbHVlID8gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCkgOiAxKTtcbiAgICB9LFxuXG4gICAgcHJlZml4OiBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdmFyIHByZWZpeGVzID0gWyd5JywgJ3onLCAnYScsICdmJywgJ3AnLCAnbicsICfCtScsICdtJywgJycsICdrJywgJ00nLCAnRycsICdUJywgJ1AnLCAnRScsICdaJywgJ1knXS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgdmFyIGsgPSBNYXRoLnBvdygxMCwgTWF0aC5hYnMoOCAtIGkpICogMyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBpID4gOCA/IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQgLyBrO1xuICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkICogaztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN5bWJvbDogZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlICo9IC0xO1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbikgdmFsdWUgPSB0aGlzLnJvdW5kKHZhbHVlLCB0aGlzLnByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICBpID0gMSArIE1hdGguZmxvb3IoMWUtMTIgKyBNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTApO1xuICAgICAgICAgICAgaSA9IE1hdGgubWF4KC0yNCwgTWF0aC5taW4oMjQsIE1hdGguZmxvb3IoKGkgPD0gMCA/IGkgKyAxIDogaSAtIDEpIC8gMykgKiAzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeGVzWzggKyBpIC8gM107XG4gICAgfVxufTtcblxuLypcbiAgICBQcmUtY29tcGlsZSB0aGUgSFRNTCB0byBiZSB1c2VkIGFzIGEgdGVtcGxhdGUuXG4qL1xuZXhwb3J0IGNvbnN0IHRlbXBsYXRlID0gZnVuY3Rpb24oaHRtbCkge1xuXG4gICAgLypcbiAgICAgICAgTXVzdCBzdXBwb3J0IHRoZSB2YXJpYXRpb24gaW4gdGVtcGxhdGluZyBzeW50YXggZm91bmQgaGVyZTpcbiAgICAgICAgaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MjdGVtcGxhdGVcbiAgICAqL1xuICAgIHZhciByZWdleCA9IC88JT0gKFteIF0rKSAlPnxcXCRcXHsgPyhbXnt9IF0rKSA/XFx9fFxce1xceyhbXnt9IF0rKVxcfVxcfS9nO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihtYXRjaCkge1xuXG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBhdHRyID0gYXJncy5zbGljZSgxLCA0KS5maW5kKGZ1bmN0aW9uKF9hdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhX2F0dHI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGF0dHJBcnJheSA9IGF0dHIuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbYXR0ckFycmF5LnNoaWZ0KCldO1xuXG4gICAgICAgICAgICB3aGlsZSAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBhdHRyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVthdHRyQXJyYXkuc2hpZnQoKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiAnJztcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBFbGVtZW50LCB3aGljaCBjb250ZW50IGlzIGludGVudCB0byBkaXNwbGF5IGluIGZ1bGwtc2NyZWVuIG1vZGUsICd3aW5kb3cudG9wLmRvY3VtZW50LmJvZHknIGlzIGRlZmF1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVGdWxsU2NyZWVuID0gZnVuY3Rpb24oZWwpIHtcblxuICAgIHZhciB0b3BEb2N1bWVudCA9IHdpbmRvdy50b3AuZG9jdW1lbnQ7XG4gICAgZWwgPSBlbCB8fCB0b3BEb2N1bWVudC5ib2R5O1xuXG4gICAgZnVuY3Rpb24gcHJlZml4ZWRSZXN1bHQoZWwsIHByb3ApIHtcblxuICAgICAgICB2YXIgcHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdtb3onLCAnbXMnLCAnbycsICcnXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJlZml4ID8gKHByZWZpeCArIHByb3ApIDogKHByb3Auc3Vic3RyKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBwcm9wLnN1YnN0cigxKSk7XG4gICAgICAgICAgICBpZiAoZWxbcHJvcE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihlbFtwcm9wTmFtZV0pID8gZWxbcHJvcE5hbWVdKCkgOiBlbFtwcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJlZml4ZWRSZXN1bHQodG9wRG9jdW1lbnQsICdGdWxsc2NyZWVuRWxlbWVudCcpIHx8IHByZWZpeGVkUmVzdWx0KHRvcERvY3VtZW50LCAnRnVsbFNjcmVlbkVsZW1lbnQnKSkge1xuICAgICAgICBwcmVmaXhlZFJlc3VsdCh0b3BEb2N1bWVudCwgJ0V4aXRGdWxsc2NyZWVuJykgfHwgLy8gU3BlYy5cbiAgICAgICAgcHJlZml4ZWRSZXN1bHQodG9wRG9jdW1lbnQsICdDYW5jZWxGdWxsU2NyZWVuJyk7IC8vIEZpcmVmb3hcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhlZFJlc3VsdChlbCwgJ1JlcXVlc3RGdWxsc2NyZWVuJykgfHwgLy8gU3BlYy5cbiAgICAgICAgcHJlZml4ZWRSZXN1bHQoZWwsICdSZXF1ZXN0RnVsbFNjcmVlbicpOyAvLyBGaXJlZm94XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZERpZmZlcmVuY2Uob2JqLCBiYXNlT2JqLCBjdXJyZW50RGVwdGgsIG1heERlcHRoKSB7XG5cbiAgICBpZiAoY3VycmVudERlcHRoID09PSBtYXhEZXB0aCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgZGlmZiA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcblxuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBjb25zdCBiYXNlVmFsdWUgPSBiYXNlT2JqW2tleV07XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheShiYXNlVmFsdWUpICYmIGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChiYXNlVmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZERlcHRoID0gY3VycmVudERlcHRoICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZERpZmYgPSBmaW5kRGlmZmVyZW5jZShvYmpWYWx1ZSwgYmFzZVZhbHVlLCBuZXN0ZWREZXB0aCwgbWF4RGVwdGgpO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmVzdGVkRGlmZikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRpZmZba2V5XSA9IG5lc3RlZERpZmY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChjdXJyZW50RGVwdGggPT09IDAgfHwgbmVzdGVkRGVwdGggPT09IG1heERlcHRoKSkge1xuICAgICAgICAgICAgICAgIGRpZmZba2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRXF1YWwob2JqVmFsdWUsIGJhc2VWYWx1ZSkpIHtcbiAgICAgICAgICAgIGRpZmZba2V5XSA9IG9ialZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGlmZjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdERpZmZlcmVuY2Uob2JqZWN0LCBiYXNlLCBvcHQpIHtcblxuICAgIGNvbnN0IHsgbWF4RGVwdGggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfSA9IG9wdCB8fCB7fTtcblxuICAgIHJldHVybiBmaW5kRGlmZmVyZW5jZShvYmplY3QsIGJhc2UsIDAsIG1heERlcHRoKTtcbn1cblxuZXhwb3J0IHtcbiAgICBpc0Jvb2xlYW4sXG4gICAgaXNPYmplY3QsXG4gICAgaXNOdW1iZXIsXG4gICAgaXNTdHJpbmcsXG4gICAgbWl4aW4sXG4gICAgZGVlcE1peGluLFxuICAgIHN1cHBsZW1lbnQsXG4gICAgZGVmYXVsdHMsXG4gICAgZGVlcFN1cHBsZW1lbnQsXG4gICAgZGVmYXVsdHNEZWVwLFxuICAgIGFzc2lnbixcbiAgICBpbnZva2UsXG4gICAgaW52b2tlUHJvcGVydHksXG4gICAgc29ydGVkSW5kZXgsXG4gICAgdW5pcSxcbiAgICBjbG9uZSxcbiAgICBjbG9uZURlZXAsXG4gICAgaXNFbXB0eSxcbiAgICBpc0VxdWFsLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNQbGFpbk9iamVjdCxcbiAgICB0b0FycmF5LFxuICAgIGRlYm91bmNlLFxuICAgIGdyb3VwQnksXG4gICAgc29ydEJ5LFxuICAgIGZsYXR0ZW5EZWVwLFxuICAgIHdpdGhvdXQsXG4gICAgZGlmZmVyZW5jZSxcbiAgICBpbnRlcnNlY3Rpb24sXG4gICAgdW5pb24sXG4gICAgaGFzLFxuICAgIHJlc3VsdCxcbiAgICBvbWl0LFxuICAgIHBpY2ssXG4gICAgYmluZEFsbCxcbiAgICBmb3JJbixcbiAgICBjYW1lbENhc2UsXG4gICAgdW5pcXVlSWQsXG4gICAgbWVyZ2Vcbn07XG5cbmV4cG9ydCBjb25zdCBub29wID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gRG8gbm90aGluZy5cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/util.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/util/utilHelpers.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bindAll: () => (/* binding */ bindAll),\n/* harmony export */   camelCase: () => (/* binding */ camelCase),\n/* harmony export */   clone: () => (/* binding */ clone),\n/* harmony export */   cloneDeep: () => (/* binding */ cloneDeep),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   deepMixin: () => (/* binding */ deepMixin),\n/* harmony export */   deepSupplement: () => (/* binding */ deepSupplement),\n/* harmony export */   defaults: () => (/* binding */ defaults),\n/* harmony export */   defaultsDeep: () => (/* binding */ defaultsDeep),\n/* harmony export */   difference: () => (/* binding */ difference),\n/* harmony export */   flattenDeep: () => (/* binding */ flattenDeep),\n/* harmony export */   forIn: () => (/* binding */ forIn),\n/* harmony export */   groupBy: () => (/* binding */ groupBy),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   invoke: () => (/* binding */ invoke),\n/* harmony export */   invokeProperty: () => (/* binding */ invokeProperty),\n/* harmony export */   isBoolean: () => (/* binding */ isBoolean),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   matches: () => (/* binding */ matches),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   mixin: () => (/* binding */ mixin),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   result: () => (/* binding */ result),\n/* harmony export */   sortBy: () => (/* binding */ sortBy),\n/* harmony export */   sortedIndex: () => (/* binding */ sortedIndex),\n/* harmony export */   supplement: () => (/* binding */ supplement),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   uniq: () => (/* binding */ uniq),\n/* harmony export */   uniqueId: () => (/* binding */ uniqueId),\n/* harmony export */   without: () => (/* binding */ without)\n/* harmony export */ });\n// code is inspired by https://github.com/lodash/lodash\n\n/* eslint-disable no-case-declarations */\n// -- helper constants\nconst argsTag = '[object Arguments]';\nconst arrayTag = '[object Array]';\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst funcTag = '[object Function]';\nconst mapTag = '[object Map]';\nconst numberTag = '[object Number]';\nconst nullTag = '[object Null]';\nconst objectTag = '[object Object]';\nconst regexpTag = '[object RegExp]';\nconst setTag = '[object Set]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst undefinedTag = '[object Undefined]';\nconst weakMapTag = '[object WeakMap]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst dataViewTag = '[object DataView]';\nconst float32Tag = '[object Float32Array]';\nconst float64Tag = '[object Float64Array]';\nconst int8Tag = '[object Int8Array]';\nconst int16Tag = '[object Int16Array]';\nconst int32Tag = '[object Int32Array]';\nconst uint8Tag = '[object Uint8Array]';\nconst uint8ClampedTag = '[object Uint8ClampedArray]';\nconst uint16Tag = '[object Uint16Array]';\nconst uint32Tag = '[object Uint32Array]';\n\nconst CLONEABLE_TAGS = {\n    [argsTag]: true,\n    [arrayTag]: true,\n    [arrayBufferTag]: true,\n    [dataViewTag]: true,\n    [boolTag]: true,\n    [dateTag]: true,\n    [float32Tag]: true,\n    [float64Tag]: true,\n    [int8Tag]: true,\n    [int16Tag]: true,\n    [int32Tag]: true,\n    [mapTag]: true,\n    [numberTag]: true,\n    [objectTag]: true,\n    [regexpTag]: true,\n    [setTag]: true,\n    [stringTag]: true,\n    [symbolTag]: true,\n    [uint8Tag]: true,\n    [uint8ClampedTag]: true,\n    [uint16Tag]: true,\n    [uint32Tag]: true,\n    [errorTag]: false,\n    [funcTag]: false,\n    [weakMapTag]: false,\n};\n\n/** Used to compose unicode character classes. */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f';\nconst reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nconst rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff';\nconst rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff';\nconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\nconst rsDingbatRange = '\\\\u2700-\\\\u27bf';\nconst rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff';\nconst rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7';\nconst rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf';\nconst rsPunctuationRange = '\\\\u2000-\\\\u206f';\nconst rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000';\nconst rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\nconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nconst rsApos = '[\\'\\u2019]';\nconst rsBreak = `[${rsBreakRange}]`;\nconst rsCombo = `[${rsComboRange}]`;\nconst rsDigit = '\\\\d';\nconst rsDingbat = `[${rsDingbatRange}]`;\nconst rsLower = `[${rsLowerRange}]`;\nconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsUpper = `[${rsUpperRange}]`;\nconst rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nconst rsMiscLower = `(?:${rsLower}|${rsMisc})`;\nconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;\nconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;\nconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`;\nconst rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])';\nconst rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;\n\nconst reUnicodeWords = RegExp([\n    `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`,\n    `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`,\n    `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,\n    `${rsUpper}+${rsOptContrUpper}`,\n    rsOrdUpper,\n    rsOrdLower,\n    `${rsDigit}+`,\n    rsEmoji\n].join('|'), 'g');\n\nconst LARGE_ARRAY_SIZE = 200;\nconst HASH_UNDEFINED = '__hash_undefined__';\n\n// Used to match `toStringTag` values of typed arrays\nconst reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n\n// Used to compose unicode capture groups\nconst rsAstral = `[${rsAstralRange}]`;\n\n// Used to compose unicode regexes\nconst rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;\nconst rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})`;\n\n// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, 'g');\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n    , 'g');\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\nconst hasUnicodeWord = RegExp.prototype.test.bind(\n    /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/\n);\n\nconst MAX_ARRAY_INDEX = 4294967295 - 1;\n\n/** Used to match words composed of alphanumeric characters. */\n// eslint-disable-next-line no-control-regex\nconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n\n\n// -- helper functions\nconst hasUnicode = (string) => {\n    return reUnicode.test(string);\n};\n\nconst unicodeToArray = (string) => {\n    return string.match(reUnicode) || [];\n};\n\nconst asciiToArray = (string) => {\n    return string.split('');\n};\n\nconst stringToArray = (string) => {\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n};\n\nconst values = (object) => {\n    if (object == null) {\n        return [];\n    }\n\n    return keys(object).map((key) => object[key]);\n};\n\nconst keys = (object) => {\n    return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n};\n\nconst baseKeys = (object) => {\n    if (!isPrototype(object)) {\n        return Object.keys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n            result.push(key);\n        }\n    }\n\n    return result;\n};\n\nconst arrayLikeKeys = (value, inherited) => {\n    const isArr = Array.isArray(value);\n    const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n    const isType = !isArr && !isArg && isTypedArray(value);\n    const skipIndexes = isArr || isArg || isType;\n    const length = value.length;\n    const result = new Array(skipIndexes ? length : 0);\n    let index = skipIndexes ? -1 : length;\n    while (++index < length) {\n        result[index] = `${index}`;\n    }\n    for (const key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n                // Safari 9 has enumerable `arguments.length` in strict mode.\n                key === 'length' ||\n                // Skip index properties.\n                isIndex(key, length)\n            ))\n        ) {\n            result.push(key);\n        }\n    }\n    return result;\n};\n\nconst assocIndexOf = (array, key) => {\n    let { length } = array;\n    while (length--) {\n        if (eq(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n};\n\nconst eq = (value, other) => {\n    return value === other || (value !== value && other !== other);\n};\n\nconst isObjectLike = (value) => {\n    return value != null && typeof value == 'object';\n};\n\nconst isIterateeCall = (value, index, object) => {\n    if (!isObject(object)) {\n        return false;\n    }\n    const type = typeof index;\n\n    const isPossibleIteratee = type == 'number' ?\n        (isArrayLike(object) && index > -1 && index < object.length) :\n        (type == 'string' && index in object);\n\n    if (isPossibleIteratee) {\n        return eq(object[index], value);\n    }\n    return false;\n};\n\nconst isSet = (value) => {\n    return isObjectLike(value) && getTag(value) == setTag;\n};\n\nconst isMap = (value) => {\n    return isObjectLike(value) && getTag(value) == mapTag;\n};\n\nconst isPrototype = (value) => {\n    const Ctor = value && value.constructor;\n    const proto = (typeof Ctor === 'function' && Ctor.prototype) || Object.prototype;\n\n    return value === proto;\n};\n\nconst assignValue = (object, key, value) => {\n    const objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n        object[key] = value;\n    }\n};\n\nconst copyObject = (source, props, object) => {\n    let index = -1;\n    const length = props.length;\n\n    while (++index < length) {\n        const key = props[index];\n        assignValue(object, key, source[key]);\n    }\n    return object;\n};\n\nconst isArrayLike = (value) => {\n    return value != null && typeof value !== 'function' && typeof value.length === 'number' &&\n        value.length > -1 && value.length % 1 === 0;\n};\n\nconst isSymbol = (value) => {\n    return typeof value == 'symbol' ||\n        (isObjectLike(value) && getTag(value) === symbolTag);\n};\n\nconst initCloneArray = (array) => {\n    const length = array.length;\n    let result = new array.constructor(length);\n\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n    }\n\n    return result;\n};\n\nconst copyArray = (source, array) => {\n    let index = -1;\n    const length = source.length;\n\n    array || (array = new Array(length));\n    while (++index < length) {\n        array[index] = source[index];\n    }\n    return array;\n};\n\nconst getTag = (value) => {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return Object.prototype.toString.call(value);\n};\n\nconst cloneArrayBuffer = (arrayBuffer) => {\n    const result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n};\n\nconst cloneTypedArray = (typedArray, isDeep) => {\n    const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n};\n\nconst cloneRegExp = (regexp) =>{\n    const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n};\n\nconst initCloneObject = (object) => {\n    return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? Object.create(Object.getPrototypeOf(object))\n        : {};\n};\n\nconst getSymbols = (object) => {\n    if (object == null) {\n        return [];\n    }\n\n    object = Object(object);\n    const symbols = Object.getOwnPropertySymbols(object);\n\n    return symbols.filter((symbol) => propertyIsEnumerable.call(object, symbol));\n};\n\nconst copySymbols = (source, object) => {\n    return copyObject(source, getSymbols(source), object);\n};\n\nfunction cloneDataView(dataView, isDeep) {\n    const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nconst initCloneByTag = (object, tag, isDeep) => {\n    const Constructor = object.constructor;\n    switch(tag) {\n        case arrayBufferTag:\n            return cloneArrayBuffer(object);\n        case boolTag:\n        case dateTag:\n            return new Constructor(+object);\n        case dataViewTag:\n            return cloneDataView(object, isDeep);\n        case float32Tag:\n        case float64Tag:\n        case int8Tag:\n        case int16Tag:\n        case int32Tag:\n        case uint8Tag:\n        case uint8ClampedTag:\n        case uint16Tag:\n        case uint32Tag:\n            return cloneTypedArray(object, isDeep);\n        case mapTag:\n            return new Constructor(object);\n        case numberTag:\n        case stringTag:\n            return new Constructor(object);\n        case regexpTag:\n            return cloneRegExp(object);\n        case setTag:\n            return new Constructor;\n        case symbolTag:\n            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n    }\n};\n\nconst isTypedArray = (value) => {\n    return isObjectLike(value) && reTypedTag.test(getTag(value));\n};\n\nconst getAllKeys = (object) => {\n    const result = Object.keys(object);\n    if(!Array.isArray(object) && object != null) {\n        result.push(...getSymbols(Object(object)));\n    }\n\n    return result;\n};\n\nconst getSymbolsIn = (object) => {\n    const result = [];\n    while (object) {\n        result.push(...getSymbols(object));\n        object = Object.getPrototypeOf(Object(object));\n    }\n\n    return result;\n};\n\nconst getAllKeysIn = (object) => {\n    const result = [];\n\n    for (const key in object) {\n        result.push(key);\n    }\n\n    if (!Array.isArray(object)) {\n        result.push(...getSymbolsIn(object));\n    }\n\n    return result;\n};\n\nconst getMapData = ({ __data__ }, key) => {\n    const data = __data__;\n    return isKeyable(key)\n        ? data[typeof key === 'string' ? 'string' : 'hash']\n        : data.map;\n};\n\nconst equalObjects = (object, other, equalFunc, stack) => {\n    const objProps = getAllKeys(object);\n    const objLength = objProps.length;\n    const othProps = getAllKeys(other);\n    const othLength = othProps.length;\n\n    if (objLength != othLength) {\n        return false;\n    }\n    let key;\n    let index = objLength;\n    while (index--) {\n        key = objProps[index];\n        if (!(hasOwnProperty.call(other, key))) {\n            return false;\n        }\n    }\n\n    const objStacked = stack.get(object);\n    const othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    let result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n\n    let compared;\n    let skipCtor;\n\n    while (++index < objLength) {\n        key = objProps[index];\n        const objValue = object[key];\n        const othValue = other[key];\n\n        if (!(compared === undefined\n            ? (objValue === othValue || equalFunc(objValue, othValue, stack))\n            : compared\n        )) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n    }\n\n    if (result && !skipCtor) {\n        const objCtor = object.constructor;\n        const othCtor = other.constructor;\n\n        if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor === 'function' && objCtor instanceof objCtor &&\n            typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n};\n\nconst baseIsEqual = (value, other, stack) => {\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n    }\n\n    return baseIsEqualDeep(value, other, baseIsEqual, stack);\n};\n\nconst baseIsEqualDeep = (object, other, equalFunc, stack) => {\n    let objIsArr = Array.isArray(object);\n    const othIsArr = Array.isArray(other);\n    let objTag = objIsArr ? arrayTag : getTag(object);\n    let othTag = othIsArr ? arrayTag : getTag(other);\n\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n\n    let objIsObj = objTag == objectTag;\n    const othIsObj = othTag == objectTag;\n    const isSameTag = objTag == othTag;\n\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n            ? equalArrays(object, other, false, equalFunc, stack)\n            : equalByTag(object, other, objTag, equalFunc, stack);\n    }\n\n    const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');\n    const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n        const objUnwrapped = objIsWrapped ? object.value() : object;\n        const othUnwrapped = othIsWrapped ? other.value() : other;\n\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, stack);\n    }\n\n    if (!isSameTag) {\n        return false;\n    }\n\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, stack);\n};\n\nconst equalArrays = (array, other, compareUnordered, equalFunc, stack) => {\n    const isPartial = false;\n    const arrLength = array.length;\n    const othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Assume cyclic values are equal.\n    const arrStacked = stack.get(array);\n    const othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    let index = -1;\n    let result = true;\n    const seen = compareUnordered ? new SetCache : undefined;\n\n    stack.set(array, other);\n    stack.set(other, array);\n\n    while (++index < arrLength) {\n        let compared;\n        const arrValue = array[index];\n        const othValue = other[index];\n\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n\n        if (seen) {\n            if (!some(other, (othValue, othIndex) => {\n                if (!cacheHas(seen, othIndex) &&\n            (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(\n            arrValue === othValue ||\n            equalFunc(arrValue, othValue, stack)\n        )) {\n            result = false;\n            break;\n        }\n    }\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n};\n\nconst some = (array, predicate) => {\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst cacheHas = (cache, key) => {\n    return cache.has(key);\n};\n\nconst compareArrayBufferTag = (object, other, equalFunc, stack) => {\n    if ((object.byteLength != other.byteLength) ||\n                !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n        return false;\n    }\n    return true;\n};\n\nconst equalByTag = (object, other, tag, equalFunc, stack) => {\n\n    switch (tag) {\n        case dataViewTag:\n            if ((object.byteLength != other.byteLength) ||\n                (object.byteOffset != other.byteOffset)) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case arrayBufferTag:\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case boolTag:\n        case dateTag:\n        case numberTag:\n            return eq(+object, +other);\n        case errorTag:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n            return object == `${other}`;\n        case mapTag:\n            // This use of 'var' is intentional. Don't remove if replacing all instances.\n            var convert = mapToArray;\n        // Intentional fallthrough\n        // eslint-disable-next-line no-fallthrough\n        case setTag:\n            convert || (convert = setToArray);\n\n            if (object.size != other.size) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            const stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n            stack['delete'](object);\n            return result;\n        case symbolTag:\n            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n    }\n\n    return false;\n};\n\nconst mapToArray = (map) => {\n    let index = -1;\n    let result = Array(map.size);\n\n    map.forEach((value, key) => {\n        result[++index] = [key, value];\n    });\n    return result;\n};\n\nconst setToArray = (set) => {\n    let index = -1;\n    const result = new Array(set.size);\n\n    set.forEach((value) => {\n        result[++index] = value;\n    });\n    return result;\n};\n\nconst isKey = (value, object) => {\n    if (Array.isArray(value)) {\n        return false;\n    }\n    const type = typeof value;\n    if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n};\n\nconst stringToPath = (string) => {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push('');\n    }\n    string.replace(rePropName, (match, expression, quote, subString) => {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, '$1');\n        }\n        else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n    });\n    return result;\n};\n\nconst castPath = (path, object) => {\n    if (Array.isArray(path)) {\n        return path;\n    }\n\n    return isKey(path, object) ? [path] : stringToPath(`${path}`);\n};\n\nconst get = (object, path) => {\n    path = castPath(path, object);\n\n    let index = 0;\n    const length = path.length;\n\n    while (object != null && index < length) {\n        object = object[toKey(path[index])];\n        index++;\n    }\n\n    return (index && index == length) ? object : undefined;\n};\n\nfunction compareAscending(value, other) {\n    if (value !== other) {\n        const valIsDefined = value !== undefined;\n        const valIsNull = value === null;\n        const valIsReflexive = value === value;\n        const valIsSymbol = isSymbol(value);\n\n        const othIsDefined = other !== undefined;\n        const othIsNull = other === null;\n        const othIsReflexive = other === other;\n        const othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n            return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nfunction compareMultiple(object, other, orders) {\n    let index = -1;\n    const objCriteria = object.criteria;\n    const othCriteria = other.criteria;\n    const length = objCriteria.length;\n    const ordersLength = orders.length;\n\n    while (++index < length) {\n        const order = index < ordersLength ? orders[index] : null;\n        const cmpFn = (order && typeof order === 'function') ? order : compareAscending;\n        const result = cmpFn(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (order && typeof order !== 'function') {\n                return result * (order == 'desc' ? -1 : 1);\n            }\n            return result;\n        }\n    }\n\n    return object.index - other.index;\n}\n\nconst diff = (array, values) => {\n    let includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    let isCommon = true;\n    const result = [];\n    const valuesLength = values.length;\n\n    if (!array.length) {\n        return result;\n    }\n\n    if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = (cache, key) => cache.has(key);\n        isCommon = false;\n        values = new SetCache(values);\n    }\n\n    outer:\n    for (let key in array) {\n        let value = array[key];\n        const computed = value;\n\n        value = (value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n            let valuesIndex = valuesLength;\n            while (valuesIndex--) {\n                if (values[valuesIndex] === computed) {\n                    continue outer;\n                }\n            }\n            result.push(value);\n        }\n        else if (!includes(values, computed)) {\n            result.push(value);\n        }\n    }\n\n    return result;\n};\n\nconst intersect = (arrays) => {\n    const includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    const cacheHas = (cache, key) => cache.has(key);\n    const length = arrays[0].length;\n    const othLength = arrays.length;\n    const caches = new Array(othLength);\n    const result = [];\n\n    let array;\n    let maxLength = Infinity;\n    let othIndex = othLength;\n\n    while (othIndex--) {\n        array = arrays[othIndex];\n\n        maxLength = Math.min(array.length, maxLength);\n        caches[othIndex] = length >= 120 && array.length >= 120\n            ? new SetCache(othIndex && array)\n            : undefined;\n    }\n    array = arrays[0];\n\n    let index = -1;\n    const seen = caches[0];\n\n    outer:\n    while (++index < length && result.length < maxLength) {\n        let value = array[index];\n        const computed = value;\n\n        value = (value !== 0) ? value : 0;\n        if (!(seen\n            ? cacheHas(seen, computed)\n            : includes(result, computed)\n        )) {\n            othIndex = othLength;\n            while (--othIndex) {\n                const cache = caches[othIndex];\n                if (!(cache\n                    ? cacheHas(cache, computed)\n                    : includes(arrays[othIndex], computed))\n                ) {\n                    continue outer;\n                }\n            }\n            if (seen) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nconst toKey = (value) => {\n    if (typeof value === 'string' || isSymbol(value)) {\n        return value;\n    }\n    const result = `${value}`;\n    return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;\n};\n\nconst baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {\n    let result;\n\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n\n    if (result !== undefined) {\n        return result;\n    }\n\n    if (!isObject(value)) {\n        return value;\n    }\n\n    const isArr = Array.isArray(value);\n    const tag = getTag(value);\n\n    if (isArr) {\n        result = initCloneArray(value);\n\n        if (!isDeep) {\n            return copyArray(value, result);\n        }\n    } else {\n        const isFunc = typeof value === 'function';\n\n        if (tag === objectTag || tag === argsTag || (isFunc && !object)) {\n            result = (isFlat || isFunc) ? {} : initCloneObject(value);\n            if (!isDeep) {\n                return isFlat ?\n                    copySymbolsIn(value, copyObject(value, Object.keys(value), result)) :\n                    copySymbols(value, Object.assign(result, value));\n            }\n        } else {\n            if (isFunc || !CLONEABLE_TAGS[tag]) {\n                return object ? value : {};\n            }\n            result = initCloneByTag(value, tag, isDeep);\n        }\n    }\n\n    stack || (stack = new Stack);\n    const stacked = stack.get(value);\n\n    if (stacked) {\n        return stacked;\n    }\n\n    stack.set(value, result);\n\n    if (isMap(value)) {\n        value.forEach((subValue, key) => {\n            result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n        });\n\n        return result;\n    }\n\n    if (isSet(value)) {\n        value.forEach(subValue => {\n            result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n        });\n\n        return result;\n    }\n\n    if(isTypedArray(value)) {\n        return result;\n    }\n\n    const keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n    const props =  isArr ? undefined : keysFunc(value);\n\n    (props || value).forEach((subValue, key) => {\n        if (props) {\n            key = subValue;\n            subValue = value[key];\n        }\n\n        assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n    });\n\n    return result;\n};\n\nconst copySymbolsIn = (source, object) => {\n    return copyObject(source, getSymbolsIn(source), object);\n};\n\nconst parent = (object, path) => {\n    return path.length < 2 ? object : get(object, path.slice(0, -1));\n};\n\nconst set = (object, path, value) => {\n    if (!isObject(object)) {\n        return object;\n    }\n    path = castPath(path, object);\n\n    const length = path.length;\n    const lastIndex = length - 1;\n\n    let index = -1;\n    let nested = object;\n\n    while (nested != null && ++index < length) {\n        const key = toKey(path[index]);\n        let newValue = value;\n\n        if (index != lastIndex) {\n            const objValue = nested[key];\n            newValue = undefined;\n            if (newValue === undefined) {\n                newValue = isObject(objValue)\n                    ? objValue\n                    : (isIndex(path[index + 1]) ? [] : {});\n            }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n    }\n    return object;\n};\n\nconst isIndex = (value, length) => {\n    const type = typeof value;\n    length = length == null ? Number.MAX_SAFE_INTEGER : length;\n\n    return !!length &&\n    (type === 'number' ||\n        (type !== 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n};\n\nconst unset = (object, path) => {\n    path = castPath(path, object);\n    object = parent(object, path);\n    const lastSegment = path[path.length - 1];\n    return object == null || delete object[toKey(lastSegment)];\n};\n\nconst isKeyable = (value) => {\n    const type = typeof value;\n    return (type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n};\n\nconst keysIn = (object) => {\n    const result = [];\n    for (const key in object) {\n        result.push(key);\n    }\n    return result;\n};\n\nconst toPlainObject = (value) => {\n    value = Object(value);\n    const result = {};\n    for (const key in value) {\n        result[key] = value[key];\n    }\n    return result;\n};\n\nconst safeGet = (object, key) => {\n    if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n    }\n\n    if (key == '__proto__') {\n        return;\n    }\n\n    return object[key];\n};\n\nfunction createAssigner(assigner, isMerge = false) {\n    return (object, ...sources) => {\n        let index = -1;\n        let length = sources.length;\n        let customizer = length > 1 ? sources[length - 1] : undefined;\n        const guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer === 'function')\n            ? (length--, customizer)\n            : isMerge ? (a, b) => {\n                if (Array.isArray(a) && !Array.isArray(b)) {\n                    return b;\n                }\n            } : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n            customizer = length < 3 ? undefined : customizer;\n            length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n            const source = sources[index];\n            if (source) {\n                assigner(object, source, index, customizer);\n            }\n        }\n        return object;\n    };\n}\n\nconst baseMerge = (object, source, srcIndex, customizer, stack) => {\n    if (object === source) {\n        return;\n    }\n\n    forIn(source, (srcValue, key) => {\n        if (isObject(srcValue)) {\n            stack || (stack = new Stack);\n            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        } else {\n            let newValue = customizer\n                ? customizer(object[key], srcValue, `${key}`, object, source, stack)\n                : undefined;\n\n            if (newValue === undefined) {\n                newValue = srcValue;\n            }\n\n            assignMergeValue(object, key, newValue);\n        }\n    });\n};\n\nconst baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {\n    const objValue = safeGet(object, key);\n    const srcValue = safeGet(source, key);\n    const stacked = stack.get(srcValue);\n\n    if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n    }\n\n    let newValue = customizer\n        ? customizer(objValue, srcValue, `${key}`, object, source, stack)\n        : undefined;\n\n    let isCommon = newValue === undefined;\n\n    if (isCommon) {\n        const isArr = Array.isArray(srcValue);\n        const isTyped = !isArr && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isTyped) {\n            if (Array.isArray(objValue)) {\n                newValue = objValue;\n            }\n            else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n                newValue = copyArray(objValue);\n            }\n            else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n            }\n            else {\n                newValue = [];\n            }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n            newValue = objValue;\n            if (isArguments(objValue)) {\n                newValue = toPlainObject(objValue);\n            }\n            else if (typeof objValue === 'function' || !isObject(objValue)) {\n                newValue = initCloneObject(srcValue);\n            }\n        }\n        else {\n            isCommon = false;\n        }\n    }\n    if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n    }\n    assignMergeValue(object, key, newValue);\n};\n\nconst assignMergeValue = (object, key, value) => {\n    if ((value !== undefined && !eq(object[key], value)) ||\n        (value === undefined && !(key in object))) {\n        assignValue(object, key, value);\n    }\n};\n\nfunction baseFor(object, iteratee, keysFunc) {\n    const iterable = Object(object);\n    const props = keysFunc(object);\n    let { length } = props;\n    let index = -1;\n\n    while (length--) {\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n    return object;\n}\n\nconst baseForOwn = (object, iteratee) => {\n    return object && baseFor(object, iteratee, keys);\n};\n\nconst baseEach = (collection, iteratee) => {\n    if (collection == null) {\n        return collection;\n    }\n    if (!isArrayLike(collection)) {\n        return baseForOwn(collection, iteratee);\n    }\n    const length = collection.length;\n    const iterable = Object(collection);\n    let index = -1;\n\n    while (++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n        }\n    }\n    return collection;\n};\n\nfunction last(array) {\n    const length = array == null ? 0 : array.length;\n    return length ? array[length - 1] : undefined;\n}\n\nconst createSet = (Set && (1 / setToArray(new Set([undefined,-0]))[1]) == 1 / 0)\n    ? (values) => new Set(values)\n    : () => { /* no-op */ };\n\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n    if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n    }\n    return objValue;\n}\n\nfunction baseOrderBy(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = iteratees.map((iteratee) => {\n            if (Array.isArray(iteratee)) {\n                return (value) => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n\n            return iteratee;\n        });\n    } else {\n        iteratees = [(value) => value];\n    }\n\n    let criteriaIndex = -1;\n    let eachIndex = -1;\n\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n    baseEach(collection, (value) => {\n        const criteria = iteratees.map((iteratee) => iteratee(value));\n\n        result[++eachIndex] = {\n            criteria,\n            index: ++criteriaIndex,\n            value\n        };\n    });\n\n    return baseSortBy(result, (object, other) => compareMultiple(object, other, orders));\n}\n\nfunction baseSortBy(array, comparer) {\n    let { length } = array;\n\n    array.sort(comparer);\n    while (length--) {\n        array[length] = array[length].value;\n    }\n    return array;\n}\n\nfunction isStrictComparable(value) {\n    return value === value && !isObject(value);\n}\n\nfunction matchesStrictComparable(key, srcValue) {\n    return (object) => {\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue &&\n            (srcValue !== undefined || (key in Object(object)));\n    };\n}\n\nfunction hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\n\nfunction baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return (object) => {\n        const objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n            ? hasIn(object, path)\n            : baseIsEqual(srcValue, objValue);\n    };\n}\n\nfunction baseMatches(source) {\n    const matchData = getMatchData(source);\n    if (matchData.length === 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return (object) => object === source || baseIsMatch(object, source, matchData);\n}\n\nfunction getMatchData(object) {\n    const result = keys(object);\n    let length = result.length;\n\n    while (length--) {\n        const key = result[length];\n        const value = object[key];\n        result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n}\n\nfunction baseIsMatch(object, source, matchData, customizer) {\n    let index = matchData.length;\n    const length = index;\n    const noCustomizer = !customizer;\n\n    if (object == null) {\n        return !length;\n    }\n    let data;\n    let result;\n    object = Object(object);\n    while (index--) {\n        data = matchData[index];\n        if ((noCustomizer && data[2])\n            ? data[1] !== object[data[0]]\n            : !(data[0] in object)\n        ) {\n            return false;\n        }\n    }\n    while (++index < length) {\n        data = matchData[index];\n        const key = data[0];\n        const objValue = object[key];\n        const srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            const stack = new Stack;\n            if (customizer) {\n                result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, stack)\n                : result\n            )) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nfunction baseProperty(key) {\n    return (object) => object == null ? undefined : object[key];\n}\n\nfunction basePropertyDeep(path) {\n    return (object) => get(object, path);\n}\n\nfunction baseIteratee(value) {\n    if (typeof value == 'function') {\n        return value;\n    }\n    if (value == null) {\n        return (val) => val;\n    }\n    if (typeof value == 'object') {\n        return Array.isArray(value)\n            ? baseMatchesProperty(value[0], value[1])\n            : baseMatches(value);\n    }\n    return property(value);\n}\n\nfunction getIteratee() {\n    const result = baseIteratee;\n    return arguments.length ? result(arguments[0], arguments[1]) : result;\n}\n\nconst arrayReduce = (array, iteratee, accumulator, initAccum) => {\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n        accumulator = array[++index];\n    }\n    while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n};\n\nconst baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {\n    eachFunc(collection, (value, index, collection) => {\n        accumulator = initAccum\n            ? (initAccum = false, value)\n            : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n};\n\nfunction reduce(collection, iteratee, accumulator) {\n    const func = Array.isArray(collection) ? arrayReduce : baseReduce;\n    const initAccum = arguments.length < 3;\n    return func(collection, iteratee, accumulator, initAccum, baseEach);\n}\n\nconst isFlattenable = (value) => {\n    return Array.isArray(value) || isArguments(value) ||\n    !!(value && value[Symbol.isConcatSpreadable]);\n};\n\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n    let index = -1;\n    const length = array.length;\n\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten(value, depth - 1, predicate, isStrict, result);\n            } else {\n                result.push(...value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\n\nconst isArguments = (value) => {\n    return isObjectLike(value) && getTag(value) == '[object Arguments]';\n};\n\nconst basePick = (object, paths) => {\n    return basePickBy(object, paths, (value, path) => hasIn(object, path));\n};\n\nconst basePickBy = (object, paths, predicate) => {\n    let index = -1;\n    const length = paths.length;\n    const result = {};\n\n    while (++index < length) {\n        const path = paths[index];\n        const value = get(object, path);\n        if (predicate(value, path)) {\n            set(result, castPath(path, object), value);\n        }\n    }\n    return result;\n};\n\nconst isLength = (value) => {\n    return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n};\n\nconst baseHasIn = (object, key) =>{\n    return object != null && key in Object(object);\n};\n\nconst hasPath = (object, path, hasFunc) => {\n    path = castPath(path, object);\n\n    var index = -1,\n        length = path.length,\n        result = false;\n\n    while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) &&\n        (Array.isArray(object) || isArguments(object));\n};\n\nconst asciiWords = (string) => {\n    return string.match(reAsciiWord);\n};\n\nconst unicodeWords = (string) => {\n    return string.match(reUnicodeWords);\n};\n\nconst words = (string, pattern) => {\n    if (pattern === undefined) {\n        const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n        return result || [];\n    }\n    return string.match(pattern) || [];\n};\n\nconst castSlice = (array, start, end) => {\n    const { length } = array;\n    end = end === undefined ? length : end;\n    return (!start && end >= length) ? array : array.slice(start, end);\n};\n\nconst upperFirst = createCaseFirst('toUpperCase');\n\nfunction createCaseFirst(methodName) {\n    return (string) => {\n        if (!string) {\n            return '';\n        }\n\n        const strSymbols = hasUnicode(string)\n            ? stringToArray(string)\n            : undefined;\n\n        const chr = strSymbols\n            ? strSymbols[0]\n            : string[0];\n\n        const trailing = strSymbols\n            ? castSlice(strSymbols, 1).join('')\n            : string.slice(1);\n\n        return chr[methodName]() + trailing;\n    };\n}\n\nfunction matches(source) {\n    return baseMatches(baseClone(source, true));\n}\n\n// -- helper classes\nclass Stack {\n    constructor(entries) {\n        const data = this.__data__ = new ListCache(entries);\n        this.size = data.size;\n    }\n\n    clear() {\n        this.__data__ = new ListCache;\n        this.size = 0;\n    }\n\n    delete(key) {\n        const data = this.__data__;\n        const result = data['delete'](key);\n\n        this.size = data.size;\n        return result;\n    }\n\n    get(key) {\n        return this.__data__.get(key);\n    }\n\n    has(key) {\n        return this.__data__.has(key);\n    }\n\n    set(key, value) {\n        let data = this.__data__;\n        if (data instanceof ListCache) {\n            const pairs = data.__data__;\n            if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([key, value]);\n                this.size = ++data.size;\n                return this;\n            }\n            data = this.__data__ = new MapCache(pairs);\n        }\n        data.set(key, value);\n        this.size = data.size;\n        return this;\n    }\n}\n\nclass ListCache {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n\n    delete(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n\n        if (index < 0) {\n            return false;\n        }\n        const lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            data.splice(index, 1);\n        }\n        --this.size;\n        return true;\n    }\n\n    get(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n\n    has(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    set(key, value) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n\n        if (index < 0) {\n            ++this.size;\n            data.push([key, value]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n}\n\nclass MapCache {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.size = 0;\n        this.__data__ = {\n            'hash': new Hash,\n            'map': new Map,\n            'string': new Hash\n        };\n    }\n\n    delete(key) {\n        const result = getMapData(this, key)['delete'](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n\n    get(key) {\n        return getMapData(this, key).get(key);\n    }\n\n    has(key) {\n        return getMapData(this, key).has(key);\n    }\n\n    set(key, value) {\n        const data = getMapData(this, key);\n        const size = data.size;\n\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n}\n\nclass Hash {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.__data__ = Object.create(null);\n        this.size = 0;\n    }\n\n    delete(key) {\n        const result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n\n    get(key) {\n        const data = this.__data__;\n        const result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    has(key) {\n        const data = this.__data__;\n        return data[key] !== undefined;\n    }\n\n    set(key, value) {\n        const data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n}\n\nclass SetCache {\n    constructor(values) {\n        let index = -1;\n        const length = values == null ? 0 : values.length;\n\n        this.__data__ = new MapCache;\n        while (++index < length) {\n            this.add(values[index]);\n        }\n    }\n\n    add(value) {\n        this.__data__.set(value, HASH_UNDEFINED);\n        return this;\n    }\n\n    has(value) {\n        return this.__data__.has(value);\n    }\n}\n\nSetCache.prototype.push = SetCache.prototype.add;\n\n// -- top level functions\n\nconst isBoolean = function(value) {\n    var toString = Object.prototype.toString;\n    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === boolTag);\n};\n\nconst isObject = function(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function');\n};\n\nconst isNumber = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === numberTag);\n};\n\nconst isString = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === stringTag);\n};\n\nconst assign = createAssigner((object, source) => {\n    if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n    }\n    for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n            assignValue(object, key, source[key]);\n        }\n    }\n});\n\nconst mixin = assign;\n\nconst deepMixin = mixin;\n\nconst supplement = (object, ...sources) => {\n    let index = -1;\n    let length = sources.length;\n    const guard = length > 2 ? sources[2] : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n    }\n\n    while (++index < length) {\n        const source = sources[index];\n\n        if (source == null) {\n            continue;\n        }\n\n        const props = Object.keys(source);\n        const propsLength = props.length;\n        let propsIndex = -1;\n\n        while (++propsIndex < propsLength) {\n            const key = props[propsIndex];\n            const value = object[key];\n\n            if (value === undefined ||\n                (eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key))) {\n                object[key] = source[key];\n            }\n        }\n    }\n\n    return object;\n};\n\nconst defaults = supplement;\n\nconst deepSupplement = function defaultsDeep(...args) {\n    args.push(undefined, customDefaultsMerge);\n    return merge.apply(undefined, args);\n};\n\nconst defaultsDeep = deepSupplement;\n\n// _.invokeMap\nconst invoke = (collection, path, ...args) => {\n    let index = -1;\n    const isFunc = typeof path === 'function';\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n    baseEach(collection, (value) => {\n        result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);\n    });\n\n    return result;\n};\n\n// _.invoke\nconst invokeProperty = (object, path, ...args) => {\n    path = castPath(path, object);\n    object = parent(object, path);\n    const func = object == null ? object : object[toKey(last(path))];\n    return func == null ? undefined : func.apply(object, args);\n};\n\nconst sortedIndex = (array, value, iteratee) => {\n    let low = 0;\n    let high = array == null ? 0 : array.length;\n    if (high == 0) {\n        return 0;\n    }\n\n    iteratee = getIteratee(iteratee, 2);\n    value = iteratee(value);\n\n    const valIsNaN = value !== value;\n    const valIsNull = value === null;\n    const valIsSymbol = isSymbol(value);\n    const valIsUndefined = value === undefined;\n\n    while (low < high) {\n        let setLow;\n        const mid = Math.floor((low + high) / 2);\n        const computed = iteratee(array[mid]);\n        const othIsDefined = computed !== undefined;\n        const othIsNull = computed === null;\n        const othIsReflexive = computed === computed;\n        const othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n            setLow = othIsReflexive;\n        } else if (valIsUndefined) {\n            setLow = othIsReflexive &&othIsDefined;\n        } else if (valIsNull) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull;\n        } else if (valIsSymbol) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n        } else if (othIsNull || othIsSymbol) {\n            setLow = false;\n        } else {\n            setLow = computed < value;\n        }\n        if (setLow) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return Math.min(high, MAX_ARRAY_INDEX);\n};\n\nconst uniq = (array, iteratee) => {\n    let index = -1;\n    let includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    iteratee = getIteratee(iteratee, 2);\n    let isCommon = true;\n\n    const { length } = array;\n    const result = [];\n    let seen = result;\n\n    if (length >= LARGE_ARRAY_SIZE) {\n        const set = iteratee ? null : createSet(array);\n        if (set) {\n            return setToArray(set);\n        }\n        isCommon = false;\n        includes = (cache, key) => cache.has(key);\n        seen = new SetCache;\n    } else {\n        seen = iteratee ? [] : result;\n    }\n    outer:\n    while (++index < length) {\n        let value = array[index];\n        const computed = iteratee ? iteratee(value) : value;\n\n        value = (value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n            let seenIndex = seen.length;\n            while (seenIndex--) {\n                if (seen[seenIndex] === computed) {\n                    continue outer;\n                }\n            }\n            if (iteratee) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n        else if (!includes(seen, computed)) {\n            if (seen !== result) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nconst clone = (value) => baseClone(value);\n\nconst cloneDeep = (value) => baseClone(value, true);\n\nconst isEmpty = (value) => {\n    if (value == null) {\n        return true;\n    }\n    if (isArrayLike(value) &&\n        (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' ||\n            isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n    }\n    const tag = getTag(value);\n    if (tag == '[object Map]' || tag == '[object Set]') {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !baseKeys(value).length;\n    }\n    for (const key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n};\nconst isEqual = (object, other) => baseIsEqual(object, other);\n\nconst isFunction = (value) => typeof value === 'function';\n\nconst isPlainObject = (value) => {\n    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n};\n\nconst toArray = (value) => {\n    if (!value) {\n        return [];\n    }\n\n    if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n    }\n\n    if (Symbol.iterator && Symbol.iterator in Object(value)) {\n        const iterator = value[Symbol.iterator]();\n        let data;\n        const result = [];\n\n        while (!(data = iterator.next()).done) {\n            result.push(data.value);\n        }\n        return result;\n    }\n\n    const tag = getTag(value);\n    const func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n    return func(value);\n};\n\nfunction debounce(func, wait, opt) {\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n\n    let lastArgs;\n    let lastThis;\n    let maxWait;\n    let result;\n    let timerId;\n    let lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n\n    const useRaf = (!wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function');\n\n    wait = +wait || 0;\n\n    if (isObject(opt)) {\n        leading = !!opt.leading;\n        maxing = 'maxWait' in opt;\n        maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n        trailing = 'trailing' in opt ? !!opt.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n\n    function startTimer(pendingFunc, wait) {\n        if (useRaf) {\n            window.cancelAnimationFrame(timerId);\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n\n    function cancelTimer(id) {\n        if (useRaf) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n\n        return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n        timerId = undefined;\n\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n\n    debounced.cancel = () => {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    };\n    debounced.flush = () => timerId === undefined ? result : trailingEdge(Date.now());\n    debounced.pending = () => timerId !== undefined;\n\n    return debounced;\n}\n\nconst groupBy = (collection, iteratee) => {\n    iteratee = getIteratee(iteratee, 2);\n\n    return reduce(collection, (result, value) => {\n        const key = iteratee(value);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(value);\n        } else {\n            assignValue(result, key, [value]);\n        }\n        return result;\n    }, {});\n};\n\nconst sortBy = (collection, iteratees = []) => {\n    if (collection == null) {\n        return [];\n    }\n\n    const length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n    }\n\n    if (!Array.isArray(iteratees)) {\n        iteratees = [getIteratee(iteratees, 2)];\n    }\n\n    return baseOrderBy(collection, iteratees.flat(1), []);\n};\n\nconst flattenDeep = (array) => {\n    const length = array == null ? 0 : array.length;\n    return length ? baseFlatten(array, Infinity) : [];\n};\n\nconst without = (array, ...values) => isArrayLike(array) ? diff(array, values) : [];\n\nconst difference = (array, ...values) =>\n    isObjectLike(array) && isArrayLike(array) ?\n        diff(array, values.flat(1)) : [];\n\nconst intersection = (...arrays) => {\n    const mapped = arrays.map((array) =>\n        isObjectLike(array) && isArrayLike(array) ?\n            array : []\n    );\n\n    return mapped.length && mapped[0] === arrays[0] ?\n        intersect(mapped) : [];\n};\n\nconst union = (...arrays) => {\n    const array = arrays.flat(1);\n    return uniq(array);\n};\n\nconst has = (object, key) => {\n    if (object == null) {\n        return false;\n    }\n\n    if (typeof key === 'string') {\n        key = key.split('.');\n    }\n\n    let index = -1;\n    let value = object;\n\n    while (++index < key.length) {\n        if (!value || !hasOwnProperty.call(value, key[index])) {\n            return false;\n        }\n        value = value[key[index]];\n    }\n\n    return true;\n};\n\nconst result = (object, path, defaultValue) => {\n    path = castPath(path, object);\n\n    let index = -1;\n    let length = path.length;\n\n    if (!length) {\n        length = 1;\n        object = undefined;\n    }\n    while (++index < length) {\n        let value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n            index = length;\n            value = defaultValue;\n        }\n        object = typeof value === 'function' ? value.call(object) : value;\n    }\n    return object;\n};\n\nconst omit = (object, ...paths) => {\n    let result = {};\n    if (object == null) {\n        return result;\n    }\n    let isDeep = false;\n    paths = paths.flat(1).map((path) => {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n    });\n    copyObject(object, getAllKeysIn(object), result);\n    if (isDeep) {\n        result = baseClone(result, true, true, true, (value) => isPlainObject(value) ? undefined : value);\n    }\n    let length = paths.length;\n    while (length--) {\n        unset(result, paths[length]);\n    }\n    return result;\n};\n\nconst pick = (object, ...paths) => {\n    return object == null ? {} : basePick(object, paths.flat(Infinity));\n};\n\nconst bindAll = (object, ...methodNames) => {\n    methodNames.flat(1).forEach((key) => {\n        key = toKey(key);\n        assignValue(object, key, object[key].bind(object));\n    });\n    return object;\n};\n\nconst forIn = (object, iteratee = (value) => value) => {\n    let index = -1;\n    const iterable = Object(object);\n    const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n    let length = props.length;\n\n    while(length--) {\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n};\n\nconst camelCase = (string = '') => (\n    words(`${string}`.replace(/['\\u2019]/g, ''))\n        .reduce((result, word, index) => {\n            word = word.toLowerCase();\n            return result + (index ? upperFirst(word) : word);\n        }, '')\n);\n\nlet idCounter = 0;\n\nconst uniqueId = (prefix = '') => {\n    const id = ++idCounter;\n    return `${prefix}` + id;\n};\n\nconst merge = createAssigner((object, source, srcIndex, customizer) => {\n    baseMerge(object, source, srcIndex, customizer);\n}, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvdXRpbEhlbHBlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxvQkFBb0IsYUFBYTtBQUNqQztBQUNBLHNCQUFzQixlQUFlO0FBQ3JDLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixjQUFjLEVBQUUsc0VBQXNFO0FBQzFHO0FBQ0EseUJBQXlCLFFBQVEsR0FBRyxPQUFPO0FBQzNDLHlCQUF5QixjQUFjO0FBQ3ZDLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7O0FBRUE7QUFDQSwwQkFBMEIsUUFBUSxHQUFHLE9BQU87QUFDNUMsMEJBQTBCLFFBQVEsR0FBRyxPQUFPO0FBQzVDLDhCQUE4QixPQUFPO0FBQ3JDLDhCQUE4QixPQUFPO0FBQ3JDLG9CQUFvQixXQUFXO0FBQy9CLHFCQUFxQixXQUFXO0FBQ2hDLHdCQUF3QixNQUFNLEtBQUssZ0RBQWdELEdBQUcsb0JBQW9CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4Q0FBOEMsR0FBRyxNQUFNOztBQUU3RTtBQUNBLE9BQU8sUUFBUSxHQUFHLFFBQVEsR0FBRyxnQkFBZ0IsS0FBSyxrQ0FBa0M7QUFDcEYsT0FBTyxZQUFZLEdBQUcsZ0JBQWdCLEtBQUssZ0RBQWdEO0FBQzNGLE9BQU8sUUFBUSxHQUFHLFlBQVksR0FBRyxnQkFBZ0I7QUFDakQsT0FBTyxRQUFRLEdBQUcsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxPQUFPLFFBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixjQUFjOztBQUVuQztBQUNBLDRCQUE0QixZQUFZLEVBQUUsUUFBUTtBQUNsRCx1QkFBdUIsd0VBQXdFOztBQUUvRjtBQUNBLDRCQUE0QixPQUFPLEtBQUssT0FBTyxJQUFJLGlCQUFpQjs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixFQUFFO0FBQ3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRCxLQUFLO0FBQy9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVEQUF1RCxJQUFJO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPOztBQUVBO0FBQ1A7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFQTs7QUFFQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCwrQkFBK0I7QUFDL0I7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFTztBQUNQO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOztBQUVPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC91dGlsSGVscGVycy5tanM/M2ZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG4vLyAtLSBoZWxwZXIgY29uc3RhbnRzXG5jb25zdCBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5jb25zdCBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XSc7XG5jb25zdCBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuY29uc3QgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJztcbmNvbnN0IGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcbmNvbnN0IGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuY29uc3QgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5jb25zdCBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJztcbmNvbnN0IG51bGxUYWcgPSAnW29iamVjdCBOdWxsXSc7XG5jb25zdCBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuY29uc3Qgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcbmNvbnN0IHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuY29uc3QgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5jb25zdCB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuY29uc3QgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xuY29uc3QgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuY29uc3QgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nO1xuY29uc3QgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nO1xuY29uc3QgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nO1xuY29uc3QgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XSc7XG5jb25zdCBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJztcbmNvbnN0IHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xuY29uc3QgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJztcbmNvbnN0IHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XSc7XG5jb25zdCB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG5jb25zdCBDTE9ORUFCTEVfVEFHUyA9IHtcbiAgICBbYXJnc1RhZ106IHRydWUsXG4gICAgW2FycmF5VGFnXTogdHJ1ZSxcbiAgICBbYXJyYXlCdWZmZXJUYWddOiB0cnVlLFxuICAgIFtkYXRhVmlld1RhZ106IHRydWUsXG4gICAgW2Jvb2xUYWddOiB0cnVlLFxuICAgIFtkYXRlVGFnXTogdHJ1ZSxcbiAgICBbZmxvYXQzMlRhZ106IHRydWUsXG4gICAgW2Zsb2F0NjRUYWddOiB0cnVlLFxuICAgIFtpbnQ4VGFnXTogdHJ1ZSxcbiAgICBbaW50MTZUYWddOiB0cnVlLFxuICAgIFtpbnQzMlRhZ106IHRydWUsXG4gICAgW21hcFRhZ106IHRydWUsXG4gICAgW251bWJlclRhZ106IHRydWUsXG4gICAgW29iamVjdFRhZ106IHRydWUsXG4gICAgW3JlZ2V4cFRhZ106IHRydWUsXG4gICAgW3NldFRhZ106IHRydWUsXG4gICAgW3N0cmluZ1RhZ106IHRydWUsXG4gICAgW3N5bWJvbFRhZ106IHRydWUsXG4gICAgW3VpbnQ4VGFnXTogdHJ1ZSxcbiAgICBbdWludDhDbGFtcGVkVGFnXTogdHJ1ZSxcbiAgICBbdWludDE2VGFnXTogdHJ1ZSxcbiAgICBbdWludDMyVGFnXTogdHJ1ZSxcbiAgICBbZXJyb3JUYWddOiBmYWxzZSxcbiAgICBbZnVuY1RhZ106IGZhbHNlLFxuICAgIFt3ZWFrTWFwVGFnXTogZmFsc2UsXG59O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG5jb25zdCByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnO1xuY29uc3QgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2Zic7XG5jb25zdCByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZic7XG5jb25zdCByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnO1xuY29uc3QgcnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSA9ICdcXFxcdTFhYjAtXFxcXHUxYWZmJztcbmNvbnN0IHJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZSA9ICdcXFxcdTFkYzAtXFxcXHUxZGZmJztcbmNvbnN0IHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSArIHJzQ29tYm9NYXJrc0V4dGVuZGVkUmFuZ2UgKyByc0NvbWJvTWFya3NTdXBwbGVtZW50UmFuZ2U7XG5jb25zdCByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJztcbmNvbnN0IHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnO1xuY29uc3QgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JztcbmNvbnN0IHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZic7XG5jb25zdCByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2Zic7XG5jb25zdCByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnO1xuY29uc3QgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZSc7XG5jb25zdCByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5jb25zdCByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbmNvbnN0IHJzQXBvcyA9ICdbXFwnXFx1MjAxOV0nO1xuY29uc3QgcnNCcmVhayA9IGBbJHtyc0JyZWFrUmFuZ2V9XWA7XG5jb25zdCByc0NvbWJvID0gYFske3JzQ29tYm9SYW5nZX1dYDtcbmNvbnN0IHJzRGlnaXQgPSAnXFxcXGQnO1xuY29uc3QgcnNEaW5nYmF0ID0gYFske3JzRGluZ2JhdFJhbmdlfV1gO1xuY29uc3QgcnNMb3dlciA9IGBbJHtyc0xvd2VyUmFuZ2V9XWA7XG5jb25zdCByc01pc2MgPSBgW14ke3JzQXN0cmFsUmFuZ2V9JHtyc0JyZWFrUmFuZ2UgKyByc0RpZ2l0ICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2V9XWA7XG5jb25zdCByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJztcbmNvbnN0IHJzTW9kaWZpZXIgPSBgKD86JHtyc0NvbWJvfXwke3JzRml0en0pYDtcbmNvbnN0IHJzTm9uQXN0cmFsID0gYFteJHtyc0FzdHJhbFJhbmdlfV1gO1xuY29uc3QgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JztcbmNvbnN0IHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJztcbmNvbnN0IHJzVXBwZXIgPSBgWyR7cnNVcHBlclJhbmdlfV1gO1xuY29uc3QgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG5jb25zdCByc01pc2NMb3dlciA9IGAoPzoke3JzTG93ZXJ9fCR7cnNNaXNjfSlgO1xuY29uc3QgcnNNaXNjVXBwZXIgPSBgKD86JHtyc1VwcGVyfXwke3JzTWlzY30pYDtcbmNvbnN0IHJzT3B0Q29udHJMb3dlciA9IGAoPzoke3JzQXBvc30oPzpkfGxsfG18cmV8c3x0fHZlKSk/YDtcbmNvbnN0IHJzT3B0Q29udHJVcHBlciA9IGAoPzoke3JzQXBvc30oPzpEfExMfE18UkV8U3xUfFZFKSk/YDtcbmNvbnN0IHJlT3B0TW9kID0gYCR7cnNNb2RpZmllcn0/YDtcbmNvbnN0IHJzT3B0VmFyID0gYFske3JzVmFyUmFuZ2V9XT9gO1xuY29uc3QgcnNPcHRKb2luID0gYCg/OiR7cnNaV0p9KD86JHtbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKX0pJHtyc09wdFZhciArIHJlT3B0TW9kfSkqYDtcbmNvbnN0IHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJztcbmNvbnN0IHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJztcbmNvbnN0IHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbjtcbmNvbnN0IHJzRW1vamkgPSBgKD86JHtbcnNEaW5nYmF0LCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8Jyl9KSR7cnNTZXF9YDtcblxuY29uc3QgcmVVbmljb2RlV29yZHMgPSBSZWdFeHAoW1xuICAgIGAke3JzVXBwZXJ9PyR7cnNMb3dlcn0rJHtyc09wdENvbnRyTG93ZXJ9KD89JHtbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8Jyl9KWAsXG4gICAgYCR7cnNNaXNjVXBwZXJ9KyR7cnNPcHRDb250clVwcGVyfSg/PSR7W3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8Jyl9KWAsXG4gICAgYCR7cnNVcHBlcn0/JHtyc01pc2NMb3dlcn0rJHtyc09wdENvbnRyTG93ZXJ9YCxcbiAgICBgJHtyc1VwcGVyfSske3JzT3B0Q29udHJVcHBlcn1gLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICBgJHtyc0RpZ2l0fStgLFxuICAgIHJzRW1vamlcbl0uam9pbignfCcpLCAnZycpO1xuXG5jb25zdCBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuY29uc3QgSEFTSF9VTkRFRklORUQgPSAnX19oYXNoX3VuZGVmaW5lZF9fJztcblxuLy8gVXNlZCB0byBtYXRjaCBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXNcbmNvbnN0IHJlVHlwZWRUYWcgPSAvXlxcW29iamVjdCAoPzpGbG9hdCg/OjMyfDY0KXwoPzpJbnR8VWludCkoPzo4fDE2fDMyKXxVaW50OENsYW1wZWQpQXJyYXlcXF0kLztcblxuLy8gVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHNcbmNvbnN0IHJzQXN0cmFsID0gYFske3JzQXN0cmFsUmFuZ2V9XWA7XG5cbi8vIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXNcbmNvbnN0IHJzTm9uQXN0cmFsQ29tYm8gPSBgJHtyc05vbkFzdHJhbH0ke3JzQ29tYm99P2A7XG5jb25zdCByc1N5bWJvbCA9IGAoPzoke1tyc05vbkFzdHJhbENvbWJvLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpfSlgO1xuXG4vLyBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSlcbmNvbnN0IHJlVW5pY29kZSA9IFJlZ0V4cChgJHtyc0ZpdHp9KD89JHtyc0ZpdHp9KXwke3JzU3ltYm9sICsgcnNTZXF9YCwgJ2cnKTtcblxuY29uc3QgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLztcbmNvbnN0IHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuY29uc3QgY2hhckNvZGVPZkRvdCA9ICcuJy5jaGFyQ29kZUF0KDApO1xuY29uc3QgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5jb25zdCByZVByb3BOYW1lID0gUmVnRXhwKFxuICAgIC8vIE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBkb3Qgb3IgYnJhY2tldC5cbiAgICAnW14uW1xcXFxdXSsnICsgJ3wnICtcbiAgLy8gT3IgbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIGJyYWNrZXRzLlxuICAnXFxcXFsoPzonICtcbiAgICAvLyBNYXRjaCBhIG5vbi1zdHJpbmcgZXhwcmVzc2lvbi5cbiAgICAnKFteXCJcXCddW15bXSopJyArICd8JyArXG4gICAgLy8gT3IgbWF0Y2ggc3RyaW5ncyAoc3VwcG9ydHMgZXNjYXBpbmcgY2hhcmFjdGVycykuXG4gICAgJyhbXCJcXCddKSgoPzooPyFcXFxcMilbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8pXFxcXDInICtcbiAgJylcXFxcXScrICd8JyArXG4gIC8vIE9yIG1hdGNoIFwiXCIgYXMgdGhlIHNwYWNlIGJldHdlZW4gY29uc2VjdXRpdmUgZG90cyBvciBlbXB0eSBicmFja2V0cy5cbiAgJyg/PSg/OlxcXFwufFxcXFxbXFxcXF0pKD86XFxcXC58XFxcXFtcXFxcXXwkKSknXG4gICAgLCAnZycpO1xuY29uc3QgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG5jb25zdCBoYXNVbmljb2RlV29yZCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKFxuICAgIC9bYS16XVtBLVpdfFtBLVpdezJ9W2Etel18WzAtOV1bYS16QS1aXXxbYS16QS1aXVswLTldfFteYS16QS1aMC05IF0vXG4pO1xuXG5jb25zdCBNQVhfQVJSQVlfSU5ERVggPSA0Mjk0OTY3Mjk1IC0gMTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cblxuXG4vLyAtLSBoZWxwZXIgZnVuY3Rpb25zXG5jb25zdCBoYXNVbmljb2RlID0gKHN0cmluZykgPT4ge1xuICAgIHJldHVybiByZVVuaWNvZGUudGVzdChzdHJpbmcpO1xufTtcblxuY29uc3QgdW5pY29kZVRvQXJyYXkgPSAoc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xufTtcblxuY29uc3QgYXNjaWlUb0FycmF5ID0gKHN0cmluZykgPT4ge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xufTtcblxuY29uc3Qgc3RyaW5nVG9BcnJheSA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xufTtcblxuY29uc3QgdmFsdWVzID0gKG9iamVjdCkgPT4ge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXMob2JqZWN0KS5tYXAoKGtleSkgPT4gb2JqZWN0W2tleV0pO1xufTtcblxuY29uc3Qga2V5cyA9IChvYmplY3QpID0+IHtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IE9iamVjdC5rZXlzKE9iamVjdChvYmplY3QpKTtcbn07XG5cbmNvbnN0IGJhc2VLZXlzID0gKG9iamVjdCkgPT4ge1xuICAgIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgYXJyYXlMaWtlS2V5cyA9ICh2YWx1ZSwgaW5oZXJpdGVkKSA9PiB7XG4gICAgY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICBjb25zdCBpc0FyZyA9ICFpc0FyciAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT09IGFyZ3NUYWc7XG4gICAgY29uc3QgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc1R5cGVkQXJyYXkodmFsdWUpO1xuICAgIGNvbnN0IHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNUeXBlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoc2tpcEluZGV4ZXMgPyBsZW5ndGggOiAwKTtcbiAgICBsZXQgaW5kZXggPSBza2lwSW5kZXhlcyA/IC0xIDogbGVuZ3RoO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBgJHtpbmRleH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAgIGtleSA9PT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgYXNzb2NJbmRleE9mID0gKGFycmF5LCBrZXkpID0+IHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGFycmF5O1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5jb25zdCBlcSA9ICh2YWx1ZSwgb3RoZXIpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn07XG5cbmNvbnN0IGlzT2JqZWN0TGlrZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn07XG5cbmNvbnN0IGlzSXRlcmF0ZWVDYWxsID0gKHZhbHVlLCBpbmRleCwgb2JqZWN0KSA9PiB7XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbmRleDtcblxuICAgIGNvbnN0IGlzUG9zc2libGVJdGVyYXRlZSA9IHR5cGUgPT0gJ251bWJlcicgP1xuICAgICAgICAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpbmRleCA+IC0xICYmIGluZGV4IDwgb2JqZWN0Lmxlbmd0aCkgOlxuICAgICAgICAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpO1xuXG4gICAgaWYgKGlzUG9zc2libGVJdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBpc1NldCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufTtcblxuY29uc3QgaXNNYXAgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn07XG5cbmNvbnN0IGlzUHJvdG90eXBlID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IHByb3RvID0gKHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBPYmplY3QucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn07XG5cbmNvbnN0IGFzc2lnblZhbHVlID0gKG9iamVjdCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG59O1xuXG5jb25zdCBjb3B5T2JqZWN0ID0gKHNvdXJjZSwgcHJvcHMsIG9iamVjdCkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IGlzQXJyYXlMaWtlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlLmxlbmd0aCA+IC0xICYmIHZhbHVlLmxlbmd0aCAlIDEgPT09IDA7XG59O1xuXG5jb25zdCBpc1N5bWJvbCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PT0gc3ltYm9sVGFnKTtcbn07XG5cbmNvbnN0IGluaXRDbG9uZUFycmF5ID0gKGFycmF5KSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGxldCByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY29weUFycmF5ID0gKHNvdXJjZSwgYXJyYXkpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgYXJyYXkgfHwgKGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCkpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn07XG5cbmNvbnN0IGdldFRhZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbn07XG5cbmNvbnN0IGNsb25lQXJyYXlCdWZmZXIgPSAoYXJyYXlCdWZmZXIpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY2xvbmVUeXBlZEFycmF5ID0gKHR5cGVkQXJyYXksIGlzRGVlcCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59O1xuXG5jb25zdCBjbG9uZVJlZ0V4cCA9IChyZWdleHApID0+e1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgL1xcdyokLy5leGVjKHJlZ2V4cCkpO1xuICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpbml0Q2xvbmVPYmplY3QgPSAob2JqZWN0KSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgID8gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSlcbiAgICAgICAgOiB7fTtcbn07XG5cbmNvbnN0IGdldFN5bWJvbHMgPSAob2JqZWN0KSA9PiB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgcmV0dXJuIHN5bWJvbHMuZmlsdGVyKChzeW1ib2wpID0+IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpKTtcbn07XG5cbmNvbnN0IGNvcHlTeW1ib2xzID0gKHNvdXJjZSwgb2JqZWN0KSA9PiB7XG4gICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59O1xuXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICBjb25zdCBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5jb25zdCBpbml0Q2xvbmVCeVRhZyA9IChvYmplY3QsIHRhZywgaXNEZWVwKSA9PiB7XG4gICAgY29uc3QgQ29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgc3dpdGNoKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKCtvYmplY3QpO1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6XG4gICAgICAgIGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOlxuICAgICAgICBjYXNlIGludDE2VGFnOlxuICAgICAgICBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOlxuICAgICAgICBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzpcbiAgICAgICAgY2FzZSB1aW50MTZUYWc6XG4gICAgICAgIGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihvYmplY3QpO1xuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKG9iamVjdCk7XG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcjtcbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mID8gT2JqZWN0KFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKG9iamVjdCkpIDoge307XG4gICAgfVxufTtcblxuY29uc3QgaXNUeXBlZEFycmF5ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVUeXBlZFRhZy50ZXN0KGdldFRhZyh2YWx1ZSkpO1xufTtcblxuY29uc3QgZ2V0QWxsS2V5cyA9IChvYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIGlmKCFBcnJheS5pc0FycmF5KG9iamVjdCkgJiYgb2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goLi4uZ2V0U3ltYm9scyhPYmplY3Qob2JqZWN0KSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBnZXRTeW1ib2xzSW4gPSAob2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICByZXN1bHQucHVzaCguLi5nZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBnZXRBbGxLZXlzSW4gPSAob2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXN1bHQucHVzaCguLi5nZXRTeW1ib2xzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldE1hcERhdGEgPSAoeyBfX2RhdGFfXyB9LCBrZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gX19kYXRhX187XG4gICAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xufTtcblxuY29uc3QgZXF1YWxPYmplY3RzID0gKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgc3RhY2spID0+IHtcbiAgICBjb25zdCBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KTtcbiAgICBjb25zdCBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGg7XG4gICAgY29uc3Qgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKTtcbiAgICBjb25zdCBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBrZXk7XG4gICAgbGV0IGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9ialN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICBjb25zdCBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBvYmpTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gb2JqZWN0O1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgbGV0IGNvbXBhcmVkO1xuICAgIGxldCBza2lwQ3RvcjtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgY29uc3Qgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBzdGFjaykpXG4gICAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIGNvbnN0IG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGJhc2VJc0VxdWFsID0gKHZhbHVlLCBvdGhlciwgc3RhY2spID0+IHtcbiAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59O1xuXG5jb25zdCBiYXNlSXNFcXVhbERlZXAgPSAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuICAgIGxldCBvYmpJc0FyciA9IEFycmF5LmlzQXJyYXkob2JqZWN0KTtcbiAgICBjb25zdCBvdGhJc0FyciA9IEFycmF5LmlzQXJyYXkob3RoZXIpO1xuICAgIGxldCBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCk7XG4gICAgbGV0IG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgICBsZXQgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnO1xuICAgIGNvbnN0IG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZztcbiAgICBjb25zdCBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZmFsc2UsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICBjb25zdCBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyk7XG4gICAgY29uc3Qgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICBjb25zdCBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdDtcbiAgICAgICAgY29uc3Qgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIHN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufTtcblxuY29uc3QgZXF1YWxBcnJheXMgPSAoYXJyYXksIG90aGVyLCBjb21wYXJlVW5vcmRlcmVkLCBlcXVhbEZ1bmMsIHN0YWNrKSA9PiB7XG4gICAgY29uc3QgaXNQYXJ0aWFsID0gZmFsc2U7XG4gICAgY29uc3QgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgY29uc3QgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgY29uc3Qgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgaWYgKGFyclN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBjb25zdCBzZWVuID0gY29tcGFyZVVub3JkZXJlZCA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgbGV0IGNvbXBhcmVkO1xuICAgICAgICBjb25zdCBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgY29uc3Qgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBpZiAoIXNvbWUob3RoZXIsIChvdGhWYWx1ZSwgb3RoSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBzb21lID0gKGFycmF5LCBwcmVkaWNhdGUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBjYWNoZUhhcyA9IChjYWNoZSwga2V5KSA9PiB7XG4gICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufTtcblxuY29uc3QgY29tcGFyZUFycmF5QnVmZmVyVGFnID0gKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgc3RhY2spID0+IHtcbiAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlciksIHN0YWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZXF1YWxCeVRhZyA9IChvYmplY3QsIG90aGVyLCB0YWcsIGVxdWFsRnVuYywgc3RhY2spID0+IHtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheUJ1ZmZlclRhZyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlCdWZmZXJUYWcob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBgJHtvdGhlcn1gO1xuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICAgIC8vIFRoaXMgdXNlIG9mICd2YXInIGlzIGludGVudGlvbmFsLiBEb24ndCByZW1vdmUgaWYgcmVwbGFjaW5nIGFsbCBpbnN0YW5jZXMuXG4gICAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG4gICAgICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgICBjb25zdCBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIHRydWUsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICAgIHJldHVybiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbChvYmplY3QpID09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBtYXBUb0FycmF5ID0gKG1hcCkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHNldFRvQXJyYXkgPSAoc2V0KSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgaXNLZXkgPSAodmFsdWUsIG9iamVjdCkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59O1xuXG5jb25zdCBzdHJpbmdUb1BhdGggPSAoc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSBjaGFyQ29kZU9mRG90KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICB9XG4gICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgKG1hdGNoLCBleHByZXNzaW9uLCBxdW90ZSwgc3ViU3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBrZXkgPSBtYXRjaDtcbiAgICAgICAgaWYgKHF1b3RlKSB7XG4gICAgICAgICAgICBrZXkgPSBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGtleSA9IGV4cHJlc3Npb24udHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGNhc3RQYXRoID0gKHBhdGgsIG9iamVjdCkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIHJldHVybiBpc0tleShwYXRoLCBvYmplY3QpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKGAke3BhdGh9YCk7XG59O1xuXG5jb25zdCBnZXQgPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpbmRleCsrO1xuICAgIH1cblxuICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgICAgICBjb25zdCB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgY29uc3QgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIGNvbnN0IHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIGNvbnN0IG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG90aElzTnVsbCA9IG90aGVyID09PSBudWxsO1xuICAgICAgICBjb25zdCBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcjtcbiAgICAgICAgY29uc3Qgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhO1xuICAgIGNvbnN0IG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWE7XG4gICAgY29uc3QgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoO1xuICAgIGNvbnN0IG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBvcmRlciA9IGluZGV4IDwgb3JkZXJzTGVuZ3RoID8gb3JkZXJzW2luZGV4XSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGNtcEZuID0gKG9yZGVyICYmIHR5cGVvZiBvcmRlciA9PT0gJ2Z1bmN0aW9uJykgPyBvcmRlciA6IGNvbXBhcmVBc2NlbmRpbmc7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNtcEZuKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG9yZGVyICYmIHR5cGVvZiBvcmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbmNvbnN0IGRpZmYgPSAoYXJyYXksIHZhbHVlcykgPT4ge1xuICAgIGxldCBpbmNsdWRlcyA9IChhcnJheSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBhcnJheS5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICAgIH07XG4gICAgbGV0IGlzQ29tbW9uID0gdHJ1ZTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgaWYgKCFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGluY2x1ZGVzID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmhhcyhrZXkpO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICB9XG5cbiAgICBvdXRlcjpcbiAgICBmb3IgKGxldCBrZXkgaW4gYXJyYXkpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlba2V5XTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpbnRlcnNlY3QgPSAoYXJyYXlzKSA9PiB7XG4gICAgY29uc3QgaW5jbHVkZXMgPSAoYXJyYXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgYXJyYXkuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgICB9O1xuICAgIGNvbnN0IGNhY2hlSGFzID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmhhcyhrZXkpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGg7XG4gICAgY29uc3Qgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aDtcbiAgICBjb25zdCBjYWNoZXMgPSBuZXcgQXJyYXkob3RoTGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGxldCBhcnJheTtcbiAgICBsZXQgbWF4TGVuZ3RoID0gSW5maW5pdHk7XG4gICAgbGV0IG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuXG4gICAgd2hpbGUgKG90aEluZGV4LS0pIHtcbiAgICAgICAgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuXG4gICAgICAgIG1heExlbmd0aCA9IE1hdGgubWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgY2FjaGVzW290aEluZGV4XSA9IGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMFxuICAgICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBzZWVuID0gY2FjaGVzWzBdO1xuXG4gICAgb3V0ZXI6XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAodmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoIShzZWVuXG4gICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkKVxuICAgICAgICApKSB7XG4gICAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b0tleSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAke3ZhbHVlfWA7XG4gICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JbmZpbml0eSkgPyAnLTAnIDogcmVzdWx0O1xufTtcblxuY29uc3QgYmFzZUNsb25lID0gKHZhbHVlLCBpc0RlZXAgPSBmYWxzZSwgaXNGbGF0ID0gZmFsc2UsIGlzRnVsbCA9IHRydWUsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykgPT4ge1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQXJyID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgY29uc3QgdGFnID0gZ2V0VGFnKHZhbHVlKTtcblxuICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgICAgaWYgKHRhZyA9PT0gb2JqZWN0VGFnIHx8IHRhZyA9PT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0ZsYXQgP1xuICAgICAgICAgICAgICAgICAgICBjb3B5U3ltYm9sc0luKHZhbHVlLCBjb3B5T2JqZWN0KHZhbHVlLCBPYmplY3Qua2V5cyh2YWx1ZSksIHJlc3VsdCkpIDpcbiAgICAgICAgICAgICAgICAgICAgY29weVN5bWJvbHModmFsdWUsIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzRnVuYyB8fCAhQ0xPTkVBQkxFX1RBR1NbdGFnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICB9XG5cbiAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKHN1YlZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgaXNGbGF0LCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKHN1YlZhbHVlID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRmxhdCwgaXNGdWxsLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYoaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGNvbnN0IGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgY29uc3QgcHJvcHMgPSAgaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG5cbiAgICAocHJvcHMgfHwgdmFsdWUpLmZvckVhY2goKHN1YlZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgaXNGbGF0LCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY29weVN5bWJvbHNJbiA9IChzb3VyY2UsIG9iamVjdCkgPT4ge1xuICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59O1xuXG5jb25zdCBwYXJlbnQgPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGdldChvYmplY3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbn07XG5cbmNvbnN0IHNldCA9IChvYmplY3QsIHBhdGgsIHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IGlzSW5kZXggPSAodmFsdWUsIGxlbmd0aCkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAodHlwZSAhPT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59O1xuXG5jb25zdCB1bnNldCA9IChvYmplY3QsIHBhdGgpID0+IHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICBjb25zdCBsYXN0U2VnbWVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0U2VnbWVudCldO1xufTtcblxuY29uc3QgaXNLZXlhYmxlID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGUgPT09ICdib29sZWFuJylcbiAgICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59O1xuXG5jb25zdCBrZXlzSW4gPSAob2JqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b1BsYWluT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgdmFsdWUgPSBPYmplY3QodmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHNhZmVHZXQgPSAob2JqZWN0LCBrZXkpID0+IHtcbiAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIsIGlzTWVyZ2UgPSBmYWxzZSkge1xuICAgIHJldHVybiAob2JqZWN0LCAuLi5zb3VyY2VzKSA9PiB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBsZXQgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICAgIGxldCBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICAgICAgICA6IGlzTWVyZ2UgPyAoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmICFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xufVxuXG5jb25zdCBiYXNlTWVyZ2UgPSAob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykgPT4ge1xuICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9ySW4oc291cmNlLCAoc3JjVmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzcmNWYWx1ZSwgYCR7a2V5fWAsIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmNvbnN0IGJhc2VNZXJnZURlZXAgPSAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spID0+IHtcbiAgICBjb25zdCBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpO1xuICAgIGNvbnN0IHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgYCR7a2V5fWAsIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIGNvbnN0IGlzQXJyID0gQXJyYXkuaXNBcnJheShzcmNWYWx1ZSk7XG4gICAgICAgIGNvbnN0IGlzVHlwZWQgPSAhaXNBcnIgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNUeXBlZCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0TGlrZShvYmpWYWx1ZSkgJiYgaXNBcnJheUxpa2Uob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmpWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgfVxuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn07XG5cbmNvbnN0IGFzc2lnbk1lcmdlVmFsdWUgPSAob2JqZWN0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICBjb25zdCBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpO1xuICAgIGNvbnN0IHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IHByb3BzO1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3BzWysraW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG5jb25zdCBiYXNlRm9yT3duID0gKG9iamVjdCwgaXRlcmF0ZWUpID0+IHtcbiAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59O1xuXG5jb25zdCBiYXNlRWFjaCA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VGb3JPd24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICBjb25zdCBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbn07XG5cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IGNyZWF0ZVNldCA9IChTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoW3VuZGVmaW5lZCwtMF0pKVsxXSkgPT0gMSAvIDApXG4gICAgPyAodmFsdWVzKSA9PiBuZXcgU2V0KHZhbHVlcylcbiAgICA6ICgpID0+IHsgLyogbm8tb3AgKi8gfTtcblxuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzLm1hcCgoaXRlcmF0ZWUpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZXJhdGVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IGdldCh2YWx1ZSwgaXRlcmF0ZWUubGVuZ3RoID09PSAxID8gaXRlcmF0ZWVbMF0gOiBpdGVyYXRlZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gWyh2YWx1ZSkgPT4gdmFsdWVdO1xuICAgIH1cblxuICAgIGxldCBjcml0ZXJpYUluZGV4ID0gLTE7XG4gICAgbGV0IGVhY2hJbmRleCA9IC0xO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBuZXcgQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgY3JpdGVyaWEgPSBpdGVyYXRlZXMubWFwKChpdGVyYXRlZSkgPT4gaXRlcmF0ZWUodmFsdWUpKTtcblxuICAgICAgICByZXN1bHRbKytlYWNoSW5kZXhdID0ge1xuICAgICAgICAgICAgY3JpdGVyaWEsXG4gICAgICAgICAgICBpbmRleDogKytjcml0ZXJpYUluZGV4LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgKG9iamVjdCwgb3RoZXIpID0+IGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpKTtcbn1cblxuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGFycmF5O1xuXG4gICAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgIHJldHVybiAob2JqZWN0KSA9PiB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIChvYmplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgIGNvbnN0IG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gKG9iamVjdCkgPT4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSBrZXlzKG9iamVjdCk7XG4gICAgbGV0IGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVzdWx0W2xlbmd0aF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgbGV0IGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSBpbmRleDtcbiAgICBjb25zdCBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICAgICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBjb25zdCBrZXkgPSBkYXRhWzBdO1xuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBjb25zdCBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBzdGFjaylcbiAgICAgICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIChvYmplY3QpID0+IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgIHJldHVybiAob2JqZWN0KSA9PiBnZXQob2JqZWN0LCBwYXRoKTtcbn1cblxuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICh2YWwpID0+IHZhbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0ZWUoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYmFzZUl0ZXJhdGVlO1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0KGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKSA6IHJlc3VsdDtcbn1cblxuY29uc3QgYXJyYXlSZWR1Y2UgPSAoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn07XG5cbmNvbnN0IGJhc2VSZWR1Y2UgPSAoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSA9PiB7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikgPT4ge1xuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG59O1xuXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgY29uc3QgZnVuYyA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2U7XG4gICAgY29uc3QgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbn1cblxuY29uc3QgaXNGbGF0dGVuYWJsZSA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhISh2YWx1ZSAmJiB2YWx1ZVtTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlXSk7XG59O1xuXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgaXNBcmd1bWVudHMgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuY29uc3QgYmFzZVBpY2sgPSAob2JqZWN0LCBwYXRocykgPT4ge1xuICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsICh2YWx1ZSwgcGF0aCkgPT4gaGFzSW4ob2JqZWN0LCBwYXRoKSk7XG59O1xuXG5jb25zdCBiYXNlUGlja0J5ID0gKG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgICBzZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGlzTGVuZ3RoID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xufTtcblxuY29uc3QgYmFzZUhhc0luID0gKG9iamVjdCwga2V5KSA9PntcbiAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufTtcblxuY29uc3QgaGFzUGF0aCA9IChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpID0+IHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgICAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn07XG5cbmNvbnN0IGFzY2lpV29yZHMgPSAoc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCk7XG59O1xuXG5jb25zdCB1bmljb2RlV29yZHMgPSAoc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3Jkcyk7XG59O1xuXG5jb25zdCB3b3JkcyA9IChzdHJpbmcsIHBhdHRlcm4pID0+IHtcbiAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbn07XG5cbmNvbnN0IGNhc3RTbGljZSA9IChhcnJheSwgc3RhcnQsIGVuZCkgPT4ge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBhcnJheTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYXJyYXkuc2xpY2Uoc3RhcnQsIGVuZCk7XG59O1xuXG5jb25zdCB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgIHJldHVybiAoc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdHJTeW1ib2xzID0gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY29uc3QgY2hyID0gc3RyU3ltYm9sc1xuICAgICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgICA6IHN0cmluZ1swXTtcblxuICAgICAgICBjb25zdCB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgICA6IHN0cmluZy5zbGljZSgxKTtcblxuICAgICAgICByZXR1cm4gY2hyW21ldGhvZE5hbWVdKCkgKyB0cmFpbGluZztcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICByZXR1cm4gYmFzZU1hdGNoZXMoYmFzZUNsb25lKHNvdXJjZSwgdHJ1ZSkpO1xufVxuXG4vLyAtLSBoZWxwZXIgY2xhc3Nlc1xuY2xhc3MgU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgICAgICAgICBpZiAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpIHtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBMaXN0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgY29uc3QgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICBjb25zdCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgY29uc3QgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICArK3RoaXMuc2l6ZTtcbiAgICAgICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIE1hcENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICAgICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgICAgICAgICAnbWFwJzogbmV3IE1hcCxcbiAgICAgICAgICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICAgIH1cblxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpO1xuICAgICAgICBjb25zdCBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgICAgIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgIH1cblxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIHJldHVybiBkYXRhW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgU2V0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxufVxuXG5TZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IFNldENhY2hlLnByb3RvdHlwZS5hZGQ7XG5cbi8vIC0tIHRvcCBsZXZlbCBmdW5jdGlvbnNcblxuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8ICghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IGJvb2xUYWcpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzTnVtYmVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8ICghIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IG51bWJlclRhZyk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gc3RyaW5nVGFnKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcigob2JqZWN0LCBzb3VyY2UpID0+IHtcbiAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IG1peGluID0gYXNzaWduO1xuXG5leHBvcnQgY29uc3QgZGVlcE1peGluID0gbWl4aW47XG5cbmV4cG9ydCBjb25zdCBzdXBwbGVtZW50ID0gKG9iamVjdCwgLi4uc291cmNlcykgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICBjb25zdCBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuXG4gICAgICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgICAgICBsZXQgcHJvcHNJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChlcSh2YWx1ZSwgT2JqZWN0LnByb3RvdHlwZVtrZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdHMgPSBzdXBwbGVtZW50O1xuXG5leHBvcnQgY29uc3QgZGVlcFN1cHBsZW1lbnQgPSBmdW5jdGlvbiBkZWZhdWx0c0RlZXAoLi4uYXJncykge1xuICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgIHJldHVybiBtZXJnZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRzRGVlcCA9IGRlZXBTdXBwbGVtZW50O1xuXG4vLyBfLmludm9rZU1hcFxuZXhwb3J0IGNvbnN0IGludm9rZSA9IChjb2xsZWN0aW9uLCBwYXRoLCAuLi5hcmdzKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgaXNGdW5jID0gdHlwZW9mIHBhdGggPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3QgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBuZXcgQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gcGF0aC5hcHBseSh2YWx1ZSwgYXJncykgOiBpbnZva2VQcm9wZXJ0eSh2YWx1ZSwgcGF0aCwgLi4uYXJncyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gXy5pbnZva2VcbmV4cG9ydCBjb25zdCBpbnZva2VQcm9wZXJ0eSA9IChvYmplY3QsIHBhdGgsIC4uLmFyZ3MpID0+IHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICBjb25zdCBmdW5jID0gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jLmFwcGx5KG9iamVjdCwgYXJncyk7XG59O1xuXG5leHBvcnQgY29uc3Qgc29ydGVkSW5kZXggPSAoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkgPT4ge1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGhpZ2ggPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKTtcbiAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIGNvbnN0IHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlO1xuICAgIGNvbnN0IHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsO1xuICAgIGNvbnN0IHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuICAgIGNvbnN0IHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGxldCBzZXRMb3c7XG4gICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gaXRlcmF0ZWUoYXJyYXlbbWlkXSk7XG4gICAgICAgIGNvbnN0IG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsO1xuICAgICAgICBjb25zdCBvdGhJc1JlZmxleGl2ZSA9IGNvbXB1dGVkID09PSBjb21wdXRlZDtcbiAgICAgICAgY29uc3Qgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiZvdGhJc0RlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sO1xuICAgICAgICB9IGVsc2UgaWYgKG90aElzTnVsbCB8fCBvdGhJc1N5bWJvbCkge1xuICAgICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBjb21wdXRlZCA8IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xufTtcblxuZXhwb3J0IGNvbnN0IHVuaXEgPSAoYXJyYXksIGl0ZXJhdGVlKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IGluY2x1ZGVzID0gKGFycmF5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGFycmF5LmluZGV4T2YodmFsdWUpID4gLTE7XG4gICAgfTtcbiAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKTtcbiAgICBsZXQgaXNDb21tb24gPSB0cnVlO1xuXG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFycmF5O1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBzZWVuID0gcmVzdWx0O1xuXG4gICAgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSAoY2FjaGUsIGtleSkgPT4gY2FjaGUuaGFzKGtleSk7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgfVxuICAgIG91dGVyOlxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgbGV0IHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IGNsb25lID0gKHZhbHVlKSA9PiBiYXNlQ2xvbmUodmFsdWUpO1xuXG5leHBvcnQgY29uc3QgY2xvbmVEZWVwID0gKHZhbHVlKSA9PiBiYXNlQ2xvbmUodmFsdWUsIHRydWUpO1xuXG5leHBvcnQgY29uc3QgaXNFbXB0eSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICBpZiAodGFnID09ICdbb2JqZWN0IE1hcF0nIHx8IHRhZyA9PSAnW29iamVjdCBTZXRdJykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgfVxuICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydCBjb25zdCBpc0VxdWFsID0gKG9iamVjdCwgb3RoZXIpID0+IGJhc2VJc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBnZXRUYWcodmFsdWUpICE9ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKFN5bWJvbC5pdGVyYXRvciAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICBjb25zdCBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdCkge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgbGV0IGxhc3RBcmdzO1xuICAgIGxldCBsYXN0VGhpcztcbiAgICBsZXQgbWF4V2FpdDtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCB0aW1lcklkO1xuICAgIGxldCBsYXN0Q2FsbFRpbWU7XG4gICAgbGV0IGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsZXQgbGVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBtYXhpbmcgPSBmYWxzZTtcbiAgICBsZXQgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgdXNlUmFmID0gKCF3YWl0ICYmIHdhaXQgIT09IDAgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKTtcblxuICAgIHdhaXQgPSArd2FpdCB8fCAwO1xuXG4gICAgaWYgKGlzT2JqZWN0KG9wdCkpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0LmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHQ7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBNYXRoLm1heCgrb3B0Lm1heFdhaXQgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0ID8gISFvcHQudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGxhc3RBcmdzO1xuICAgICAgICBjb25zdCB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0VGltZXIocGVuZGluZ0Z1bmMsIHdhaXQpIHtcbiAgICAgICAgaWYgKHVzZVJhZikge1xuICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRpbWVySWQpO1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGVuZGluZ0Z1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHBlbmRpbmdGdW5jLCB3YWl0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5jZWxUaW1lcihpZCkge1xuICAgICAgICBpZiAodXNlUmFmKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICB0aW1lcklkID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcbiAgICAgICAgY29uc3QgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZyA/IE1hdGgubWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiB0aW1lV2FpdGluZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWU7XG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHwgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHxcbiAgICAgICAgICAgIChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lcklkID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlYm91bmNlZCguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJncztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAgICAgdGltZXJJZCA9IHN0YXJ0VGltZXIodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW5jZWxUaW1lcih0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgZGVib3VuY2VkLmZsdXNoID0gKCkgPT4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKERhdGUubm93KCkpO1xuICAgIGRlYm91bmNlZC5wZW5kaW5nID0gKCkgPT4gdGltZXJJZCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZXhwb3J0IGNvbnN0IGdyb3VwQnkgPSAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpID0+IHtcbiAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKTtcblxuICAgIHJldHVybiByZWR1Y2UoY29sbGVjdGlvbiwgKHJlc3VsdCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xufTtcblxuZXhwb3J0IGNvbnN0IHNvcnRCeSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZXMgPSBbXSkgPT4ge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbZ2V0SXRlcmF0ZWUoaXRlcmF0ZWVzLCAyKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcy5mbGF0KDEpLCBbXSk7XG59O1xuXG5leHBvcnQgY29uc3QgZmxhdHRlbkRlZXAgPSAoYXJyYXkpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIEluZmluaXR5KSA6IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IHdpdGhvdXQgPSAoYXJyYXksIC4uLnZhbHVlcykgPT4gaXNBcnJheUxpa2UoYXJyYXkpID8gZGlmZihhcnJheSwgdmFsdWVzKSA6IFtdO1xuXG5leHBvcnQgY29uc3QgZGlmZmVyZW5jZSA9IChhcnJheSwgLi4udmFsdWVzKSA9PlxuICAgIGlzT2JqZWN0TGlrZShhcnJheSkgJiYgaXNBcnJheUxpa2UoYXJyYXkpID9cbiAgICAgICAgZGlmZihhcnJheSwgdmFsdWVzLmZsYXQoMSkpIDogW107XG5cbmV4cG9ydCBjb25zdCBpbnRlcnNlY3Rpb24gPSAoLi4uYXJyYXlzKSA9PiB7XG4gICAgY29uc3QgbWFwcGVkID0gYXJyYXlzLm1hcCgoYXJyYXkpID0+XG4gICAgICAgIGlzT2JqZWN0TGlrZShhcnJheSkgJiYgaXNBcnJheUxpa2UoYXJyYXkpID9cbiAgICAgICAgICAgIGFycmF5IDogW11cbiAgICApO1xuXG4gICAgcmV0dXJuIG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0gP1xuICAgICAgICBpbnRlcnNlY3QobWFwcGVkKSA6IFtdO1xufTtcblxuZXhwb3J0IGNvbnN0IHVuaW9uID0gKC4uLmFycmF5cykgPT4ge1xuICAgIGNvbnN0IGFycmF5ID0gYXJyYXlzLmZsYXQoMSk7XG4gICAgcmV0dXJuIHVuaXEoYXJyYXkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGhhcyA9IChvYmplY3QsIGtleSkgPT4ge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGtleSA9IGtleS5zcGxpdCgnLicpO1xuICAgIH1cblxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCB2YWx1ZSA9IG9iamVjdDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwga2V5Lmxlbmd0aCkge1xuICAgICAgICBpZiAoIXZhbHVlIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXlbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWVba2V5W2luZGV4XV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3QgcmVzdWx0ID0gKG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuZXhwb3J0IGNvbnN0IG9taXQgPSAob2JqZWN0LCAuLi5wYXRocykgPT4ge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IGlzRGVlcCA9IGZhbHNlO1xuICAgIHBhdGhzID0gcGF0aHMuZmxhdCgxKS5tYXAoKHBhdGgpID0+IHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSk7XG4gICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgKHZhbHVlKSA9PiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlKTtcbiAgICB9XG4gICAgbGV0IGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydCBjb25zdCBwaWNrID0gKG9iamVjdCwgLi4ucGF0aHMpID0+IHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMuZmxhdChJbmZpbml0eSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGJpbmRBbGwgPSAob2JqZWN0LCAuLi5tZXRob2ROYW1lcykgPT4ge1xuICAgIG1ldGhvZE5hbWVzLmZsYXQoMSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBvYmplY3Rba2V5XS5iaW5kKG9iamVjdCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3QgZm9ySW4gPSAob2JqZWN0LCBpdGVyYXRlZSA9ICh2YWx1ZSkgPT4gdmFsdWUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpO1xuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGtleXNJbihvYmplY3QpO1xuICAgIGxldCBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZShsZW5ndGgtLSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1srK2luZGV4XTtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgY2FtZWxDYXNlID0gKHN0cmluZyA9ICcnKSA9PiAoXG4gICAgd29yZHMoYCR7c3RyaW5nfWAucmVwbGFjZSgvWydcXHUyMDE5XS9nLCAnJykpXG4gICAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgd29yZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gdXBwZXJGaXJzdCh3b3JkKSA6IHdvcmQpO1xuICAgICAgICB9LCAnJylcbik7XG5cbmxldCBpZENvdW50ZXIgPSAwO1xuXG5leHBvcnQgY29uc3QgdW5pcXVlSWQgPSAocHJlZml4ID0gJycpID0+IHtcbiAgICBjb25zdCBpZCA9ICsraWRDb3VudGVyO1xuICAgIHJldHVybiBgJHtwcmVmaXh9YCArIGlkO1xufTtcblxuZXhwb3J0IGNvbnN0IG1lcmdlID0gY3JlYXRlQXNzaWduZXIoKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikgPT4ge1xuICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xufSwgdHJ1ZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@joint/core/src/util/wrappers.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/util/wrappers.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrapWith: () => (/* binding */ wrapWith),\n/* harmony export */   wrappers: () => (/* binding */ wrappers)\n/* harmony export */ });\n/* harmony import */ var _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/Cell.mjs */ \"(ssr)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(ssr)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\nconst wrapWith = function(object, methods, wrapper) {\n\n    if ((0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(wrapper)) {\n\n        if (!wrappers[wrapper]) {\n            throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n        }\n\n        wrapper = wrappers[wrapper];\n    }\n\n    if (!(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(wrapper)) {\n        throw new Error('Wrapper must be a function.');\n    }\n\n    (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(methods).forEach(function(method) {\n        object[method] = wrapper(object[method]);\n    });\n};\n\nconst wrappers = {\n\n    cells: function(fn) {\n\n        return function() {\n\n            var args = Array.from(arguments);\n            var n = args.length;\n            var cells = n > 0 && args[0] || [];\n            var opt = n > 1 && args[n - 1] || {};\n\n            if (!Array.isArray(cells)) {\n\n                if (opt instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                    cells = args;\n                } else if (cells instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                    if (args.length > 1) {\n                        args.pop();\n                    }\n                    cells = args;\n                }\n            }\n\n            if (opt instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                opt = {};\n            }\n\n            return fn.call(this, cells, opt);\n        };\n    }\n\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvd3JhcHBlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUM7QUFDb0I7O0FBRXBEOztBQUVQLFFBQVEsbURBQVE7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMscURBQVU7QUFDbkI7QUFDQTs7QUFFQSxJQUFJLGtEQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQ0w7O0FBRU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLCtDQUFJO0FBQ3ZDO0FBQ0Esa0JBQWtCLDBCQUEwQiwrQ0FBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLCtDQUFJO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ3JhcGgtdmlzdWFsaXplci8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC93cmFwcGVycy5tanM/ZWQ4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi4vZGlhL0NlbGwubWpzJztcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nLCB0b0FycmF5IH0gZnJvbSAnLi91dGlsLm1qcyc7XG5cbmV4cG9ydCBjb25zdCB3cmFwV2l0aCA9IGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kcywgd3JhcHBlcikge1xuXG4gICAgaWYgKGlzU3RyaW5nKHdyYXBwZXIpKSB7XG5cbiAgICAgICAgaWYgKCF3cmFwcGVyc1t3cmFwcGVyXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHdyYXBwZXI6IFwiJyArIHdyYXBwZXIgKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyc1t3cmFwcGVyXTtcbiAgICB9XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24od3JhcHBlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcmFwcGVyIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB0b0FycmF5KG1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIG9iamVjdFttZXRob2RdID0gd3JhcHBlcihvYmplY3RbbWV0aG9kXSk7XG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3Qgd3JhcHBlcnMgPSB7XG5cbiAgICBjZWxsczogZnVuY3Rpb24oZm4pIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIG4gPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IG4gPiAwICYmIGFyZ3NbMF0gfHwgW107XG4gICAgICAgICAgICB2YXIgb3B0ID0gbiA+IDEgJiYgYXJnc1tuIC0gMV0gfHwge307XG5cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjZWxscykpIHtcblxuICAgICAgICAgICAgICAgIGlmIChvcHQgaW5zdGFuY2VvZiBDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzID0gYXJncztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNlbGxzIGluc3RhbmNlb2YgQ2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzID0gYXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHQgaW5zdGFuY2VvZiBDZWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0ID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGNlbGxzLCBvcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@joint/core/src/util/wrappers.mjs\n");

/***/ })

};
;