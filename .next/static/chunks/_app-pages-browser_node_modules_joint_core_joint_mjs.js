"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_joint_core_joint_mjs"],{

/***/ "(app-pages-browser)/./node_modules/@joint/core/dist/version.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/dist/version.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: function() { return /* binding */ version; }\n/* harmony export */ });\nvar version = \"4.1.3\";\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9kaXN0L3ZlcnNpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL2Rpc3QvdmVyc2lvbi5tanM/MjQwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdmVyc2lvbiA9IFwiNC4xLjNcIjtcblxuZXhwb3J0IHsgdmVyc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/dist/version.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/joint.mjs":
/*!********************************************!*\
  !*** ./node_modules/@joint/core/joint.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; },\n/* harmony export */   Vectorizer: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__.Vectorizer; },\n/* harmony export */   anchors: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_3__; },\n/* harmony export */   config: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_1__.config; },\n/* harmony export */   connectionPoints: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_5__; },\n/* harmony export */   connectionStrategies: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_6__; },\n/* harmony export */   connectors: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_7__; },\n/* harmony export */   dia: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_8__; },\n/* harmony export */   elementTools: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_14__; },\n/* harmony export */   env: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_2__.env; },\n/* harmony export */   g: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_17__; },\n/* harmony export */   highlighters: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_9__; },\n/* harmony export */   layout: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__.layout; },\n/* harmony export */   linkAnchors: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_4__; },\n/* harmony export */   linkTools: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_13__; },\n/* harmony export */   mvc: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_10__; },\n/* harmony export */   routers: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_11__; },\n/* harmony export */   setTheme: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__.setTheme; },\n/* harmony export */   shapes: function() { return /* reexport module object */ _src_shapes_index_mjs__WEBPACK_IMPORTED_MODULE_18__; },\n/* harmony export */   util: function() { return /* reexport module object */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_12__; },\n/* harmony export */   version: function() { return /* reexport safe */ _src_core_mjs__WEBPACK_IMPORTED_MODULE_16__.version; }\n/* harmony export */ });\n/* harmony import */ var _src_shapes_index_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/shapes/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/shapes/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/core.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/env/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/anchors/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectionPoints/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/elementTools/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/dist/version.mjs\");\n/* harmony import */ var _src_core_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/core.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\");\n\n\n// joint core\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9qb2ludC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDs7QUFFakQ7QUFzQndCOztBQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9qb2ludC5tanM/ZjExMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzaGFwZXMgZnJvbSAnLi9zcmMvc2hhcGVzL2luZGV4Lm1qcyc7XG5cbi8vIGpvaW50IGNvcmVcbmV4cG9ydCB7XG4gICAgc2V0VGhlbWUsXG4gICAgY29uZmlnLFxuICAgIGVudixcbiAgICBhbmNob3JzLFxuICAgIGxheW91dCxcbiAgICBsaW5rQW5jaG9ycyxcbiAgICBjb25uZWN0aW9uUG9pbnRzLFxuICAgIGNvbm5lY3Rpb25TdHJhdGVnaWVzLFxuICAgIGNvbm5lY3RvcnMsXG4gICAgZGlhLFxuICAgIGhpZ2hsaWdodGVycyxcbiAgICBtdmMsXG4gICAgcm91dGVycyxcbiAgICB1dGlsLFxuICAgIGxpbmtUb29scyxcbiAgICBlbGVtZW50VG9vbHMsXG4gICAgVmVjdG9yaXplcixcbiAgICBWLFxuICAgIHZlcnNpb24sXG4gICAgZ1xufSBmcm9tICcuL3NyYy9jb3JlLm1qcyc7XG5cbmV4cG9ydCB7IHNoYXBlcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/joint.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/V/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\");\n// Vectorizer.\n// -----------\n\n// A tiny library for making your life easier when dealing with SVG.\n// The only Vectorizer dependency is the Geometry library.\n\n\n\nconst V = (function() {\n\n    var hasSvg = typeof window === 'object' && !!window.SVGAngle;\n\n    // SVG support is required.\n    if (!hasSvg) {\n\n        // Return a function that throws an error when it is used.\n        return function() {\n            throw new Error('SVG is required to use Vectorizer.');\n        };\n    }\n\n    // XML namespaces.\n    var ns = {\n        svg: 'http://www.w3.org/2000/svg',\n        xmlns: 'http://www.w3.org/2000/xmlns/',\n        xml: 'http://www.w3.org/XML/1998/namespace',\n        xlink: 'http://www.w3.org/1999/xlink',\n        xhtml: 'http://www.w3.org/1999/xhtml'\n    };\n\n    var SVGVersion = '1.1';\n\n    // Declare shorthands to the most used math functions.\n    var math = Math;\n    var PI = math.PI;\n    var atan2 = math.atan2;\n    var sqrt = math.sqrt;\n    var min = math.min;\n    var max = math.max;\n    var cos = math.cos;\n    var sin = math.sin;\n\n    var V = function(el, attrs, children) {\n\n        // This allows using V() without the new keyword.\n        if (!(this instanceof V)) {\n            return V.apply(Object.create(V.prototype), arguments);\n        }\n\n        if (!el) return;\n\n        if (V.isV(el)) {\n            el = el.node;\n        }\n\n        attrs = attrs || {};\n\n        if (V.isString(el)) {\n\n            el = el.trim();\n\n            if (el.toLowerCase() === 'svg') {\n\n                // Create a new SVG canvas.\n                el = V.createSvgDocument();\n\n            } else if (el[0] === '<') {\n\n                // Create element from an SVG string.\n                // Allows constructs of type: `document.appendChild(V('<rect></rect>').node)`.\n\n                var svgDoc = V.createSvgDocument(el);\n\n                // Note that `V()` might also return an array should the SVG string passed as\n                // the first argument contain more than one root element.\n                if (svgDoc.childNodes.length > 1) {\n\n                    // Map child nodes to `V`s.\n                    var arrayOfVels = [];\n                    var i, len;\n\n                    for (i = 0, len = svgDoc.childNodes.length; i < len; i++) {\n\n                        var childNode = svgDoc.childNodes[i];\n                        arrayOfVels.push(new V(document.importNode(childNode, true)));\n                    }\n\n                    return arrayOfVels;\n                }\n\n                el = document.importNode(svgDoc.firstChild, true);\n\n            } else {\n\n                el = document.createElementNS(ns.svg, el);\n            }\n\n            V.ensureId(el);\n        }\n\n        this.node = el;\n\n        this.setAttributes(attrs);\n\n        if (children) {\n            this.append(children);\n        }\n\n        return this;\n    };\n\n    var VPrototype = V.prototype;\n\n    Object.defineProperty(VPrototype, 'id', {\n        enumerable: true,\n        get: function() {\n            return this.node.id;\n        },\n        set: function(id) {\n            this.node.id = id;\n        }\n    });\n\n    /**\n     * @param {SVGGElement} toElem\n     * @returns {SVGMatrix}\n     */\n    VPrototype.getTransformToElement = function(target) {\n        var node = this.node;\n        if (V.isSVGGraphicsElement(target) && V.isSVGGraphicsElement(node)) {\n            var targetCTM = V.toNode(target).getScreenCTM();\n            var nodeCTM = node.getScreenCTM();\n            if (targetCTM && nodeCTM) {\n                return targetCTM.inverse().multiply(nodeCTM);\n            }\n        }\n        // Could not get actual transformation matrix\n        return V.createSVGMatrix();\n    };\n\n    /**\n     * @param {SVGMatrix} matrix\n     * @param {Object=} opt\n     * @returns {Vectorizer|SVGMatrix} Setter / Getter\n     */\n    VPrototype.transform = function(matrix, opt) {\n\n        var node = this.node;\n        if (V.isUndefined(matrix)) {\n            return V.transformStringToMatrix(this.attr('transform'));\n        }\n\n        if (opt && opt.absolute) {\n            return this.attr('transform', V.matrixToTransformString(matrix));\n        }\n\n        var svgTransform = V.createSVGTransform(matrix);\n        node.transform.baseVal.appendItem(svgTransform);\n        return this;\n    };\n\n    VPrototype.translate = function(tx, ty, opt) {\n\n        opt = opt || {};\n        ty = ty || 0;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n        // Is it a getter?\n        if (V.isUndefined(tx)) {\n            return transform.translate;\n        }\n\n        transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n\n        var newTx = opt.absolute ? tx : transform.translate.tx + tx;\n        var newTy = opt.absolute ? ty : transform.translate.ty + ty;\n        var newTranslate = 'translate(' + newTx + ',' + newTy + ')';\n\n        // Note that `translate()` is always the first transformation. This is\n        // usually the desired case.\n        this.attr('transform', (newTranslate + ' ' + transformAttr).trim());\n        return this;\n    };\n\n    VPrototype.rotate = function(angle, cx, cy, opt) {\n\n        opt = opt || {};\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(angle)) {\n            return transform.rotate;\n        }\n\n        transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n\n        angle %= 360;\n\n        var newAngle = opt.absolute ? angle : transform.rotate.angle + angle;\n        var newOrigin = (cx !== undefined && cy !== undefined) ? ',' + cx + ',' + cy : '';\n        var newRotate = 'rotate(' + newAngle + newOrigin + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newRotate).trim());\n        return this;\n    };\n\n    // Note that `scale` as the only transformation does not combine with previous values.\n    VPrototype.scale = function(sx, sy) {\n\n        sy = V.isUndefined(sy) ? sx : sy;\n\n        var transformAttr = this.attr('transform') || '';\n        var transform = V.parseTransformString(transformAttr);\n        transformAttr = transform.value;\n\n        // Is it a getter?\n        if (V.isUndefined(sx)) {\n            return transform.scale;\n        }\n\n        transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n\n        var newScale = 'scale(' + sx + ',' + sy + ')';\n\n        this.attr('transform', (transformAttr + ' ' + newScale).trim());\n        return this;\n    };\n\n    // Get SVGRect that contains coordinates and dimension of the real bounding box,\n    // i.e. after transformations are applied.\n    // If `target` is specified, bounding box will be computed relatively to `target` element.\n    VPrototype.bbox = function(withoutTransformations, target) {\n\n        var box;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        if (!ownerSVGElement) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);\n        }\n\n        try {\n\n            box = node.getBBox();\n\n        } catch (e) {\n\n            // Fallback for IE.\n            box = {\n                x: node.clientLeft,\n                y: node.clientTop,\n                width: node.clientWidth,\n                height: node.clientHeight\n            };\n        }\n\n        if (withoutTransformations) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(box);\n        }\n\n        var matrix = this.getTransformToElement(target || ownerSVGElement);\n\n        return V.transformRect(box, matrix);\n    };\n\n    // Returns an SVGRect that contains coordinates and dimensions of the real bounding box,\n    // i.e. after transformations are applied.\n    // Fixes a browser implementation bug that returns incorrect bounding boxes for groups of svg elements.\n    // Takes an (Object) `opt` argument (optional) with the following attributes:\n    // (Object) `target` (optional): if not undefined, transform bounding boxes relative to `target`; if undefined, transform relative to this\n    // (Boolean) `recursive` (optional): if true, recursively enter all groups and get a union of element bounding boxes (svg bbox fix); if false or undefined, return result of native function this.node.getBBox();\n    VPrototype.getBBox = function(opt) {\n\n        var options = {};\n\n        var outputBBox;\n        var node = this.node;\n        var ownerSVGElement = node.ownerSVGElement;\n\n        // If the element is not in the live DOM, it does not have a bounding box defined and\n        // so fall back to 'zero' dimension element.\n        // If the element is not an SVGGraphicsElement, we could not measure the bounding box either\n        if (!ownerSVGElement || !V.isSVGGraphicsElement(node)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);\n        }\n\n        if (opt) {\n            if (opt.target) { // check if target exists\n                options.target = V.toNode(opt.target); // works for V objects, jquery objects, and node objects\n            }\n            if (opt.recursive) {\n                options.recursive = opt.recursive;\n            }\n        }\n\n        if (!options.recursive) {\n            try {\n                outputBBox = node.getBBox();\n            } catch (e) {\n                // Fallback for IE.\n                outputBBox = {\n                    x: node.clientLeft,\n                    y: node.clientTop,\n                    width: node.clientWidth,\n                    height: node.clientHeight\n                };\n            }\n\n            if (!options.target) {\n                // transform like this (that is, not at all)\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(outputBBox);\n            } else {\n                // transform like target\n                var matrix = this.getTransformToElement(options.target);\n                return V.transformRect(outputBBox, matrix);\n            }\n        } else { // if we want to calculate the bbox recursively\n            // browsers report correct bbox around svg elements (one that envelops the path lines tightly)\n            // but some browsers fail to report the same bbox when the elements are in a group (returning a looser bbox that also includes control points, like node.getClientRect())\n            // this happens even if we wrap a single svg element into a group!\n            // this option setting makes the function recursively enter all the groups from this and deeper, get bboxes of the elements inside, then return a union of those bboxes\n\n            var children = this.children();\n            var n = children.length;\n\n            if (n === 0) {\n                return this.getBBox({ target: options.target, recursive: false });\n            }\n\n            // recursion's initial pass-through setting:\n            // recursive passes-through just keep the target as whatever was set up here during the initial pass-through\n            if (!options.target) {\n                // transform children/descendants like this (their parent/ancestor)\n                options.target = this;\n            } // else transform children/descendants like target\n\n            for (var i = 0; i < n; i++) {\n                var currentChild = children[i];\n\n                var childBBox;\n\n                // if currentChild is not a group element, get its bbox with a nonrecursive call\n                if (currentChild.children().length === 0) {\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: false });\n                } else {\n                    // if currentChild is a group element (determined by checking the number of children), enter it with a recursive call\n                    childBBox = currentChild.getBBox({ target: options.target, recursive: true });\n                }\n\n                if (!outputBBox) {\n                    // if this is the first iteration\n                    outputBBox = childBBox;\n                } else {\n                    // make a new bounding box rectangle that contains this child's bounding box and previous bounding box\n                    outputBBox = outputBBox.union(childBBox);\n                }\n            }\n\n            return outputBBox;\n        }\n    };\n\n    // Text() helpers\n\n    function createTextPathNode(attrs, vel) {\n        attrs || (attrs = {});\n        var textPathElement = V('textPath');\n        var d = attrs.d;\n        if (d && attrs['xlink:href'] === undefined) {\n            // If `opt.attrs` is a plain string, consider it to be directly the\n            // SVG path data for the text to go along (this is a shortcut).\n            // Otherwise if it is an object and contains the `d` property, then this is our path.\n            // Wrap the text in the SVG <textPath> element that points\n            // to a path defined by `opt.attrs` inside the `<defs>` element.\n            var linkedPath = V('path').attr('d', d).appendTo(vel.defs());\n            textPathElement.attr('xlink:href', '#' + linkedPath.id);\n        }\n        if (V.isObject(attrs)) {\n            // Set attributes on the `<textPath>`. The most important one\n            // is the `xlink:href` that points to our newly created `<path/>` element in `<defs/>`.\n            // Note that we also allow the following construct:\n            // `t.text('my text', { textPath: { 'xlink:href': '#my-other-path' } })`.\n            // In other words, one can completely skip the auto-creation of the path\n            // and use any other arbitrary path that is in the document.\n            textPathElement.attr(attrs);\n        }\n        return textPathElement.node;\n    }\n\n    function annotateTextLine(lineNode, lineAnnotations, opt) {\n        opt || (opt = {});\n        var includeAnnotationIndices = opt.includeAnnotationIndices;\n        var eol = opt.eol;\n        var lineHeight = opt.lineHeight;\n        var baseSize = opt.baseSize;\n        var maxFontSize = 0;\n        var fontMetrics = {};\n        var lastJ = lineAnnotations.length - 1;\n        for (var j = 0; j <= lastJ; j++) {\n            var annotation = lineAnnotations[j];\n            var fontSize = null;\n            if (V.isObject(annotation)) {\n                var annotationAttrs = annotation.attrs;\n                var vTSpan = V('tspan', annotationAttrs);\n                var tspanNode = vTSpan.node;\n                var t = annotation.t;\n                if (eol && j === lastJ) t += eol;\n                tspanNode.textContent = t;\n                // Per annotation className\n                var annotationClass = annotationAttrs['class'];\n                if (annotationClass) vTSpan.addClass(annotationClass);\n                // If `opt.includeAnnotationIndices` is `true`,\n                // set the list of indices of all the applied annotations\n                // in the `annotations` attribute. This list is a comma\n                // separated list of indices.\n                if (includeAnnotationIndices) vTSpan.attr('annotations', annotation.annotations);\n                // Check for max font size\n                fontSize = parseFloat(annotationAttrs['font-size']);\n                if (!isFinite(fontSize)) fontSize = baseSize;\n                if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n            } else {\n                if (eol && j === lastJ) annotation += eol;\n                tspanNode = document.createTextNode(annotation || ' ');\n                if (baseSize && baseSize > maxFontSize) maxFontSize = baseSize;\n            }\n            lineNode.appendChild(tspanNode);\n        }\n\n        if (maxFontSize) fontMetrics.maxFontSize = maxFontSize;\n        if (lineHeight) {\n            fontMetrics.lineHeight = lineHeight;\n        } else if (maxFontSize) {\n            fontMetrics.lineHeight = (maxFontSize * 1.2);\n        }\n        return fontMetrics;\n    }\n\n    var emRegex = /em$/;\n\n    function convertEmToPx(em, fontSize) {\n        var numerical = parseFloat(em);\n        if (emRegex.test(em)) return numerical * fontSize;\n        return numerical;\n    }\n\n    function calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n        if (!Array.isArray(linesMetrics)) return 0;\n        var n = linesMetrics.length;\n        if (!n) return 0;\n        var lineMetrics = linesMetrics[0];\n        var flMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var rLineHeights = 0;\n        var lineHeightPx = convertEmToPx(lineHeight, baseSizePx);\n        for (var i = 1; i < n; i++) {\n            lineMetrics = linesMetrics[i];\n            var iLineHeight = convertEmToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n            rLineHeights += iLineHeight;\n        }\n        var llMaxFont = convertEmToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n        var dy;\n        switch (alignment) {\n            case 'middle':\n                dy = (flMaxFont / 2) - (0.15 * llMaxFont) - (rLineHeights / 2);\n                break;\n            case 'bottom':\n                dy = -(0.25 * llMaxFont) - rLineHeights;\n                break;\n            case 'top':\n            default:\n                dy = (0.8 * flMaxFont);\n                break;\n        }\n        return dy;\n    }\n\n    VPrototype.text = function(content, opt) {\n\n        if (content && typeof content !== 'string') throw new Error('Vectorizer: text() expects the first argument to be a string.');\n\n        // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n        // IE would otherwise collapse all spaces into one.\n        content = V.sanitizeText(content);\n        opt || (opt = {});\n        // Should we allow the text to be selected?\n        var displayEmpty = opt.displayEmpty;\n        // End of Line character\n        var eol = opt.eol;\n        // Text along path\n        var textPath = opt.textPath;\n        // Vertical shift\n        var verticalAnchor = opt.textVerticalAnchor;\n        var namedVerticalAnchor = (verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top');\n        // Horizontal shift applied to all the lines but the first.\n        var x = opt.x;\n        if (x === undefined) x = this.attr('x') || 0;\n        // Annotations\n        var iai = opt.includeAnnotationIndices;\n        var annotations = opt.annotations;\n        if (annotations && !V.isArray(annotations)) annotations = [annotations];\n        // Shift all the <tspan> but first by one line (`1em`)\n        var defaultLineHeight = opt.lineHeight;\n        var autoLineHeight = (defaultLineHeight === 'auto');\n        var lineHeight = (autoLineHeight) ? '1.5em' : (defaultLineHeight || '1em');\n        // Clearing the element\n        this.empty();\n        this.attr({\n            // Preserve spaces. In other words, we do not want consecutive spaces to get collapsed to one.\n            'xml:space': 'preserve',\n            // An empty text gets rendered into the DOM in webkit-based browsers.\n            // In order to unify this behaviour across all browsers\n            // we rather hide the text element when it's empty.\n            'display': (content || displayEmpty) ? null : 'none'\n        });\n\n        // Set default font-size if none\n        var fontSize = parseFloat(this.attr('font-size'));\n        if (!fontSize) {\n            fontSize = 16;\n            if (namedVerticalAnchor || annotations) this.attr('font-size', fontSize);\n        }\n\n        var doc = document;\n        var containerNode;\n        if (textPath) {\n            // Now all the `<tspan>`s will be inside the `<textPath>`.\n            if (typeof textPath === 'string') textPath = { d: textPath };\n            containerNode = createTextPathNode(textPath, this);\n        } else {\n            containerNode = doc.createDocumentFragment();\n        }\n        var offset = 0;\n        var lines = content.split('\\n');\n        var linesMetrics = [];\n        var annotatedY;\n        for (var i = 0, lastI = lines.length - 1; i <= lastI; i++) {\n            var dy = lineHeight;\n            var lineClassName = 'v-line';\n            var lineNode = doc.createElementNS(ns.svg, 'tspan');\n            var line = lines[i];\n            var lineMetrics;\n            if (line) {\n                if (annotations) {\n                    // Find the *compacted* annotations for this line.\n                    var lineAnnotations = V.annotateString(line, annotations, {\n                        offset: -offset,\n                        includeAnnotationIndices: iai\n                    });\n                    lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                        includeAnnotationIndices: iai,\n                        eol: (i !== lastI && eol),\n                        lineHeight: (autoLineHeight) ? null : lineHeight,\n                        baseSize: fontSize\n                    });\n                    // Get the line height based on the biggest font size in the annotations for this line.\n                    var iLineHeight = lineMetrics.lineHeight;\n                    if (iLineHeight && autoLineHeight && i !== 0) dy = iLineHeight;\n                    if (i === 0) annotatedY = lineMetrics.maxFontSize * 0.8;\n                } else {\n                    if (eol && i !== lastI) line += eol;\n                    lineNode.textContent = line;\n                }\n            } else {\n                // Make sure the textContent is never empty. If it is, add a dummy\n                // character and make it invisible, making the following lines correctly\n                // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n                lineNode.textContent = '-';\n                lineClassName += ' v-empty-line';\n                // 'opacity' needs to be specified with fill, stroke. Opacity without specification\n                // is not applied in Firefox\n                var lineNodeStyle = lineNode.style;\n                lineNodeStyle.fillOpacity = 0;\n                lineNodeStyle.strokeOpacity = 0;\n                if (annotations) {\n                    // Empty line with annotations.\n                    lineMetrics = {};\n                    lineAnnotations = V.findAnnotationsAtIndex(annotations, offset);\n                    let lineFontSize = fontSize;\n                    // Check if any of the annotations overrides the font size.\n                    for (let j = lineAnnotations.length; j > 0; j--) {\n                        const attrs = lineAnnotations[j - 1].attrs;\n                        if (!attrs || !('font-size' in attrs)) continue;\n                        const fs = parseFloat(attrs['font-size']);\n                        if (isFinite(fs)) {\n                            lineFontSize = fs;\n                            break;\n                        }\n                    }\n                    if (autoLineHeight) {\n                        if (i > 0) {\n                            dy = lineFontSize * 1.2;\n                        } else {\n                            annotatedY = lineFontSize * 0.8;\n                        }\n                    }\n                    // The font size is important for the native selection box height.\n                    lineNode.setAttribute('font-size', lineFontSize);\n                    lineMetrics.maxFontSize = lineFontSize;\n                }\n            }\n            if (lineMetrics) linesMetrics.push(lineMetrics);\n            if (i > 0) lineNode.setAttribute('dy', dy);\n            // Firefox requires 'x' to be set on the first line when inside a text path\n            if (i > 0 || textPath) lineNode.setAttribute('x', x);\n            lineNode.className.baseVal = lineClassName;\n            containerNode.appendChild(lineNode);\n            offset += line.length + 1;      // + 1 = newline character.\n        }\n        // Y Alignment calculation\n        if (namedVerticalAnchor) {\n            if (annotations) {\n                dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n            } else if (verticalAnchor === 'top') {\n                // A shortcut for top alignment. It does not depend on font-size nor line-height\n                dy = '0.8em';\n            } else {\n                var rh; // remaining height\n                if (lastI > 0) {\n                    rh = parseFloat(lineHeight) || 1;\n                    rh *= lastI;\n                    if (!emRegex.test(lineHeight)) rh /= fontSize;\n                } else {\n                    // Single-line text\n                    rh = 0;\n                }\n                switch (verticalAnchor) {\n                    case 'middle':\n                        dy = (0.3 - (rh / 2)) + 'em';\n                        break;\n                    case 'bottom':\n                        dy = (-rh - 0.3) + 'em';\n                        break;\n                }\n            }\n        } else {\n            if (verticalAnchor === 0) {\n                dy = '0em';\n            } else if (verticalAnchor) {\n                dy = verticalAnchor;\n            } else {\n                // No vertical anchor is defined\n                dy = 0;\n                // Backwards compatibility - we change the `y` attribute instead of `dy`.\n                if (this.attr('y') === null) this.attr('y', annotatedY || '0.8em');\n            }\n        }\n        containerNode.firstChild.setAttribute('dy', dy);\n        // Appending lines to the element.\n        this.append(containerNode);\n        return this;\n    };\n\n    /**\n     * @public\n     * @param {string} name\n     * @returns {Vectorizer}\n     */\n    VPrototype.removeAttr = function(name) {\n\n        const trueName = attributeNames[name];\n\n        const { ns, local } = V.qualifyAttr(trueName);\n        const el = this.node;\n\n        if (ns) {\n            if (el.hasAttributeNS(ns, local)) {\n                el.removeAttributeNS(ns, local);\n            }\n        } else if (el.hasAttribute(trueName)) {\n            el.removeAttribute(trueName);\n        }\n        return this;\n    };\n\n    VPrototype.attr = function(name, value) {\n\n        if (V.isUndefined(name)) {\n\n            // Return all attributes.\n            var attributes = this.node.attributes;\n            var attrs = {};\n\n            for (var i = 0; i < attributes.length; i++) {\n                attrs[attributes[i].name] = attributes[i].value;\n            }\n\n            return attrs;\n        }\n\n        if (V.isString(name) && V.isUndefined(value)) {\n            return this.node.getAttribute(attributeNames[name]);\n        }\n\n        if (typeof name === 'object') {\n\n            for (var attrName in name) {\n                if (name.hasOwnProperty(attrName)) {\n                    this.setAttribute(attrName, name[attrName]);\n                }\n            }\n\n        } else {\n\n            this.setAttribute(name, value);\n        }\n\n        return this;\n    };\n\n    VPrototype.normalizePath = function() {\n\n        var tagName = this.tagName();\n        if (tagName === 'PATH') {\n            this.attr('d', V.normalizePathData(this.attr('d')));\n        }\n\n        return this;\n    };\n\n    VPrototype.remove = function() {\n\n        if (this.node.parentNode) {\n            this.node.parentNode.removeChild(this.node);\n        }\n\n        return this;\n    };\n\n    VPrototype.empty = function() {\n\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n\n        return this;\n    };\n\n    /**\n     * @private\n     * @param {object} attrs\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttributes = function(attrs) {\n\n        for (var key in attrs) {\n            if (attrs.hasOwnProperty(key)) {\n                this.setAttribute(key, attrs[key]);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.append = function(els) {\n\n        if (!V.isArray(els)) {\n            els = [els];\n        }\n\n        for (var i = 0, len = els.length; i < len; i++) {\n            this.node.appendChild(V.toNode(els[i])); // lgtm [js/xss-through-dom]\n        }\n\n        return this;\n    };\n\n    VPrototype.prepend = function(els) {\n\n        var child = this.node.firstChild;\n        return child ? V(child).before(els) : this.append(els);\n    };\n\n    VPrototype.before = function(els) {\n\n        var node = this.node;\n        var parent = node.parentNode;\n\n        if (parent) {\n\n            if (!V.isArray(els)) {\n                els = [els];\n            }\n\n            for (var i = 0, len = els.length; i < len; i++) {\n                parent.insertBefore(V.toNode(els[i]), node);\n            }\n        }\n\n        return this;\n    };\n\n    VPrototype.appendTo = function(node) {\n        V.toNode(node).appendChild(this.node); // lgtm [js/xss-through-dom]\n        return this;\n    };\n\n    VPrototype.svg = function() {\n\n        return this.node instanceof window.SVGSVGElement ? this : V(this.node.ownerSVGElement);\n    };\n\n    VPrototype.tagName = function() {\n\n        return this.node.tagName.toUpperCase();\n    };\n\n    VPrototype.defs = function() {\n        var context = this.svg() || this;\n        var defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) return V(defsNode);\n        return V('defs').appendTo(context);\n    };\n\n    VPrototype.clone = function() {\n\n        var clone = V(this.node.cloneNode(true/* deep */));\n        // Note that clone inherits also ID. Therefore, we need to change it here.\n        clone.node.id = V.uniqueId();\n        return clone;\n    };\n\n    VPrototype.findOne = function(selector) {\n\n        var found = this.node.querySelector(selector);\n        return found ? V(found) : undefined;\n    };\n\n    VPrototype.find = function(selector) {\n\n        var vels = [];\n        var nodes = this.node.querySelectorAll(selector);\n\n        if (nodes) {\n\n            // Map DOM elements to `V`s.\n            for (var i = 0; i < nodes.length; i++) {\n                vels.push(V(nodes[i]));\n            }\n        }\n\n        return vels;\n    };\n\n    // Returns an array of V elements made from children of this.node.\n    VPrototype.children = function() {\n\n        var children = this.node.childNodes;\n\n        var outputArray = [];\n        for (var i = 0; i < children.length; i++) {\n            var currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                outputArray.push(V(children[i]));\n            }\n        }\n        return outputArray;\n    };\n\n    // Returns the V element from parentNode of this.node.\n    VPrototype.parent = function() {\n        return V(this.node.parentNode) || null;\n    },\n\n    // Find an index of an element inside its container.\n    VPrototype.index = function() {\n\n        var index = 0;\n        var node = this.node.previousSibling;\n\n        while (node) {\n            // nodeType 1 for ELEMENT_NODE\n            if (node.nodeType === 1) index++;\n            node = node.previousSibling;\n        }\n\n        return index;\n    };\n\n    VPrototype.findParentByClass = function(className, terminator) {\n\n        var ownerSVGElement = this.node.ownerSVGElement;\n        var node = this.node.parentNode;\n\n        while (node && node !== terminator && node !== ownerSVGElement) {\n\n            var vel = V(node);\n            if (vel.hasClass(className)) {\n                return vel;\n            }\n\n            node = node.parentNode;\n        }\n\n        return null;\n    };\n\n    // https://jsperf.com/get-common-parent\n    VPrototype.contains = function(el) {\n\n        var a = this.node;\n        var b = V.toNode(el);\n        var bup = b && b.parentNode;\n\n        return (a === bup) || !!(bup && bup.nodeType === 1 && (a.compareDocumentPosition(bup) & 16));\n    };\n\n    // Convert global point into the coordinate space of this element.\n    VPrototype.toLocalPoint = function(x, y) {\n\n        var svg = this.svg().node;\n\n        var p = svg.createSVGPoint();\n        p.x = x;\n        p.y = y;\n\n        try {\n\n            var globalPoint = p.matrixTransform(svg.getScreenCTM().inverse());\n            var globalToLocalMatrix = this.getTransformToElement(svg).inverse();\n\n        } catch (e) {\n            // IE9 throws an exception in odd cases. (`Unexpected call to method or property access`)\n            // We have to make do with the original coordianates.\n            return p;\n        }\n\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    };\n\n    VPrototype.translateCenterToPoint = function(p) {\n\n        var bbox = this.getBBox({ target: this.svg() });\n        var center = bbox.center();\n\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    };\n\n    // Efficiently auto-orient an element. This basically implements the orient=auto attribute\n    // of markers. The easiest way of understanding on what this does is to imagine the element is an\n    // arrowhead. Calling this method on the arrowhead makes it point to the `position` point while\n    // being auto-oriented (properly rotated) towards the `reference` point.\n    // `target` is the element relative to which the transformations are applied. Usually a viewport.\n    VPrototype.translateAndAutoOrient = function(position, reference, target) {\n\n        position = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(position);\n        reference =  new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(reference);\n        target || (target = this.svg());\n\n        // Clean-up previously set transformations except the scale. If we didn't clean up the\n        // previous transformations then they'd add up with the old ones. Scale is an exception as\n        // it doesn't add up, consider: `this.scale(2).scale(2).scale(2)`. The result is that the\n        // element is scaled by the factor 2, not 8.\n        var scale = this.scale();\n        this.attr('transform', '');\n        var bbox = this.getBBox({ target: target }).scale(scale.sx, scale.sy);\n\n        // 1. Translate to origin.\n        var translateToOrigin = V.createSVGTransform();\n        translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n\n        // 2. Rotate around origin.\n        var rotateAroundOrigin = V.createSVGTransform();\n        var angle = position.angleBetween(reference, position.clone().offset(1, 0));\n        if (angle) rotateAroundOrigin.setRotate(angle, 0, 0);\n\n        // 3. Translate to the `position` + the offset (half my width) towards the `reference` point.\n        var translateFromOrigin = V.createSVGTransform();\n        var finalPosition = position.clone().move(reference, bbox.width / 2);\n        translateFromOrigin.setTranslate(2 * position.x - finalPosition.x, 2 * position.y - finalPosition.y);\n\n        // 4. Get the current transformation matrix of this node\n        var ctm = this.getTransformToElement(target);\n\n        // 5. Apply transformations and the scale\n        var transform = V.createSVGTransform();\n        transform.setMatrix(\n            translateFromOrigin.matrix.multiply(\n                rotateAroundOrigin.matrix.multiply(\n                    translateToOrigin.matrix.multiply(\n                        ctm.scale(scale.sx, scale.sy)))));\n\n        this.attr('transform', V.matrixToTransformString(transform.matrix));\n\n        return this;\n    };\n\n    VPrototype.animateAlongPath = function(attrs, path) {\n\n        path = V.toNode(path);\n\n        var id = V.ensureId(path);\n        var animateMotion = V('animateMotion', attrs);\n        var mpath = V('mpath', { 'xlink:href': '#' + id });\n\n        animateMotion.append(mpath);\n\n        this.append(animateMotion);\n        try {\n            animateMotion.node.beginElement();\n        } catch (e) {\n            // Fallback for IE 9.\n            // Run the animation programmatically if FakeSmile (`http://leunen.me/fakesmile/`) present\n            if (document.documentElement.getAttribute('smiling') === 'fake') {\n                /* global getTargets:true, Animator:true, animators:true id2anim:true */\n                // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n                var animation = animateMotion.node;\n                animation.animators = [];\n\n                var animationID = animation.getAttribute('id');\n                if (animationID) id2anim[animationID] = animation;\n\n                var targets = getTargets(animation);\n                for (var i = 0, len = targets.length; i < len; i++) {\n                    var target = targets[i];\n                    var animator = new Animator(animation, target, i);\n                    animators.push(animator);\n                    animation.animators[i] = animator;\n                    animator.register();\n                }\n            }\n        }\n        return this;\n    };\n\n\n    // Split a string into an array of tokens.\n    // https://infra.spec.whatwg.org/#ascii-whitespace\n    const noHTMLWhitespaceRegex = /[^\\x20\\t\\r\\n\\f]+/g;\n    function getTokenList(str) {\n        if (!V.isString(str)) return [];\n        return str.trim().match(noHTMLWhitespaceRegex) || [];\n    }\n\n    VPrototype.hasClass = function(className) {\n        if (!V.isString(className)) return false;\n        return this.node.classList.contains(className.trim());\n    };\n\n    VPrototype.addClass = function(className) {\n        this.node.classList.add(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.removeClass = function(className) {\n        this.node.classList.remove(...getTokenList(className));\n        return this;\n    };\n\n    VPrototype.toggleClass = function(className, toAdd) {\n        const tokens = getTokenList(className);\n        for (let i = 0; i < tokens.length; i++) {\n            this.node.classList.toggle(tokens[i], toAdd);\n        }\n        return this;\n    };\n\n    // Interpolate path by discrete points. The precision of the sampling\n    // is controlled by `interval`. In other words, `sample()` will generate\n    // a point on the path starting at the beginning of the path going to the end\n    // every `interval` pixels.\n    // The sampler can be very useful for e.g. finding intersection between two\n    // paths (finding the two closest points from two samples).\n    VPrototype.sample = function(interval) {\n\n        interval = interval || 1;\n        var node = this.node;\n        var length = node.getTotalLength();\n        var samples = [];\n        var distance = 0;\n        var sample;\n        while (distance < length) {\n            sample = node.getPointAtLength(distance);\n            samples.push({ x: sample.x, y: sample.y, distance: distance });\n            distance += interval;\n        }\n        return samples;\n    };\n\n    VPrototype.convertToPath = function() {\n\n        var path = V('path');\n        path.attr(this.attr());\n        var d = this.convertToPathData();\n        if (d) {\n            path.attr('d', d);\n        }\n        return path;\n    };\n\n    VPrototype.convertToPathData = function() {\n\n        var tagName = this.tagName();\n\n        switch (tagName) {\n            case 'PATH':\n                return this.attr('d');\n            case 'LINE':\n                return V.convertLineToPathData(this.node);\n            case 'POLYGON':\n                return V.convertPolygonToPathData(this.node);\n            case 'POLYLINE':\n                return V.convertPolylineToPathData(this.node);\n            case 'ELLIPSE':\n                return V.convertEllipseToPathData(this.node);\n            case 'CIRCLE':\n                return V.convertCircleToPathData(this.node);\n            case 'RECT':\n                return V.convertRectToPathData(this.node);\n        }\n\n        throw new Error(tagName + ' cannot be converted to PATH.');\n    };\n\n    V.prototype.toGeometryShape = function() {\n        var x, y, width, height, cx, cy, r, rx, ry, points, d, x1, x2, y1, y2;\n        switch (this.tagName()) {\n\n            case 'RECT':\n                x = parseFloat(this.attr('x')) || 0;\n                y = parseFloat(this.attr('y')) || 0;\n                width = parseFloat(this.attr('width')) || 0;\n                height = parseFloat(this.attr('height')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(x, y, width, height);\n\n            case 'CIRCLE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                r = parseFloat(this.attr('r')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse({ x: cx, y: cy }, r, r);\n\n            case 'ELLIPSE':\n                cx = parseFloat(this.attr('cx')) || 0;\n                cy = parseFloat(this.attr('cy')) || 0;\n                rx = parseFloat(this.attr('rx')) || 0;\n                ry = parseFloat(this.attr('ry')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse({ x: cx, y: cy }, rx, ry);\n\n            case 'POLYLINE':\n                points = V.getPointsFromSvgNode(this);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n\n            case 'POLYGON':\n                points = V.getPointsFromSvgNode(this);\n                if (points.length > 1) points.push(points[0]);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n\n            case 'PATH':\n                d = this.attr('d');\n                if (!_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path.isDataSupported(d)) d = V.normalizePathData(d);\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path(d);\n\n            case 'LINE':\n                x1 = parseFloat(this.attr('x1')) || 0;\n                y1 = parseFloat(this.attr('y1')) || 0;\n                x2 = parseFloat(this.attr('x2')) || 0;\n                y2 = parseFloat(this.attr('y2')) || 0;\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Line({ x: x1, y: y1 }, { x: x2, y: y2 });\n        }\n\n        // Anything else is a rectangle\n        return this.getBBox();\n    };\n\n    // Find the intersection of a line starting in the center\n    // of the SVG `node` ending in the point `ref`.\n    // `target` is an SVG element to which `node`s transformations are relative to.\n    // Note that `ref` point must be in the coordinate system of the `target` for this function to work properly.\n    // Returns a point in the `target` coordinate system (the same system as `ref` is in) if\n    // an intersection is found. Returns `undefined` otherwise.\n    VPrototype.findIntersection = function(ref, target) {\n\n        var svg = this.svg().node;\n        target = target || svg;\n        var bbox = this.getBBox({ target: target });\n        var center = bbox.center();\n\n        if (!bbox.intersectionWithLineFromCenterToPoint(ref)) return undefined;\n\n        var spot;\n        var tagName = this.tagName();\n\n        // Little speed up optimization for `<rect>` element. We do not do conversion\n        // to path element and sampling but directly calculate the intersection through\n        // a transformed geometrical rectangle.\n        if (tagName === 'RECT') {\n\n            var gRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(\n                parseFloat(this.attr('x') || 0),\n                parseFloat(this.attr('y') || 0),\n                parseFloat(this.attr('width')),\n                parseFloat(this.attr('height'))\n            );\n            // Get the rect transformation matrix with regards to the SVG document.\n            var rectMatrix = this.getTransformToElement(target);\n            // Decompose the matrix to find the rotation angle.\n            var rectMatrixComponents = V.decomposeMatrix(rectMatrix);\n            // Now we want to rotate the rectangle back so that we\n            // can use `intersectionWithLineFromCenterToPoint()` passing the angle as the second argument.\n            var resetRotation = svg.createSVGTransform();\n            resetRotation.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n            var rect = V.transformRect(gRect, resetRotation.matrix.multiply(rectMatrix));\n            spot = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(rect)).intersectionWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n\n        } else if (tagName === 'PATH' || tagName === 'POLYGON' || tagName === 'POLYLINE' || tagName === 'CIRCLE' || tagName === 'ELLIPSE') {\n\n            var pathNode = (tagName === 'PATH') ? this : this.convertToPath();\n            var samples = pathNode.sample();\n            var minDistance = Infinity;\n            var closestSamples = [];\n\n            var i, sample, gp, centerDistance, refDistance, distance;\n\n            for (i = 0; i < samples.length; i++) {\n\n                sample = samples[i];\n                // Convert the sample point in the local coordinate system to the global coordinate system.\n                gp = V.createSVGPoint(sample.x, sample.y);\n                gp = gp.matrixTransform(this.getTransformToElement(target));\n                sample = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(gp);\n                centerDistance = sample.distance(center);\n                // Penalize a higher distance to the reference point by 10%.\n                // This gives better results. This is due to\n                // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n                refDistance = sample.distance(ref) * 1.1;\n                distance = centerDistance + refDistance;\n\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    closestSamples = [{ sample: sample, refDistance: refDistance }];\n                } else if (distance < minDistance + 1) {\n                    closestSamples.push({ sample: sample, refDistance: refDistance });\n                }\n            }\n\n            closestSamples.sort(function(a, b) {\n                return a.refDistance - b.refDistance;\n            });\n\n            if (closestSamples[0]) {\n                spot = closestSamples[0].sample;\n            }\n        }\n\n        return spot;\n    };\n\n    /**\n     * @private\n     * @param {string} name\n     * @param {string} value\n     * @returns {Vectorizer}\n     */\n    VPrototype.setAttribute = function(name, value) {\n\n        const el = this.node;\n\n        if (value === null) {\n            this.removeAttr(name);\n            return this;\n        }\n\n        const trueName = attributeNames[name];\n\n        const { ns } = V.qualifyAttr(trueName);\n        if (ns) {\n            // Attribute names can be namespaced. E.g. `image` elements\n            // have a `xlink:href` attribute to set the source of the image.\n            el.setAttributeNS(ns, trueName, value);\n        } else if (trueName === 'id') {\n            el.id = value;\n        } else {\n            el.setAttribute(trueName, value);\n        }\n\n        return this;\n    };\n\n    // Create an SVG document element.\n    // If `content` is passed, it will be used as the SVG content of the `<svg>` root element.\n    V.createSvgDocument = function(content) {\n\n        if (content) {\n            const XMLString = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${SVGVersion}\">${content}</svg>`;\n            const { documentElement } = V.parseXML(XMLString, { async: false });\n            return documentElement;\n        }\n\n        const svg = document.createElementNS(ns.svg, 'svg');\n        svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n        svg.setAttribute('version', SVGVersion);\n        return svg;\n    };\n\n    V.createSVGStyle = function(stylesheet) {\n        const { node } = V('style', { type: 'text/css' }, [\n            V.createCDATASection(stylesheet)\n        ]);\n        return node;\n    },\n\n    V.createCDATASection = function(data = '') {\n        const xml = document.implementation.createDocument(null, 'xml', null);\n        return xml.createCDATASection(data);\n    };\n\n    V.idCounter = 0;\n\n    // A function returning a unique identifier for this client session with every call.\n    V.uniqueId = function() {\n\n        return 'v-' + (++V.idCounter);\n    };\n\n    V.toNode = function(el) {\n\n        return V.isV(el) ? el.node : (el.nodeName && el || el[0]);\n    };\n\n    V.ensureId = function(node) {\n\n        node = V.toNode(node);\n        return node.id || (node.id = V.uniqueId());\n    };\n\n    // Replace all spaces with the Unicode No-break space (http://www.fileformat.info/info/unicode/char/a0/index.htm).\n    // IE would otherwise collapse all spaces into one. This is used in the text() method but it is\n    // also exposed so that the programmer can use it in case he needs to. This is useful e.g. in tests\n    // when you want to compare the actual DOM text content without having to add the unicode character in\n    // the place of all spaces.\n    V.sanitizeText = function(text) {\n\n        return (text || '').replace(/ /g, '\\u00A0');\n    };\n\n    V.isUndefined = function(value) {\n\n        return typeof value === 'undefined';\n    };\n\n    V.isString = function(value) {\n\n        return typeof value === 'string';\n    };\n\n    V.isObject = function(value) {\n\n        return value && (typeof value === 'object');\n    };\n\n    V.isArray = Array.isArray;\n\n    V.parseXML = function(data, opt) {\n\n        opt = opt || {};\n\n        var xml;\n\n        try {\n            var parser = new DOMParser();\n\n            if (!V.isUndefined(opt.async)) {\n                parser.async = opt.async;\n            }\n\n            xml = parser.parseFromString(data, 'text/xml');\n        } catch (error) {\n            xml = undefined;\n        }\n\n        if (!xml || xml.getElementsByTagName('parsererror').length) {\n            throw new Error('Invalid XML: ' + data);\n        }\n\n        return xml;\n    };\n\n    // Create an empty object which does not inherit any properties from `Object.prototype`.\n    // This is useful when we want to use an object as a dictionary without having to\n    // worry about inherited properties such as `toString`, `valueOf` etc.\n    const _attributeNames = Object.create(null);\n\n    // List of attributes for which not to split camel case words.\n    // It contains known SVG attribute names and may be extended with user-defined attribute names.\n    [\n        'baseFrequency',\n        'baseProfile',\n        'clipPathUnits',\n        'contentScriptType',\n        'contentStyleType',\n        'diffuseConstant',\n        'edgeMode',\n        'externalResourcesRequired',\n        'filterRes', // deprecated\n        'filterUnits',\n        'gradientTransform',\n        'gradientUnits',\n        'kernelMatrix',\n        'kernelUnitLength',\n        'keyPoints',\n        'lengthAdjust',\n        'limitingConeAngle',\n        'markerHeight',\n        'markerUnits',\n        'markerWidth',\n        'maskContentUnits',\n        'maskUnits',\n        'numOctaves',\n        'pathLength',\n        'patternContentUnits',\n        'patternTransform',\n        'patternUnits',\n        'pointsAtX',\n        'pointsAtY',\n        'pointsAtZ',\n        'preserveAlpha',\n        'preserveAspectRatio',\n        'primitiveUnits',\n        'refX',\n        'refY',\n        'requiredExtensions',\n        'requiredFeatures',\n        'specularConstant',\n        'specularExponent',\n        'spreadMethod',\n        'startOffset',\n        'stdDeviation',\n        'stitchTiles',\n        'surfaceScale',\n        'systemLanguage',\n        'tableValues',\n        'targetX',\n        'targetY',\n        'textLength',\n        'viewBox',\n        'viewTarget', // deprecated\n        'xChannelSelector',\n        'yChannelSelector',\n        'zoomAndPan' // deprecated\n    ].forEach((name) => _attributeNames[name] = name);\n\n    _attributeNames['xlinkShow'] = 'xlink:show';\n    _attributeNames['xlinkRole'] = 'xlink:role';\n    _attributeNames['xlinkActuate'] = 'xlink:actuate';\n    _attributeNames['xlinkHref'] = 'xlink:href';\n    _attributeNames['xlinkType'] = 'xlink:type';\n    _attributeNames['xlinkTitle'] = 'xlink:title';\n    _attributeNames['xmlBase'] = 'xml:base';\n    _attributeNames['xmlLang'] = 'xml:lang';\n    _attributeNames['xmlSpace'] = 'xml:space';\n\n    const attributeNames = new Proxy(_attributeNames, {\n        get(cache, name) {\n            // The cache is a dictionary of attribute names. See `_attributeNames` above.\n            // If the attribute name is not in the cache, it means that it is not\n            // a camel-case attribute name. In that case, we need to convert\n            // the attribute name to dash-separated words.\n            if (!V.supportCamelCaseAttributes) return name;\n            if (name in cache) {\n                return cache[name];\n            }\n            // Convert camel case to dash-separated words.\n            return (cache[name] = name.replace(/[A-Z]/g, '-$&').toLowerCase());\n        }\n    });\n\n    // Dictionary of attribute names\n    Object.defineProperty(V, 'attributeNames', {\n        enumerable: true,\n        value: attributeNames,\n        writable: false,\n    });\n\n    // Should camel case attributes be supported?\n    Object.defineProperty(V, 'supportCamelCaseAttributes', {\n        enumerable: true,\n        value: true,\n        writable: true,\n    });\n\n    /**\n     * @param {string} name\n     * @returns {{ns: string|null, local: string}} namespace and attribute name\n     */\n    V.qualifyAttr = function(name) {\n\n        if (name.indexOf(':') !== -1) {\n            var combinedKey = name.split(':');\n            return {\n                ns: ns[combinedKey[0]],\n                local: combinedKey[1]\n            };\n        }\n\n        return {\n            ns: null,\n            local: name\n        };\n    };\n\n    // Note: This regex allows multiple commas as separator which is incorrect in SVG\n    // This regex is used by `split()`, so it doesn't need to use /g\n    V.transformSeparatorRegex = /[ ,]+/;\n    // Note: All following regexes are more restrictive than SVG specification\n    // ReDoS mitigation: Use an anchor at the beginning of the match\n    // ReDoS mitigation: Avoid backtracking (uses `[^()]+` instead of `.*?`)\n    // ReDoS mitigation: Don't match initial `(` inside repeated part\n    // The following regex needs to use /g (= cannot use capturing groups)\n    V.transformRegex = /\\b\\w+\\([^()]+\\)/g;\n    // The following regexes need to use capturing groups (= cannot use /g)\n    V.transformFunctionRegex = /\\b(\\w+)\\(([^()]+)\\)/;\n    V.transformTranslateRegex = /\\btranslate\\(([^()]+)\\)/;\n    V.transformRotateRegex = /\\brotate\\(([^()]+)\\)/;\n    V.transformScaleRegex = /\\bscale\\(([^()]+)\\)/;\n\n    V.transformStringToMatrix = function(transform) {\n\n        // Initialize result matrix as identity matrix\n        let transformationMatrix = V.createSVGMatrix();\n\n        // Note: Multiple transform functions are allowed in `transform` string\n        // `match()` returns `null` if none found\n        const transformMatches = transform && transform.match(V.transformRegex);\n        if (!transformMatches) {\n            // Return identity matrix\n            return transformationMatrix;\n        }\n\n        const numMatches = transformMatches.length;\n        for (let i = 0; i < numMatches; i++) {\n\n            const transformMatch = transformMatches[i];\n            // Use same regex as above, but with capturing groups\n            // `match()` returns values of capturing groups as `[1]`, `[2]`\n            const transformFunctionMatch = transformMatch.match(V.transformFunctionRegex);\n            if (transformFunctionMatch) {\n\n                let sx, sy, tx, ty, angle;\n                let ctm = V.createSVGMatrix();\n                const transformFunction = transformFunctionMatch[1].toLowerCase();\n                const args = transformFunctionMatch[2].split(V.transformSeparatorRegex);\n                switch (transformFunction) {\n\n                    case 'scale':\n                        sx = parseFloat(args[0]);\n                        sy = (args[1] === undefined) ? sx : parseFloat(args[1]);\n                        ctm = ctm.scaleNonUniform(sx, sy);\n                        break;\n\n                    case 'translate':\n                        tx = parseFloat(args[0]);\n                        ty = parseFloat(args[1]);\n                        ctm = ctm.translate(tx, ty);\n                        break;\n\n                    case 'rotate':\n                        angle = parseFloat(args[0]);\n                        tx = parseFloat(args[1]) || 0;\n                        ty = parseFloat(args[2]) || 0;\n                        if (tx !== 0 || ty !== 0) {\n                            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                        } else {\n                            ctm = ctm.rotate(angle);\n                        }\n                        break;\n\n                    case 'skewx':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewX(angle);\n                        break;\n\n                    case 'skewy':\n                        angle = parseFloat(args[0]);\n                        ctm = ctm.skewY(angle);\n                        break;\n\n                    case 'matrix':\n                        ctm.a = parseFloat(args[0]);\n                        ctm.b = parseFloat(args[1]);\n                        ctm.c = parseFloat(args[2]);\n                        ctm.d = parseFloat(args[3]);\n                        ctm.e = parseFloat(args[4]);\n                        ctm.f = parseFloat(args[5]);\n                        break;\n\n                    default:\n                        continue;\n                }\n\n                // Multiply current transformation into result matrix\n                transformationMatrix = transformationMatrix.multiply(ctm);\n            }\n\n        }\n        return transformationMatrix;\n    };\n\n    V.matrixToTransformString = function(matrix) {\n        matrix || (matrix = true);\n\n        return 'matrix(' +\n            (matrix.a !== undefined ? matrix.a : 1) + ',' +\n            (matrix.b !== undefined ? matrix.b : 0) + ',' +\n            (matrix.c !== undefined ? matrix.c : 0) + ',' +\n            (matrix.d !== undefined ? matrix.d : 1) + ',' +\n            (matrix.e !== undefined ? matrix.e : 0) + ',' +\n            (matrix.f !== undefined ? matrix.f : 0) +\n            ')';\n    };\n\n    V.parseTransformString = function(transform) {\n\n        var translate, rotate, scale;\n\n        if (transform) {\n\n            var separator = V.transformSeparatorRegex;\n\n            // Special handling for `transform` with one or more matrix functions\n            if (transform.trim().indexOf('matrix') >= 0) {\n\n                // Convert EVERYTHING in `transform` string to a matrix\n                // Will combine ALL matrixes * ALL translates * ALL scales * ALL rotates\n                // Note: In non-matrix case, we only take first one of each (if any)\n                var matrix = V.transformStringToMatrix(transform);\n                var decomposedMatrix = V.decomposeMatrix(matrix);\n\n                // Extract `translate`, `scale`, `rotate` from matrix\n                translate = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n                scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n                rotate = [decomposedMatrix.rotation];\n\n                // Rewrite `transform` string in `translate scale rotate` format\n                var transformations = [];\n                if (translate[0] !== 0 || translate[1] !== 0) {\n                    transformations.push('translate(' + translate + ')');\n                }\n                if (scale[0] !== 1 || scale[1] !== 1) {\n                    transformations.push('scale(' + scale + ')');\n                }\n                if (rotate[0] !== 0) {\n                    transformations.push('rotate(' + rotate + ')');\n                }\n                transform = transformations.join(' ');\n\n            } else {\n\n                // Extract `translate`, `rotate`, `scale` functions from `transform` string\n                // Note: We only detect the first match of each (if any)\n                // `match()` returns value of capturing group as `[1]`\n                const translateMatch = transform.match(V.transformTranslateRegex);\n                if (translateMatch) {\n                    translate = translateMatch[1].split(separator);\n                }\n                const rotateMatch = transform.match(V.transformRotateRegex);\n                if (rotateMatch) {\n                    rotate = rotateMatch[1].split(separator);\n                }\n                const scaleMatch = transform.match(V.transformScaleRegex);\n                if (scaleMatch) {\n                    scale = scaleMatch[1].split(separator);\n                }\n            }\n        }\n\n        var sx = (scale && scale[0]) ? parseFloat(scale[0]) : 1;\n\n        return {\n            value: transform,\n            translate: {\n                tx: (translate && translate[0]) ? parseInt(translate[0], 10) : 0,\n                ty: (translate && translate[1]) ? parseInt(translate[1], 10) : 0\n            },\n            rotate: {\n                angle: (rotate && rotate[0]) ? parseInt(rotate[0], 10) : 0,\n                cx: (rotate && rotate[1]) ? parseInt(rotate[1], 10) : undefined,\n                cy: (rotate && rotate[2]) ? parseInt(rotate[2], 10) : undefined\n            },\n            scale: {\n                sx: sx,\n                sy: (scale && scale[1]) ? parseFloat(scale[1]) : sx\n            }\n        };\n    };\n\n    V.deltaTransformPoint = function(matrix, point) {\n\n        var dx = point.x * matrix.a + point.y * matrix.c + 0;\n        var dy = point.x * matrix.b + point.y * matrix.d + 0;\n        return { x: dx, y: dy };\n    };\n\n    V.decomposeMatrix = function(matrix) {\n\n        // @see https://gist.github.com/2052247\n\n        // calculate delta transform point\n        var px = V.deltaTransformPoint(matrix, { x: 0, y: 1 });\n        var py = V.deltaTransformPoint(matrix, { x: 1, y: 0 });\n\n        // calculate skew\n        var skewX = ((180 / PI) * atan2(px.y, px.x) - 90);\n        var skewY = ((180 / PI) * atan2(py.y, py.x));\n\n        return {\n\n            translateX: matrix.e,\n            translateY: matrix.f,\n            scaleX: sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n            scaleY: sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n            skewX: skewX,\n            skewY: skewY,\n            rotation: skewX // rotation is the same as skew x\n        };\n    };\n\n    // Return the `scale` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToScale = function(matrix) {\n\n        var a, b, c, d;\n        if (matrix) {\n            a = V.isUndefined(matrix.a) ? 1 : matrix.a;\n            d = V.isUndefined(matrix.d) ? 1 : matrix.d;\n            b = matrix.b;\n            c = matrix.c;\n        } else {\n            a = d = 1;\n        }\n        return {\n            sx: b ? sqrt(a * a + b * b) : a,\n            sy: c ? sqrt(c * c + d * d) : d\n        };\n    };\n\n    // Return the `rotate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToRotate = function(matrix) {\n\n        var p = { x: 0, y: 1 };\n        if (matrix) {\n            p = V.deltaTransformPoint(matrix, p);\n        }\n\n        return {\n            angle: _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.normalizeAngle(_g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.toDeg(atan2(p.y, p.x)) - 90)\n        };\n    };\n\n    // Return the `translate` transformation from the following equation:\n    // `translate(tx, ty) . rotate(angle) . scale(sx, sy) === matrix(a,b,c,d,e,f)`\n    V.matrixToTranslate = function(matrix) {\n\n        return {\n            tx: (matrix && matrix.e) || 0,\n            ty: (matrix && matrix.f) || 0\n        };\n    };\n\n    V.isV = function(object) {\n\n        return object instanceof V;\n    };\n\n    // For backwards compatibility:\n    V.isVElement = V.isV;\n\n    // Element implements `getBBox()`, `getCTM()` and `getScreenCTM()`\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n    V.isSVGGraphicsElement = function(node) {\n        if (!node) return false;\n        node = V.toNode(node);\n        // IE/Edge does not implement SVGGraphicsElement interface, thus check for `getScreenCTM` below\n        return node instanceof SVGElement && typeof node.getScreenCTM === 'function';\n    };\n\n    var svgDocument = V('svg').node;\n\n    V.createSVGMatrix = function(matrix) {\n\n        var svgMatrix = svgDocument.createSVGMatrix();\n        for (var component in matrix) {\n            svgMatrix[component] = matrix[component];\n        }\n\n        return svgMatrix;\n    };\n\n    V.createSVGTransform = function(matrix) {\n\n        if (!V.isUndefined(matrix)) {\n\n            if (!(matrix instanceof SVGMatrix)) {\n                matrix = V.createSVGMatrix(matrix);\n            }\n\n            return svgDocument.createSVGTransformFromMatrix(matrix);\n        }\n\n        return svgDocument.createSVGTransform();\n    };\n\n    V.createSVGPoint = function(x, y) {\n\n        var p = svgDocument.createSVGPoint();\n        p.x = x;\n        p.y = y;\n        return p;\n    };\n\n    V.transformRect = function(r, matrix) {\n\n        var p = svgDocument.createSVGPoint();\n\n        p.x = r.x;\n        p.y = r.y;\n        var corner1 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y;\n        var corner2 = p.matrixTransform(matrix);\n\n        p.x = r.x + r.width;\n        p.y = r.y + r.height;\n        var corner3 = p.matrixTransform(matrix);\n\n        p.x = r.x;\n        p.y = r.y + r.height;\n        var corner4 = p.matrixTransform(matrix);\n\n        var minX = min(corner1.x, corner2.x, corner3.x, corner4.x);\n        var maxX = max(corner1.x, corner2.x, corner3.x, corner4.x);\n        var minY = min(corner1.y, corner2.y, corner3.y, corner4.y);\n        var maxY = max(corner1.y, corner2.y, corner3.y, corner4.y);\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(minX, minY, maxX - minX, maxY - minY);\n    };\n\n    V.transformPoint = function(p, matrix) {\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(V.createSVGPoint(p.x, p.y).matrixTransform(matrix));\n    };\n\n    V.transformLine = function(l, matrix) {\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Line(\n            V.transformPoint(l.start, matrix),\n            V.transformPoint(l.end, matrix)\n        );\n    };\n\n    V.transformPolyline = function(p, matrix) {\n\n        var inPoints = (p instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline) ? p.points : p;\n        if (!V.isArray(inPoints)) inPoints = [];\n        var outPoints = [];\n        for (var i = 0, n = inPoints.length; i < n; i++) outPoints[i] = V.transformPoint(inPoints[i], matrix);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(outPoints);\n    };\n\n    // Convert a style represented as string (e.g. `'fill=\"blue\"; stroke=\"red\"'`) to\n    // an object (`{ fill: 'blue', stroke: 'red' }`).\n    V.styleToObject = function(styleString) {\n        var ret = {};\n        var styles = styleString.split(';');\n        for (var i = 0; i < styles.length; i++) {\n            var style = styles[i];\n            var pair = style.split('=');\n            ret[pair[0].trim()] = pair[1].trim();\n        }\n        return ret;\n    };\n\n    // Inspired by d3.js https://github.com/mbostock/d3/blob/master/src/svg/arc.js\n    V.createSlicePathData = function(innerRadius, outerRadius, startAngle, endAngle) {\n\n        var svgArcMax = 2 * PI - 1e-6;\n        var r0 = innerRadius;\n        var r1 = outerRadius;\n        var a0 = startAngle;\n        var a1 = endAngle;\n        var da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0);\n        var df = da < PI ? '0' : '1';\n        var c0 = cos(a0);\n        var s0 = sin(a0);\n        var c1 = cos(a1);\n        var s1 = sin(a1);\n\n        return (da >= svgArcMax)\n            ? (r0\n                ? 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'M0,' + r0\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + (-r0)\n                + 'A' + r0 + ',' + r0 + ' 0 1,0 0,' + r0\n                + 'Z'\n                : 'M0,' + r1\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + (-r1)\n                + 'A' + r1 + ',' + r1 + ' 0 1,1 0,' + r1\n                + 'Z')\n            : (r0\n                ? 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L' + r0 * c1 + ',' + r0 * s1\n                + 'A' + r0 + ',' + r0 + ' 0 ' + df + ',0 ' + r0 * c0 + ',' + r0 * s0\n                + 'Z'\n                : 'M' + r1 * c0 + ',' + r1 * s0\n                + 'A' + r1 + ',' + r1 + ' 0 ' + df + ',1 ' + r1 * c1 + ',' + r1 * s1\n                + 'L0,0'\n                + 'Z');\n    };\n\n    // Merge attributes from object `b` with attributes in object `a`.\n    // Note that this modifies the object `a`.\n    // Also important to note that attributes are merged but CSS classes are concatenated.\n    V.mergeAttrs = function(a, b) {\n\n        for (var attr in b) {\n\n            if (attr === 'class') {\n                // Concatenate classes.\n                a[attr] = a[attr] ? a[attr] + ' ' + b[attr] : b[attr];\n            } else if (attr === 'style') {\n                // `style` attribute can be an object.\n                if (V.isObject(a[attr]) && V.isObject(b[attr])) {\n                    // `style` stored in `a` is an object.\n                    a[attr] = V.mergeAttrs(a[attr], b[attr]);\n                } else if (V.isObject(a[attr])) {\n                    // `style` in `a` is an object but it's a string in `b`.\n                    // Convert the style represented as a string to an object in `b`.\n                    a[attr] = V.mergeAttrs(a[attr], V.styleToObject(b[attr]));\n                } else if (V.isObject(b[attr])) {\n                    // `style` in `a` is a string, in `b` it's an object.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), b[attr]);\n                } else {\n                    // Both styles are strings.\n                    a[attr] = V.mergeAttrs(V.styleToObject(a[attr]), V.styleToObject(b[attr]));\n                }\n            } else {\n                a[attr] = b[attr];\n            }\n        }\n\n        return a;\n    };\n\n    V.annotateString = function(t, annotations, opt) {\n\n        annotations = annotations || [];\n        opt = opt || {};\n\n        var offset = opt.offset || 0;\n        var compacted = [];\n        var batch;\n        var ret = [];\n        var item;\n        var prev;\n\n        for (var i = 0; i < t.length; i++) {\n\n            item = ret[i] = t[i];\n\n            for (var j = 0; j < annotations.length; j++) {\n\n                var annotation = annotations[j];\n                var start = annotation.start + offset;\n                var end = annotation.end + offset;\n\n                if (i >= start && i < end) {\n                    // Annotation applies.\n                    if (V.isObject(item)) {\n                        // There is more than one annotation to be applied => Merge attributes.\n                        item.attrs = V.mergeAttrs(V.mergeAttrs({}, item.attrs), annotation.attrs);\n                    } else {\n                        item = ret[i] = { t: t[i], attrs: annotation.attrs };\n                    }\n                    if (opt.includeAnnotationIndices) {\n                        (item.annotations || (item.annotations = [])).push(j);\n                    }\n                }\n            }\n\n            prev = ret[i - 1];\n\n            if (!prev) {\n\n                batch = item;\n\n            } else if (V.isObject(item) && V.isObject(prev)) {\n                // Both previous item and the current one are annotations. If the attributes\n                // didn't change, merge the text.\n                if (JSON.stringify(item.attrs) === JSON.stringify(prev.attrs)) {\n                    batch.t += item.t;\n                } else {\n                    compacted.push(batch);\n                    batch = item;\n                }\n\n            } else if (V.isObject(item)) {\n                // Previous item was a string, current item is an annotation.\n                compacted.push(batch);\n                batch = item;\n\n            } else if (V.isObject(prev)) {\n                // Previous item was an annotation, current item is a string.\n                compacted.push(batch);\n                batch = item;\n\n            } else {\n                // Both previous and current item are strings.\n                batch = (batch || '') + item;\n            }\n        }\n\n        if (batch) {\n            compacted.push(batch);\n        }\n\n        return compacted;\n    };\n\n    V.findAnnotationsAtIndex = function(annotations, index) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && index <= annotation.end) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    V.findAnnotationsBetweenIndexes = function(annotations, start, end) {\n\n        var found = [];\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if ((start >= annotation.start && start < annotation.end) || (end > annotation.start && end <= annotation.end) || (annotation.start >= start && annotation.end < end)) {\n                    found.push(annotation);\n                }\n            });\n        }\n\n        return found;\n    };\n\n    // Shift all the text annotations after character `index` by `offset` positions.\n    V.shiftAnnotations = function(annotations, index, offset) {\n\n        if (annotations) {\n\n            annotations.forEach(function(annotation) {\n\n                if (annotation.start < index && annotation.end >= index) {\n                    annotation.end += offset;\n                } else if (annotation.start >= index) {\n                    annotation.start += offset;\n                    annotation.end += offset;\n                }\n            });\n        }\n\n        return annotations;\n    };\n\n    V.convertLineToPathData = function(line) {\n\n        line = V(line);\n        var d = [\n            'M', line.attr('x1'), line.attr('y1'),\n            'L', line.attr('x2'), line.attr('y2')\n        ].join(' ');\n        return d;\n    };\n\n    V.convertPolygonToPathData = function(polygon) {\n\n        var points = V.getPointsFromSvgNode(polygon);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points) + ' Z';\n    };\n\n    V.convertPolylineToPathData = function(polyline) {\n\n        var points = V.getPointsFromSvgNode(polyline);\n        if (points.length === 0) return null;\n\n        return V.svgPointsToPath(points);\n    };\n\n    V.svgPointsToPath = function(points) {\n\n        for (var i = 0, n = points.length; i < n; i++) {\n            points[i] = points[i].x + ' ' + points[i].y;\n        }\n\n        return 'M ' + points.join(' L');\n    };\n\n    V.getPointsFromSvgNode = function(node) {\n\n        node = V.toNode(node);\n        var points = [];\n        var nodePoints = node.points;\n        if (nodePoints) {\n            for (var i = 0, n = nodePoints.numberOfItems; i < n; i++) {\n                points.push(nodePoints.getItem(i));\n            }\n        }\n\n        return points;\n    };\n\n    V.KAPPA = 0.551784;\n\n    V.convertCircleToPathData = function(circle) {\n\n        circle = V(circle);\n        var cx = parseFloat(circle.attr('cx')) || 0;\n        var cy = parseFloat(circle.attr('cy')) || 0;\n        var r = parseFloat(circle.attr('r'));\n        var cd = r * V.KAPPA; // Control distance.\n\n        var d = [\n            'M', cx, cy - r,    // Move to the first point.\n            'C', cx + cd, cy - r, cx + r, cy - cd, cx + r, cy, // I. Quadrant.\n            'C', cx + r, cy + cd, cx + cd, cy + r, cx, cy + r, // II. Quadrant.\n            'C', cx - cd, cy + r, cx - r, cy + cd, cx - r, cy, // III. Quadrant.\n            'C', cx - r, cy - cd, cx - cd, cy - r, cx, cy - r, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertEllipseToPathData = function(ellipse) {\n\n        ellipse = V(ellipse);\n        var cx = parseFloat(ellipse.attr('cx')) || 0;\n        var cy = parseFloat(ellipse.attr('cy')) || 0;\n        var rx = parseFloat(ellipse.attr('rx'));\n        var ry = parseFloat(ellipse.attr('ry')) || rx;\n        var cdx = rx * V.KAPPA; // Control distance x.\n        var cdy = ry * V.KAPPA; // Control distance y.\n\n        var d = [\n            'M', cx, cy - ry,    // Move to the first point.\n            'C', cx + cdx, cy - ry, cx + rx, cy - cdy, cx + rx, cy, // I. Quadrant.\n            'C', cx + rx, cy + cdy, cx + cdx, cy + ry, cx, cy + ry, // II. Quadrant.\n            'C', cx - cdx, cy + ry, cx - rx, cy + cdy, cx - rx, cy, // III. Quadrant.\n            'C', cx - rx, cy - cdy, cx - cdx, cy - ry, cx, cy - ry, // IV. Quadrant.\n            'Z'\n        ].join(' ');\n        return d;\n    };\n\n    V.convertRectToPathData = function(rect) {\n\n        rect = V(rect);\n\n        return V.rectToPath({\n            x: parseFloat(rect.attr('x')) || 0,\n            y: parseFloat(rect.attr('y')) || 0,\n            width: parseFloat(rect.attr('width')) || 0,\n            height: parseFloat(rect.attr('height')) || 0,\n            rx: parseFloat(rect.attr('rx')) || 0,\n            ry: parseFloat(rect.attr('ry')) || 0\n        });\n    };\n\n    // Convert a rectangle to SVG path commands. `r` is an object of the form:\n    // `{ x: [number], y: [number], width: [number], height: [number], top-ry: [number], top-ry: [number], bottom-rx: [number], bottom-ry: [number] }`,\n    // where `x, y, width, height` are the usual rectangle attributes and [top-/bottom-]rx/ry allows for\n    // specifying radius of the rectangle for all its sides (as opposed to the built-in SVG rectangle\n    // that has only `rx` and `ry` attributes).\n    V.rectToPath = function(r) {\n\n        var d;\n        var x = r.x;\n        var y = r.y;\n        var width = r.width;\n        var height = r.height;\n        var topRx = min(r.rx || r['top-rx'] || 0, width / 2);\n        var bottomRx = min(r.rx || r['bottom-rx'] || 0, width / 2);\n        var topRy = min(r.ry || r['top-ry'] || 0, height / 2);\n        var bottomRy = min(r.ry || r['bottom-ry'] || 0, height / 2);\n\n        if (topRx || bottomRx || topRy || bottomRy) {\n            d = [\n                'M', x, y + topRy,\n                'v', height - topRy - bottomRy,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, bottomRy,\n                'h', width - 2 * bottomRx,\n                'a', bottomRx, bottomRy, 0, 0, 0, bottomRx, -bottomRy,\n                'v', -(height - bottomRy - topRy),\n                'a', topRx, topRy, 0, 0, 0, -topRx, -topRy,\n                'h', -(width - 2 * topRx),\n                'a', topRx, topRy, 0, 0, 0, -topRx, topRy,\n                'Z'\n            ];\n        } else {\n            d = [\n                'M', x, y,\n                'H', x + width,\n                'V', y + height,\n                'H', x,\n                'V', y,\n                'Z'\n            ];\n        }\n\n        return d.join(' ');\n    };\n\n    // Take a path data string\n    // Return a normalized path data string\n    // If data cannot be parsed, return 'M 0 0'\n    // Highly inspired by Raphael Library (www.raphael.com)\n    V.normalizePathData = (function() {\n\n        var spaces = '\\x09\\x0a\\x0b\\x0c\\x0d\\x20\\xa0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\u2028\\u2029';\n        var pathCommand = new RegExp('([a-z])[' + spaces + ',]*((-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?[' + spaces + ']*,?[' + spaces + ']*)+)', 'ig');\n        var pathValues = new RegExp('(-?\\\\d*\\\\.?\\\\d*(?:e[\\\\-+]?\\\\d+)?)[' + spaces + ']*,?[' + spaces + ']*', 'ig');\n\n        var math = Math;\n        var PI = math.PI;\n        var sin = math.sin;\n        var cos = math.cos;\n        var tan = math.tan;\n        var asin = math.asin;\n        var sqrt = math.sqrt;\n        var abs = math.abs;\n\n        function q2c(x1, y1, ax, ay, x2, y2) {\n\n            var _13 = 1 / 3;\n            var _23 = 2 / 3;\n            return [(_13 * x1) + (_23 * ax), (_13 * y1) + (_23 * ay), (_13 * x2) + (_23 * ax), (_13 * y2) + (_23 * ay), x2, y2];\n        }\n\n        function rotate(x, y, rad) {\n\n            var X = (x * cos(rad)) - (y * sin(rad));\n            var Y = (x * sin(rad)) + (y * cos(rad));\n            return { x: X, y: Y };\n        }\n\n        function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n            // for more information of where this math came from visit:\n            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n            var _120 = (PI * 120) / 180;\n            var rad = (PI / 180) * (+angle || 0);\n            var res = [];\n            var xy;\n\n            if (!recursive) {\n                xy = rotate(x1, y1, -rad);\n                x1 = xy.x;\n                y1 = xy.y;\n\n                xy = rotate(x2, y2, -rad);\n                x2 = xy.x;\n                y2 = xy.y;\n\n                var x = (x1 - x2) / 2;\n                var y = (y1 - y2) / 2;\n                var h = ((x * x) / (rx * rx)) + ((y * y) / (ry * ry));\n\n                if (h > 1) {\n                    h = sqrt(h);\n                    rx = h * rx;\n                    ry = h * ry;\n                }\n\n                var rx2 = rx * rx;\n                var ry2 = ry * ry;\n\n                var k = ((large_arc_flag == sweep_flag) ? -1 : 1) * sqrt(abs(((rx2 * ry2) - (rx2 * y * y) - (ry2 * x * x)) / ((rx2 * y * y) + (ry2 * x * x))));\n                if (!Number.isFinite(k)) {\n                    // Arc is a single point\n                    return [x1, y1, x2, y2, x2, y2];\n                }\n\n                var cx = ((k * rx * y) / ry) + ((x1 + x2) / 2);\n                var cy = ((k * -ry * x) / rx) + ((y1 + y2) / 2);\n\n                var f1 = asin(((y1 - cy) / ry).toFixed(9));\n                var f2 = asin(((y2 - cy) / ry).toFixed(9));\n\n                f1 = ((x1 < cx) ? (PI - f1) : f1);\n                f2 = ((x2 < cx) ? (PI - f2) : f2);\n\n                if (f1 < 0) f1 = (PI * 2) + f1;\n                if (f2 < 0) f2 = (PI * 2) + f2;\n\n                if (sweep_flag && (f1 > f2)) f1 = f1 - (PI * 2);\n                if (!sweep_flag && (f2 > f1)) f2 = f2 - (PI * 2);\n\n            } else {\n                f1 = recursive[0];\n                f2 = recursive[1];\n                cx = recursive[2];\n                cy = recursive[3];\n            }\n\n            var df = f2 - f1;\n            if (abs(df) > _120) {\n                var f2old = f2;\n                var x2old = x2;\n                var y2old = y2;\n                f2 = f1 + (_120 * ((sweep_flag && (f2 > f1)) ? 1 : -1));\n                x2 = cx + (rx * cos(f2));\n                y2 = cy + (ry * sin(f2));\n                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n            }\n\n            df = f2 - f1;\n\n            var c1 = cos(f1);\n            var s1 = sin(f1);\n            var c2 = cos(f2);\n            var s2 = sin(f2);\n            var t = tan(df / 4);\n            var hx = (4 / 3) * (rx * t);\n            var hy = (4 / 3) * (ry * t);\n            var m1 = [x1, y1];\n            var m2 = [x1 + (hx * s1), y1 - (hy * c1)];\n            var m3 = [x2 + (hx * s2), y2 - (hy * c2)];\n            var m4 = [x2, y2];\n\n            m2[0] = (2 * m1[0]) - m2[0];\n            m2[1] = (2 * m1[1]) - m2[1];\n\n            if (recursive) {\n                return [m2, m3, m4].concat(res);\n            } else {\n                res = [m2, m3, m4].concat(res).join().split(',');\n                var newres = [];\n                var ii = res.length;\n                for (var i = 0; i < ii; i++) {\n                    newres[i] = (i % 2) ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n                }\n                return newres;\n            }\n        }\n\n        function parsePathString(pathString) {\n\n            if (!pathString) return null;\n\n            var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };\n            var data = [];\n\n            String(pathString).replace(pathCommand, function(a, b, c) {\n\n                var params = [];\n                var name = b.toLowerCase();\n                c.replace(pathValues, function(a, b) {\n                    if (b) params.push(+b);\n                });\n\n                if ((name === 'm') && (params.length > 2)) {\n                    data.push([b].concat(params.splice(0, 2)));\n                    name = 'l';\n                    b = ((b === 'm') ? 'l' : 'L');\n                }\n\n                while (params.length >= paramCounts[name]) {\n                    data.push([b].concat(params.splice(0, paramCounts[name])));\n                    if (!paramCounts[name]) break;\n                }\n            });\n\n            return data;\n        }\n\n        function pathToAbsolute(pathArray) {\n\n            if (!Array.isArray(pathArray) || !Array.isArray(pathArray && pathArray[0])) { // rough assumption\n                pathArray = parsePathString(pathArray);\n            }\n\n            // if invalid string, return 'M 0 0'\n            if (!pathArray || !pathArray.length) return [['M', 0, 0]];\n\n            var res = [];\n            var x = 0;\n            var y = 0;\n            var mx = 0;\n            var my = 0;\n            var start = 0;\n            var pa0;\n\n            var ii = pathArray.length;\n            for (var i = start; i < ii; i++) {\n\n                var r = [];\n                res.push(r);\n\n                var pa = pathArray[i];\n                pa0 = pa[0];\n\n                if (pa0 != pa0.toUpperCase()) {\n                    r[0] = pa0.toUpperCase();\n\n                    var jj;\n                    var j;\n                    switch (r[0]) {\n                        case 'A':\n                            r[1] = pa[1];\n                            r[2] = pa[2];\n                            r[3] = pa[3];\n                            r[4] = pa[4];\n                            r[5] = pa[5];\n                            r[6] = +pa[6] + x;\n                            r[7] = +pa[7] + y;\n                            break;\n\n                        case 'V':\n                            r[1] = +pa[1] + y;\n                            break;\n\n                        case 'H':\n                            r[1] = +pa[1] + x;\n                            break;\n\n                        case 'M':\n                            mx = +pa[1] + x;\n                            my = +pa[2] + y;\n\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n\n                        default:\n                            jj = pa.length;\n                            for (j = 1; j < jj; j++) {\n                                r[j] = +pa[j] + ((j % 2) ? x : y);\n                            }\n                            break;\n                    }\n                } else {\n                    var kk = pa.length;\n                    for (var k = 0; k < kk; k++) {\n                        r[k] = pa[k];\n                    }\n                }\n\n                switch (r[0]) {\n                    case 'Z':\n                        x = +mx;\n                        y = +my;\n                        break;\n\n                    case 'H':\n                        x = r[1];\n                        break;\n\n                    case 'V':\n                        y = r[1];\n                        break;\n\n                    case 'M':\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                        break;\n                }\n            }\n\n            return res;\n        }\n\n        function normalize(path) {\n\n            var p = pathToAbsolute(path);\n            var attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };\n\n            function processPath(path, d, pcom) {\n\n                var nx, ny;\n\n                if (!path) return ['C', d.x, d.y, d.x, d.y, d.x, d.y];\n\n                if (!(path[0] in { T: 1, Q: 1 })) {\n                    d.qx = null;\n                    d.qy = null;\n                }\n\n                switch (path[0]) {\n                    case 'M':\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n\n                    case 'A':\n                        if (parseFloat(path[1]) === 0 || parseFloat(path[2]) === 0) {\n                            // https://www.w3.org/TR/SVG/paths.html#ArcOutOfRangeParameters\n                            // \"If either rx or ry is 0, then this arc is treated as a\n                            // straight line segment (a \"lineto\") joining the endpoints.\"\n                            path = ['L', path[6], path[7]];\n                        } else {\n                            path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        }\n                        break;\n\n                    case 'S':\n                        if (pcom === 'C' || pcom === 'S') { // In 'S' case we have to take into account, if the previous command is C/S.\n                            nx = (d.x * 2) - d.bx;          // And reflect the previous\n                            ny = (d.y * 2) - d.by;          // command's control point relative to the current point.\n                        } else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = ['C', nx, ny].concat(path.slice(1));\n                        break;\n\n                    case 'T':\n                        if (pcom === 'Q' || pcom === 'T') { // In 'T' case we have to take into account, if the previous command is Q/T.\n                            d.qx = (d.x * 2) - d.qx;        // And make a reflection similar\n                            d.qy = (d.y * 2) - d.qy;        // to case 'S'.\n                        } else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n\n                    case 'Q':\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n\n                    case 'H':\n                        path = ['L'].concat(path[1], d.y);\n                        break;\n\n                    case 'V':\n                        path = ['L'].concat(d.x, path[1]);\n                        break;\n\n                    case 'L':\n                        break;\n\n                    case 'Z':\n                        break;\n                }\n\n                return path;\n            }\n\n            function fixArc(pp, i) {\n\n                if (pp[i].length > 7) {\n\n                    pp[i].shift();\n                    var pi = pp[i];\n\n                    while (pi.length) {\n                        pcoms[i] = 'A'; // if created multiple 'C's, their original seg is saved\n                        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));\n                    }\n\n                    pp.splice(i, 1);\n                    ii = p.length;\n                }\n            }\n\n            var pcoms = []; // path commands of original path p\n            var pfirst = ''; // temporary holder for original path command\n            var pcom = ''; // holder for previous path command of original path\n\n            var ii = p.length;\n            for (var i = 0; i < ii; i++) {\n                if (p[i]) pfirst = p[i][0]; // save current path command\n\n                if (pfirst !== 'C') { // C is not saved yet, because it may be result of conversion\n                    pcoms[i] = pfirst; // Save current path command\n                    if (i > 0) pcom = pcoms[i - 1]; // Get previous path command pcom\n                }\n\n                p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n                if (pcoms[i] !== 'A' && pfirst === 'C') pcoms[i] = 'C'; // 'A' is the only command\n                // which may produce multiple 'C's\n                // so we have to make sure that 'C' is also 'C' in original path\n\n                fixArc(p, i); // fixArc adds also the right amount of 'A's to pcoms\n\n                var seg = p[i];\n                var seglen = seg.length;\n\n                attrs.x = seg[seglen - 2];\n                attrs.y = seg[seglen - 1];\n\n                attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;\n                attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;\n            }\n\n            // make sure normalized path data string starts with an M segment\n            if (!p[0][0] || p[0][0] !== 'M') {\n                p.unshift(['M', 0, 0]);\n            }\n\n            return p;\n        }\n\n        return function(pathData) {\n            return normalize(pathData).join(',').split(',').join(' ');\n        };\n    })();\n\n    V.namespace = ns;\n\n    V.g = _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__;\n\n    return V;\n\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (V);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvVi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVvQzs7QUFFcEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdFQUFnRSxTQUFTOztBQUV6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFnQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdELGlEQUFpRCxZQUFZOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0RBQWdCLENBQUMsK0NBQU87QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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QSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLFVBQVUsMklBQTJJO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7O0FBRUEsMEZBQTBGO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxRQUFROztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBOztBQUVBOztBQUVBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELDREQUE0RDtBQUM1RCwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsMkJBQTJCOztBQUUzQjtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLDRDQUE0Qzs7QUFFNUMsc0NBQXNDO0FBQ3RDLHVDQUF1QztBQUN2QyxvREFBb0Q7QUFDcEQ7O0FBRUEsdURBQXVEOztBQUV2RCx3RUFBd0U7QUFDeEU7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLFVBQVUseUNBQUM7O0FBRVg7O0FBRUEsQ0FBQzs7QUFFRCwrREFBZSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9WL2luZGV4Lm1qcz8yNzljIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFZlY3Rvcml6ZXIuXG4vLyAtLS0tLS0tLS0tLVxuXG4vLyBBIHRpbnkgbGlicmFyeSBmb3IgbWFraW5nIHlvdXIgbGlmZSBlYXNpZXIgd2hlbiBkZWFsaW5nIHdpdGggU1ZHLlxuLy8gVGhlIG9ubHkgVmVjdG9yaXplciBkZXBlbmRlbmN5IGlzIHRoZSBHZW9tZXRyeSBsaWJyYXJ5LlxuXG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuY29uc3QgViA9IChmdW5jdGlvbigpIHtcblxuICAgIHZhciBoYXNTdmcgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiAhIXdpbmRvdy5TVkdBbmdsZTtcblxuICAgIC8vIFNWRyBzdXBwb3J0IGlzIHJlcXVpcmVkLlxuICAgIGlmICghaGFzU3ZnKSB7XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB0aHJvd3MgYW4gZXJyb3Igd2hlbiBpdCBpcyB1c2VkLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NWRyBpcyByZXF1aXJlZCB0byB1c2UgVmVjdG9yaXplci4nKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBYTUwgbmFtZXNwYWNlcy5cbiAgICB2YXIgbnMgPSB7XG4gICAgICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAgICAgeG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycsXG4gICAgICAgIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG4gICAgICAgIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgICAgIHhodG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCdcbiAgICB9O1xuXG4gICAgdmFyIFNWR1ZlcnNpb24gPSAnMS4xJztcblxuICAgIC8vIERlY2xhcmUgc2hvcnRoYW5kcyB0byB0aGUgbW9zdCB1c2VkIG1hdGggZnVuY3Rpb25zLlxuICAgIHZhciBtYXRoID0gTWF0aDtcbiAgICB2YXIgUEkgPSBtYXRoLlBJO1xuICAgIHZhciBhdGFuMiA9IG1hdGguYXRhbjI7XG4gICAgdmFyIHNxcnQgPSBtYXRoLnNxcnQ7XG4gICAgdmFyIG1pbiA9IG1hdGgubWluO1xuICAgIHZhciBtYXggPSBtYXRoLm1heDtcbiAgICB2YXIgY29zID0gbWF0aC5jb3M7XG4gICAgdmFyIHNpbiA9IG1hdGguc2luO1xuXG4gICAgdmFyIFYgPSBmdW5jdGlvbihlbCwgYXR0cnMsIGNoaWxkcmVuKSB7XG5cbiAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXNpbmcgVigpIHdpdGhvdXQgdGhlIG5ldyBrZXl3b3JkLlxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVikpIHtcbiAgICAgICAgICAgIHJldHVybiBWLmFwcGx5KE9iamVjdC5jcmVhdGUoVi5wcm90b3R5cGUpLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChWLmlzVihlbCkpIHtcbiAgICAgICAgICAgIGVsID0gZWwubm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG5cbiAgICAgICAgaWYgKFYuaXNTdHJpbmcoZWwpKSB7XG5cbiAgICAgICAgICAgIGVsID0gZWwudHJpbSgpO1xuXG4gICAgICAgICAgICBpZiAoZWwudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycpIHtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBTVkcgY2FudmFzLlxuICAgICAgICAgICAgICAgIGVsID0gVi5jcmVhdGVTdmdEb2N1bWVudCgpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsWzBdID09PSAnPCcpIHtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBlbGVtZW50IGZyb20gYW4gU1ZHIHN0cmluZy5cbiAgICAgICAgICAgICAgICAvLyBBbGxvd3MgY29uc3RydWN0cyBvZiB0eXBlOiBgZG9jdW1lbnQuYXBwZW5kQ2hpbGQoVignPHJlY3Q+PC9yZWN0PicpLm5vZGUpYC5cblxuICAgICAgICAgICAgICAgIHZhciBzdmdEb2MgPSBWLmNyZWF0ZVN2Z0RvY3VtZW50KGVsKTtcblxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBgVigpYCBtaWdodCBhbHNvIHJldHVybiBhbiBhcnJheSBzaG91bGQgdGhlIFNWRyBzdHJpbmcgcGFzc2VkIGFzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGFyZ3VtZW50IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSByb290IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKHN2Z0RvYy5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgY2hpbGQgbm9kZXMgdG8gYFZgcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5T2ZWZWxzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBsZW47XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3ZnRG9jLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHN2Z0RvYy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlPZlZlbHMucHVzaChuZXcgVihkb2N1bWVudC5pbXBvcnROb2RlKGNoaWxkTm9kZSwgdHJ1ZSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheU9mVmVscztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmltcG9ydE5vZGUoc3ZnRG9jLmZpcnN0Q2hpbGQsIHRydWUpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMuc3ZnLCBlbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFYuZW5zdXJlSWQoZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ub2RlID0gZWw7XG5cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcblxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB2YXIgVlByb3RvdHlwZSA9IFYucHJvdG90eXBlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZQcm90b3R5cGUsICdpZCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NWR0dFbGVtZW50fSB0b0VsZW1cbiAgICAgKiBAcmV0dXJucyB7U1ZHTWF0cml4fVxuICAgICAqL1xuICAgIFZQcm90b3R5cGUuZ2V0VHJhbnNmb3JtVG9FbGVtZW50ID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICBpZiAoVi5pc1NWR0dyYXBoaWNzRWxlbWVudCh0YXJnZXQpICYmIFYuaXNTVkdHcmFwaGljc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDVE0gPSBWLnRvTm9kZSh0YXJnZXQpLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgdmFyIG5vZGVDVE0gPSBub2RlLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldENUTSAmJiBub2RlQ1RNKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldENUTS5pbnZlcnNlKCkubXVsdGlwbHkobm9kZUNUTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ291bGQgbm90IGdldCBhY3R1YWwgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NWR01hdHJpeH0gbWF0cml4XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yaXplcnxTVkdNYXRyaXh9IFNldHRlciAvIEdldHRlclxuICAgICAqL1xuICAgIFZQcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24obWF0cml4LCBvcHQpIHtcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgaWYgKFYuaXNVbmRlZmluZWQobWF0cml4KSkge1xuICAgICAgICAgICAgcmV0dXJuIFYudHJhbnNmb3JtU3RyaW5nVG9NYXRyaXgodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0ICYmIG9wdC5hYnNvbHV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyhtYXRyaXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdmdUcmFuc2Zvcm0gPSBWLmNyZWF0ZVNWR1RyYW5zZm9ybShtYXRyaXgpO1xuICAgICAgICBub2RlLnRyYW5zZm9ybS5iYXNlVmFsLmFwcGVuZEl0ZW0oc3ZnVHJhbnNmb3JtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24odHgsIHR5LCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHR5ID0gdHkgfHwgMDtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtQXR0ciA9IHRoaXMuYXR0cigndHJhbnNmb3JtJykgfHwgJyc7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBWLnBhcnNlVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybUF0dHIpO1xuICAgICAgICB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtLnZhbHVlO1xuICAgICAgICAvLyBJcyBpdCBhIGdldHRlcj9cbiAgICAgICAgaWYgKFYuaXNVbmRlZmluZWQodHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybUF0dHIgPSB0cmFuc2Zvcm1BdHRyLnJlcGxhY2UoL3RyYW5zbGF0ZVxcKFteKV0qXFwpL2csICcnKS50cmltKCk7XG5cbiAgICAgICAgdmFyIG5ld1R4ID0gb3B0LmFic29sdXRlID8gdHggOiB0cmFuc2Zvcm0udHJhbnNsYXRlLnR4ICsgdHg7XG4gICAgICAgIHZhciBuZXdUeSA9IG9wdC5hYnNvbHV0ZSA/IHR5IDogdHJhbnNmb3JtLnRyYW5zbGF0ZS50eSArIHR5O1xuICAgICAgICB2YXIgbmV3VHJhbnNsYXRlID0gJ3RyYW5zbGF0ZSgnICsgbmV3VHggKyAnLCcgKyBuZXdUeSArICcpJztcblxuICAgICAgICAvLyBOb3RlIHRoYXQgYHRyYW5zbGF0ZSgpYCBpcyBhbHdheXMgdGhlIGZpcnN0IHRyYW5zZm9ybWF0aW9uLiBUaGlzIGlzXG4gICAgICAgIC8vIHVzdWFsbHkgdGhlIGRlc2lyZWQgY2FzZS5cbiAgICAgICAgdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCAobmV3VHJhbnNsYXRlICsgJyAnICsgdHJhbnNmb3JtQXR0cikudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24oYW5nbGUsIGN4LCBjeSwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm1BdHRyID0gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFYucGFyc2VUcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtQXR0cik7XG4gICAgICAgIHRyYW5zZm9ybUF0dHIgPSB0cmFuc2Zvcm0udmFsdWU7XG5cbiAgICAgICAgLy8gSXMgaXQgYSBnZXR0ZXI/XG4gICAgICAgIGlmIChWLmlzVW5kZWZpbmVkKGFuZ2xlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5yb3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2Zvcm1BdHRyID0gdHJhbnNmb3JtQXR0ci5yZXBsYWNlKC9yb3RhdGVcXChbXildKlxcKS9nLCAnJykudHJpbSgpO1xuXG4gICAgICAgIGFuZ2xlICU9IDM2MDtcblxuICAgICAgICB2YXIgbmV3QW5nbGUgPSBvcHQuYWJzb2x1dGUgPyBhbmdsZSA6IHRyYW5zZm9ybS5yb3RhdGUuYW5nbGUgKyBhbmdsZTtcbiAgICAgICAgdmFyIG5ld09yaWdpbiA9IChjeCAhPT0gdW5kZWZpbmVkICYmIGN5ICE9PSB1bmRlZmluZWQpID8gJywnICsgY3ggKyAnLCcgKyBjeSA6ICcnO1xuICAgICAgICB2YXIgbmV3Um90YXRlID0gJ3JvdGF0ZSgnICsgbmV3QW5nbGUgKyBuZXdPcmlnaW4gKyAnKSc7XG5cbiAgICAgICAgdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCAodHJhbnNmb3JtQXR0ciArICcgJyArIG5ld1JvdGF0ZSkudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8vIE5vdGUgdGhhdCBgc2NhbGVgIGFzIHRoZSBvbmx5IHRyYW5zZm9ybWF0aW9uIGRvZXMgbm90IGNvbWJpbmUgd2l0aCBwcmV2aW91cyB2YWx1ZXMuXG4gICAgVlByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHN4LCBzeSkge1xuXG4gICAgICAgIHN5ID0gVi5pc1VuZGVmaW5lZChzeSkgPyBzeCA6IHN5O1xuXG4gICAgICAgIHZhciB0cmFuc2Zvcm1BdHRyID0gdGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IFYucGFyc2VUcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtQXR0cik7XG4gICAgICAgIHRyYW5zZm9ybUF0dHIgPSB0cmFuc2Zvcm0udmFsdWU7XG5cbiAgICAgICAgLy8gSXMgaXQgYSBnZXR0ZXI/XG4gICAgICAgIGlmIChWLmlzVW5kZWZpbmVkKHN4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybUF0dHIgPSB0cmFuc2Zvcm1BdHRyLnJlcGxhY2UoL3NjYWxlXFwoW14pXSpcXCkvZywgJycpLnRyaW0oKTtcblxuICAgICAgICB2YXIgbmV3U2NhbGUgPSAnc2NhbGUoJyArIHN4ICsgJywnICsgc3kgKyAnKSc7XG5cbiAgICAgICAgdGhpcy5hdHRyKCd0cmFuc2Zvcm0nLCAodHJhbnNmb3JtQXR0ciArICcgJyArIG5ld1NjYWxlKS50cmltKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gR2V0IFNWR1JlY3QgdGhhdCBjb250YWlucyBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9uIG9mIHRoZSByZWFsIGJvdW5kaW5nIGJveCxcbiAgICAvLyBpLmUuIGFmdGVyIHRyYW5zZm9ybWF0aW9ucyBhcmUgYXBwbGllZC5cbiAgICAvLyBJZiBgdGFyZ2V0YCBpcyBzcGVjaWZpZWQsIGJvdW5kaW5nIGJveCB3aWxsIGJlIGNvbXB1dGVkIHJlbGF0aXZlbHkgdG8gYHRhcmdldGAgZWxlbWVudC5cbiAgICBWUHJvdG90eXBlLmJib3ggPSBmdW5jdGlvbih3aXRob3V0VHJhbnNmb3JtYXRpb25zLCB0YXJnZXQpIHtcblxuICAgICAgICB2YXIgYm94O1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIG93bmVyU1ZHRWxlbWVudCA9IG5vZGUub3duZXJTVkdFbGVtZW50O1xuXG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBpbiB0aGUgbGl2ZSBET00sIGl0IGRvZXMgbm90IGhhdmUgYSBib3VuZGluZyBib3ggZGVmaW5lZCBhbmRcbiAgICAgICAgLy8gc28gZmFsbCBiYWNrIHRvICd6ZXJvJyBkaW1lbnNpb24gZWxlbWVudC5cbiAgICAgICAgaWYgKCFvd25lclNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZy5SZWN0KDAsIDAsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgYm94ID0gbm9kZS5nZXRCQm94KCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgSUUuXG4gICAgICAgICAgICBib3ggPSB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5jbGllbnRMZWZ0LFxuICAgICAgICAgICAgICAgIHk6IG5vZGUuY2xpZW50VG9wLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2l0aG91dFRyYW5zZm9ybWF0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3QoYm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLmdldFRyYW5zZm9ybVRvRWxlbWVudCh0YXJnZXQgfHwgb3duZXJTVkdFbGVtZW50KTtcblxuICAgICAgICByZXR1cm4gVi50cmFuc2Zvcm1SZWN0KGJveCwgbWF0cml4KTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBhbiBTVkdSZWN0IHRoYXQgY29udGFpbnMgY29vcmRpbmF0ZXMgYW5kIGRpbWVuc2lvbnMgb2YgdGhlIHJlYWwgYm91bmRpbmcgYm94LFxuICAgIC8vIGkuZS4gYWZ0ZXIgdHJhbnNmb3JtYXRpb25zIGFyZSBhcHBsaWVkLlxuICAgIC8vIEZpeGVzIGEgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBidWcgdGhhdCByZXR1cm5zIGluY29ycmVjdCBib3VuZGluZyBib3hlcyBmb3IgZ3JvdXBzIG9mIHN2ZyBlbGVtZW50cy5cbiAgICAvLyBUYWtlcyBhbiAoT2JqZWN0KSBgb3B0YCBhcmd1bWVudCAob3B0aW9uYWwpIHdpdGggdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgIC8vIChPYmplY3QpIGB0YXJnZXRgIChvcHRpb25hbCk6IGlmIG5vdCB1bmRlZmluZWQsIHRyYW5zZm9ybSBib3VuZGluZyBib3hlcyByZWxhdGl2ZSB0byBgdGFyZ2V0YDsgaWYgdW5kZWZpbmVkLCB0cmFuc2Zvcm0gcmVsYXRpdmUgdG8gdGhpc1xuICAgIC8vIChCb29sZWFuKSBgcmVjdXJzaXZlYCAob3B0aW9uYWwpOiBpZiB0cnVlLCByZWN1cnNpdmVseSBlbnRlciBhbGwgZ3JvdXBzIGFuZCBnZXQgYSB1bmlvbiBvZiBlbGVtZW50IGJvdW5kaW5nIGJveGVzIChzdmcgYmJveCBmaXgpOyBpZiBmYWxzZSBvciB1bmRlZmluZWQsIHJldHVybiByZXN1bHQgb2YgbmF0aXZlIGZ1bmN0aW9uIHRoaXMubm9kZS5nZXRCQm94KCk7XG4gICAgVlByb3RvdHlwZS5nZXRCQm94ID0gZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICB2YXIgb3V0cHV0QkJveDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIHZhciBvd25lclNWR0VsZW1lbnQgPSBub2RlLm93bmVyU1ZHRWxlbWVudDtcblxuICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgaW4gdGhlIGxpdmUgRE9NLCBpdCBkb2VzIG5vdCBoYXZlIGEgYm91bmRpbmcgYm94IGRlZmluZWQgYW5kXG4gICAgICAgIC8vIHNvIGZhbGwgYmFjayB0byAnemVybycgZGltZW5zaW9uIGVsZW1lbnQuXG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBhbiBTVkdHcmFwaGljc0VsZW1lbnQsIHdlIGNvdWxkIG5vdCBtZWFzdXJlIHRoZSBib3VuZGluZyBib3ggZWl0aGVyXG4gICAgICAgIGlmICghb3duZXJTVkdFbGVtZW50IHx8ICFWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGcuUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIGlmIChvcHQudGFyZ2V0KSB7IC8vIGNoZWNrIGlmIHRhcmdldCBleGlzdHNcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRhcmdldCA9IFYudG9Ob2RlKG9wdC50YXJnZXQpOyAvLyB3b3JrcyBmb3IgViBvYmplY3RzLCBqcXVlcnkgb2JqZWN0cywgYW5kIG5vZGUgb2JqZWN0c1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5yZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlY3Vyc2l2ZSA9IG9wdC5yZWN1cnNpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMucmVjdXJzaXZlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dEJCb3ggPSBub2RlLmdldEJCb3goKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgSUUuXG4gICAgICAgICAgICAgICAgb3V0cHV0QkJveCA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogbm9kZS5jbGllbnRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLmNsaWVudFRvcCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGxpa2UgdGhpcyAodGhhdCBpcywgbm90IGF0IGFsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuUmVjdChvdXRwdXRCQm94KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGxpa2UgdGFyZ2V0XG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVi50cmFuc2Zvcm1SZWN0KG91dHB1dEJCb3gsIG1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIGlmIHdlIHdhbnQgdG8gY2FsY3VsYXRlIHRoZSBiYm94IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAvLyBicm93c2VycyByZXBvcnQgY29ycmVjdCBiYm94IGFyb3VuZCBzdmcgZWxlbWVudHMgKG9uZSB0aGF0IGVudmVsb3BzIHRoZSBwYXRoIGxpbmVzIHRpZ2h0bHkpXG4gICAgICAgICAgICAvLyBidXQgc29tZSBicm93c2VycyBmYWlsIHRvIHJlcG9ydCB0aGUgc2FtZSBiYm94IHdoZW4gdGhlIGVsZW1lbnRzIGFyZSBpbiBhIGdyb3VwIChyZXR1cm5pbmcgYSBsb29zZXIgYmJveCB0aGF0IGFsc28gaW5jbHVkZXMgY29udHJvbCBwb2ludHMsIGxpa2Ugbm9kZS5nZXRDbGllbnRSZWN0KCkpXG4gICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgZXZlbiBpZiB3ZSB3cmFwIGEgc2luZ2xlIHN2ZyBlbGVtZW50IGludG8gYSBncm91cCFcbiAgICAgICAgICAgIC8vIHRoaXMgb3B0aW9uIHNldHRpbmcgbWFrZXMgdGhlIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IGVudGVyIGFsbCB0aGUgZ3JvdXBzIGZyb20gdGhpcyBhbmQgZGVlcGVyLCBnZXQgYmJveGVzIG9mIHRoZSBlbGVtZW50cyBpbnNpZGUsIHRoZW4gcmV0dXJuIGEgdW5pb24gb2YgdGhvc2UgYmJveGVzXG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHZhciBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJCb3goeyB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LCByZWN1cnNpdmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZWN1cnNpb24ncyBpbml0aWFsIHBhc3MtdGhyb3VnaCBzZXR0aW5nOlxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlIHBhc3Nlcy10aHJvdWdoIGp1c3Qga2VlcCB0aGUgdGFyZ2V0IGFzIHdoYXRldmVyIHdhcyBzZXQgdXAgaGVyZSBkdXJpbmcgdGhlIGluaXRpYWwgcGFzcy10aHJvdWdoXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIGxpa2UgdGhpcyAodGhlaXIgcGFyZW50L2FuY2VzdG9yKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMudGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIH0gLy8gZWxzZSB0cmFuc2Zvcm0gY2hpbGRyZW4vZGVzY2VuZGFudHMgbGlrZSB0YXJnZXRcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRCQm94O1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgY3VycmVudENoaWxkIGlzIG5vdCBhIGdyb3VwIGVsZW1lbnQsIGdldCBpdHMgYmJveCB3aXRoIGEgbm9ucmVjdXJzaXZlIGNhbGxcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENoaWxkLmNoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IGN1cnJlbnRDaGlsZC5nZXRCQm94KHsgdGFyZ2V0OiBvcHRpb25zLnRhcmdldCwgcmVjdXJzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50Q2hpbGQgaXMgYSBncm91cCBlbGVtZW50IChkZXRlcm1pbmVkIGJ5IGNoZWNraW5nIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4pLCBlbnRlciBpdCB3aXRoIGEgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gY3VycmVudENoaWxkLmdldEJCb3goeyB0YXJnZXQ6IG9wdGlvbnMudGFyZ2V0LCByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXRCQm94KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRCQm94ID0gY2hpbGRCQm94O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBuZXcgYm91bmRpbmcgYm94IHJlY3RhbmdsZSB0aGF0IGNvbnRhaW5zIHRoaXMgY2hpbGQncyBib3VuZGluZyBib3ggYW5kIHByZXZpb3VzIGJvdW5kaW5nIGJveFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRCQm94ID0gb3V0cHV0QkJveC51bmlvbihjaGlsZEJCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEJCb3g7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVGV4dCgpIGhlbHBlcnNcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRleHRQYXRoTm9kZShhdHRycywgdmVsKSB7XG4gICAgICAgIGF0dHJzIHx8IChhdHRycyA9IHt9KTtcbiAgICAgICAgdmFyIHRleHRQYXRoRWxlbWVudCA9IFYoJ3RleHRQYXRoJyk7XG4gICAgICAgIHZhciBkID0gYXR0cnMuZDtcbiAgICAgICAgaWYgKGQgJiYgYXR0cnNbJ3hsaW5rOmhyZWYnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBJZiBgb3B0LmF0dHJzYCBpcyBhIHBsYWluIHN0cmluZywgY29uc2lkZXIgaXQgdG8gYmUgZGlyZWN0bHkgdGhlXG4gICAgICAgICAgICAvLyBTVkcgcGF0aCBkYXRhIGZvciB0aGUgdGV4dCB0byBnbyBhbG9uZyAodGhpcyBpcyBhIHNob3J0Y3V0KS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiBpdCBpcyBhbiBvYmplY3QgYW5kIGNvbnRhaW5zIHRoZSBgZGAgcHJvcGVydHksIHRoZW4gdGhpcyBpcyBvdXIgcGF0aC5cbiAgICAgICAgICAgIC8vIFdyYXAgdGhlIHRleHQgaW4gdGhlIFNWRyA8dGV4dFBhdGg+IGVsZW1lbnQgdGhhdCBwb2ludHNcbiAgICAgICAgICAgIC8vIHRvIGEgcGF0aCBkZWZpbmVkIGJ5IGBvcHQuYXR0cnNgIGluc2lkZSB0aGUgYDxkZWZzPmAgZWxlbWVudC5cbiAgICAgICAgICAgIHZhciBsaW5rZWRQYXRoID0gVigncGF0aCcpLmF0dHIoJ2QnLCBkKS5hcHBlbmRUbyh2ZWwuZGVmcygpKTtcbiAgICAgICAgICAgIHRleHRQYXRoRWxlbWVudC5hdHRyKCd4bGluazpocmVmJywgJyMnICsgbGlua2VkUGF0aC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFYuaXNPYmplY3QoYXR0cnMpKSB7XG4gICAgICAgICAgICAvLyBTZXQgYXR0cmlidXRlcyBvbiB0aGUgYDx0ZXh0UGF0aD5gLiBUaGUgbW9zdCBpbXBvcnRhbnQgb25lXG4gICAgICAgICAgICAvLyBpcyB0aGUgYHhsaW5rOmhyZWZgIHRoYXQgcG9pbnRzIHRvIG91ciBuZXdseSBjcmVhdGVkIGA8cGF0aC8+YCBlbGVtZW50IGluIGA8ZGVmcy8+YC5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHNvIGFsbG93IHRoZSBmb2xsb3dpbmcgY29uc3RydWN0OlxuICAgICAgICAgICAgLy8gYHQudGV4dCgnbXkgdGV4dCcsIHsgdGV4dFBhdGg6IHsgJ3hsaW5rOmhyZWYnOiAnI215LW90aGVyLXBhdGgnIH0gfSlgLlxuICAgICAgICAgICAgLy8gSW4gb3RoZXIgd29yZHMsIG9uZSBjYW4gY29tcGxldGVseSBza2lwIHRoZSBhdXRvLWNyZWF0aW9uIG9mIHRoZSBwYXRoXG4gICAgICAgICAgICAvLyBhbmQgdXNlIGFueSBvdGhlciBhcmJpdHJhcnkgcGF0aCB0aGF0IGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgIHRleHRQYXRoRWxlbWVudC5hdHRyKGF0dHJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dFBhdGhFbGVtZW50Lm5vZGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYW5ub3RhdGVUZXh0TGluZShsaW5lTm9kZSwgbGluZUFubm90YXRpb25zLCBvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIHZhciBpbmNsdWRlQW5ub3RhdGlvbkluZGljZXMgPSBvcHQuaW5jbHVkZUFubm90YXRpb25JbmRpY2VzO1xuICAgICAgICB2YXIgZW9sID0gb3B0LmVvbDtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBvcHQubGluZUhlaWdodDtcbiAgICAgICAgdmFyIGJhc2VTaXplID0gb3B0LmJhc2VTaXplO1xuICAgICAgICB2YXIgbWF4Rm9udFNpemUgPSAwO1xuICAgICAgICB2YXIgZm9udE1ldHJpY3MgPSB7fTtcbiAgICAgICAgdmFyIGxhc3RKID0gbGluZUFubm90YXRpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGxhc3RKOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uID0gbGluZUFubm90YXRpb25zW2pdO1xuICAgICAgICAgICAgdmFyIGZvbnRTaXplID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChWLmlzT2JqZWN0KGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25BdHRycyA9IGFubm90YXRpb24uYXR0cnM7XG4gICAgICAgICAgICAgICAgdmFyIHZUU3BhbiA9IFYoJ3RzcGFuJywgYW5ub3RhdGlvbkF0dHJzKTtcbiAgICAgICAgICAgICAgICB2YXIgdHNwYW5Ob2RlID0gdlRTcGFuLm5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBhbm5vdGF0aW9uLnQ7XG4gICAgICAgICAgICAgICAgaWYgKGVvbCAmJiBqID09PSBsYXN0SikgdCArPSBlb2w7XG4gICAgICAgICAgICAgICAgdHNwYW5Ob2RlLnRleHRDb250ZW50ID0gdDtcbiAgICAgICAgICAgICAgICAvLyBQZXIgYW5ub3RhdGlvbiBjbGFzc05hbWVcbiAgICAgICAgICAgICAgICB2YXIgYW5ub3RhdGlvbkNsYXNzID0gYW5ub3RhdGlvbkF0dHJzWydjbGFzcyddO1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uQ2xhc3MpIHZUU3Bhbi5hZGRDbGFzcyhhbm5vdGF0aW9uQ2xhc3MpO1xuICAgICAgICAgICAgICAgIC8vIElmIGBvcHQuaW5jbHVkZUFubm90YXRpb25JbmRpY2VzYCBpcyBgdHJ1ZWAsXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBsaXN0IG9mIGluZGljZXMgb2YgYWxsIHRoZSBhcHBsaWVkIGFubm90YXRpb25zXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIGBhbm5vdGF0aW9uc2AgYXR0cmlidXRlLiBUaGlzIGxpc3QgaXMgYSBjb21tYVxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlZCBsaXN0IG9mIGluZGljZXMuXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlcykgdlRTcGFuLmF0dHIoJ2Fubm90YXRpb25zJywgYW5ub3RhdGlvbi5hbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1heCBmb250IHNpemVcbiAgICAgICAgICAgICAgICBmb250U2l6ZSA9IHBhcnNlRmxvYXQoYW5ub3RhdGlvbkF0dHJzWydmb250LXNpemUnXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShmb250U2l6ZSkpIGZvbnRTaXplID0gYmFzZVNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGZvbnRTaXplICYmIGZvbnRTaXplID4gbWF4Rm9udFNpemUpIG1heEZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlb2wgJiYgaiA9PT0gbGFzdEopIGFubm90YXRpb24gKz0gZW9sO1xuICAgICAgICAgICAgICAgIHRzcGFuTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFubm90YXRpb24gfHwgJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVNpemUgJiYgYmFzZVNpemUgPiBtYXhGb250U2l6ZSkgbWF4Rm9udFNpemUgPSBiYXNlU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVOb2RlLmFwcGVuZENoaWxkKHRzcGFuTm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4Rm9udFNpemUpIGZvbnRNZXRyaWNzLm1heEZvbnRTaXplID0gbWF4Rm9udFNpemU7XG4gICAgICAgIGlmIChsaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICBmb250TWV0cmljcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhGb250U2l6ZSkge1xuICAgICAgICAgICAgZm9udE1ldHJpY3MubGluZUhlaWdodCA9IChtYXhGb250U2l6ZSAqIDEuMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbnRNZXRyaWNzO1xuICAgIH1cblxuICAgIHZhciBlbVJlZ2V4ID0gL2VtJC87XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0RW1Ub1B4KGVtLCBmb250U2l6ZSkge1xuICAgICAgICB2YXIgbnVtZXJpY2FsID0gcGFyc2VGbG9hdChlbSk7XG4gICAgICAgIGlmIChlbVJlZ2V4LnRlc3QoZW0pKSByZXR1cm4gbnVtZXJpY2FsICogZm9udFNpemU7XG4gICAgICAgIHJldHVybiBudW1lcmljYWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlRFkoYWxpZ25tZW50LCBsaW5lc01ldHJpY3MsIGJhc2VTaXplUHgsIGxpbmVIZWlnaHQpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpbmVzTWV0cmljcykpIHJldHVybiAwO1xuICAgICAgICB2YXIgbiA9IGxpbmVzTWV0cmljcy5sZW5ndGg7XG4gICAgICAgIGlmICghbikgcmV0dXJuIDA7XG4gICAgICAgIHZhciBsaW5lTWV0cmljcyA9IGxpbmVzTWV0cmljc1swXTtcbiAgICAgICAgdmFyIGZsTWF4Rm9udCA9IGNvbnZlcnRFbVRvUHgobGluZU1ldHJpY3MubWF4Rm9udFNpemUsIGJhc2VTaXplUHgpIHx8IGJhc2VTaXplUHg7XG4gICAgICAgIHZhciByTGluZUhlaWdodHMgPSAwO1xuICAgICAgICB2YXIgbGluZUhlaWdodFB4ID0gY29udmVydEVtVG9QeChsaW5lSGVpZ2h0LCBiYXNlU2l6ZVB4KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVNZXRyaWNzID0gbGluZXNNZXRyaWNzW2ldO1xuICAgICAgICAgICAgdmFyIGlMaW5lSGVpZ2h0ID0gY29udmVydEVtVG9QeChsaW5lTWV0cmljcy5saW5lSGVpZ2h0LCBiYXNlU2l6ZVB4KSB8fCBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgICByTGluZUhlaWdodHMgKz0gaUxpbmVIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxsTWF4Rm9udCA9IGNvbnZlcnRFbVRvUHgobGluZU1ldHJpY3MubWF4Rm9udFNpemUsIGJhc2VTaXplUHgpIHx8IGJhc2VTaXplUHg7XG4gICAgICAgIHZhciBkeTtcbiAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgZHkgPSAoZmxNYXhGb250IC8gMikgLSAoMC4xNSAqIGxsTWF4Rm9udCkgLSAockxpbmVIZWlnaHRzIC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGR5ID0gLSgwLjI1ICogbGxNYXhGb250KSAtIHJMaW5lSGVpZ2h0cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGR5ID0gKDAuOCAqIGZsTWF4Rm9udCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5O1xuICAgIH1cblxuICAgIFZQcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKGNvbnRlbnQsIG9wdCkge1xuXG4gICAgICAgIGlmIChjb250ZW50ICYmIHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdWZWN0b3JpemVyOiB0ZXh0KCkgZXhwZWN0cyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBzdHJpbmcuJyk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBhbGwgc3BhY2VzIHdpdGggdGhlIFVuaWNvZGUgTm8tYnJlYWsgc3BhY2UgKGh0dHA6Ly93d3cuZmlsZWZvcm1hdC5pbmZvL2luZm8vdW5pY29kZS9jaGFyL2EwL2luZGV4Lmh0bSkuXG4gICAgICAgIC8vIElFIHdvdWxkIG90aGVyd2lzZSBjb2xsYXBzZSBhbGwgc3BhY2VzIGludG8gb25lLlxuICAgICAgICBjb250ZW50ID0gVi5zYW5pdGl6ZVRleHQoY29udGVudCk7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICAvLyBTaG91bGQgd2UgYWxsb3cgdGhlIHRleHQgdG8gYmUgc2VsZWN0ZWQ/XG4gICAgICAgIHZhciBkaXNwbGF5RW1wdHkgPSBvcHQuZGlzcGxheUVtcHR5O1xuICAgICAgICAvLyBFbmQgb2YgTGluZSBjaGFyYWN0ZXJcbiAgICAgICAgdmFyIGVvbCA9IG9wdC5lb2w7XG4gICAgICAgIC8vIFRleHQgYWxvbmcgcGF0aFxuICAgICAgICB2YXIgdGV4dFBhdGggPSBvcHQudGV4dFBhdGg7XG4gICAgICAgIC8vIFZlcnRpY2FsIHNoaWZ0XG4gICAgICAgIHZhciB2ZXJ0aWNhbEFuY2hvciA9IG9wdC50ZXh0VmVydGljYWxBbmNob3I7XG4gICAgICAgIHZhciBuYW1lZFZlcnRpY2FsQW5jaG9yID0gKHZlcnRpY2FsQW5jaG9yID09PSAnbWlkZGxlJyB8fCB2ZXJ0aWNhbEFuY2hvciA9PT0gJ2JvdHRvbScgfHwgdmVydGljYWxBbmNob3IgPT09ICd0b3AnKTtcbiAgICAgICAgLy8gSG9yaXpvbnRhbCBzaGlmdCBhcHBsaWVkIHRvIGFsbCB0aGUgbGluZXMgYnV0IHRoZSBmaXJzdC5cbiAgICAgICAgdmFyIHggPSBvcHQueDtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkgeCA9IHRoaXMuYXR0cigneCcpIHx8IDA7XG4gICAgICAgIC8vIEFubm90YXRpb25zXG4gICAgICAgIHZhciBpYWkgPSBvcHQuaW5jbHVkZUFubm90YXRpb25JbmRpY2VzO1xuICAgICAgICB2YXIgYW5ub3RhdGlvbnMgPSBvcHQuYW5ub3RhdGlvbnM7XG4gICAgICAgIGlmIChhbm5vdGF0aW9ucyAmJiAhVi5pc0FycmF5KGFubm90YXRpb25zKSkgYW5ub3RhdGlvbnMgPSBbYW5ub3RhdGlvbnNdO1xuICAgICAgICAvLyBTaGlmdCBhbGwgdGhlIDx0c3Bhbj4gYnV0IGZpcnN0IGJ5IG9uZSBsaW5lIChgMWVtYClcbiAgICAgICAgdmFyIGRlZmF1bHRMaW5lSGVpZ2h0ID0gb3B0LmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBhdXRvTGluZUhlaWdodCA9IChkZWZhdWx0TGluZUhlaWdodCA9PT0gJ2F1dG8nKTtcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSAoYXV0b0xpbmVIZWlnaHQpID8gJzEuNWVtJyA6IChkZWZhdWx0TGluZUhlaWdodCB8fCAnMWVtJyk7XG4gICAgICAgIC8vIENsZWFyaW5nIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5hdHRyKHtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNwYWNlcy4gSW4gb3RoZXIgd29yZHMsIHdlIGRvIG5vdCB3YW50IGNvbnNlY3V0aXZlIHNwYWNlcyB0byBnZXQgY29sbGFwc2VkIHRvIG9uZS5cbiAgICAgICAgICAgICd4bWw6c3BhY2UnOiAncHJlc2VydmUnLFxuICAgICAgICAgICAgLy8gQW4gZW1wdHkgdGV4dCBnZXRzIHJlbmRlcmVkIGludG8gdGhlIERPTSBpbiB3ZWJraXQtYmFzZWQgYnJvd3NlcnMuXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byB1bmlmeSB0aGlzIGJlaGF2aW91ciBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB3ZSByYXRoZXIgaGlkZSB0aGUgdGV4dCBlbGVtZW50IHdoZW4gaXQncyBlbXB0eS5cbiAgICAgICAgICAgICdkaXNwbGF5JzogKGNvbnRlbnQgfHwgZGlzcGxheUVtcHR5KSA/IG51bGwgOiAnbm9uZSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgZm9udC1zaXplIGlmIG5vbmVcbiAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScpKTtcbiAgICAgICAgaWYgKCFmb250U2l6ZSkge1xuICAgICAgICAgICAgZm9udFNpemUgPSAxNjtcbiAgICAgICAgICAgIGlmIChuYW1lZFZlcnRpY2FsQW5jaG9yIHx8IGFubm90YXRpb25zKSB0aGlzLmF0dHIoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudDtcbiAgICAgICAgdmFyIGNvbnRhaW5lck5vZGU7XG4gICAgICAgIGlmICh0ZXh0UGF0aCkge1xuICAgICAgICAgICAgLy8gTm93IGFsbCB0aGUgYDx0c3Bhbj5gcyB3aWxsIGJlIGluc2lkZSB0aGUgYDx0ZXh0UGF0aD5gLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0UGF0aCA9PT0gJ3N0cmluZycpIHRleHRQYXRoID0geyBkOiB0ZXh0UGF0aCB9O1xuICAgICAgICAgICAgY29udGFpbmVyTm9kZSA9IGNyZWF0ZVRleHRQYXRoTm9kZSh0ZXh0UGF0aCwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXJOb2RlID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIHZhciBsaW5lc01ldHJpY3MgPSBbXTtcbiAgICAgICAgdmFyIGFubm90YXRlZFk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsYXN0SSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPD0gbGFzdEk7IGkrKykge1xuICAgICAgICAgICAgdmFyIGR5ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHZhciBsaW5lQ2xhc3NOYW1lID0gJ3YtbGluZSc7XG4gICAgICAgICAgICB2YXIgbGluZU5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5zLnN2ZywgJ3RzcGFuJyk7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgdmFyIGxpbmVNZXRyaWNzO1xuICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgKmNvbXBhY3RlZCogYW5ub3RhdGlvbnMgZm9yIHRoaXMgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVBbm5vdGF0aW9ucyA9IFYuYW5ub3RhdGVTdHJpbmcobGluZSwgYW5ub3RhdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogLW9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVBbm5vdGF0aW9uSW5kaWNlczogaWFpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lTWV0cmljcyA9IGFubm90YXRlVGV4dExpbmUobGluZU5vZGUsIGxpbmVBbm5vdGF0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUFubm90YXRpb25JbmRpY2VzOiBpYWksXG4gICAgICAgICAgICAgICAgICAgICAgICBlb2w6IChpICE9PSBsYXN0SSAmJiBlb2wpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogKGF1dG9MaW5lSGVpZ2h0KSA/IG51bGwgOiBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVNpemU6IGZvbnRTaXplXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGxpbmUgaGVpZ2h0IGJhc2VkIG9uIHRoZSBiaWdnZXN0IGZvbnQgc2l6ZSBpbiB0aGUgYW5ub3RhdGlvbnMgZm9yIHRoaXMgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlMaW5lSGVpZ2h0ID0gbGluZU1ldHJpY3MubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlMaW5lSGVpZ2h0ICYmIGF1dG9MaW5lSGVpZ2h0ICYmIGkgIT09IDApIGR5ID0gaUxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSBhbm5vdGF0ZWRZID0gbGluZU1ldHJpY3MubWF4Rm9udFNpemUgKiAwLjg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVvbCAmJiBpICE9PSBsYXN0SSkgbGluZSArPSBlb2w7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVOb2RlLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdGV4dENvbnRlbnQgaXMgbmV2ZXIgZW1wdHkuIElmIGl0IGlzLCBhZGQgYSBkdW1teVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3RlciBhbmQgbWFrZSBpdCBpbnZpc2libGUsIG1ha2luZyB0aGUgZm9sbG93aW5nIGxpbmVzIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlbHkgcG9zaXRpb25lZC4gYGR5PTFlbWAgd29uJ3Qgd29yayB3aXRoIGVtcHR5IGxpbmVzIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICBsaW5lTm9kZS50ZXh0Q29udGVudCA9ICctJztcbiAgICAgICAgICAgICAgICBsaW5lQ2xhc3NOYW1lICs9ICcgdi1lbXB0eS1saW5lJztcbiAgICAgICAgICAgICAgICAvLyAnb3BhY2l0eScgbmVlZHMgdG8gYmUgc3BlY2lmaWVkIHdpdGggZmlsbCwgc3Ryb2tlLiBPcGFjaXR5IHdpdGhvdXQgc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBhcHBsaWVkIGluIEZpcmVmb3hcbiAgICAgICAgICAgICAgICB2YXIgbGluZU5vZGVTdHlsZSA9IGxpbmVOb2RlLnN0eWxlO1xuICAgICAgICAgICAgICAgIGxpbmVOb2RlU3R5bGUuZmlsbE9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgIGxpbmVOb2RlU3R5bGUuc3Ryb2tlT3BhY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGxpbmUgd2l0aCBhbm5vdGF0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgbGluZU1ldHJpY3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgbGluZUFubm90YXRpb25zID0gVi5maW5kQW5ub3RhdGlvbnNBdEluZGV4KGFubm90YXRpb25zLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZUZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgYW5ub3RhdGlvbnMgb3ZlcnJpZGVzIHRoZSBmb250IHNpemUuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBsaW5lQW5ub3RhdGlvbnMubGVuZ3RoOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRycyA9IGxpbmVBbm5vdGF0aW9uc1tqIC0gMV0uYXR0cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF0dHJzIHx8ICEoJ2ZvbnQtc2l6ZScgaW4gYXR0cnMpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gcGFyc2VGbG9hdChhdHRyc1snZm9udC1zaXplJ10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKGZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVGb250U2l6ZSA9IGZzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdXRvTGluZUhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBsaW5lRm9udFNpemUgKiAxLjI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZFkgPSBsaW5lRm9udFNpemUgKiAwLjg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbnQgc2l6ZSBpcyBpbXBvcnRhbnQgZm9yIHRoZSBuYXRpdmUgc2VsZWN0aW9uIGJveCBoZWlnaHQuXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOb2RlLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgbGluZUZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZU1ldHJpY3MubWF4Rm9udFNpemUgPSBsaW5lRm9udFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmVNZXRyaWNzKSBsaW5lc01ldHJpY3MucHVzaChsaW5lTWV0cmljcyk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIGxpbmVOb2RlLnNldEF0dHJpYnV0ZSgnZHknLCBkeSk7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJlcXVpcmVzICd4JyB0byBiZSBzZXQgb24gdGhlIGZpcnN0IGxpbmUgd2hlbiBpbnNpZGUgYSB0ZXh0IHBhdGhcbiAgICAgICAgICAgIGlmIChpID4gMCB8fCB0ZXh0UGF0aCkgbGluZU5vZGUuc2V0QXR0cmlidXRlKCd4JywgeCk7XG4gICAgICAgICAgICBsaW5lTm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IGxpbmVDbGFzc05hbWU7XG4gICAgICAgICAgICBjb250YWluZXJOb2RlLmFwcGVuZENoaWxkKGxpbmVOb2RlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsaW5lLmxlbmd0aCArIDE7ICAgICAgLy8gKyAxID0gbmV3bGluZSBjaGFyYWN0ZXIuXG4gICAgICAgIH1cbiAgICAgICAgLy8gWSBBbGlnbm1lbnQgY2FsY3VsYXRpb25cbiAgICAgICAgaWYgKG5hbWVkVmVydGljYWxBbmNob3IpIHtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGR5ID0gY2FsY3VsYXRlRFkodmVydGljYWxBbmNob3IsIGxpbmVzTWV0cmljcywgZm9udFNpemUsIGxpbmVIZWlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbEFuY2hvciA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAvLyBBIHNob3J0Y3V0IGZvciB0b3AgYWxpZ25tZW50LiBJdCBkb2VzIG5vdCBkZXBlbmQgb24gZm9udC1zaXplIG5vciBsaW5lLWhlaWdodFxuICAgICAgICAgICAgICAgIGR5ID0gJzAuOGVtJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJoOyAvLyByZW1haW5pbmcgaGVpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByaCA9IHBhcnNlRmxvYXQobGluZUhlaWdodCkgfHwgMTtcbiAgICAgICAgICAgICAgICAgICAgcmggKj0gbGFzdEk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW1SZWdleC50ZXN0KGxpbmVIZWlnaHQpKSByaCAvPSBmb250U2l6ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUtbGluZSB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIHJoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbEFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSAoMC4zIC0gKHJoIC8gMikpICsgJ2VtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSAoLXJoIC0gMC4zKSArICdlbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmVydGljYWxBbmNob3IgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkeSA9ICcwZW0nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbEFuY2hvcikge1xuICAgICAgICAgICAgICAgIGR5ID0gdmVydGljYWxBbmNob3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIHZlcnRpY2FsIGFuY2hvciBpcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IC0gd2UgY2hhbmdlIHRoZSBgeWAgYXR0cmlidXRlIGluc3RlYWQgb2YgYGR5YC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdHRyKCd5JykgPT09IG51bGwpIHRoaXMuYXR0cigneScsIGFubm90YXRlZFkgfHwgJzAuOGVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyTm9kZS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnZHknLCBkeSk7XG4gICAgICAgIC8vIEFwcGVuZGluZyBsaW5lcyB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgdGhpcy5hcHBlbmQoY29udGFpbmVyTm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yaXplcn1cbiAgICAgKi9cbiAgICBWUHJvdG90eXBlLnJlbW92ZUF0dHIgPSBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgY29uc3QgdHJ1ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tuYW1lXTtcblxuICAgICAgICBjb25zdCB7IG5zLCBsb2NhbCB9ID0gVi5xdWFsaWZ5QXR0cih0cnVlTmFtZSk7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5ub2RlO1xuXG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZU5TKG5zLCBsb2NhbCkpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyhucywgbG9jYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGVsLmhhc0F0dHJpYnV0ZSh0cnVlTmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSh0cnVlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKFYuaXNVbmRlZmluZWQobmFtZSkpIHtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLm5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhdHRyc1thdHRyaWJ1dGVzW2ldLm5hbWVdID0gYXR0cmlidXRlc1tpXS52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFYuaXNTdHJpbmcobmFtZSkgJiYgVi5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWVzW25hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmFtZVthdHRyTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5ub3JtYWxpemVQYXRoID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0aGlzLnRhZ05hbWUoKTtcbiAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdQQVRIJykge1xuICAgICAgICAgICAgdGhpcy5hdHRyKCdkJywgVi5ub3JtYWxpemVQYXRoRGF0YSh0aGlzLmF0dHIoJ2QnKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB3aGlsZSAodGhpcy5ub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cnNcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yaXplcn1cbiAgICAgKi9cbiAgICBWUHJvdG90eXBlLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbihhdHRycykge1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oZWxzKSB7XG5cbiAgICAgICAgaWYgKCFWLmlzQXJyYXkoZWxzKSkge1xuICAgICAgICAgICAgZWxzID0gW2Vsc107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoVi50b05vZGUoZWxzW2ldKSk7IC8vIGxndG0gW2pzL3hzcy10aHJvdWdoLWRvbV1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihlbHMpIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLm5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgcmV0dXJuIGNoaWxkID8gVihjaGlsZCkuYmVmb3JlKGVscykgOiB0aGlzLmFwcGVuZChlbHMpO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uKGVscykge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlO1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcblxuICAgICAgICAgICAgaWYgKCFWLmlzQXJyYXkoZWxzKSkge1xuICAgICAgICAgICAgICAgIGVscyA9IFtlbHNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShWLnRvTm9kZShlbHNbaV0pLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBWLnRvTm9kZShub2RlKS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUpOyAvLyBsZ3RtIFtqcy94c3MtdGhyb3VnaC1kb21dXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHU1ZHRWxlbWVudCA/IHRoaXMgOiBWKHRoaXMubm9kZS5vd25lclNWR0VsZW1lbnQpO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnRhZ05hbWUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5kZWZzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5zdmcoKSB8fCB0aGlzO1xuICAgICAgICB2YXIgZGVmc05vZGUgPSBjb250ZXh0Lm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RlZnMnKVswXTtcbiAgICAgICAgaWYgKGRlZnNOb2RlKSByZXR1cm4gVihkZWZzTm9kZSk7XG4gICAgICAgIHJldHVybiBWKCdkZWZzJykuYXBwZW5kVG8oY29udGV4dCk7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2xvbmUgPSBWKHRoaXMubm9kZS5jbG9uZU5vZGUodHJ1ZS8qIGRlZXAgKi8pKTtcbiAgICAgICAgLy8gTm90ZSB0aGF0IGNsb25lIGluaGVyaXRzIGFsc28gSUQuIFRoZXJlZm9yZSwgd2UgbmVlZCB0byBjaGFuZ2UgaXQgaGVyZS5cbiAgICAgICAgY2xvbmUubm9kZS5pZCA9IFYudW5pcXVlSWQoKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmZpbmRPbmUgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuXG4gICAgICAgIHZhciBmb3VuZCA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kID8gVihmb3VuZCkgOiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cbiAgICAgICAgdmFyIHZlbHMgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gICAgICAgIGlmIChub2Rlcykge1xuXG4gICAgICAgICAgICAvLyBNYXAgRE9NIGVsZW1lbnRzIHRvIGBWYHMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVscy5wdXNoKFYobm9kZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2ZWxzO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIFYgZWxlbWVudHMgbWFkZSBmcm9tIGNoaWxkcmVuIG9mIHRoaXMubm9kZS5cbiAgICBWUHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXM7XG5cbiAgICAgICAgdmFyIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKFYoY2hpbGRyZW5baV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIFYgZWxlbWVudCBmcm9tIHBhcmVudE5vZGUgb2YgdGhpcy5ub2RlLlxuICAgIFZQcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBWKHRoaXMubm9kZS5wYXJlbnROb2RlKSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIGFuIGluZGV4IG9mIGFuIGVsZW1lbnQgaW5zaWRlIGl0cyBjb250YWluZXIuXG4gICAgVlByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLnByZXZpb3VzU2libGluZztcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgLy8gbm9kZVR5cGUgMSBmb3IgRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkgaW5kZXgrKztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5maW5kUGFyZW50QnlDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgdGVybWluYXRvcikge1xuXG4gICAgICAgIHZhciBvd25lclNWR0VsZW1lbnQgPSB0aGlzLm5vZGUub3duZXJTVkdFbGVtZW50O1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHRlcm1pbmF0b3IgJiYgbm9kZSAhPT0gb3duZXJTVkdFbGVtZW50KSB7XG5cbiAgICAgICAgICAgIHZhciB2ZWwgPSBWKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHZlbC5oYXNDbGFzcyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICAvLyBodHRwczovL2pzcGVyZi5jb20vZ2V0LWNvbW1vbi1wYXJlbnRcbiAgICBWUHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oZWwpIHtcblxuICAgICAgICB2YXIgYSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIGIgPSBWLnRvTm9kZShlbCk7XG4gICAgICAgIHZhciBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblxuICAgICAgICByZXR1cm4gKGEgPT09IGJ1cCkgfHwgISEoYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihidXApICYgMTYpKTtcbiAgICB9O1xuXG4gICAgLy8gQ29udmVydCBnbG9iYWwgcG9pbnQgaW50byB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgVlByb3RvdHlwZS50b0xvY2FsUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnKCkubm9kZTtcblxuICAgICAgICB2YXIgcCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICBwLnggPSB4O1xuICAgICAgICBwLnkgPSB5O1xuXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgIHZhciBnbG9iYWxQb2ludCA9IHAubWF0cml4VHJhbnNmb3JtKHN2Zy5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgICAgICAgdmFyIGdsb2JhbFRvTG9jYWxNYXRyaXggPSB0aGlzLmdldFRyYW5zZm9ybVRvRWxlbWVudChzdmcpLmludmVyc2UoKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJRTkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBvZGQgY2FzZXMuIChgVW5leHBlY3RlZCBjYWxsIHRvIG1ldGhvZCBvciBwcm9wZXJ0eSBhY2Nlc3NgKVxuICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBtYWtlIGRvIHdpdGggdGhlIG9yaWdpbmFsIGNvb3JkaWFuYXRlcy5cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbFBvaW50Lm1hdHJpeFRyYW5zZm9ybShnbG9iYWxUb0xvY2FsTWF0cml4KTtcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS50cmFuc2xhdGVDZW50ZXJUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KHsgdGFyZ2V0OiB0aGlzLnN2ZygpIH0pO1xuICAgICAgICB2YXIgY2VudGVyID0gYmJveC5jZW50ZXIoKTtcblxuICAgICAgICB0aGlzLnRyYW5zbGF0ZShwLnggLSBjZW50ZXIueCwgcC55IC0gY2VudGVyLnkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gRWZmaWNpZW50bHkgYXV0by1vcmllbnQgYW4gZWxlbWVudC4gVGhpcyBiYXNpY2FsbHkgaW1wbGVtZW50cyB0aGUgb3JpZW50PWF1dG8gYXR0cmlidXRlXG4gICAgLy8gb2YgbWFya2Vycy4gVGhlIGVhc2llc3Qgd2F5IG9mIHVuZGVyc3RhbmRpbmcgb24gd2hhdCB0aGlzIGRvZXMgaXMgdG8gaW1hZ2luZSB0aGUgZWxlbWVudCBpcyBhblxuICAgIC8vIGFycm93aGVhZC4gQ2FsbGluZyB0aGlzIG1ldGhvZCBvbiB0aGUgYXJyb3doZWFkIG1ha2VzIGl0IHBvaW50IHRvIHRoZSBgcG9zaXRpb25gIHBvaW50IHdoaWxlXG4gICAgLy8gYmVpbmcgYXV0by1vcmllbnRlZCAocHJvcGVybHkgcm90YXRlZCkgdG93YXJkcyB0aGUgYHJlZmVyZW5jZWAgcG9pbnQuXG4gICAgLy8gYHRhcmdldGAgaXMgdGhlIGVsZW1lbnQgcmVsYXRpdmUgdG8gd2hpY2ggdGhlIHRyYW5zZm9ybWF0aW9ucyBhcmUgYXBwbGllZC4gVXN1YWxseSBhIHZpZXdwb3J0LlxuICAgIFZQcm90b3R5cGUudHJhbnNsYXRlQW5kQXV0b09yaWVudCA9IGZ1bmN0aW9uKHBvc2l0aW9uLCByZWZlcmVuY2UsIHRhcmdldCkge1xuXG4gICAgICAgIHBvc2l0aW9uID0gbmV3IGcuUG9pbnQocG9zaXRpb24pO1xuICAgICAgICByZWZlcmVuY2UgPSAgbmV3IGcuUG9pbnQocmVmZXJlbmNlKTtcbiAgICAgICAgdGFyZ2V0IHx8ICh0YXJnZXQgPSB0aGlzLnN2ZygpKTtcblxuICAgICAgICAvLyBDbGVhbi11cCBwcmV2aW91c2x5IHNldCB0cmFuc2Zvcm1hdGlvbnMgZXhjZXB0IHRoZSBzY2FsZS4gSWYgd2UgZGlkbid0IGNsZWFuIHVwIHRoZVxuICAgICAgICAvLyBwcmV2aW91cyB0cmFuc2Zvcm1hdGlvbnMgdGhlbiB0aGV5J2QgYWRkIHVwIHdpdGggdGhlIG9sZCBvbmVzLiBTY2FsZSBpcyBhbiBleGNlcHRpb24gYXNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBhZGQgdXAsIGNvbnNpZGVyOiBgdGhpcy5zY2FsZSgyKS5zY2FsZSgyKS5zY2FsZSgyKWAuIFRoZSByZXN1bHQgaXMgdGhhdCB0aGVcbiAgICAgICAgLy8gZWxlbWVudCBpcyBzY2FsZWQgYnkgdGhlIGZhY3RvciAyLCBub3QgOC5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZSgpO1xuICAgICAgICB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goeyB0YXJnZXQ6IHRhcmdldCB9KS5zY2FsZShzY2FsZS5zeCwgc2NhbGUuc3kpO1xuXG4gICAgICAgIC8vIDEuIFRyYW5zbGF0ZSB0byBvcmlnaW4uXG4gICAgICAgIHZhciB0cmFuc2xhdGVUb09yaWdpbiA9IFYuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgICAgIHRyYW5zbGF0ZVRvT3JpZ2luLnNldFRyYW5zbGF0ZSgtYmJveC54IC0gYmJveC53aWR0aCAvIDIsIC1iYm94LnkgLSBiYm94LmhlaWdodCAvIDIpO1xuXG4gICAgICAgIC8vIDIuIFJvdGF0ZSBhcm91bmQgb3JpZ2luLlxuICAgICAgICB2YXIgcm90YXRlQXJvdW5kT3JpZ2luID0gVi5jcmVhdGVTVkdUcmFuc2Zvcm0oKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gcG9zaXRpb24uYW5nbGVCZXR3ZWVuKHJlZmVyZW5jZSwgcG9zaXRpb24uY2xvbmUoKS5vZmZzZXQoMSwgMCkpO1xuICAgICAgICBpZiAoYW5nbGUpIHJvdGF0ZUFyb3VuZE9yaWdpbi5zZXRSb3RhdGUoYW5nbGUsIDAsIDApO1xuXG4gICAgICAgIC8vIDMuIFRyYW5zbGF0ZSB0byB0aGUgYHBvc2l0aW9uYCArIHRoZSBvZmZzZXQgKGhhbGYgbXkgd2lkdGgpIHRvd2FyZHMgdGhlIGByZWZlcmVuY2VgIHBvaW50LlxuICAgICAgICB2YXIgdHJhbnNsYXRlRnJvbU9yaWdpbiA9IFYuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgICAgIHZhciBmaW5hbFBvc2l0aW9uID0gcG9zaXRpb24uY2xvbmUoKS5tb3ZlKHJlZmVyZW5jZSwgYmJveC53aWR0aCAvIDIpO1xuICAgICAgICB0cmFuc2xhdGVGcm9tT3JpZ2luLnNldFRyYW5zbGF0ZSgyICogcG9zaXRpb24ueCAtIGZpbmFsUG9zaXRpb24ueCwgMiAqIHBvc2l0aW9uLnkgLSBmaW5hbFBvc2l0aW9uLnkpO1xuXG4gICAgICAgIC8vIDQuIEdldCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhpcyBub2RlXG4gICAgICAgIHZhciBjdG0gPSB0aGlzLmdldFRyYW5zZm9ybVRvRWxlbWVudCh0YXJnZXQpO1xuXG4gICAgICAgIC8vIDUuIEFwcGx5IHRyYW5zZm9ybWF0aW9ucyBhbmQgdGhlIHNjYWxlXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBWLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgICAgICB0cmFuc2Zvcm0uc2V0TWF0cml4KFxuICAgICAgICAgICAgdHJhbnNsYXRlRnJvbU9yaWdpbi5tYXRyaXgubXVsdGlwbHkoXG4gICAgICAgICAgICAgICAgcm90YXRlQXJvdW5kT3JpZ2luLm1hdHJpeC5tdWx0aXBseShcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlVG9PcmlnaW4ubWF0cml4Lm11bHRpcGx5KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLnNjYWxlKHNjYWxlLnN4LCBzY2FsZS5zeSkpKSkpO1xuXG4gICAgICAgIHRoaXMuYXR0cigndHJhbnNmb3JtJywgVi5tYXRyaXhUb1RyYW5zZm9ybVN0cmluZyh0cmFuc2Zvcm0ubWF0cml4KSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuYW5pbWF0ZUFsb25nUGF0aCA9IGZ1bmN0aW9uKGF0dHJzLCBwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IFYudG9Ob2RlKHBhdGgpO1xuXG4gICAgICAgIHZhciBpZCA9IFYuZW5zdXJlSWQocGF0aCk7XG4gICAgICAgIHZhciBhbmltYXRlTW90aW9uID0gVignYW5pbWF0ZU1vdGlvbicsIGF0dHJzKTtcbiAgICAgICAgdmFyIG1wYXRoID0gVignbXBhdGgnLCB7ICd4bGluazpocmVmJzogJyMnICsgaWQgfSk7XG5cbiAgICAgICAgYW5pbWF0ZU1vdGlvbi5hcHBlbmQobXBhdGgpO1xuXG4gICAgICAgIHRoaXMuYXBwZW5kKGFuaW1hdGVNb3Rpb24pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYW5pbWF0ZU1vdGlvbi5ub2RlLmJlZ2luRWxlbWVudCgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgSUUgOS5cbiAgICAgICAgICAgIC8vIFJ1biB0aGUgYW5pbWF0aW9uIHByb2dyYW1tYXRpY2FsbHkgaWYgRmFrZVNtaWxlIChgaHR0cDovL2xldW5lbi5tZS9mYWtlc21pbGUvYCkgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NtaWxpbmcnKSA9PT0gJ2Zha2UnKSB7XG4gICAgICAgICAgICAgICAgLyogZ2xvYmFsIGdldFRhcmdldHM6dHJ1ZSwgQW5pbWF0b3I6dHJ1ZSwgYW5pbWF0b3JzOnRydWUgaWQyYW5pbTp0cnVlICovXG4gICAgICAgICAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGFuaW1hdGlvbi4gKFNlZSBgaHR0cHM6Ly9hbnN3ZXJzLmxhdW5jaHBhZC5uZXQvc21pbC8rcXVlc3Rpb24vMjAzMzMzYClcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pbWF0ZU1vdGlvbi5ub2RlO1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmltYXRvcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JRCA9IGFuaW1hdGlvbi5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbklEKSBpZDJhbmltW2FuaW1hdGlvbklEXSA9IGFuaW1hdGlvbjtcblxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gZ2V0VGFyZ2V0cyhhbmltYXRpb24pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoYW5pbWF0aW9uLCB0YXJnZXQsIGkpO1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRvcnMucHVzaChhbmltYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5hbmltYXRvcnNbaV0gPSBhbmltYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3IucmVnaXN0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgLy8gU3BsaXQgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiB0b2tlbnMuXG4gICAgLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbiAgICBjb25zdCBub0hUTUxXaGl0ZXNwYWNlUmVnZXggPSAvW15cXHgyMFxcdFxcclxcblxcZl0rL2c7XG4gICAgZnVuY3Rpb24gZ2V0VG9rZW5MaXN0KHN0cikge1xuICAgICAgICBpZiAoIVYuaXNTdHJpbmcoc3RyKSkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0oKS5tYXRjaChub0hUTUxXaGl0ZXNwYWNlUmVnZXgpIHx8IFtdO1xuICAgIH1cblxuICAgIFZQcm90b3R5cGUuaGFzQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgaWYgKCFWLmlzU3RyaW5nKGNsYXNzTmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lLnRyaW0oKSk7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoLi4uZ2V0VG9rZW5MaXN0KGNsYXNzTmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVlByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NMaXN0LnJlbW92ZSguLi5nZXRUb2tlbkxpc3QoY2xhc3NOYW1lKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24oY2xhc3NOYW1lLCB0b0FkZCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlbkxpc3QoY2xhc3NOYW1lKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5jbGFzc0xpc3QudG9nZ2xlKHRva2Vuc1tpXSwgdG9BZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcnBvbGF0ZSBwYXRoIGJ5IGRpc2NyZXRlIHBvaW50cy4gVGhlIHByZWNpc2lvbiBvZiB0aGUgc2FtcGxpbmdcbiAgICAvLyBpcyBjb250cm9sbGVkIGJ5IGBpbnRlcnZhbGAuIEluIG90aGVyIHdvcmRzLCBgc2FtcGxlKClgIHdpbGwgZ2VuZXJhdGVcbiAgICAvLyBhIHBvaW50IG9uIHRoZSBwYXRoIHN0YXJ0aW5nIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGggZ29pbmcgdG8gdGhlIGVuZFxuICAgIC8vIGV2ZXJ5IGBpbnRlcnZhbGAgcGl4ZWxzLlxuICAgIC8vIFRoZSBzYW1wbGVyIGNhbiBiZSB2ZXJ5IHVzZWZ1bCBmb3IgZS5nLiBmaW5kaW5nIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3b1xuICAgIC8vIHBhdGhzIChmaW5kaW5nIHRoZSB0d28gY2xvc2VzdCBwb2ludHMgZnJvbSB0d28gc2FtcGxlcykuXG4gICAgVlByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXG4gICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgIHZhciBsZW5ndGggPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgICAgIHZhciBzYW1wbGVzID0gW107XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDA7XG4gICAgICAgIHZhciBzYW1wbGU7XG4gICAgICAgIHdoaWxlIChkaXN0YW5jZSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgc2FtcGxlID0gbm9kZS5nZXRQb2ludEF0TGVuZ3RoKGRpc3RhbmNlKTtcbiAgICAgICAgICAgIHNhbXBsZXMucHVzaCh7IHg6IHNhbXBsZS54LCB5OiBzYW1wbGUueSwgZGlzdGFuY2U6IGRpc3RhbmNlIH0pO1xuICAgICAgICAgICAgZGlzdGFuY2UgKz0gaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhbXBsZXM7XG4gICAgfTtcblxuICAgIFZQcm90b3R5cGUuY29udmVydFRvUGF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwYXRoID0gVigncGF0aCcpO1xuICAgICAgICBwYXRoLmF0dHIodGhpcy5hdHRyKCkpO1xuICAgICAgICB2YXIgZCA9IHRoaXMuY29udmVydFRvUGF0aERhdGEoKTtcbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgIHBhdGguYXR0cignZCcsIGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBWUHJvdG90eXBlLmNvbnZlcnRUb1BhdGhEYXRhID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0aGlzLnRhZ05hbWUoKTtcblxuICAgICAgICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1BBVEgnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2QnKTtcbiAgICAgICAgICAgIGNhc2UgJ0xJTkUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBWLmNvbnZlcnRMaW5lVG9QYXRoRGF0YSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnUE9MWUdPTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYuY29udmVydFBvbHlnb25Ub1BhdGhEYXRhKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBjYXNlICdQT0xZTElORSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYuY29udmVydFBvbHlsaW5lVG9QYXRoRGF0YSh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgY2FzZSAnRUxMSVBTRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFYuY29udmVydEVsbGlwc2VUb1BhdGhEYXRhKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBjYXNlICdDSVJDTEUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBWLmNvbnZlcnRDaXJjbGVUb1BhdGhEYXRhKHRoaXMubm9kZSk7XG4gICAgICAgICAgICBjYXNlICdSRUNUJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVi5jb252ZXJ0UmVjdFRvUGF0aERhdGEodGhpcy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0YWdOYW1lICsgJyBjYW5ub3QgYmUgY29udmVydGVkIHRvIFBBVEguJyk7XG4gICAgfTtcblxuICAgIFYucHJvdG90eXBlLnRvR2VvbWV0cnlTaGFwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCwgeSwgd2lkdGgsIGhlaWdodCwgY3gsIGN5LCByLCByeCwgcnksIHBvaW50cywgZCwgeDEsIHgyLCB5MSwgeTI7XG4gICAgICAgIHN3aXRjaCAodGhpcy50YWdOYW1lKCkpIHtcblxuICAgICAgICAgICAgY2FzZSAnUkVDVCc6XG4gICAgICAgICAgICAgICAgeCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd4JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgeSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignd2lkdGgnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignaGVpZ2h0JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NJUkNMRSc6XG4gICAgICAgICAgICAgICAgY3ggPSBwYXJzZUZsb2F0KHRoaXMuYXR0cignY3gnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICBjeSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdjeScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHIgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigncicpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5FbGxpcHNlKHsgeDogY3gsIHk6IGN5IH0sIHIsIHIpO1xuXG4gICAgICAgICAgICBjYXNlICdFTExJUFNFJzpcbiAgICAgICAgICAgICAgICBjeCA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdjeCcpKSB8fCAwO1xuICAgICAgICAgICAgICAgIGN5ID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ2N5JykpIHx8IDA7XG4gICAgICAgICAgICAgICAgcnggPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigncngnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICByeSA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCdyeScpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5FbGxpcHNlKHsgeDogY3gsIHk6IGN5IH0sIHJ4LCByeSk7XG5cbiAgICAgICAgICAgIGNhc2UgJ1BPTFlMSU5FJzpcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBWLmdldFBvaW50c0Zyb21TdmdOb2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZy5Qb2x5bGluZShwb2ludHMpO1xuXG4gICAgICAgICAgICBjYXNlICdQT0xZR09OJzpcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBWLmdldFBvaW50c0Zyb21TdmdOb2RlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoID4gMSkgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGcuUG9seWxpbmUocG9pbnRzKTtcblxuICAgICAgICAgICAgY2FzZSAnUEFUSCc6XG4gICAgICAgICAgICAgICAgZCA9IHRoaXMuYXR0cignZCcpO1xuICAgICAgICAgICAgICAgIGlmICghZy5QYXRoLmlzRGF0YVN1cHBvcnRlZChkKSkgZCA9IFYubm9ybWFsaXplUGF0aERhdGEoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLlBhdGgoZCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ0xJTkUnOlxuICAgICAgICAgICAgICAgIHgxID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3gxJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgeTEgPSBwYXJzZUZsb2F0KHRoaXMuYXR0cigneTEnKSkgfHwgMDtcbiAgICAgICAgICAgICAgICB4MiA9IHBhcnNlRmxvYXQodGhpcy5hdHRyKCd4MicpKSB8fCAwO1xuICAgICAgICAgICAgICAgIHkyID0gcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3kyJykpIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnLkxpbmUoeyB4OiB4MSwgeTogeTEgfSwgeyB4OiB4MiwgeTogeTIgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGEgcmVjdGFuZ2xlXG4gICAgICAgIHJldHVybiB0aGlzLmdldEJCb3goKTtcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgaW50ZXJzZWN0aW9uIG9mIGEgbGluZSBzdGFydGluZyBpbiB0aGUgY2VudGVyXG4gICAgLy8gb2YgdGhlIFNWRyBgbm9kZWAgZW5kaW5nIGluIHRoZSBwb2ludCBgcmVmYC5cbiAgICAvLyBgdGFyZ2V0YCBpcyBhbiBTVkcgZWxlbWVudCB0byB3aGljaCBgbm9kZWBzIHRyYW5zZm9ybWF0aW9ucyBhcmUgcmVsYXRpdmUgdG8uXG4gICAgLy8gTm90ZSB0aGF0IGByZWZgIHBvaW50IG11c3QgYmUgaW4gdGhlIGNvb3JkaW5hdGUgc3lzdGVtIG9mIHRoZSBgdGFyZ2V0YCBmb3IgdGhpcyBmdW5jdGlvbiB0byB3b3JrIHByb3Blcmx5LlxuICAgIC8vIFJldHVybnMgYSBwb2ludCBpbiB0aGUgYHRhcmdldGAgY29vcmRpbmF0ZSBzeXN0ZW0gKHRoZSBzYW1lIHN5c3RlbSBhcyBgcmVmYCBpcyBpbikgaWZcbiAgICAvLyBhbiBpbnRlcnNlY3Rpb24gaXMgZm91bmQuIFJldHVybnMgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgIFZQcm90b3R5cGUuZmluZEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHJlZiwgdGFyZ2V0KSB7XG5cbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnKCkubm9kZTtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHN2ZztcbiAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goeyB0YXJnZXQ6IHRhcmdldCB9KTtcbiAgICAgICAgdmFyIGNlbnRlciA9IGJib3guY2VudGVyKCk7XG5cbiAgICAgICAgaWYgKCFiYm94LmludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQocmVmKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgc3BvdDtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSB0aGlzLnRhZ05hbWUoKTtcblxuICAgICAgICAvLyBMaXR0bGUgc3BlZWQgdXAgb3B0aW1pemF0aW9uIGZvciBgPHJlY3Q+YCBlbGVtZW50LiBXZSBkbyBub3QgZG8gY29udmVyc2lvblxuICAgICAgICAvLyB0byBwYXRoIGVsZW1lbnQgYW5kIHNhbXBsaW5nIGJ1dCBkaXJlY3RseSBjYWxjdWxhdGUgdGhlIGludGVyc2VjdGlvbiB0aHJvdWdoXG4gICAgICAgIC8vIGEgdHJhbnNmb3JtZWQgZ2VvbWV0cmljYWwgcmVjdGFuZ2xlLlxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ1JFQ1QnKSB7XG5cbiAgICAgICAgICAgIHZhciBnUmVjdCA9IG5ldyBnLlJlY3QoXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmF0dHIoJ3gnKSB8fCAwKSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMuYXR0cigneScpIHx8IDApLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5hdHRyKCd3aWR0aCcpKSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMuYXR0cignaGVpZ2h0JykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSByZWN0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB3aXRoIHJlZ2FyZHMgdG8gdGhlIFNWRyBkb2N1bWVudC5cbiAgICAgICAgICAgIHZhciByZWN0TWF0cml4ID0gdGhpcy5nZXRUcmFuc2Zvcm1Ub0VsZW1lbnQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIERlY29tcG9zZSB0aGUgbWF0cml4IHRvIGZpbmQgdGhlIHJvdGF0aW9uIGFuZ2xlLlxuICAgICAgICAgICAgdmFyIHJlY3RNYXRyaXhDb21wb25lbnRzID0gVi5kZWNvbXBvc2VNYXRyaXgocmVjdE1hdHJpeCk7XG4gICAgICAgICAgICAvLyBOb3cgd2Ugd2FudCB0byByb3RhdGUgdGhlIHJlY3RhbmdsZSBiYWNrIHNvIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiB1c2UgYGludGVyc2VjdGlvbldpdGhMaW5lRnJvbUNlbnRlclRvUG9pbnQoKWAgcGFzc2luZyB0aGUgYW5nbGUgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAgICAgICAgICAgIHZhciByZXNldFJvdGF0aW9uID0gc3ZnLmNyZWF0ZVNWR1RyYW5zZm9ybSgpO1xuICAgICAgICAgICAgcmVzZXRSb3RhdGlvbi5zZXRSb3RhdGUoLXJlY3RNYXRyaXhDb21wb25lbnRzLnJvdGF0aW9uLCBjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBWLnRyYW5zZm9ybVJlY3QoZ1JlY3QsIHJlc2V0Um90YXRpb24ubWF0cml4Lm11bHRpcGx5KHJlY3RNYXRyaXgpKTtcbiAgICAgICAgICAgIHNwb3QgPSAobmV3IGcuUmVjdChyZWN0KSkuaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludChyZWYsIHJlY3RNYXRyaXhDb21wb25lbnRzLnJvdGF0aW9uKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdQQVRIJyB8fCB0YWdOYW1lID09PSAnUE9MWUdPTicgfHwgdGFnTmFtZSA9PT0gJ1BPTFlMSU5FJyB8fCB0YWdOYW1lID09PSAnQ0lSQ0xFJyB8fCB0YWdOYW1lID09PSAnRUxMSVBTRScpIHtcblxuICAgICAgICAgICAgdmFyIHBhdGhOb2RlID0gKHRhZ05hbWUgPT09ICdQQVRIJykgPyB0aGlzIDogdGhpcy5jb252ZXJ0VG9QYXRoKCk7XG4gICAgICAgICAgICB2YXIgc2FtcGxlcyA9IHBhdGhOb2RlLnNhbXBsZSgpO1xuICAgICAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFNhbXBsZXMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIGksIHNhbXBsZSwgZ3AsIGNlbnRlckRpc3RhbmNlLCByZWZEaXN0YW5jZSwgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBzYW1wbGUgPSBzYW1wbGVzW2ldO1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHNhbXBsZSBwb2ludCBpbiB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gdGhlIGdsb2JhbCBjb29yZGluYXRlIHN5c3RlbS5cbiAgICAgICAgICAgICAgICBncCA9IFYuY3JlYXRlU1ZHUG9pbnQoc2FtcGxlLngsIHNhbXBsZS55KTtcbiAgICAgICAgICAgICAgICBncCA9IGdwLm1hdHJpeFRyYW5zZm9ybSh0aGlzLmdldFRyYW5zZm9ybVRvRWxlbWVudCh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICBzYW1wbGUgPSBuZXcgZy5Qb2ludChncCk7XG4gICAgICAgICAgICAgICAgY2VudGVyRGlzdGFuY2UgPSBzYW1wbGUuZGlzdGFuY2UoY2VudGVyKTtcbiAgICAgICAgICAgICAgICAvLyBQZW5hbGl6ZSBhIGhpZ2hlciBkaXN0YW5jZSB0byB0aGUgcmVmZXJlbmNlIHBvaW50IGJ5IDEwJS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGdpdmVzIGJldHRlciByZXN1bHRzLiBUaGlzIGlzIGR1ZSB0b1xuICAgICAgICAgICAgICAgIC8vIGluYWNjdXJhY2llcyBpbnRyb2R1Y2VkIGJ5IHJvdW5kaW5nIGVycm9ycyBhbmQgZ2V0UG9pbnRBdExlbmd0aCgpIHJldHVybnMuXG4gICAgICAgICAgICAgICAgcmVmRGlzdGFuY2UgPSBzYW1wbGUuZGlzdGFuY2UocmVmKSAqIDEuMTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGNlbnRlckRpc3RhbmNlICsgcmVmRGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlcyA9IFt7IHNhbXBsZTogc2FtcGxlLCByZWZEaXN0YW5jZTogcmVmRGlzdGFuY2UgfV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlICsgMSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2FtcGxlcy5wdXNoKHsgc2FtcGxlOiBzYW1wbGUsIHJlZkRpc3RhbmNlOiByZWZEaXN0YW5jZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsb3Nlc3RTYW1wbGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJlZkRpc3RhbmNlIC0gYi5yZWZEaXN0YW5jZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2xvc2VzdFNhbXBsZXNbMF0pIHtcbiAgICAgICAgICAgICAgICBzcG90ID0gY2xvc2VzdFNhbXBsZXNbMF0uc2FtcGxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwb3Q7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yaXplcn1cbiAgICAgKi9cbiAgICBWUHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG5cbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLm5vZGU7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHIobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRydWVOYW1lID0gYXR0cmlidXRlTmFtZXNbbmFtZV07XG5cbiAgICAgICAgY29uc3QgeyBucyB9ID0gVi5xdWFsaWZ5QXR0cih0cnVlTmFtZSk7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgLy8gQXR0cmlidXRlIG5hbWVzIGNhbiBiZSBuYW1lc3BhY2VkLiBFLmcuIGBpbWFnZWAgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGhhdmUgYSBgeGxpbms6aHJlZmAgYXR0cmlidXRlIHRvIHNldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZS5cbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKG5zLCB0cnVlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRydWVOYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgICBlbC5pZCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKHRydWVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gQ3JlYXRlIGFuIFNWRyBkb2N1bWVudCBlbGVtZW50LlxuICAgIC8vIElmIGBjb250ZW50YCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgU1ZHIGNvbnRlbnQgb2YgdGhlIGA8c3ZnPmAgcm9vdCBlbGVtZW50LlxuICAgIFYuY3JlYXRlU3ZnRG9jdW1lbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG5cbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IFhNTFN0cmluZyA9IGA8c3ZnIHhtbG5zPVwiJHtucy5zdmd9XCIgeG1sbnM6eGxpbms9XCIke25zLnhsaW5rfVwiIHZlcnNpb249XCIke1NWR1ZlcnNpb259XCI+JHtjb250ZW50fTwvc3ZnPmA7XG4gICAgICAgICAgICBjb25zdCB7IGRvY3VtZW50RWxlbWVudCB9ID0gVi5wYXJzZVhNTChYTUxTdHJpbmcsIHsgYXN5bmM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucy5zdmcsICdzdmcnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZU5TKG5zLnhtbG5zLCAneG1sbnM6eGxpbmsnLCBucy54bGluayk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCBTVkdWZXJzaW9uKTtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9O1xuXG4gICAgVi5jcmVhdGVTVkdTdHlsZSA9IGZ1bmN0aW9uKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgY29uc3QgeyBub2RlIH0gPSBWKCdzdHlsZScsIHsgdHlwZTogJ3RleHQvY3NzJyB9LCBbXG4gICAgICAgICAgICBWLmNyZWF0ZUNEQVRBU2VjdGlvbihzdHlsZXNoZWV0KVxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIFYuY3JlYXRlQ0RBVEFTZWN0aW9uID0gZnVuY3Rpb24oZGF0YSA9ICcnKSB7XG4gICAgICAgIGNvbnN0IHhtbCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KG51bGwsICd4bWwnLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHhtbC5jcmVhdGVDREFUQVNlY3Rpb24oZGF0YSk7XG4gICAgfTtcblxuICAgIFYuaWRDb3VudGVyID0gMDtcblxuICAgIC8vIEEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgY2xpZW50IHNlc3Npb24gd2l0aCBldmVyeSBjYWxsLlxuICAgIFYudW5pcXVlSWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gJ3YtJyArICgrK1YuaWRDb3VudGVyKTtcbiAgICB9O1xuXG4gICAgVi50b05vZGUgPSBmdW5jdGlvbihlbCkge1xuXG4gICAgICAgIHJldHVybiBWLmlzVihlbCkgPyBlbC5ub2RlIDogKGVsLm5vZGVOYW1lICYmIGVsIHx8IGVsWzBdKTtcbiAgICB9O1xuXG4gICAgVi5lbnN1cmVJZCA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICBub2RlID0gVi50b05vZGUobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlLmlkIHx8IChub2RlLmlkID0gVi51bmlxdWVJZCgpKTtcbiAgICB9O1xuXG4gICAgLy8gUmVwbGFjZSBhbGwgc3BhY2VzIHdpdGggdGhlIFVuaWNvZGUgTm8tYnJlYWsgc3BhY2UgKGh0dHA6Ly93d3cuZmlsZWZvcm1hdC5pbmZvL2luZm8vdW5pY29kZS9jaGFyL2EwL2luZGV4Lmh0bSkuXG4gICAgLy8gSUUgd291bGQgb3RoZXJ3aXNlIGNvbGxhcHNlIGFsbCBzcGFjZXMgaW50byBvbmUuIFRoaXMgaXMgdXNlZCBpbiB0aGUgdGV4dCgpIG1ldGhvZCBidXQgaXQgaXNcbiAgICAvLyBhbHNvIGV4cG9zZWQgc28gdGhhdCB0aGUgcHJvZ3JhbW1lciBjYW4gdXNlIGl0IGluIGNhc2UgaGUgbmVlZHMgdG8uIFRoaXMgaXMgdXNlZnVsIGUuZy4gaW4gdGVzdHNcbiAgICAvLyB3aGVuIHlvdSB3YW50IHRvIGNvbXBhcmUgdGhlIGFjdHVhbCBET00gdGV4dCBjb250ZW50IHdpdGhvdXQgaGF2aW5nIHRvIGFkZCB0aGUgdW5pY29kZSBjaGFyYWN0ZXIgaW5cbiAgICAvLyB0aGUgcGxhY2Ugb2YgYWxsIHNwYWNlcy5cbiAgICBWLnNhbml0aXplVGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcblxuICAgICAgICByZXR1cm4gKHRleHQgfHwgJycpLnJlcGxhY2UoLyAvZywgJ1xcdTAwQTAnKTtcbiAgICB9O1xuXG4gICAgVi5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfTtcblxuICAgIFYuaXNTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH07XG5cbiAgICBWLmlzT2JqZWN0ID0gZnVuY3Rpb24odmFsdWUpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuICAgIH07XG5cbiAgICBWLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgVi5wYXJzZVhNTCA9IGZ1bmN0aW9uKGRhdGEsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgeG1sO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuXG4gICAgICAgICAgICBpZiAoIVYuaXNVbmRlZmluZWQob3B0LmFzeW5jKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5hc3luYyA9IG9wdC5hc3luYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhLCAndGV4dC94bWwnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHhtbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFyc2VyZXJyb3InKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYTUw6ICcgKyBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4bWw7XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBvYmplY3Qgd2hpY2ggZG9lcyBub3QgaW5oZXJpdCBhbnkgcHJvcGVydGllcyBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAvLyBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8gdXNlIGFuIG9iamVjdCBhcyBhIGRpY3Rpb25hcnkgd2l0aG91dCBoYXZpbmcgdG9cbiAgICAvLyB3b3JyeSBhYm91dCBpbmhlcml0ZWQgcHJvcGVydGllcyBzdWNoIGFzIGB0b1N0cmluZ2AsIGB2YWx1ZU9mYCBldGMuXG4gICAgY29uc3QgX2F0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIExpc3Qgb2YgYXR0cmlidXRlcyBmb3Igd2hpY2ggbm90IHRvIHNwbGl0IGNhbWVsIGNhc2Ugd29yZHMuXG4gICAgLy8gSXQgY29udGFpbnMga25vd24gU1ZHIGF0dHJpYnV0ZSBuYW1lcyBhbmQgbWF5IGJlIGV4dGVuZGVkIHdpdGggdXNlci1kZWZpbmVkIGF0dHJpYnV0ZSBuYW1lcy5cbiAgICBbXG4gICAgICAgICdiYXNlRnJlcXVlbmN5JyxcbiAgICAgICAgJ2Jhc2VQcm9maWxlJyxcbiAgICAgICAgJ2NsaXBQYXRoVW5pdHMnLFxuICAgICAgICAnY29udGVudFNjcmlwdFR5cGUnLFxuICAgICAgICAnY29udGVudFN0eWxlVHlwZScsXG4gICAgICAgICdkaWZmdXNlQ29uc3RhbnQnLFxuICAgICAgICAnZWRnZU1vZGUnLFxuICAgICAgICAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgICAgICdmaWx0ZXJSZXMnLCAvLyBkZXByZWNhdGVkXG4gICAgICAgICdmaWx0ZXJVbml0cycsXG4gICAgICAgICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgICAgICdncmFkaWVudFVuaXRzJyxcbiAgICAgICAgJ2tlcm5lbE1hdHJpeCcsXG4gICAgICAgICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAgICAgICAgJ2tleVBvaW50cycsXG4gICAgICAgICdsZW5ndGhBZGp1c3QnLFxuICAgICAgICAnbGltaXRpbmdDb25lQW5nbGUnLFxuICAgICAgICAnbWFya2VySGVpZ2h0JyxcbiAgICAgICAgJ21hcmtlclVuaXRzJyxcbiAgICAgICAgJ21hcmtlcldpZHRoJyxcbiAgICAgICAgJ21hc2tDb250ZW50VW5pdHMnLFxuICAgICAgICAnbWFza1VuaXRzJyxcbiAgICAgICAgJ251bU9jdGF2ZXMnLFxuICAgICAgICAncGF0aExlbmd0aCcsXG4gICAgICAgICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgICAgICAgJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICAgICAgICAncGF0dGVyblVuaXRzJyxcbiAgICAgICAgJ3BvaW50c0F0WCcsXG4gICAgICAgICdwb2ludHNBdFknLFxuICAgICAgICAncG9pbnRzQXRaJyxcbiAgICAgICAgJ3ByZXNlcnZlQWxwaGEnLFxuICAgICAgICAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgICAgICdwcmltaXRpdmVVbml0cycsXG4gICAgICAgICdyZWZYJyxcbiAgICAgICAgJ3JlZlknLFxuICAgICAgICAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgICAgICAgJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICAgICAgICAnc3BlY3VsYXJDb25zdGFudCcsXG4gICAgICAgICdzcGVjdWxhckV4cG9uZW50JyxcbiAgICAgICAgJ3NwcmVhZE1ldGhvZCcsXG4gICAgICAgICdzdGFydE9mZnNldCcsXG4gICAgICAgICdzdGREZXZpYXRpb24nLFxuICAgICAgICAnc3RpdGNoVGlsZXMnLFxuICAgICAgICAnc3VyZmFjZVNjYWxlJyxcbiAgICAgICAgJ3N5c3RlbUxhbmd1YWdlJyxcbiAgICAgICAgJ3RhYmxlVmFsdWVzJyxcbiAgICAgICAgJ3RhcmdldFgnLFxuICAgICAgICAndGFyZ2V0WScsXG4gICAgICAgICd0ZXh0TGVuZ3RoJyxcbiAgICAgICAgJ3ZpZXdCb3gnLFxuICAgICAgICAndmlld1RhcmdldCcsIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgJ3hDaGFubmVsU2VsZWN0b3InLFxuICAgICAgICAneUNoYW5uZWxTZWxlY3RvcicsXG4gICAgICAgICd6b29tQW5kUGFuJyAvLyBkZXByZWNhdGVkXG4gICAgXS5mb3JFYWNoKChuYW1lKSA9PiBfYXR0cmlidXRlTmFtZXNbbmFtZV0gPSBuYW1lKTtcblxuICAgIF9hdHRyaWJ1dGVOYW1lc1sneGxpbmtTaG93J10gPSAneGxpbms6c2hvdyc7XG4gICAgX2F0dHJpYnV0ZU5hbWVzWyd4bGlua1JvbGUnXSA9ICd4bGluazpyb2xlJztcbiAgICBfYXR0cmlidXRlTmFtZXNbJ3hsaW5rQWN0dWF0ZSddID0gJ3hsaW5rOmFjdHVhdGUnO1xuICAgIF9hdHRyaWJ1dGVOYW1lc1sneGxpbmtIcmVmJ10gPSAneGxpbms6aHJlZic7XG4gICAgX2F0dHJpYnV0ZU5hbWVzWyd4bGlua1R5cGUnXSA9ICd4bGluazp0eXBlJztcbiAgICBfYXR0cmlidXRlTmFtZXNbJ3hsaW5rVGl0bGUnXSA9ICd4bGluazp0aXRsZSc7XG4gICAgX2F0dHJpYnV0ZU5hbWVzWyd4bWxCYXNlJ10gPSAneG1sOmJhc2UnO1xuICAgIF9hdHRyaWJ1dGVOYW1lc1sneG1sTGFuZyddID0gJ3htbDpsYW5nJztcbiAgICBfYXR0cmlidXRlTmFtZXNbJ3htbFNwYWNlJ10gPSAneG1sOnNwYWNlJztcblxuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gbmV3IFByb3h5KF9hdHRyaWJ1dGVOYW1lcywge1xuICAgICAgICBnZXQoY2FjaGUsIG5hbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjYWNoZSBpcyBhIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlIG5hbWVzLiBTZWUgYF9hdHRyaWJ1dGVOYW1lc2AgYWJvdmUuXG4gICAgICAgICAgICAvLyBJZiB0aGUgYXR0cmlidXRlIG5hbWUgaXMgbm90IGluIHRoZSBjYWNoZSwgaXQgbWVhbnMgdGhhdCBpdCBpcyBub3RcbiAgICAgICAgICAgIC8vIGEgY2FtZWwtY2FzZSBhdHRyaWJ1dGUgbmFtZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIGNvbnZlcnRcbiAgICAgICAgICAgIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBkYXNoLXNlcGFyYXRlZCB3b3Jkcy5cbiAgICAgICAgICAgIGlmICghVi5zdXBwb3J0Q2FtZWxDYXNlQXR0cmlidXRlcykgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBjYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbnZlcnQgY2FtZWwgY2FzZSB0byBkYXNoLXNlcGFyYXRlZCB3b3Jkcy5cbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVbbmFtZV0gPSBuYW1lLnJlcGxhY2UoL1tBLVpdL2csICctJCYnKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGljdGlvbmFyeSBvZiBhdHRyaWJ1dGUgbmFtZXNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoViwgJ2F0dHJpYnV0ZU5hbWVzJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogYXR0cmlidXRlTmFtZXMsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIFNob3VsZCBjYW1lbCBjYXNlIGF0dHJpYnV0ZXMgYmUgc3VwcG9ydGVkP1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWLCAnc3VwcG9ydENhbWVsQ2FzZUF0dHJpYnV0ZXMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge3tuczogc3RyaW5nfG51bGwsIGxvY2FsOiBzdHJpbmd9fSBuYW1lc3BhY2UgYW5kIGF0dHJpYnV0ZSBuYW1lXG4gICAgICovXG4gICAgVi5xdWFsaWZ5QXR0ciA9IGZ1bmN0aW9uKG5hbWUpIHtcblxuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgY29tYmluZWRLZXkgPSBuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5zOiBuc1tjb21iaW5lZEtleVswXV0sXG4gICAgICAgICAgICAgICAgbG9jYWw6IGNvbWJpbmVkS2V5WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5zOiBudWxsLFxuICAgICAgICAgICAgbG9jYWw6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gTm90ZTogVGhpcyByZWdleCBhbGxvd3MgbXVsdGlwbGUgY29tbWFzIGFzIHNlcGFyYXRvciB3aGljaCBpcyBpbmNvcnJlY3QgaW4gU1ZHXG4gICAgLy8gVGhpcyByZWdleCBpcyB1c2VkIGJ5IGBzcGxpdCgpYCwgc28gaXQgZG9lc24ndCBuZWVkIHRvIHVzZSAvZ1xuICAgIFYudHJhbnNmb3JtU2VwYXJhdG9yUmVnZXggPSAvWyAsXSsvO1xuICAgIC8vIE5vdGU6IEFsbCBmb2xsb3dpbmcgcmVnZXhlcyBhcmUgbW9yZSByZXN0cmljdGl2ZSB0aGFuIFNWRyBzcGVjaWZpY2F0aW9uXG4gICAgLy8gUmVEb1MgbWl0aWdhdGlvbjogVXNlIGFuIGFuY2hvciBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYXRjaFxuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IEF2b2lkIGJhY2t0cmFja2luZyAodXNlcyBgW14oKV0rYCBpbnN0ZWFkIG9mIGAuKj9gKVxuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IERvbid0IG1hdGNoIGluaXRpYWwgYChgIGluc2lkZSByZXBlYXRlZCBwYXJ0XG4gICAgLy8gVGhlIGZvbGxvd2luZyByZWdleCBuZWVkcyB0byB1c2UgL2cgKD0gY2Fubm90IHVzZSBjYXB0dXJpbmcgZ3JvdXBzKVxuICAgIFYudHJhbnNmb3JtUmVnZXggPSAvXFxiXFx3K1xcKFteKCldK1xcKS9nO1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgcmVnZXhlcyBuZWVkIHRvIHVzZSBjYXB0dXJpbmcgZ3JvdXBzICg9IGNhbm5vdCB1c2UgL2cpXG4gICAgVi50cmFuc2Zvcm1GdW5jdGlvblJlZ2V4ID0gL1xcYihcXHcrKVxcKChbXigpXSspXFwpLztcbiAgICBWLnRyYW5zZm9ybVRyYW5zbGF0ZVJlZ2V4ID0gL1xcYnRyYW5zbGF0ZVxcKChbXigpXSspXFwpLztcbiAgICBWLnRyYW5zZm9ybVJvdGF0ZVJlZ2V4ID0gL1xcYnJvdGF0ZVxcKChbXigpXSspXFwpLztcbiAgICBWLnRyYW5zZm9ybVNjYWxlUmVnZXggPSAvXFxic2NhbGVcXCgoW14oKV0rKVxcKS87XG5cbiAgICBWLnRyYW5zZm9ybVN0cmluZ1RvTWF0cml4ID0gZnVuY3Rpb24odHJhbnNmb3JtKSB7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSByZXN1bHQgbWF0cml4IGFzIGlkZW50aXR5IG1hdHJpeFxuICAgICAgICBsZXQgdHJhbnNmb3JtYXRpb25NYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuXG4gICAgICAgIC8vIE5vdGU6IE11bHRpcGxlIHRyYW5zZm9ybSBmdW5jdGlvbnMgYXJlIGFsbG93ZWQgaW4gYHRyYW5zZm9ybWAgc3RyaW5nXG4gICAgICAgIC8vIGBtYXRjaCgpYCByZXR1cm5zIGBudWxsYCBpZiBub25lIGZvdW5kXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdGNoZXMgPSB0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtLm1hdGNoKFYudHJhbnNmb3JtUmVnZXgpO1xuICAgICAgICBpZiAoIXRyYW5zZm9ybU1hdGNoZXMpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiBpZGVudGl0eSBtYXRyaXhcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1hdGlvbk1hdHJpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG51bU1hdGNoZXMgPSB0cmFuc2Zvcm1NYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NYXRjaGVzOyBpKyspIHtcblxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtTWF0Y2ggPSB0cmFuc2Zvcm1NYXRjaGVzW2ldO1xuICAgICAgICAgICAgLy8gVXNlIHNhbWUgcmVnZXggYXMgYWJvdmUsIGJ1dCB3aXRoIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgIC8vIGBtYXRjaCgpYCByZXR1cm5zIHZhbHVlcyBvZiBjYXB0dXJpbmcgZ3JvdXBzIGFzIGBbMV1gLCBgWzJdYFxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtRnVuY3Rpb25NYXRjaCA9IHRyYW5zZm9ybU1hdGNoLm1hdGNoKFYudHJhbnNmb3JtRnVuY3Rpb25SZWdleCk7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtRnVuY3Rpb25NYXRjaCkge1xuXG4gICAgICAgICAgICAgICAgbGV0IHN4LCBzeSwgdHgsIHR5LCBhbmdsZTtcbiAgICAgICAgICAgICAgICBsZXQgY3RtID0gVi5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1GdW5jdGlvbiA9IHRyYW5zZm9ybUZ1bmN0aW9uTWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gdHJhbnNmb3JtRnVuY3Rpb25NYXRjaFsyXS5zcGxpdChWLnRyYW5zZm9ybVNlcGFyYXRvclJlZ2V4KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zZm9ybUZ1bmN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2NhbGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3ggPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSAoYXJnc1sxXSA9PT0gdW5kZWZpbmVkKSA/IHN4IDogcGFyc2VGbG9hdChhcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5zY2FsZU5vblVuaWZvcm0oc3gsIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zbGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHBhcnNlRmxvYXQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9IHBhcnNlRmxvYXQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdG0gPSBjdG0udHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBwYXJzZUZsb2F0KGFyZ3NbMV0pIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eSA9IHBhcnNlRmxvYXQoYXJnc1syXSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eCAhPT0gMCB8fCB0eSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS50cmFuc2xhdGUodHgsIHR5KS5yb3RhdGUoYW5nbGUpLnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5yb3RhdGUoYW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2tld3gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtID0gY3RtLnNrZXdYKGFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NrZXd5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gcGFyc2VGbG9hdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bSA9IGN0bS5za2V3WShhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmEgPSBwYXJzZUZsb2F0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmIgPSBwYXJzZUZsb2F0KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmMgPSBwYXJzZUZsb2F0KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmQgPSBwYXJzZUZsb2F0KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmUgPSBwYXJzZUZsb2F0KGFyZ3NbNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RtLmYgPSBwYXJzZUZsb2F0KGFyZ3NbNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE11bHRpcGx5IGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gaW50byByZXN1bHQgbWF0cml4XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB0cmFuc2Zvcm1hdGlvbk1hdHJpeC5tdWx0aXBseShjdG0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uTWF0cml4O1xuICAgIH07XG5cbiAgICBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nID0gZnVuY3Rpb24obWF0cml4KSB7XG4gICAgICAgIG1hdHJpeCB8fCAobWF0cml4ID0gdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuICdtYXRyaXgoJyArXG4gICAgICAgICAgICAobWF0cml4LmEgIT09IHVuZGVmaW5lZCA/IG1hdHJpeC5hIDogMSkgKyAnLCcgK1xuICAgICAgICAgICAgKG1hdHJpeC5iICE9PSB1bmRlZmluZWQgPyBtYXRyaXguYiA6IDApICsgJywnICtcbiAgICAgICAgICAgIChtYXRyaXguYyAhPT0gdW5kZWZpbmVkID8gbWF0cml4LmMgOiAwKSArICcsJyArXG4gICAgICAgICAgICAobWF0cml4LmQgIT09IHVuZGVmaW5lZCA/IG1hdHJpeC5kIDogMSkgKyAnLCcgK1xuICAgICAgICAgICAgKG1hdHJpeC5lICE9PSB1bmRlZmluZWQgPyBtYXRyaXguZSA6IDApICsgJywnICtcbiAgICAgICAgICAgIChtYXRyaXguZiAhPT0gdW5kZWZpbmVkID8gbWF0cml4LmYgOiAwKSArXG4gICAgICAgICAgICAnKSc7XG4gICAgfTtcblxuICAgIFYucGFyc2VUcmFuc2Zvcm1TdHJpbmcgPSBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcblxuICAgICAgICB2YXIgdHJhbnNsYXRlLCByb3RhdGUsIHNjYWxlO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcblxuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFYudHJhbnNmb3JtU2VwYXJhdG9yUmVnZXg7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGB0cmFuc2Zvcm1gIHdpdGggb25lIG9yIG1vcmUgbWF0cml4IGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybS50cmltKCkuaW5kZXhPZignbWF0cml4JykgPj0gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBFVkVSWVRISU5HIGluIGB0cmFuc2Zvcm1gIHN0cmluZyB0byBhIG1hdHJpeFxuICAgICAgICAgICAgICAgIC8vIFdpbGwgY29tYmluZSBBTEwgbWF0cml4ZXMgKiBBTEwgdHJhbnNsYXRlcyAqIEFMTCBzY2FsZXMgKiBBTEwgcm90YXRlc1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IEluIG5vbi1tYXRyaXggY2FzZSwgd2Ugb25seSB0YWtlIGZpcnN0IG9uZSBvZiBlYWNoIChpZiBhbnkpXG4gICAgICAgICAgICAgICAgdmFyIG1hdHJpeCA9IFYudHJhbnNmb3JtU3RyaW5nVG9NYXRyaXgodHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVjb21wb3NlZE1hdHJpeCA9IFYuZGVjb21wb3NlTWF0cml4KG1hdHJpeCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGB0cmFuc2xhdGVgLCBgc2NhbGVgLCBgcm90YXRlYCBmcm9tIG1hdHJpeFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSA9IFtkZWNvbXBvc2VkTWF0cml4LnRyYW5zbGF0ZVgsIGRlY29tcG9zZWRNYXRyaXgudHJhbnNsYXRlWV07XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBbZGVjb21wb3NlZE1hdHJpeC5zY2FsZVgsIGRlY29tcG9zZWRNYXRyaXguc2NhbGVZXTtcbiAgICAgICAgICAgICAgICByb3RhdGUgPSBbZGVjb21wb3NlZE1hdHJpeC5yb3RhdGlvbl07XG5cbiAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIGB0cmFuc2Zvcm1gIHN0cmluZyBpbiBgdHJhbnNsYXRlIHNjYWxlIHJvdGF0ZWAgZm9ybWF0XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGVbMF0gIT09IDAgfHwgdHJhbnNsYXRlWzFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKCd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZSArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2FsZVswXSAhPT0gMSB8fCBzY2FsZVsxXSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaCgnc2NhbGUoJyArIHNjYWxlICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0ZVswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaCgncm90YXRlKCcgKyByb3RhdGUgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1hdGlvbnMuam9pbignICcpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBgdHJhbnNsYXRlYCwgYHJvdGF0ZWAsIGBzY2FsZWAgZnVuY3Rpb25zIGZyb20gYHRyYW5zZm9ybWAgc3RyaW5nXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2Ugb25seSBkZXRlY3QgdGhlIGZpcnN0IG1hdGNoIG9mIGVhY2ggKGlmIGFueSlcbiAgICAgICAgICAgICAgICAvLyBgbWF0Y2goKWAgcmV0dXJucyB2YWx1ZSBvZiBjYXB0dXJpbmcgZ3JvdXAgYXMgYFsxXWBcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVNYXRjaCA9IHRyYW5zZm9ybS5tYXRjaChWLnRyYW5zZm9ybVRyYW5zbGF0ZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlID0gdHJhbnNsYXRlTWF0Y2hbMV0uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm90YXRlTWF0Y2ggPSB0cmFuc2Zvcm0ubWF0Y2goVi50cmFuc2Zvcm1Sb3RhdGVSZWdleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZSA9IHJvdGF0ZU1hdGNoWzFdLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlTWF0Y2ggPSB0cmFuc2Zvcm0ubWF0Y2goVi50cmFuc2Zvcm1TY2FsZVJlZ2V4KTtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlTWF0Y2hbMV0uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3ggPSAoc2NhbGUgJiYgc2NhbGVbMF0pID8gcGFyc2VGbG9hdChzY2FsZVswXSkgOiAxO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdHJhbnNmb3JtLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiB7XG4gICAgICAgICAgICAgICAgdHg6ICh0cmFuc2xhdGUgJiYgdHJhbnNsYXRlWzBdKSA/IHBhcnNlSW50KHRyYW5zbGF0ZVswXSwgMTApIDogMCxcbiAgICAgICAgICAgICAgICB0eTogKHRyYW5zbGF0ZSAmJiB0cmFuc2xhdGVbMV0pID8gcGFyc2VJbnQodHJhbnNsYXRlWzFdLCAxMCkgOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm90YXRlOiB7XG4gICAgICAgICAgICAgICAgYW5nbGU6IChyb3RhdGUgJiYgcm90YXRlWzBdKSA/IHBhcnNlSW50KHJvdGF0ZVswXSwgMTApIDogMCxcbiAgICAgICAgICAgICAgICBjeDogKHJvdGF0ZSAmJiByb3RhdGVbMV0pID8gcGFyc2VJbnQocm90YXRlWzFdLCAxMCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY3k6IChyb3RhdGUgJiYgcm90YXRlWzJdKSA/IHBhcnNlSW50KHJvdGF0ZVsyXSwgMTApIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGU6IHtcbiAgICAgICAgICAgICAgICBzeDogc3gsXG4gICAgICAgICAgICAgICAgc3k6IChzY2FsZSAmJiBzY2FsZVsxXSkgPyBwYXJzZUZsb2F0KHNjYWxlWzFdKSA6IHN4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFYuZGVsdGFUcmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uKG1hdHJpeCwgcG9pbnQpIHtcblxuICAgICAgICB2YXIgZHggPSBwb2ludC54ICogbWF0cml4LmEgKyBwb2ludC55ICogbWF0cml4LmMgKyAwO1xuICAgICAgICB2YXIgZHkgPSBwb2ludC54ICogbWF0cml4LmIgKyBwb2ludC55ICogbWF0cml4LmQgKyAwO1xuICAgICAgICByZXR1cm4geyB4OiBkeCwgeTogZHkgfTtcbiAgICB9O1xuXG4gICAgVi5kZWNvbXBvc2VNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzIwNTIyNDdcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZGVsdGEgdHJhbnNmb3JtIHBvaW50XG4gICAgICAgIHZhciBweCA9IFYuZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHsgeDogMCwgeTogMSB9KTtcbiAgICAgICAgdmFyIHB5ID0gVi5kZWx0YVRyYW5zZm9ybVBvaW50KG1hdHJpeCwgeyB4OiAxLCB5OiAwIH0pO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBza2V3XG4gICAgICAgIHZhciBza2V3WCA9ICgoMTgwIC8gUEkpICogYXRhbjIocHgueSwgcHgueCkgLSA5MCk7XG4gICAgICAgIHZhciBza2V3WSA9ICgoMTgwIC8gUEkpICogYXRhbjIocHkueSwgcHkueCkpO1xuXG4gICAgICAgIHJldHVybiB7XG5cbiAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG1hdHJpeC5lLFxuICAgICAgICAgICAgdHJhbnNsYXRlWTogbWF0cml4LmYsXG4gICAgICAgICAgICBzY2FsZVg6IHNxcnQobWF0cml4LmEgKiBtYXRyaXguYSArIG1hdHJpeC5iICogbWF0cml4LmIpLFxuICAgICAgICAgICAgc2NhbGVZOiBzcXJ0KG1hdHJpeC5jICogbWF0cml4LmMgKyBtYXRyaXguZCAqIG1hdHJpeC5kKSxcbiAgICAgICAgICAgIHNrZXdYOiBza2V3WCxcbiAgICAgICAgICAgIHNrZXdZOiBza2V3WSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBza2V3WCAvLyByb3RhdGlvbiBpcyB0aGUgc2FtZSBhcyBza2V3IHhcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBgc2NhbGVgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcbiAgICAvLyBgdHJhbnNsYXRlKHR4LCB0eSkgLiByb3RhdGUoYW5nbGUpIC4gc2NhbGUoc3gsIHN5KSA9PT0gbWF0cml4KGEsYixjLGQsZSxmKWBcbiAgICBWLm1hdHJpeFRvU2NhbGUgPSBmdW5jdGlvbihtYXRyaXgpIHtcblxuICAgICAgICB2YXIgYSwgYiwgYywgZDtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgYSA9IFYuaXNVbmRlZmluZWQobWF0cml4LmEpID8gMSA6IG1hdHJpeC5hO1xuICAgICAgICAgICAgZCA9IFYuaXNVbmRlZmluZWQobWF0cml4LmQpID8gMSA6IG1hdHJpeC5kO1xuICAgICAgICAgICAgYiA9IG1hdHJpeC5iO1xuICAgICAgICAgICAgYyA9IG1hdHJpeC5jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYSA9IGQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzeDogYiA/IHNxcnQoYSAqIGEgKyBiICogYikgOiBhLFxuICAgICAgICAgICAgc3k6IGMgPyBzcXJ0KGMgKiBjICsgZCAqIGQpIDogZFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGByb3RhdGVgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcbiAgICAvLyBgdHJhbnNsYXRlKHR4LCB0eSkgLiByb3RhdGUoYW5nbGUpIC4gc2NhbGUoc3gsIHN5KSA9PT0gbWF0cml4KGEsYixjLGQsZSxmKWBcbiAgICBWLm1hdHJpeFRvUm90YXRlID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgdmFyIHAgPSB7IHg6IDAsIHk6IDEgfTtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgcCA9IFYuZGVsdGFUcmFuc2Zvcm1Qb2ludChtYXRyaXgsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuZ2xlOiBnLm5vcm1hbGl6ZUFuZ2xlKGcudG9EZWcoYXRhbjIocC55LCBwLngpKSAtIDkwKVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGB0cmFuc2xhdGVgIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBlcXVhdGlvbjpcbiAgICAvLyBgdHJhbnNsYXRlKHR4LCB0eSkgLiByb3RhdGUoYW5nbGUpIC4gc2NhbGUoc3gsIHN5KSA9PT0gbWF0cml4KGEsYixjLGQsZSxmKWBcbiAgICBWLm1hdHJpeFRvVHJhbnNsYXRlID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4OiAobWF0cml4ICYmIG1hdHJpeC5lKSB8fCAwLFxuICAgICAgICAgICAgdHk6IChtYXRyaXggJiYgbWF0cml4LmYpIHx8IDBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgVi5pc1YgPSBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgVjtcbiAgICB9O1xuXG4gICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuICAgIFYuaXNWRWxlbWVudCA9IFYuaXNWO1xuXG4gICAgLy8gRWxlbWVudCBpbXBsZW1lbnRzIGBnZXRCQm94KClgLCBgZ2V0Q1RNKClgIGFuZCBgZ2V0U2NyZWVuQ1RNKClgXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR0dyYXBoaWNzRWxlbWVudFxuICAgIFYuaXNTVkdHcmFwaGljc0VsZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBub2RlID0gVi50b05vZGUobm9kZSk7XG4gICAgICAgIC8vIElFL0VkZ2UgZG9lcyBub3QgaW1wbGVtZW50IFNWR0dyYXBoaWNzRWxlbWVudCBpbnRlcmZhY2UsIHRodXMgY2hlY2sgZm9yIGBnZXRTY3JlZW5DVE1gIGJlbG93XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiB0eXBlb2Ygbm9kZS5nZXRTY3JlZW5DVE0gPT09ICdmdW5jdGlvbic7XG4gICAgfTtcblxuICAgIHZhciBzdmdEb2N1bWVudCA9IFYoJ3N2ZycpLm5vZGU7XG5cbiAgICBWLmNyZWF0ZVNWR01hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXG4gICAgICAgIHZhciBzdmdNYXRyaXggPSBzdmdEb2N1bWVudC5jcmVhdGVTVkdNYXRyaXgoKTtcbiAgICAgICAgZm9yICh2YXIgY29tcG9uZW50IGluIG1hdHJpeCkge1xuICAgICAgICAgICAgc3ZnTWF0cml4W2NvbXBvbmVudF0gPSBtYXRyaXhbY29tcG9uZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdmdNYXRyaXg7XG4gICAgfTtcblxuICAgIFYuY3JlYXRlU1ZHVHJhbnNmb3JtID0gZnVuY3Rpb24obWF0cml4KSB7XG5cbiAgICAgICAgaWYgKCFWLmlzVW5kZWZpbmVkKG1hdHJpeCkpIHtcblxuICAgICAgICAgICAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgU1ZHTWF0cml4KSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KG1hdHJpeCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdmdEb2N1bWVudC5jcmVhdGVTVkdUcmFuc2Zvcm1Gcm9tTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3ZnRG9jdW1lbnQuY3JlYXRlU1ZHVHJhbnNmb3JtKCk7XG4gICAgfTtcblxuICAgIFYuY3JlYXRlU1ZHUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgICAgdmFyIHAgPSBzdmdEb2N1bWVudC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICBwLnggPSB4O1xuICAgICAgICBwLnkgPSB5O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgVi50cmFuc2Zvcm1SZWN0ID0gZnVuY3Rpb24ociwgbWF0cml4KSB7XG5cbiAgICAgICAgdmFyIHAgPSBzdmdEb2N1bWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXG4gICAgICAgIHAueCA9IHIueDtcbiAgICAgICAgcC55ID0gci55O1xuICAgICAgICB2YXIgY29ybmVyMSA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgcC54ID0gci54ICsgci53aWR0aDtcbiAgICAgICAgcC55ID0gci55O1xuICAgICAgICB2YXIgY29ybmVyMiA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgcC54ID0gci54ICsgci53aWR0aDtcbiAgICAgICAgcC55ID0gci55ICsgci5oZWlnaHQ7XG4gICAgICAgIHZhciBjb3JuZXIzID0gcC5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcblxuICAgICAgICBwLnggPSByLng7XG4gICAgICAgIHAueSA9IHIueSArIHIuaGVpZ2h0O1xuICAgICAgICB2YXIgY29ybmVyNCA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgICAgdmFyIG1pblggPSBtaW4oY29ybmVyMS54LCBjb3JuZXIyLngsIGNvcm5lcjMueCwgY29ybmVyNC54KTtcbiAgICAgICAgdmFyIG1heFggPSBtYXgoY29ybmVyMS54LCBjb3JuZXIyLngsIGNvcm5lcjMueCwgY29ybmVyNC54KTtcbiAgICAgICAgdmFyIG1pblkgPSBtaW4oY29ybmVyMS55LCBjb3JuZXIyLnksIGNvcm5lcjMueSwgY29ybmVyNC55KTtcbiAgICAgICAgdmFyIG1heFkgPSBtYXgoY29ybmVyMS55LCBjb3JuZXIyLnksIGNvcm5lcjMueSwgY29ybmVyNC55KTtcblxuICAgICAgICByZXR1cm4gbmV3IGcuUmVjdChtaW5YLCBtaW5ZLCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIH07XG5cbiAgICBWLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24ocCwgbWF0cml4KSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBnLlBvaW50KFYuY3JlYXRlU1ZHUG9pbnQocC54LCBwLnkpLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpKTtcbiAgICB9O1xuXG4gICAgVi50cmFuc2Zvcm1MaW5lID0gZnVuY3Rpb24obCwgbWF0cml4KSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBnLkxpbmUoXG4gICAgICAgICAgICBWLnRyYW5zZm9ybVBvaW50KGwuc3RhcnQsIG1hdHJpeCksXG4gICAgICAgICAgICBWLnRyYW5zZm9ybVBvaW50KGwuZW5kLCBtYXRyaXgpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIFYudHJhbnNmb3JtUG9seWxpbmUgPSBmdW5jdGlvbihwLCBtYXRyaXgpIHtcblxuICAgICAgICB2YXIgaW5Qb2ludHMgPSAocCBpbnN0YW5jZW9mIGcuUG9seWxpbmUpID8gcC5wb2ludHMgOiBwO1xuICAgICAgICBpZiAoIVYuaXNBcnJheShpblBvaW50cykpIGluUG9pbnRzID0gW107XG4gICAgICAgIHZhciBvdXRQb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBpblBvaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIG91dFBvaW50c1tpXSA9IFYudHJhbnNmb3JtUG9pbnQoaW5Qb2ludHNbaV0sIG1hdHJpeCk7XG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2x5bGluZShvdXRQb2ludHMpO1xuICAgIH07XG5cbiAgICAvLyBDb252ZXJ0IGEgc3R5bGUgcmVwcmVzZW50ZWQgYXMgc3RyaW5nIChlLmcuIGAnZmlsbD1cImJsdWVcIjsgc3Ryb2tlPVwicmVkXCInYCkgdG9cbiAgICAvLyBhbiBvYmplY3QgKGB7IGZpbGw6ICdibHVlJywgc3Ryb2tlOiAncmVkJyB9YCkuXG4gICAgVi5zdHlsZVRvT2JqZWN0ID0gZnVuY3Rpb24oc3R5bGVTdHJpbmcpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgICB2YXIgc3R5bGVzID0gc3R5bGVTdHJpbmcuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICAgICAgICAgIHZhciBwYWlyID0gc3R5bGUuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIHJldFtwYWlyWzBdLnRyaW0oKV0gPSBwYWlyWzFdLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvLyBJbnNwaXJlZCBieSBkMy5qcyBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvYmxvYi9tYXN0ZXIvc3JjL3N2Zy9hcmMuanNcbiAgICBWLmNyZWF0ZVNsaWNlUGF0aERhdGEgPSBmdW5jdGlvbihpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSB7XG5cbiAgICAgICAgdmFyIHN2Z0FyY01heCA9IDIgKiBQSSAtIDFlLTY7XG4gICAgICAgIHZhciByMCA9IGlubmVyUmFkaXVzO1xuICAgICAgICB2YXIgcjEgPSBvdXRlclJhZGl1cztcbiAgICAgICAgdmFyIGEwID0gc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIGExID0gZW5kQW5nbGU7XG4gICAgICAgIHZhciBkYSA9IChhMSA8IGEwICYmIChkYSA9IGEwLCBhMCA9IGExLCBhMSA9IGRhKSwgYTEgLSBhMCk7XG4gICAgICAgIHZhciBkZiA9IGRhIDwgUEkgPyAnMCcgOiAnMSc7XG4gICAgICAgIHZhciBjMCA9IGNvcyhhMCk7XG4gICAgICAgIHZhciBzMCA9IHNpbihhMCk7XG4gICAgICAgIHZhciBjMSA9IGNvcyhhMSk7XG4gICAgICAgIHZhciBzMSA9IHNpbihhMSk7XG5cbiAgICAgICAgcmV0dXJuIChkYSA+PSBzdmdBcmNNYXgpXG4gICAgICAgICAgICA/IChyMFxuICAgICAgICAgICAgICAgID8gJ00wLCcgKyByMVxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjEgKyAnLCcgKyByMSArICcgMCAxLDEgMCwnICsgKC1yMSlcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgMSwxIDAsJyArIHIxXG4gICAgICAgICAgICAgICAgKyAnTTAsJyArIHIwXG4gICAgICAgICAgICAgICAgKyAnQScgKyByMCArICcsJyArIHIwICsgJyAwIDEsMCAwLCcgKyAoLXIwKVxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjAgKyAnLCcgKyByMCArICcgMCAxLDAgMCwnICsgcjBcbiAgICAgICAgICAgICAgICArICdaJ1xuICAgICAgICAgICAgICAgIDogJ00wLCcgKyByMVxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjEgKyAnLCcgKyByMSArICcgMCAxLDEgMCwnICsgKC1yMSlcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgMSwxIDAsJyArIHIxXG4gICAgICAgICAgICAgICAgKyAnWicpXG4gICAgICAgICAgICA6IChyMFxuICAgICAgICAgICAgICAgID8gJ00nICsgcjEgKiBjMCArICcsJyArIHIxICogczBcbiAgICAgICAgICAgICAgICArICdBJyArIHIxICsgJywnICsgcjEgKyAnIDAgJyArIGRmICsgJywxICcgKyByMSAqIGMxICsgJywnICsgcjEgKiBzMVxuICAgICAgICAgICAgICAgICsgJ0wnICsgcjAgKiBjMSArICcsJyArIHIwICogczFcbiAgICAgICAgICAgICAgICArICdBJyArIHIwICsgJywnICsgcjAgKyAnIDAgJyArIGRmICsgJywwICcgKyByMCAqIGMwICsgJywnICsgcjAgKiBzMFxuICAgICAgICAgICAgICAgICsgJ1onXG4gICAgICAgICAgICAgICAgOiAnTScgKyByMSAqIGMwICsgJywnICsgcjEgKiBzMFxuICAgICAgICAgICAgICAgICsgJ0EnICsgcjEgKyAnLCcgKyByMSArICcgMCAnICsgZGYgKyAnLDEgJyArIHIxICogYzEgKyAnLCcgKyByMSAqIHMxXG4gICAgICAgICAgICAgICAgKyAnTDAsMCdcbiAgICAgICAgICAgICAgICArICdaJyk7XG4gICAgfTtcblxuICAgIC8vIE1lcmdlIGF0dHJpYnV0ZXMgZnJvbSBvYmplY3QgYGJgIHdpdGggYXR0cmlidXRlcyBpbiBvYmplY3QgYGFgLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVzIHRoZSBvYmplY3QgYGFgLlxuICAgIC8vIEFsc28gaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYnV0IENTUyBjbGFzc2VzIGFyZSBjb25jYXRlbmF0ZWQuXG4gICAgVi5tZXJnZUF0dHJzID0gZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICAgIGZvciAodmFyIGF0dHIgaW4gYikge1xuXG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIC8vIENvbmNhdGVuYXRlIGNsYXNzZXMuXG4gICAgICAgICAgICAgICAgYVthdHRyXSA9IGFbYXR0cl0gPyBhW2F0dHJdICsgJyAnICsgYlthdHRyXSA6IGJbYXR0cl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgICAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSBjYW4gYmUgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIGlmIChWLmlzT2JqZWN0KGFbYXR0cl0pICYmIFYuaXNPYmplY3QoYlthdHRyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0eWxlYCBzdG9yZWQgaW4gYGFgIGlzIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgYVthdHRyXSA9IFYubWVyZ2VBdHRycyhhW2F0dHJdLCBiW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFYuaXNPYmplY3QoYVthdHRyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHN0eWxlYCBpbiBgYWAgaXMgYW4gb2JqZWN0IGJ1dCBpdCdzIGEgc3RyaW5nIGluIGBiYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3R5bGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgdG8gYW4gb2JqZWN0IGluIGBiYC5cbiAgICAgICAgICAgICAgICAgICAgYVthdHRyXSA9IFYubWVyZ2VBdHRycyhhW2F0dHJdLCBWLnN0eWxlVG9PYmplY3QoYlthdHRyXSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVi5pc09iamVjdChiW2F0dHJdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgc3R5bGVgIGluIGBhYCBpcyBhIHN0cmluZywgaW4gYGJgIGl0J3MgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBhW2F0dHJdID0gVi5tZXJnZUF0dHJzKFYuc3R5bGVUb09iamVjdChhW2F0dHJdKSwgYlthdHRyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBzdHlsZXMgYXJlIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIGFbYXR0cl0gPSBWLm1lcmdlQXR0cnMoVi5zdHlsZVRvT2JqZWN0KGFbYXR0cl0pLCBWLnN0eWxlVG9PYmplY3QoYlthdHRyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYVthdHRyXSA9IGJbYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgVi5hbm5vdGF0ZVN0cmluZyA9IGZ1bmN0aW9uKHQsIGFubm90YXRpb25zLCBvcHQpIHtcblxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zIHx8IFtdO1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IG9wdC5vZmZzZXQgfHwgMDtcbiAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuICAgICAgICB2YXIgYmF0Y2g7XG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgdmFyIGl0ZW07XG4gICAgICAgIHZhciBwcmV2O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBpdGVtID0gcmV0W2ldID0gdFtpXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbm5vdGF0aW9ucy5sZW5ndGg7IGorKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb24gPSBhbm5vdGF0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBhbm5vdGF0aW9uLnN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBhbm5vdGF0aW9uLmVuZCArIG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlmIChpID49IHN0YXJ0ICYmIGkgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW5ub3RhdGlvbiBhcHBsaWVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoVi5pc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBhbm5vdGF0aW9uIHRvIGJlIGFwcGxpZWQgPT4gTWVyZ2UgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cnMgPSBWLm1lcmdlQXR0cnMoVi5tZXJnZUF0dHJzKHt9LCBpdGVtLmF0dHJzKSwgYW5ub3RhdGlvbi5hdHRycyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gcmV0W2ldID0geyB0OiB0W2ldLCBhdHRyczogYW5ub3RhdGlvbi5hdHRycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQuaW5jbHVkZUFubm90YXRpb25JbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoaXRlbS5hbm5vdGF0aW9ucyB8fCAoaXRlbS5hbm5vdGF0aW9ucyA9IFtdKSkucHVzaChqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldiA9IHJldFtpIC0gMV07XG5cbiAgICAgICAgICAgIGlmICghcHJldikge1xuXG4gICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFYuaXNPYmplY3QoaXRlbSkgJiYgVi5pc09iamVjdChwcmV2KSkge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggcHJldmlvdXMgaXRlbSBhbmQgdGhlIGN1cnJlbnQgb25lIGFyZSBhbm5vdGF0aW9ucy4gSWYgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyBkaWRuJ3QgY2hhbmdlLCBtZXJnZSB0aGUgdGV4dC5cbiAgICAgICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoaXRlbS5hdHRycykgPT09IEpTT04uc3RyaW5naWZ5KHByZXYuYXR0cnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLnQgKz0gaXRlbS50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChWLmlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmlvdXMgaXRlbSB3YXMgYSBzdHJpbmcsIGN1cnJlbnQgaXRlbSBpcyBhbiBhbm5vdGF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgICAgICBiYXRjaCA9IGl0ZW07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoVi5pc09iamVjdChwcmV2KSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZpb3VzIGl0ZW0gd2FzIGFuIGFubm90YXRpb24sIGN1cnJlbnQgaXRlbSBpcyBhIHN0cmluZy5cbiAgICAgICAgICAgICAgICBjb21wYWN0ZWQucHVzaChiYXRjaCk7XG4gICAgICAgICAgICAgICAgYmF0Y2ggPSBpdGVtO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggcHJldmlvdXMgYW5kIGN1cnJlbnQgaXRlbSBhcmUgc3RyaW5ncy5cbiAgICAgICAgICAgICAgICBiYXRjaCA9IChiYXRjaCB8fCAnJykgKyBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhdGNoKSB7XG4gICAgICAgICAgICBjb21wYWN0ZWQucHVzaChiYXRjaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGFjdGVkO1xuICAgIH07XG5cbiAgICBWLmZpbmRBbm5vdGF0aW9uc0F0SW5kZXggPSBmdW5jdGlvbihhbm5vdGF0aW9ucywgaW5kZXgpIHtcblxuICAgICAgICB2YXIgZm91bmQgPSBbXTtcblxuICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcblxuICAgICAgICAgICAgYW5ub3RhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhbm5vdGF0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5zdGFydCA8IGluZGV4ICYmIGluZGV4IDw9IGFubm90YXRpb24uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2goYW5ub3RhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfTtcblxuICAgIFYuZmluZEFubm90YXRpb25zQmV0d2VlbkluZGV4ZXMgPSBmdW5jdGlvbihhbm5vdGF0aW9ucywgc3RhcnQsIGVuZCkge1xuXG4gICAgICAgIHZhciBmb3VuZCA9IFtdO1xuXG4gICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuXG4gICAgICAgICAgICBhbm5vdGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGFubm90YXRpb24pIHtcblxuICAgICAgICAgICAgICAgIGlmICgoc3RhcnQgPj0gYW5ub3RhdGlvbi5zdGFydCAmJiBzdGFydCA8IGFubm90YXRpb24uZW5kKSB8fCAoZW5kID4gYW5ub3RhdGlvbi5zdGFydCAmJiBlbmQgPD0gYW5ub3RhdGlvbi5lbmQpIHx8IChhbm5vdGF0aW9uLnN0YXJ0ID49IHN0YXJ0ICYmIGFubm90YXRpb24uZW5kIDwgZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKGFubm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH07XG5cbiAgICAvLyBTaGlmdCBhbGwgdGhlIHRleHQgYW5ub3RhdGlvbnMgYWZ0ZXIgY2hhcmFjdGVyIGBpbmRleGAgYnkgYG9mZnNldGAgcG9zaXRpb25zLlxuICAgIFYuc2hpZnRBbm5vdGF0aW9ucyA9IGZ1bmN0aW9uKGFubm90YXRpb25zLCBpbmRleCwgb2Zmc2V0KSB7XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG5cbiAgICAgICAgICAgIGFubm90YXRpb25zLmZvckVhY2goZnVuY3Rpb24oYW5ub3RhdGlvbikge1xuXG4gICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb24uc3RhcnQgPCBpbmRleCAmJiBhbm5vdGF0aW9uLmVuZCA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmVuZCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhbm5vdGF0aW9uLnN0YXJ0ID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb24uc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uLmVuZCArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5ub3RhdGlvbnM7XG4gICAgfTtcblxuICAgIFYuY29udmVydExpbmVUb1BhdGhEYXRhID0gZnVuY3Rpb24obGluZSkge1xuXG4gICAgICAgIGxpbmUgPSBWKGxpbmUpO1xuICAgICAgICB2YXIgZCA9IFtcbiAgICAgICAgICAgICdNJywgbGluZS5hdHRyKCd4MScpLCBsaW5lLmF0dHIoJ3kxJyksXG4gICAgICAgICAgICAnTCcsIGxpbmUuYXR0cigneDInKSwgbGluZS5hdHRyKCd5MicpXG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgVi5jb252ZXJ0UG9seWdvblRvUGF0aERhdGEgPSBmdW5jdGlvbihwb2x5Z29uKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUocG9seWdvbik7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gVi5zdmdQb2ludHNUb1BhdGgocG9pbnRzKSArICcgWic7XG4gICAgfTtcblxuICAgIFYuY29udmVydFBvbHlsaW5lVG9QYXRoRGF0YSA9IGZ1bmN0aW9uKHBvbHlsaW5lKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFYuZ2V0UG9pbnRzRnJvbVN2Z05vZGUocG9seWxpbmUpO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIFYuc3ZnUG9pbnRzVG9QYXRoKHBvaW50cyk7XG4gICAgfTtcblxuICAgIFYuc3ZnUG9pbnRzVG9QYXRoID0gZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaV0ueCArICcgJyArIHBvaW50c1tpXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdNICcgKyBwb2ludHMuam9pbignIEwnKTtcbiAgICB9O1xuXG4gICAgVi5nZXRQb2ludHNGcm9tU3ZnTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICBub2RlID0gVi50b05vZGUobm9kZSk7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVQb2ludHMgPSBub2RlLnBvaW50cztcbiAgICAgICAgaWYgKG5vZGVQb2ludHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZVBvaW50cy5udW1iZXJPZkl0ZW1zOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gobm9kZVBvaW50cy5nZXRJdGVtKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfTtcblxuICAgIFYuS0FQUEEgPSAwLjU1MTc4NDtcblxuICAgIFYuY29udmVydENpcmNsZVRvUGF0aERhdGEgPSBmdW5jdGlvbihjaXJjbGUpIHtcblxuICAgICAgICBjaXJjbGUgPSBWKGNpcmNsZSk7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlRmxvYXQoY2lyY2xlLmF0dHIoJ2N4JykpIHx8IDA7XG4gICAgICAgIHZhciBjeSA9IHBhcnNlRmxvYXQoY2lyY2xlLmF0dHIoJ2N5JykpIHx8IDA7XG4gICAgICAgIHZhciByID0gcGFyc2VGbG9hdChjaXJjbGUuYXR0cigncicpKTtcbiAgICAgICAgdmFyIGNkID0gciAqIFYuS0FQUEE7IC8vIENvbnRyb2wgZGlzdGFuY2UuXG5cbiAgICAgICAgdmFyIGQgPSBbXG4gICAgICAgICAgICAnTScsIGN4LCBjeSAtIHIsICAgIC8vIE1vdmUgdG8gdGhlIGZpcnN0IHBvaW50LlxuICAgICAgICAgICAgJ0MnLCBjeCArIGNkLCBjeSAtIHIsIGN4ICsgciwgY3kgLSBjZCwgY3ggKyByLCBjeSwgLy8gSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4ICsgciwgY3kgKyBjZCwgY3ggKyBjZCwgY3kgKyByLCBjeCwgY3kgKyByLCAvLyBJSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4IC0gY2QsIGN5ICsgciwgY3ggLSByLCBjeSArIGNkLCBjeCAtIHIsIGN5LCAvLyBJSUkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCAtIHIsIGN5IC0gY2QsIGN4IC0gY2QsIGN5IC0gciwgY3gsIGN5IC0gciwgLy8gSVYuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ1onXG4gICAgICAgIF0uam9pbignICcpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgVi5jb252ZXJ0RWxsaXBzZVRvUGF0aERhdGEgPSBmdW5jdGlvbihlbGxpcHNlKSB7XG5cbiAgICAgICAgZWxsaXBzZSA9IFYoZWxsaXBzZSk7XG4gICAgICAgIHZhciBjeCA9IHBhcnNlRmxvYXQoZWxsaXBzZS5hdHRyKCdjeCcpKSB8fCAwO1xuICAgICAgICB2YXIgY3kgPSBwYXJzZUZsb2F0KGVsbGlwc2UuYXR0cignY3knKSkgfHwgMDtcbiAgICAgICAgdmFyIHJ4ID0gcGFyc2VGbG9hdChlbGxpcHNlLmF0dHIoJ3J4JykpO1xuICAgICAgICB2YXIgcnkgPSBwYXJzZUZsb2F0KGVsbGlwc2UuYXR0cigncnknKSkgfHwgcng7XG4gICAgICAgIHZhciBjZHggPSByeCAqIFYuS0FQUEE7IC8vIENvbnRyb2wgZGlzdGFuY2UgeC5cbiAgICAgICAgdmFyIGNkeSA9IHJ5ICogVi5LQVBQQTsgLy8gQ29udHJvbCBkaXN0YW5jZSB5LlxuXG4gICAgICAgIHZhciBkID0gW1xuICAgICAgICAgICAgJ00nLCBjeCwgY3kgLSByeSwgICAgLy8gTW92ZSB0byB0aGUgZmlyc3QgcG9pbnQuXG4gICAgICAgICAgICAnQycsIGN4ICsgY2R4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSAtIGNkeSwgY3ggKyByeCwgY3ksIC8vIEkuIFF1YWRyYW50LlxuICAgICAgICAgICAgJ0MnLCBjeCArIHJ4LCBjeSArIGNkeSwgY3ggKyBjZHgsIGN5ICsgcnksIGN4LCBjeSArIHJ5LCAvLyBJSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4IC0gY2R4LCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIGNkeSwgY3ggLSByeCwgY3ksIC8vIElJSS4gUXVhZHJhbnQuXG4gICAgICAgICAgICAnQycsIGN4IC0gcngsIGN5IC0gY2R5LCBjeCAtIGNkeCwgY3kgLSByeSwgY3gsIGN5IC0gcnksIC8vIElWLiBRdWFkcmFudC5cbiAgICAgICAgICAgICdaJ1xuICAgICAgICBdLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIFYuY29udmVydFJlY3RUb1BhdGhEYXRhID0gZnVuY3Rpb24ocmVjdCkge1xuXG4gICAgICAgIHJlY3QgPSBWKHJlY3QpO1xuXG4gICAgICAgIHJldHVybiBWLnJlY3RUb1BhdGgoe1xuICAgICAgICAgICAgeDogcGFyc2VGbG9hdChyZWN0LmF0dHIoJ3gnKSkgfHwgMCxcbiAgICAgICAgICAgIHk6IHBhcnNlRmxvYXQocmVjdC5hdHRyKCd5JykpIHx8IDAsXG4gICAgICAgICAgICB3aWR0aDogcGFyc2VGbG9hdChyZWN0LmF0dHIoJ3dpZHRoJykpIHx8IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQocmVjdC5hdHRyKCdoZWlnaHQnKSkgfHwgMCxcbiAgICAgICAgICAgIHJ4OiBwYXJzZUZsb2F0KHJlY3QuYXR0cigncngnKSkgfHwgMCxcbiAgICAgICAgICAgIHJ5OiBwYXJzZUZsb2F0KHJlY3QuYXR0cigncnknKSkgfHwgMFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gQ29udmVydCBhIHJlY3RhbmdsZSB0byBTVkcgcGF0aCBjb21tYW5kcy4gYHJgIGlzIGFuIG9iamVjdCBvZiB0aGUgZm9ybTpcbiAgICAvLyBgeyB4OiBbbnVtYmVyXSwgeTogW251bWJlcl0sIHdpZHRoOiBbbnVtYmVyXSwgaGVpZ2h0OiBbbnVtYmVyXSwgdG9wLXJ5OiBbbnVtYmVyXSwgdG9wLXJ5OiBbbnVtYmVyXSwgYm90dG9tLXJ4OiBbbnVtYmVyXSwgYm90dG9tLXJ5OiBbbnVtYmVyXSB9YCxcbiAgICAvLyB3aGVyZSBgeCwgeSwgd2lkdGgsIGhlaWdodGAgYXJlIHRoZSB1c3VhbCByZWN0YW5nbGUgYXR0cmlidXRlcyBhbmQgW3RvcC0vYm90dG9tLV1yeC9yeSBhbGxvd3MgZm9yXG4gICAgLy8gc3BlY2lmeWluZyByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSBmb3IgYWxsIGl0cyBzaWRlcyAoYXMgb3Bwb3NlZCB0byB0aGUgYnVpbHQtaW4gU1ZHIHJlY3RhbmdsZVxuICAgIC8vIHRoYXQgaGFzIG9ubHkgYHJ4YCBhbmQgYHJ5YCBhdHRyaWJ1dGVzKS5cbiAgICBWLnJlY3RUb1BhdGggPSBmdW5jdGlvbihyKSB7XG5cbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHZhciB4ID0gci54O1xuICAgICAgICB2YXIgeSA9IHIueTtcbiAgICAgICAgdmFyIHdpZHRoID0gci53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHIuaGVpZ2h0O1xuICAgICAgICB2YXIgdG9wUnggPSBtaW4oci5yeCB8fCByWyd0b3AtcngnXSB8fCAwLCB3aWR0aCAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tUnggPSBtaW4oci5yeCB8fCByWydib3R0b20tcngnXSB8fCAwLCB3aWR0aCAvIDIpO1xuICAgICAgICB2YXIgdG9wUnkgPSBtaW4oci5yeSB8fCByWyd0b3AtcnknXSB8fCAwLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgdmFyIGJvdHRvbVJ5ID0gbWluKHIucnkgfHwgclsnYm90dG9tLXJ5J10gfHwgMCwgaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgaWYgKHRvcFJ4IHx8IGJvdHRvbVJ4IHx8IHRvcFJ5IHx8IGJvdHRvbVJ5KSB7XG4gICAgICAgICAgICBkID0gW1xuICAgICAgICAgICAgICAgICdNJywgeCwgeSArIHRvcFJ5LFxuICAgICAgICAgICAgICAgICd2JywgaGVpZ2h0IC0gdG9wUnkgLSBib3R0b21SeSxcbiAgICAgICAgICAgICAgICAnYScsIGJvdHRvbVJ4LCBib3R0b21SeSwgMCwgMCwgMCwgYm90dG9tUngsIGJvdHRvbVJ5LFxuICAgICAgICAgICAgICAgICdoJywgd2lkdGggLSAyICogYm90dG9tUngsXG4gICAgICAgICAgICAgICAgJ2EnLCBib3R0b21SeCwgYm90dG9tUnksIDAsIDAsIDAsIGJvdHRvbVJ4LCAtYm90dG9tUnksXG4gICAgICAgICAgICAgICAgJ3YnLCAtKGhlaWdodCAtIGJvdHRvbVJ5IC0gdG9wUnkpLFxuICAgICAgICAgICAgICAgICdhJywgdG9wUngsIHRvcFJ5LCAwLCAwLCAwLCAtdG9wUngsIC10b3BSeSxcbiAgICAgICAgICAgICAgICAnaCcsIC0od2lkdGggLSAyICogdG9wUngpLFxuICAgICAgICAgICAgICAgICdhJywgdG9wUngsIHRvcFJ5LCAwLCAwLCAwLCAtdG9wUngsIHRvcFJ5LFxuICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBbXG4gICAgICAgICAgICAgICAgJ00nLCB4LCB5LFxuICAgICAgICAgICAgICAgICdIJywgeCArIHdpZHRoLFxuICAgICAgICAgICAgICAgICdWJywgeSArIGhlaWdodCxcbiAgICAgICAgICAgICAgICAnSCcsIHgsXG4gICAgICAgICAgICAgICAgJ1YnLCB5LFxuICAgICAgICAgICAgICAgICdaJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkLmpvaW4oJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gVGFrZSBhIHBhdGggZGF0YSBzdHJpbmdcbiAgICAvLyBSZXR1cm4gYSBub3JtYWxpemVkIHBhdGggZGF0YSBzdHJpbmdcbiAgICAvLyBJZiBkYXRhIGNhbm5vdCBiZSBwYXJzZWQsIHJldHVybiAnTSAwIDAnXG4gICAgLy8gSGlnaGx5IGluc3BpcmVkIGJ5IFJhcGhhZWwgTGlicmFyeSAod3d3LnJhcGhhZWwuY29tKVxuICAgIFYubm9ybWFsaXplUGF0aERhdGEgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNwYWNlcyA9ICdcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MjBcXHhhMFxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHUyMDI4XFx1MjAyOSc7XG4gICAgICAgIHZhciBwYXRoQ29tbWFuZCA9IG5ldyBSZWdFeHAoJyhbYS16XSlbJyArIHNwYWNlcyArICcsXSooKC0/XFxcXGQqXFxcXC4/XFxcXGQqKD86ZVtcXFxcLStdP1xcXFxkKyk/WycgKyBzcGFjZXMgKyAnXSosP1snICsgc3BhY2VzICsgJ10qKSspJywgJ2lnJyk7XG4gICAgICAgIHZhciBwYXRoVmFsdWVzID0gbmV3IFJlZ0V4cCgnKC0/XFxcXGQqXFxcXC4/XFxcXGQqKD86ZVtcXFxcLStdP1xcXFxkKyk/KVsnICsgc3BhY2VzICsgJ10qLD9bJyArIHNwYWNlcyArICddKicsICdpZycpO1xuXG4gICAgICAgIHZhciBtYXRoID0gTWF0aDtcbiAgICAgICAgdmFyIFBJID0gbWF0aC5QSTtcbiAgICAgICAgdmFyIHNpbiA9IG1hdGguc2luO1xuICAgICAgICB2YXIgY29zID0gbWF0aC5jb3M7XG4gICAgICAgIHZhciB0YW4gPSBtYXRoLnRhbjtcbiAgICAgICAgdmFyIGFzaW4gPSBtYXRoLmFzaW47XG4gICAgICAgIHZhciBzcXJ0ID0gbWF0aC5zcXJ0O1xuICAgICAgICB2YXIgYWJzID0gbWF0aC5hYnM7XG5cbiAgICAgICAgZnVuY3Rpb24gcTJjKHgxLCB5MSwgYXgsIGF5LCB4MiwgeTIpIHtcblxuICAgICAgICAgICAgdmFyIF8xMyA9IDEgLyAzO1xuICAgICAgICAgICAgdmFyIF8yMyA9IDIgLyAzO1xuICAgICAgICAgICAgcmV0dXJuIFsoXzEzICogeDEpICsgKF8yMyAqIGF4KSwgKF8xMyAqIHkxKSArIChfMjMgKiBheSksIChfMTMgKiB4MikgKyAoXzIzICogYXgpLCAoXzEzICogeTIpICsgKF8yMyAqIGF5KSwgeDIsIHkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCByYWQpIHtcblxuICAgICAgICAgICAgdmFyIFggPSAoeCAqIGNvcyhyYWQpKSAtICh5ICogc2luKHJhZCkpO1xuICAgICAgICAgICAgdmFyIFkgPSAoeCAqIHNpbihyYWQpKSArICh5ICogY29zKHJhZCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogWCwgeTogWSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYTJjKHgxLCB5MSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VfYXJjX2ZsYWcsIHN3ZWVwX2ZsYWcsIHgyLCB5MiwgcmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAvLyBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvZiB3aGVyZSB0aGlzIG1hdGggY2FtZSBmcm9tIHZpc2l0OlxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvaW1wbG5vdGUuaHRtbCNBcmNJbXBsZW1lbnRhdGlvbk5vdGVzXG4gICAgICAgICAgICB2YXIgXzEyMCA9IChQSSAqIDEyMCkgLyAxODA7XG4gICAgICAgICAgICB2YXIgcmFkID0gKFBJIC8gMTgwKSAqICgrYW5nbGUgfHwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICB2YXIgeHk7XG5cbiAgICAgICAgICAgIGlmICghcmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgeHkgPSByb3RhdGUoeDEsIHkxLCAtcmFkKTtcbiAgICAgICAgICAgICAgICB4MSA9IHh5Lng7XG4gICAgICAgICAgICAgICAgeTEgPSB4eS55O1xuXG4gICAgICAgICAgICAgICAgeHkgPSByb3RhdGUoeDIsIHkyLCAtcmFkKTtcbiAgICAgICAgICAgICAgICB4MiA9IHh5Lng7XG4gICAgICAgICAgICAgICAgeTIgPSB4eS55O1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSAoeDEgLSB4MikgLyAyO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gKHkxIC0geTIpIC8gMjtcbiAgICAgICAgICAgICAgICB2YXIgaCA9ICgoeCAqIHgpIC8gKHJ4ICogcngpKSArICgoeSAqIHkpIC8gKHJ5ICogcnkpKTtcblxuICAgICAgICAgICAgICAgIGlmIChoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBoID0gc3FydChoKTtcbiAgICAgICAgICAgICAgICAgICAgcnggPSBoICogcng7XG4gICAgICAgICAgICAgICAgICAgIHJ5ID0gaCAqIHJ5O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByeDIgPSByeCAqIHJ4O1xuICAgICAgICAgICAgICAgIHZhciByeTIgPSByeSAqIHJ5O1xuXG4gICAgICAgICAgICAgICAgdmFyIGsgPSAoKGxhcmdlX2FyY19mbGFnID09IHN3ZWVwX2ZsYWcpID8gLTEgOiAxKSAqIHNxcnQoYWJzKCgocngyICogcnkyKSAtIChyeDIgKiB5ICogeSkgLSAocnkyICogeCAqIHgpKSAvICgocngyICogeSAqIHkpICsgKHJ5MiAqIHggKiB4KSkpKTtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShrKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcmMgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5MiwgeDIsIHkyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY3ggPSAoKGsgKiByeCAqIHkpIC8gcnkpICsgKCh4MSArIHgyKSAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBjeSA9ICgoayAqIC1yeSAqIHgpIC8gcngpICsgKCh5MSArIHkyKSAvIDIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGYxID0gYXNpbigoKHkxIC0gY3kpIC8gcnkpLnRvRml4ZWQoOSkpO1xuICAgICAgICAgICAgICAgIHZhciBmMiA9IGFzaW4oKCh5MiAtIGN5KSAvIHJ5KS50b0ZpeGVkKDkpKTtcblxuICAgICAgICAgICAgICAgIGYxID0gKCh4MSA8IGN4KSA/IChQSSAtIGYxKSA6IGYxKTtcbiAgICAgICAgICAgICAgICBmMiA9ICgoeDIgPCBjeCkgPyAoUEkgLSBmMikgOiBmMik7XG5cbiAgICAgICAgICAgICAgICBpZiAoZjEgPCAwKSBmMSA9IChQSSAqIDIpICsgZjE7XG4gICAgICAgICAgICAgICAgaWYgKGYyIDwgMCkgZjIgPSAoUEkgKiAyKSArIGYyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN3ZWVwX2ZsYWcgJiYgKGYxID4gZjIpKSBmMSA9IGYxIC0gKFBJICogMik7XG4gICAgICAgICAgICAgICAgaWYgKCFzd2VlcF9mbGFnICYmIChmMiA+IGYxKSkgZjIgPSBmMiAtIChQSSAqIDIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGYxID0gcmVjdXJzaXZlWzBdO1xuICAgICAgICAgICAgICAgIGYyID0gcmVjdXJzaXZlWzFdO1xuICAgICAgICAgICAgICAgIGN4ID0gcmVjdXJzaXZlWzJdO1xuICAgICAgICAgICAgICAgIGN5ID0gcmVjdXJzaXZlWzNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGYgPSBmMiAtIGYxO1xuICAgICAgICAgICAgaWYgKGFicyhkZikgPiBfMTIwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYyb2xkID0gZjI7XG4gICAgICAgICAgICAgICAgdmFyIHgyb2xkID0geDI7XG4gICAgICAgICAgICAgICAgdmFyIHkyb2xkID0geTI7XG4gICAgICAgICAgICAgICAgZjIgPSBmMSArIChfMTIwICogKChzd2VlcF9mbGFnICYmIChmMiA+IGYxKSkgPyAxIDogLTEpKTtcbiAgICAgICAgICAgICAgICB4MiA9IGN4ICsgKHJ4ICogY29zKGYyKSk7XG4gICAgICAgICAgICAgICAgeTIgPSBjeSArIChyeSAqIHNpbihmMikpO1xuICAgICAgICAgICAgICAgIHJlcyA9IGEyYyh4MiwgeTIsIHJ4LCByeSwgYW5nbGUsIDAsIHN3ZWVwX2ZsYWcsIHgyb2xkLCB5Mm9sZCwgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRmID0gZjIgLSBmMTtcblxuICAgICAgICAgICAgdmFyIGMxID0gY29zKGYxKTtcbiAgICAgICAgICAgIHZhciBzMSA9IHNpbihmMSk7XG4gICAgICAgICAgICB2YXIgYzIgPSBjb3MoZjIpO1xuICAgICAgICAgICAgdmFyIHMyID0gc2luKGYyKTtcbiAgICAgICAgICAgIHZhciB0ID0gdGFuKGRmIC8gNCk7XG4gICAgICAgICAgICB2YXIgaHggPSAoNCAvIDMpICogKHJ4ICogdCk7XG4gICAgICAgICAgICB2YXIgaHkgPSAoNCAvIDMpICogKHJ5ICogdCk7XG4gICAgICAgICAgICB2YXIgbTEgPSBbeDEsIHkxXTtcbiAgICAgICAgICAgIHZhciBtMiA9IFt4MSArIChoeCAqIHMxKSwgeTEgLSAoaHkgKiBjMSldO1xuICAgICAgICAgICAgdmFyIG0zID0gW3gyICsgKGh4ICogczIpLCB5MiAtIChoeSAqIGMyKV07XG4gICAgICAgICAgICB2YXIgbTQgPSBbeDIsIHkyXTtcblxuICAgICAgICAgICAgbTJbMF0gPSAoMiAqIG0xWzBdKSAtIG0yWzBdO1xuICAgICAgICAgICAgbTJbMV0gPSAoMiAqIG0xWzFdKSAtIG0yWzFdO1xuXG4gICAgICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFttMiwgbTMsIG00XS5jb25jYXQocmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gW20yLCBtMywgbTRdLmNvbmNhdChyZXMpLmpvaW4oKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaWkgPSByZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBuZXdyZXNbaV0gPSAoaSAlIDIpID8gcm90YXRlKHJlc1tpIC0gMV0sIHJlc1tpXSwgcmFkKS55IDogcm90YXRlKHJlc1tpXSwgcmVzW2kgKyAxXSwgcmFkKS54O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3cmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcblxuICAgICAgICAgICAgaWYgKCFwYXRoU3RyaW5nKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgdmFyIHBhcmFtQ291bnRzID0geyBhOiA3LCBjOiA2LCBoOiAxLCBsOiAyLCBtOiAyLCBxOiA0LCBzOiA0LCB0OiAyLCB2OiAxLCB6OiAwIH07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgICAgICAgICBTdHJpbmcocGF0aFN0cmluZykucmVwbGFjZShwYXRoQ29tbWFuZCwgZnVuY3Rpb24oYSwgYiwgYykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGMucmVwbGFjZShwYXRoVmFsdWVzLCBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiKSBwYXJhbXMucHVzaCgrYik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKG5hbWUgPT09ICdtJykgJiYgKHBhcmFtcy5sZW5ndGggPiAyKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goW2JdLmNvbmNhdChwYXJhbXMuc3BsaWNlKDAsIDIpKSk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnbCc7XG4gICAgICAgICAgICAgICAgICAgIGIgPSAoKGIgPT09ICdtJykgPyAnbCcgOiAnTCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJhbXMubGVuZ3RoID49IHBhcmFtQ291bnRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChbYl0uY29uY2F0KHBhcmFtcy5zcGxpY2UoMCwgcGFyYW1Db3VudHNbbmFtZV0pKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyYW1Db3VudHNbbmFtZV0pIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhdGhUb0Fic29sdXRlKHBhdGhBcnJheSkge1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aEFycmF5KSB8fCAhQXJyYXkuaXNBcnJheShwYXRoQXJyYXkgJiYgcGF0aEFycmF5WzBdKSkgeyAvLyByb3VnaCBhc3N1bXB0aW9uXG4gICAgICAgICAgICAgICAgcGF0aEFycmF5ID0gcGFyc2VQYXRoU3RyaW5nKHBhdGhBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGludmFsaWQgc3RyaW5nLCByZXR1cm4gJ00gMCAwJ1xuICAgICAgICAgICAgaWYgKCFwYXRoQXJyYXkgfHwgIXBhdGhBcnJheS5sZW5ndGgpIHJldHVybiBbWydNJywgMCwgMF1dO1xuXG4gICAgICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgICAgICB2YXIgbXggPSAwO1xuICAgICAgICAgICAgdmFyIG15ID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICAgICAgICB2YXIgcGEwO1xuXG4gICAgICAgICAgICB2YXIgaWkgPSBwYXRoQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgaWk7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChyKTtcblxuICAgICAgICAgICAgICAgIHZhciBwYSA9IHBhdGhBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBwYTAgPSBwYVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChwYTAgIT0gcGEwLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgclswXSA9IHBhMC50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBqajtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9IHBhWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMl0gPSBwYVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzNdID0gcGFbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcls0XSA9IHBhWzRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbNV0gPSBwYVs1XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzZdID0gK3BhWzZdICsgeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByWzddID0gK3BhWzddICsgeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclsxXSA9ICtwYVsxXSArIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJbMV0gPSArcGFbMV0gKyB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteCA9ICtwYVsxXSArIHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSArcGFbMl0gKyB5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgamogPSBwYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMTsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcltqXSA9ICtwYVtqXSArICgoaiAlIDIpID8geCA6IHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqaiA9IHBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgamo7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByW2pdID0gK3BhW2pdICsgKChqICUgMikgPyB4IDogeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtrID0gcGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGtrOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJba10gPSBwYVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSArbXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gK215O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG14ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXkgPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcltyLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XG5cbiAgICAgICAgICAgIHZhciBwID0gcGF0aFRvQWJzb2x1dGUocGF0aCk7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7IHg6IDAsIHk6IDAsIGJ4OiAwLCBieTogMCwgWDogMCwgWTogMCwgcXg6IG51bGwsIHF5OiBudWxsIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NQYXRoKHBhdGgsIGQsIHBjb20pIHtcblxuICAgICAgICAgICAgICAgIHZhciBueCwgbnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBbJ0MnLCBkLngsIGQueSwgZC54LCBkLnksIGQueCwgZC55XTtcblxuICAgICAgICAgICAgICAgIGlmICghKHBhdGhbMF0gaW4geyBUOiAxLCBROiAxIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGQucXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkLnF5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLlggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5ZID0gcGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQocGF0aFsxXSkgPT09IDAgfHwgcGFyc2VGbG9hdChwYXRoWzJdKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNBcmNPdXRPZlJhbmdlUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiSWYgZWl0aGVyIHJ4IG9yIHJ5IGlzIDAsIHRoZW4gdGhpcyBhcmMgaXMgdHJlYXRlZCBhcyBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZSBzZWdtZW50IChhIFwibGluZXRvXCIpIGpvaW5pbmcgdGhlIGVuZHBvaW50cy5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbJ0wnLCBwYXRoWzZdLCBwYXRoWzddXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChhMmMuYXBwbHkoMCwgW2QueCwgZC55XS5jb25jYXQocGF0aC5zbGljZSgxKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBjb20gPT09ICdDJyB8fCBwY29tID09PSAnUycpIHsgLy8gSW4gJ1MnIGNhc2Ugd2UgaGF2ZSB0byB0YWtlIGludG8gYWNjb3VudCwgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgaXMgQy9TLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG54ID0gKGQueCAqIDIpIC0gZC5ieDsgICAgICAgICAgLy8gQW5kIHJlZmxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSAoZC55ICogMikgLSBkLmJ5OyAgICAgICAgICAvLyBjb21tYW5kJ3MgY29udHJvbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHNvbWUgZWxzZSBvciBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnggPSBkLng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnkgPSBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydDJywgbngsIG55XS5jb25jYXQocGF0aC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwY29tID09PSAnUScgfHwgcGNvbSA9PT0gJ1QnKSB7IC8vIEluICdUJyBjYXNlIHdlIGhhdmUgdG8gdGFrZSBpbnRvIGFjY291bnQsIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIGlzIFEvVC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gKGQueCAqIDIpIC0gZC5xeDsgICAgICAgIC8vIEFuZCBtYWtlIGEgcmVmbGVjdGlvbiBzaW1pbGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5xeSA9IChkLnkgKiAyKSAtIGQucXk7ICAgICAgICAvLyB0byBjYXNlICdTJy5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yIHNvbWV0aGluZyBlbHNlIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gZC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydDJ10uY29uY2F0KHEyYyhkLngsIGQueSwgZC5xeCwgZC5xeSwgcGF0aFsxXSwgcGF0aFsyXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnF4ID0gcGF0aFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucXkgPSBwYXRoWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnQyddLmNvbmNhdChxMmMoZC54LCBkLnksIHBhdGhbMV0sIHBhdGhbMl0sIHBhdGhbM10sIHBhdGhbNF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFsnTCddLmNvbmNhdChwYXRoWzFdLCBkLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gWydMJ10uY29uY2F0KGQueCwgcGF0aFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpeEFyYyhwcCwgaSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBwW2ldLmxlbmd0aCA+IDcpIHtcblxuICAgICAgICAgICAgICAgICAgICBwcFtpXS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGkgPSBwcFtpXTtcblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwY29tc1tpXSA9ICdBJzsgLy8gaWYgY3JlYXRlZCBtdWx0aXBsZSAnQydzLCB0aGVpciBvcmlnaW5hbCBzZWcgaXMgc2F2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBwLnNwbGljZShpKyssIDAsIFsnQyddLmNvbmNhdChwaS5zcGxpY2UoMCwgNikpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWkgPSBwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwY29tcyA9IFtdOyAvLyBwYXRoIGNvbW1hbmRzIG9mIG9yaWdpbmFsIHBhdGggcFxuICAgICAgICAgICAgdmFyIHBmaXJzdCA9ICcnOyAvLyB0ZW1wb3JhcnkgaG9sZGVyIGZvciBvcmlnaW5hbCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgIHZhciBwY29tID0gJyc7IC8vIGhvbGRlciBmb3IgcHJldmlvdXMgcGF0aCBjb21tYW5kIG9mIG9yaWdpbmFsIHBhdGhcblxuICAgICAgICAgICAgdmFyIGlpID0gcC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocFtpXSkgcGZpcnN0ID0gcFtpXVswXTsgLy8gc2F2ZSBjdXJyZW50IHBhdGggY29tbWFuZFxuXG4gICAgICAgICAgICAgICAgaWYgKHBmaXJzdCAhPT0gJ0MnKSB7IC8vIEMgaXMgbm90IHNhdmVkIHlldCwgYmVjYXVzZSBpdCBtYXkgYmUgcmVzdWx0IG9mIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICAgICAgcGNvbXNbaV0gPSBwZmlyc3Q7IC8vIFNhdmUgY3VycmVudCBwYXRoIGNvbW1hbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSBwY29tID0gcGNvbXNbaSAtIDFdOyAvLyBHZXQgcHJldmlvdXMgcGF0aCBjb21tYW5kIHBjb21cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwW2ldID0gcHJvY2Vzc1BhdGgocFtpXSwgYXR0cnMsIHBjb20pOyAvLyBQcmV2aW91cyBwYXRoIGNvbW1hbmQgaXMgaW5wdXR0ZWQgdG8gcHJvY2Vzc1BhdGhcblxuICAgICAgICAgICAgICAgIGlmIChwY29tc1tpXSAhPT0gJ0EnICYmIHBmaXJzdCA9PT0gJ0MnKSBwY29tc1tpXSA9ICdDJzsgLy8gJ0EnIGlzIHRoZSBvbmx5IGNvbW1hbmRcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBtYXkgcHJvZHVjZSBtdWx0aXBsZSAnQydzXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCAnQycgaXMgYWxzbyAnQycgaW4gb3JpZ2luYWwgcGF0aFxuXG4gICAgICAgICAgICAgICAgZml4QXJjKHAsIGkpOyAvLyBmaXhBcmMgYWRkcyBhbHNvIHRoZSByaWdodCBhbW91bnQgb2YgJ0EncyB0byBwY29tc1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHBbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNlZ2xlbiA9IHNlZy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBhdHRycy54ID0gc2VnW3NlZ2xlbiAtIDJdO1xuICAgICAgICAgICAgICAgIGF0dHJzLnkgPSBzZWdbc2VnbGVuIC0gMV07XG5cbiAgICAgICAgICAgICAgICBhdHRycy5ieCA9IHBhcnNlRmxvYXQoc2VnW3NlZ2xlbiAtIDRdKSB8fCBhdHRycy54O1xuICAgICAgICAgICAgICAgIGF0dHJzLmJ5ID0gcGFyc2VGbG9hdChzZWdbc2VnbGVuIC0gM10pIHx8IGF0dHJzLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBub3JtYWxpemVkIHBhdGggZGF0YSBzdHJpbmcgc3RhcnRzIHdpdGggYW4gTSBzZWdtZW50XG4gICAgICAgICAgICBpZiAoIXBbMF1bMF0gfHwgcFswXVswXSAhPT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgcC51bnNoaWZ0KFsnTScsIDAsIDBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemUocGF0aERhdGEpLmpvaW4oJywnKS5zcGxpdCgnLCcpLmpvaW4oJyAnKTtcbiAgICAgICAgfTtcbiAgICB9KSgpO1xuXG4gICAgVi5uYW1lc3BhY2UgPSBucztcblxuICAgIFYuZyA9IGc7XG5cbiAgICByZXR1cm4gVjtcblxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgVjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/anchors/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/anchors/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: function() { return /* binding */ bottom; },\n/* harmony export */   bottomLeft: function() { return /* binding */ bottomLeft; },\n/* harmony export */   bottomRight: function() { return /* binding */ bottomRight; },\n/* harmony export */   center: function() { return /* binding */ center; },\n/* harmony export */   left: function() { return /* binding */ left; },\n/* harmony export */   midSide: function() { return /* binding */ midSide; },\n/* harmony export */   modelCenter: function() { return /* binding */ modelCenter; },\n/* harmony export */   perpendicular: function() { return /* binding */ perpendicular; },\n/* harmony export */   right: function() { return /* binding */ right; },\n/* harmony export */   top: function() { return /* binding */ top; },\n/* harmony export */   topLeft: function() { return /* binding */ topLeft; },\n/* harmony export */   topRight: function() { return /* binding */ topRight; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../linkAnchors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n\n\n\n\nfunction bboxWrapper(method) {\n\n    return function(view, magnet, ref, opt) {\n\n        var rotate = !!opt.rotate;\n        var bbox = (rotate) ? view.getNodeUnrotatedBBox(magnet) : view.getNodeBBox(magnet);\n        var anchor = bbox[method]();\n\n        var dx = opt.dx;\n        if (dx) {\n            var dxPercentage = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage(dx);\n            dx = parseFloat(dx);\n            if (isFinite(dx)) {\n                if (dxPercentage) {\n                    dx /= 100;\n                    dx *= bbox.width;\n                }\n                anchor.x += dx;\n            }\n        }\n\n        var dy = opt.dy;\n        if (dy) {\n            var dyPercentage = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage(dy);\n            dy = parseFloat(dy);\n            if (isFinite(dy)) {\n                if (dyPercentage) {\n                    dy /= 100;\n                    dy *= bbox.height;\n                }\n                anchor.y += dy;\n            }\n        }\n\n        return (rotate) ? anchor.rotate(view.model.getBBox().center(), -view.model.angle()) : anchor;\n    };\n}\n\nfunction _perpendicular(view, magnet, refPoint, opt) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeBBox(magnet);\n    var anchor = bbox.center();\n    var topLeft = bbox.origin();\n    var bottomRight = bbox.corner();\n\n    var padding = opt.padding;\n    if (!isFinite(padding)) padding = 0;\n\n    if ((topLeft.y + padding) <= refPoint.y && refPoint.y <= (bottomRight.y - padding)) {\n        var dy = (refPoint.y - anchor.y);\n        anchor.x += (angle === 0 || angle === 180) ? 0 : dy * 1 / Math.tan((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toRad)(angle));\n        anchor.y += dy;\n    } else if ((topLeft.x + padding) <= refPoint.x && refPoint.x <= (bottomRight.x - padding)) {\n        var dx = (refPoint.x - anchor.x);\n        anchor.y += (angle === 90 || angle === 270) ? 0 : dx * Math.tan((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toRad)(angle));\n        anchor.x += dx;\n    }\n\n    return anchor;\n}\n\nfunction _midSide(view, magnet, refPoint, opt) {\n\n    var rotate = !!opt.rotate;\n    var bbox, angle, center;\n    if (rotate) {\n        bbox = view.getNodeUnrotatedBBox(magnet);\n        center = view.model.getBBox().center();\n        angle = view.model.angle();\n    } else {\n        bbox = view.getNodeBBox(magnet);\n    }\n\n    var padding = opt.padding;\n    if (isFinite(padding)) bbox.inflate(padding);\n\n    if (rotate) refPoint.rotate(center, angle);\n\n    var side = bbox.sideNearestToPoint(refPoint);\n    var anchor;\n    switch (side) {\n        case 'left':\n            anchor = bbox.leftMiddle();\n            break;\n        case 'right':\n            anchor = bbox.rightMiddle();\n            break;\n        case 'top':\n            anchor = bbox.topMiddle();\n            break;\n        case 'bottom':\n            anchor = bbox.bottomMiddle();\n            break;\n    }\n\n    return (rotate) ? anchor.rotate(center, -angle) : anchor;\n}\n\n// Can find anchor from model, when there is no selector or the link end\n// is connected to a port\nfunction _modelCenter(view, _magnet, _refPoint, opt, endType) {\n    return view.model.getPointFromConnectedLink(this.model, endType).offset(opt.dx, opt.dy);\n}\n\n//joint.anchors\nconst center = bboxWrapper('center');\nconst top = bboxWrapper('topMiddle');\nconst bottom = bboxWrapper('bottomMiddle');\nconst left = bboxWrapper('leftMiddle');\nconst right = bboxWrapper('rightMiddle');\nconst topLeft = bboxWrapper('origin');\nconst topRight = bboxWrapper('topRight');\nconst bottomLeft = bboxWrapper('bottomLeft');\nconst bottomRight = bboxWrapper('corner');\nconst perpendicular = (0,_linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveRef)(_perpendicular);\nconst midSide = (0,_linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_2__.resolveRef)(_midSide);\nconst modelCenter = _modelCenter;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvYW5jaG9ycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ0g7QUFDZTs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IseURBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLG1EQUFLO0FBQ2hGO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0VBQXdFLG1EQUFLO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrRUFBVTtBQUNoQyxnQkFBZ0Isa0VBQVU7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9hbmNob3JzL2luZGV4Lm1qcz8xMDkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgdG9SYWQgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlUmVmIH0gZnJvbSAnLi4vbGlua0FuY2hvcnMvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gYmJveFdyYXBwZXIobWV0aG9kKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24odmlldywgbWFnbmV0LCByZWYsIG9wdCkge1xuXG4gICAgICAgIHZhciByb3RhdGUgPSAhIW9wdC5yb3RhdGU7XG4gICAgICAgIHZhciBiYm94ID0gKHJvdGF0ZSkgPyB2aWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KG1hZ25ldCkgOiB2aWV3LmdldE5vZGVCQm94KG1hZ25ldCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBiYm94W21ldGhvZF0oKTtcblxuICAgICAgICB2YXIgZHggPSBvcHQuZHg7XG4gICAgICAgIGlmIChkeCkge1xuICAgICAgICAgICAgdmFyIGR4UGVyY2VudGFnZSA9IHV0aWwuaXNQZXJjZW50YWdlKGR4KTtcbiAgICAgICAgICAgIGR4ID0gcGFyc2VGbG9hdChkeCk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZHgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGR4UGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBkeCAvPSAxMDA7XG4gICAgICAgICAgICAgICAgICAgIGR4ICo9IGJib3gud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2hvci54ICs9IGR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR5ID0gb3B0LmR5O1xuICAgICAgICBpZiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkeVBlcmNlbnRhZ2UgPSB1dGlsLmlzUGVyY2VudGFnZShkeSk7XG4gICAgICAgICAgICBkeSA9IHBhcnNlRmxvYXQoZHkpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGR5KSkge1xuICAgICAgICAgICAgICAgIGlmIChkeVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZHkgLz0gMTAwO1xuICAgICAgICAgICAgICAgICAgICBkeSAqPSBiYm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW5jaG9yLnkgKz0gZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHJvdGF0ZSkgPyBhbmNob3Iucm90YXRlKHZpZXcubW9kZWwuZ2V0QkJveCgpLmNlbnRlcigpLCAtdmlldy5tb2RlbC5hbmdsZSgpKSA6IGFuY2hvcjtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBfcGVycGVuZGljdWxhcih2aWV3LCBtYWduZXQsIHJlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciBhbmdsZSA9IHZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICB2YXIgYmJveCA9IHZpZXcuZ2V0Tm9kZUJCb3gobWFnbmV0KTtcbiAgICB2YXIgYW5jaG9yID0gYmJveC5jZW50ZXIoKTtcbiAgICB2YXIgdG9wTGVmdCA9IGJib3gub3JpZ2luKCk7XG4gICAgdmFyIGJvdHRvbVJpZ2h0ID0gYmJveC5jb3JuZXIoKTtcblxuICAgIHZhciBwYWRkaW5nID0gb3B0LnBhZGRpbmc7XG4gICAgaWYgKCFpc0Zpbml0ZShwYWRkaW5nKSkgcGFkZGluZyA9IDA7XG5cbiAgICBpZiAoKHRvcExlZnQueSArIHBhZGRpbmcpIDw9IHJlZlBvaW50LnkgJiYgcmVmUG9pbnQueSA8PSAoYm90dG9tUmlnaHQueSAtIHBhZGRpbmcpKSB7XG4gICAgICAgIHZhciBkeSA9IChyZWZQb2ludC55IC0gYW5jaG9yLnkpO1xuICAgICAgICBhbmNob3IueCArPSAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkgPyAwIDogZHkgKiAxIC8gTWF0aC50YW4odG9SYWQoYW5nbGUpKTtcbiAgICAgICAgYW5jaG9yLnkgKz0gZHk7XG4gICAgfSBlbHNlIGlmICgodG9wTGVmdC54ICsgcGFkZGluZykgPD0gcmVmUG9pbnQueCAmJiByZWZQb2ludC54IDw9IChib3R0b21SaWdodC54IC0gcGFkZGluZykpIHtcbiAgICAgICAgdmFyIGR4ID0gKHJlZlBvaW50LnggLSBhbmNob3IueCk7XG4gICAgICAgIGFuY2hvci55ICs9IChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkgPyAwIDogZHggKiBNYXRoLnRhbih0b1JhZChhbmdsZSkpO1xuICAgICAgICBhbmNob3IueCArPSBkeDtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jaG9yO1xufVxuXG5mdW5jdGlvbiBfbWlkU2lkZSh2aWV3LCBtYWduZXQsIHJlZlBvaW50LCBvcHQpIHtcblxuICAgIHZhciByb3RhdGUgPSAhIW9wdC5yb3RhdGU7XG4gICAgdmFyIGJib3gsIGFuZ2xlLCBjZW50ZXI7XG4gICAgaWYgKHJvdGF0ZSkge1xuICAgICAgICBiYm94ID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgICAgICBjZW50ZXIgPSB2aWV3Lm1vZGVsLmdldEJCb3goKS5jZW50ZXIoKTtcbiAgICAgICAgYW5nbGUgPSB2aWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmJveCA9IHZpZXcuZ2V0Tm9kZUJCb3gobWFnbmV0KTtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IG9wdC5wYWRkaW5nO1xuICAgIGlmIChpc0Zpbml0ZShwYWRkaW5nKSkgYmJveC5pbmZsYXRlKHBhZGRpbmcpO1xuXG4gICAgaWYgKHJvdGF0ZSkgcmVmUG9pbnQucm90YXRlKGNlbnRlciwgYW5nbGUpO1xuXG4gICAgdmFyIHNpZGUgPSBiYm94LnNpZGVOZWFyZXN0VG9Qb2ludChyZWZQb2ludCk7XG4gICAgdmFyIGFuY2hvcjtcbiAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBhbmNob3IgPSBiYm94LmxlZnRNaWRkbGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBhbmNob3IgPSBiYm94LnJpZ2h0TWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGFuY2hvciA9IGJib3gudG9wTWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGFuY2hvciA9IGJib3guYm90dG9tTWlkZGxlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gKHJvdGF0ZSkgPyBhbmNob3Iucm90YXRlKGNlbnRlciwgLWFuZ2xlKSA6IGFuY2hvcjtcbn1cblxuLy8gQ2FuIGZpbmQgYW5jaG9yIGZyb20gbW9kZWwsIHdoZW4gdGhlcmUgaXMgbm8gc2VsZWN0b3Igb3IgdGhlIGxpbmsgZW5kXG4vLyBpcyBjb25uZWN0ZWQgdG8gYSBwb3J0XG5mdW5jdGlvbiBfbW9kZWxDZW50ZXIodmlldywgX21hZ25ldCwgX3JlZlBvaW50LCBvcHQsIGVuZFR5cGUpIHtcbiAgICByZXR1cm4gdmlldy5tb2RlbC5nZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rKHRoaXMubW9kZWwsIGVuZFR5cGUpLm9mZnNldChvcHQuZHgsIG9wdC5keSk7XG59XG5cbi8vam9pbnQuYW5jaG9yc1xuZXhwb3J0IGNvbnN0IGNlbnRlciA9IGJib3hXcmFwcGVyKCdjZW50ZXInKTtcbmV4cG9ydCBjb25zdCB0b3AgPSBiYm94V3JhcHBlcigndG9wTWlkZGxlJyk7XG5leHBvcnQgY29uc3QgYm90dG9tID0gYmJveFdyYXBwZXIoJ2JvdHRvbU1pZGRsZScpO1xuZXhwb3J0IGNvbnN0IGxlZnQgPSBiYm94V3JhcHBlcignbGVmdE1pZGRsZScpO1xuZXhwb3J0IGNvbnN0IHJpZ2h0ID0gYmJveFdyYXBwZXIoJ3JpZ2h0TWlkZGxlJyk7XG5leHBvcnQgY29uc3QgdG9wTGVmdCA9IGJib3hXcmFwcGVyKCdvcmlnaW4nKTtcbmV4cG9ydCBjb25zdCB0b3BSaWdodCA9IGJib3hXcmFwcGVyKCd0b3BSaWdodCcpO1xuZXhwb3J0IGNvbnN0IGJvdHRvbUxlZnQgPSBiYm94V3JhcHBlcignYm90dG9tTGVmdCcpO1xuZXhwb3J0IGNvbnN0IGJvdHRvbVJpZ2h0ID0gYmJveFdyYXBwZXIoJ2Nvcm5lcicpO1xuZXhwb3J0IGNvbnN0IHBlcnBlbmRpY3VsYXIgPSByZXNvbHZlUmVmKF9wZXJwZW5kaWN1bGFyKTtcbmV4cG9ydCBjb25zdCBtaWRTaWRlID0gcmVzb2x2ZVJlZihfbWlkU2lkZSk7XG5leHBvcnQgY29uc3QgbW9kZWxDZW50ZXIgPSBfbW9kZWxDZW50ZXI7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/anchors/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Boundary.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Boundary.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Boundary: function() { return /* binding */ Boundary; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\nconst Boundary = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    name: 'boundary',\n    tagName: 'rect',\n    options: {\n        padding: 10,\n        useModelGeometry: false,\n    },\n    attributes: {\n        'fill': 'none',\n        'stroke': '#33334F',\n        'stroke-width': .5,\n        'stroke-dasharray': '5, 5',\n        'pointer-events': 'none'\n    },\n    onRender: function() {\n        this.update();\n    },\n    update: function() {\n        const { relatedView: view, options, vel } = this;\n        const { useModelGeometry, rotate } = options;\n        const padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeSides(options.padding);\n        let bbox = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getViewBBox)(view, useModelGeometry).moveAndExpand({\n            x: -padding.left,\n            y: -padding.top,\n            width: padding.left + padding.right,\n            height: padding.top + padding.bottom\n        });\n        var model = view.model;\n        if (model.isElement()) {\n            var angle = model.angle();\n            if (angle) {\n                if (rotate) {\n                    var origin = model.getBBox().center();\n                    vel.rotate(angle, origin.x, origin.y, { absolute: true });\n                } else {\n                    bbox = bbox.bbox(angle);\n                }\n            }\n        }\n        vel.attr(bbox.toJSON());\n        return this;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0JvdW5kYXJ5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUMwQztBQUNLO0FBQ0g7O0FBRXJDLGlCQUFpQix1REFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRCxnQkFBZ0IsMkJBQTJCO0FBQzNDLHdCQUF3QiwyREFBbUI7QUFDM0MsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxnQkFBZ0I7QUFDNUUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9Cb3VuZGFyeS5tanM/MzU5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgVG9vbFZpZXcgfSBmcm9tICcuLi9kaWEvVG9vbFZpZXcubWpzJztcbmltcG9ydCB7IGdldFZpZXdCQm94IH0gZnJvbSAnLi9oZWxwZXJzLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBCb3VuZGFyeSA9IFRvb2xWaWV3LmV4dGVuZCh7XG4gICAgbmFtZTogJ2JvdW5kYXJ5JyxcbiAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgdXNlTW9kZWxHZW9tZXRyeTogZmFsc2UsXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAnc3Ryb2tlJzogJyMzMzMzNEYnLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogLjUsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JzogJzUsIDUnLFxuICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXc6IHZpZXcsIG9wdGlvbnMsIHZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB1c2VNb2RlbEdlb21ldHJ5LCByb3RhdGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB1dGlsLm5vcm1hbGl6ZVNpZGVzKG9wdGlvbnMucGFkZGluZyk7XG4gICAgICAgIGxldCBiYm94ID0gZ2V0Vmlld0JCb3godmlldywgdXNlTW9kZWxHZW9tZXRyeSkubW92ZUFuZEV4cGFuZCh7XG4gICAgICAgICAgICB4OiAtcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgeTogLXBhZGRpbmcudG9wLFxuICAgICAgICAgICAgd2lkdGg6IHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b21cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtb2RlbCA9IHZpZXcubW9kZWw7XG4gICAgICAgIGlmIChtb2RlbC5pc0VsZW1lbnQoKSkge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gbW9kZWwuYW5nbGUoKTtcbiAgICAgICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IG1vZGVsLmdldEJCb3goKS5jZW50ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmVsLnJvdGF0ZShhbmdsZSwgb3JpZ2luLngsIG9yaWdpbi55LCB7IGFic29sdXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJib3ggPSBiYm94LmJib3goYW5nbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2ZWwuYXR0cihiYm94LnRvSlNPTigpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Boundary.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Button.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Button.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ Button; },\n/* harmony export */   Remove: function() { return /* binding */ Remove; }\n/* harmony export */ });\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\n\n\nconst Button = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    name: 'button',\n    events: {\n        'mousedown': 'onPointerDown',\n        'touchstart': 'onPointerDown'\n    },\n    options: {\n        distance: 0,\n        offset: 0,\n        scale: null,\n        rotate: false\n    },\n    onRender: function() {\n        this.renderChildren(this.options.markup);\n        this.update();\n    },\n    update: function() {\n        this.position();\n        return this;\n    },\n    position: function() {\n        const { vel } = this;\n        vel.transform(this.getCellMatrix(), { absolute: true });\n    },\n    getCellMatrix() {\n        return this.relatedView.model.isLink() ? this.getLinkMatrix() : this.getElementMatrix();\n    },\n    getElementMatrix() {\n        const { relatedView: view, options } = this;\n        let { x = 0, y = 0, offset = {}, useModelGeometry, rotate, scale } = options;\n        let bbox = (0,_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.getViewBBox)(view, useModelGeometry);\n        const angle = view.model.angle();\n        if (!rotate) bbox = bbox.bbox(angle);\n        const { x: offsetX = 0, y: offsetY = 0 } = offset;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(x)) {\n            x = parseFloat(x) / 100 * bbox.width;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isCalcExpression(x)) {\n            x = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.evalCalcExpression(x, bbox));\n        }\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(y)) {\n            y = parseFloat(y) / 100 * bbox.height;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isCalcExpression(y)) {\n            y = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.evalCalcExpression(y, bbox));\n        }\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n        if (rotate) matrix = matrix.rotate(angle);\n        matrix = matrix.translate(x + offsetX - bbox.width / 2, y + offsetY - bbox.height / 2);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n    getLinkMatrix() {\n        const { relatedView: view, options } = this;\n        const { offset = 0, distance: distanceOpt = 0, rotate, scale } = options;\n        const distance = (typeof distanceOpt === 'function')\n            ? distanceOpt.call(this, view, this)\n            : distanceOpt;\n        let tangent, position, angle;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(distance)) {\n            tangent = view.getTangentAtRatio(parseFloat(distance) / 100);\n        } else {\n            tangent = view.getTangentAtLength(distance);\n        }\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(1, 0)) || 0;\n        } else {\n            position = view.getConnection().start;\n            angle = 0;\n        }\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix()\n            .translate(position.x, position.y)\n            .rotate(angle)\n            .translate(0, offset);\n        if (!rotate) matrix = matrix.rotate(-angle);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var actionFn = this.options.action;\n        if (typeof actionFn === 'function') {\n            actionFn.call(this.relatedView, evt, this.relatedView, this);\n        }\n    }\n});\n\nconst Remove = Button.extend({\n    name: 'remove',\n    children: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#FF1D00',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -3 -3 3 3 M -3 3 3 -3',\n            'fill': 'none',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    options: {\n        distance: 60,\n        offset: 0,\n        action: function(evt, view, tool) {\n            view.model.remove({ ui: true, tool: tool.cid });\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0J1dHRvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBK0M7QUFDSDtBQUNGO0FBQ047QUFDTDs7QUFFeEIsZUFBZSx1REFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0Qiw4Q0FBOEMsZ0JBQWdCO0FBQzlELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxjQUFjLHlCQUF5QixvQ0FBb0M7QUFDM0UsbUJBQW1CLHlEQUFXO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pELFlBQVkseURBQWlCO0FBQzdCO0FBQ0EsVUFBVSxTQUFTLDZEQUFxQjtBQUN4Qyx1QkFBdUIsK0RBQXVCO0FBQzlDO0FBQ0EsWUFBWSx5REFBaUI7QUFDN0I7QUFDQSxVQUFVLFNBQVMsNkRBQXFCO0FBQ3hDLHVCQUF1QiwrREFBdUI7QUFDOUM7QUFDQSxxQkFBcUIsb0RBQUM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDLGdCQUFnQix1REFBdUQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlEQUFpQjtBQUM3QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwrQ0FBTztBQUM1RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFDO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQkFBMEI7QUFDMUQ7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jZWxsVG9vbHMvQnV0dG9uLm1qcz9iZDAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRvb2xWaWV3IH0gZnJvbSAnLi4vZGlhL1Rvb2xWaWV3Lm1qcyc7XG5pbXBvcnQgeyBnZXRWaWV3QkJveCB9IGZyb20gJy4vaGVscGVycy5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IEJ1dHRvbiA9IFRvb2xWaWV3LmV4dGVuZCh7XG4gICAgbmFtZTogJ2J1dHRvbicsXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdtb3VzZWRvd24nOiAnb25Qb2ludGVyRG93bicsXG4gICAgICAgICd0b3VjaHN0YXJ0JzogJ29uUG9pbnRlckRvd24nXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGRpc3RhbmNlOiAwLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICByb3RhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4odGhpcy5vcHRpb25zLm1hcmt1cCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHZlbCB9ID0gdGhpcztcbiAgICAgICAgdmVsLnRyYW5zZm9ybSh0aGlzLmdldENlbGxNYXRyaXgoKSwgeyBhYnNvbHV0ZTogdHJ1ZSB9KTtcbiAgICB9LFxuICAgIGdldENlbGxNYXRyaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGF0ZWRWaWV3Lm1vZGVsLmlzTGluaygpID8gdGhpcy5nZXRMaW5rTWF0cml4KCkgOiB0aGlzLmdldEVsZW1lbnRNYXRyaXgoKTtcbiAgICB9LFxuICAgIGdldEVsZW1lbnRNYXRyaXgoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXc6IHZpZXcsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHggPSAwLCB5ID0gMCwgb2Zmc2V0ID0ge30sIHVzZU1vZGVsR2VvbWV0cnksIHJvdGF0ZSwgc2NhbGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBiYm94ID0gZ2V0Vmlld0JCb3godmlldywgdXNlTW9kZWxHZW9tZXRyeSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAoIXJvdGF0ZSkgYmJveCA9IGJib3guYmJveChhbmdsZSk7XG4gICAgICAgIGNvbnN0IHsgeDogb2Zmc2V0WCA9IDAsIHk6IG9mZnNldFkgPSAwIH0gPSBvZmZzZXQ7XG4gICAgICAgIGlmICh1dGlsLmlzUGVyY2VudGFnZSh4KSkge1xuICAgICAgICAgICAgeCA9IHBhcnNlRmxvYXQoeCkgLyAxMDAgKiBiYm94LndpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNDYWxjRXhwcmVzc2lvbih4KSkge1xuICAgICAgICAgICAgeCA9IE51bWJlcih1dGlsLmV2YWxDYWxjRXhwcmVzc2lvbih4LCBiYm94KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwuaXNQZXJjZW50YWdlKHkpKSB7XG4gICAgICAgICAgICB5ID0gcGFyc2VGbG9hdCh5KSAvIDEwMCAqIGJib3guaGVpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNDYWxjRXhwcmVzc2lvbih5KSkge1xuICAgICAgICAgICAgeSA9IE51bWJlcih1dGlsLmV2YWxDYWxjRXhwcmVzc2lvbih5LCBiYm94KSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KCkudHJhbnNsYXRlKGJib3gueCArIGJib3gud2lkdGggLyAyLCBiYm94LnkgKyBiYm94LmhlaWdodCAvIDIpO1xuICAgICAgICBpZiAocm90YXRlKSBtYXRyaXggPSBtYXRyaXgucm90YXRlKGFuZ2xlKTtcbiAgICAgICAgbWF0cml4ID0gbWF0cml4LnRyYW5zbGF0ZSh4ICsgb2Zmc2V0WCAtIGJib3gud2lkdGggLyAyLCB5ICsgb2Zmc2V0WSAtIGJib3guaGVpZ2h0IC8gMik7XG4gICAgICAgIGlmIChzY2FsZSkgbWF0cml4ID0gbWF0cml4LnNjYWxlKHNjYWxlKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuICAgIGdldExpbmtNYXRyaXgoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXc6IHZpZXcsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0ID0gMCwgZGlzdGFuY2U6IGRpc3RhbmNlT3B0ID0gMCwgcm90YXRlLCBzY2FsZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAodHlwZW9mIGRpc3RhbmNlT3B0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgPyBkaXN0YW5jZU9wdC5jYWxsKHRoaXMsIHZpZXcsIHRoaXMpXG4gICAgICAgICAgICA6IGRpc3RhbmNlT3B0O1xuICAgICAgICBsZXQgdGFuZ2VudCwgcG9zaXRpb24sIGFuZ2xlO1xuICAgICAgICBpZiAodXRpbC5pc1BlcmNlbnRhZ2UoZGlzdGFuY2UpKSB7XG4gICAgICAgICAgICB0YW5nZW50ID0gdmlldy5nZXRUYW5nZW50QXRSYXRpbyhwYXJzZUZsb2F0KGRpc3RhbmNlKSAvIDEwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YW5nZW50ID0gdmlldy5nZXRUYW5nZW50QXRMZW5ndGgoZGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRhbmdlbnQuc3RhcnQ7XG4gICAgICAgICAgICBhbmdsZSA9IHRhbmdlbnQudmVjdG9yKCkudmVjdG9yQW5nbGUobmV3IGcuUG9pbnQoMSwgMCkpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHZpZXcuZ2V0Q29ubmVjdGlvbigpLnN0YXJ0O1xuICAgICAgICAgICAgYW5nbGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpXG4gICAgICAgICAgICAudHJhbnNsYXRlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpXG4gICAgICAgICAgICAucm90YXRlKGFuZ2xlKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICBpZiAoIXJvdGF0ZSkgbWF0cml4ID0gbWF0cml4LnJvdGF0ZSgtYW5nbGUpO1xuICAgICAgICBpZiAoc2NhbGUpIG1hdHJpeCA9IG1hdHJpeC5zY2FsZShzY2FsZSk7XG4gICAgICAgIHJldHVybiBtYXRyaXg7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0KSkgcmV0dXJuO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgYWN0aW9uRm4gPSB0aGlzLm9wdGlvbnMuYWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbkZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhY3Rpb25Gbi5jYWxsKHRoaXMucmVsYXRlZFZpZXcsIGV2dCwgdGhpcy5yZWxhdGVkVmlldywgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IFJlbW92ZSA9IEJ1dHRvbi5leHRlbmQoe1xuICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0YWdOYW1lOiAnY2lyY2xlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdidXR0b24nLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAncic6IDcsXG4gICAgICAgICAgICAnZmlsbCc6ICcjRkYxRDAwJyxcbiAgICAgICAgICAgICdjdXJzb3InOiAncG9pbnRlcidcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ2ljb24nLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZCc6ICdNIC0zIC0zIDMgMyBNIC0zIDMgMyAtMycsXG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfV0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBkaXN0YW5jZTogNjAsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihldnQsIHZpZXcsIHRvb2wpIHtcbiAgICAgICAgICAgIHZpZXcubW9kZWwucmVtb3ZlKHsgdWk6IHRydWUsIHRvb2w6IHRvb2wuY2lkIH0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Button.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Connect.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Connect.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Connect: function() { return /* binding */ Connect; }\n/* harmony export */ });\n/* harmony import */ var _Button_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Button.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Button.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nconst Connect = _Button_mjs__WEBPACK_IMPORTED_MODULE_0__.Button.extend({\n    name: 'connect',\n    documentEvents: {\n        mousemove: 'drag',\n        touchmove: 'drag',\n        mouseup: 'dragend',\n        touchend: 'dragend',\n        touchcancel: 'dragend'\n    },\n    children: [{\n        tagName: 'circle',\n        selector: 'button',\n        attributes: {\n            'r': 7,\n            'fill': '#333333',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'icon',\n        attributes: {\n            'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n            'fill': '#FFFFFF',\n            'stroke': 'none',\n            'stroke-width': 2,\n            'pointer-events': 'none'\n        }\n    }],\n    options: {\n        distance: 80,\n        offset: 0,\n        magnet: (view) => view.el,\n        action: (evt, _view, tool) => tool.dragstart(evt),\n    },\n    getMagnetNode: function() {\n        const { options, relatedView } = this;\n        const { magnet } = options;\n        let magnetNode;\n        switch (typeof magnet) {\n            case 'function': {\n                magnetNode = magnet.call(this, relatedView, this);\n                break;\n            }\n            case 'string': {\n                magnetNode = relatedView.findNode(magnet);\n                break;\n            }\n            default: {\n                magnetNode = magnet;\n                break;\n            }\n        }\n        if (!magnetNode) magnetNode = relatedView.el;\n        if (magnetNode instanceof SVGElement) return magnetNode;\n        throw new Error('Connect: magnet must be an SVGElement');\n    },\n    dragstart: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const { x, y } = paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLinkStart(normalizedEvent, this.getMagnetNode(), x, y);\n        paper.undelegateEvents();\n        this.delegateDocumentEvents(null, normalizedEvent.data);\n        this.focus();\n    },\n    drag: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const { x, y } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLink(normalizedEvent, x, y);\n    },\n    dragend: function(evt) {\n        const { paper, relatedView } = this;\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const { x, y } = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.dragLinkEnd(normalizedEvent, x, y);\n        this.undelegateDocumentEvents();\n        paper.delegateEvents();\n        this.blur();\n        relatedView.checkMouseleave(normalizedEvent);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0Nvbm5lY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFzQztBQUNJOztBQUVuQyxnQkFBZ0IsK0NBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQ0FBZ0MsMkRBQW1CO0FBQ25ELGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQ0FBZ0MsMkRBQW1CO0FBQ25ELGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQ0FBZ0MsMkRBQW1CO0FBQ25ELGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jZWxsVG9vbHMvQ29ubmVjdC5tanM/ZGMyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdXR0b24gfSBmcm9tICcuL0J1dHRvbi5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBDb25uZWN0ID0gQnV0dG9uLmV4dGVuZCh7XG4gICAgbmFtZTogJ2Nvbm5lY3QnLFxuICAgIGRvY3VtZW50RXZlbnRzOiB7XG4gICAgICAgIG1vdXNlbW92ZTogJ2RyYWcnLFxuICAgICAgICB0b3VjaG1vdmU6ICdkcmFnJyxcbiAgICAgICAgbW91c2V1cDogJ2RyYWdlbmQnLFxuICAgICAgICB0b3VjaGVuZDogJ2RyYWdlbmQnLFxuICAgICAgICB0b3VjaGNhbmNlbDogJ2RyYWdlbmQnXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnTmFtZTogJ2NpcmNsZScsXG4gICAgICAgIHNlbGVjdG9yOiAnYnV0dG9uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3InOiA3LFxuICAgICAgICAgICAgJ2ZpbGwnOiAnIzMzMzMzMycsXG4gICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdpY29uJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2QnOiAnTSAtNCAtMSBMIDAgLTEgTCAwIC00IEwgNCAwIEwgMCA0IDAgMSAtNCAxIHonLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZGlzdGFuY2U6IDgwLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIG1hZ25ldDogKHZpZXcpID0+IHZpZXcuZWwsXG4gICAgICAgIGFjdGlvbjogKGV2dCwgX3ZpZXcsIHRvb2wpID0+IHRvb2wuZHJhZ3N0YXJ0KGV2dCksXG4gICAgfSxcbiAgICBnZXRNYWduZXROb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCByZWxhdGVkVmlldyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBtYWduZXQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBtYWduZXROb2RlO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBtYWduZXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzoge1xuICAgICAgICAgICAgICAgIG1hZ25ldE5vZGUgPSBtYWduZXQuY2FsbCh0aGlzLCByZWxhdGVkVmlldywgdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICAgICAgbWFnbmV0Tm9kZSA9IHJlbGF0ZWRWaWV3LmZpbmROb2RlKG1hZ25ldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbWFnbmV0Tm9kZSA9IG1hZ25ldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hZ25ldE5vZGUpIG1hZ25ldE5vZGUgPSByZWxhdGVkVmlldy5lbDtcbiAgICAgICAgaWYgKG1hZ25ldE5vZGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSByZXR1cm4gbWFnbmV0Tm9kZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0OiBtYWduZXQgbXVzdCBiZSBhbiBTVkdFbGVtZW50Jyk7XG4gICAgfSxcbiAgICBkcmFnc3RhcnQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBjb25zdCB7IHBhcGVyLCByZWxhdGVkVmlldyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBhcGVyLmNsaWVudFRvTG9jYWxQb2ludChub3JtYWxpemVkRXZlbnQuY2xpZW50WCwgbm9ybWFsaXplZEV2ZW50LmNsaWVudFkpO1xuICAgICAgICByZWxhdGVkVmlldy5kcmFnTGlua1N0YXJ0KG5vcm1hbGl6ZWRFdmVudCwgdGhpcy5nZXRNYWduZXROb2RlKCksIHgsIHkpO1xuICAgICAgICBwYXBlci51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVEb2N1bWVudEV2ZW50cyhudWxsLCBub3JtYWxpemVkRXZlbnQuZGF0YSk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9LFxuICAgIGRyYWc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBjb25zdCB7IHBhcGVyLCByZWxhdGVkVmlldyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBhcGVyLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgcmVsYXRlZFZpZXcuZHJhZ0xpbmsobm9ybWFsaXplZEV2ZW50LCB4LCB5KTtcbiAgICB9LFxuICAgIGRyYWdlbmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBjb25zdCB7IHBhcGVyLCByZWxhdGVkVmlldyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHBhcGVyLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgcmVsYXRlZFZpZXcuZHJhZ0xpbmtFbmQobm9ybWFsaXplZEV2ZW50LCB4LCB5KTtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgcGFwZXIuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIHJlbGF0ZWRWaWV3LmNoZWNrTW91c2VsZWF2ZShub3JtYWxpemVkRXZlbnQpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Connect.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Control.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/Control.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Control: function() { return /* binding */ Control; }\n/* harmony export */ });\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nconst Control = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    tagName: 'g',\n    children: [{\n        tagName: 'circle',\n        selector: 'handle',\n        attributes: {\n            'cursor': 'pointer',\n            'stroke-width': 2,\n            'stroke': '#FFFFFF',\n            'fill': '#33334F',\n            'r': 6\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'extras',\n        attributes: {\n            'pointer-events': 'none',\n            'fill': 'none',\n            'stroke': '#33334F',\n            'stroke-dasharray': '2,4',\n            'rx': 5,\n            'ry': 5\n        }\n    }],\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onPointerDblClick',\n        dbltap: 'onPointerDblClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        handleAttributes: null,\n        selector: 'root',\n        padding: 6,\n        scale: null\n    },\n\n    getPosition: function() {\n        // To be overridden\n    },\n    setPosition: function() {\n        // To be overridden\n    },\n    resetPosition: function() {\n        // To be overridden\n    },\n    onRender: function() {\n        this.renderChildren();\n        this.toggleExtras(false);\n        this.update();\n    },\n    update: function() {\n        const { handle, extras } = this.childNodes;\n        if (handle) {\n            this.updateHandle(handle);\n        } else {\n            throw new Error('Control: markup selector `handle` is required');\n        }\n        if (extras) {\n            this.updateExtras(extras);\n        }\n        return this;\n    },\n    updateHandle: function(handleNode) {\n        const { relatedView, options } = this;\n        const { model } = relatedView;\n        const relativePos = this.getPosition(relatedView, this);\n        const absolutePos = model.getAbsolutePointFromRelative(relativePos);\n        const { handleAttributes, scale } = options;\n        let transformString =  `translate(${absolutePos.x},${absolutePos.y})`;\n        if (scale) {\n            transformString += ` scale(${scale})`;\n        }\n        handleNode.setAttribute('transform', transformString);\n        if (handleAttributes) {\n            for (let attrName in handleAttributes) {\n                handleNode.setAttribute(attrName, handleAttributes[attrName]);\n            }\n        }\n    },\n    updateExtras: function(extrasNode) {\n        const { relatedView, options } = this;\n        const { selector } = this.options;\n        if (!selector) {\n            this.toggleExtras(false);\n            return;\n        }\n        const magnet = relatedView.findNode(selector);\n        if (!magnet) throw new Error('Control: invalid selector.');\n        let padding = options.padding;\n        if (!isFinite(padding)) padding = 0;\n        const bbox = relatedView.getNodeUnrotatedBBox(magnet);\n        const model = relatedView.model;\n        const angle = model.angle();\n        const center = bbox.center();\n        if (angle) center.rotate(model.getBBox().center(), -angle);\n        bbox.inflate(padding);\n        extrasNode.setAttribute('x', -bbox.width / 2);\n        extrasNode.setAttribute('y', -bbox.height / 2);\n        extrasNode.setAttribute('width', bbox.width);\n        extrasNode.setAttribute('height', bbox.height);\n        extrasNode.setAttribute('transform', `translate(${center.x},${center.y}) rotate(${angle})`);\n    },\n    toggleExtras: function(visible) {\n        const { extras } = this.childNodes;\n        if (!extras) return;\n        extras.style.display = (visible) ? '' : 'none';\n    },\n    onPointerDown: function(evt) {\n        const { relatedView, paper } = this;\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        paper.undelegateEvents();\n        this.delegateDocumentEvents();\n        this.focus();\n        this.toggleExtras(true);\n        relatedView.model.startBatch('control-move', { ui: true, tool: this.cid });\n    },\n    onPointerMove: function(evt) {\n        const { relatedView, paper } = this;\n        const { model } = relatedView;\n        const { clientX, clientY } = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent(evt);\n        const coords = paper.clientToLocalPoint(clientX, clientY);\n        const relativeCoords = model.getRelativePointFromAbsolute(coords);\n        this.setPosition(relatedView, relativeCoords, evt);\n        this.update();\n    },\n    onPointerUp: function(_evt) {\n        const { relatedView, paper } = this;\n        paper.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleExtras(false);\n        relatedView.model.stopBatch('control-move', { ui: true, tool: this.cid });\n    },\n    onPointerDblClick: function(evt) {\n        const { relatedView } = this;\n        this.resetPosition(relatedView, evt);\n        this.update();\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0NvbnRyb2wubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNMOztBQUVuQyxnQkFBZ0IsdURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDLDRDQUE0QyxjQUFjLEdBQUcsY0FBYztBQUMzRTtBQUNBLHlDQUF5QyxNQUFNO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUyxHQUFHLFNBQVMsV0FBVyxNQUFNO0FBQ2hHLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQjtBQUNqRixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixtQkFBbUIsRUFBRSwyREFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2NlbGxUb29scy9Db250cm9sLm1qcz84YjI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRvb2xWaWV3IH0gZnJvbSAnLi4vZGlhL1Rvb2xWaWV3Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IENvbnRyb2wgPSBUb29sVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnTmFtZTogJ2NpcmNsZScsXG4gICAgICAgIHNlbGVjdG9yOiAnaGFuZGxlJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAgICAgJ3N0cm9rZSc6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICdmaWxsJzogJyMzMzMzNEYnLFxuICAgICAgICAgICAgJ3InOiA2XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdleHRyYXMnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAnIzMzMzM0RicsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcyLDQnLFxuICAgICAgICAgICAgJ3J4JzogNSxcbiAgICAgICAgICAgICdyeSc6IDVcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIGV2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgdG91Y2hzdGFydDogJ29uUG9pbnRlckRvd24nLFxuICAgICAgICBkYmxjbGljazogJ29uUG9pbnRlckRibENsaWNrJyxcbiAgICAgICAgZGJsdGFwOiAnb25Qb2ludGVyRGJsQ2xpY2snXG4gICAgfSxcbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICdvblBvaW50ZXJNb3ZlJyxcbiAgICAgICAgdG91Y2htb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIG1vdXNldXA6ICdvblBvaW50ZXJVcCcsXG4gICAgICAgIHRvdWNoZW5kOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGNhbmNlbDogJ29uUG9pbnRlclVwJ1xuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBoYW5kbGVBdHRyaWJ1dGVzOiBudWxsLFxuICAgICAgICBzZWxlY3RvcjogJ3Jvb3QnLFxuICAgICAgICBwYWRkaW5nOiA2LFxuICAgICAgICBzY2FsZTogbnVsbFxuICAgIH0sXG5cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVG8gYmUgb3ZlcnJpZGRlblxuICAgIH0sXG4gICAgcmVzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZUV4dHJhcyhmYWxzZSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGhhbmRsZSwgZXh0cmFzIH0gPSB0aGlzLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSGFuZGxlKGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyb2w6IG1hcmt1cCBzZWxlY3RvciBgaGFuZGxlYCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYXMpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXh0cmFzKGV4dHJhcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB1cGRhdGVIYW5kbGU6IGZ1bmN0aW9uKGhhbmRsZU5vZGUpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gcmVsYXRlZFZpZXc7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUG9zID0gdGhpcy5nZXRQb3NpdGlvbihyZWxhdGVkVmlldywgdGhpcyk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlUG9zID0gbW9kZWwuZ2V0QWJzb2x1dGVQb2ludEZyb21SZWxhdGl2ZShyZWxhdGl2ZVBvcyk7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlQXR0cmlidXRlcywgc2NhbGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1TdHJpbmcgPSAgYHRyYW5zbGF0ZSgke2Fic29sdXRlUG9zLnh9LCR7YWJzb2x1dGVQb3MueX0pYDtcbiAgICAgICAgaWYgKHNjYWxlKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gYCBzY2FsZSgke3NjYWxlfSlgO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZU5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1TdHJpbmcpO1xuICAgICAgICBpZiAoaGFuZGxlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ck5hbWUgaW4gaGFuZGxlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBoYW5kbGVBdHRyaWJ1dGVzW2F0dHJOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHVwZGF0ZUV4dHJhczogZnVuY3Rpb24oZXh0cmFzTm9kZSkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3LCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRXh0cmFzKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYWduZXQgPSByZWxhdGVkVmlldy5maW5kTm9kZShzZWxlY3Rvcik7XG4gICAgICAgIGlmICghbWFnbmV0KSB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyb2w6IGludmFsaWQgc2VsZWN0b3IuJyk7XG4gICAgICAgIGxldCBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHBhZGRpbmcpKSBwYWRkaW5nID0gMDtcbiAgICAgICAgY29uc3QgYmJveCA9IHJlbGF0ZWRWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KG1hZ25ldCk7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gcmVsYXRlZFZpZXcubW9kZWw7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gbW9kZWwuYW5nbGUoKTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gYmJveC5jZW50ZXIoKTtcbiAgICAgICAgaWYgKGFuZ2xlKSBjZW50ZXIucm90YXRlKG1vZGVsLmdldEJCb3goKS5jZW50ZXIoKSwgLWFuZ2xlKTtcbiAgICAgICAgYmJveC5pbmZsYXRlKHBhZGRpbmcpO1xuICAgICAgICBleHRyYXNOb2RlLnNldEF0dHJpYnV0ZSgneCcsIC1iYm94LndpZHRoIC8gMik7XG4gICAgICAgIGV4dHJhc05vZGUuc2V0QXR0cmlidXRlKCd5JywgLWJib3guaGVpZ2h0IC8gMik7XG4gICAgICAgIGV4dHJhc05vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJib3gud2lkdGgpO1xuICAgICAgICBleHRyYXNOb2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYmJveC5oZWlnaHQpO1xuICAgICAgICBleHRyYXNOb2RlLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2NlbnRlci54fSwke2NlbnRlci55fSkgcm90YXRlKCR7YW5nbGV9KWApO1xuICAgIH0sXG4gICAgdG9nZ2xlRXh0cmFzOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICAgIGNvbnN0IHsgZXh0cmFzIH0gPSB0aGlzLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmICghZXh0cmFzKSByZXR1cm47XG4gICAgICAgIGV4dHJhcy5zdHlsZS5kaXNwbGF5ID0gKHZpc2libGUpID8gJycgOiAnbm9uZSc7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCkpIHJldHVybjtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcGFwZXIudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB0aGlzLnRvZ2dsZUV4dHJhcyh0cnVlKTtcbiAgICAgICAgcmVsYXRlZFZpZXcubW9kZWwuc3RhcnRCYXRjaCgnY29udHJvbC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHJlbGF0ZWRWaWV3O1xuICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgY29uc3QgY29vcmRzID0gcGFwZXIuY2xpZW50VG9Mb2NhbFBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvb3JkcyA9IG1vZGVsLmdldFJlbGF0aXZlUG9pbnRGcm9tQWJzb2x1dGUoY29vcmRzKTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihyZWxhdGVkVmlldywgcmVsYXRpdmVDb29yZHMsIGV2dCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJVcDogZnVuY3Rpb24oX2V2dCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3LCBwYXBlciB9ID0gdGhpcztcbiAgICAgICAgcGFwZXIuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRXh0cmFzKGZhbHNlKTtcbiAgICAgICAgcmVsYXRlZFZpZXcubW9kZWwuc3RvcEJhdGNoKCdjb250cm9sLW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICB9LFxuICAgIG9uUG9pbnRlckRibENsaWNrOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldyB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKHJlbGF0ZWRWaWV3LCBldnQpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Control.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/HoverConnect.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HoverConnect: function() { return /* binding */ HoverConnect; }\n/* harmony export */ });\n/* harmony import */ var _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Connect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Connect.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\n\n\n\n\nconst HoverConnect = _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__.Connect.extend({\n\n    name: 'hover-connect',\n\n    defaultMarkup: [\n        {\n            tagName: 'circle',\n            attributes: {\n                'r': 7,\n                'fill': '#333333',\n                'cursor': 'pointer'\n            }\n        },\n        {\n            tagName: 'path',\n            attributes: {\n                'd': 'M -4 -1 L 0 -1 L 0 -4 L 4 0 L 0 4 0 1 -4 1 z',\n                'fill': '#FFFFFF',\n                'stroke': 'none',\n                'stroke-width': 2\n            }\n        }\n    ],\n\n    children() {\n        const { options, defaultMarkup } = this;\n        return [\n            {\n                tagName: 'path',\n                selector: 'track',\n                attributes: {\n                    'fill': 'none',\n                    'stroke': 'transparent',\n                    'stroke-width': options.trackWidth || 15,\n                    'cursor': 'pointer'\n                }\n            },\n            {\n                tagName: 'g',\n                selector: 'button',\n                attributes: {\n                    'pointer-events': 'none',\n                    'display': 'none'\n                },\n                children: options.markup || defaultMarkup\n            }\n        ];\n    },\n\n    events: Object.assign({\n        mousemove: 'onMousemove',\n        mouseenter: 'onMouseenter',\n        mouseleave: 'onMouseleave'\n    }, _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__.Connect.prototype.events),\n\n    onRender: function() {\n        this.renderChildren();\n        this.update();\n    },\n\n    trackPath: null,\n\n    update() {\n        const { childNodes } = this;\n        this.trackPath = this.getTrackPath();\n        _Connect_mjs__WEBPACK_IMPORTED_MODULE_0__.Connect.prototype.update.apply(this, arguments);\n        childNodes.track.setAttribute(\n            'd',\n            this.trackPath.serialize()\n        );\n    },\n\n    position() {\n        const { el, childNodes } = this;\n        childNodes.button.setAttribute(\n            'transform',\n            _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(this.getButtonMatrix())\n        );\n        el.setAttribute(\n            'transform',\n            _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(this.getTrackMatrix())\n        );\n    },\n\n    getButtonMatrix() {\n        const { options, trackPath } = this;\n        const { offset = 0, distance = 0, rotate, scale } = options;\n        let tangent, position, angle;\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage(distance)) {\n            tangent = trackPath.tangentAtRatio(parseFloat(distance) / 100);\n        } else {\n            tangent = trackPath.tangentAtLength(distance);\n        }\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(1, 0)) || 0;\n        } else {\n            position = trackPath.start;\n            angle = 0;\n        }\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix()\n            .translate(position.x, position.y)\n            .rotate(angle)\n            .translate(0, offset);\n        if (!rotate) matrix = matrix.rotate(-angle);\n        if (scale) matrix = matrix.scale(scale);\n        return matrix;\n    },\n\n    getTrackPath() {\n        return this.relatedView.getConnection();\n    },\n\n    getTrackMatrix() {\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix();\n    },\n\n    getTrackRatioFromEvent(evt) {\n        const { relatedView, trackPath } = this;\n        const localPoint = relatedView.paper.clientToLocalPoint(evt.clientX, evt.clientY);\n        const trackPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformPoint(localPoint, this.getTrackMatrix().inverse());\n        return trackPath.closestPointLength(trackPoint);\n    },\n\n    canShowButton() {\n        // Has been the paper events undelegated? If so, we can't show the button.\n        // TODO: add a method to the paper to check if the events are delegated.\n        return _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].event.has(this.paper.el);\n    },\n\n    showButton() {\n        this.childNodes.button.style.display = 'block';\n    },\n\n    hideButton() {\n        this.childNodes.button.style.display = '';\n    },\n\n    onMousemove(evt) {\n        const { trackPath } = this;\n        if (!trackPath) return;\n        const { options } = this;\n        options.distance = this.getTrackRatioFromEvent(evt);\n        this.position();\n    },\n\n    onMouseenter() {\n        if (!this.canShowButton()) return;\n        this.showButton();\n    },\n\n    onMouseleave() {\n        this.hideButton();\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL0hvdmVyQ29ubmVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdDO0FBQ1Q7QUFDTTtBQUNLO0FBQ047O0FBRTdCLHFCQUFxQixpREFBTzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsaURBQU87O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0EsUUFBUSxpREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLFlBQVksb0RBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9EQUFDO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0IsMENBQTBDO0FBQzFEO0FBQ0EsWUFBWSx5REFBaUI7QUFDN0I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsK0NBQU87QUFDNUQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxvREFBQztBQUNoQixLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBLDJCQUEyQixvREFBQztBQUM1QjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBQztBQUNoQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jZWxsVG9vbHMvSG92ZXJDb25uZWN0Lm1qcz84NDQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3QgfSBmcm9tICcuL0Nvbm5lY3QubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCAkIGZyb20gJy4uL212Yy9Eb20vaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBIb3ZlckNvbm5lY3QgPSBDb25uZWN0LmV4dGVuZCh7XG5cbiAgICBuYW1lOiAnaG92ZXItY29ubmVjdCcsXG5cbiAgICBkZWZhdWx0TWFya3VwOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICdyJzogNyxcbiAgICAgICAgICAgICAgICAnZmlsbCc6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAnZCc6ICdNIC00IC0xIEwgMCAtMSBMIDAgLTQgTCA0IDAgTCAwIDQgMCAxIC00IDEgeicsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSxcblxuICAgIGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIGRlZmF1bHRNYXJrdXAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAndHJhY2snLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICdzdHJva2UnOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogb3B0aW9ucy50cmFja1dpZHRoIHx8IDE1LFxuICAgICAgICAgICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnZycsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdidXR0b24nLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAnZGlzcGxheSc6ICdub25lJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IG9wdGlvbnMubWFya3VwIHx8IGRlZmF1bHRNYXJrdXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZXZlbnRzOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbW91c2Vtb3ZlOiAnb25Nb3VzZW1vdmUnLFxuICAgICAgICBtb3VzZWVudGVyOiAnb25Nb3VzZWVudGVyJyxcbiAgICAgICAgbW91c2VsZWF2ZTogJ29uTW91c2VsZWF2ZSdcbiAgICB9LCBDb25uZWN0LnByb3RvdHlwZS5ldmVudHMpLFxuXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHRyYWNrUGF0aDogbnVsbCxcblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZE5vZGVzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYWNrUGF0aCA9IHRoaXMuZ2V0VHJhY2tQYXRoKCk7XG4gICAgICAgIENvbm5lY3QucHJvdG90eXBlLnVwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBjaGlsZE5vZGVzLnRyYWNrLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICdkJyxcbiAgICAgICAgICAgIHRoaXMudHJhY2tQYXRoLnNlcmlhbGl6ZSgpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHBvc2l0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGVsLCBjaGlsZE5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBjaGlsZE5vZGVzLmJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgICAgIFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcodGhpcy5nZXRCdXR0b25NYXRyaXgoKSlcbiAgICAgICAgKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFxuICAgICAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKHRoaXMuZ2V0VHJhY2tNYXRyaXgoKSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0QnV0dG9uTWF0cml4KCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHRyYWNrUGF0aCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBvZmZzZXQgPSAwLCBkaXN0YW5jZSA9IDAsIHJvdGF0ZSwgc2NhbGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCB0YW5nZW50LCBwb3NpdGlvbiwgYW5nbGU7XG4gICAgICAgIGlmICh1dGlsLmlzUGVyY2VudGFnZShkaXN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRhbmdlbnQgPSB0cmFja1BhdGgudGFuZ2VudEF0UmF0aW8ocGFyc2VGbG9hdChkaXN0YW5jZSkgLyAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFuZ2VudCA9IHRyYWNrUGF0aC50YW5nZW50QXRMZW5ndGgoZGlzdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRhbmdlbnQuc3RhcnQ7XG4gICAgICAgICAgICBhbmdsZSA9IHRhbmdlbnQudmVjdG9yKCkudmVjdG9yQW5nbGUobmV3IGcuUG9pbnQoMSwgMCkpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRyYWNrUGF0aC5zdGFydDtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KVxuICAgICAgICAgICAgLnJvdGF0ZShhbmdsZSlcbiAgICAgICAgICAgIC50cmFuc2xhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFyb3RhdGUpIG1hdHJpeCA9IG1hdHJpeC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgICAgaWYgKHNjYWxlKSBtYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH0sXG5cbiAgICBnZXRUcmFja1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGF0ZWRWaWV3LmdldENvbm5lY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgZ2V0VHJhY2tNYXRyaXgoKSB7XG4gICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuICAgIH0sXG5cbiAgICBnZXRUcmFja1JhdGlvRnJvbUV2ZW50KGV2dCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3LCB0cmFja1BhdGggfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxvY2FsUG9pbnQgPSByZWxhdGVkVmlldy5wYXBlci5jbGllbnRUb0xvY2FsUG9pbnQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgdHJhY2tQb2ludCA9IFYudHJhbnNmb3JtUG9pbnQobG9jYWxQb2ludCwgdGhpcy5nZXRUcmFja01hdHJpeCgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiB0cmFja1BhdGguY2xvc2VzdFBvaW50TGVuZ3RoKHRyYWNrUG9pbnQpO1xuICAgIH0sXG5cbiAgICBjYW5TaG93QnV0dG9uKCkge1xuICAgICAgICAvLyBIYXMgYmVlbiB0aGUgcGFwZXIgZXZlbnRzIHVuZGVsZWdhdGVkPyBJZiBzbywgd2UgY2FuJ3Qgc2hvdyB0aGUgYnV0dG9uLlxuICAgICAgICAvLyBUT0RPOiBhZGQgYSBtZXRob2QgdG8gdGhlIHBhcGVyIHRvIGNoZWNrIGlmIHRoZSBldmVudHMgYXJlIGRlbGVnYXRlZC5cbiAgICAgICAgcmV0dXJuICQuZXZlbnQuaGFzKHRoaXMucGFwZXIuZWwpO1xuICAgIH0sXG5cbiAgICBzaG93QnV0dG9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXMuYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH0sXG5cbiAgICBoaWRlQnV0dG9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkTm9kZXMuYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB9LFxuXG4gICAgb25Nb3VzZW1vdmUoZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgdHJhY2tQYXRoIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXRyYWNrUGF0aCkgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMuZGlzdGFuY2UgPSB0aGlzLmdldFRyYWNrUmF0aW9Gcm9tRXZlbnQoZXZ0KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbigpO1xuICAgIH0sXG5cbiAgICBvbk1vdXNlZW50ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5TaG93QnV0dG9uKCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5zaG93QnV0dG9uKCk7XG4gICAgfSxcblxuICAgIG9uTW91c2VsZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5oaWRlQnV0dG9uKCk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/cellTools/helpers.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnchor: function() { return /* binding */ getAnchor; },\n/* harmony export */   getViewBBox: function() { return /* binding */ getViewBBox; },\n/* harmony export */   snapAnchor: function() { return /* binding */ snapAnchor; }\n/* harmony export */ });\n/* harmony import */ var _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../connectionStrategies/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\");\n\n\nfunction getViewBBox(view, useModelGeometry) {\n    const { model } = view;\n    if (useModelGeometry) return model.getBBox();\n    return (model.isLink()) ? view.getConnection().bbox() : view.getNodeUnrotatedBBox(view.el);\n}\n\nfunction getAnchor(coords, view, magnet) {\n    // take advantage of an existing logic inside of the\n    // pin relative connection strategy\n    var end = _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_0__.pinRelative.call(\n        this.paper,\n        {},\n        view,\n        magnet,\n        coords,\n        this.model\n    );\n    return end.anchor;\n}\n\nfunction snapAnchor(coords, view, magnet, type, relatedView, toolView) {\n    var snapRadius = toolView.options.snapRadius;\n    var isSource = (type === 'source');\n    var refIndex = (isSource ? 0 : -1);\n    var ref = this.model.vertex(refIndex) || this.getEndAnchor(isSource ? 'target' : 'source');\n    if (ref) {\n        if (Math.abs(ref.x - coords.x) < snapRadius) coords.x = ref.x;\n        if (Math.abs(ref.y - coords.y) < snapRadius) coords.y = ref.y;\n    }\n    return coords;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL2hlbHBlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEU7O0FBRW5FO0FBQ1AsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxjQUFjLHdFQUFnQztBQUM5QztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY2VsbFRvb2xzL2hlbHBlcnMubWpzPzU1ZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29ubmVjdGlvblN0cmF0ZWdpZXMgZnJvbSAnLi4vY29ubmVjdGlvblN0cmF0ZWdpZXMvaW5kZXgubWpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdCQm94KHZpZXcsIHVzZU1vZGVsR2VvbWV0cnkpIHtcbiAgICBjb25zdCB7IG1vZGVsIH0gPSB2aWV3O1xuICAgIGlmICh1c2VNb2RlbEdlb21ldHJ5KSByZXR1cm4gbW9kZWwuZ2V0QkJveCgpO1xuICAgIHJldHVybiAobW9kZWwuaXNMaW5rKCkpID8gdmlldy5nZXRDb25uZWN0aW9uKCkuYmJveCgpIDogdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveCh2aWV3LmVsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuY2hvcihjb29yZHMsIHZpZXcsIG1hZ25ldCkge1xuICAgIC8vIHRha2UgYWR2YW50YWdlIG9mIGFuIGV4aXN0aW5nIGxvZ2ljIGluc2lkZSBvZiB0aGVcbiAgICAvLyBwaW4gcmVsYXRpdmUgY29ubmVjdGlvbiBzdHJhdGVneVxuICAgIHZhciBlbmQgPSBjb25uZWN0aW9uU3RyYXRlZ2llcy5waW5SZWxhdGl2ZS5jYWxsKFxuICAgICAgICB0aGlzLnBhcGVyLFxuICAgICAgICB7fSxcbiAgICAgICAgdmlldyxcbiAgICAgICAgbWFnbmV0LFxuICAgICAgICBjb29yZHMsXG4gICAgICAgIHRoaXMubW9kZWxcbiAgICApO1xuICAgIHJldHVybiBlbmQuYW5jaG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc25hcEFuY2hvcihjb29yZHMsIHZpZXcsIG1hZ25ldCwgdHlwZSwgcmVsYXRlZFZpZXcsIHRvb2xWaWV3KSB7XG4gICAgdmFyIHNuYXBSYWRpdXMgPSB0b29sVmlldy5vcHRpb25zLnNuYXBSYWRpdXM7XG4gICAgdmFyIGlzU291cmNlID0gKHR5cGUgPT09ICdzb3VyY2UnKTtcbiAgICB2YXIgcmVmSW5kZXggPSAoaXNTb3VyY2UgPyAwIDogLTEpO1xuICAgIHZhciByZWYgPSB0aGlzLm1vZGVsLnZlcnRleChyZWZJbmRleCkgfHwgdGhpcy5nZXRFbmRBbmNob3IoaXNTb3VyY2UgPyAndGFyZ2V0JyA6ICdzb3VyY2UnKTtcbiAgICBpZiAocmVmKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhyZWYueCAtIGNvb3Jkcy54KSA8IHNuYXBSYWRpdXMpIGNvb3Jkcy54ID0gcmVmLng7XG4gICAgICAgIGlmIChNYXRoLmFicyhyZWYueSAtIGNvb3Jkcy55KSA8IHNuYXBSYWRpdXMpIGNvb3Jkcy55ID0gcmVmLnk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZHM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/config/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: function() { return /* binding */ config; }\n/* harmony export */ });\nconst config = {\n    // When set to `true` the cell selectors could be defined as CSS selectors.\n    // If not, only JSON Markup selectors are taken into account.\n    useCSSSelectors: false,\n    // The class name prefix config is for advanced use only.\n    // Be aware that if you change the prefix, the JointJS CSS will no longer function properly.\n    classNamePrefix: 'joint-',\n    defaultTheme: 'default',\n    // The maximum delay required for two consecutive touchend events to be interpreted\n    // as a double-tap.\n    doubleTapInterval: 300\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29uZmlnL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29uZmlnL2luZGV4Lm1qcz8wZTAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjb25maWcgPSB7XG4gICAgLy8gV2hlbiBzZXQgdG8gYHRydWVgIHRoZSBjZWxsIHNlbGVjdG9ycyBjb3VsZCBiZSBkZWZpbmVkIGFzIENTUyBzZWxlY3RvcnMuXG4gICAgLy8gSWYgbm90LCBvbmx5IEpTT04gTWFya3VwIHNlbGVjdG9ycyBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgIHVzZUNTU1NlbGVjdG9yczogZmFsc2UsXG4gICAgLy8gVGhlIGNsYXNzIG5hbWUgcHJlZml4IGNvbmZpZyBpcyBmb3IgYWR2YW5jZWQgdXNlIG9ubHkuXG4gICAgLy8gQmUgYXdhcmUgdGhhdCBpZiB5b3UgY2hhbmdlIHRoZSBwcmVmaXgsIHRoZSBKb2ludEpTIENTUyB3aWxsIG5vIGxvbmdlciBmdW5jdGlvbiBwcm9wZXJseS5cbiAgICBjbGFzc05hbWVQcmVmaXg6ICdqb2ludC0nLFxuICAgIGRlZmF1bHRUaGVtZTogJ2RlZmF1bHQnLFxuICAgIC8vIFRoZSBtYXhpbXVtIGRlbGF5IHJlcXVpcmVkIGZvciB0d28gY29uc2VjdXRpdmUgdG91Y2hlbmQgZXZlbnRzIHRvIGJlIGludGVycHJldGVkXG4gICAgLy8gYXMgYSBkb3VibGUtdGFwLlxuICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectionPoints/index.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectionPoints/index.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   anchor: function() { return /* binding */ anchor; },\n/* harmony export */   bbox: function() { return /* binding */ bbox; },\n/* harmony export */   boundary: function() { return /* binding */ boundary; },\n/* harmony export */   rectangle: function() { return /* binding */ rectangle; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\n\nfunction offsetPoint(p1, p2, offset) {\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(offset)) {\n        const { x, y } = offset;\n        if (isFinite(y)) {\n            const line =  new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(p2, p1);\n            const { start, end } = line.parallel(y);\n            p2 = start;\n            p1 = end;\n        }\n        offset = x;\n    }\n    if (!isFinite(offset)) return p1;\n    var length = p1.distance(p2);\n    if (offset === 0 && length > 0) return p1;\n    return p1.move(p2, -Math.min(offset, length - 1));\n}\n\nfunction stroke(magnet) {\n\n    var stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) return 0;\n    return parseFloat(stroke) || 0;\n}\n\nfunction alignLine(line, type, offset = 0) {\n    let coordinate, a, b, direction;\n    const { start, end } = line;\n    switch (type) {\n        case 'left':\n            coordinate = 'x';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'right':\n            coordinate = 'x';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        case 'top':\n            coordinate = 'y';\n            a = end;\n            b = start;\n            direction = -1;\n            break;\n        case 'bottom':\n            coordinate = 'y';\n            a = start;\n            b = end;\n            direction = 1;\n            break;\n        default:\n            return;\n    }\n    if (start[coordinate] < end[coordinate]) {\n        a[coordinate] = b[coordinate];\n    } else {\n        b[coordinate] = a[coordinate];\n    }\n    if (isFinite(offset)) {\n        a[coordinate] += direction * offset;\n        b[coordinate] += direction * offset;\n    }\n}\n\n// Connection Points\n\nfunction anchorConnectionPoint(line, _view, _magnet, opt) {\n    let { offset, alignOffset, align } = opt;\n    if (align) alignLine(line, align, alignOffset);\n    return offsetPoint(line.end, line.start, offset);\n}\n\nfunction bboxIntersection(line, view, magnet, opt) {\n\n    var bbox = view.getNodeBBox(magnet);\n    if (opt.stroke) bbox.inflate(stroke(magnet) / 2);\n    var intersections = line.intersect(bbox);\n    var cp = (intersections)\n        ? line.start.chooseClosest(intersections)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction rectangleIntersection(line, view, magnet, opt) {\n\n    var angle = view.model.angle();\n    if (angle === 0) {\n        return bboxIntersection(line, view, magnet, opt);\n    }\n\n    var bboxWORotation = view.getNodeUnrotatedBBox(magnet);\n    if (opt.stroke) bboxWORotation.inflate(stroke(magnet) / 2);\n    var center = bboxWORotation.center();\n    var lineWORotation = line.clone().rotate(center, angle);\n    var intersections = lineWORotation.setLength(1e6).intersect(bboxWORotation);\n    var cp = (intersections)\n        ? lineWORotation.start.chooseClosest(intersections).rotate(center, -angle)\n        : line.end;\n    return offsetPoint(cp, line.start, opt.offset);\n}\n\nfunction findShapeNode(magnet) {\n    if (!magnet) return null;\n    var node = magnet;\n    do {\n        var tagName = node.tagName;\n        if (typeof tagName !== 'string') return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        } else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        } else break;\n    } while (node);\n    return node;\n}\n\nvar BNDR_SUBDIVISIONS = 'segmentSubdivisons';\nvar BNDR_SHAPE_BBOX = 'shapeBBox';\n\nfunction boundaryIntersection(line, view, magnet, opt) {\n\n    var node, intersection;\n    var selector = opt.selector;\n    var anchor = line.end;\n\n    if (typeof selector === 'string') {\n        node = view.findNode(selector);\n    } else if (selector === false) {\n        node = magnet;\n    } else if (Array.isArray(selector)) {\n        node = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath(magnet, selector);\n    } else {\n        node = findShapeNode(magnet);\n    }\n\n    if (!_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isSVGGraphicsElement(node)) {\n        if (node === magnet || !_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isSVGGraphicsElement(magnet)) return anchor;\n        node = magnet;\n    }\n\n    var localShape = view.getNodeShape(node);\n    var magnetMatrix = view.getNodeMatrix(node);\n    var translateMatrix = view.getRootTranslateMatrix();\n    var rotateMatrix = view.getRootRotateMatrix();\n    var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n    var localMatrix = targetMatrix.inverse();\n    var localLine = _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].transformLine(line, localMatrix);\n    var localRef = localLine.start.clone();\n    var data = view.getNodeData(node);\n\n    if (opt.insideout === false) {\n        if (!data[BNDR_SHAPE_BBOX]) data[BNDR_SHAPE_BBOX] = localShape.bbox();\n        var localBBox = data[BNDR_SHAPE_BBOX];\n        if (localBBox.containsPoint(localRef)) return anchor;\n    }\n\n    // Caching segment subdivisions for paths\n    var pathOpt;\n    if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Path) {\n        var precision = opt.precision || 2;\n        if (!data[BNDR_SUBDIVISIONS]) data[BNDR_SUBDIVISIONS] = localShape.getSegmentSubdivisions({ precision: precision });\n        pathOpt = {\n            precision: precision,\n            segmentSubdivisions: data[BNDR_SUBDIVISIONS]\n        };\n    }\n\n    if (opt.extrapolate === true) localLine.setLength(1e6);\n\n    intersection = localLine.intersect(localShape, pathOpt);\n    if (intersection) {\n        // More than one intersection\n        if (_V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].isArray(intersection)) intersection = localRef.chooseClosest(intersection);\n    } else if (opt.sticky === true) {\n        // No intersection, find the closest point instead\n        if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) {\n            intersection = localShape.pointNearestToPoint(localRef);\n        } else if (localShape instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Ellipse) {\n            intersection = localShape.intersectionWithLineFromCenterToPoint(localRef);\n        } else {\n            intersection = localShape.closestPoint(localRef, pathOpt);\n        }\n    }\n\n    var cp = (intersection) ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].transformPoint(intersection, targetMatrix) : anchor;\n    var cpOffset = opt.offset || 0;\n    if (opt.stroke) cpOffset += stroke(node) / 2;\n\n    return offsetPoint(cp, line.start, cpOffset);\n}\n\nconst anchor = anchorConnectionPoint;\nconst bbox = bboxIntersection;\nconst rectangle = rectangleIntersection;\nconst boundary = boundaryIntersection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdGlvblBvaW50cy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDTDtBQUNXOztBQUUxQztBQUNBLFFBQVEsMERBQWtCO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsOEJBQThCLDhDQUFNO0FBQ3BDLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sZUFBZSxzREFBYztBQUM3QixNQUFNO0FBQ047QUFDQTs7QUFFQSxTQUFTLG9EQUFDO0FBQ1YsZ0NBQWdDLG9EQUFDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFDO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUFNO0FBQ3BDO0FBQ0Esb0dBQW9HLHNCQUFzQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQUM7QUFDYixNQUFNO0FBQ047QUFDQSxrQ0FBa0MsOENBQU07QUFDeEM7QUFDQSxVQUFVLCtCQUErQixpREFBUztBQUNsRDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG9EQUFDO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3Rpb25Qb2ludHMvaW5kZXgubWpzPzAwNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gb2Zmc2V0UG9pbnQocDEsIHAyLCBvZmZzZXQpIHtcbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBvZmZzZXQ7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh5KSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9ICBuZXcgZy5MaW5lKHAyLCBwMSk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGxpbmUucGFyYWxsZWwoeSk7XG4gICAgICAgICAgICBwMiA9IHN0YXJ0O1xuICAgICAgICAgICAgcDEgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0geDtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZShvZmZzZXQpKSByZXR1cm4gcDE7XG4gICAgdmFyIGxlbmd0aCA9IHAxLmRpc3RhbmNlKHAyKTtcbiAgICBpZiAob2Zmc2V0ID09PSAwICYmIGxlbmd0aCA+IDApIHJldHVybiBwMTtcbiAgICByZXR1cm4gcDEubW92ZShwMiwgLU1hdGgubWluKG9mZnNldCwgbGVuZ3RoIC0gMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJva2UobWFnbmV0KSB7XG5cbiAgICB2YXIgc3Ryb2tlID0gbWFnbmV0LmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyk7XG4gICAgaWYgKHN0cm9rZSA9PT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3Ryb2tlKSB8fCAwO1xufVxuXG5mdW5jdGlvbiBhbGlnbkxpbmUobGluZSwgdHlwZSwgb2Zmc2V0ID0gMCkge1xuICAgIGxldCBjb29yZGluYXRlLCBhLCBiLCBkaXJlY3Rpb247XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBsaW5lO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneCc7XG4gICAgICAgICAgICBhID0gZW5kO1xuICAgICAgICAgICAgYiA9IHN0YXJ0O1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd4JztcbiAgICAgICAgICAgIGEgPSBzdGFydDtcbiAgICAgICAgICAgIGIgPSBlbmQ7XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3knO1xuICAgICAgICAgICAgYSA9IGVuZDtcbiAgICAgICAgICAgIGIgPSBzdGFydDtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBjb29yZGluYXRlID0gJ3knO1xuICAgICAgICAgICAgYSA9IHN0YXJ0O1xuICAgICAgICAgICAgYiA9IGVuZDtcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YXJ0W2Nvb3JkaW5hdGVdIDwgZW5kW2Nvb3JkaW5hdGVdKSB7XG4gICAgICAgIGFbY29vcmRpbmF0ZV0gPSBiW2Nvb3JkaW5hdGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJbY29vcmRpbmF0ZV0gPSBhW2Nvb3JkaW5hdGVdO1xuICAgIH1cbiAgICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgICAgICBhW2Nvb3JkaW5hdGVdICs9IGRpcmVjdGlvbiAqIG9mZnNldDtcbiAgICAgICAgYltjb29yZGluYXRlXSArPSBkaXJlY3Rpb24gKiBvZmZzZXQ7XG4gICAgfVxufVxuXG4vLyBDb25uZWN0aW9uIFBvaW50c1xuXG5mdW5jdGlvbiBhbmNob3JDb25uZWN0aW9uUG9pbnQobGluZSwgX3ZpZXcsIF9tYWduZXQsIG9wdCkge1xuICAgIGxldCB7IG9mZnNldCwgYWxpZ25PZmZzZXQsIGFsaWduIH0gPSBvcHQ7XG4gICAgaWYgKGFsaWduKSBhbGlnbkxpbmUobGluZSwgYWxpZ24sIGFsaWduT2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0UG9pbnQobGluZS5lbmQsIGxpbmUuc3RhcnQsIG9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGJib3hJbnRlcnNlY3Rpb24obGluZSwgdmlldywgbWFnbmV0LCBvcHQpIHtcblxuICAgIHZhciBiYm94ID0gdmlldy5nZXROb2RlQkJveChtYWduZXQpO1xuICAgIGlmIChvcHQuc3Ryb2tlKSBiYm94LmluZmxhdGUoc3Ryb2tlKG1hZ25ldCkgLyAyKTtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IGxpbmUuaW50ZXJzZWN0KGJib3gpO1xuICAgIHZhciBjcCA9IChpbnRlcnNlY3Rpb25zKVxuICAgICAgICA/IGxpbmUuc3RhcnQuY2hvb3NlQ2xvc2VzdChpbnRlcnNlY3Rpb25zKVxuICAgICAgICA6IGxpbmUuZW5kO1xuICAgIHJldHVybiBvZmZzZXRQb2ludChjcCwgbGluZS5zdGFydCwgb3B0Lm9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZUludGVyc2VjdGlvbihsaW5lLCB2aWV3LCBtYWduZXQsIG9wdCkge1xuXG4gICAgdmFyIGFuZ2xlID0gdmlldy5tb2RlbC5hbmdsZSgpO1xuICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmJveEludGVyc2VjdGlvbihsaW5lLCB2aWV3LCBtYWduZXQsIG9wdCk7XG4gICAgfVxuXG4gICAgdmFyIGJib3hXT1JvdGF0aW9uID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgIGlmIChvcHQuc3Ryb2tlKSBiYm94V09Sb3RhdGlvbi5pbmZsYXRlKHN0cm9rZShtYWduZXQpIC8gMik7XG4gICAgdmFyIGNlbnRlciA9IGJib3hXT1JvdGF0aW9uLmNlbnRlcigpO1xuICAgIHZhciBsaW5lV09Sb3RhdGlvbiA9IGxpbmUuY2xvbmUoKS5yb3RhdGUoY2VudGVyLCBhbmdsZSk7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBsaW5lV09Sb3RhdGlvbi5zZXRMZW5ndGgoMWU2KS5pbnRlcnNlY3QoYmJveFdPUm90YXRpb24pO1xuICAgIHZhciBjcCA9IChpbnRlcnNlY3Rpb25zKVxuICAgICAgICA/IGxpbmVXT1JvdGF0aW9uLnN0YXJ0LmNob29zZUNsb3Nlc3QoaW50ZXJzZWN0aW9ucykucm90YXRlKGNlbnRlciwgLWFuZ2xlKVxuICAgICAgICA6IGxpbmUuZW5kO1xuICAgIHJldHVybiBvZmZzZXRQb2ludChjcCwgbGluZS5zdGFydCwgb3B0Lm9mZnNldCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRTaGFwZU5vZGUobWFnbmV0KSB7XG4gICAgaWYgKCFtYWduZXQpIHJldHVybiBudWxsO1xuICAgIHZhciBub2RlID0gbWFnbmV0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBub2RlLnRhZ05hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPT0gJ3N0cmluZycpIHJldHVybiBudWxsO1xuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ0cnKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSAnVElUTEUnKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSBicmVhaztcbiAgICB9IHdoaWxlIChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxudmFyIEJORFJfU1VCRElWSVNJT05TID0gJ3NlZ21lbnRTdWJkaXZpc29ucyc7XG52YXIgQk5EUl9TSEFQRV9CQk9YID0gJ3NoYXBlQkJveCc7XG5cbmZ1bmN0aW9uIGJvdW5kYXJ5SW50ZXJzZWN0aW9uKGxpbmUsIHZpZXcsIG1hZ25ldCwgb3B0KSB7XG5cbiAgICB2YXIgbm9kZSwgaW50ZXJzZWN0aW9uO1xuICAgIHZhciBzZWxlY3RvciA9IG9wdC5zZWxlY3RvcjtcbiAgICB2YXIgYW5jaG9yID0gbGluZS5lbmQ7XG5cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2RlID0gdmlldy5maW5kTm9kZShzZWxlY3Rvcik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3RvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZSA9IG1hZ25ldDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpKSB7XG4gICAgICAgIG5vZGUgPSB1dGlsLmdldEJ5UGF0aChtYWduZXQsIHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gZmluZFNoYXBlTm9kZShtYWduZXQpO1xuICAgIH1cblxuICAgIGlmICghVi5pc1NWR0dyYXBoaWNzRWxlbWVudChub2RlKSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gbWFnbmV0IHx8ICFWLmlzU1ZHR3JhcGhpY3NFbGVtZW50KG1hZ25ldCkpIHJldHVybiBhbmNob3I7XG4gICAgICAgIG5vZGUgPSBtYWduZXQ7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsU2hhcGUgPSB2aWV3LmdldE5vZGVTaGFwZShub2RlKTtcbiAgICB2YXIgbWFnbmV0TWF0cml4ID0gdmlldy5nZXROb2RlTWF0cml4KG5vZGUpO1xuICAgIHZhciB0cmFuc2xhdGVNYXRyaXggPSB2aWV3LmdldFJvb3RUcmFuc2xhdGVNYXRyaXgoKTtcbiAgICB2YXIgcm90YXRlTWF0cml4ID0gdmlldy5nZXRSb290Um90YXRlTWF0cml4KCk7XG4gICAgdmFyIHRhcmdldE1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeC5tdWx0aXBseShyb3RhdGVNYXRyaXgpLm11bHRpcGx5KG1hZ25ldE1hdHJpeCk7XG4gICAgdmFyIGxvY2FsTWF0cml4ID0gdGFyZ2V0TWF0cml4LmludmVyc2UoKTtcbiAgICB2YXIgbG9jYWxMaW5lID0gVi50cmFuc2Zvcm1MaW5lKGxpbmUsIGxvY2FsTWF0cml4KTtcbiAgICB2YXIgbG9jYWxSZWYgPSBsb2NhbExpbmUuc3RhcnQuY2xvbmUoKTtcbiAgICB2YXIgZGF0YSA9IHZpZXcuZ2V0Tm9kZURhdGEobm9kZSk7XG5cbiAgICBpZiAob3B0Lmluc2lkZW91dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFkYXRhW0JORFJfU0hBUEVfQkJPWF0pIGRhdGFbQk5EUl9TSEFQRV9CQk9YXSA9IGxvY2FsU2hhcGUuYmJveCgpO1xuICAgICAgICB2YXIgbG9jYWxCQm94ID0gZGF0YVtCTkRSX1NIQVBFX0JCT1hdO1xuICAgICAgICBpZiAobG9jYWxCQm94LmNvbnRhaW5zUG9pbnQobG9jYWxSZWYpKSByZXR1cm4gYW5jaG9yO1xuICAgIH1cblxuICAgIC8vIENhY2hpbmcgc2VnbWVudCBzdWJkaXZpc2lvbnMgZm9yIHBhdGhzXG4gICAgdmFyIHBhdGhPcHQ7XG4gICAgaWYgKGxvY2FsU2hhcGUgaW5zdGFuY2VvZiBnLlBhdGgpIHtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IG9wdC5wcmVjaXNpb24gfHwgMjtcbiAgICAgICAgaWYgKCFkYXRhW0JORFJfU1VCRElWSVNJT05TXSkgZGF0YVtCTkRSX1NVQkRJVklTSU9OU10gPSBsb2NhbFNoYXBlLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KTtcbiAgICAgICAgcGF0aE9wdCA9IHtcbiAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgc2VnbWVudFN1YmRpdmlzaW9uczogZGF0YVtCTkRSX1NVQkRJVklTSU9OU11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0LmV4dHJhcG9sYXRlID09PSB0cnVlKSBsb2NhbExpbmUuc2V0TGVuZ3RoKDFlNik7XG5cbiAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbExpbmUuaW50ZXJzZWN0KGxvY2FsU2hhcGUsIHBhdGhPcHQpO1xuICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgLy8gTW9yZSB0aGFuIG9uZSBpbnRlcnNlY3Rpb25cbiAgICAgICAgaWYgKFYuaXNBcnJheShpbnRlcnNlY3Rpb24pKSBpbnRlcnNlY3Rpb24gPSBsb2NhbFJlZi5jaG9vc2VDbG9zZXN0KGludGVyc2VjdGlvbik7XG4gICAgfSBlbHNlIGlmIChvcHQuc3RpY2t5ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvbiwgZmluZCB0aGUgY2xvc2VzdCBwb2ludCBpbnN0ZWFkXG4gICAgICAgIGlmIChsb2NhbFNoYXBlIGluc3RhbmNlb2YgZy5SZWN0KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbFNoYXBlLnBvaW50TmVhcmVzdFRvUG9pbnQobG9jYWxSZWYpO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsU2hhcGUgaW5zdGFuY2VvZiBnLkVsbGlwc2UpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbiA9IGxvY2FsU2hhcGUuaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludChsb2NhbFJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBsb2NhbFNoYXBlLmNsb3Nlc3RQb2ludChsb2NhbFJlZiwgcGF0aE9wdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3AgPSAoaW50ZXJzZWN0aW9uKSA/IFYudHJhbnNmb3JtUG9pbnQoaW50ZXJzZWN0aW9uLCB0YXJnZXRNYXRyaXgpIDogYW5jaG9yO1xuICAgIHZhciBjcE9mZnNldCA9IG9wdC5vZmZzZXQgfHwgMDtcbiAgICBpZiAob3B0LnN0cm9rZSkgY3BPZmZzZXQgKz0gc3Ryb2tlKG5vZGUpIC8gMjtcblxuICAgIHJldHVybiBvZmZzZXRQb2ludChjcCwgbGluZS5zdGFydCwgY3BPZmZzZXQpO1xufVxuXG5leHBvcnQgY29uc3QgYW5jaG9yID0gYW5jaG9yQ29ubmVjdGlvblBvaW50O1xuZXhwb3J0IGNvbnN0IGJib3ggPSBiYm94SW50ZXJzZWN0aW9uO1xuZXhwb3J0IGNvbnN0IHJlY3RhbmdsZSA9IHJlY3RhbmdsZUludGVyc2VjdGlvbjtcbmV4cG9ydCBjb25zdCBib3VuZGFyeSA9IGJvdW5kYXJ5SW50ZXJzZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectionPoints/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectionStrategies/index.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectionStrategies/index.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pinAbsolute: function() { return /* binding */ pinAbsolute; },\n/* harmony export */   pinRelative: function() { return /* binding */ pinRelative; },\n/* harmony export */   useDefaults: function() { return /* binding */ useDefaults; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\nfunction abs2rel(absolute, max) {\n\n    if (max === 0) return '0%';\n    // round to 3 decimal places\n    const dp = 1000;\n    const relative = Math.round(absolute / max * 100 * dp) / dp;\n    return `${relative}%`;\n}\n\nfunction pin(relative) {\n\n    return function(end, view, magnet, coords) {\n        var fn = (view.isNodeConnection(magnet)) ? pinnedLinkEnd : pinnedElementEnd;\n        return fn(relative, end, view, magnet, coords);\n    };\n}\n\nfunction pinnedElementEnd(relative, end, view, magnet, coords) {\n\n    var angle = view.model.angle();\n    var bbox = view.getNodeUnrotatedBBox(magnet);\n    var origin = view.model.getBBox().center();\n    coords.rotate(origin, angle);\n    var dx = coords.x - bbox.x;\n    var dy = coords.y - bbox.y;\n\n    if (relative) {\n        dx = abs2rel(dx, bbox.width);\n        dy = abs2rel(dy, bbox.height);\n    }\n\n    end.anchor = {\n        name: 'topLeft',\n        args: {\n            dx: dx,\n            dy: dy,\n            rotate: true\n        }\n    };\n\n    return end;\n}\n\nfunction pinnedLinkEnd(relative, end, view, _magnet, coords) {\n\n    var connection = view.getConnection();\n    if (!connection) return end;\n    var length = connection.closestPointLength(coords);\n    if (relative) {\n        var totalLength = connection.length();\n        end.anchor = {\n            name: 'connectionRatio',\n            args: {\n                ratio: length / totalLength\n            }\n        };\n    } else {\n        end.anchor = {\n            name: 'connectionLength',\n            args: {\n                length: length\n            }\n        };\n    }\n    return end;\n}\n\nconst useDefaults = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;\nconst pinAbsolute = pin(false);\nconst pinRelative = pin(true);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdGlvblN0cmF0ZWdpZXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxvQkFBb0IsaURBQVM7QUFDN0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3Rpb25TdHJhdGVnaWVzL2luZGV4Lm1qcz8xNTY0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG5mdW5jdGlvbiBhYnMycmVsKGFic29sdXRlLCBtYXgpIHtcblxuICAgIGlmIChtYXggPT09IDApIHJldHVybiAnMCUnO1xuICAgIC8vIHJvdW5kIHRvIDMgZGVjaW1hbCBwbGFjZXNcbiAgICBjb25zdCBkcCA9IDEwMDA7XG4gICAgY29uc3QgcmVsYXRpdmUgPSBNYXRoLnJvdW5kKGFic29sdXRlIC8gbWF4ICogMTAwICogZHApIC8gZHA7XG4gICAgcmV0dXJuIGAke3JlbGF0aXZlfSVgO1xufVxuXG5mdW5jdGlvbiBwaW4ocmVsYXRpdmUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbihlbmQsIHZpZXcsIG1hZ25ldCwgY29vcmRzKSB7XG4gICAgICAgIHZhciBmbiA9ICh2aWV3LmlzTm9kZUNvbm5lY3Rpb24obWFnbmV0KSkgPyBwaW5uZWRMaW5rRW5kIDogcGlubmVkRWxlbWVudEVuZDtcbiAgICAgICAgcmV0dXJuIGZuKHJlbGF0aXZlLCBlbmQsIHZpZXcsIG1hZ25ldCwgY29vcmRzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwaW5uZWRFbGVtZW50RW5kKHJlbGF0aXZlLCBlbmQsIHZpZXcsIG1hZ25ldCwgY29vcmRzKSB7XG5cbiAgICB2YXIgYW5nbGUgPSB2aWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgdmFyIGJib3ggPSB2aWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KG1hZ25ldCk7XG4gICAgdmFyIG9yaWdpbiA9IHZpZXcubW9kZWwuZ2V0QkJveCgpLmNlbnRlcigpO1xuICAgIGNvb3Jkcy5yb3RhdGUob3JpZ2luLCBhbmdsZSk7XG4gICAgdmFyIGR4ID0gY29vcmRzLnggLSBiYm94Lng7XG4gICAgdmFyIGR5ID0gY29vcmRzLnkgLSBiYm94Lnk7XG5cbiAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgZHggPSBhYnMycmVsKGR4LCBiYm94LndpZHRoKTtcbiAgICAgICAgZHkgPSBhYnMycmVsKGR5LCBiYm94LmhlaWdodCk7XG4gICAgfVxuXG4gICAgZW5kLmFuY2hvciA9IHtcbiAgICAgICAgbmFtZTogJ3RvcExlZnQnLFxuICAgICAgICBhcmdzOiB7XG4gICAgICAgICAgICBkeDogZHgsXG4gICAgICAgICAgICBkeTogZHksXG4gICAgICAgICAgICByb3RhdGU6IHRydWVcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBwaW5uZWRMaW5rRW5kKHJlbGF0aXZlLCBlbmQsIHZpZXcsIF9tYWduZXQsIGNvb3Jkcykge1xuXG4gICAgdmFyIGNvbm5lY3Rpb24gPSB2aWV3LmdldENvbm5lY3Rpb24oKTtcbiAgICBpZiAoIWNvbm5lY3Rpb24pIHJldHVybiBlbmQ7XG4gICAgdmFyIGxlbmd0aCA9IGNvbm5lY3Rpb24uY2xvc2VzdFBvaW50TGVuZ3RoKGNvb3Jkcyk7XG4gICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgIHZhciB0b3RhbExlbmd0aCA9IGNvbm5lY3Rpb24ubGVuZ3RoKCk7XG4gICAgICAgIGVuZC5hbmNob3IgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdGlvblJhdGlvJyxcbiAgICAgICAgICAgIGFyZ3M6IHtcbiAgICAgICAgICAgICAgICByYXRpbzogbGVuZ3RoIC8gdG90YWxMZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmQuYW5jaG9yID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rpb25MZW5ndGgnLFxuICAgICAgICAgICAgYXJnczoge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5cbmV4cG9ydCBjb25zdCB1c2VEZWZhdWx0cyA9IHV0aWwubm9vcDtcbmV4cG9ydCBjb25zdCBwaW5BYnNvbHV0ZSA9IHBpbihmYWxzZSk7XG5leHBvcnQgY29uc3QgcGluUmVsYXRpdmUgPSBwaW4odHJ1ZSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/curve.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/curve.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curve: function() { return /* binding */ curve; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs\");\n\n\nconst Directions = {\n    AUTO: 'auto',\n    HORIZONTAL: 'horizontal',\n    VERTICAL: 'vertical',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst TangentDirections = {\n    UP: 'up',\n    DOWN: 'down',\n    LEFT: 'left',\n    RIGHT: 'right',\n    AUTO: 'auto',\n    CLOSEST_POINT: 'closest-point',\n    OUTWARDS: 'outwards'\n};\n\nconst curve = function(sourcePoint, targetPoint, route = [], opt = {}, linkView) {\n    const raw = Boolean(opt.raw);\n    // distanceCoefficient - a coefficient of the tangent vector length relative to the distance between points.\n    // angleTangentCoefficient - a coefficient of the end tangents length in the case of angles larger than 45 degrees.\n    // tension - a Catmull-Rom curve tension parameter.\n    // sourceTangent - a tangent vector along the curve at the sourcePoint.\n    // sourceDirection - a unit direction vector along the curve at the sourcePoint.\n    // targetTangent - a tangent vector along the curve at the targetPoint.\n    // targetDirection - a unit direction vector along the curve at the targetPoint.\n    // precision - a rounding precision for path values.\n    const { direction = Directions.AUTO, precision = 3 } = opt;\n    const options = {\n        coeff: opt.distanceCoefficient || 0.6,\n        angleTangentCoefficient: opt.angleTangentCoefficient || 80,\n        tau: opt.tension || 0.5,\n        sourceTangent: opt.sourceTangent ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.sourceTangent) : null,\n        targetTangent: opt.targetTangent ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.targetTangent) : null,\n        rotate: Boolean(opt.rotate)\n    };\n    if (typeof opt.sourceDirection === 'string')\n        options.sourceDirection = opt.sourceDirection;\n    else if (typeof opt.sourceDirection === 'number')\n        options.sourceDirection = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0).rotate(null, opt.sourceDirection);\n    else\n        options.sourceDirection = opt.sourceDirection ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.sourceDirection).normalize() : null;\n\n    if (typeof opt.targetDirection === 'string')\n        options.targetDirection = opt.targetDirection;\n    else if (typeof opt.targetDirection === 'number')\n        options.targetDirection = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0).rotate(null, opt.targetDirection);\n    else\n        options.targetDirection = opt.targetDirection ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(opt.targetDirection).normalize() : null;\n\n    const completeRoute = [sourcePoint, ...route, targetPoint].map(p => new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p));\n\n    // The calculation of a sourceTangent\n    let sourceTangent;\n    if (options.sourceTangent) {\n        sourceTangent = options.sourceTangent;\n    } else {\n        const sourceDirection = getSourceTangentDirection(linkView, completeRoute, direction, options);\n        const tangentLength = completeRoute[0].distance(completeRoute[1]) * options.coeff;\n        const pointsVector = completeRoute[1].difference(completeRoute[0]).normalize();\n        const angle = angleBetweenVectors(sourceDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            sourceTangent = sourceDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            sourceTangent = sourceDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    // The calculation of a targetTangent\n    let targetTangent;\n    if (options.targetTangent) {\n        targetTangent = options.targetTangent;\n    } else {\n        const targetDirection = getTargetTangentDirection(linkView, completeRoute, direction, options);\n        const last = completeRoute.length - 1;\n        const tangentLength = completeRoute[last - 1].distance(completeRoute[last]) * options.coeff;\n        const pointsVector = completeRoute[last - 1].difference(completeRoute[last]).normalize();\n        const angle = angleBetweenVectors(targetDirection, pointsVector);\n        if (angle > Math.PI / 4) {\n            const updatedLength = tangentLength + (angle - Math.PI / 4) * options.angleTangentCoefficient;\n            targetTangent = targetDirection.clone().scale(updatedLength, updatedLength);\n        } else {\n            targetTangent = targetDirection.clone().scale(tangentLength, tangentLength);\n        }\n    }\n\n    const catmullRomCurves = createCatmullRomCurves(completeRoute, sourceTangent, targetTangent, options);\n    const bezierCurves = catmullRomCurves.map(curve => catmullRomToBezier(curve, options));\n    const path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(bezierCurves).round(precision);\n\n    return (raw) ? path : path.serialize();\n};\ncurve.Directions = Directions;\ncurve.TangentDirections = TangentDirections;\n\nfunction getHorizontalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.x > route[1].x)\n            sourceSide = 'right';\n        else\n            sourceSide = 'left';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getHorizontalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.x > route[route.length - 2].x)\n            targetSide = 'left';\n        else\n            targetSide = 'right';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n        case 'right':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        if (sourceBBox.y > route[1].y)\n            sourceSide = 'bottom';\n        else\n            sourceSide = 'top';\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getVerticalTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        if (targetBBox.y > route[route.length - 2].y)\n            targetSide = 'top';\n        else\n            targetSide = 'bottom';\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n        default:\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n\n    let sourceSide;\n    let rotation;\n    if (!linkView.sourceView) {\n        sourceSide = sourceBBox.sideNearestToPoint(route[1]);\n    } else {\n        rotation = linkView.sourceView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.sourceView.getNodeUnrotatedBBox(linkView.sourceView.el);\n            const sourcePoint = route[0].clone();\n            sourcePoint.rotate(sourceBBox.center(), rotation);\n            sourceSide = unrotatedBBox.sideNearestToPoint(sourcePoint);\n        } else {\n            sourceSide = sourceBBox.sideNearestToPoint(route[0]);\n        }\n    }\n\n    let direction;\n    switch (sourceSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n        case 'right':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getAutoTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n\n    let targetSide;\n    let rotation;\n    if (!linkView.targetView) {\n        targetSide = targetBBox.sideNearestToPoint(route[route.length - 2]);\n    } else {\n        rotation = linkView.targetView.model.angle();\n        if (options.rotate && rotation) {\n            const unrotatedBBox = linkView.targetView.getNodeUnrotatedBBox(linkView.targetView.el);\n            const targetPoint = route[route.length - 1].clone();\n            targetPoint.rotate(targetBBox.center(), rotation);\n            targetSide = unrotatedBBox.sideNearestToPoint(targetPoint);\n        } else {\n            targetSide = targetBBox.sideNearestToPoint(route[route.length - 1]);\n        }\n    }\n\n    let direction;\n    switch (targetSide) {\n        case 'top':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            break;\n        case 'bottom':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            break;\n        case 'right':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            break;\n        case 'left':\n            direction = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            break;\n    }\n\n    if (options.rotate && rotation) {\n        direction.rotate(null, -rotation);\n    }\n\n    return direction;\n}\n\nfunction getClosestPointSourceDirection(linkView, route, options) {\n    return route[1].difference(route[0]).normalize();\n}\n\nfunction getClosestPointTargetDirection(linkView, route, options) {\n    const last = route.length - 1;\n    return route[last - 1].difference(route[last]).normalize();\n}\n\nfunction getOutwardsSourceDirection(linkView, route, options) {\n    const { sourceBBox } = linkView;\n    const sourceCenter = sourceBBox.center();\n    return route[0].difference(sourceCenter).normalize();\n}\n\nfunction getOutwardsTargetDirection(linkView, route, options) {\n    const { targetBBox } = linkView;\n    const targetCenter = targetBBox.center();\n    return route[route.length - 1].difference(targetCenter).normalize();\n}\n\nfunction getSourceTangentDirection(linkView, route, direction, options) {\n    if (options.sourceDirection) {\n        switch (options.sourceDirection) {\n            case TangentDirections.UP:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            case TangentDirections.DOWN:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            case TangentDirections.LEFT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoSourceDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointSourceDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsSourceDirection(linkView, route, options);\n            default:\n                return options.sourceDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalSourceDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalSourceDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointSourceDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsSourceDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoSourceDirection(linkView, route, options);\n    }\n}\n\nfunction getTargetTangentDirection(linkView, route, direction, options) {\n    if (options.targetDirection) {\n        switch (options.targetDirection) {\n            case TangentDirections.UP:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, -1);\n            case TangentDirections.DOWN:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(0, 1);\n            case TangentDirections.LEFT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(-1, 0);\n            case TangentDirections.RIGHT:\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n            case TangentDirections.AUTO:\n                return getAutoTargetDirection(linkView, route, options);\n            case TangentDirections.CLOSEST_POINT:\n                return getClosestPointTargetDirection(linkView, route, options);\n            case TangentDirections.OUTWARDS:\n                return getOutwardsTargetDirection(linkView, route, options);\n            default:\n                return options.targetDirection;\n        }\n    }\n\n    switch (direction) {\n        case Directions.HORIZONTAL:\n            return getHorizontalTargetDirection(linkView, route, options);\n        case Directions.VERTICAL:\n            return getVerticalTargetDirection(linkView, route, options);\n        case Directions.CLOSEST_POINT:\n            return getClosestPointTargetDirection(linkView, route, options);\n        case Directions.OUTWARDS:\n            return getOutwardsTargetDirection(linkView, route, options);\n        case Directions.AUTO:\n        default:\n            return getAutoTargetDirection(linkView, route, options);\n    }\n}\n\nfunction rotateVector(vector, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    const x = cos * vector.x - sin * vector.y;\n    const y = sin * vector.x + cos * vector.y;\n    vector.x = x;\n    vector.y = y;\n}\n\nfunction angleBetweenVectors(v1, v2) {\n    let cos = v1.dot(v2) / (v1.magnitude() * v2.magnitude());\n    if (cos < -1) cos = -1;\n    if (cos > 1) cos = 1;\n    return Math.acos(cos);\n}\n\nfunction determinant(v1, v2) {\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\nfunction createCatmullRomCurves(points, sourceTangent, targetTangent, options) {\n    const { tau, coeff } = options;\n    const distances = [];\n    const tangents = [];\n    const catmullRomCurves = [];\n    const n = points.length - 1;\n\n    for (let i = 0; i < n; i++) {\n        distances[i] = points[i].distance(points[i + 1]);\n    }\n\n    tangents[0] = sourceTangent;\n    tangents[n] = targetTangent;\n\n    // The calculation of tangents of vertices\n    for (let i = 1; i < n; i++) {\n        let tpPrev;\n        let tpNext;\n        if (i === 1) {\n            tpPrev = points[i - 1].clone().offset(tangents[i - 1].x, tangents[i - 1].y);\n        } else {\n            tpPrev = points[i - 1].clone();\n        }\n        if (i === n - 1) {\n            tpNext = points[i + 1].clone().offset(tangents[i + 1].x, tangents[i + 1].y);\n        } else {\n            tpNext = points[i + 1].clone();\n        }\n        const v1 = tpPrev.difference(points[i]).normalize();\n        const v2 = tpNext.difference(points[i]).normalize();\n        const vAngle = angleBetweenVectors(v1, v2);\n\n        let rot = (Math.PI - vAngle) / 2;\n        let t;\n        const vectorDeterminant = determinant(v1, v2);\n        let pointsDeterminant;\n        pointsDeterminant = determinant(points[i].difference(points[i + 1]), points[i].difference(points[i - 1]));\n        if (vectorDeterminant < 0) {\n            rot = -rot;\n        }\n        if ((vAngle < Math.PI / 2) && ((rot < 0 && pointsDeterminant < 0) || (rot > 0 && pointsDeterminant > 0))) {\n            rot = rot - Math.PI;\n        }\n        t = v2.clone();\n        rotateVector(t, rot);\n\n        const t1 = t.clone();\n        const t2 = t.clone();\n        const scaleFactor1 = distances[i - 1] * coeff;\n        const scaleFactor2 = distances[i] * coeff;\n        t1.scale(scaleFactor1, scaleFactor1);\n        t2.scale(scaleFactor2, scaleFactor2);\n\n        tangents[i] = [t1, t2];\n    }\n\n    // The building of a Catmull-Rom curve based of tangents of points\n    for (let i = 0; i < n; i++) {\n        let p0;\n        let p3;\n        if (i === 0) {\n            p0 = points[i + 1].difference(tangents[i].x / tau, tangents[i].y / tau);\n        } else {\n            p0 = points[i + 1].difference(tangents[i][1].x / tau, tangents[i][1].y / tau);\n        }\n        if (i === n - 1) {\n            p3 = points[i].clone().offset(tangents[i + 1].x / tau, tangents[i + 1].y / tau);\n        } else {\n            p3 = points[i].difference(tangents[i + 1][0].x / tau, tangents[i + 1][0].y / tau);\n        }\n\n        catmullRomCurves[i] = [p0, points[i], points[i + 1], p3];\n    }\n    return catmullRomCurves;\n}\n\n// The function to convert Catmull-Rom curve to Bezier curve using the tension (tau)\nfunction catmullRomToBezier(points, options) {\n    const { tau } = options;\n\n    const bcp1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n    bcp1.x = points[1].x + (points[2].x - points[0].x) / (6 * tau);\n    bcp1.y = points[1].y + (points[2].y - points[0].y) / (6 * tau);\n\n    const bcp2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n    bcp2.x = points[2].x + (points[3].x - points[1].x) / (6 * tau);\n    bcp2.y = points[2].y + (points[3].y - points[1].y) / (6 * tau);\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Curve(\n        points[1],\n        bcp1,\n        bcp2,\n        points[2]\n    );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9jdXJ2ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHFFQUFxRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywrQ0FBSztBQUNwRCwrQ0FBK0MsK0NBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQ0FBSztBQUMzQztBQUNBLDREQUE0RCwrQ0FBSzs7QUFFakU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtDQUFLO0FBQzNDO0FBQ0EsNERBQTRELCtDQUFLOztBQUVqRSw0RUFBNEUsK0NBQUs7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFJOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksYUFBYTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTs7QUFFbEIscUJBQXFCLCtDQUFLO0FBQzFCO0FBQ0E7O0FBRUEscUJBQXFCLCtDQUFLO0FBQzFCO0FBQ0E7QUFDQSxlQUFlLCtDQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvY3VydmUubWpzPzY0YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0aCwgUG9pbnQsIEN1cnZlIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5jb25zdCBEaXJlY3Rpb25zID0ge1xuICAgIEFVVE86ICdhdXRvJyxcbiAgICBIT1JJWk9OVEFMOiAnaG9yaXpvbnRhbCcsXG4gICAgVkVSVElDQUw6ICd2ZXJ0aWNhbCcsXG4gICAgQ0xPU0VTVF9QT0lOVDogJ2Nsb3Nlc3QtcG9pbnQnLFxuICAgIE9VVFdBUkRTOiAnb3V0d2FyZHMnXG59O1xuXG5jb25zdCBUYW5nZW50RGlyZWN0aW9ucyA9IHtcbiAgICBVUDogJ3VwJyxcbiAgICBET1dOOiAnZG93bicsXG4gICAgTEVGVDogJ2xlZnQnLFxuICAgIFJJR0hUOiAncmlnaHQnLFxuICAgIEFVVE86ICdhdXRvJyxcbiAgICBDTE9TRVNUX1BPSU5UOiAnY2xvc2VzdC1wb2ludCcsXG4gICAgT1VUV0FSRFM6ICdvdXR3YXJkcydcbn07XG5cbmV4cG9ydCBjb25zdCBjdXJ2ZSA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUgPSBbXSwgb3B0ID0ge30sIGxpbmtWaWV3KSB7XG4gICAgY29uc3QgcmF3ID0gQm9vbGVhbihvcHQucmF3KTtcbiAgICAvLyBkaXN0YW5jZUNvZWZmaWNpZW50IC0gYSBjb2VmZmljaWVudCBvZiB0aGUgdGFuZ2VudCB2ZWN0b3IgbGVuZ3RoIHJlbGF0aXZlIHRvIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cy5cbiAgICAvLyBhbmdsZVRhbmdlbnRDb2VmZmljaWVudCAtIGEgY29lZmZpY2llbnQgb2YgdGhlIGVuZCB0YW5nZW50cyBsZW5ndGggaW4gdGhlIGNhc2Ugb2YgYW5nbGVzIGxhcmdlciB0aGFuIDQ1IGRlZ3JlZXMuXG4gICAgLy8gdGVuc2lvbiAtIGEgQ2F0bXVsbC1Sb20gY3VydmUgdGVuc2lvbiBwYXJhbWV0ZXIuXG4gICAgLy8gc291cmNlVGFuZ2VudCAtIGEgdGFuZ2VudCB2ZWN0b3IgYWxvbmcgdGhlIGN1cnZlIGF0IHRoZSBzb3VyY2VQb2ludC5cbiAgICAvLyBzb3VyY2VEaXJlY3Rpb24gLSBhIHVuaXQgZGlyZWN0aW9uIHZlY3RvciBhbG9uZyB0aGUgY3VydmUgYXQgdGhlIHNvdXJjZVBvaW50LlxuICAgIC8vIHRhcmdldFRhbmdlbnQgLSBhIHRhbmdlbnQgdmVjdG9yIGFsb25nIHRoZSBjdXJ2ZSBhdCB0aGUgdGFyZ2V0UG9pbnQuXG4gICAgLy8gdGFyZ2V0RGlyZWN0aW9uIC0gYSB1bml0IGRpcmVjdGlvbiB2ZWN0b3IgYWxvbmcgdGhlIGN1cnZlIGF0IHRoZSB0YXJnZXRQb2ludC5cbiAgICAvLyBwcmVjaXNpb24gLSBhIHJvdW5kaW5nIHByZWNpc2lvbiBmb3IgcGF0aCB2YWx1ZXMuXG4gICAgY29uc3QgeyBkaXJlY3Rpb24gPSBEaXJlY3Rpb25zLkFVVE8sIHByZWNpc2lvbiA9IDMgfSA9IG9wdDtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBjb2VmZjogb3B0LmRpc3RhbmNlQ29lZmZpY2llbnQgfHwgMC42LFxuICAgICAgICBhbmdsZVRhbmdlbnRDb2VmZmljaWVudDogb3B0LmFuZ2xlVGFuZ2VudENvZWZmaWNpZW50IHx8IDgwLFxuICAgICAgICB0YXU6IG9wdC50ZW5zaW9uIHx8IDAuNSxcbiAgICAgICAgc291cmNlVGFuZ2VudDogb3B0LnNvdXJjZVRhbmdlbnQgPyBuZXcgUG9pbnQob3B0LnNvdXJjZVRhbmdlbnQpIDogbnVsbCxcbiAgICAgICAgdGFyZ2V0VGFuZ2VudDogb3B0LnRhcmdldFRhbmdlbnQgPyBuZXcgUG9pbnQob3B0LnRhcmdldFRhbmdlbnQpIDogbnVsbCxcbiAgICAgICAgcm90YXRlOiBCb29sZWFuKG9wdC5yb3RhdGUpXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdC5zb3VyY2VEaXJlY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgICBvcHRpb25zLnNvdXJjZURpcmVjdGlvbiA9IG9wdC5zb3VyY2VEaXJlY3Rpb247XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdC5zb3VyY2VEaXJlY3Rpb24gPT09ICdudW1iZXInKVxuICAgICAgICBvcHRpb25zLnNvdXJjZURpcmVjdGlvbiA9IG5ldyBQb2ludCgxLCAwKS5yb3RhdGUobnVsbCwgb3B0LnNvdXJjZURpcmVjdGlvbik7XG4gICAgZWxzZVxuICAgICAgICBvcHRpb25zLnNvdXJjZURpcmVjdGlvbiA9IG9wdC5zb3VyY2VEaXJlY3Rpb24gPyBuZXcgUG9pbnQob3B0LnNvdXJjZURpcmVjdGlvbikubm9ybWFsaXplKCkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHQudGFyZ2V0RGlyZWN0aW9uID09PSAnc3RyaW5nJylcbiAgICAgICAgb3B0aW9ucy50YXJnZXREaXJlY3Rpb24gPSBvcHQudGFyZ2V0RGlyZWN0aW9uO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHQudGFyZ2V0RGlyZWN0aW9uID09PSAnbnVtYmVyJylcbiAgICAgICAgb3B0aW9ucy50YXJnZXREaXJlY3Rpb24gPSBuZXcgUG9pbnQoMSwgMCkucm90YXRlKG51bGwsIG9wdC50YXJnZXREaXJlY3Rpb24pO1xuICAgIGVsc2VcbiAgICAgICAgb3B0aW9ucy50YXJnZXREaXJlY3Rpb24gPSBvcHQudGFyZ2V0RGlyZWN0aW9uID8gbmV3IFBvaW50KG9wdC50YXJnZXREaXJlY3Rpb24pLm5vcm1hbGl6ZSgpIDogbnVsbDtcblxuICAgIGNvbnN0IGNvbXBsZXRlUm91dGUgPSBbc291cmNlUG9pbnQsIC4uLnJvdXRlLCB0YXJnZXRQb2ludF0ubWFwKHAgPT4gbmV3IFBvaW50KHApKTtcblxuICAgIC8vIFRoZSBjYWxjdWxhdGlvbiBvZiBhIHNvdXJjZVRhbmdlbnRcbiAgICBsZXQgc291cmNlVGFuZ2VudDtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUYW5nZW50KSB7XG4gICAgICAgIHNvdXJjZVRhbmdlbnQgPSBvcHRpb25zLnNvdXJjZVRhbmdlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlRGlyZWN0aW9uID0gZ2V0U291cmNlVGFuZ2VudERpcmVjdGlvbihsaW5rVmlldywgY29tcGxldGVSb3V0ZSwgZGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdGFuZ2VudExlbmd0aCA9IGNvbXBsZXRlUm91dGVbMF0uZGlzdGFuY2UoY29tcGxldGVSb3V0ZVsxXSkgKiBvcHRpb25zLmNvZWZmO1xuICAgICAgICBjb25zdCBwb2ludHNWZWN0b3IgPSBjb21wbGV0ZVJvdXRlWzFdLmRpZmZlcmVuY2UoY29tcGxldGVSb3V0ZVswXSkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gYW5nbGVCZXR3ZWVuVmVjdG9ycyhzb3VyY2VEaXJlY3Rpb24sIHBvaW50c1ZlY3Rvcik7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyA0KSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTGVuZ3RoID0gdGFuZ2VudExlbmd0aCArIChhbmdsZSAtIE1hdGguUEkgLyA0KSAqIG9wdGlvbnMuYW5nbGVUYW5nZW50Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICBzb3VyY2VUYW5nZW50ID0gc291cmNlRGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodXBkYXRlZExlbmd0aCwgdXBkYXRlZExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VUYW5nZW50ID0gc291cmNlRGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodGFuZ2VudExlbmd0aCwgdGFuZ2VudExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgY2FsY3VsYXRpb24gb2YgYSB0YXJnZXRUYW5nZW50XG4gICAgbGV0IHRhcmdldFRhbmdlbnQ7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0VGFuZ2VudCkge1xuICAgICAgICB0YXJnZXRUYW5nZW50ID0gb3B0aW9ucy50YXJnZXRUYW5nZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERpcmVjdGlvbiA9IGdldFRhcmdldFRhbmdlbnREaXJlY3Rpb24obGlua1ZpZXcsIGNvbXBsZXRlUm91dGUsIGRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBjb21wbGV0ZVJvdXRlLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHRhbmdlbnRMZW5ndGggPSBjb21wbGV0ZVJvdXRlW2xhc3QgLSAxXS5kaXN0YW5jZShjb21wbGV0ZVJvdXRlW2xhc3RdKSAqIG9wdGlvbnMuY29lZmY7XG4gICAgICAgIGNvbnN0IHBvaW50c1ZlY3RvciA9IGNvbXBsZXRlUm91dGVbbGFzdCAtIDFdLmRpZmZlcmVuY2UoY29tcGxldGVSb3V0ZVtsYXN0XSkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gYW5nbGVCZXR3ZWVuVmVjdG9ycyh0YXJnZXREaXJlY3Rpb24sIHBvaW50c1ZlY3Rvcik7XG4gICAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkgLyA0KSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTGVuZ3RoID0gdGFuZ2VudExlbmd0aCArIChhbmdsZSAtIE1hdGguUEkgLyA0KSAqIG9wdGlvbnMuYW5nbGVUYW5nZW50Q29lZmZpY2llbnQ7XG4gICAgICAgICAgICB0YXJnZXRUYW5nZW50ID0gdGFyZ2V0RGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodXBkYXRlZExlbmd0aCwgdXBkYXRlZExlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRUYW5nZW50ID0gdGFyZ2V0RGlyZWN0aW9uLmNsb25lKCkuc2NhbGUodGFuZ2VudExlbmd0aCwgdGFuZ2VudExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjYXRtdWxsUm9tQ3VydmVzID0gY3JlYXRlQ2F0bXVsbFJvbUN1cnZlcyhjb21wbGV0ZVJvdXRlLCBzb3VyY2VUYW5nZW50LCB0YXJnZXRUYW5nZW50LCBvcHRpb25zKTtcbiAgICBjb25zdCBiZXppZXJDdXJ2ZXMgPSBjYXRtdWxsUm9tQ3VydmVzLm1hcChjdXJ2ZSA9PiBjYXRtdWxsUm9tVG9CZXppZXIoY3VydmUsIG9wdGlvbnMpKTtcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgoYmV6aWVyQ3VydmVzKS5yb3VuZChwcmVjaXNpb24pO1xuXG4gICAgcmV0dXJuIChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCk7XG59O1xuY3VydmUuRGlyZWN0aW9ucyA9IERpcmVjdGlvbnM7XG5jdXJ2ZS5UYW5nZW50RGlyZWN0aW9ucyA9IFRhbmdlbnREaXJlY3Rpb25zO1xuXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgc291cmNlQkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgc291cmNlU2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy5zb3VyY2VWaWV3KSB7XG4gICAgICAgIGlmIChzb3VyY2VCQm94LnggPiByb3V0ZVsxXS54KVxuICAgICAgICAgICAgc291cmNlU2lkZSA9ICdyaWdodCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSAnbGVmdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy5zb3VyY2VWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnNvdXJjZVZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcuc291cmNlVmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQb2ludCA9IHJvdXRlWzBdLmNsb25lKCk7XG4gICAgICAgICAgICBzb3VyY2VQb2ludC5yb3RhdGUoc291cmNlQkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgc291cmNlU2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSBzb3VyY2VCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVswXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAoc291cmNlU2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGFyZ2V0QkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgdGFyZ2V0U2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy50YXJnZXRWaWV3KSB7XG4gICAgICAgIGlmICh0YXJnZXRCQm94LnggPiByb3V0ZVtyb3V0ZS5sZW5ndGggLSAyXS54KVxuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9ICdsZWZ0JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9ICdyaWdodCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy50YXJnZXRWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnRhcmdldFZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcudGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb2ludCA9IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLmNsb25lKCk7XG4gICAgICAgICAgICB0YXJnZXRQb2ludC5yb3RhdGUodGFyZ2V0QkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAodGFyZ2V0U2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRWZXJ0aWNhbFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcuc291cmNlVmlldykge1xuICAgICAgICBpZiAoc291cmNlQkJveC55ID4gcm91dGVbMV0ueSlcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSAnYm90dG9tJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc291cmNlU2lkZSA9ICd0b3AnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcuc291cmNlVmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy5zb3VyY2VWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnNvdXJjZVZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9pbnQgPSByb3V0ZVswXS5jbG9uZSgpO1xuICAgICAgICAgICAgc291cmNlUG9pbnQucm90YXRlKHNvdXJjZUJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0VmVydGljYWxUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0YXJnZXRCQm94IH0gPSBsaW5rVmlldztcblxuICAgIGxldCB0YXJnZXRTaWRlO1xuICAgIGxldCByb3RhdGlvbjtcbiAgICBpZiAoIWxpbmtWaWV3LnRhcmdldFZpZXcpIHtcbiAgICAgICAgaWYgKHRhcmdldEJCb3gueSA+IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDJdLnkpXG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gJ3RvcCc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSAnYm90dG9tJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGlvbiA9IGxpbmtWaWV3LnRhcmdldFZpZXcubW9kZWwuYW5nbGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB1bnJvdGF0ZWRCQm94ID0gbGlua1ZpZXcudGFyZ2V0Vmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChsaW5rVmlldy50YXJnZXRWaWV3LmVsKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvaW50ID0gcm91dGVbcm91dGUubGVuZ3RoIC0gMV0uY2xvbmUoKTtcbiAgICAgICAgICAgIHRhcmdldFBvaW50LnJvdGF0ZSh0YXJnZXRCQm94LmNlbnRlcigpLCByb3RhdGlvbik7XG4gICAgICAgICAgICB0YXJnZXRTaWRlID0gdW5yb3RhdGVkQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQodGFyZ2V0UG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHRhcmdldFNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICBkaXJlY3Rpb24ucm90YXRlKG51bGwsIC1yb3RhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0QXV0b1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuXG4gICAgbGV0IHNvdXJjZVNpZGU7XG4gICAgbGV0IHJvdGF0aW9uO1xuICAgIGlmICghbGlua1ZpZXcuc291cmNlVmlldykge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbGlua1ZpZXcuc291cmNlVmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHVucm90YXRlZEJCb3ggPSBsaW5rVmlldy5zb3VyY2VWaWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KGxpbmtWaWV3LnNvdXJjZVZpZXcuZWwpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlUG9pbnQgPSByb3V0ZVswXS5jbG9uZSgpO1xuICAgICAgICAgICAgc291cmNlUG9pbnQucm90YXRlKHNvdXJjZUJCb3guY2VudGVyKCksIHJvdGF0aW9uKTtcbiAgICAgICAgICAgIHNvdXJjZVNpZGUgPSB1bnJvdGF0ZWRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChzb3VyY2VQb2ludCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQocm91dGVbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpcmVjdGlvbjtcbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucm90YXRlICYmIHJvdGF0aW9uKSB7XG4gICAgICAgIGRpcmVjdGlvbi5yb3RhdGUobnVsbCwgLXJvdGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRBdXRvVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGFyZ2V0QkJveCB9ID0gbGlua1ZpZXc7XG5cbiAgICBsZXQgdGFyZ2V0U2lkZTtcbiAgICBsZXQgcm90YXRpb247XG4gICAgaWYgKCFsaW5rVmlldy50YXJnZXRWaWV3KSB7XG4gICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm90YXRpb24gPSBsaW5rVmlldy50YXJnZXRWaWV3Lm1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLnJvdGF0ZSAmJiByb3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdW5yb3RhdGVkQkJveCA9IGxpbmtWaWV3LnRhcmdldFZpZXcuZ2V0Tm9kZVVucm90YXRlZEJCb3gobGlua1ZpZXcudGFyZ2V0Vmlldy5lbCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb2ludCA9IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdLmNsb25lKCk7XG4gICAgICAgICAgICB0YXJnZXRQb2ludC5yb3RhdGUodGFyZ2V0QkJveC5jZW50ZXIoKSwgcm90YXRpb24pO1xuICAgICAgICAgICAgdGFyZ2V0U2lkZSA9IHVucm90YXRlZEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFNpZGUgPSB0YXJnZXRCQm94LnNpZGVOZWFyZXN0VG9Qb2ludChyb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGlyZWN0aW9uO1xuICAgIHN3aXRjaCAodGFyZ2V0U2lkZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDAsIC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gbmV3IFBvaW50KDAsIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ldyBQb2ludCgtMSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yb3RhdGUgJiYgcm90YXRpb24pIHtcbiAgICAgICAgZGlyZWN0aW9uLnJvdGF0ZShudWxsLCAtcm90YXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQb2ludFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcm91dGVbMV0uZGlmZmVyZW5jZShyb3V0ZVswXSkubm9ybWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQb2ludFRhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYXN0ID0gcm91dGUubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gcm91dGVbbGFzdCAtIDFdLmRpZmZlcmVuY2Uocm91dGVbbGFzdF0pLm5vcm1hbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRPdXR3YXJkc1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNvdXJjZUJCb3ggfSA9IGxpbmtWaWV3O1xuICAgIGNvbnN0IHNvdXJjZUNlbnRlciA9IHNvdXJjZUJCb3guY2VudGVyKCk7XG4gICAgcmV0dXJuIHJvdXRlWzBdLmRpZmZlcmVuY2Uoc291cmNlQ2VudGVyKS5ub3JtYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3V0d2FyZHNUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0YXJnZXRCQm94IH0gPSBsaW5rVmlldztcbiAgICBjb25zdCB0YXJnZXRDZW50ZXIgPSB0YXJnZXRCQm94LmNlbnRlcigpO1xuICAgIHJldHVybiByb3V0ZVtyb3V0ZS5sZW5ndGggLSAxXS5kaWZmZXJlbmNlKHRhcmdldENlbnRlcikubm9ybWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZVRhbmdlbnREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zb3VyY2VEaXJlY3Rpb24pIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnNvdXJjZURpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5VUDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KDAsIC0xKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuRE9XTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KDAsIDEpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoLTEsIDApO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KDEsIDApO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5BVVRPOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBdXRvU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkNMT1NFU1RfUE9JTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENsb3Nlc3RQb2ludFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5PVVRXQVJEUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T3V0d2FyZHNTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlRGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkhPUklaT05UQUw6XG4gICAgICAgICAgICByZXR1cm4gZ2V0SG9yaXpvbnRhbFNvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuVkVSVElDQUw6XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmVydGljYWxTb3VyY2VEaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkNMT1NFU1RfUE9JTlQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q2xvc2VzdFBvaW50U291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5PVVRXQVJEUzpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXR3YXJkc1NvdXJjZURpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuQVVUTzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnZXRBdXRvU291cmNlRGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRUYW5nZW50RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0RGlyZWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy50YXJnZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuVVA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAtMSk7XG4gICAgICAgICAgICBjYXNlIFRhbmdlbnREaXJlY3Rpb25zLkRPV046XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgwLCAxKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuTEVGVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KC0xLCAwKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuUklHSFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCgxLCAwKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuQVVUTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXV0b1RhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBUYW5nZW50RGlyZWN0aW9ucy5DTE9TRVNUX1BPSU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDbG9zZXN0UG9pbnRUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVGFuZ2VudERpcmVjdGlvbnMuT1VUV0FSRFM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE91dHdhcmRzVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnRhcmdldERpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5IT1JJWk9OVEFMOlxuICAgICAgICAgICAgcmV0dXJuIGdldEhvcml6b250YWxUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlZFUlRJQ0FMOlxuICAgICAgICAgICAgcmV0dXJuIGdldFZlcnRpY2FsVGFyZ2V0RGlyZWN0aW9uKGxpbmtWaWV3LCByb3V0ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5DTE9TRVNUX1BPSU5UOlxuICAgICAgICAgICAgcmV0dXJuIGdldENsb3Nlc3RQb2ludFRhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuT1VUV0FSRFM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0d2FyZHNUYXJnZXREaXJlY3Rpb24obGlua1ZpZXcsIHJvdXRlLCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkFVVE86XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0QXV0b1RhcmdldERpcmVjdGlvbihsaW5rVmlldywgcm91dGUsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcm90YXRlVmVjdG9yKHZlY3RvciwgYW5nbGUpIHtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHggPSBjb3MgKiB2ZWN0b3IueCAtIHNpbiAqIHZlY3Rvci55O1xuICAgIGNvbnN0IHkgPSBzaW4gKiB2ZWN0b3IueCArIGNvcyAqIHZlY3Rvci55O1xuICAgIHZlY3Rvci54ID0geDtcbiAgICB2ZWN0b3IueSA9IHk7XG59XG5cbmZ1bmN0aW9uIGFuZ2xlQmV0d2VlblZlY3RvcnModjEsIHYyKSB7XG4gICAgbGV0IGNvcyA9IHYxLmRvdCh2MikgLyAodjEubWFnbml0dWRlKCkgKiB2Mi5tYWduaXR1ZGUoKSk7XG4gICAgaWYgKGNvcyA8IC0xKSBjb3MgPSAtMTtcbiAgICBpZiAoY29zID4gMSkgY29zID0gMTtcbiAgICByZXR1cm4gTWF0aC5hY29zKGNvcyk7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluYW50KHYxLCB2Mikge1xuICAgIHJldHVybiB2MS54ICogdjIueSAtIHYxLnkgKiB2Mi54O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXRtdWxsUm9tQ3VydmVzKHBvaW50cywgc291cmNlVGFuZ2VudCwgdGFyZ2V0VGFuZ2VudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgdGF1LCBjb2VmZiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkaXN0YW5jZXMgPSBbXTtcbiAgICBjb25zdCB0YW5nZW50cyA9IFtdO1xuICAgIGNvbnN0IGNhdG11bGxSb21DdXJ2ZXMgPSBbXTtcbiAgICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBkaXN0YW5jZXNbaV0gPSBwb2ludHNbaV0uZGlzdGFuY2UocG9pbnRzW2kgKyAxXSk7XG4gICAgfVxuXG4gICAgdGFuZ2VudHNbMF0gPSBzb3VyY2VUYW5nZW50O1xuICAgIHRhbmdlbnRzW25dID0gdGFyZ2V0VGFuZ2VudDtcblxuICAgIC8vIFRoZSBjYWxjdWxhdGlvbiBvZiB0YW5nZW50cyBvZiB2ZXJ0aWNlc1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCB0cFByZXY7XG4gICAgICAgIGxldCB0cE5leHQ7XG4gICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICB0cFByZXYgPSBwb2ludHNbaSAtIDFdLmNsb25lKCkub2Zmc2V0KHRhbmdlbnRzW2kgLSAxXS54LCB0YW5nZW50c1tpIC0gMV0ueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cFByZXYgPSBwb2ludHNbaSAtIDFdLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XG4gICAgICAgICAgICB0cE5leHQgPSBwb2ludHNbaSArIDFdLmNsb25lKCkub2Zmc2V0KHRhbmdlbnRzW2kgKyAxXS54LCB0YW5nZW50c1tpICsgMV0ueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cE5leHQgPSBwb2ludHNbaSArIDFdLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdjEgPSB0cFByZXYuZGlmZmVyZW5jZShwb2ludHNbaV0pLm5vcm1hbGl6ZSgpO1xuICAgICAgICBjb25zdCB2MiA9IHRwTmV4dC5kaWZmZXJlbmNlKHBvaW50c1tpXSkubm9ybWFsaXplKCk7XG4gICAgICAgIGNvbnN0IHZBbmdsZSA9IGFuZ2xlQmV0d2VlblZlY3RvcnModjEsIHYyKTtcblxuICAgICAgICBsZXQgcm90ID0gKE1hdGguUEkgLSB2QW5nbGUpIC8gMjtcbiAgICAgICAgbGV0IHQ7XG4gICAgICAgIGNvbnN0IHZlY3RvckRldGVybWluYW50ID0gZGV0ZXJtaW5hbnQodjEsIHYyKTtcbiAgICAgICAgbGV0IHBvaW50c0RldGVybWluYW50O1xuICAgICAgICBwb2ludHNEZXRlcm1pbmFudCA9IGRldGVybWluYW50KHBvaW50c1tpXS5kaWZmZXJlbmNlKHBvaW50c1tpICsgMV0pLCBwb2ludHNbaV0uZGlmZmVyZW5jZShwb2ludHNbaSAtIDFdKSk7XG4gICAgICAgIGlmICh2ZWN0b3JEZXRlcm1pbmFudCA8IDApIHtcbiAgICAgICAgICAgIHJvdCA9IC1yb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh2QW5nbGUgPCBNYXRoLlBJIC8gMikgJiYgKChyb3QgPCAwICYmIHBvaW50c0RldGVybWluYW50IDwgMCkgfHwgKHJvdCA+IDAgJiYgcG9pbnRzRGV0ZXJtaW5hbnQgPiAwKSkpIHtcbiAgICAgICAgICAgIHJvdCA9IHJvdCAtIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgICAgdCA9IHYyLmNsb25lKCk7XG4gICAgICAgIHJvdGF0ZVZlY3Rvcih0LCByb3QpO1xuXG4gICAgICAgIGNvbnN0IHQxID0gdC5jbG9uZSgpO1xuICAgICAgICBjb25zdCB0MiA9IHQuY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc2NhbGVGYWN0b3IxID0gZGlzdGFuY2VzW2kgLSAxXSAqIGNvZWZmO1xuICAgICAgICBjb25zdCBzY2FsZUZhY3RvcjIgPSBkaXN0YW5jZXNbaV0gKiBjb2VmZjtcbiAgICAgICAgdDEuc2NhbGUoc2NhbGVGYWN0b3IxLCBzY2FsZUZhY3RvcjEpO1xuICAgICAgICB0Mi5zY2FsZShzY2FsZUZhY3RvcjIsIHNjYWxlRmFjdG9yMik7XG5cbiAgICAgICAgdGFuZ2VudHNbaV0gPSBbdDEsIHQyXTtcbiAgICB9XG5cbiAgICAvLyBUaGUgYnVpbGRpbmcgb2YgYSBDYXRtdWxsLVJvbSBjdXJ2ZSBiYXNlZCBvZiB0YW5nZW50cyBvZiBwb2ludHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgcDA7XG4gICAgICAgIGxldCBwMztcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHAwID0gcG9pbnRzW2kgKyAxXS5kaWZmZXJlbmNlKHRhbmdlbnRzW2ldLnggLyB0YXUsIHRhbmdlbnRzW2ldLnkgLyB0YXUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDAgPSBwb2ludHNbaSArIDFdLmRpZmZlcmVuY2UodGFuZ2VudHNbaV1bMV0ueCAvIHRhdSwgdGFuZ2VudHNbaV1bMV0ueSAvIHRhdSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XG4gICAgICAgICAgICBwMyA9IHBvaW50c1tpXS5jbG9uZSgpLm9mZnNldCh0YW5nZW50c1tpICsgMV0ueCAvIHRhdSwgdGFuZ2VudHNbaSArIDFdLnkgLyB0YXUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcDMgPSBwb2ludHNbaV0uZGlmZmVyZW5jZSh0YW5nZW50c1tpICsgMV1bMF0ueCAvIHRhdSwgdGFuZ2VudHNbaSArIDFdWzBdLnkgLyB0YXUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2F0bXVsbFJvbUN1cnZlc1tpXSA9IFtwMCwgcG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBwM107XG4gICAgfVxuICAgIHJldHVybiBjYXRtdWxsUm9tQ3VydmVzO1xufVxuXG4vLyBUaGUgZnVuY3Rpb24gdG8gY29udmVydCBDYXRtdWxsLVJvbSBjdXJ2ZSB0byBCZXppZXIgY3VydmUgdXNpbmcgdGhlIHRlbnNpb24gKHRhdSlcbmZ1bmN0aW9uIGNhdG11bGxSb21Ub0Jlemllcihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRhdSB9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJjcDEgPSBuZXcgUG9pbnQoKTtcbiAgICBiY3AxLnggPSBwb2ludHNbMV0ueCArIChwb2ludHNbMl0ueCAtIHBvaW50c1swXS54KSAvICg2ICogdGF1KTtcbiAgICBiY3AxLnkgPSBwb2ludHNbMV0ueSArIChwb2ludHNbMl0ueSAtIHBvaW50c1swXS55KSAvICg2ICogdGF1KTtcblxuICAgIGNvbnN0IGJjcDIgPSBuZXcgUG9pbnQoKTtcbiAgICBiY3AyLnggPSBwb2ludHNbMl0ueCArIChwb2ludHNbM10ueCAtIHBvaW50c1sxXS54KSAvICg2ICogdGF1KTtcbiAgICBiY3AyLnkgPSBwb2ludHNbMl0ueSArIChwb2ludHNbM10ueSAtIHBvaW50c1sxXS55KSAvICg2ICogdGF1KTtcbiAgICByZXR1cm4gbmV3IEN1cnZlKFxuICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgIGJjcDEsXG4gICAgICAgIGJjcDIsXG4gICAgICAgIHBvaW50c1syXVxuICAgICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/curve.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/index.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curve: function() { return /* reexport safe */ _curve_mjs__WEBPACK_IMPORTED_MODULE_5__.curve; },\n/* harmony export */   jumpover: function() { return /* reexport safe */ _jumpover_mjs__WEBPACK_IMPORTED_MODULE_1__.jumpover; },\n/* harmony export */   normal: function() { return /* reexport safe */ _normal_mjs__WEBPACK_IMPORTED_MODULE_2__.normal; },\n/* harmony export */   rounded: function() { return /* reexport safe */ _rounded_mjs__WEBPACK_IMPORTED_MODULE_3__.rounded; },\n/* harmony export */   smooth: function() { return /* reexport safe */ _smooth_mjs__WEBPACK_IMPORTED_MODULE_4__.smooth; },\n/* harmony export */   straight: function() { return /* reexport safe */ _straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight; }\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/straight.mjs\");\n/* harmony import */ var _jumpover_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jumpover.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/jumpover.mjs\");\n/* harmony import */ var _normal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normal.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/normal.mjs\");\n/* harmony import */ var _rounded_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rounded.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/rounded.mjs\");\n/* harmony import */ var _smooth_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./smooth.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/smooth.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./curve.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/curve.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDRjtBQUNDO0FBQ0Q7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvaW5kZXgubWpzPzBhMzAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9zdHJhaWdodC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9qdW1wb3Zlci5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ub3JtYWwubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcm91bmRlZC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zbW9vdGgubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vY3VydmUubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/jumpover.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/jumpover.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   jumpover: function() { return /* binding */ jumpover; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n\n\n\n// default size of jump if not specified in options\nvar JUMP_SIZE = 5;\n\n// available jump types\n// first one taken as default\nvar JUMP_TYPES = ['arc', 'gap', 'cubic'];\n\n// default radius\nvar RADIUS = 0;\n\n// takes care of math. error for case when jump is too close to end of line\nvar CLOSE_PROXIMITY_PADDING = 1;\n\n// list of connector types not to jump over.\nvar IGNORED_CONNECTORS = ['smooth'];\n\n// internal constants for round segment\nvar _13 = 1 / 3;\nvar _23 = 2 / 3;\n\nfunction sortPointsAscending(p1, p2) {\n\n    let { x: x1, y: y1 } = p1;\n    let { x: x2, y: y2 } = p2;\n\n    if (x1 > x2) {\n\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    if (y1 > y2) {\n        let swap = x1;\n        x1 = x2;\n        x2 = swap;\n\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n    }\n\n    return [new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x1, y1), new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x2, y2)];\n}\n\nfunction overlapExists(line1, line2) {\n\n    const [{ x: x1, y: y1 }, { x: x2, y: y2 }] = sortPointsAscending(line1.start, line1.end);\n    const [{ x: x3, y: y3 }, { x: x4, y: y4 }] = sortPointsAscending(line2.start, line2.end);\n\n    const xMatch = x1 <= x4 && x3 <= x2;\n    const yMatch = y1 <= y4 && y3 <= y2;\n\n    return xMatch && yMatch;\n}\n\n/**\n * Transform start/end and route into series of lines\n * @param {g.point} sourcePoint start point\n * @param {g.point} targetPoint end point\n * @param {g.point[]} route optional list of route\n * @return {g.line[]} [description]\n */\nfunction createLines(sourcePoint, targetPoint, route) {\n    // make a flattened array of all points\n    var points = [].concat(sourcePoint, route, targetPoint);\n    return points.reduce(function(resultLines, point, idx) {\n        // if there is a next point, make a line with it\n        var nextPoint = points[idx + 1];\n        if (nextPoint != null) {\n            resultLines[idx] = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(point, nextPoint);\n        }\n        return resultLines;\n    }, []);\n}\n\nfunction setupUpdating(jumpOverLinkView) {\n    var paper = jumpOverLinkView.paper;\n    var updateList = paper._jumpOverUpdateList;\n\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = paper._jumpOverUpdateList = [];\n        var graph = paper.model;\n        graph.on('batch:stop', function() {\n            if (this.hasActiveBatch()) return;\n            updateJumpOver(paper);\n        });\n        graph.on('reset', function() {\n            updateList = paper._jumpOverUpdateList = [];\n        });\n    }\n\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(jumpOverLinkView) < 0) {\n        updateList.push(jumpOverLinkView);\n\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        jumpOverLinkView.listenToOnce(jumpOverLinkView.model, 'change:connector remove', function() {\n            updateList.splice(updateList.indexOf(jumpOverLinkView), 1);\n        });\n    }\n}\n\n/**\n * Handler for a batch:stop event to force\n * update of all registered links with jump over connector\n * @param {object} batchEvent optional object with info about batch\n */\nfunction updateJumpOver(paper) {\n    var updateList = paper._jumpOverUpdateList;\n    for (var i = 0; i < updateList.length; i++) {\n        const linkView = updateList[i];\n        const updateFlag = linkView.getFlag(linkView.constructor.Flags.CONNECTOR);\n        linkView.requestUpdate(updateFlag);\n    }\n}\n\n/**\n * Utility function to collect all intersection points of a single\n * line against group of other lines.\n * @param {g.line} line where to find points\n * @param {g.line[]} crossCheckLines lines to cross\n * @return {g.point[]} list of intersection points\n */\nfunction findLineIntersections(line, crossCheckLines) {\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(crossCheckLines).reduce(function(res, crossCheckLine) {\n        var intersection = line.intersection(crossCheckLine);\n        if (intersection) {\n            res.push(intersection);\n        }\n        return res;\n    }, []);\n}\n\n/**\n * Sorting function for list of points by their distance.\n * @param {g.point} p1 first point\n * @param {g.point} p2 second point\n * @return {number} squared distance between points\n */\nfunction sortPoints(p1, p2) {\n    return _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2).squaredLength();\n}\n\n/**\n * Split input line into multiple based on intersection points.\n * @param {g.line} line input line to split\n * @param {g.point[]} intersections points where to split the line\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @return {g.line[]} list of lines being split\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce(function(resultLines, point, idx) {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (point.skip === true) {\n            return resultLines;\n        }\n\n        // always grab the last line from buffer and modify it\n        var lastLine = resultLines.pop() || line;\n\n        // calculate start and end of jump by moving by a given size of jump\n        var jumpStart = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.point(point).move(lastLine.start, -(jumpSize));\n        var jumpEnd = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.point(point).move(lastLine.start, +(jumpSize));\n\n        // now try to look at the next intersection point\n        var nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            var distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                nextPoint.skip = true;\n            }\n        } else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            var endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                resultLines.push(lastLine);\n                return resultLines;\n            }\n        }\n\n        var startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            resultLines.push(lastLine);\n            return resultLines;\n        }\n\n        // finally create a jump line\n        var jumpLine = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumpLine.isJump = true;\n\n        resultLines.push(\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(lastLine.start, jumpStart),\n            jumpLine,\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(jumpEnd, lastLine.end)\n        );\n        return resultLines;\n    }, []);\n}\n\n/**\n * Assemble `D` attribute of a SVG path by iterating given lines.\n * @param {g.line[]} lines source lines to use\n * @param {number} jumpSize the size of jump arc (length empty spot on a line)\n * @param {number} radius the radius\n * @return {string}\n */\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n\n    var path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path();\n    var segment;\n\n    // first move to the start of a first line\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n\n    // make a paths from lines\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(lines).forEach(function(line, index) {\n\n        if (line.isJump) {\n            var angle, diff;\n\n            var control1, control2;\n\n            if (jumpType === 'arc') { // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                var xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) angle += 180;\n\n                var midpoint = line.midpoint();\n                var centerLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint, line.end).rotate(midpoint, angle);\n\n                var halfLine;\n\n                // first half\n                halfLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(line.start, midpoint);\n\n                control1 = halfLine.pointAt(2 / 3).rotate(line.start, angle);\n                control2 = centerLine.pointAt(1 / 3).rotate(centerLine.end, -angle);\n\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n\n                // second half\n                halfLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Line(midpoint, line.end);\n\n                control1 = centerLine.pointAt(1 / 3).rotate(centerLine.end, angle);\n                control2 = halfLine.pointAt(1 / 3).rotate(line.end, -angle);\n\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'gap') {\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n\n            } else if (jumpType === 'cubic') { // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n\n                var xOffset = jumpSize * 0.6;\n                var yOffset = jumpSize * 1.35;\n\n                // determine rotation of arc based on difference between points\n                diff = line.start.difference(line.end);\n                // make sure the arc always points up (or right)\n                xAxisRotate = Number((diff.x < 0) || (diff.x === 0 && diff.y < 0));\n                if (xAxisRotate) yOffset *= -1;\n\n                control1 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x + xOffset, line.start.y + yOffset).rotate(line.start, angle);\n                control2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - xOffset, line.end.y + yOffset).rotate(line.end, angle);\n\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n\n        } else {\n            var nextLine = lines[index + 1];\n            if (radius == 0 || !nextLine || nextLine.isJump) {\n                segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            } else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n\n    return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    var prevDistance = curr.distance(prev) / 2;\n    var nextDistance = curr.distance(next) / 2;\n\n    var startMove = -Math.min(offset, prevDistance);\n    var endMove = -Math.min(offset, nextDistance);\n\n    var roundedStart = curr.clone().move(prev, startMove).round();\n    var roundedEnd = curr.clone().move(next, endMove).round();\n\n    var control1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((_13 * roundedStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedStart.y));\n    var control2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point((_13 * roundedEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * roundedEnd.y));\n\n    var segment;\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n\n    segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\n\n/**\n * Actual connector function that will be run on every update.\n * @param {g.point} sourcePoint start point of this link\n * @param {g.point} targetPoint end point of this link\n * @param {g.point[]} route of this link\n * @param {object} opt options\n * @property {number} size optional size of a jump arc\n * @return {string} created `D` attribute of SVG path\n */\nconst jumpover = function(sourcePoint, targetPoint, route, opt) { // eslint-disable-line max-params\n\n    setupUpdating(this);\n\n    var raw = opt.raw;\n    var jumpSize = opt.size || JUMP_SIZE;\n    var jumpType = opt.jump && ('' + opt.jump).toLowerCase();\n    var radius = opt.radius || RADIUS;\n    var ignoreConnectors = opt.ignoreConnectors || IGNORED_CONNECTORS;\n\n    // grab the first jump type as a default if specified one is invalid\n    if (JUMP_TYPES.indexOf(jumpType) === -1) {\n        jumpType = JUMP_TYPES[0];\n    }\n\n    var paper = this.paper;\n    var graph = paper.model;\n    var allLinks = graph.getLinks();\n\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(\n            createLines(sourcePoint, targetPoint, route),\n            jumpSize, jumpType, radius\n        );\n    }\n\n    var thisModel = this.model;\n    var thisIndex = allLinks.indexOf(thisModel);\n    var defaultConnector = paper.options.defaultConnector || {};\n\n    // not all links are meant to be jumped over.\n    var links = allLinks.filter(function(link, idx) {\n\n        var connector = link.get('connector') || defaultConnector;\n\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toArray(ignoreConnectors).includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n\n    // find views for all links\n    var linkViews = links.map(function(link) {\n        return paper.findViewByModel(link);\n    });\n\n    // create lines for this link\n    var thisLines = createLines(\n        sourcePoint,\n        targetPoint,\n        route\n    );\n\n    // create lines for all other links\n    var linkLines = linkViews.map(function(linkView) {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(\n            linkView.sourcePoint,\n            linkView.targetPoint,\n            linkView.route\n        );\n    }, this);\n\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    var jumpingLines = thisLines.reduce(function(resultLines, thisLine) {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        var intersections = links.reduce(function(res, link, i) {\n            // don't intersection with itself\n            if (link !== thisModel) {\n\n                const linkLinesToTest = linkLines[i].slice();\n                const overlapIndex = linkLinesToTest.findIndex((line) => overlapExists(thisLine, line));\n\n                // Overlap occurs and the end point of one segment lies on thisLine\n                if (overlapIndex > -1 && thisLine.containsPoint(linkLinesToTest[overlapIndex].end)) {\n                    // Remove the next segment because there will never be a jump\n                    linkLinesToTest.splice(overlapIndex + 1, 1);\n                }\n                const lineIntersections = findLineIntersections(thisLine, linkLinesToTest);\n                res.push.apply(res, lineIntersections);\n            }\n            return res;\n        }, []).sort(function(a, b) {\n            return sortPoints(thisLine.start, a) - sortPoints(thisLine.start, b);\n        });\n\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            resultLines.push.apply(resultLines, createJumps(thisLine, intersections, jumpSize));\n        } else {\n            // without any intersection the line goes uninterrupted\n            resultLines.push(thisLine);\n        }\n        return resultLines;\n    }, []);\n\n    var path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    return (raw) ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9qdW1wb3Zlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEM7QUFDTjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsZUFBZTtBQUN6QixVQUFVLGVBQWU7O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsK0NBQU8sY0FBYywrQ0FBTztBQUM1Qzs7QUFFQTs7QUFFQSxhQUFhLGNBQWMsSUFBSSxjQUFjO0FBQzdDLGFBQWEsY0FBYyxJQUFJLGNBQWM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFdBQVc7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOENBQU07QUFDckM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxX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Szs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Nvbm5lY3RvcnMvanVtcG92ZXIubWpzPzJkZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuLy8gZGVmYXVsdCBzaXplIG9mIGp1bXAgaWYgbm90IHNwZWNpZmllZCBpbiBvcHRpb25zXG52YXIgSlVNUF9TSVpFID0gNTtcblxuLy8gYXZhaWxhYmxlIGp1bXAgdHlwZXNcbi8vIGZpcnN0IG9uZSB0YWtlbiBhcyBkZWZhdWx0XG52YXIgSlVNUF9UWVBFUyA9IFsnYXJjJywgJ2dhcCcsICdjdWJpYyddO1xuXG4vLyBkZWZhdWx0IHJhZGl1c1xudmFyIFJBRElVUyA9IDA7XG5cbi8vIHRha2VzIGNhcmUgb2YgbWF0aC4gZXJyb3IgZm9yIGNhc2Ugd2hlbiBqdW1wIGlzIHRvbyBjbG9zZSB0byBlbmQgb2YgbGluZVxudmFyIENMT1NFX1BST1hJTUlUWV9QQURESU5HID0gMTtcblxuLy8gbGlzdCBvZiBjb25uZWN0b3IgdHlwZXMgbm90IHRvIGp1bXAgb3Zlci5cbnZhciBJR05PUkVEX0NPTk5FQ1RPUlMgPSBbJ3Ntb290aCddO1xuXG4vLyBpbnRlcm5hbCBjb25zdGFudHMgZm9yIHJvdW5kIHNlZ21lbnRcbnZhciBfMTMgPSAxIC8gMztcbnZhciBfMjMgPSAyIC8gMztcblxuZnVuY3Rpb24gc29ydFBvaW50c0FzY2VuZGluZyhwMSwgcDIpIHtcblxuICAgIGxldCB7IHg6IHgxLCB5OiB5MSB9ID0gcDE7XG4gICAgbGV0IHsgeDogeDIsIHk6IHkyIH0gPSBwMjtcblxuICAgIGlmICh4MSA+IHgyKSB7XG5cbiAgICAgICAgbGV0IHN3YXAgPSB4MTtcbiAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuXG4gICAgICAgIHN3YXAgPSB5MTtcbiAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgIH1cblxuICAgIGlmICh5MSA+IHkyKSB7XG4gICAgICAgIGxldCBzd2FwID0geDE7XG4gICAgICAgIHgxID0geDI7XG4gICAgICAgIHgyID0gc3dhcDtcblxuICAgICAgICBzd2FwID0geTE7XG4gICAgICAgIHkxID0geTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICB9XG5cbiAgICByZXR1cm4gW25ldyBnLlBvaW50KHgxLCB5MSksIG5ldyBnLlBvaW50KHgyLCB5MildO1xufVxuXG5mdW5jdGlvbiBvdmVybGFwRXhpc3RzKGxpbmUxLCBsaW5lMikge1xuXG4gICAgY29uc3QgW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dID0gc29ydFBvaW50c0FzY2VuZGluZyhsaW5lMS5zdGFydCwgbGluZTEuZW5kKTtcbiAgICBjb25zdCBbeyB4OiB4MywgeTogeTMgfSwgeyB4OiB4NCwgeTogeTQgfV0gPSBzb3J0UG9pbnRzQXNjZW5kaW5nKGxpbmUyLnN0YXJ0LCBsaW5lMi5lbmQpO1xuXG4gICAgY29uc3QgeE1hdGNoID0geDEgPD0geDQgJiYgeDMgPD0geDI7XG4gICAgY29uc3QgeU1hdGNoID0geTEgPD0geTQgJiYgeTMgPD0geTI7XG5cbiAgICByZXR1cm4geE1hdGNoICYmIHlNYXRjaDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gc3RhcnQvZW5kIGFuZCByb3V0ZSBpbnRvIHNlcmllcyBvZiBsaW5lc1xuICogQHBhcmFtIHtnLnBvaW50fSBzb3VyY2VQb2ludCBzdGFydCBwb2ludFxuICogQHBhcmFtIHtnLnBvaW50fSB0YXJnZXRQb2ludCBlbmQgcG9pbnRcbiAqIEBwYXJhbSB7Zy5wb2ludFtdfSByb3V0ZSBvcHRpb25hbCBsaXN0IG9mIHJvdXRlXG4gKiBAcmV0dXJuIHtnLmxpbmVbXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBjcmVhdGVMaW5lcyhzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlKSB7XG4gICAgLy8gbWFrZSBhIGZsYXR0ZW5lZCBhcnJheSBvZiBhbGwgcG9pbnRzXG4gICAgdmFyIHBvaW50cyA9IFtdLmNvbmNhdChzb3VyY2VQb2ludCwgcm91dGUsIHRhcmdldFBvaW50KTtcbiAgICByZXR1cm4gcG9pbnRzLnJlZHVjZShmdW5jdGlvbihyZXN1bHRMaW5lcywgcG9pbnQsIGlkeCkge1xuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIG5leHQgcG9pbnQsIG1ha2UgYSBsaW5lIHdpdGggaXRcbiAgICAgICAgdmFyIG5leHRQb2ludCA9IHBvaW50c1tpZHggKyAxXTtcbiAgICAgICAgaWYgKG5leHRQb2ludCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHRMaW5lc1tpZHhdID0gZy5saW5lKHBvaW50LCBuZXh0UG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRMaW5lcztcbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHNldHVwVXBkYXRpbmcoanVtcE92ZXJMaW5rVmlldykge1xuICAgIHZhciBwYXBlciA9IGp1bXBPdmVyTGlua1ZpZXcucGFwZXI7XG4gICAgdmFyIHVwZGF0ZUxpc3QgPSBwYXBlci5fanVtcE92ZXJVcGRhdGVMaXN0O1xuXG4gICAgLy8gZmlyc3QgdGltZSBzZXR1cCBmb3IgdGhpcyBwYXBlclxuICAgIGlmICh1cGRhdGVMaXN0ID09IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTGlzdCA9IHBhcGVyLl9qdW1wT3ZlclVwZGF0ZUxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGdyYXBoID0gcGFwZXIubW9kZWw7XG4gICAgICAgIGdyYXBoLm9uKCdiYXRjaDpzdG9wJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBY3RpdmVCYXRjaCgpKSByZXR1cm47XG4gICAgICAgICAgICB1cGRhdGVKdW1wT3ZlcihwYXBlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBncmFwaC5vbigncmVzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpc3QgPSBwYXBlci5fanVtcE92ZXJVcGRhdGVMaXN0ID0gW107XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGlzIGxpbmsgdG8gYSBsaXN0IHNvIGl0IGNhbiBiZSB1cGRhdGVkIHdoZW4gc29tZSBvdGhlciBsaW5rIGlzIHVwZGF0ZWRcbiAgICBpZiAodXBkYXRlTGlzdC5pbmRleE9mKGp1bXBPdmVyTGlua1ZpZXcpIDwgMCkge1xuICAgICAgICB1cGRhdGVMaXN0LnB1c2goanVtcE92ZXJMaW5rVmlldyk7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZSBvZiBjb25uZWN0b3IgdHlwZSBvciByZW1vdmFsIG9mIGxpbmsgaXRzZWxmXG4gICAgICAgIC8vIHRvIHJlbW92ZSB0aGUgbGluayBmcm9tIGEgbGlzdCBvZiBqdW1wIG92ZXIgY29ubmVjdG9yc1xuICAgICAgICBqdW1wT3ZlckxpbmtWaWV3Lmxpc3RlblRvT25jZShqdW1wT3ZlckxpbmtWaWV3Lm1vZGVsLCAnY2hhbmdlOmNvbm5lY3RvciByZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpc3Quc3BsaWNlKHVwZGF0ZUxpc3QuaW5kZXhPZihqdW1wT3ZlckxpbmtWaWV3KSwgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBhIGJhdGNoOnN0b3AgZXZlbnQgdG8gZm9yY2VcbiAqIHVwZGF0ZSBvZiBhbGwgcmVnaXN0ZXJlZCBsaW5rcyB3aXRoIGp1bXAgb3ZlciBjb25uZWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBiYXRjaEV2ZW50IG9wdGlvbmFsIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgYmF0Y2hcbiAqL1xuZnVuY3Rpb24gdXBkYXRlSnVtcE92ZXIocGFwZXIpIHtcbiAgICB2YXIgdXBkYXRlTGlzdCA9IHBhcGVyLl9qdW1wT3ZlclVwZGF0ZUxpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmtWaWV3ID0gdXBkYXRlTGlzdFtpXTtcbiAgICAgICAgY29uc3QgdXBkYXRlRmxhZyA9IGxpbmtWaWV3LmdldEZsYWcobGlua1ZpZXcuY29uc3RydWN0b3IuRmxhZ3MuQ09OTkVDVE9SKTtcbiAgICAgICAgbGlua1ZpZXcucmVxdWVzdFVwZGF0ZSh1cGRhdGVGbGFnKTtcbiAgICB9XG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBjb2xsZWN0IGFsbCBpbnRlcnNlY3Rpb24gcG9pbnRzIG9mIGEgc2luZ2xlXG4gKiBsaW5lIGFnYWluc3QgZ3JvdXAgb2Ygb3RoZXIgbGluZXMuXG4gKiBAcGFyYW0ge2cubGluZX0gbGluZSB3aGVyZSB0byBmaW5kIHBvaW50c1xuICogQHBhcmFtIHtnLmxpbmVbXX0gY3Jvc3NDaGVja0xpbmVzIGxpbmVzIHRvIGNyb3NzXG4gKiBAcmV0dXJuIHtnLnBvaW50W119IGxpc3Qgb2YgaW50ZXJzZWN0aW9uIHBvaW50c1xuICovXG5mdW5jdGlvbiBmaW5kTGluZUludGVyc2VjdGlvbnMobGluZSwgY3Jvc3NDaGVja0xpbmVzKSB7XG4gICAgcmV0dXJuIHV0aWwudG9BcnJheShjcm9zc0NoZWNrTGluZXMpLnJlZHVjZShmdW5jdGlvbihyZXMsIGNyb3NzQ2hlY2tMaW5lKSB7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBsaW5lLmludGVyc2VjdGlvbihjcm9zc0NoZWNrTGluZSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGludGVyc2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG59XG5cbi8qKlxuICogU29ydGluZyBmdW5jdGlvbiBmb3IgbGlzdCBvZiBwb2ludHMgYnkgdGhlaXIgZGlzdGFuY2UuXG4gKiBAcGFyYW0ge2cucG9pbnR9IHAxIGZpcnN0IHBvaW50XG4gKiBAcGFyYW0ge2cucG9pbnR9IHAyIHNlY29uZCBwb2ludFxuICogQHJldHVybiB7bnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzXG4gKi9cbmZ1bmN0aW9uIHNvcnRQb2ludHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIGcubGluZShwMSwgcDIpLnNxdWFyZWRMZW5ndGgoKTtcbn1cblxuLyoqXG4gKiBTcGxpdCBpbnB1dCBsaW5lIGludG8gbXVsdGlwbGUgYmFzZWQgb24gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAqIEBwYXJhbSB7Zy5saW5lfSBsaW5lIGlucHV0IGxpbmUgdG8gc3BsaXRcbiAqIEBwYXJhbSB7Zy5wb2ludFtdfSBpbnRlcnNlY3Rpb25zIHBvaW50cyB3aGVyZSB0byBzcGxpdCB0aGUgbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGp1bXBTaXplIHRoZSBzaXplIG9mIGp1bXAgYXJjIChsZW5ndGggZW1wdHkgc3BvdCBvbiBhIGxpbmUpXG4gKiBAcmV0dXJuIHtnLmxpbmVbXX0gbGlzdCBvZiBsaW5lcyBiZWluZyBzcGxpdFxuICovXG5mdW5jdGlvbiBjcmVhdGVKdW1wcyhsaW5lLCBpbnRlcnNlY3Rpb25zLCBqdW1wU2l6ZSkge1xuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zLnJlZHVjZShmdW5jdGlvbihyZXN1bHRMaW5lcywgcG9pbnQsIGlkeCkge1xuICAgICAgICAvLyBza2lwcGluZyBwb2ludHMgdGhhdCB3ZXJlIG1lcmdlZCB3aXRoIHRoZSBwcmV2aW91cyBsaW5lXG4gICAgICAgIC8vIHRvIG1ha2UgYmlnZ2VyIGFyYyBvdmVyIG11bHRpcGxlIGxpbmVzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXJcbiAgICAgICAgaWYgKHBvaW50LnNraXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRMaW5lcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsd2F5cyBncmFiIHRoZSBsYXN0IGxpbmUgZnJvbSBidWZmZXIgYW5kIG1vZGlmeSBpdFxuICAgICAgICB2YXIgbGFzdExpbmUgPSByZXN1bHRMaW5lcy5wb3AoKSB8fCBsaW5lO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBzdGFydCBhbmQgZW5kIG9mIGp1bXAgYnkgbW92aW5nIGJ5IGEgZ2l2ZW4gc2l6ZSBvZiBqdW1wXG4gICAgICAgIHZhciBqdW1wU3RhcnQgPSBnLnBvaW50KHBvaW50KS5tb3ZlKGxhc3RMaW5lLnN0YXJ0LCAtKGp1bXBTaXplKSk7XG4gICAgICAgIHZhciBqdW1wRW5kID0gZy5wb2ludChwb2ludCkubW92ZShsYXN0TGluZS5zdGFydCwgKyhqdW1wU2l6ZSkpO1xuXG4gICAgICAgIC8vIG5vdyB0cnkgdG8gbG9vayBhdCB0aGUgbmV4dCBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICAgdmFyIG5leHRQb2ludCA9IGludGVyc2VjdGlvbnNbaWR4ICsgMV07XG4gICAgICAgIGlmIChuZXh0UG9pbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0ganVtcEVuZC5kaXN0YW5jZShuZXh0UG9pbnQpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDw9IGp1bXBTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gbmV4dCBwb2ludCBpcyBjbG9zZSBlbm91Z2gsIG1vdmUgdGhlIGp1bXAgZW5kIGJ5IHRoaXNcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGFuZCBtYXJrIHRoZSBuZXh0IHBvaW50IHRvIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICBqdW1wRW5kID0gbmV4dFBvaW50Lm1vdmUobGFzdExpbmUuc3RhcnQsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQuc2tpcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGJsb2NrIGlzIGluc2lkZSBvZiBgZWxzZWAgYXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoZSBkaXN0YW5jZSBpc1xuICAgICAgICAgICAgLy8gbm90IGNhbGN1bGF0ZWQgd2hlbiB3ZSBrbm93IHRoZXJlIGFyZSBubyBvdGhlciBpbnRlcnNlY3Rpb24gcG9pbnRzXG4gICAgICAgICAgICB2YXIgZW5kRGlzdGFuY2UgPSBqdW1wU3RhcnQuZGlzdGFuY2UobGFzdExpbmUuZW5kKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBlbmQgaXMgdG9vIGNsb3NlIHRvIHBvc3NpYmxlIGp1bXAsIGRyYXcgcmVtYWluaW5nIGxpbmUgaW5zdGVhZCBvZiBhIGp1bXBcbiAgICAgICAgICAgIGlmIChlbmREaXN0YW5jZSA8IGp1bXBTaXplICogMiArIENMT1NFX1BST1hJTUlUWV9QQURESU5HKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaChsYXN0TGluZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExpbmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0RGlzdGFuY2UgPSBqdW1wRW5kLmRpc3RhbmNlKGxhc3RMaW5lLnN0YXJ0KTtcbiAgICAgICAgaWYgKHN0YXJ0RGlzdGFuY2UgPCBqdW1wU2l6ZSAqIDIgKyBDTE9TRV9QUk9YSU1JVFlfUEFERElORykge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXJ0IG9mIGxpbmUgaXMgdG9vIGNsb3NlIHRvIGp1bXAsIGRyYXcgdGhhdCBsaW5lIGluc3RlYWQgb2YgYSBqdW1wXG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKGxhc3RMaW5lKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRMaW5lcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHkgY3JlYXRlIGEganVtcCBsaW5lXG4gICAgICAgIHZhciBqdW1wTGluZSA9IGcubGluZShqdW1wU3RhcnQsIGp1bXBFbmQpO1xuICAgICAgICAvLyBpdCdzIGp1c3Qgc2ltcGxlIGxpbmUgYnV0IHdpdGggYSBgaXNKdW1wYCBwcm9wZXJ0eVxuICAgICAgICBqdW1wTGluZS5pc0p1bXAgPSB0cnVlO1xuXG4gICAgICAgIHJlc3VsdExpbmVzLnB1c2goXG4gICAgICAgICAgICBnLmxpbmUobGFzdExpbmUuc3RhcnQsIGp1bXBTdGFydCksXG4gICAgICAgICAgICBqdW1wTGluZSxcbiAgICAgICAgICAgIGcubGluZShqdW1wRW5kLCBsYXN0TGluZS5lbmQpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiByZXN1bHRMaW5lcztcbiAgICB9LCBbXSk7XG59XG5cbi8qKlxuICogQXNzZW1ibGUgYERgIGF0dHJpYnV0ZSBvZiBhIFNWRyBwYXRoIGJ5IGl0ZXJhdGluZyBnaXZlbiBsaW5lcy5cbiAqIEBwYXJhbSB7Zy5saW5lW119IGxpbmVzIHNvdXJjZSBsaW5lcyB0byB1c2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBqdW1wU2l6ZSB0aGUgc2l6ZSBvZiBqdW1wIGFyYyAobGVuZ3RoIGVtcHR5IHNwb3Qgb24gYSBsaW5lKVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyB0aGUgcmFkaXVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUGF0aChsaW5lcywganVtcFNpemUsIGp1bXBUeXBlLCByYWRpdXMpIHtcblxuICAgIHZhciBwYXRoID0gbmV3IGcuUGF0aCgpO1xuICAgIHZhciBzZWdtZW50O1xuXG4gICAgLy8gZmlyc3QgbW92ZSB0byB0aGUgc3RhcnQgb2YgYSBmaXJzdCBsaW5lXG4gICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgbGluZXNbMF0uc3RhcnQpO1xuICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgIC8vIG1ha2UgYSBwYXRocyBmcm9tIGxpbmVzXG4gICAgdXRpbC50b0FycmF5KGxpbmVzKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUsIGluZGV4KSB7XG5cbiAgICAgICAgaWYgKGxpbmUuaXNKdW1wKSB7XG4gICAgICAgICAgICB2YXIgYW5nbGUsIGRpZmY7XG5cbiAgICAgICAgICAgIHZhciBjb250cm9sMSwgY29udHJvbDI7XG5cbiAgICAgICAgICAgIGlmIChqdW1wVHlwZSA9PT0gJ2FyYycpIHsgLy8gYXBwcm94aW1hdGVzIHNlbWljaXJjbGUgd2l0aCAyIGN1cnZlc1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gLTkwO1xuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSByb3RhdGlvbiBvZiBhcmMgYmFzZWQgb24gZGlmZmVyZW5jZSBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgICAgICAgIGRpZmYgPSBsaW5lLnN0YXJ0LmRpZmZlcmVuY2UobGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYXJjIGFsd2F5cyBwb2ludHMgdXAgKG9yIHJpZ2h0KVxuICAgICAgICAgICAgICAgIHZhciB4QXhpc1JvdGF0ZSA9IE51bWJlcigoZGlmZi54IDwgMCkgfHwgKGRpZmYueCA9PT0gMCAmJiBkaWZmLnkgPCAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKHhBeGlzUm90YXRlKSBhbmdsZSArPSAxODA7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWlkcG9pbnQgPSBsaW5lLm1pZHBvaW50KCk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckxpbmUgPSBuZXcgZy5MaW5lKG1pZHBvaW50LCBsaW5lLmVuZCkucm90YXRlKG1pZHBvaW50LCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGFsZkxpbmU7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBoYWxmXG4gICAgICAgICAgICAgICAgaGFsZkxpbmUgPSBuZXcgZy5MaW5lKGxpbmUuc3RhcnQsIG1pZHBvaW50KTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2wxID0gaGFsZkxpbmUucG9pbnRBdCgyIC8gMykucm90YXRlKGxpbmUuc3RhcnQsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb250cm9sMiA9IGNlbnRlckxpbmUucG9pbnRBdCgxIC8gMykucm90YXRlKGNlbnRlckxpbmUuZW5kLCAtYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgY29udHJvbDEsIGNvbnRyb2wyLCBjZW50ZXJMaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kIGhhbGZcbiAgICAgICAgICAgICAgICBoYWxmTGluZSA9IG5ldyBnLkxpbmUobWlkcG9pbnQsIGxpbmUuZW5kKTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2wxID0gY2VudGVyTGluZS5wb2ludEF0KDEgLyAzKS5yb3RhdGUoY2VudGVyTGluZS5lbmQsIGFuZ2xlKTtcbiAgICAgICAgICAgICAgICBjb250cm9sMiA9IGhhbGZMaW5lLnBvaW50QXQoMSAvIDMpLnJvdGF0ZShsaW5lLmVuZCwgLWFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2wxLCBjb250cm9sMiwgbGluZS5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChqdW1wVHlwZSA9PT0gJ2dhcCcpIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBsaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGp1bXBUeXBlID09PSAnY3ViaWMnKSB7IC8vIGFwcHJveGltYXRlcyBzZW1pY2lyY2xlIHdpdGggMSBjdXJ2ZVxuICAgICAgICAgICAgICAgIGFuZ2xlID0gbGluZS5zdGFydC50aGV0YShsaW5lLmVuZCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldCA9IGp1bXBTaXplICogMC42O1xuICAgICAgICAgICAgICAgIHZhciB5T2Zmc2V0ID0ganVtcFNpemUgKiAxLjM1O1xuXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHJvdGF0aW9uIG9mIGFyYyBiYXNlZCBvbiBkaWZmZXJlbmNlIGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICAgICAgZGlmZiA9IGxpbmUuc3RhcnQuZGlmZmVyZW5jZShsaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBhcmMgYWx3YXlzIHBvaW50cyB1cCAob3IgcmlnaHQpXG4gICAgICAgICAgICAgICAgeEF4aXNSb3RhdGUgPSBOdW1iZXIoKGRpZmYueCA8IDApIHx8IChkaWZmLnggPT09IDAgJiYgZGlmZi55IDwgMCkpO1xuICAgICAgICAgICAgICAgIGlmICh4QXhpc1JvdGF0ZSkgeU9mZnNldCAqPSAtMTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2wxID0gZy5Qb2ludChsaW5lLnN0YXJ0LnggKyB4T2Zmc2V0LCBsaW5lLnN0YXJ0LnkgKyB5T2Zmc2V0KS5yb3RhdGUobGluZS5zdGFydCwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wyID0gZy5Qb2ludChsaW5lLmVuZC54IC0geE9mZnNldCwgbGluZS5lbmQueSArIHlPZmZzZXQpLnJvdGF0ZShsaW5lLmVuZCwgYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgY29udHJvbDEsIGNvbnRyb2wyLCBsaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV4dExpbmUgPSBsaW5lc1tpbmRleCArIDFdO1xuICAgICAgICAgICAgaWYgKHJhZGl1cyA9PSAwIHx8ICFuZXh0TGluZSB8fCBuZXh0TGluZS5pc0p1bXApIHtcbiAgICAgICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCBsaW5lLmVuZCk7XG4gICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWlsZFJvdW5kZWRTZWdtZW50KHJhZGl1cywgcGF0aCwgbGluZS5lbmQsIGxpbmUuc3RhcnQsIG5leHRMaW5lLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBidWlsZFJvdW5kZWRTZWdtZW50KG9mZnNldCwgcGF0aCwgY3VyciwgcHJldiwgbmV4dCkge1xuICAgIHZhciBwcmV2RGlzdGFuY2UgPSBjdXJyLmRpc3RhbmNlKHByZXYpIC8gMjtcbiAgICB2YXIgbmV4dERpc3RhbmNlID0gY3Vyci5kaXN0YW5jZShuZXh0KSAvIDI7XG5cbiAgICB2YXIgc3RhcnRNb3ZlID0gLU1hdGgubWluKG9mZnNldCwgcHJldkRpc3RhbmNlKTtcbiAgICB2YXIgZW5kTW92ZSA9IC1NYXRoLm1pbihvZmZzZXQsIG5leHREaXN0YW5jZSk7XG5cbiAgICB2YXIgcm91bmRlZFN0YXJ0ID0gY3Vyci5jbG9uZSgpLm1vdmUocHJldiwgc3RhcnRNb3ZlKS5yb3VuZCgpO1xuICAgIHZhciByb3VuZGVkRW5kID0gY3Vyci5jbG9uZSgpLm1vdmUobmV4dCwgZW5kTW92ZSkucm91bmQoKTtcblxuICAgIHZhciBjb250cm9sMSA9IG5ldyBnLlBvaW50KChfMTMgKiByb3VuZGVkU3RhcnQueCkgKyAoXzIzICogY3Vyci54KSwgKF8yMyAqIGN1cnIueSkgKyAoXzEzICogcm91bmRlZFN0YXJ0LnkpKTtcbiAgICB2YXIgY29udHJvbDIgPSBuZXcgZy5Qb2ludCgoXzEzICogcm91bmRlZEVuZC54KSArIChfMjMgKiBjdXJyLngpLCAoXzIzICogY3Vyci55KSArIChfMTMgKiByb3VuZGVkRW5kLnkpKTtcblxuICAgIHZhciBzZWdtZW50O1xuICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnTCcsIHJvdW5kZWRTdGFydCk7XG4gICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgc2VnbWVudCA9IGcuUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgY29udHJvbDEsIGNvbnRyb2wyLCByb3VuZGVkRW5kKTtcbiAgICBwYXRoLmFwcGVuZFNlZ21lbnQoc2VnbWVudCk7XG59XG5cbi8qKlxuICogQWN0dWFsIGNvbm5lY3RvciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuIG9uIGV2ZXJ5IHVwZGF0ZS5cbiAqIEBwYXJhbSB7Zy5wb2ludH0gc291cmNlUG9pbnQgc3RhcnQgcG9pbnQgb2YgdGhpcyBsaW5rXG4gKiBAcGFyYW0ge2cucG9pbnR9IHRhcmdldFBvaW50IGVuZCBwb2ludCBvZiB0aGlzIGxpbmtcbiAqIEBwYXJhbSB7Zy5wb2ludFtdfSByb3V0ZSBvZiB0aGlzIGxpbmtcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHQgb3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpemUgb3B0aW9uYWwgc2l6ZSBvZiBhIGp1bXAgYXJjXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGNyZWF0ZWQgYERgIGF0dHJpYnV0ZSBvZiBTVkcgcGF0aFxuICovXG5leHBvcnQgY29uc3QganVtcG92ZXIgPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlLCBvcHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtcGFyYW1zXG5cbiAgICBzZXR1cFVwZGF0aW5nKHRoaXMpO1xuXG4gICAgdmFyIHJhdyA9IG9wdC5yYXc7XG4gICAgdmFyIGp1bXBTaXplID0gb3B0LnNpemUgfHwgSlVNUF9TSVpFO1xuICAgIHZhciBqdW1wVHlwZSA9IG9wdC5qdW1wICYmICgnJyArIG9wdC5qdW1wKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciByYWRpdXMgPSBvcHQucmFkaXVzIHx8IFJBRElVUztcbiAgICB2YXIgaWdub3JlQ29ubmVjdG9ycyA9IG9wdC5pZ25vcmVDb25uZWN0b3JzIHx8IElHTk9SRURfQ09OTkVDVE9SUztcblxuICAgIC8vIGdyYWIgdGhlIGZpcnN0IGp1bXAgdHlwZSBhcyBhIGRlZmF1bHQgaWYgc3BlY2lmaWVkIG9uZSBpcyBpbnZhbGlkXG4gICAgaWYgKEpVTVBfVFlQRVMuaW5kZXhPZihqdW1wVHlwZSkgPT09IC0xKSB7XG4gICAgICAgIGp1bXBUeXBlID0gSlVNUF9UWVBFU1swXTtcbiAgICB9XG5cbiAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuICAgIHZhciBncmFwaCA9IHBhcGVyLm1vZGVsO1xuICAgIHZhciBhbGxMaW5rcyA9IGdyYXBoLmdldExpbmtzKCk7XG5cbiAgICAvLyB0aGVyZSBpcyBqdXN0IG9uZSBsaW5rLCBkcmF3IGl0IGRpcmVjdGx5XG4gICAgaWYgKGFsbExpbmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVpbGRQYXRoKFxuICAgICAgICAgICAgY3JlYXRlTGluZXMoc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZSksXG4gICAgICAgICAgICBqdW1wU2l6ZSwganVtcFR5cGUsIHJhZGl1c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciB0aGlzTW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHZhciB0aGlzSW5kZXggPSBhbGxMaW5rcy5pbmRleE9mKHRoaXNNb2RlbCk7XG4gICAgdmFyIGRlZmF1bHRDb25uZWN0b3IgPSBwYXBlci5vcHRpb25zLmRlZmF1bHRDb25uZWN0b3IgfHwge307XG5cbiAgICAvLyBub3QgYWxsIGxpbmtzIGFyZSBtZWFudCB0byBiZSBqdW1wZWQgb3Zlci5cbiAgICB2YXIgbGlua3MgPSBhbGxMaW5rcy5maWx0ZXIoZnVuY3Rpb24obGluaywgaWR4KSB7XG5cbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IGxpbmsuZ2V0KCdjb25uZWN0b3InKSB8fCBkZWZhdWx0Q29ubmVjdG9yO1xuXG4gICAgICAgIC8vIGF2b2lkIGp1bXBpbmcgb3ZlciBsaW5rcyB3aXRoIGNvbm5lY3RvciB0eXBlIGxpc3RlZCBpbiBgaWdub3JlZCBjb25uZWN0b3JzYC5cbiAgICAgICAgaWYgKHV0aWwudG9BcnJheShpZ25vcmVDb25uZWN0b3JzKS5pbmNsdWRlcyhjb25uZWN0b3IubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaWx0ZXIgb3V0IGxpbmtzIHRoYXQgYXJlIGFib3ZlIHRoaXMgb25lIGFuZCAgaGF2ZSB0aGUgc2FtZSBjb25uZWN0b3IgdHlwZVxuICAgICAgICAvLyBvdGhlcndpc2UgdGhlcmUgd291bGQgZG91YmxlIGhvb3BzIGZvciBlYWNoIGludGVyc2VjdGlvblxuICAgICAgICBpZiAoaWR4ID4gdGhpc0luZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdG9yLm5hbWUgIT09ICdqdW1wb3Zlcic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBmaW5kIHZpZXdzIGZvciBhbGwgbGlua3NcbiAgICB2YXIgbGlua1ZpZXdzID0gbGlua3MubWFwKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgcmV0dXJuIHBhcGVyLmZpbmRWaWV3QnlNb2RlbChsaW5rKTtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSBsaW5lcyBmb3IgdGhpcyBsaW5rXG4gICAgdmFyIHRoaXNMaW5lcyA9IGNyZWF0ZUxpbmVzKFxuICAgICAgICBzb3VyY2VQb2ludCxcbiAgICAgICAgdGFyZ2V0UG9pbnQsXG4gICAgICAgIHJvdXRlXG4gICAgKTtcblxuICAgIC8vIGNyZWF0ZSBsaW5lcyBmb3IgYWxsIG90aGVyIGxpbmtzXG4gICAgdmFyIGxpbmtMaW5lcyA9IGxpbmtWaWV3cy5tYXAoZnVuY3Rpb24obGlua1ZpZXcpIHtcbiAgICAgICAgaWYgKGxpbmtWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlua1ZpZXcgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzTGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxpbmVzKFxuICAgICAgICAgICAgbGlua1ZpZXcuc291cmNlUG9pbnQsXG4gICAgICAgICAgICBsaW5rVmlldy50YXJnZXRQb2ludCxcbiAgICAgICAgICAgIGxpbmtWaWV3LnJvdXRlXG4gICAgICAgICk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyB0cmFuc2Zvcm0gbGluZXMgZm9yIHRoaXMgbGluayBieSBzcGxpdHRpbmcgd2l0aCBqdW1wIGxpbmVzIGF0XG4gICAgLy8gcG9pbnRzIG9mIGludGVyc2VjdGlvbiB3aXRoIG90aGVyIGxpbmtzXG4gICAgdmFyIGp1bXBpbmdMaW5lcyA9IHRoaXNMaW5lcy5yZWR1Y2UoZnVuY3Rpb24ocmVzdWx0TGluZXMsIHRoaXNMaW5lKSB7XG4gICAgICAgIC8vIGl0ZXJhdGUgYWxsIGxpbmtzIGFuZCBncmFiIHRoZSBpbnRlcnNlY3Rpb25zIHdpdGggdGhpcyBsaW5lXG4gICAgICAgIC8vIHRoZXNlIGFyZSB0aGVuIHNvcnRlZCBieSBkaXN0YW5jZSBzbyB0aGUgbGluZSBjYW4gYmUgc3BsaXQgbW9yZSBlYXNpbHlcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBsaW5rcy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBsaW5rLCBpKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBpbnRlcnNlY3Rpb24gd2l0aCBpdHNlbGZcbiAgICAgICAgICAgIGlmIChsaW5rICE9PSB0aGlzTW9kZWwpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtMaW5lc1RvVGVzdCA9IGxpbmtMaW5lc1tpXS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBJbmRleCA9IGxpbmtMaW5lc1RvVGVzdC5maW5kSW5kZXgoKGxpbmUpID0+IG92ZXJsYXBFeGlzdHModGhpc0xpbmUsIGxpbmUpKTtcblxuICAgICAgICAgICAgICAgIC8vIE92ZXJsYXAgb2NjdXJzIGFuZCB0aGUgZW5kIHBvaW50IG9mIG9uZSBzZWdtZW50IGxpZXMgb24gdGhpc0xpbmVcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcEluZGV4ID4gLTEgJiYgdGhpc0xpbmUuY29udGFpbnNQb2ludChsaW5rTGluZXNUb1Rlc3Rbb3ZlcmxhcEluZGV4XS5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbmV4dCBzZWdtZW50IGJlY2F1c2UgdGhlcmUgd2lsbCBuZXZlciBiZSBhIGp1bXBcbiAgICAgICAgICAgICAgICAgICAgbGlua0xpbmVzVG9UZXN0LnNwbGljZShvdmVybGFwSW5kZXggKyAxLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZUludGVyc2VjdGlvbnMgPSBmaW5kTGluZUludGVyc2VjdGlvbnModGhpc0xpbmUsIGxpbmtMaW5lc1RvVGVzdCk7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBsaW5lSW50ZXJzZWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LCBbXSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydFBvaW50cyh0aGlzTGluZS5zdGFydCwgYSkgLSBzb3J0UG9pbnRzKHRoaXNMaW5lLnN0YXJ0LCBiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgdGhlIGxpbmUgYmFzZWQgb24gZm91bmQgaW50ZXJzZWN0aW9uIHBvaW50c1xuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaC5hcHBseShyZXN1bHRMaW5lcywgY3JlYXRlSnVtcHModGhpc0xpbmUsIGludGVyc2VjdGlvbnMsIGp1bXBTaXplKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3aXRob3V0IGFueSBpbnRlcnNlY3Rpb24gdGhlIGxpbmUgZ29lcyB1bmludGVycnVwdGVkXG4gICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXNMaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0TGluZXM7XG4gICAgfSwgW10pO1xuXG4gICAgdmFyIHBhdGggPSBidWlsZFBhdGgoanVtcGluZ0xpbmVzLCBqdW1wU2l6ZSwganVtcFR5cGUsIHJhZGl1cyk7XG4gICAgcmV0dXJuIChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/jumpover.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/normal.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/normal.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: function() { return /* binding */ normal; }\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/straight.mjs\");\n\n\nconst normal = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { raw } = opt;\n    const localOpt = {\n        cornerType: 'point',\n        raw\n    };\n\n    return (0,_straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)(sourcePoint, targetPoint, route, localOpt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9ub3JtYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDOztBQUVuQyxzRUFBc0U7O0FBRTdFLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHVEQUFRO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9ub3JtYWwubWpzPzAzNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyYWlnaHQgfSBmcm9tICcuL3N0cmFpZ2h0Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBub3JtYWwgPSBmdW5jdGlvbihzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlID0gW10sIG9wdCA9IHt9KSB7XG5cbiAgICBjb25zdCB7IHJhdyB9ID0gb3B0O1xuICAgIGNvbnN0IGxvY2FsT3B0ID0ge1xuICAgICAgICBjb3JuZXJUeXBlOiAncG9pbnQnLFxuICAgICAgICByYXdcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cmFpZ2h0KHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUsIGxvY2FsT3B0KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/normal.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/rounded.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/rounded.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rounded: function() { return /* binding */ rounded; }\n/* harmony export */ });\n/* harmony import */ var _straight_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./straight.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/straight.mjs\");\n\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 0;\n\nconst rounded = function(sourcePoint, targetPoint, route = [], opt = {}) {\n\n    const { radius = CORNER_RADIUS, raw } = opt;\n    const localOpt = {\n        cornerType: 'cubic',\n        cornerRadius: radius,\n        precision: PRECISION,\n        raw\n    };\n\n    return (0,_straight_mjs__WEBPACK_IMPORTED_MODULE_0__.straight)(sourcePoint, targetPoint, route, localOpt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9yb3VuZGVkLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUM7QUFDQTs7QUFFTyx1RUFBdUU7O0FBRTlFLFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLHVEQUFRO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9yb3VuZGVkLm1qcz9mYzZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN0cmFpZ2h0IH0gZnJvbSAnLi9zdHJhaWdodC5tanMnO1xuXG5jb25zdCBDT1JORVJfUkFESVVTID0gMTA7XG5jb25zdCBQUkVDSVNJT04gPSAwO1xuXG5leHBvcnQgY29uc3Qgcm91bmRlZCA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUgPSBbXSwgb3B0ID0ge30pIHtcblxuICAgIGNvbnN0IHsgcmFkaXVzID0gQ09STkVSX1JBRElVUywgcmF3IH0gPSBvcHQ7XG4gICAgY29uc3QgbG9jYWxPcHQgPSB7XG4gICAgICAgIGNvcm5lclR5cGU6ICdjdWJpYycsXG4gICAgICAgIGNvcm5lclJhZGl1czogcmFkaXVzLFxuICAgICAgICBwcmVjaXNpb246IFBSRUNJU0lPTixcbiAgICAgICAgcmF3XG4gICAgfTtcblxuICAgIHJldHVybiBzdHJhaWdodChzb3VyY2VQb2ludCwgdGFyZ2V0UG9pbnQsIHJvdXRlLCBsb2NhbE9wdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/rounded.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/smooth.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/smooth.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   smooth: function() { return /* binding */ smooth; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n\n\nconst smooth = function(sourcePoint, targetPoint, route, opt) {\n\n    var raw = opt && opt.raw;\n    var path;\n\n    if (route && route.length !== 0) {\n\n        var points = [sourcePoint].concat(route).concat([targetPoint]);\n        var curves = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Curve.throughPoints(points);\n\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(curves);\n\n    } else {\n        // if we have no route, use a default cubic bezier curve\n        // cubic bezier requires two control points\n        // the control points have `x` midway between source and target\n        // this produces an S-like curve\n\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path();\n\n        var segment;\n\n        segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('M', sourcePoint);\n        path.appendSegment(segment);\n\n        if ((Math.abs(sourcePoint.x - targetPoint.x)) >= (Math.abs(sourcePoint.y - targetPoint.y))) {\n            var controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n\n            segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        } else {\n            var controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n\n            segment = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y);\n            path.appendSegment(segment);\n\n        }\n    }\n\n    return (raw) ? path : path.serialize();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9zbW9vdGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQzs7QUFFN0I7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQiwrQ0FBTzs7QUFFNUIsbUJBQW1CLDhDQUFNOztBQUV6QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDhDQUFNOztBQUV6Qjs7QUFFQSxrQkFBa0IsOENBQU07QUFDeEI7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsOENBQU07QUFDNUI7O0FBRUEsVUFBVTtBQUNWOztBQUVBLHNCQUFzQiw4Q0FBTTtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0b3JzL3Ntb290aC5tanM/NDE2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcblxuZXhwb3J0IGNvbnN0IHNtb290aCA9IGZ1bmN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgcm91dGUsIG9wdCkge1xuXG4gICAgdmFyIHJhdyA9IG9wdCAmJiBvcHQucmF3O1xuICAgIHZhciBwYXRoO1xuXG4gICAgaWYgKHJvdXRlICYmIHJvdXRlLmxlbmd0aCAhPT0gMCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBbc291cmNlUG9pbnRdLmNvbmNhdChyb3V0ZSkuY29uY2F0KFt0YXJnZXRQb2ludF0pO1xuICAgICAgICB2YXIgY3VydmVzID0gZy5DdXJ2ZS50aHJvdWdoUG9pbnRzKHBvaW50cyk7XG5cbiAgICAgICAgcGF0aCA9IG5ldyBnLlBhdGgoY3VydmVzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gcm91dGUsIHVzZSBhIGRlZmF1bHQgY3ViaWMgYmV6aWVyIGN1cnZlXG4gICAgICAgIC8vIGN1YmljIGJlemllciByZXF1aXJlcyB0d28gY29udHJvbCBwb2ludHNcbiAgICAgICAgLy8gdGhlIGNvbnRyb2wgcG9pbnRzIGhhdmUgYHhgIG1pZHdheSBiZXR3ZWVuIHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgICAgIC8vIHRoaXMgcHJvZHVjZXMgYW4gUy1saWtlIGN1cnZlXG5cbiAgICAgICAgcGF0aCA9IG5ldyBnLlBhdGgoKTtcblxuICAgICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBzb3VyY2VQb2ludCk7XG4gICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICBpZiAoKE1hdGguYWJzKHNvdXJjZVBvaW50LnggLSB0YXJnZXRQb2ludC54KSkgPj0gKE1hdGguYWJzKHNvdXJjZVBvaW50LnkgLSB0YXJnZXRQb2ludC55KSkpIHtcbiAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRYID0gKHNvdXJjZVBvaW50LnggKyB0YXJnZXRQb2ludC54KSAvIDI7XG5cbiAgICAgICAgICAgIHNlZ21lbnQgPSBnLlBhdGguY3JlYXRlU2VnbWVudCgnQycsIGNvbnRyb2xQb2ludFgsIHNvdXJjZVBvaW50LnksIGNvbnRyb2xQb2ludFgsIHRhcmdldFBvaW50LnksIHRhcmdldFBvaW50LngsIHRhcmdldFBvaW50LnkpO1xuICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFBvaW50WSA9IChzb3VyY2VQb2ludC55ICsgdGFyZ2V0UG9pbnQueSkgLyAyO1xuXG4gICAgICAgICAgICBzZWdtZW50ID0gZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBzb3VyY2VQb2ludC54LCBjb250cm9sUG9pbnRZLCB0YXJnZXRQb2ludC54LCBjb250cm9sUG9pbnRZLCB0YXJnZXRQb2ludC54LCB0YXJnZXRQb2ludC55KTtcbiAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChyYXcpID8gcGF0aCA6IHBhdGguc2VyaWFsaXplKCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/smooth.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/connectors/straight.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/connectors/straight.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   straight: function() { return /* binding */ straight; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\nconst CornerTypes = {\n    POINT: 'point',\n    CUBIC: 'cubic',\n    LINE: 'line',\n    GAP: 'gap'\n};\n\nconst DEFINED_CORNER_TYPES = Object.values(CornerTypes);\n\nconst CORNER_RADIUS = 10;\nconst PRECISION = 1;\n\nconst straight = function(sourcePoint, targetPoint, routePoints = [], opt = {}) {\n\n    const {\n        cornerType = CornerTypes.POINT,\n        cornerRadius = CORNER_RADIUS,\n        cornerPreserveAspectRatio = false,\n        precision = PRECISION,\n        raw = false\n    } = opt;\n\n    if (DEFINED_CORNER_TYPES.indexOf(cornerType) === -1) {\n        // unknown `cornerType` provided => error\n        throw new Error('Invalid `cornerType` provided to `straight` connector.');\n    }\n\n    let path;\n\n    if ((cornerType === CornerTypes.POINT) || !cornerRadius) {\n        // default option => normal connector\n        // simply connect all points with straight lines\n        const points = [sourcePoint].concat(routePoints).concat([targetPoint]);\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Polyline(points);\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(polyline);\n\n    } else {\n        // `cornerType` is not unknown and not 'point' (default) => must be one of other valid types\n        path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path();\n\n        // add initial gap segment = to source point\n        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('M', sourcePoint));\n\n        let nextDistance;\n        const routePointsLength = routePoints.length;\n        for (let i = 0; i < routePointsLength; i++) {\n\n            const curr = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(routePoints[i]);\n            const prev = (routePoints[i - 1] || sourcePoint);\n            const next = (routePoints[i + 1] || targetPoint);\n            const prevDistance = (nextDistance || (curr.distance(prev) / 2)); // try to re-use previously-computed `nextDistance`\n            nextDistance = (curr.distance(next) / 2);\n\n            let startMove, endMove;\n            if (!cornerPreserveAspectRatio) {\n                // `startMove` and `endMove` may be different\n                // (this happens when next or previous path point is closer than `2 * cornerRadius`)\n                startMove = -Math.min(cornerRadius, prevDistance);\n                endMove = -Math.min(cornerRadius, nextDistance);\n            } else {\n                // force `startMove` and `endMove` to be the same\n                startMove = endMove = -Math.min(cornerRadius, prevDistance, nextDistance);\n            }\n\n            // to find `cornerStart` and `cornerEnd`, the logic is as follows (using `cornerStart` as example):\n            // - find a point lying on the line `prev - startMove` such that...\n            // - ...the point lies `abs(startMove)` distance away from `curr`...\n            // - ...and its coordinates are rounded to whole numbers\n            const cornerStart = curr.clone().move(prev, startMove).round(precision);\n            const cornerEnd = curr.clone().move(next, endMove).round(precision);\n\n            // add in-between straight segment = from previous route point to corner start point\n            // (may have zero length)\n            path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('L', cornerStart));\n\n            // add corner segment = from corner start point to corner end point\n            switch (cornerType) {\n                case CornerTypes.CUBIC: {\n                    // corner is rounded\n                    const _13 = (1 / 3);\n                    const _23 = (2 / 3);\n                    const control1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point((_13 * cornerStart.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerStart.y));\n                    const control2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point((_13 * cornerEnd.x) + (_23 * curr.x), (_23 * curr.y) + (_13 * cornerEnd.y));\n                    path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('C', control1, control2, cornerEnd));\n                    break;\n                }\n                case CornerTypes.LINE: {\n                    // corner has bevel\n                    path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('L', cornerEnd));\n                    break;\n                }\n                case CornerTypes.GAP: {\n                    // corner has empty space\n                    path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('M', cornerEnd));\n                    break;\n                }\n                // default: no segment is created\n            }\n        }\n\n        // add final straight segment = from last corner end point to target point\n        // (= or from start point to end point, if there are no route points)\n        // (may have zero length)\n        path.appendSegment(_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path.createSegment('L', targetPoint));\n    }\n\n    return ((raw) ? path : path.serialize());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29ubmVjdG9ycy9zdHJhaWdodC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRU8sOEVBQThFOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFVO0FBQ3ZDLG1CQUFtQiw4Q0FBTTs7QUFFekIsTUFBTTtBQUNOO0FBQ0EsbUJBQW1CLDhDQUFNOztBQUV6QjtBQUNBLDJCQUEyQiw4Q0FBTTs7QUFFakM7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7O0FBRS9DLDZCQUE2QiwrQ0FBTztBQUNwQztBQUNBO0FBQ0EsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsOENBQU07O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQ0FBTztBQUNoRCx5Q0FBeUMsK0NBQU87QUFDaEQsdUNBQXVDLDhDQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhDQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDhDQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFNO0FBQ2pDOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb25uZWN0b3JzL3N0cmFpZ2h0Lm1qcz9jNzI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5jb25zdCBDb3JuZXJUeXBlcyA9IHtcbiAgICBQT0lOVDogJ3BvaW50JyxcbiAgICBDVUJJQzogJ2N1YmljJyxcbiAgICBMSU5FOiAnbGluZScsXG4gICAgR0FQOiAnZ2FwJ1xufTtcblxuY29uc3QgREVGSU5FRF9DT1JORVJfVFlQRVMgPSBPYmplY3QudmFsdWVzKENvcm5lclR5cGVzKTtcblxuY29uc3QgQ09STkVSX1JBRElVUyA9IDEwO1xuY29uc3QgUFJFQ0lTSU9OID0gMTtcblxuZXhwb3J0IGNvbnN0IHN0cmFpZ2h0ID0gZnVuY3Rpb24oc291cmNlUG9pbnQsIHRhcmdldFBvaW50LCByb3V0ZVBvaW50cyA9IFtdLCBvcHQgPSB7fSkge1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjb3JuZXJUeXBlID0gQ29ybmVyVHlwZXMuUE9JTlQsXG4gICAgICAgIGNvcm5lclJhZGl1cyA9IENPUk5FUl9SQURJVVMsXG4gICAgICAgIGNvcm5lclByZXNlcnZlQXNwZWN0UmF0aW8gPSBmYWxzZSxcbiAgICAgICAgcHJlY2lzaW9uID0gUFJFQ0lTSU9OLFxuICAgICAgICByYXcgPSBmYWxzZVxuICAgIH0gPSBvcHQ7XG5cbiAgICBpZiAoREVGSU5FRF9DT1JORVJfVFlQRVMuaW5kZXhPZihjb3JuZXJUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gdW5rbm93biBgY29ybmVyVHlwZWAgcHJvdmlkZWQgPT4gZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGBjb3JuZXJUeXBlYCBwcm92aWRlZCB0byBgc3RyYWlnaHRgIGNvbm5lY3Rvci4nKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aDtcblxuICAgIGlmICgoY29ybmVyVHlwZSA9PT0gQ29ybmVyVHlwZXMuUE9JTlQpIHx8ICFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBvcHRpb24gPT4gbm9ybWFsIGNvbm5lY3RvclxuICAgICAgICAvLyBzaW1wbHkgY29ubmVjdCBhbGwgcG9pbnRzIHdpdGggc3RyYWlnaHQgbGluZXNcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW3NvdXJjZVBvaW50XS5jb25jYXQocm91dGVQb2ludHMpLmNvbmNhdChbdGFyZ2V0UG9pbnRdKTtcbiAgICAgICAgY29uc3QgcG9seWxpbmUgPSBuZXcgZy5Qb2x5bGluZShwb2ludHMpO1xuICAgICAgICBwYXRoID0gbmV3IGcuUGF0aChwb2x5bGluZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgY29ybmVyVHlwZWAgaXMgbm90IHVua25vd24gYW5kIG5vdCAncG9pbnQnIChkZWZhdWx0KSA9PiBtdXN0IGJlIG9uZSBvZiBvdGhlciB2YWxpZCB0eXBlc1xuICAgICAgICBwYXRoID0gbmV3IGcuUGF0aCgpO1xuXG4gICAgICAgIC8vIGFkZCBpbml0aWFsIGdhcCBzZWdtZW50ID0gdG8gc291cmNlIHBvaW50XG4gICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChnLlBhdGguY3JlYXRlU2VnbWVudCgnTScsIHNvdXJjZVBvaW50KSk7XG5cbiAgICAgICAgbGV0IG5leHREaXN0YW5jZTtcbiAgICAgICAgY29uc3Qgcm91dGVQb2ludHNMZW5ndGggPSByb3V0ZVBvaW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVQb2ludHNMZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBjb25zdCBjdXJyID0gbmV3IGcuUG9pbnQocm91dGVQb2ludHNbaV0pO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IChyb3V0ZVBvaW50c1tpIC0gMV0gfHwgc291cmNlUG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IChyb3V0ZVBvaW50c1tpICsgMV0gfHwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgcHJldkRpc3RhbmNlID0gKG5leHREaXN0YW5jZSB8fCAoY3Vyci5kaXN0YW5jZShwcmV2KSAvIDIpKTsgLy8gdHJ5IHRvIHJlLXVzZSBwcmV2aW91c2x5LWNvbXB1dGVkIGBuZXh0RGlzdGFuY2VgXG4gICAgICAgICAgICBuZXh0RGlzdGFuY2UgPSAoY3Vyci5kaXN0YW5jZShuZXh0KSAvIDIpO1xuXG4gICAgICAgICAgICBsZXQgc3RhcnRNb3ZlLCBlbmRNb3ZlO1xuICAgICAgICAgICAgaWYgKCFjb3JuZXJQcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgLy8gYHN0YXJ0TW92ZWAgYW5kIGBlbmRNb3ZlYCBtYXkgYmUgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgLy8gKHRoaXMgaGFwcGVucyB3aGVuIG5leHQgb3IgcHJldmlvdXMgcGF0aCBwb2ludCBpcyBjbG9zZXIgdGhhbiBgMiAqIGNvcm5lclJhZGl1c2ApXG4gICAgICAgICAgICAgICAgc3RhcnRNb3ZlID0gLU1hdGgubWluKGNvcm5lclJhZGl1cywgcHJldkRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBlbmRNb3ZlID0gLU1hdGgubWluKGNvcm5lclJhZGl1cywgbmV4dERpc3RhbmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgYHN0YXJ0TW92ZWAgYW5kIGBlbmRNb3ZlYCB0byBiZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIHN0YXJ0TW92ZSA9IGVuZE1vdmUgPSAtTWF0aC5taW4oY29ybmVyUmFkaXVzLCBwcmV2RGlzdGFuY2UsIG5leHREaXN0YW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRvIGZpbmQgYGNvcm5lclN0YXJ0YCBhbmQgYGNvcm5lckVuZGAsIHRoZSBsb2dpYyBpcyBhcyBmb2xsb3dzICh1c2luZyBgY29ybmVyU3RhcnRgIGFzIGV4YW1wbGUpOlxuICAgICAgICAgICAgLy8gLSBmaW5kIGEgcG9pbnQgbHlpbmcgb24gdGhlIGxpbmUgYHByZXYgLSBzdGFydE1vdmVgIHN1Y2ggdGhhdC4uLlxuICAgICAgICAgICAgLy8gLSAuLi50aGUgcG9pbnQgbGllcyBgYWJzKHN0YXJ0TW92ZSlgIGRpc3RhbmNlIGF3YXkgZnJvbSBgY3VycmAuLi5cbiAgICAgICAgICAgIC8vIC0gLi4uYW5kIGl0cyBjb29yZGluYXRlcyBhcmUgcm91bmRlZCB0byB3aG9sZSBudW1iZXJzXG4gICAgICAgICAgICBjb25zdCBjb3JuZXJTdGFydCA9IGN1cnIuY2xvbmUoKS5tb3ZlKHByZXYsIHN0YXJ0TW92ZSkucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcm5lckVuZCA9IGN1cnIuY2xvbmUoKS5tb3ZlKG5leHQsIGVuZE1vdmUpLnJvdW5kKHByZWNpc2lvbik7XG5cbiAgICAgICAgICAgIC8vIGFkZCBpbi1iZXR3ZWVuIHN0cmFpZ2h0IHNlZ21lbnQgPSBmcm9tIHByZXZpb3VzIHJvdXRlIHBvaW50IHRvIGNvcm5lciBzdGFydCBwb2ludFxuICAgICAgICAgICAgLy8gKG1heSBoYXZlIHplcm8gbGVuZ3RoKVxuICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KGcuUGF0aC5jcmVhdGVTZWdtZW50KCdMJywgY29ybmVyU3RhcnQpKTtcblxuICAgICAgICAgICAgLy8gYWRkIGNvcm5lciBzZWdtZW50ID0gZnJvbSBjb3JuZXIgc3RhcnQgcG9pbnQgdG8gY29ybmVyIGVuZCBwb2ludFxuICAgICAgICAgICAgc3dpdGNoIChjb3JuZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb3JuZXJUeXBlcy5DVUJJQzoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3JuZXIgaXMgcm91bmRlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBfMTMgPSAoMSAvIDMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBfMjMgPSAoMiAvIDMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sMSA9IG5ldyBnLlBvaW50KChfMTMgKiBjb3JuZXJTdGFydC54KSArIChfMjMgKiBjdXJyLngpLCAoXzIzICogY3Vyci55KSArIChfMTMgKiBjb3JuZXJTdGFydC55KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wyID0gbmV3IGcuUG9pbnQoKF8xMyAqIGNvcm5lckVuZC54KSArIChfMjMgKiBjdXJyLngpLCAoXzIzICogY3Vyci55KSArIChfMTMgKiBjb3JuZXJFbmQueSkpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0MnLCBjb250cm9sMSwgY29udHJvbDIsIGNvcm5lckVuZCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb3JuZXJUeXBlcy5MSU5FOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcm5lciBoYXMgYmV2ZWxcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KGcuUGF0aC5jcmVhdGVTZWdtZW50KCdMJywgY29ybmVyRW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENvcm5lclR5cGVzLkdBUDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb3JuZXIgaGFzIGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChnLlBhdGguY3JlYXRlU2VnbWVudCgnTScsIGNvcm5lckVuZCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdDogbm8gc2VnbWVudCBpcyBjcmVhdGVkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgZmluYWwgc3RyYWlnaHQgc2VnbWVudCA9IGZyb20gbGFzdCBjb3JuZXIgZW5kIHBvaW50IHRvIHRhcmdldCBwb2ludFxuICAgICAgICAvLyAoPSBvciBmcm9tIHN0YXJ0IHBvaW50IHRvIGVuZCBwb2ludCwgaWYgdGhlcmUgYXJlIG5vIHJvdXRlIHBvaW50cylcbiAgICAgICAgLy8gKG1heSBoYXZlIHplcm8gbGVuZ3RoKVxuICAgICAgICBwYXRoLmFwcGVuZFNlZ21lbnQoZy5QYXRoLmNyZWF0ZVNlZ21lbnQoJ0wnLCB0YXJnZXRQb2ludCkpO1xuICAgIH1cblxuICAgIHJldHVybiAoKHJhdykgPyBwYXRoIDogcGF0aC5zZXJpYWxpemUoKSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/connectors/straight.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/core.mjs":
/*!***********************************************!*\
  !*** ./node_modules/@joint/core/src/core.mjs ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   V: function() { return /* reexport safe */ _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   Vectorizer: function() { return /* binding */ Vectorizer; },\n/* harmony export */   anchors: function() { return /* reexport module object */ _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_6__; },\n/* harmony export */   config: function() { return /* reexport safe */ _config_index_mjs__WEBPACK_IMPORTED_MODULE_5__.config; },\n/* harmony export */   connectionPoints: function() { return /* reexport module object */ _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_8__; },\n/* harmony export */   connectionStrategies: function() { return /* reexport module object */ _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_9__; },\n/* harmony export */   connectors: function() { return /* reexport module object */ _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_10__; },\n/* harmony export */   dia: function() { return /* reexport module object */ _dia_index_mjs__WEBPACK_IMPORTED_MODULE_11__; },\n/* harmony export */   elementTools: function() { return /* reexport module object */ _elementTools_index_mjs__WEBPACK_IMPORTED_MODULE_17__; },\n/* harmony export */   env: function() { return /* reexport safe */ _env_index_mjs__WEBPACK_IMPORTED_MODULE_4__.env; },\n/* harmony export */   g: function() { return /* reexport module object */ _g_index_mjs__WEBPACK_IMPORTED_MODULE_18__; },\n/* harmony export */   highlighters: function() { return /* reexport module object */ _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_12__; },\n/* harmony export */   layout: function() { return /* binding */ layout; },\n/* harmony export */   linkAnchors: function() { return /* reexport module object */ _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__; },\n/* harmony export */   linkTools: function() { return /* reexport module object */ _linkTools_index_mjs__WEBPACK_IMPORTED_MODULE_16__; },\n/* harmony export */   mvc: function() { return /* reexport module object */ _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_13__; },\n/* harmony export */   routers: function() { return /* reexport module object */ _routers_index_mjs__WEBPACK_IMPORTED_MODULE_14__; },\n/* harmony export */   setTheme: function() { return /* binding */ setTheme; },\n/* harmony export */   util: function() { return /* reexport module object */ _util_index_mjs__WEBPACK_IMPORTED_MODULE_15__; },\n/* harmony export */   version: function() { return /* reexport safe */ _dist_version_mjs__WEBPACK_IMPORTED_MODULE_0__.version; }\n/* harmony export */ });\n/* harmony import */ var _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./connectors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/index.mjs\");\n/* harmony import */ var _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./highlighters/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/index.mjs\");\n/* harmony import */ var _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./connectionPoints/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectionPoints/index.mjs\");\n/* harmony import */ var _connectionStrategies_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./connectionStrategies/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectionStrategies/index.mjs\");\n/* harmony import */ var _routers_index_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./routers/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/index.mjs\");\n/* harmony import */ var _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./anchors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/anchors/index.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./linkAnchors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n/* harmony import */ var _dia_index_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dia/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/index.mjs\");\n/* harmony import */ var _linkTools_index_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./linkTools/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/index.mjs\");\n/* harmony import */ var _elementTools_index_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./elementTools/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/elementTools/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/index.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./layout/ports/port.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/port.mjs\");\n/* harmony import */ var _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layout/ports/portLabel.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs\");\n/* harmony import */ var _dist_version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/version.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/dist/version.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/env/index.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Vectorizer = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\nconst layout = { PortLabel: _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__, Port: _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_3__ };\n\n\nconst setTheme = function(theme, opt) {\n\n    opt = opt || {};\n\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_19__.invoke(_mvc_index_mjs__WEBPACK_IMPORTED_MODULE_20__.views, 'setTheme', theme, opt);\n\n    // Update the default theme on the view prototype.\n    _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_20__.View.prototype.defaultTheme = theme;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvY29yZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUQ7QUFDSTtBQUNRO0FBQ1E7QUFDMUI7QUFDQTtBQUNRO0FBQ2hCO0FBQ1k7QUFDTTtBQUNoQjtBQUNGO0FBQ0o7QUFDUztBQUNkO0FBQ2tCO0FBQ1U7O0FBRXRCO0FBQzdCLG1CQUFtQixvREFBQztBQUNwQixpQkFBaUIsU0FBUyxnRUFBTTtBQUNEO0FBaUJwQztBQUNLOztBQUVQOztBQUVBLElBQUksb0RBQVcsQ0FBQyxrREFBUzs7QUFFekI7QUFDQSxJQUFJLGlEQUFRO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9jb3JlLm1qcz82NGQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvbm5lY3RvcnMgZnJvbSAnLi9jb25uZWN0b3JzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBoaWdobGlnaHRlcnMgZnJvbSAnLi9oaWdobGlnaHRlcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGNvbm5lY3Rpb25Qb2ludHMgZnJvbSAnLi9jb25uZWN0aW9uUG9pbnRzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBjb25uZWN0aW9uU3RyYXRlZ2llcyBmcm9tICcuL2Nvbm5lY3Rpb25TdHJhdGVnaWVzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyByb3V0ZXJzIGZyb20gJy4vcm91dGVycy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgYW5jaG9ycyBmcm9tICcuL2FuY2hvcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGxpbmtBbmNob3JzIGZyb20gJy4vbGlua0FuY2hvcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGRpYSBmcm9tICcuL2RpYS9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgbGlua1Rvb2xzIGZyb20gJy4vbGlua1Rvb2xzL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBlbGVtZW50VG9vbHMgZnJvbSAnLi9lbGVtZW50VG9vbHMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBtdmMgZnJvbSAnLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZy9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyBQb3J0IGZyb20gJy4vbGF5b3V0L3BvcnRzL3BvcnQubWpzJztcbmltcG9ydCAqIGFzIFBvcnRMYWJlbCBmcm9tICcuL2xheW91dC9wb3J0cy9wb3J0TGFiZWwubWpzJztcblxuZXhwb3J0ICogZnJvbSAnLi4vZGlzdC92ZXJzaW9uLm1qcyc7XG5leHBvcnQgY29uc3QgVmVjdG9yaXplciA9IFY7XG5leHBvcnQgY29uc3QgbGF5b3V0ID0geyBQb3J0TGFiZWwsIFBvcnQgfTtcbmV4cG9ydCB7IGVudiB9IGZyb20gJy4vZW52L2luZGV4Lm1qcyc7XG5leHBvcnQge1xuICAgIGNvbmZpZyxcbiAgICBhbmNob3JzLFxuICAgIGxpbmtBbmNob3JzLFxuICAgIGNvbm5lY3Rpb25Qb2ludHMsXG4gICAgY29ubmVjdGlvblN0cmF0ZWdpZXMsXG4gICAgY29ubmVjdG9ycyxcbiAgICBkaWEsXG4gICAgaGlnaGxpZ2h0ZXJzLFxuICAgIG12YyxcbiAgICByb3V0ZXJzLFxuICAgIHV0aWwsXG4gICAgbGlua1Rvb2xzLFxuICAgIGVsZW1lbnRUb29scyxcbiAgICBWLFxuICAgIGdcbn07XG5leHBvcnQgY29uc3Qgc2V0VGhlbWUgPSBmdW5jdGlvbih0aGVtZSwgb3B0KSB7XG5cbiAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICB1dGlsLmludm9rZShtdmMudmlld3MsICdzZXRUaGVtZScsIHRoZW1lLCBvcHQpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBkZWZhdWx0IHRoZW1lIG9uIHRoZSB2aWV3IHByb3RvdHlwZS5cbiAgICBtdmMuVmlldy5wcm90b3R5cGUuZGVmYXVsdFRoZW1lID0gdGhlbWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/core.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Cell.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: function() { return /* binding */ Cell; }\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mvc/Model.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _util_cloneCells_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/cloneCells.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/cloneCells.mjs\");\n/* harmony import */ var _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attributes/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n\n\n\n\n\n\n\n// Cell base model.\n// --------------------------\n\nconst attributesMerger = function(a, b) {\n    if (Array.isArray(a)) {\n        return b;\n    }\n};\n\nfunction removeEmptyAttributes(obj) {\n\n    // Remove toplevel empty attributes\n    for (const key in obj) {\n\n        const objValue = obj[key];\n        const isRealObject = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(objValue) && !Array.isArray(objValue);\n\n        if (!isRealObject) continue;\n\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(objValue)) {\n            delete obj[key];\n        }\n    }\n}\n\nconst Cell = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_1__.Model.extend({\n\n    // This is the same as mvc.Model with the only difference that is uses util.merge\n    // instead of just _.extend. The reason is that we want to mixin attributes set in upper classes.\n    constructor: function(attributes, options) {\n\n        var defaults;\n        var attrs = attributes || {};\n        if (typeof this.preinitialize === 'function') {\n            // Check to support an older version\n            this.preinitialize.apply(this, arguments);\n        }\n        this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('c');\n        this.attributes = {};\n        if (options && options.collection) this.collection = options.collection;\n        if (options && options.parse) attrs = this.parse(attrs, options) || {};\n        if ((defaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'defaults'))) {\n            //<custom code>\n            // Replaced the call to _.defaults with util.merge.\n            const customizer = (options && options.mergeArrays === true) ? false : attributesMerger;\n            attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)({}, defaults, attrs, customizer);\n            //</custom code>\n        }\n        this.set(attrs, options);\n        this.changed = {};\n        this.initialize.apply(this, arguments);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        throw new Error('Must define a translate() method.');\n    },\n\n    toJSON: function(opt) {\n\n        const { ignoreDefaults, ignoreEmptyAttributes = false } = opt || {};\n        const defaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this.constructor.prototype, 'defaults');\n\n        if (ignoreDefaults === false) {\n            // Return all attributes without omitting the defaults\n            const finalAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(this.attributes);\n\n            if (!ignoreEmptyAttributes) return finalAttributes;\n\n            removeEmptyAttributes(finalAttributes);\n\n            return finalAttributes;\n        }\n\n        let defaultAttributes = {};\n        let attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(this.attributes);\n\n        if (ignoreDefaults === true) {\n            // Compare all attributes with the defaults\n            defaultAttributes = defaults;\n        } else {\n            // Compare only the specified attributes with the defaults, use `attrs` as a default if not specified\n            const differentiateKeys = Array.isArray(ignoreDefaults) ? ignoreDefaults : ['attrs'];\n\n            differentiateKeys.forEach((key) => {\n                defaultAttributes[key] = defaults[key] || {};\n            });\n        }\n\n        // Omit `id` and `type` attribute from the defaults since it should be always present\n        const finalAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.objectDifference)(attributes, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.omit)(defaultAttributes, 'id', 'type'), { maxDepth: 4 });\n\n        if (ignoreEmptyAttributes) {\n            removeEmptyAttributes(finalAttributes);\n        }\n\n        return finalAttributes;\n    },\n\n    initialize: function(options) {\n\n        const idAttribute = this.getIdAttribute();\n        if (!options || options[idAttribute] === undefined) {\n            this.set(idAttribute, this.generateId(), { silent: true });\n        }\n\n        this._transitionIds = {};\n        this._scheduledTransitionIds = {};\n\n        // Collect ports defined in `attrs` and keep collecting whenever `attrs` object changes.\n        this.processPorts();\n        this.on('change:attrs', this.processPorts, this);\n    },\n\n    getIdAttribute: function() {\n        return this.idAttribute || 'id';\n    },\n\n    generateId: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.uuid)();\n    },\n\n    /**\n     * @deprecated\n     */\n    processPorts: function() {\n\n        // Whenever `attrs` changes, we extract ports from the `attrs` object and store it\n        // in a more accessible way. Also, if any port got removed and there were links that had `target`/`source`\n        // set to that port, we remove those links as well (to follow the same behaviour as\n        // with a removed element).\n\n        var previousPorts = this.ports;\n\n        // Collect ports from the `attrs` object.\n        var ports = {};\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.forIn)(this.get('attrs'), function(attrs, selector) {\n\n            if (attrs && attrs.port) {\n\n                // `port` can either be directly an `id` or an object containing an `id` (and potentially other data).\n                if (attrs.port.id !== undefined) {\n                    ports[attrs.port.id] = attrs.port;\n                } else {\n                    ports[attrs.port] = { id: attrs.port };\n                }\n            }\n        });\n\n        // Collect ports that have been removed (compared to the previous ports) - if any.\n        // Use hash table for quick lookup.\n        var removedPorts = {};\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.forIn)(previousPorts, function(port, id) {\n\n            if (!ports[id]) removedPorts[id] = true;\n        });\n\n        // Remove all the incoming/outgoing links that have source/target port set to any of the removed ports.\n        if (this.graph && !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(removedPorts)) {\n\n            var inboundLinks = this.graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = this.graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removedPorts[link.get('source').port]) link.remove();\n            });\n        }\n\n        // Update the `ports` object.\n        this.ports = ports;\n    },\n\n    remove: function(opt = {}) {\n\n        // Store the graph in a variable because `this.graph` won't be accessible\n        // after `this.trigger('remove', ...)` down below.\n        const { graph, collection } = this;\n        if (!graph) {\n            // The collection is a common mvc collection (not the graph collection).\n            if (collection) collection.remove(this, opt);\n            return this;\n        }\n\n        graph.startBatch('remove');\n\n        // First, unembed this cell from its parent cell if there is one.\n        const parentCell = this.getParentCell();\n        if (parentCell) {\n            parentCell.unembed(this, opt);\n        }\n\n        // Remove also all the cells, which were embedded into this cell\n        const embeddedCells = this.getEmbeddedCells();\n        for (let i = 0, n = embeddedCells.length; i < n; i++) {\n            const embed = embeddedCells[i];\n            if (embed) {\n                embed.remove(opt);\n            }\n        }\n\n        this.trigger('remove', this, graph.attributes.cells, opt);\n\n        graph.stopBatch('remove');\n\n        return this;\n    },\n\n    toFront: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults)(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy)(cells, cell => cell.z());\n\n            const maxZ = graph.maxZIndex();\n            let z = maxZ - cells.length + 1;\n\n            const collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== (collection.length - cells.length));\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-front');\n\n                z = z + cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-front');\n            }\n        }\n\n        return this;\n    },\n\n    toBack: function(opt) {\n        var graph = this.graph;\n        if (graph) {\n            opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults)(opt || {}, { foregroundEmbeds: true });\n\n            let cells;\n            if (opt.deep) {\n                cells = this.getEmbeddedCells({ deep: true, breadthFirst: opt.breadthFirst !== false, sortSiblings: opt.foregroundEmbeds });\n                cells.unshift(this);\n            } else {\n                cells = [this];\n            }\n\n            const sortedCells = opt.foregroundEmbeds ? cells : (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy)(cells, cell => cell.z());\n\n            let z = graph.minZIndex();\n\n            var collection = graph.get('cells');\n\n            let shouldUpdate = (collection.toArray().indexOf(sortedCells[0]) !== 0);\n            if (!shouldUpdate) {\n                shouldUpdate = sortedCells.some(function(cell, index) {\n                    return cell.z() !== z + index;\n                });\n            }\n\n            if (shouldUpdate) {\n                this.startBatch('to-back');\n\n                z -= cells.length;\n\n                sortedCells.forEach(function(cell, index) {\n                    cell.set('z', z + index, opt);\n                });\n\n                this.stopBatch('to-back');\n            }\n        }\n\n        return this;\n    },\n\n    parent: function(parent, opt) {\n\n        // getter\n        if (parent === undefined) return this.get('parent');\n        // setter\n        return this.set('parent', parent, opt);\n    },\n\n    embed: function(cell, opt = {}) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        if (!this.canEmbed(cells)) {\n            throw new Error('Recursive embedding not allowed.');\n        }\n        if (opt.reparent) {\n            const parents = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(cells.map(c => c.getParentCell()));\n\n            // Unembed cells from their current parents.\n            parents.forEach((parent) => {\n                // Cell doesn't have to be embedded.\n                if (!parent) return;\n\n                // Pass all the `cells` since the `dia.Cell._unembedCells` method can handle cases\n                // where not all elements of `cells` are embedded in the same parent.\n                parent._unembedCells(cells, opt);\n            });\n\n        } else if (cells.some(c => c.isEmbedded() && this.id !== c.parent())) {\n            throw new Error('Embedding of already embedded cells is not allowed.');\n        }\n        this._embedCells(cells, opt);\n        return this;\n    },\n\n    unembed: function(cell, opt) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        this._unembedCells(cells, opt);\n        return this;\n    },\n\n    canEmbed: function(cell) {\n        const cells = Array.isArray(cell) ? cell : [cell];\n        return cells.every(c => this !== c && !this.isEmbeddedIn(c));\n    },\n\n    _embedCells: function(cells, opt) {\n        const batchName = 'embed';\n        this.startBatch(batchName);\n        const embeds = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)([], this.get('embeds'));\n        cells.forEach(cell => {\n            // We keep all element ids after link ids.\n            embeds[cell.isLink() ? 'unshift' : 'push'](cell.id);\n            cell.parent(this.id, opt);\n        });\n        this.set('embeds', (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(embeds), opt);\n        this.stopBatch(batchName);\n    },\n\n    _unembedCells: function(cells, opt) {\n        const batchName = 'unembed';\n        this.startBatch(batchName);\n        cells.forEach(cell => cell.unset('parent', opt));\n        this.set('embeds', (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.without)(this.get('embeds'), ...cells.map(cell => cell.id)), opt);\n        this.stopBatch(batchName);\n    },\n\n    getParentCell: function() {\n\n        // unlike link.source/target, cell.parent stores id directly as a string\n        var parentId = this.parent();\n        var graph = this.graph;\n\n        return (parentId && graph && graph.getCell(parentId)) || null;\n    },\n\n    // Return an array of ancestor cells.\n    // The array is ordered from the parent of the cell\n    // to the most distant ancestor.\n    getAncestors: function() {\n\n        var ancestors = [];\n\n        if (!this.graph) {\n            return ancestors;\n        }\n\n        var parentCell = this.getParentCell();\n        while (parentCell) {\n            ancestors.push(parentCell);\n            parentCell = parentCell.getParentCell();\n        }\n\n        return ancestors;\n    },\n\n    getEmbeddedCells: function(opt) {\n\n        opt = opt || {};\n\n        // Cell models can only be retrieved when this element is part of a collection.\n        // There is no way this element knows about other cells otherwise.\n        // This also means that calling e.g. `translate()` on an element with embeds before\n        // adding it to a graph does not translate its embeds.\n        if (!this.graph) {\n            return [];\n        }\n\n        if (opt.deep) {\n            if (opt.breadthFirst) {\n                return this._getEmbeddedCellsBfs(opt.sortSiblings);\n            } else {\n                return this._getEmbeddedCellsDfs(opt.sortSiblings);\n            }\n        }\n\n        const embeddedIds = this.get('embeds');\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(embeddedIds)) {\n            return [];\n        }\n\n        let cells = embeddedIds.map(this.graph.getCell, this.graph);\n        if (opt.sortSiblings) {\n            cells = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy)(cells, cell => cell.z());\n        }\n\n        return cells;\n    },\n\n    _getEmbeddedCellsBfs: function(sortSiblings) {\n        const cells = [];\n\n        const queue = [];\n        queue.push(this);\n\n        while (queue.length > 0) {\n            const current = queue.shift();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            queue.push(...embeddedCells);\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    _getEmbeddedCellsDfs: function(sortSiblings) {\n        const cells = [];\n\n        const stack = [];\n        stack.push(this);\n\n        while (stack.length > 0) {\n            const current = stack.pop();\n            cells.push(current);\n\n            const embeddedCells = current.getEmbeddedCells({ sortSiblings: sortSiblings });\n\n            // When using the stack, cells that are embedded last are processed first.\n            // To maintain the original order, we need to push the cells in reverse order\n            for (let i = embeddedCells.length - 1; i >= 0; --i) {\n                stack.push(embeddedCells[i]);\n            }\n        }\n        cells.shift();\n\n        return cells;\n    },\n\n    isEmbeddedIn: function(cell, opt) {\n\n        var cellId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(cell) ? cell : cell.id;\n        var parentId = this.parent();\n\n        opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ deep: true }, opt);\n\n        // See getEmbeddedCells().\n        if (this.graph && opt.deep) {\n\n            while (parentId) {\n                if (parentId === cellId) {\n                    return true;\n                }\n                parentId = this.graph.getCell(parentId).parent();\n            }\n\n            return false;\n\n        } else {\n\n            // When this cell is not part of a collection check\n            // at least whether it's a direct child of given cell.\n            return parentId === cellId;\n        }\n    },\n\n    // Whether or not the cell is embedded in any other cell.\n    isEmbedded: function() {\n\n        return !!this.parent();\n    },\n\n    // Isolated cloning. Isolated cloning has two versions: shallow and deep (pass `{ deep: true }` in `opt`).\n    // Shallow cloning simply clones the cell and returns a new cell with different ID.\n    // Deep cloning clones the cell and all its embedded cells recursively.\n    clone: function(opt) {\n\n        opt = opt || {};\n\n        if (!opt.deep) {\n            // Shallow cloning.\n\n            var clone = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_1__.Model.prototype.clone.apply(this, arguments);\n            // We don't want the clone to have the same ID as the original.\n            clone.set(this.getIdAttribute(), this.generateId());\n            // A shallow cloned element does not carry over the original embeds.\n            clone.unset('embeds');\n            // And can not be embedded in any cell\n            // as the clone is not part of the graph.\n            clone.unset('parent');\n\n            return clone;\n\n        } else {\n            // Deep cloning.\n\n            // For a deep clone, simply call `graph.cloneCells()` with the cell and all its embedded cells.\n            return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)((0,_util_cloneCells_mjs__WEBPACK_IMPORTED_MODULE_3__.cloneCells)([this].concat(this.getEmbeddedCells({ deep: true }))));\n        }\n    },\n\n    // A convenient way to set nested properties.\n    // This method merges the properties you'd like to set with the ones\n    // stored in the cell and makes sure change events are properly triggered.\n    // You can either set a nested property with one object\n    // or use a property path.\n    // The most simple use case is:\n    // `cell.prop('name/first', 'John')` or\n    // `cell.prop({ name: { first: 'John' } })`.\n    // Nested arrays are supported too:\n    // `cell.prop('series/0/data/0/degree', 50)` or\n    // `cell.prop({ series: [ { data: [ { degree: 50 } ] } ] })`.\n    prop: function(props, value, opt) {\n\n        var delim = '/';\n        var _isString = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(props);\n\n        if (_isString || Array.isArray(props)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n\n            if (arguments.length > 1) {\n\n                var path;\n                var pathArray;\n\n                if (_isString) {\n                    path = props;\n                    pathArray = path.split('/');\n                } else {\n                    path = props.join(delim);\n                    pathArray = props.slice();\n                }\n\n                var property = pathArray[0];\n                var pathArrayLength = pathArray.length;\n\n                const options = opt || {};\n                options.propertyPath = path;\n                options.propertyValue = value;\n                options.propertyPathArray = pathArray;\n                if (!('rewrite' in options)) {\n                    options.rewrite = false;\n                }\n\n                var update = {};\n                // Initialize the nested object. Sub-objects are either arrays or objects.\n                // An empty array is created if the sub-key is an integer. Otherwise, an empty object is created.\n                // Note that this imposes a limitation on object keys one can use with Inspector.\n                // Pure integer keys will cause issues and are therefore not allowed.\n                var initializer = update;\n                var prevProperty = property;\n\n                for (var i = 1; i < pathArrayLength; i++) {\n                    var pathItem = pathArray[i];\n                    var isArrayIndex = Number.isFinite(_isString ? Number(pathItem) : pathItem);\n                    initializer = initializer[prevProperty] = isArrayIndex ? [] : {};\n                    prevProperty = pathItem;\n                }\n\n                // Fill update with the `value` on `path`.\n                update = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.setByPath)(update, pathArray, value, '/');\n\n                var baseAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)({}, this.attributes);\n                // if rewrite mode enabled, we replace value referenced by path with\n                // the new one (we don't merge).\n                options.rewrite && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.unsetByPath)(baseAttributes, path, '/');\n\n                // Merge update with the model attributes.\n                var attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)(baseAttributes, update);\n                // Finally, set the property to the updated attributes.\n                return this.set(property, attributes[property], options);\n\n            } else {\n\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath)(this.attributes, props, delim);\n            }\n        }\n\n        const options = value || {};\n        // Note: '' is not the path to the root. It's a path with an empty string i.e. { '': {}}.\n        options.propertyPath = null;\n        options.propertyValue = props;\n        options.propertyPathArray = [];\n        if (!('rewrite' in options)) {\n            options.rewrite = false;\n        }\n\n        // Create a new object containing only the changed attributes.\n        const changedAttributes = {};\n        for (const key in props) {\n            // Merging the values of changed attributes with the current ones.\n            const { changedValue } = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.merge)({}, { changedValue: this.attributes[key] }, { changedValue: props[key] });\n            changedAttributes[key] = changedValue;\n        }\n\n        return this.set(changedAttributes, options);\n    },\n\n    // A convenient way to unset nested properties\n    removeProp: function(path, opt) {\n\n        opt = opt || {};\n\n        var pathArray = Array.isArray(path) ? path : path.split('/');\n\n        // Once a property is removed from the `attrs` attribute\n        // the cellView will recognize a `dirty` flag and re-render itself\n        // in order to remove the attribute from SVG element.\n        var property = pathArray[0];\n        if (property === 'attrs') opt.dirty = true;\n\n        if (pathArray.length === 1) {\n            // A top level property\n            return this.unset(path, opt);\n        }\n\n        // A nested property\n        var nestedPath = pathArray.slice(1);\n        var propertyValue = this.get(property);\n        if (propertyValue === undefined || propertyValue === null) return this;\n        propertyValue = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep)(propertyValue);\n\n        (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.unsetByPath)(propertyValue, nestedPath, '/');\n\n        return this.set(property, propertyValue, opt);\n    },\n\n    // A convenient way to set nested attributes.\n    attr: function(attrs, value, opt) {\n\n        var args = Array.from(arguments);\n        if (args.length === 0) {\n            return this.get('attrs');\n        }\n\n        if (Array.isArray(attrs)) {\n            args[0] = ['attrs'].concat(attrs);\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(attrs)) {\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = 'attrs/' + attrs;\n\n        } else {\n\n            args[0] = { 'attrs' : attrs };\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    // A convenient way to unset nested attributes\n    removeAttr: function(path, opt) {\n\n        if (Array.isArray(path)) {\n\n            return this.removeProp(['attrs'].concat(path));\n        }\n\n        return this.removeProp('attrs/' + path, opt);\n    },\n\n    transition: function(path, value, opt, delim) {\n\n        delim = delim || '/';\n\n        var defaults = {\n            duration: 100,\n            delay: 10,\n            timingFunction: _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.timing.linear,\n            valueFunction: _util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.interpolate.number\n        };\n\n        opt = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(defaults, opt);\n\n        var firstFrameTime = 0;\n        var interpolatingFunction;\n\n        var setter = function(runtime) {\n\n            var id, progress, propertyValue;\n\n            firstFrameTime = firstFrameTime || runtime;\n            runtime -= firstFrameTime;\n            progress = runtime / opt.duration;\n\n            if (progress < 1) {\n                this._transitionIds[path] = id = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(setter);\n            } else {\n                progress = 1;\n                delete this._transitionIds[path];\n            }\n\n            propertyValue = interpolatingFunction(opt.timingFunction(progress));\n\n            opt.transitionId = id;\n\n            this.prop(path, propertyValue, opt);\n\n            if (!id) this.trigger('transition:end', this, path);\n\n        }.bind(this);\n\n        const { _scheduledTransitionIds } = this;\n        let initialId;\n\n        var initiator = (callback) => {\n\n            if (_scheduledTransitionIds[path]) {\n                _scheduledTransitionIds[path] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.without)(_scheduledTransitionIds[path], initialId);\n                if (_scheduledTransitionIds[path].length === 0) {\n                    delete _scheduledTransitionIds[path];\n                }\n            }\n\n            this.stopPendingTransitions(path, delim);\n\n            interpolatingFunction = opt.valueFunction((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath)(this.attributes, path, delim), value);\n\n            this._transitionIds[path] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.nextFrame)(callback);\n\n            this.trigger('transition:start', this, path);\n\n        };\n\n        initialId = setTimeout(initiator, opt.delay, setter);\n\n        _scheduledTransitionIds[path] || (_scheduledTransitionIds[path] = []);\n        _scheduledTransitionIds[path].push(initialId);\n\n        return initialId;\n    },\n\n    getTransitions: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.union)(\n            Object.keys(this._transitionIds),\n            Object.keys(this._scheduledTransitionIds)\n        );\n    },\n\n    stopScheduledTransitions: function(path, delim = '/') {\n        const { _scheduledTransitionIds = {}} = this;\n        let transitions = Object.keys(_scheduledTransitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionIds = _scheduledTransitionIds[key];\n            // stop the initiator\n            transitionIds.forEach(transitionId => clearTimeout(transitionId));\n            delete _scheduledTransitionIds[key];\n            // Note: we could trigger transition:cancel` event here\n        });\n        return this;\n    },\n\n    stopPendingTransitions(path, delim = '/') {\n        const { _transitionIds = {}} = this;\n        let transitions = Object.keys(_transitionIds);\n        if (path) {\n            const pathArray = path.split(delim);\n            transitions = transitions.filter((key) => {\n                return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(pathArray, key.split(delim).slice(0, pathArray.length));\n            });\n        }\n        transitions.forEach((key) => {\n            const transitionId = _transitionIds[key];\n            // stop the setter\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.cancelFrame)(transitionId);\n            delete _transitionIds[key];\n            this.trigger('transition:end', this, key);\n        });\n    },\n\n    stopTransitions: function(path, delim = '/') {\n        this.stopScheduledTransitions(path, delim);\n        this.stopPendingTransitions(path, delim);\n        return this;\n    },\n\n    // A shorcut making it easy to create constructs like the following:\n    // `var el = (new joint.shapes.standard.Rectangle()).addTo(graph)`.\n    addTo: function(graph, opt) {\n\n        graph.addCell(this, opt);\n        return this;\n    },\n\n    // A shortcut for an equivalent call: `paper.findViewByModel(cell)`\n    // making it easy to create constructs like the following:\n    // `cell.findView(paper).highlight()`\n    findView: function(paper) {\n\n        return paper.findViewByModel(this);\n    },\n\n    isElement: function() {\n\n        return false;\n    },\n\n    isLink: function() {\n\n        return false;\n    },\n\n    startBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.startBatch(name, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, opt, { cell: this })); }\n        return this;\n    },\n\n    stopBatch: function(name, opt) {\n\n        if (this.graph) { this.graph.stopBatch(name, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, opt, { cell: this })); }\n        return this;\n    },\n\n    getChangeFlag: function(attributes) {\n\n        var flag = 0;\n        if (!attributes) return flag;\n        for (var key in attributes) {\n            if (!attributes.hasOwnProperty(key) || !this.hasChanged(key)) continue;\n            flag |= attributes[key];\n        }\n        return flag;\n    },\n\n    angle: function() {\n\n        // To be overridden.\n        return 0;\n    },\n\n    position: function() {\n\n        // To be overridden.\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point(0, 0);\n    },\n\n    z: function() {\n        return this.get('z') || 0;\n    },\n\n    getPointFromConnectedLink: function() {\n\n        // To be overridden\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point();\n    },\n\n    getBBox: function() {\n\n        // To be overridden\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(0, 0, 0, 0);\n    },\n\n    getPointRotatedAroundCenter(angle, x, y) {\n        const point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Point(x, y);\n        if (angle) point.rotate(this.getBBox().center(), angle);\n        return point;\n    },\n\n    getAbsolutePointFromRelative(x, y) {\n        // Rotate the position to take the model angle into account\n        return this.getPointRotatedAroundCenter(\n            -this.angle(),\n            // Transform the relative position to absolute\n            this.position().offset(x, y)\n        );\n    },\n\n    getRelativePointFromAbsolute(x, y) {\n        return this\n            // Rotate the coordinates to mitigate the element's rotation.\n            .getPointRotatedAroundCenter(this.angle(), x, y)\n            // Transform the absolute position into relative\n            .difference(this.position());\n    }\n\n}, {\n\n    getAttributeDefinition: function(attrName) {\n\n        var defNS = this.attributes;\n        var globalDefNS = _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_6__.attributes;\n        return (defNS && defNS[attrName]) || globalDefNS[attrName];\n    },\n\n    define: function(type, defaults, protoProps, staticProps) {\n\n        protoProps = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({\n            defaults: (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep)({ type: type }, defaults, this.prototype.defaults)\n        }, protoProps);\n\n        var Cell = this.extend(protoProps, staticProps);\n        // es5 backward compatibility\n        /* eslint-disable no-undef */\n        if (typeof joint !== 'undefined' && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.has)(joint, 'shapes')) {\n            (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_2__.setByPath)(joint.shapes, type, Cell, '.');\n        }\n        /* eslint-enable no-undef */\n        return Cell;\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0NlbGwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBNkIwQjtBQUNlO0FBQ1c7QUFDQTtBQUNoQjs7O0FBR3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHdEQUFROztBQUVyQzs7QUFFQSxZQUFZLHVEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVPLGFBQWEsaURBQUs7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0RBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBSyxHQUFHO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLHlCQUF5QixzREFBTTs7QUFFL0I7QUFDQTtBQUNBLG9DQUFvQyx5REFBUzs7QUFFN0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix5REFBUzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGdDQUFnQyxnRUFBZ0IsYUFBYSxvREFBSSxxQ0FBcUMsYUFBYTs7QUFFbkg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxvREFBSTtBQUNuQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSwwQkFBMEIsNkRBQVU7QUFDcEM7QUFDQSxLQUFLOztBQUVMOztBQUVBLHFCQUFxQixzREFBTTtBQUMzQixzQkFBc0IsNERBQVksR0FBRyxZQUFZO0FBQ2pELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1EQUFHO0FBQy9DLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0NlbGwubWpzPzMzMmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICB1bmlxdWVJZCxcbiAgICB1bmlvbixcbiAgICByZXN1bHQsXG4gICAgbWVyZ2UsXG4gICAgZm9ySW4sXG4gICAgaXNPYmplY3QsXG4gICAgaXNFcXVhbCxcbiAgICBpc1N0cmluZyxcbiAgICBjbG9uZURlZXAsXG4gICAgb21pdCxcbiAgICB1dWlkLFxuICAgIGlzRW1wdHksXG4gICAgYXNzaWduLFxuICAgIHVuaXEsXG4gICAgdG9BcnJheSxcbiAgICBzZXRCeVBhdGgsXG4gICAgdW5zZXRCeVBhdGgsXG4gICAgZ2V0QnlQYXRoLFxuICAgIHRpbWluZyxcbiAgICBpbnRlcnBvbGF0ZSxcbiAgICBuZXh0RnJhbWUsXG4gICAgd2l0aG91dCxcbiAgICBjYW5jZWxGcmFtZSxcbiAgICBkZWZhdWx0c0RlZXAsXG4gICAgaGFzLFxuICAgIHNvcnRCeSxcbiAgICBkZWZhdWx0cyxcbiAgICBvYmplY3REaWZmZXJlbmNlXG59IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuaW1wb3J0IHsgTW9kZWwgfSBmcm9tICcuLi9tdmMvTW9kZWwubWpzJztcbmltcG9ydCB7IGNsb25lQ2VsbHMgfSBmcm9tICcuLi91dGlsL2Nsb25lQ2VsbHMubWpzJztcbmltcG9ydCB7IGF0dHJpYnV0ZXMgfSBmcm9tICcuL2F0dHJpYnV0ZXMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5cbi8vIENlbGwgYmFzZSBtb2RlbC5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IGF0dHJpYnV0ZXNNZXJnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlBdHRyaWJ1dGVzKG9iaikge1xuXG4gICAgLy8gUmVtb3ZlIHRvcGxldmVsIGVtcHR5IGF0dHJpYnV0ZXNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcblxuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBjb25zdCBpc1JlYWxPYmplY3QgPSBpc09iamVjdChvYmpWYWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkob2JqVmFsdWUpO1xuXG4gICAgICAgIGlmICghaXNSZWFsT2JqZWN0KSBjb250aW51ZTtcblxuICAgICAgICBpZiAoaXNFbXB0eShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IENlbGwgPSBNb2RlbC5leHRlbmQoe1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBhcyBtdmMuTW9kZWwgd2l0aCB0aGUgb25seSBkaWZmZXJlbmNlIHRoYXQgaXMgdXNlcyB1dGlsLm1lcmdlXG4gICAgLy8gaW5zdGVhZCBvZiBqdXN0IF8uZXh0ZW5kLiBUaGUgcmVhc29uIGlzIHRoYXQgd2Ugd2FudCB0byBtaXhpbiBhdHRyaWJ1dGVzIHNldCBpbiB1cHBlciBjbGFzc2VzLlxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRzO1xuICAgICAgICB2YXIgYXR0cnMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucHJlaW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc3VwcG9ydCBhbiBvbGRlciB2ZXJzaW9uXG4gICAgICAgICAgICB0aGlzLnByZWluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNpZCA9IHVuaXF1ZUlkKCdjJyk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJzZSkgYXR0cnMgPSB0aGlzLnBhcnNlKGF0dHJzLCBvcHRpb25zKSB8fCB7fTtcbiAgICAgICAgaWYgKChkZWZhdWx0cyA9IHJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSkpIHtcbiAgICAgICAgICAgIC8vPGN1c3RvbSBjb2RlPlxuICAgICAgICAgICAgLy8gUmVwbGFjZWQgdGhlIGNhbGwgdG8gXy5kZWZhdWx0cyB3aXRoIHV0aWwubWVyZ2UuXG4gICAgICAgICAgICBjb25zdCBjdXN0b21pemVyID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXJnZUFycmF5cyA9PT0gdHJ1ZSkgPyBmYWxzZSA6IGF0dHJpYnV0ZXNNZXJnZXI7XG4gICAgICAgICAgICBhdHRycyA9IG1lcmdlKHt9LCBkZWZhdWx0cywgYXR0cnMsIGN1c3RvbWl6ZXIpO1xuICAgICAgICAgICAgLy88L2N1c3RvbSBjb2RlPlxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKGR4LCBkeSwgb3B0KSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGRlZmluZSBhIHRyYW5zbGF0ZSgpIG1ldGhvZC4nKTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBjb25zdCB7IGlnbm9yZURlZmF1bHRzLCBpZ25vcmVFbXB0eUF0dHJpYnV0ZXMgPSBmYWxzZSB9ID0gb3B0IHx8IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHJlc3VsdCh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2RlZmF1bHRzJyk7XG5cbiAgICAgICAgaWYgKGlnbm9yZURlZmF1bHRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCBhdHRyaWJ1dGVzIHdpdGhvdXQgb21pdHRpbmcgdGhlIGRlZmF1bHRzXG4gICAgICAgICAgICBjb25zdCBmaW5hbEF0dHJpYnV0ZXMgPSBjbG9uZURlZXAodGhpcy5hdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgaWYgKCFpZ25vcmVFbXB0eUF0dHJpYnV0ZXMpIHJldHVybiBmaW5hbEF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIHJlbW92ZUVtcHR5QXR0cmlidXRlcyhmaW5hbEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmluYWxBdHRyaWJ1dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGxldCBhdHRyaWJ1dGVzID0gY2xvbmVEZWVwKHRoaXMuYXR0cmlidXRlcyk7XG5cbiAgICAgICAgaWYgKGlnbm9yZURlZmF1bHRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBDb21wYXJlIGFsbCBhdHRyaWJ1dGVzIHdpdGggdGhlIGRlZmF1bHRzXG4gICAgICAgICAgICBkZWZhdWx0QXR0cmlidXRlcyA9IGRlZmF1bHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29tcGFyZSBvbmx5IHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBkZWZhdWx0cywgdXNlIGBhdHRyc2AgYXMgYSBkZWZhdWx0IGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVudGlhdGVLZXlzID0gQXJyYXkuaXNBcnJheShpZ25vcmVEZWZhdWx0cykgPyBpZ25vcmVEZWZhdWx0cyA6IFsnYXR0cnMnXTtcblxuICAgICAgICAgICAgZGlmZmVyZW50aWF0ZUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEF0dHJpYnV0ZXNba2V5XSA9IGRlZmF1bHRzW2tleV0gfHwge307XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9taXQgYGlkYCBhbmQgYHR5cGVgIGF0dHJpYnV0ZSBmcm9tIHRoZSBkZWZhdWx0cyBzaW5jZSBpdCBzaG91bGQgYmUgYWx3YXlzIHByZXNlbnRcbiAgICAgICAgY29uc3QgZmluYWxBdHRyaWJ1dGVzID0gb2JqZWN0RGlmZmVyZW5jZShhdHRyaWJ1dGVzLCBvbWl0KGRlZmF1bHRBdHRyaWJ1dGVzLCAnaWQnLCAndHlwZScpLCB7IG1heERlcHRoOiA0IH0pO1xuXG4gICAgICAgIGlmIChpZ25vcmVFbXB0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5QXR0cmlidXRlcyhmaW5hbEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbmFsQXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGlkQXR0cmlidXRlID0gdGhpcy5nZXRJZEF0dHJpYnV0ZSgpO1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9uc1tpZEF0dHJpYnV0ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoaWRBdHRyaWJ1dGUsIHRoaXMuZ2VuZXJhdGVJZCgpLCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25JZHMgPSB7fTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVkVHJhbnNpdGlvbklkcyA9IHt9O1xuXG4gICAgICAgIC8vIENvbGxlY3QgcG9ydHMgZGVmaW5lZCBpbiBgYXR0cnNgIGFuZCBrZWVwIGNvbGxlY3Rpbmcgd2hlbmV2ZXIgYGF0dHJzYCBvYmplY3QgY2hhbmdlcy5cbiAgICAgICAgdGhpcy5wcm9jZXNzUG9ydHMoKTtcbiAgICAgICAgdGhpcy5vbignY2hhbmdlOmF0dHJzJywgdGhpcy5wcm9jZXNzUG9ydHMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICBnZXRJZEF0dHJpYnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkQXR0cmlidXRlIHx8ICdpZCc7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlSWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXVpZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHByb2Nlc3NQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gV2hlbmV2ZXIgYGF0dHJzYCBjaGFuZ2VzLCB3ZSBleHRyYWN0IHBvcnRzIGZyb20gdGhlIGBhdHRyc2Agb2JqZWN0IGFuZCBzdG9yZSBpdFxuICAgICAgICAvLyBpbiBhIG1vcmUgYWNjZXNzaWJsZSB3YXkuIEFsc28sIGlmIGFueSBwb3J0IGdvdCByZW1vdmVkIGFuZCB0aGVyZSB3ZXJlIGxpbmtzIHRoYXQgaGFkIGB0YXJnZXRgL2Bzb3VyY2VgXG4gICAgICAgIC8vIHNldCB0byB0aGF0IHBvcnQsIHdlIHJlbW92ZSB0aG9zZSBsaW5rcyBhcyB3ZWxsICh0byBmb2xsb3cgdGhlIHNhbWUgYmVoYXZpb3VyIGFzXG4gICAgICAgIC8vIHdpdGggYSByZW1vdmVkIGVsZW1lbnQpLlxuXG4gICAgICAgIHZhciBwcmV2aW91c1BvcnRzID0gdGhpcy5wb3J0cztcblxuICAgICAgICAvLyBDb2xsZWN0IHBvcnRzIGZyb20gdGhlIGBhdHRyc2Agb2JqZWN0LlxuICAgICAgICB2YXIgcG9ydHMgPSB7fTtcbiAgICAgICAgZm9ySW4odGhpcy5nZXQoJ2F0dHJzJyksIGZ1bmN0aW9uKGF0dHJzLCBzZWxlY3Rvcikge1xuXG4gICAgICAgICAgICBpZiAoYXR0cnMgJiYgYXR0cnMucG9ydCkge1xuXG4gICAgICAgICAgICAgICAgLy8gYHBvcnRgIGNhbiBlaXRoZXIgYmUgZGlyZWN0bHkgYW4gYGlkYCBvciBhbiBvYmplY3QgY29udGFpbmluZyBhbiBgaWRgIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgZGF0YSkuXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLnBvcnQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwb3J0c1thdHRycy5wb3J0LmlkXSA9IGF0dHJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydHNbYXR0cnMucG9ydF0gPSB7IGlkOiBhdHRycy5wb3J0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb2xsZWN0IHBvcnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgKGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBwb3J0cykgLSBpZiBhbnkuXG4gICAgICAgIC8vIFVzZSBoYXNoIHRhYmxlIGZvciBxdWljayBsb29rdXAuXG4gICAgICAgIHZhciByZW1vdmVkUG9ydHMgPSB7fTtcbiAgICAgICAgZm9ySW4ocHJldmlvdXNQb3J0cywgZnVuY3Rpb24ocG9ydCwgaWQpIHtcblxuICAgICAgICAgICAgaWYgKCFwb3J0c1tpZF0pIHJlbW92ZWRQb3J0c1tpZF0gPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgYWxsIHRoZSBpbmNvbWluZy9vdXRnb2luZyBsaW5rcyB0aGF0IGhhdmUgc291cmNlL3RhcmdldCBwb3J0IHNldCB0byBhbnkgb2YgdGhlIHJlbW92ZWQgcG9ydHMuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoICYmICFpc0VtcHR5KHJlbW92ZWRQb3J0cykpIHtcblxuICAgICAgICAgICAgdmFyIGluYm91bmRMaW5rcyA9IHRoaXMuZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3ModGhpcywgeyBpbmJvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgaW5ib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRQb3J0c1tsaW5rLmdldCgndGFyZ2V0JykucG9ydF0pIGxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIG91dGJvdW5kTGlua3MgPSB0aGlzLmdyYXBoLmdldENvbm5lY3RlZExpbmtzKHRoaXMsIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICBvdXRib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRQb3J0c1tsaW5rLmdldCgnc291cmNlJykucG9ydF0pIGxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYHBvcnRzYCBvYmplY3QuXG4gICAgICAgIHRoaXMucG9ydHMgPSBwb3J0cztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihvcHQgPSB7fSkge1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBncmFwaCBpbiBhIHZhcmlhYmxlIGJlY2F1c2UgYHRoaXMuZ3JhcGhgIHdvbid0IGJlIGFjY2Vzc2libGVcbiAgICAgICAgLy8gYWZ0ZXIgYHRoaXMudHJpZ2dlcigncmVtb3ZlJywgLi4uKWAgZG93biBiZWxvdy5cbiAgICAgICAgY29uc3QgeyBncmFwaCwgY29sbGVjdGlvbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFncmFwaCkge1xuICAgICAgICAgICAgLy8gVGhlIGNvbGxlY3Rpb24gaXMgYSBjb21tb24gbXZjIGNvbGxlY3Rpb24gKG5vdCB0aGUgZ3JhcGggY29sbGVjdGlvbikuXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlvbikgY29sbGVjdGlvbi5yZW1vdmUodGhpcywgb3B0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JhcGguc3RhcnRCYXRjaCgncmVtb3ZlJyk7XG5cbiAgICAgICAgLy8gRmlyc3QsIHVuZW1iZWQgdGhpcyBjZWxsIGZyb20gaXRzIHBhcmVudCBjZWxsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAgY29uc3QgcGFyZW50Q2VsbCA9IHRoaXMuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICBpZiAocGFyZW50Q2VsbCkge1xuICAgICAgICAgICAgcGFyZW50Q2VsbC51bmVtYmVkKHRoaXMsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYWxzbyBhbGwgdGhlIGNlbGxzLCB3aGljaCB3ZXJlIGVtYmVkZGVkIGludG8gdGhpcyBjZWxsXG4gICAgICAgIGNvbnN0IGVtYmVkZGVkQ2VsbHMgPSB0aGlzLmdldEVtYmVkZGVkQ2VsbHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBlbWJlZGRlZENlbGxzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZW1iZWQgPSBlbWJlZGRlZENlbGxzW2ldO1xuICAgICAgICAgICAgaWYgKGVtYmVkKSB7XG4gICAgICAgICAgICAgICAgZW1iZWQucmVtb3ZlKG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbW92ZScsIHRoaXMsIGdyYXBoLmF0dHJpYnV0ZXMuY2VsbHMsIG9wdCk7XG5cbiAgICAgICAgZ3JhcGguc3RvcEJhdGNoKCdyZW1vdmUnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9Gcm9udDogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgb3B0ID0gZGVmYXVsdHMob3B0IHx8IHt9LCB7IGZvcmVncm91bmRFbWJlZHM6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIGxldCBjZWxscztcbiAgICAgICAgICAgIGlmIChvcHQuZGVlcCkge1xuICAgICAgICAgICAgICAgIGNlbGxzID0gdGhpcy5nZXRFbWJlZGRlZENlbGxzKHsgZGVlcDogdHJ1ZSwgYnJlYWR0aEZpcnN0OiBvcHQuYnJlYWR0aEZpcnN0ICE9PSBmYWxzZSwgc29ydFNpYmxpbmdzOiBvcHQuZm9yZWdyb3VuZEVtYmVkcyB9KTtcbiAgICAgICAgICAgICAgICBjZWxscy51bnNoaWZ0KHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjZWxscyA9IFt0aGlzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc29ydGVkQ2VsbHMgPSBvcHQuZm9yZWdyb3VuZEVtYmVkcyA/IGNlbGxzIDogc29ydEJ5KGNlbGxzLCBjZWxsID0+IGNlbGwueigpKTtcblxuICAgICAgICAgICAgY29uc3QgbWF4WiA9IGdyYXBoLm1heFpJbmRleCgpO1xuICAgICAgICAgICAgbGV0IHogPSBtYXhaIC0gY2VsbHMubGVuZ3RoICsgMTtcblxuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGdyYXBoLmdldCgnY2VsbHMnKTtcblxuICAgICAgICAgICAgbGV0IHNob3VsZFVwZGF0ZSA9IChjb2xsZWN0aW9uLnRvQXJyYXkoKS5pbmRleE9mKHNvcnRlZENlbGxzWzBdKSAhPT0gKGNvbGxlY3Rpb24ubGVuZ3RoIC0gY2VsbHMubGVuZ3RoKSk7XG4gICAgICAgICAgICBpZiAoIXNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IHNvcnRlZENlbGxzLnNvbWUoZnVuY3Rpb24oY2VsbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwueigpICE9PSB6ICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ3RvLWZyb250Jyk7XG5cbiAgICAgICAgICAgICAgICB6ID0geiArIGNlbGxzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHNvcnRlZENlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXQoJ3onLCB6ICsgaW5kZXgsIG9wdCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BCYXRjaCgndG8tZnJvbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JhY2s6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICBpZiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIG9wdCA9IGRlZmF1bHRzKG9wdCB8fCB7fSwgeyBmb3JlZ3JvdW5kRW1iZWRzOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBsZXQgY2VsbHM7XG4gICAgICAgICAgICBpZiAob3B0LmRlZXApIHtcbiAgICAgICAgICAgICAgICBjZWxscyA9IHRoaXMuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUsIGJyZWFkdGhGaXJzdDogb3B0LmJyZWFkdGhGaXJzdCAhPT0gZmFsc2UsIHNvcnRTaWJsaW5nczogb3B0LmZvcmVncm91bmRFbWJlZHMgfSk7XG4gICAgICAgICAgICAgICAgY2VsbHMudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2VsbHMgPSBbdGhpc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZENlbGxzID0gb3B0LmZvcmVncm91bmRFbWJlZHMgPyBjZWxscyA6IHNvcnRCeShjZWxscywgY2VsbCA9PiBjZWxsLnooKSk7XG5cbiAgICAgICAgICAgIGxldCB6ID0gZ3JhcGgubWluWkluZGV4KCk7XG5cbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gZ3JhcGguZ2V0KCdjZWxscycpO1xuXG4gICAgICAgICAgICBsZXQgc2hvdWxkVXBkYXRlID0gKGNvbGxlY3Rpb24udG9BcnJheSgpLmluZGV4T2Yoc29ydGVkQ2VsbHNbMF0pICE9PSAwKTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlID0gc29ydGVkQ2VsbHMuc29tZShmdW5jdGlvbihjZWxsLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC56KCkgIT09IHogKyBpbmRleDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgndG8tYmFjaycpO1xuXG4gICAgICAgICAgICAgICAgeiAtPSBjZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzb3J0ZWRDZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuc2V0KCd6JywgeiArIGluZGV4LCBvcHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3RvLWJhY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCwgb3B0KSB7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZ2V0KCdwYXJlbnQnKTtcbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgncGFyZW50JywgcGFyZW50LCBvcHQpO1xuICAgIH0sXG5cbiAgICBlbWJlZDogZnVuY3Rpb24oY2VsbCwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgY2VsbHMgPSBBcnJheS5pc0FycmF5KGNlbGwpID8gY2VsbCA6IFtjZWxsXTtcbiAgICAgICAgaWYgKCF0aGlzLmNhbkVtYmVkKGNlbGxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpdmUgZW1iZWRkaW5nIG5vdCBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHQucmVwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudHMgPSB1bmlxKGNlbGxzLm1hcChjID0+IGMuZ2V0UGFyZW50Q2VsbCgpKSk7XG5cbiAgICAgICAgICAgIC8vIFVuZW1iZWQgY2VsbHMgZnJvbSB0aGVpciBjdXJyZW50IHBhcmVudHMuXG4gICAgICAgICAgICBwYXJlbnRzLmZvckVhY2goKHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENlbGwgZG9lc24ndCBoYXZlIHRvIGJlIGVtYmVkZGVkLlxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50KSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBQYXNzIGFsbCB0aGUgYGNlbGxzYCBzaW5jZSB0aGUgYGRpYS5DZWxsLl91bmVtYmVkQ2VsbHNgIG1ldGhvZCBjYW4gaGFuZGxlIGNhc2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgbm90IGFsbCBlbGVtZW50cyBvZiBgY2VsbHNgIGFyZSBlbWJlZGRlZCBpbiB0aGUgc2FtZSBwYXJlbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Ll91bmVtYmVkQ2VsbHMoY2VsbHMsIG9wdCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNlbGxzLnNvbWUoYyA9PiBjLmlzRW1iZWRkZWQoKSAmJiB0aGlzLmlkICE9PSBjLnBhcmVudCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbWJlZGRpbmcgb2YgYWxyZWFkeSBlbWJlZGRlZCBjZWxscyBpcyBub3QgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWJlZENlbGxzKGNlbGxzLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5lbWJlZDogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuaXNBcnJheShjZWxsKSA/IGNlbGwgOiBbY2VsbF07XG4gICAgICAgIHRoaXMuX3VuZW1iZWRDZWxscyhjZWxscywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNhbkVtYmVkOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gQXJyYXkuaXNBcnJheShjZWxsKSA/IGNlbGwgOiBbY2VsbF07XG4gICAgICAgIHJldHVybiBjZWxscy5ldmVyeShjID0+IHRoaXMgIT09IGMgJiYgIXRoaXMuaXNFbWJlZGRlZEluKGMpKTtcbiAgICB9LFxuXG4gICAgX2VtYmVkQ2VsbHM6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcbiAgICAgICAgY29uc3QgYmF0Y2hOYW1lID0gJ2VtYmVkJztcbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKGJhdGNoTmFtZSk7XG4gICAgICAgIGNvbnN0IGVtYmVkcyA9IGFzc2lnbihbXSwgdGhpcy5nZXQoJ2VtYmVkcycpKTtcbiAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgIC8vIFdlIGtlZXAgYWxsIGVsZW1lbnQgaWRzIGFmdGVyIGxpbmsgaWRzLlxuICAgICAgICAgICAgZW1iZWRzW2NlbGwuaXNMaW5rKCkgPyAndW5zaGlmdCcgOiAncHVzaCddKGNlbGwuaWQpO1xuICAgICAgICAgICAgY2VsbC5wYXJlbnQodGhpcy5pZCwgb3B0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0KCdlbWJlZHMnLCB1bmlxKGVtYmVkcyksIG9wdCk7XG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKGJhdGNoTmFtZSk7XG4gICAgfSxcblxuICAgIF91bmVtYmVkQ2VsbHM6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcbiAgICAgICAgY29uc3QgYmF0Y2hOYW1lID0gJ3VuZW1iZWQnO1xuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goYmF0Y2hOYW1lKTtcbiAgICAgICAgY2VsbHMuZm9yRWFjaChjZWxsID0+IGNlbGwudW5zZXQoJ3BhcmVudCcsIG9wdCkpO1xuICAgICAgICB0aGlzLnNldCgnZW1iZWRzJywgd2l0aG91dCh0aGlzLmdldCgnZW1iZWRzJyksIC4uLmNlbGxzLm1hcChjZWxsID0+IGNlbGwuaWQpKSwgb3B0KTtcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goYmF0Y2hOYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0UGFyZW50Q2VsbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gdW5saWtlIGxpbmsuc291cmNlL3RhcmdldCwgY2VsbC5wYXJlbnQgc3RvcmVzIGlkIGRpcmVjdGx5IGFzIGEgc3RyaW5nXG4gICAgICAgIHZhciBwYXJlbnRJZCA9IHRoaXMucGFyZW50KCk7XG4gICAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG5cbiAgICAgICAgcmV0dXJuIChwYXJlbnRJZCAmJiBncmFwaCAmJiBncmFwaC5nZXRDZWxsKHBhcmVudElkKSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIGFuY2VzdG9yIGNlbGxzLlxuICAgIC8vIFRoZSBhcnJheSBpcyBvcmRlcmVkIGZyb20gdGhlIHBhcmVudCBvZiB0aGUgY2VsbFxuICAgIC8vIHRvIHRoZSBtb3N0IGRpc3RhbnQgYW5jZXN0b3IuXG4gICAgZ2V0QW5jZXN0b3JzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgYW5jZXN0b3JzID0gW107XG5cbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoKSB7XG4gICAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudENlbGwgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcbiAgICAgICAgd2hpbGUgKHBhcmVudENlbGwpIHtcbiAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudENlbGwpO1xuICAgICAgICAgICAgcGFyZW50Q2VsbCA9IHBhcmVudENlbGwuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9LFxuXG4gICAgZ2V0RW1iZWRkZWRDZWxsczogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIC8vIENlbGwgbW9kZWxzIGNhbiBvbmx5IGJlIHJldHJpZXZlZCB3aGVuIHRoaXMgZWxlbWVudCBpcyBwYXJ0IG9mIGEgY29sbGVjdGlvbi5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRoaXMgZWxlbWVudCBrbm93cyBhYm91dCBvdGhlciBjZWxscyBvdGhlcndpc2UuXG4gICAgICAgIC8vIFRoaXMgYWxzbyBtZWFucyB0aGF0IGNhbGxpbmcgZS5nLiBgdHJhbnNsYXRlKClgIG9uIGFuIGVsZW1lbnQgd2l0aCBlbWJlZHMgYmVmb3JlXG4gICAgICAgIC8vIGFkZGluZyBpdCB0byBhIGdyYXBoIGRvZXMgbm90IHRyYW5zbGF0ZSBpdHMgZW1iZWRzLlxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuZGVlcCkge1xuICAgICAgICAgICAgaWYgKG9wdC5icmVhZHRoRmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RW1iZWRkZWRDZWxsc0JmcyhvcHQuc29ydFNpYmxpbmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEVtYmVkZGVkQ2VsbHNEZnMob3B0LnNvcnRTaWJsaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbWJlZGRlZElkcyA9IHRoaXMuZ2V0KCdlbWJlZHMnKTtcbiAgICAgICAgaWYgKGlzRW1wdHkoZW1iZWRkZWRJZHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2VsbHMgPSBlbWJlZGRlZElkcy5tYXAodGhpcy5ncmFwaC5nZXRDZWxsLCB0aGlzLmdyYXBoKTtcbiAgICAgICAgaWYgKG9wdC5zb3J0U2libGluZ3MpIHtcbiAgICAgICAgICAgIGNlbGxzID0gc29ydEJ5KGNlbGxzLCBjZWxsID0+IGNlbGwueigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjZWxscztcbiAgICB9LFxuXG4gICAgX2dldEVtYmVkZGVkQ2VsbHNCZnM6IGZ1bmN0aW9uKHNvcnRTaWJsaW5ncykge1xuICAgICAgICBjb25zdCBjZWxscyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLnB1c2godGhpcyk7XG5cbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgY2VsbHMucHVzaChjdXJyZW50KTtcblxuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRDZWxscyA9IGN1cnJlbnQuZ2V0RW1iZWRkZWRDZWxscyh7IHNvcnRTaWJsaW5nczogc29ydFNpYmxpbmdzIH0pO1xuXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKC4uLmVtYmVkZGVkQ2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGNlbGxzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH0sXG5cbiAgICBfZ2V0RW1iZWRkZWRDZWxsc0RmczogZnVuY3Rpb24oc29ydFNpYmxpbmdzKSB7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gW107XG5cbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY2VsbHMucHVzaChjdXJyZW50KTtcblxuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRDZWxscyA9IGN1cnJlbnQuZ2V0RW1iZWRkZWRDZWxscyh7IHNvcnRTaWJsaW5nczogc29ydFNpYmxpbmdzIH0pO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHVzaW5nIHRoZSBzdGFjaywgY2VsbHMgdGhhdCBhcmUgZW1iZWRkZWQgbGFzdCBhcmUgcHJvY2Vzc2VkIGZpcnN0LlxuICAgICAgICAgICAgLy8gVG8gbWFpbnRhaW4gdGhlIG9yaWdpbmFsIG9yZGVyLCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGNlbGxzIGluIHJldmVyc2Ugb3JkZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBlbWJlZGRlZENlbGxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbWJlZGRlZENlbGxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjZWxscy5zaGlmdCgpO1xuXG4gICAgICAgIHJldHVybiBjZWxscztcbiAgICB9LFxuXG4gICAgaXNFbWJlZGRlZEluOiBmdW5jdGlvbihjZWxsLCBvcHQpIHtcblxuICAgICAgICB2YXIgY2VsbElkID0gaXNTdHJpbmcoY2VsbCkgPyBjZWxsIDogY2VsbC5pZDtcbiAgICAgICAgdmFyIHBhcmVudElkID0gdGhpcy5wYXJlbnQoKTtcblxuICAgICAgICBvcHQgPSBhc3NpZ24oeyBkZWVwOiB0cnVlIH0sIG9wdCk7XG5cbiAgICAgICAgLy8gU2VlIGdldEVtYmVkZGVkQ2VsbHMoKS5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGggJiYgb3B0LmRlZXApIHtcblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSBjZWxsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudElkID0gdGhpcy5ncmFwaC5nZXRDZWxsKHBhcmVudElkKS5wYXJlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyBjZWxsIGlzIG5vdCBwYXJ0IG9mIGEgY29sbGVjdGlvbiBjaGVja1xuICAgICAgICAgICAgLy8gYXQgbGVhc3Qgd2hldGhlciBpdCdzIGEgZGlyZWN0IGNoaWxkIG9mIGdpdmVuIGNlbGwuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50SWQgPT09IGNlbGxJZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCB0aGUgY2VsbCBpcyBlbWJlZGRlZCBpbiBhbnkgb3RoZXIgY2VsbC5cbiAgICBpc0VtYmVkZGVkOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLnBhcmVudCgpO1xuICAgIH0sXG5cbiAgICAvLyBJc29sYXRlZCBjbG9uaW5nLiBJc29sYXRlZCBjbG9uaW5nIGhhcyB0d28gdmVyc2lvbnM6IHNoYWxsb3cgYW5kIGRlZXAgKHBhc3MgYHsgZGVlcDogdHJ1ZSB9YCBpbiBgb3B0YCkuXG4gICAgLy8gU2hhbGxvdyBjbG9uaW5nIHNpbXBseSBjbG9uZXMgdGhlIGNlbGwgYW5kIHJldHVybnMgYSBuZXcgY2VsbCB3aXRoIGRpZmZlcmVudCBJRC5cbiAgICAvLyBEZWVwIGNsb25pbmcgY2xvbmVzIHRoZSBjZWxsIGFuZCBhbGwgaXRzIGVtYmVkZGVkIGNlbGxzIHJlY3Vyc2l2ZWx5LlxuICAgIGNsb25lOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgaWYgKCFvcHQuZGVlcCkge1xuICAgICAgICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nLlxuXG4gICAgICAgICAgICB2YXIgY2xvbmUgPSBNb2RlbC5wcm90b3R5cGUuY2xvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdGhlIGNsb25lIHRvIGhhdmUgdGhlIHNhbWUgSUQgYXMgdGhlIG9yaWdpbmFsLlxuICAgICAgICAgICAgY2xvbmUuc2V0KHRoaXMuZ2V0SWRBdHRyaWJ1dGUoKSwgdGhpcy5nZW5lcmF0ZUlkKCkpO1xuICAgICAgICAgICAgLy8gQSBzaGFsbG93IGNsb25lZCBlbGVtZW50IGRvZXMgbm90IGNhcnJ5IG92ZXIgdGhlIG9yaWdpbmFsIGVtYmVkcy5cbiAgICAgICAgICAgIGNsb25lLnVuc2V0KCdlbWJlZHMnKTtcbiAgICAgICAgICAgIC8vIEFuZCBjYW4gbm90IGJlIGVtYmVkZGVkIGluIGFueSBjZWxsXG4gICAgICAgICAgICAvLyBhcyB0aGUgY2xvbmUgaXMgbm90IHBhcnQgb2YgdGhlIGdyYXBoLlxuICAgICAgICAgICAgY2xvbmUudW5zZXQoJ3BhcmVudCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERlZXAgY2xvbmluZy5cblxuICAgICAgICAgICAgLy8gRm9yIGEgZGVlcCBjbG9uZSwgc2ltcGx5IGNhbGwgYGdyYXBoLmNsb25lQ2VsbHMoKWAgd2l0aCB0aGUgY2VsbCBhbmQgYWxsIGl0cyBlbWJlZGRlZCBjZWxscy5cbiAgICAgICAgICAgIHJldHVybiB0b0FycmF5KGNsb25lQ2VsbHMoW3RoaXNdLmNvbmNhdCh0aGlzLmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlIH0pKSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEEgY29udmVuaWVudCB3YXkgdG8gc2V0IG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgIC8vIFRoaXMgbWV0aG9kIG1lcmdlcyB0aGUgcHJvcGVydGllcyB5b3UnZCBsaWtlIHRvIHNldCB3aXRoIHRoZSBvbmVzXG4gICAgLy8gc3RvcmVkIGluIHRoZSBjZWxsIGFuZCBtYWtlcyBzdXJlIGNoYW5nZSBldmVudHMgYXJlIHByb3Blcmx5IHRyaWdnZXJlZC5cbiAgICAvLyBZb3UgY2FuIGVpdGhlciBzZXQgYSBuZXN0ZWQgcHJvcGVydHkgd2l0aCBvbmUgb2JqZWN0XG4gICAgLy8gb3IgdXNlIGEgcHJvcGVydHkgcGF0aC5cbiAgICAvLyBUaGUgbW9zdCBzaW1wbGUgdXNlIGNhc2UgaXM6XG4gICAgLy8gYGNlbGwucHJvcCgnbmFtZS9maXJzdCcsICdKb2huJylgIG9yXG4gICAgLy8gYGNlbGwucHJvcCh7IG5hbWU6IHsgZmlyc3Q6ICdKb2huJyB9IH0pYC5cbiAgICAvLyBOZXN0ZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWQgdG9vOlxuICAgIC8vIGBjZWxsLnByb3AoJ3Nlcmllcy8wL2RhdGEvMC9kZWdyZWUnLCA1MClgIG9yXG4gICAgLy8gYGNlbGwucHJvcCh7IHNlcmllczogWyB7IGRhdGE6IFsgeyBkZWdyZWU6IDUwIH0gXSB9IF0gfSlgLlxuICAgIHByb3A6IGZ1bmN0aW9uKHByb3BzLCB2YWx1ZSwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGRlbGltID0gJy8nO1xuICAgICAgICB2YXIgX2lzU3RyaW5nID0gaXNTdHJpbmcocHJvcHMpO1xuXG4gICAgICAgIGlmIChfaXNTdHJpbmcgfHwgQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgICAgIC8vIEdldC9zZXQgYW4gYXR0cmlidXRlIGJ5IGEgc3BlY2lhbCBwYXRoIHN5bnRheCB0aGF0IGRlbGltaXRzXG4gICAgICAgICAgICAvLyBuZXN0ZWQgb2JqZWN0cyBieSB0aGUgY29sb24gY2hhcmFjdGVyLlxuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblxuICAgICAgICAgICAgICAgIHZhciBwYXRoO1xuICAgICAgICAgICAgICAgIHZhciBwYXRoQXJyYXk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2lzU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwcm9wcztcbiAgICAgICAgICAgICAgICAgICAgcGF0aEFycmF5ID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwcm9wcy5qb2luKGRlbGltKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aEFycmF5ID0gcHJvcHMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwYXRoQXJyYXlbMF07XG4gICAgICAgICAgICAgICAgdmFyIHBhdGhBcnJheUxlbmd0aCA9IHBhdGhBcnJheS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gb3B0IHx8IHt9O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydHlQYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb3BlcnR5VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb3BlcnR5UGF0aEFycmF5ID0gcGF0aEFycmF5O1xuICAgICAgICAgICAgICAgIGlmICghKCdyZXdyaXRlJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJld3JpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlID0ge307XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbmVzdGVkIG9iamVjdC4gU3ViLW9iamVjdHMgYXJlIGVpdGhlciBhcnJheXMgb3Igb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAvLyBBbiBlbXB0eSBhcnJheSBpcyBjcmVhdGVkIGlmIHRoZSBzdWIta2V5IGlzIGFuIGludGVnZXIuIE90aGVyd2lzZSwgYW4gZW1wdHkgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaW1wb3NlcyBhIGxpbWl0YXRpb24gb24gb2JqZWN0IGtleXMgb25lIGNhbiB1c2Ugd2l0aCBJbnNwZWN0b3IuXG4gICAgICAgICAgICAgICAgLy8gUHVyZSBpbnRlZ2VyIGtleXMgd2lsbCBjYXVzZSBpc3N1ZXMgYW5kIGFyZSB0aGVyZWZvcmUgbm90IGFsbG93ZWQuXG4gICAgICAgICAgICAgICAgdmFyIGluaXRpYWxpemVyID0gdXBkYXRlO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2UHJvcGVydHkgPSBwcm9wZXJ0eTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aEFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhJdGVtID0gcGF0aEFycmF5W2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNBcnJheUluZGV4ID0gTnVtYmVyLmlzRmluaXRlKF9pc1N0cmluZyA/IE51bWJlcihwYXRoSXRlbSkgOiBwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJbcHJldlByb3BlcnR5XSA9IGlzQXJyYXlJbmRleCA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgICAgIHByZXZQcm9wZXJ0eSA9IHBhdGhJdGVtO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpbGwgdXBkYXRlIHdpdGggdGhlIGB2YWx1ZWAgb24gYHBhdGhgLlxuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHNldEJ5UGF0aCh1cGRhdGUsIHBhdGhBcnJheSwgdmFsdWUsICcvJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmFzZUF0dHJpYnV0ZXMgPSBtZXJnZSh7fSwgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAvLyBpZiByZXdyaXRlIG1vZGUgZW5hYmxlZCwgd2UgcmVwbGFjZSB2YWx1ZSByZWZlcmVuY2VkIGJ5IHBhdGggd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBuZXcgb25lICh3ZSBkb24ndCBtZXJnZSkuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZXdyaXRlICYmIHVuc2V0QnlQYXRoKGJhc2VBdHRyaWJ1dGVzLCBwYXRoLCAnLycpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgdXBkYXRlIHdpdGggdGhlIG1vZGVsIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBtZXJnZShiYXNlQXR0cmlidXRlcywgdXBkYXRlKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCBzZXQgdGhlIHByb3BlcnR5IHRvIHRoZSB1cGRhdGVkIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHByb3BlcnR5LCBhdHRyaWJ1dGVzW3Byb3BlcnR5XSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QnlQYXRoKHRoaXMuYXR0cmlidXRlcywgcHJvcHMsIGRlbGltKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZSB8fCB7fTtcbiAgICAgICAgLy8gTm90ZTogJycgaXMgbm90IHRoZSBwYXRoIHRvIHRoZSByb290LiBJdCdzIGEgcGF0aCB3aXRoIGFuIGVtcHR5IHN0cmluZyBpLmUuIHsgJyc6IHt9fS5cbiAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eVBhdGggPSBudWxsO1xuICAgICAgICBvcHRpb25zLnByb3BlcnR5VmFsdWUgPSBwcm9wcztcbiAgICAgICAgb3B0aW9ucy5wcm9wZXJ0eVBhdGhBcnJheSA9IFtdO1xuICAgICAgICBpZiAoISgncmV3cml0ZScgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmV3cml0ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCBjb250YWluaW5nIG9ubHkgdGhlIGNoYW5nZWQgYXR0cmlidXRlcy5cbiAgICAgICAgY29uc3QgY2hhbmdlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIC8vIE1lcmdpbmcgdGhlIHZhbHVlcyBvZiBjaGFuZ2VkIGF0dHJpYnV0ZXMgd2l0aCB0aGUgY3VycmVudCBvbmVzLlxuICAgICAgICAgICAgY29uc3QgeyBjaGFuZ2VkVmFsdWUgfSA9IG1lcmdlKHt9LCB7IGNoYW5nZWRWYWx1ZTogdGhpcy5hdHRyaWJ1dGVzW2tleV0gfSwgeyBjaGFuZ2VkVmFsdWU6IHByb3BzW2tleV0gfSk7XG4gICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlc1trZXldID0gY2hhbmdlZFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGNoYW5nZWRBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQSBjb252ZW5pZW50IHdheSB0byB1bnNldCBuZXN0ZWQgcHJvcGVydGllc1xuICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKHBhdGgsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgcGF0aEFycmF5ID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcvJyk7XG5cbiAgICAgICAgLy8gT25jZSBhIHByb3BlcnR5IGlzIHJlbW92ZWQgZnJvbSB0aGUgYGF0dHJzYCBhdHRyaWJ1dGVcbiAgICAgICAgLy8gdGhlIGNlbGxWaWV3IHdpbGwgcmVjb2duaXplIGEgYGRpcnR5YCBmbGFnIGFuZCByZS1yZW5kZXIgaXRzZWxmXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIGZyb20gU1ZHIGVsZW1lbnQuXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHBhdGhBcnJheVswXTtcbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnYXR0cnMnKSBvcHQuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgIGlmIChwYXRoQXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBBIHRvcCBsZXZlbCBwcm9wZXJ0eVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zZXQocGF0aCwgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgbmVzdGVkIHByb3BlcnR5XG4gICAgICAgIHZhciBuZXN0ZWRQYXRoID0gcGF0aEFycmF5LnNsaWNlKDEpO1xuICAgICAgICB2YXIgcHJvcGVydHlWYWx1ZSA9IHRoaXMuZ2V0KHByb3BlcnR5KTtcbiAgICAgICAgaWYgKHByb3BlcnR5VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0eVZhbHVlID09PSBudWxsKSByZXR1cm4gdGhpcztcbiAgICAgICAgcHJvcGVydHlWYWx1ZSA9IGNsb25lRGVlcChwcm9wZXJ0eVZhbHVlKTtcblxuICAgICAgICB1bnNldEJ5UGF0aChwcm9wZXJ0eVZhbHVlLCBuZXN0ZWRQYXRoLCAnLycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldChwcm9wZXJ0eSwgcHJvcGVydHlWYWx1ZSwgb3B0KTtcbiAgICB9LFxuXG4gICAgLy8gQSBjb252ZW5pZW50IHdheSB0byBzZXQgbmVzdGVkIGF0dHJpYnV0ZXMuXG4gICAgYXR0cjogZnVuY3Rpb24oYXR0cnMsIHZhbHVlLCBvcHQpIHtcblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgICAgICAgIGFyZ3NbMF0gPSBbJ2F0dHJzJ10uY29uY2F0KGF0dHJzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyhhdHRycykpIHtcbiAgICAgICAgICAgIC8vIEdldC9zZXQgYW4gYXR0cmlidXRlIGJ5IGEgc3BlY2lhbCBwYXRoIHN5bnRheCB0aGF0IGRlbGltaXRzXG4gICAgICAgICAgICAvLyBuZXN0ZWQgb2JqZWN0cyBieSB0aGUgY29sb24gY2hhcmFjdGVyLlxuICAgICAgICAgICAgYXJnc1swXSA9ICdhdHRycy8nICsgYXR0cnM7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgYXJnc1swXSA9IHsgJ2F0dHJzJyA6IGF0dHJzIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvLyBBIGNvbnZlbmllbnQgd2F5IHRvIHVuc2V0IG5lc3RlZCBhdHRyaWJ1dGVzXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24ocGF0aCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlUHJvcChbJ2F0dHJzJ10uY29uY2F0KHBhdGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVByb3AoJ2F0dHJzLycgKyBwYXRoLCBvcHQpO1xuICAgIH0sXG5cbiAgICB0cmFuc2l0aW9uOiBmdW5jdGlvbihwYXRoLCB2YWx1ZSwgb3B0LCBkZWxpbSkge1xuXG4gICAgICAgIGRlbGltID0gZGVsaW0gfHwgJy8nO1xuXG4gICAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAxMDAsXG4gICAgICAgICAgICBkZWxheTogMTAsXG4gICAgICAgICAgICB0aW1pbmdGdW5jdGlvbjogdGltaW5nLmxpbmVhcixcbiAgICAgICAgICAgIHZhbHVlRnVuY3Rpb246IGludGVycG9sYXRlLm51bWJlclxuICAgICAgICB9O1xuXG4gICAgICAgIG9wdCA9IGFzc2lnbihkZWZhdWx0cywgb3B0KTtcblxuICAgICAgICB2YXIgZmlyc3RGcmFtZVRpbWUgPSAwO1xuICAgICAgICB2YXIgaW50ZXJwb2xhdGluZ0Z1bmN0aW9uO1xuXG4gICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbihydW50aW1lKSB7XG5cbiAgICAgICAgICAgIHZhciBpZCwgcHJvZ3Jlc3MsIHByb3BlcnR5VmFsdWU7XG5cbiAgICAgICAgICAgIGZpcnN0RnJhbWVUaW1lID0gZmlyc3RGcmFtZVRpbWUgfHwgcnVudGltZTtcbiAgICAgICAgICAgIHJ1bnRpbWUgLT0gZmlyc3RGcmFtZVRpbWU7XG4gICAgICAgICAgICBwcm9ncmVzcyA9IHJ1bnRpbWUgLyBvcHQuZHVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uSWRzW3BhdGhdID0gaWQgPSBuZXh0RnJhbWUoc2V0dGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSAxO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2l0aW9uSWRzW3BhdGhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wZXJ0eVZhbHVlID0gaW50ZXJwb2xhdGluZ0Z1bmN0aW9uKG9wdC50aW1pbmdGdW5jdGlvbihwcm9ncmVzcykpO1xuXG4gICAgICAgICAgICBvcHQudHJhbnNpdGlvbklkID0gaWQ7XG5cbiAgICAgICAgICAgIHRoaXMucHJvcChwYXRoLCBwcm9wZXJ0eVZhbHVlLCBvcHQpO1xuXG4gICAgICAgICAgICBpZiAoIWlkKSB0aGlzLnRyaWdnZXIoJ3RyYW5zaXRpb246ZW5kJywgdGhpcywgcGF0aCk7XG5cbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGNvbnN0IHsgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpbml0aWFsSWQ7XG5cbiAgICAgICAgdmFyIGluaXRpYXRvciA9IChjYWxsYmFjaykgPT4ge1xuXG4gICAgICAgICAgICBpZiAoX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0pIHtcbiAgICAgICAgICAgICAgICBfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXSA9IHdpdGhvdXQoX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0sIGluaXRpYWxJZCk7XG4gICAgICAgICAgICAgICAgaWYgKF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0b3BQZW5kaW5nVHJhbnNpdGlvbnMocGF0aCwgZGVsaW0pO1xuXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW5nRnVuY3Rpb24gPSBvcHQudmFsdWVGdW5jdGlvbihnZXRCeVBhdGgodGhpcy5hdHRyaWJ1dGVzLCBwYXRoLCBkZWxpbSksIHZhbHVlKTtcblxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbklkc1twYXRoXSA9IG5leHRGcmFtZShjYWxsYmFjayk7XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndHJhbnNpdGlvbjpzdGFydCcsIHRoaXMsIHBhdGgpO1xuXG4gICAgICAgIH07XG5cbiAgICAgICAgaW5pdGlhbElkID0gc2V0VGltZW91dChpbml0aWF0b3IsIG9wdC5kZWxheSwgc2V0dGVyKTtcblxuICAgICAgICBfc2NoZWR1bGVkVHJhbnNpdGlvbklkc1twYXRoXSB8fCAoX3NjaGVkdWxlZFRyYW5zaXRpb25JZHNbcGF0aF0gPSBbXSk7XG4gICAgICAgIF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW3BhdGhdLnB1c2goaW5pdGlhbElkKTtcblxuICAgICAgICByZXR1cm4gaW5pdGlhbElkO1xuICAgIH0sXG5cbiAgICBnZXRUcmFuc2l0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1bmlvbihcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3RyYW5zaXRpb25JZHMpLFxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fc2NoZWR1bGVkVHJhbnNpdGlvbklkcylcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgc3RvcFNjaGVkdWxlZFRyYW5zaXRpb25zOiBmdW5jdGlvbihwYXRoLCBkZWxpbSA9ICcvJykge1xuICAgICAgICBjb25zdCB7IF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzID0ge319ID0gdGhpcztcbiAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gT2JqZWN0LmtleXMoX3NjaGVkdWxlZFRyYW5zaXRpb25JZHMpO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgY29uc3QgcGF0aEFycmF5ID0gcGF0aC5zcGxpdChkZWxpbSk7XG4gICAgICAgICAgICB0cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwocGF0aEFycmF5LCBrZXkuc3BsaXQoZGVsaW0pLnNsaWNlKDAsIHBhdGhBcnJheS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb25zLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbklkcyA9IF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW2tleV07XG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBpbml0aWF0b3JcbiAgICAgICAgICAgIHRyYW5zaXRpb25JZHMuZm9yRWFjaCh0cmFuc2l0aW9uSWQgPT4gY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25JZCkpO1xuICAgICAgICAgICAgZGVsZXRlIF9zY2hlZHVsZWRUcmFuc2l0aW9uSWRzW2tleV07XG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBjb3VsZCB0cmlnZ2VyIHRyYW5zaXRpb246Y2FuY2VsYCBldmVudCBoZXJlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RvcFBlbmRpbmdUcmFuc2l0aW9ucyhwYXRoLCBkZWxpbSA9ICcvJykge1xuICAgICAgICBjb25zdCB7IF90cmFuc2l0aW9uSWRzID0ge319ID0gdGhpcztcbiAgICAgICAgbGV0IHRyYW5zaXRpb25zID0gT2JqZWN0LmtleXMoX3RyYW5zaXRpb25JZHMpO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgY29uc3QgcGF0aEFycmF5ID0gcGF0aC5zcGxpdChkZWxpbSk7XG4gICAgICAgICAgICB0cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwocGF0aEFycmF5LCBrZXkuc3BsaXQoZGVsaW0pLnNsaWNlKDAsIHBhdGhBcnJheS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zaXRpb25zLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNpdGlvbklkID0gX3RyYW5zaXRpb25JZHNba2V5XTtcbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIHNldHRlclxuICAgICAgICAgICAgY2FuY2VsRnJhbWUodHJhbnNpdGlvbklkKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdHJhbnNpdGlvbklkc1trZXldO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0cmFuc2l0aW9uOmVuZCcsIHRoaXMsIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzdG9wVHJhbnNpdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIGRlbGltID0gJy8nKSB7XG4gICAgICAgIHRoaXMuc3RvcFNjaGVkdWxlZFRyYW5zaXRpb25zKHBhdGgsIGRlbGltKTtcbiAgICAgICAgdGhpcy5zdG9wUGVuZGluZ1RyYW5zaXRpb25zKHBhdGgsIGRlbGltKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgc2hvcmN1dCBtYWtpbmcgaXQgZWFzeSB0byBjcmVhdGUgY29uc3RydWN0cyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gYHZhciBlbCA9IChuZXcgam9pbnQuc2hhcGVzLnN0YW5kYXJkLlJlY3RhbmdsZSgpKS5hZGRUbyhncmFwaClgLlxuICAgIGFkZFRvOiBmdW5jdGlvbihncmFwaCwgb3B0KSB7XG5cbiAgICAgICAgZ3JhcGguYWRkQ2VsbCh0aGlzLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQSBzaG9ydGN1dCBmb3IgYW4gZXF1aXZhbGVudCBjYWxsOiBgcGFwZXIuZmluZFZpZXdCeU1vZGVsKGNlbGwpYFxuICAgIC8vIG1ha2luZyBpdCBlYXN5IHRvIGNyZWF0ZSBjb25zdHJ1Y3RzIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgICAvLyBgY2VsbC5maW5kVmlldyhwYXBlcikuaGlnaGxpZ2h0KClgXG4gICAgZmluZFZpZXc6IGZ1bmN0aW9uKHBhcGVyKSB7XG5cbiAgICAgICAgcmV0dXJuIHBhcGVyLmZpbmRWaWV3QnlNb2RlbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgaXNFbGVtZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGlzTGluazogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBzdGFydEJhdGNoOiBmdW5jdGlvbihuYW1lLCBvcHQpIHtcblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkgeyB0aGlzLmdyYXBoLnN0YXJ0QmF0Y2gobmFtZSwgYXNzaWduKHt9LCBvcHQsIHsgY2VsbDogdGhpcyB9KSk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0b3BCYXRjaDogZnVuY3Rpb24obmFtZSwgb3B0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHsgdGhpcy5ncmFwaC5zdG9wQmF0Y2gobmFtZSwgYXNzaWduKHt9LCBvcHQsIHsgY2VsbDogdGhpcyB9KSk7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldENoYW5nZUZsYWc6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcblxuICAgICAgICB2YXIgZmxhZyA9IDA7XG4gICAgICAgIGlmICghYXR0cmlidXRlcykgcmV0dXJuIGZsYWc7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAhdGhpcy5oYXNDaGFuZ2VkKGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgZmxhZyB8PSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgfSxcblxuICAgIGFuZ2xlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBUbyBiZSBvdmVycmlkZGVuLlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFRvIGJlIG92ZXJyaWRkZW4uXG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2ludCgwLCAwKTtcbiAgICB9LFxuXG4gICAgejogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgneicpIHx8IDA7XG4gICAgfSxcblxuICAgIGdldFBvaW50RnJvbUNvbm5lY3RlZExpbms6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgcmV0dXJuIG5ldyBnLlBvaW50KCk7XG4gICAgfSxcblxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgcmV0dXJuIG5ldyBnLlJlY3QoMCwgMCwgMCwgMCk7XG4gICAgfSxcblxuICAgIGdldFBvaW50Um90YXRlZEFyb3VuZENlbnRlcihhbmdsZSwgeCwgeSkge1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBnLlBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoYW5nbGUpIHBvaW50LnJvdGF0ZSh0aGlzLmdldEJCb3goKS5jZW50ZXIoKSwgYW5nbGUpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcblxuICAgIGdldEFic29sdXRlUG9pbnRGcm9tUmVsYXRpdmUoeCwgeSkge1xuICAgICAgICAvLyBSb3RhdGUgdGhlIHBvc2l0aW9uIHRvIHRha2UgdGhlIG1vZGVsIGFuZ2xlIGludG8gYWNjb3VudFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludFJvdGF0ZWRBcm91bmRDZW50ZXIoXG4gICAgICAgICAgICAtdGhpcy5hbmdsZSgpLFxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB0byBhYnNvbHV0ZVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbigpLm9mZnNldCh4LCB5KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBnZXRSZWxhdGl2ZVBvaW50RnJvbUFic29sdXRlKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC8vIFJvdGF0ZSB0aGUgY29vcmRpbmF0ZXMgdG8gbWl0aWdhdGUgdGhlIGVsZW1lbnQncyByb3RhdGlvbi5cbiAgICAgICAgICAgIC5nZXRQb2ludFJvdGF0ZWRBcm91bmRDZW50ZXIodGhpcy5hbmdsZSgpLCB4LCB5KVxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpbnRvIHJlbGF0aXZlXG4gICAgICAgICAgICAuZGlmZmVyZW5jZSh0aGlzLnBvc2l0aW9uKCkpO1xuICAgIH1cblxufSwge1xuXG4gICAgZ2V0QXR0cmlidXRlRGVmaW5pdGlvbjogZnVuY3Rpb24oYXR0ck5hbWUpIHtcblxuICAgICAgICB2YXIgZGVmTlMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBnbG9iYWxEZWZOUyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHJldHVybiAoZGVmTlMgJiYgZGVmTlNbYXR0ck5hbWVdKSB8fCBnbG9iYWxEZWZOU1thdHRyTmFtZV07XG4gICAgfSxcblxuICAgIGRlZmluZTogZnVuY3Rpb24odHlwZSwgZGVmYXVsdHMsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG5cbiAgICAgICAgcHJvdG9Qcm9wcyA9IGFzc2lnbih7XG4gICAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHNEZWVwKHsgdHlwZTogdHlwZSB9LCBkZWZhdWx0cywgdGhpcy5wcm90b3R5cGUuZGVmYXVsdHMpXG4gICAgICAgIH0sIHByb3RvUHJvcHMpO1xuXG4gICAgICAgIHZhciBDZWxsID0gdGhpcy5leHRlbmQocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpO1xuICAgICAgICAvLyBlczUgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgICAgICBpZiAodHlwZW9mIGpvaW50ICE9PSAndW5kZWZpbmVkJyAmJiBoYXMoam9pbnQsICdzaGFwZXMnKSkge1xuICAgICAgICAgICAgc2V0QnlQYXRoKGpvaW50LnNoYXBlcywgdHlwZSwgQ2VsbCwgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG4gICAgICAgIHJldHVybiBDZWxsO1xuICAgIH1cbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/CellView.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CellView: function() { return /* binding */ CellView; }\n/* harmony export */ });\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../config/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n/* harmony import */ var _attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attributes/eval.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/eval.mjs\");\n\n\n\n\n\n\n\n\n\nconst HighlightingTypes = {\n    DEFAULT: 'default',\n    EMBEDDING: 'embedding',\n    CONNECTING: 'connecting',\n    MAGNET_AVAILABILITY: 'magnetAvailability',\n    ELEMENT_AVAILABILITY: 'elementAvailability'\n};\n\nconst Flags = {\n    TOOLS: 'TOOLS',\n};\n\n// CellView base view and controller.\n// --------------------------------------------\n\n// This is the base view and controller for `ElementView` and `LinkView`.\nconst CellView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n\n    tagName: 'g',\n\n    svgElement: true,\n\n    selector: 'root',\n\n    metrics: null,\n\n    className: function() {\n\n        var classNames = ['cell'];\n        var type = this.model.get('type');\n\n        if (type) {\n\n            type.toLowerCase().split('.').forEach(function(value, index, list) {\n                classNames.push('type-' + list.slice(0, index + 1).join('-'));\n            });\n        }\n\n        return classNames.join(' ');\n    },\n\n    _presentationAttributes: null,\n    _flags: null,\n\n    setFlags: function() {\n        var flags = {};\n        var attributes = {};\n        var shift = 0;\n        var i, n, label;\n        var presentationAttributes = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'presentationAttributes');\n        for (var attribute in presentationAttributes) {\n            if (!presentationAttributes.hasOwnProperty(attribute)) continue;\n            var labels = presentationAttributes[attribute];\n            if (!Array.isArray(labels)) labels = [labels];\n            for (i = 0, n = labels.length; i < n; i++) {\n                label = labels[i];\n                var flag = flags[label];\n                if (!flag) {\n                    flag = flags[label] = 1<<(shift++);\n                }\n                attributes[attribute] |= flag;\n            }\n        }\n        var initFlag = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'initFlag');\n        if (!Array.isArray(initFlag)) initFlag = [initFlag];\n        for (i = 0, n = initFlag.length; i < n; i++) {\n            label = initFlag[i];\n            if (!flags[label]) flags[label] = 1<<(shift++);\n        }\n\n        // 26 - 30 are reserved for paper flags\n        // 31+ overflows maximal number\n        if (shift > 25) throw new Error('dia.CellView: Maximum number of flags exceeded.');\n\n        this._flags = flags;\n        this._presentationAttributes = attributes;\n    },\n\n    hasFlag: function(flag, label) {\n        return flag & this.getFlag(label);\n    },\n\n    removeFlag: function(flag, label) {\n        return flag ^ (flag & this.getFlag(label));\n    },\n\n    getFlag: function(label) {\n        var flags = this._flags;\n        if (!flags) return 0;\n        var flag = 0;\n        if (Array.isArray(label)) {\n            for (var i = 0, n = label.length; i < n; i++) flag |= flags[label[i]];\n        } else {\n            flag |= flags[label];\n        }\n        return flag;\n    },\n\n    attributes: function() {\n        var cell = this.model;\n        return {\n            'model-id': cell.id,\n            'data-type': cell.attributes.type\n        };\n    },\n\n    constructor: function(options) {\n\n        // Make sure a global unique id is assigned to this view. Store this id also to the properties object.\n        // The global unique id makes sure that the same view can be rendered on e.g. different machines and\n        // still be associated to the same object among all those clients. This is necessary for real-time\n        // collaboration mechanism.\n        options.id = options.id || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.guid)(this);\n\n        _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.call(this, options);\n    },\n\n    initialize: function() {\n\n        this.setFlags();\n\n        _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.prototype.initialize.apply(this, arguments);\n\n        this.cleanNodesCache();\n\n        this.startListening();\n    },\n\n    startListening: function() {\n        this.listenTo(this.model, 'change', this.onAttributesChange);\n    },\n\n    onAttributesChange: function(model, opt) {\n        var flag = model.getChangeFlag(this._presentationAttributes);\n        if (opt.updateHandled || !flag) return;\n        if (opt.dirty && this.hasFlag(flag, 'UPDATE')) flag |= this.getFlag('RENDER');\n        // TODO: tool changes does not need to be sync\n        // Fix Segments tools\n        if (opt.tool) opt.async = false;\n        this.requestUpdate(flag, opt);\n    },\n\n    requestUpdate: function(flags, opt) {\n        const { paper } = this;\n        if (paper && flags > 0) {\n            paper.requestViewUpdate(this, flags, this.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    parseDOMJSON: function(markup, root) {\n\n        var doc = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.parseDOMJSON)(markup);\n        var selectors = doc.selectors;\n        var groups = doc.groupSelectors;\n        for (var group in groups) {\n            if (selectors[group]) throw new Error('dia.CellView: ambiguous group selector');\n            selectors[group] = groups[group];\n        }\n        if (root) {\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.CellView: ambiguous root selector.');\n            selectors[rootSelector] = root;\n        }\n        return { fragment: doc.fragment, selectors: selectors };\n    },\n\n    // Return `true` if cell link is allowed to perform a certain UI `feature`.\n    // Example: `can('labelMove')`.\n    can: function(feature) {\n\n        var interactive = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.options.interactive)\n            ? this.options.interactive(this)\n            : this.options.interactive;\n\n        return ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(interactive) && interactive[feature] !== false) ||\n            ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isBoolean)(interactive) && interactive !== false);\n    },\n\n    findBySelector: function(selector, root, selectors) {\n\n        // These are either descendants of `this.$el` of `this.$el` itself.\n        // `.` is a special selector used to select the wrapping `<g>` element.\n        if (!selector || selector === '.') return [root];\n        if (selectors) {\n            var nodes = selectors[selector];\n            if (nodes) {\n                if (Array.isArray(nodes)) return nodes;\n                return [nodes];\n            }\n        }\n\n        // Maintaining backwards compatibility\n        // e.g. `circle:first` would fail with querySelector() call\n        if (this.useCSSSelectors) return (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(root).find(selector).toArray();\n\n        return [];\n    },\n\n    findNodes: function(selector) {\n        return this.findBySelector(selector, this.el, this.selectors);\n    },\n\n    findNode: function(selector) {\n        const [node = null] = this.findNodes(selector);\n        return node;\n    },\n\n    notify: function(eventName) {\n\n        if (this.paper) {\n\n            var args = Array.prototype.slice.call(arguments, 1);\n\n            // Trigger the event on both the element itself and also on the paper.\n            this.trigger.apply(this, [eventName].concat(args));\n\n            // Paper event handlers receive the view object as the first argument.\n            this.paper.trigger.apply(this.paper, [eventName, this].concat(args));\n        }\n    },\n\n    getBBox: function(opt) {\n\n        var bbox;\n        if (opt && opt.useModelGeometry) {\n            var model = this.model;\n            bbox = model.getBBox().bbox(model.angle());\n        } else {\n            bbox = this.getNodeBBox(this.el);\n        }\n\n        return this.paper.localToPaperRect(bbox);\n    },\n\n    getNodeBBox: function(magnet) {\n\n        const rect = this.getNodeBoundingRect(magnet);\n        const transformMatrix = this.getRootTranslateMatrix().multiply(this.getNodeRotateMatrix(magnet));\n        const magnetMatrix = this.getNodeMatrix(magnet);\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformRect(rect, transformMatrix.multiply(magnetMatrix));\n    },\n\n    getNodeRotateMatrix(node) {\n        if (!this.rotatableNode || this.rotatableNode.contains(node)) {\n            // Rotate transformation is applied to all nodes when no rotatableGroup\n            // is present or to nodes inside the rotatableGroup only.\n            return this.getRootRotateMatrix();\n        }\n        // Nodes outside the rotatable group\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix();\n    },\n\n    getNodeUnrotatedBBox: function(magnet) {\n\n        var rect = this.getNodeBoundingRect(magnet);\n        var magnetMatrix = this.getNodeMatrix(magnet);\n        var translateMatrix = this.getRootTranslateMatrix();\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformRect(rect, translateMatrix.multiply(magnetMatrix));\n    },\n\n    getRootTranslateMatrix: function() {\n\n        var model = this.model;\n        var position = model.position();\n        var mt = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix().translate(position.x, position.y);\n        return mt;\n    },\n\n    getRootRotateMatrix: function() {\n\n        var mr = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix();\n        var model = this.model;\n        var angle = model.angle();\n        if (angle) {\n            var bbox = model.getBBox();\n            var cx = bbox.width / 2;\n            var cy = bbox.height / 2;\n            mr = mr.translate(cx, cy).rotate(angle).translate(-cx, -cy);\n        }\n        return mr;\n    },\n\n    _notifyHighlight: function(eventName, el, opt = {}) {\n        const { el: rootNode } = this;\n        let node;\n        if (typeof el === 'string') {\n            node = this.findNode(el) || rootNode;\n        } else {\n            [node = rootNode] = this.$(el);\n        }\n        // set partial flag if the highlighted element is not the entire view.\n        opt.partial = (node !== rootNode);\n        // translate type flag into a type string\n        if (opt.type === undefined) {\n            let type;\n            switch (true) {\n                case opt.embedding:\n                    type = HighlightingTypes.EMBEDDING;\n                    break;\n                case opt.connecting:\n                    type = HighlightingTypes.CONNECTING;\n                    break;\n                case opt.magnetAvailability:\n                    type = HighlightingTypes.MAGNET_AVAILABILITY;\n                    break;\n                case opt.elementAvailability:\n                    type = HighlightingTypes.ELEMENT_AVAILABILITY;\n                    break;\n                default:\n                    type = HighlightingTypes.DEFAULT;\n                    break;\n            }\n            opt.type = type;\n        }\n        this.notify(eventName, node, opt);\n        return this;\n    },\n\n    highlight: function(el, opt) {\n        return this._notifyHighlight('cell:highlight', el, opt);\n    },\n\n    unhighlight: function(el, opt = {}) {\n        return this._notifyHighlight('cell:unhighlight', el, opt);\n    },\n\n    // Find the closest element that has the `magnet` attribute set to `true`. If there was not such\n    // an element found, return the root element of the cell view.\n    findMagnet: function(el) {\n\n        const root = this.el;\n        let magnet = this.$(el)[0];\n        if (!magnet) {\n            magnet = root;\n        }\n\n        do {\n            const magnetAttribute = magnet.getAttribute('magnet');\n            const isMagnetRoot = (magnet === root);\n            if ((magnetAttribute || isMagnetRoot) && magnetAttribute !== 'false') {\n                return magnet;\n            }\n            if (isMagnetRoot) {\n                // If the overall cell has set `magnet === false`, then return `undefined` to\n                // announce there is no magnet found for this cell.\n                // This is especially useful to set on cells that have 'ports'. In this case,\n                // only the ports have set `magnet === true` and the overall element has `magnet === false`.\n                return undefined;\n            }\n            magnet = magnet.parentNode;\n        } while (magnet);\n\n        return undefined;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const proxyNode = this.findNode(nodeSelector);\n            if (proxyNode) return proxyNode;\n        }\n        return el;\n    },\n\n    // Construct a unique selector for the `el` element within this view.\n    // `prevSelector` is being collected through the recursive call.\n    // No value for `prevSelector` is expected when using this method.\n    getSelector: function(el, prevSelector) {\n\n        var selector;\n\n        if (el === this.el) {\n            if (typeof prevSelector === 'string') selector = ':scope > ' + prevSelector;\n            return selector;\n        }\n\n        if (el) {\n\n            var nthChild = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(el).index() + 1;\n            selector = el.tagName + ':nth-child(' + nthChild + ')';\n\n            if (prevSelector) {\n                selector += ' > ' + prevSelector;\n            }\n\n            selector = this.getSelector(el.parentNode, selector);\n        }\n\n        return selector;\n    },\n\n    addLinkFromMagnet: function(magnet, x, y) {\n\n        var paper = this.paper;\n        var graph = paper.model;\n\n        var link = paper.getDefaultLink(this, magnet);\n        link.set({\n            source: this.getLinkEnd(magnet, x, y, link, 'source'),\n            target: { x: x, y: y }\n        }).addTo(graph, {\n            async: false,\n            ui: true\n        });\n\n        return link.findView(paper);\n    },\n\n    getLinkEnd: function(magnet, ...args) {\n\n        const model = this.model;\n        const id = model.id;\n        // Find a node with the `port` attribute set on it.\n        const portNode = this.findAttributeNode('port', magnet);\n        // Find a unique `selector` of the element under pointer that is a magnet.\n        const selector = magnet.getAttribute('joint-selector');\n\n        const end = { id: id };\n        if (selector != null) end.magnet = selector;\n        if (portNode != null) {\n            let port = portNode.getAttribute('port');\n            if (portNode.getAttribute('port-id-type') === 'number') {\n                port = parseInt(port, 10);\n            }\n            end.port = port;\n            if (!model.hasPort(port) && !selector) {\n                // port created via the `port` attribute (not API)\n                end.selector = this.getSelector(magnet);\n            }\n        } else if (selector == null && this.el !== magnet) {\n            end.selector = this.getSelector(magnet);\n        }\n\n        return this.customizeLinkEnd(end, magnet, ...args);\n    },\n\n    customizeLinkEnd: function(end, magnet, x, y, link, endType) {\n        const { paper } = this;\n        const { connectionStrategy } = paper.options;\n        if (typeof connectionStrategy === 'function') {\n            var strategy = connectionStrategy.call(paper, end, this, magnet, new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(x, y), link, endType, paper);\n            if (strategy) return strategy;\n        }\n        return end;\n    },\n\n    getMagnetFromLinkEnd: function(end) {\n\n        var port = end.port;\n        var selector = end.magnet;\n        var model = this.model;\n        var magnet;\n        if (port != null && model.isElement() && model.hasPort(port)) {\n            magnet = this.findPortNode(port, selector) || this.el;\n        } else {\n            if (!selector) selector = end.selector;\n            if (!selector && port != null) {\n                // link end has only `id` and `port` property referencing\n                // a port created via the `port` attribute (not API).\n                selector = '[port=\"' + port + '\"]';\n            }\n            magnet = this.findNode(selector);\n        }\n\n        return this.findProxyNode(magnet, 'magnet');\n    },\n\n    dragLinkStart: function(evt, magnet, x, y) {\n        this.model.startBatch('add-link');\n        const linkView = this.addLinkFromMagnet(magnet, x, y);\n        // backwards compatibility events\n        linkView.notifyPointerdown(evt, x, y);\n        linkView.eventData(evt, linkView.startArrowheadMove('target', { whenNotAllowed: 'remove' }));\n        this.eventData(evt, { linkView });\n    },\n\n    dragLink: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (linkView) {\n            linkView.pointermove(evt, x, y);\n        } else {\n            var paper = this.paper;\n            var magnetThreshold = paper.options.magnetThreshold;\n            var currentTarget = this.getEventTarget(evt);\n            var targetMagnet = data.targetMagnet;\n            if (magnetThreshold === 'onleave') {\n                // magnetThreshold when the pointer leaves the magnet\n                if (targetMagnet === currentTarget || (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(targetMagnet).contains(currentTarget)) return;\n            } else {\n                // magnetThreshold defined as a number of movements\n                if (paper.eventData(evt).mousemoved <= magnetThreshold) return;\n            }\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n    },\n\n    dragLinkEnd: function(evt, x, y) {\n        var data = this.eventData(evt);\n        var linkView = data.linkView;\n        if (!linkView) return;\n        linkView.pointerup(evt, x, y);\n        this.model.stopBatch('add-link');\n    },\n\n    getAttributeDefinition: function(attrName) {\n\n        return this.model.constructor.getAttributeDefinition(attrName);\n    },\n\n    setNodeAttributes: function(node, attrs) {\n\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(attrs)) {\n            if (node instanceof SVGElement) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(node).attr(attrs);\n            } else {\n                (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node).attr(attrs);\n            }\n        }\n    },\n\n    processNodeAttributes: function(node, attrs) {\n\n        var attrName, attrVal, def, i, n;\n        var normalAttrs, setAttrs, positionAttrs, offsetAttrs;\n        var relatives = [];\n        const rawAttrs = {};\n        for (attrName in attrs) {\n            if (!attrs.hasOwnProperty(attrName)) continue;\n            rawAttrs[_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].attributeNames[attrName]] = attrs[attrName];\n        }\n        // divide the attributes between normal and special\n        for (attrName in rawAttrs) {\n            if (!rawAttrs.hasOwnProperty(attrName)) continue;\n            attrVal = rawAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            if (def) {\n                if (attrVal === null) {\n                    // Assign the unset attribute name.\n                    let unsetAttrName;\n                    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.unset)) {\n                        unsetAttrName = def.unset.call(this, node, rawAttrs, this);\n                    } else {\n                        unsetAttrName = def.unset;\n                    }\n                    if (!unsetAttrName && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(def.set)) {\n                        // We unset an alias attribute.\n                        unsetAttrName = def.set;\n                    }\n                    if (!unsetAttrName) {\n                        // There is no alias for the attribute. We unset the attribute itself.\n                        unsetAttrName = attrName;\n                    }\n                    // Unset the attribute.\n                    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(unsetAttrName) && unsetAttrName) {\n                        // Unset a single attribute.\n                        normalAttrs || (normalAttrs = {});\n                        // values takes precedence over unset values\n                        if (unsetAttrName in normalAttrs) continue;\n                        normalAttrs[unsetAttrName] = attrVal;\n                    } else if (Array.isArray(unsetAttrName) && unsetAttrName.length > 0) {\n                        // Unset multiple attributes.\n                        normalAttrs || (normalAttrs = {});\n                        for (i = 0, n = unsetAttrName.length; i < n; i++) {\n                            const attrName = unsetAttrName[i];\n                            // values takes precedence over unset values\n                            if (attrName in normalAttrs) continue;\n                            normalAttrs[attrName] = attrVal;\n                        }\n                    }\n                    // The unset value is neither a string nor an array.\n                    // The attribute is not unset.\n                } else {\n                    if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.qualify) || def.qualify.call(this, attrVal, node, rawAttrs, this)) {\n                        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(def.set)) {\n                            // An alias e.g 'xlink:href' -> 'href'\n                            normalAttrs || (normalAttrs = {});\n                            normalAttrs[def.set] = attrVal;\n                        }\n                        relatives.push(attrName, def);\n                    } else {\n                        normalAttrs || (normalAttrs = {});\n                        normalAttrs[attrName] = attrVal;\n                    }\n                }\n            } else {\n                normalAttrs || (normalAttrs = {});\n                normalAttrs[attrName] = attrVal;\n            }\n        }\n\n        // handle the rest of attributes via related method\n        // from the special attributes namespace.\n        for (i = 0, n = relatives.length; i < n; i+=2) {\n            attrName = relatives[i];\n            def = relatives[i+1];\n            attrVal = attrs[attrName];\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.set)) {\n                setAttrs || (setAttrs = {});\n                setAttrs[attrName] = attrVal;\n            }\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.position)) {\n                positionAttrs || (positionAttrs = {});\n                positionAttrs[attrName] = attrVal;\n            }\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(def.offset)) {\n                offsetAttrs || (offsetAttrs = {});\n                offsetAttrs[attrName] = attrVal;\n            }\n        }\n\n        return {\n            raw: rawAttrs,\n            normal: normalAttrs,\n            set: setAttrs,\n            position: positionAttrs,\n            offset: offsetAttrs\n        };\n    },\n\n    updateRelativeAttributes: function(node, attrs, refBBox, opt) {\n\n        opt || (opt = {});\n\n        var attrName, attrVal, def;\n        var evalAttrs = (0,_attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__.evalAttributes)(attrs.raw || {}, refBBox);\n        var nodeAttrs = attrs.normal || {};\n        for (const nodeAttrName in nodeAttrs) {\n            nodeAttrs[nodeAttrName] = evalAttrs[nodeAttrName];\n        }\n        var setAttrs = attrs.set;\n        var positionAttrs = attrs.position;\n        var offsetAttrs = attrs.offset;\n\n        for (attrName in setAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // SET - set function should return attributes to be set on the node,\n            // which will affect the node dimensions based on the reference bounding\n            // box. e.g. `width`, `height`, `d`, `rx`, `ry`, `points\n            var setResult = def.set.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(setResult)) {\n                (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(nodeAttrs, setResult);\n            } else if (setResult !== undefined) {\n                nodeAttrs[attrName] = setResult;\n            }\n        }\n\n        if (node instanceof HTMLElement) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.setNodeAttributes(node, nodeAttrs);\n            return;\n        }\n\n        // The final translation of the subelement.\n        var nodeTransform = nodeAttrs.transform;\n        var nodeMatrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformStringToMatrix(nodeTransform);\n        var nodePosition = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point)(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            nodeAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit)(nodeAttrs, 'transform');\n            nodeMatrix.e = nodeMatrix.f = 0;\n        }\n\n        // Calculate node scale determined by the scalable group\n        // only if later needed.\n        var sx, sy, translation;\n        if (positionAttrs || offsetAttrs) {\n            var nodeScale = this.getNodeScale(node, opt.scalableNode);\n            sx = nodeScale.sx;\n            sy = nodeScale.sy;\n        }\n\n        var positioned = false;\n        for (attrName in positionAttrs) {\n            attrVal = evalAttrs[attrName];\n            def = this.getAttributeDefinition(attrName);\n            // POSITION - position function should return a point from the\n            // reference bounding box. The default position of the node is x:0, y:0 of\n            // the reference bounding box or could be further specify by some\n            // SVG attributes e.g. `x`, `y`\n            translation = def.position.call(this, attrVal, refBBox.clone(), node, evalAttrs, this);\n            if (translation) {\n                nodePosition.offset((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point)(translation).scale(sx, sy));\n                positioned || (positioned = true);\n            }\n        }\n\n        // The node bounding box could depend on the `size` set from the previous loop.\n        // Here we know, that all the size attributes have been already set.\n        this.setNodeAttributes(node, nodeAttrs);\n\n        var offseted = false;\n        if (offsetAttrs) {\n            // Check if the node is visible\n            var nodeBoundingRect = this.getNodeBoundingRect(node);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                var nodeBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].transformRect(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                for (attrName in offsetAttrs) {\n                    attrVal = evalAttrs[attrName];\n                    def = this.getAttributeDefinition(attrName);\n                    // OFFSET - offset function should return a point from the element\n                    // bounding box. The default offset point is x:0, y:0 (origin) or could be further\n                    // specify with some SVG attributes e.g. `text-anchor`, `cx`, `cy`\n                    translation = def.offset.call(this, attrVal, nodeBBox, node, evalAttrs, this);\n                    if (translation) {\n                        nodePosition.offset((0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point)(translation).scale(sx, sy));\n                        offseted || (offseted = true);\n                    }\n                }\n            }\n        }\n\n        // Do not touch node's transform attribute if there is no transformation applied.\n        if (nodeTransform !== undefined || positioned || offseted) {\n            // Round the coordinates to 1 decimal point.\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            node.setAttribute('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].matrixToTransformString(nodeMatrix));\n            // TODO: store nodeMatrix metrics?\n        }\n    },\n\n    getNodeScale: function(node, scalableNode) {\n\n        // Check if the node is a descendant of the scalable group.\n        var sx, sy;\n        if (scalableNode && scalableNode.contains(node)) {\n            var scale = scalableNode.scale();\n            sx = 1 / scale.sx;\n            sy = 1 / scale.sy;\n        } else {\n            sx = 1;\n            sy = 1;\n        }\n\n        return { sx: sx, sy: sy };\n    },\n\n    cleanNodesCache: function() {\n        this.metrics = {};\n    },\n\n    cleanNodeCache: function(node) {\n        const id = node.id;\n        if (!id) return;\n        delete this.metrics[id];\n    },\n\n    nodeCache: function(magnet) {\n\n        var metrics = this.metrics;\n        // Don't use cache? It most likely a custom view with overridden update.\n        if (!metrics) return {};\n        var id = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ensureId(magnet);\n        var value = metrics[id];\n        if (!value) value = metrics[id] = {};\n        return value;\n    },\n\n    getNodeData: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (!metrics.data) metrics.data = {};\n        return metrics.data;\n    },\n\n    getNodeBoundingRect: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.boundingRect === undefined) metrics.boundingRect = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(magnet).getBBox();\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Rect(metrics.boundingRect);\n    },\n\n    getNodeMatrix: function(magnet) {\n\n        const metrics = this.nodeCache(magnet);\n        if (metrics.magnetMatrix === undefined) {\n            const { rotatableNode, el } = this;\n            let target;\n            if (rotatableNode && rotatableNode.contains(magnet)) {\n                target = rotatableNode;\n            } else {\n                target = el;\n            }\n            metrics.magnetMatrix = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(magnet).getTransformToElement(target);\n        }\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix(metrics.magnetMatrix);\n    },\n\n    getNodeShape: function(magnet) {\n\n        var metrics = this.nodeCache(magnet);\n        if (metrics.geometryShape === undefined) metrics.geometryShape = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(magnet).toGeometryShape();\n        return metrics.geometryShape.clone();\n    },\n\n    isNodeConnection: function(node) {\n        return this.model.isLink() && (!node || node === this.el);\n    },\n\n    findNodesAttributes: function(attrs, root, selectorCache, selectors) {\n\n        var i, n, nodeAttrs, nodeId;\n        var nodesAttrs = {};\n        var mergeIds = [];\n        for (var selector in attrs) {\n            if (!attrs.hasOwnProperty(selector)) continue;\n            nodeAttrs = attrs[selector];\n            if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(nodeAttrs)) continue; // Not a valid selector-attributes pair\n            var selected = selectorCache[selector] = this.findBySelector(selector, root, selectors);\n            for (i = 0, n = selected.length; i < n; i++) {\n                var node = selected[i];\n                nodeId = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ensureId(node);\n                // \"unique\" selectors are selectors that referencing a single node (defined by `selector`)\n                // groupSelector referencing a single node is not \"unique\"\n                var unique = (selectors && selectors[selector] === node);\n                var prevNodeAttrs = nodesAttrs[nodeId];\n                if (prevNodeAttrs) {\n                    // Note, that nodes referenced by deprecated `CSS selectors` are not taken into account.\n                    // e.g. css:`.circle` and selector:`circle` can be applied in a random order\n                    if (!prevNodeAttrs.array) {\n                        mergeIds.push(nodeId);\n                        prevNodeAttrs.array = true;\n                        prevNodeAttrs.attributes = [prevNodeAttrs.attributes];\n                        prevNodeAttrs.selectedLength = [prevNodeAttrs.selectedLength];\n                    }\n                    var attributes = prevNodeAttrs.attributes;\n                    var selectedLength = prevNodeAttrs.selectedLength;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(nodeAttrs);\n                        selectedLength.unshift(-1);\n                    } else {\n                        // node referenced by `groupSelector`\n                        var sortIndex = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.sortedIndex)(selectedLength, n);\n                        attributes.splice(sortIndex, 0, nodeAttrs);\n                        selectedLength.splice(sortIndex, 0, n);\n                    }\n                } else {\n                    nodesAttrs[nodeId] = {\n                        attributes: nodeAttrs,\n                        selectedLength: unique ? -1 : n,\n                        node: node,\n                        array: false\n                    };\n                }\n            }\n        }\n\n        for (i = 0, n = mergeIds.length; i < n; i++) {\n            nodeId = mergeIds[i];\n            nodeAttrs = nodesAttrs[nodeId];\n            nodeAttrs.attributes = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, ...nodeAttrs.attributes.reverse());\n        }\n\n        return nodesAttrs;\n    },\n\n    getEventTarget: function(evt, opt = {}) {\n        const { target, type, clientX = 0, clientY = 0 } = evt;\n        if (\n            // Explicitly defined `fromPoint` option\n            opt.fromPoint ||\n            // Touchmove/Touchend event's target is not reflecting the element under the coordinates as mousemove does.\n            // It holds the element when a touchstart triggered.\n            type === 'touchmove' || type === 'touchend' ||\n            // Pointermove/Pointerup event with the pointer captured\n            ('pointerId' in evt && target.hasPointerCapture(evt.pointerId))\n        ) {\n            return document.elementFromPoint(clientX, clientY);\n        }\n\n        return target;\n    },\n\n    // Default is to process the `model.attributes.attrs` object and set attributes on subelements based on the selectors,\n    // unless `attrs` parameter was passed.\n    updateDOMSubtreeAttributes: function(rootNode, attrs, opt) {\n\n        opt || (opt = {});\n        opt.rootBBox || (opt.rootBBox = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Rect)());\n        opt.selectors || (opt.selectors = this.selectors); // selector collection to use\n\n        // Cache table for query results and bounding box calculation.\n        // Note that `selectorCache` needs to be invalidated for all\n        // `updateAttributes` calls, as the selectors might pointing\n        // to nodes designated by an attribute or elements dynamically\n        // created.\n        var selectorCache = {};\n        var bboxCache = {};\n        var relativeItems = [];\n        var relativeRefItems = [];\n        var item, node, nodeAttrs, nodeData, processedAttrs;\n\n        var roAttrs = opt.roAttributes;\n        var nodesAttrs = this.findNodesAttributes(roAttrs || attrs, rootNode, selectorCache, opt.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only  attributes sent to this method.\n        var nodesAllAttrs = (roAttrs)\n            ? this.findNodesAttributes(attrs, rootNode, selectorCache, opt.selectors)\n            : nodesAttrs;\n\n        for (var nodeId in nodesAttrs) {\n            nodeData = nodesAttrs[nodeId];\n            nodeAttrs = nodeData.attributes;\n            node = nodeData.node;\n            processedAttrs = this.processNodeAttributes(node, nodeAttrs);\n\n            if (!processedAttrs.set && !processedAttrs.position && !processedAttrs.offset && !processedAttrs.raw.ref) {\n                // Set all the normal attributes right on the SVG/HTML element.\n                this.setNodeAttributes(node, (0,_attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__.evalAttributes)(processedAttrs.normal, opt.rootBBox));\n\n            } else {\n\n                var nodeAllAttrs = nodesAllAttrs[nodeId] && nodesAllAttrs[nodeId].attributes;\n                var refSelector = (nodeAllAttrs && (nodeAttrs.ref === undefined))\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n\n                var refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] || this.findBySelector(refSelector, rootNode, opt.selectors))[0];\n                    if (!refNode) {\n                        throw new Error('dia.CellView: \"' + refSelector + '\" reference does not exist.');\n                    }\n                } else {\n                    refNode = null;\n                }\n\n                item = {\n                    node: node,\n                    refNode: refNode,\n                    processedAttributes: processedAttrs,\n                    allAttributes: nodeAllAttrs\n                };\n\n                if (refNode) {\n                    // If an element in the list is positioned relative to this one, then\n                    // we want to insert this one before it in the list.\n                    var itemIndex = relativeRefItems.findIndex(function(item) {\n                        return item.refNode === node;\n                    });\n\n                    if (itemIndex > -1) {\n                        relativeRefItems.splice(itemIndex, 0, item);\n                    } else {\n                        relativeRefItems.push(item);\n                    }\n                } else {\n                    // A node with no ref attribute. To be updated before the nodes referencing other nodes.\n                    // The order of no-ref-items is not specified/important.\n                    relativeItems.push(item);\n                }\n            }\n        }\n\n        relativeItems.push(...relativeRefItems);\n\n        for (let i = 0, n = relativeItems.length; i < n; i++) {\n            item = relativeItems[i];\n            node = item.node;\n            refNode = item.refNode;\n\n            // Find the reference element bounding box. If no reference was provided, we\n            // use the optional bounding box.\n            const refNodeId = refNode ? _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ensureId(refNode) : '';\n            let refBBox = bboxCache[refNodeId];\n            if (!refBBox) {\n                // Get the bounding box of the reference element using to the common ancestor\n                // transformation space.\n                //\n                // @example 1\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                //     <rect @selector=\"a\"/>\n                // </g>\n                //\n                // In this case, the reference bounding box can not be affected\n                // by the `transform` attribute of the `<g>` element,\n                // because the exact transformation will be applied to the `a` element\n                // as well as to the `b` element.\n                //\n                // @example 2\n                // <g transform=\"translate(11, 13)\">\n                //     <rect @selector=\"b\" x=\"1\" y=\"2\" width=\"3\" height=\"4\"/>\n                // </g>\n                // <rect @selector=\"a\"/>\n                //\n                // In this case, the reference bounding box have to be affected by the\n                // `transform` attribute of the `<g>` element, because the `a` element\n                // is not descendant of the `<g>` element and will not be affected\n                // by the transformation.\n                refBBox = bboxCache[refNodeId] = (refNode)\n                    ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(refNode).getBBox({ target: getCommonAncestorNode(node, refNode) })\n                    : opt.rootBBox;\n            }\n\n            if (roAttrs) {\n                // if there was a special attribute affecting the position amongst passed-in attributes\n                // we have to merge it with the rest of the element's attributes as they are necessary\n                // to update the position relatively (i.e `ref-x` && 'ref-dx')\n                processedAttrs = this.processNodeAttributes(node, item.allAttributes);\n                this.mergeProcessedAttributes(processedAttrs, item.processedAttributes);\n\n            } else {\n                processedAttrs = item.processedAttributes;\n            }\n\n            this.updateRelativeAttributes(node, processedAttrs, refBBox, opt);\n        }\n    },\n\n    mergeProcessedAttributes: function(processedAttrs, roProcessedAttrs) {\n\n        processedAttrs.set || (processedAttrs.set = {});\n        processedAttrs.position || (processedAttrs.position = {});\n        processedAttrs.offset || (processedAttrs.offset = {});\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(processedAttrs.set, roProcessedAttrs.set);\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(processedAttrs.position, roProcessedAttrs.position);\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(processedAttrs.offset, roProcessedAttrs.offset);\n\n        // Handle also the special transform property.\n        var transform = processedAttrs.normal && processedAttrs.normal.transform;\n        if (transform !== undefined && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        processedAttrs.normal = roProcessedAttrs.normal;\n    },\n\n    // Lifecycle methods\n\n    // Called when the view is attached to the DOM,\n    // as result of `cell.addTo(graph)` being called (isInitialMount === true)\n    // or `paper.options.viewport` returning `true` (isInitialMount === false).\n    onMount(isInitialMount) {\n        if (isInitialMount) return;\n        this.mountTools();\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.mount(this);\n    },\n\n    // Called when the view is detached from the DOM,\n    // as result of `paper.options.viewport` returning `false`.\n    onDetach() {\n        this.unmountTools();\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.unmount(this);\n    },\n\n    // Called when the view is removed from the DOM\n    // as result of `cell.remove()`.\n    onRemove: function() {\n        this.removeTools();\n        this.removeHighlighters();\n    },\n\n    _toolsView: null,\n\n    hasTools: function(name) {\n        var toolsView = this._toolsView;\n        if (!toolsView) return false;\n        if (!name) return true;\n        return (toolsView.getName() === name);\n    },\n\n    addTools: function(toolsView) {\n\n        this.removeTools();\n\n        if (toolsView) {\n            this._toolsView = toolsView;\n            toolsView.configure({ relatedView: this });\n            toolsView.listenTo(this.paper, 'tools:event', this.onToolEvent.bind(this));\n        }\n        return this;\n    },\n\n    unmountTools() {\n        const toolsView = this._toolsView;\n        if (toolsView) toolsView.unmount();\n        return this;\n    },\n\n    mountTools() {\n        const toolsView = this._toolsView;\n        // Prevent unnecessary re-appending of the tools.\n        if (toolsView && !toolsView.isMounted()) toolsView.mount();\n        return this;\n    },\n\n    updateTools: function(opt) {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.update(opt);\n        return this;\n    },\n\n    removeTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) {\n            toolsView.remove();\n            this._toolsView = null;\n        }\n        return this;\n    },\n\n    hideTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.hide();\n        return this;\n    },\n\n    showTools: function() {\n\n        var toolsView = this._toolsView;\n        if (toolsView) toolsView.show();\n        return this;\n    },\n\n    onToolEvent: function(event) {\n        switch (event) {\n            case 'remove':\n                this.removeTools();\n                break;\n            case 'hide':\n                this.hideTools();\n                break;\n            case 'show':\n                this.showTools();\n                break;\n        }\n    },\n\n    removeHighlighters: function() {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.remove(this);\n    },\n\n    updateHighlighters: function(dirty = false) {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.update(this, null, dirty);\n    },\n\n    transformHighlighters: function() {\n        _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_8__.HighlighterView.transform(this);\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    preventDefaultInteraction(evt) {\n        this.eventData(evt, { defaultInteractionPrevented: true  });\n    },\n\n    isDefaultInteractionPrevented(evt) {\n        const { defaultInteractionPrevented = false } = this.eventData(evt);\n        return defaultInteractionPrevented;\n    },\n\n    // Interaction is handled by the paper and delegated to the view in interest.\n    // `x` & `y` parameters passed to these functions represent the coordinates already snapped to the paper grid.\n    // If necessary, real coordinates can be obtained from the `evt` event object.\n\n    // These functions are supposed to be overridden by the views that inherit from `joint.dia.Cell`,\n    // i.e. `joint.dia.Element` and `joint.dia.Link`.\n\n    pointerdblclick: function(evt, x, y) {\n\n        this.notify('cell:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        this.notify('cell:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        this.notify('cell:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        const { model } = this;\n        const { graph } = model;\n        if (graph) {\n            model.startBatch('pointer');\n            this.eventData(evt, { graph });\n        }\n\n        this.notify('cell:pointerdown', evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        this.notify('cell:pointermove', evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const { graph } = this.eventData(evt);\n\n        this.notify('cell:pointerup', evt, x, y);\n\n        if (graph) {\n            // we don't want to trigger event on model as model doesn't\n            // need to be member of collection anymore (remove)\n            graph.stopBatch('pointer', { cell: this.model });\n        }\n    },\n\n    mouseover: function(evt) {\n\n        this.notify('cell:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        this.notify('cell:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        this.notify('cell:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        this.notify('cell:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        this.notify('cell:mousewheel', evt, x, y, delta);\n    },\n\n    onevent: function(evt, eventName, x, y) {\n\n        this.notify(eventName, evt, x, y);\n    },\n\n    onmagnet: function() {\n\n        // noop\n    },\n\n    magnetpointerdblclick: function() {\n\n        // noop\n    },\n\n    magnetcontextmenu: function() {\n\n        // noop\n    },\n\n    checkMouseleave(evt) {\n        const { paper, model } = this;\n        if (paper.isAsync()) {\n            // Make sure the source/target views are updated before this view.\n            // It's not 100% bulletproof (see below) but it's a good enough solution for now.\n            // The connected cells could be links as well. In that case, we would\n            // need to recursively go through all the connected links and update\n            // their source/target views as well.\n            if (model.isLink()) {\n                // The `this.sourceView` and `this.targetView` might not be updated yet.\n                // We need to find the view by the model.\n                const sourceElement = model.getSourceElement();\n                if (sourceElement) {\n                    const sourceView = paper.findViewByModel(sourceElement);\n                    if (sourceView) {\n                        paper.dumpView(sourceView);\n                        paper.checkViewVisibility(sourceView);\n                    }\n                }\n                const targetElement = model.getTargetElement();\n                if (targetElement) {\n                    const targetView = paper.findViewByModel(targetElement);\n                    if (targetView) {\n                        paper.dumpView(targetView);\n                        paper.checkViewVisibility(targetView);\n                    }\n                }\n            }\n            // Do the updates of the current view synchronously now\n            paper.dumpView(this);\n            paper.checkViewVisibility(this);\n        }\n        const target = this.getEventTarget(evt, { fromPoint: true });\n        const view = paper.findView(target);\n        if (view === this) return;\n        // Leaving the current view\n        this.mouseleave(evt);\n        if (!view) return;\n        // Entering another view\n        view.mouseenter(evt);\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n    },\n\n    isIntersecting: function(geometryShape, geometryData) {\n        return _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__.intersection.exists(geometryShape, this.getNodeBBox(this.el), geometryData);\n    },\n\n    isEnclosedIn: function(geometryRect) {\n        return geometryRect.containsRect(this.getNodeBBox(this.el));\n    },\n\n    isInArea: function(geometryRect, options = {}) {\n        if (options.strict) {\n            return this.isEnclosedIn(geometryRect);\n        }\n        return this.isIntersecting(geometryRect);\n    },\n\n    isAtPoint: function(point, options) {\n        return this.getNodeBBox(this.el).containsPoint(point, options);\n    }\n\n}, {\n\n    Flags,\n\n    Highlighting: HighlightingTypes,\n\n    addPresentationAttributes: function(presentationAttributes) {\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this.prototype, 'presentationAttributes'), presentationAttributes, function(a, b) {\n            if (!a || !b) return;\n            if (typeof a === 'string') a = [a];\n            if (typeof b === 'string') b = [b];\n            if (Array.isArray(a) && Array.isArray(b)) return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq)(a.concat(b));\n        });\n    },\n\n    evalAttribute: _attributes_eval_mjs__WEBPACK_IMPORTED_MODULE_6__.evalAttribute,\n\n});\n\n\nObject.defineProperty(CellView.prototype, 'useCSSSelectors', {\n    get() {\n        const localUse = this.model.useCSSSelectors;\n        if (localUse !== undefined) return localUse;\n        return _config_index_mjs__WEBPACK_IMPORTED_MODULE_10__.config.useCSSSelectors;\n    }\n});\n\n// TODO: Move to Vectorizer library.\nfunction getCommonAncestorNode(node1, node2) {\n    let parent = node1;\n    do {\n        if (parent.contains(node2)) return parent;\n        parent = parent.parentNode;\n    } while (parent);\n    return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0NlbGxWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNkM7QUFDTDtBQWdCYjtBQUNnQztBQUM1QjtBQUNNO0FBQ21CO0FBQ2M7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ08saUJBQWlCLGdEQUFJOztBQUU1Qjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1REFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQU07QUFDN0I7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFEQUFJOztBQUV2QyxRQUFRLGdEQUFJO0FBQ1osS0FBSzs7QUFFTDs7QUFFQTs7QUFFQSxRQUFRLGdEQUFJOztBQUVaOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQU07QUFDckI7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0NlbGxWaWV3Lm1qcz8zODhhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgVmlldyB9IGZyb20gJy4uL212Yy9pbmRleC5tanMnO1xuaW1wb3J0IHtcbiAgICBhc3NpZ24sXG4gICAgZ3VpZCxcbiAgICBvbWl0LFxuICAgIHBhcnNlRE9NSlNPTixcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzUGxhaW5PYmplY3QsXG4gICAgaXNCb29sZWFuLFxuICAgIGlzRW1wdHksXG4gICAgaXNTdHJpbmcsXG4gICAgcmVzdWx0LFxuICAgIHNvcnRlZEluZGV4LFxuICAgIG1lcmdlLFxuICAgIHVuaXFcbn0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgUG9pbnQsIFJlY3QsIGludGVyc2VjdGlvbiB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCAkIGZyb20gJy4uL212Yy9Eb20vaW5kZXgubWpzJztcbmltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4vSGlnaGxpZ2h0ZXJWaWV3Lm1qcyc7XG5pbXBvcnQgeyBldmFsQXR0cmlidXRlcywgZXZhbEF0dHJpYnV0ZSB9IGZyb20gJy4vYXR0cmlidXRlcy9ldmFsLm1qcyc7XG5cbmNvbnN0IEhpZ2hsaWdodGluZ1R5cGVzID0ge1xuICAgIERFRkFVTFQ6ICdkZWZhdWx0JyxcbiAgICBFTUJFRERJTkc6ICdlbWJlZGRpbmcnLFxuICAgIENPTk5FQ1RJTkc6ICdjb25uZWN0aW5nJyxcbiAgICBNQUdORVRfQVZBSUxBQklMSVRZOiAnbWFnbmV0QXZhaWxhYmlsaXR5JyxcbiAgICBFTEVNRU5UX0FWQUlMQUJJTElUWTogJ2VsZW1lbnRBdmFpbGFiaWxpdHknXG59O1xuXG5jb25zdCBGbGFncyA9IHtcbiAgICBUT09MUzogJ1RPT0xTJyxcbn07XG5cbi8vIENlbGxWaWV3IGJhc2UgdmlldyBhbmQgY29udHJvbGxlci5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFRoaXMgaXMgdGhlIGJhc2UgdmlldyBhbmQgY29udHJvbGxlciBmb3IgYEVsZW1lbnRWaWV3YCBhbmQgYExpbmtWaWV3YC5cbmV4cG9ydCBjb25zdCBDZWxsVmlldyA9IFZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdnJyxcblxuICAgIHN2Z0VsZW1lbnQ6IHRydWUsXG5cbiAgICBzZWxlY3RvcjogJ3Jvb3QnLFxuXG4gICAgbWV0cmljczogbnVsbCxcblxuICAgIGNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbJ2NlbGwnXTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLm1vZGVsLmdldCgndHlwZScpO1xuXG4gICAgICAgIGlmICh0eXBlKSB7XG5cbiAgICAgICAgICAgIHR5cGUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCd0eXBlLScgKyBsaXN0LnNsaWNlKDAsIGluZGV4ICsgMSkuam9pbignLScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICBfcHJlc2VudGF0aW9uQXR0cmlidXRlczogbnVsbCxcbiAgICBfZmxhZ3M6IG51bGwsXG5cbiAgICBzZXRGbGFnczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmbGFncyA9IHt9O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB2YXIgc2hpZnQgPSAwO1xuICAgICAgICB2YXIgaSwgbiwgbGFiZWw7XG4gICAgICAgIHZhciBwcmVzZW50YXRpb25BdHRyaWJ1dGVzID0gcmVzdWx0KHRoaXMsICdwcmVzZW50YXRpb25BdHRyaWJ1dGVzJyk7XG4gICAgICAgIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBwcmVzZW50YXRpb25BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoIXByZXNlbnRhdGlvbkF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gcHJlc2VudGF0aW9uQXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIGxhYmVscyA9IFtsYWJlbHNdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IGZsYWdzW2xhYmVsXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2xhYmVsXSA9IDE8PChzaGlmdCsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdIHw9IGZsYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXRGbGFnID0gcmVzdWx0KHRoaXMsICdpbml0RmxhZycpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5pdEZsYWcpKSBpbml0RmxhZyA9IFtpbml0RmxhZ107XG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBpbml0RmxhZy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsID0gaW5pdEZsYWdbaV07XG4gICAgICAgICAgICBpZiAoIWZsYWdzW2xhYmVsXSkgZmxhZ3NbbGFiZWxdID0gMTw8KHNoaWZ0KyspO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMjYgLSAzMCBhcmUgcmVzZXJ2ZWQgZm9yIHBhcGVyIGZsYWdzXG4gICAgICAgIC8vIDMxKyBvdmVyZmxvd3MgbWF4aW1hbCBudW1iZXJcbiAgICAgICAgaWYgKHNoaWZ0ID4gMjUpIHRocm93IG5ldyBFcnJvcignZGlhLkNlbGxWaWV3OiBNYXhpbXVtIG51bWJlciBvZiBmbGFncyBleGNlZWRlZC4nKTtcblxuICAgICAgICB0aGlzLl9mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLl9wcmVzZW50YXRpb25BdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgaGFzRmxhZzogZnVuY3Rpb24oZmxhZywgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcgJiB0aGlzLmdldEZsYWcobGFiZWwpO1xuICAgIH0sXG5cbiAgICByZW1vdmVGbGFnOiBmdW5jdGlvbihmbGFnLCBsYWJlbCkge1xuICAgICAgICByZXR1cm4gZmxhZyBeIChmbGFnICYgdGhpcy5nZXRGbGFnKGxhYmVsKSk7XG4gICAgfSxcblxuICAgIGdldEZsYWc6IGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgIHZhciBmbGFncyA9IHRoaXMuX2ZsYWdzO1xuICAgICAgICBpZiAoIWZsYWdzKSByZXR1cm4gMDtcbiAgICAgICAgdmFyIGZsYWcgPSAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGFiZWwubGVuZ3RoOyBpIDwgbjsgaSsrKSBmbGFnIHw9IGZsYWdzW2xhYmVsW2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsYWcgfD0gZmxhZ3NbbGFiZWxdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLm1vZGVsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ21vZGVsLWlkJzogY2VsbC5pZCxcbiAgICAgICAgICAgICdkYXRhLXR5cGUnOiBjZWxsLmF0dHJpYnV0ZXMudHlwZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24ob3B0aW9ucykge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhIGdsb2JhbCB1bmlxdWUgaWQgaXMgYXNzaWduZWQgdG8gdGhpcyB2aWV3LiBTdG9yZSB0aGlzIGlkIGFsc28gdG8gdGhlIHByb3BlcnRpZXMgb2JqZWN0LlxuICAgICAgICAvLyBUaGUgZ2xvYmFsIHVuaXF1ZSBpZCBtYWtlcyBzdXJlIHRoYXQgdGhlIHNhbWUgdmlldyBjYW4gYmUgcmVuZGVyZWQgb24gZS5nLiBkaWZmZXJlbnQgbWFjaGluZXMgYW5kXG4gICAgICAgIC8vIHN0aWxsIGJlIGFzc29jaWF0ZWQgdG8gdGhlIHNhbWUgb2JqZWN0IGFtb25nIGFsbCB0aG9zZSBjbGllbnRzLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgcmVhbC10aW1lXG4gICAgICAgIC8vIGNvbGxhYm9yYXRpb24gbWVjaGFuaXNtLlxuICAgICAgICBvcHRpb25zLmlkID0gb3B0aW9ucy5pZCB8fCBndWlkKHRoaXMpO1xuXG4gICAgICAgIFZpZXcuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5zZXRGbGFncygpO1xuXG4gICAgICAgIFZpZXcucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICB0aGlzLmNsZWFuTm9kZXNDYWNoZSgpO1xuXG4gICAgICAgIHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICB9LFxuXG4gICAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdjaGFuZ2UnLCB0aGlzLm9uQXR0cmlidXRlc0NoYW5nZSk7XG4gICAgfSxcblxuICAgIG9uQXR0cmlidXRlc0NoYW5nZTogZnVuY3Rpb24obW9kZWwsIG9wdCkge1xuICAgICAgICB2YXIgZmxhZyA9IG1vZGVsLmdldENoYW5nZUZsYWcodGhpcy5fcHJlc2VudGF0aW9uQXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChvcHQudXBkYXRlSGFuZGxlZCB8fCAhZmxhZykgcmV0dXJuO1xuICAgICAgICBpZiAob3B0LmRpcnR5ICYmIHRoaXMuaGFzRmxhZyhmbGFnLCAnVVBEQVRFJykpIGZsYWcgfD0gdGhpcy5nZXRGbGFnKCdSRU5ERVInKTtcbiAgICAgICAgLy8gVE9ETzogdG9vbCBjaGFuZ2VzIGRvZXMgbm90IG5lZWQgdG8gYmUgc3luY1xuICAgICAgICAvLyBGaXggU2VnbWVudHMgdG9vbHNcbiAgICAgICAgaWYgKG9wdC50b29sKSBvcHQuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKGZsYWcsIG9wdCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3RVcGRhdGU6IGZ1bmN0aW9uKGZsYWdzLCBvcHQpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBhcGVyICYmIGZsYWdzID4gMCkge1xuICAgICAgICAgICAgcGFwZXIucmVxdWVzdFZpZXdVcGRhdGUodGhpcywgZmxhZ3MsIHRoaXMuVVBEQVRFX1BSSU9SSVRZLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHBhcnNlRE9NSlNPTjogZnVuY3Rpb24obWFya3VwLCByb290KSB7XG5cbiAgICAgICAgdmFyIGRvYyA9IHBhcnNlRE9NSlNPTihtYXJrdXApO1xuICAgICAgICB2YXIgc2VsZWN0b3JzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgdmFyIGdyb3VwcyA9IGRvYy5ncm91cFNlbGVjdG9ycztcbiAgICAgICAgZm9yICh2YXIgZ3JvdXAgaW4gZ3JvdXBzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0b3JzW2dyb3VwXSkgdGhyb3cgbmV3IEVycm9yKCdkaWEuQ2VsbFZpZXc6IGFtYmlndW91cyBncm91cCBzZWxlY3RvcicpO1xuICAgICAgICAgICAgc2VsZWN0b3JzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIHZhciByb290U2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc1tyb290U2VsZWN0b3JdKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5DZWxsVmlldzogYW1iaWd1b3VzIHJvb3Qgc2VsZWN0b3IuJyk7XG4gICAgICAgICAgICBzZWxlY3RvcnNbcm9vdFNlbGVjdG9yXSA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZnJhZ21lbnQ6IGRvYy5mcmFnbWVudCwgc2VsZWN0b3JzOiBzZWxlY3RvcnMgfTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpZiBjZWxsIGxpbmsgaXMgYWxsb3dlZCB0byBwZXJmb3JtIGEgY2VydGFpbiBVSSBgZmVhdHVyZWAuXG4gICAgLy8gRXhhbXBsZTogYGNhbignbGFiZWxNb3ZlJylgLlxuICAgIGNhbjogZnVuY3Rpb24oZmVhdHVyZSkge1xuXG4gICAgICAgIHZhciBpbnRlcmFjdGl2ZSA9IGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLmludGVyYWN0aXZlKVxuICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMuaW50ZXJhY3RpdmUodGhpcylcbiAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmludGVyYWN0aXZlO1xuXG4gICAgICAgIHJldHVybiAoaXNPYmplY3QoaW50ZXJhY3RpdmUpICYmIGludGVyYWN0aXZlW2ZlYXR1cmVdICE9PSBmYWxzZSkgfHxcbiAgICAgICAgICAgIChpc0Jvb2xlYW4oaW50ZXJhY3RpdmUpICYmIGludGVyYWN0aXZlICE9PSBmYWxzZSk7XG4gICAgfSxcblxuICAgIGZpbmRCeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3Rvciwgcm9vdCwgc2VsZWN0b3JzKSB7XG5cbiAgICAgICAgLy8gVGhlc2UgYXJlIGVpdGhlciBkZXNjZW5kYW50cyBvZiBgdGhpcy4kZWxgIG9mIGB0aGlzLiRlbGAgaXRzZWxmLlxuICAgICAgICAvLyBgLmAgaXMgYSBzcGVjaWFsIHNlbGVjdG9yIHVzZWQgdG8gc2VsZWN0IHRoZSB3cmFwcGluZyBgPGc+YCBlbGVtZW50LlxuICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnLicpIHJldHVybiBbcm9vdF07XG4gICAgICAgIGlmIChzZWxlY3RvcnMpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHNlbGVjdG9yc1tzZWxlY3Rvcl07XG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHJldHVybiBub2RlcztcbiAgICAgICAgICAgICAgICByZXR1cm4gW25vZGVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1haW50YWluaW5nIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIGUuZy4gYGNpcmNsZTpmaXJzdGAgd291bGQgZmFpbCB3aXRoIHF1ZXJ5U2VsZWN0b3IoKSBjYWxsXG4gICAgICAgIGlmICh0aGlzLnVzZUNTU1NlbGVjdG9ycykgcmV0dXJuICQocm9vdCkuZmluZChzZWxlY3RvcikudG9BcnJheSgpO1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgZmluZE5vZGVzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlTZWxlY3RvcihzZWxlY3RvciwgdGhpcy5lbCwgdGhpcy5zZWxlY3RvcnMpO1xuICAgIH0sXG5cbiAgICBmaW5kTm9kZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgW25vZGUgPSBudWxsXSA9IHRoaXMuZmluZE5vZGVzKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIG5vdGlmeTogZnVuY3Rpb24oZXZlbnROYW1lKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucGFwZXIpIHtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBldmVudCBvbiBib3RoIHRoZSBlbGVtZW50IGl0c2VsZiBhbmQgYWxzbyBvbiB0aGUgcGFwZXIuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgW2V2ZW50TmFtZV0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgICAgICAgLy8gUGFwZXIgZXZlbnQgaGFuZGxlcnMgcmVjZWl2ZSB0aGUgdmlldyBvYmplY3QgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgICAgICAgICAgdGhpcy5wYXBlci50cmlnZ2VyLmFwcGx5KHRoaXMucGFwZXIsIFtldmVudE5hbWUsIHRoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QkJveDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIGJib3g7XG4gICAgICAgIGlmIChvcHQgJiYgb3B0LnVzZU1vZGVsR2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICBiYm94ID0gbW9kZWwuZ2V0QkJveCgpLmJib3gobW9kZWwuYW5nbGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYm94ID0gdGhpcy5nZXROb2RlQkJveCh0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcGVyLmxvY2FsVG9QYXBlclJlY3QoYmJveCk7XG4gICAgfSxcblxuICAgIGdldE5vZGVCQm94OiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5nZXROb2RlQm91bmRpbmdSZWN0KG1hZ25ldCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRoaXMuZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCgpLm11bHRpcGx5KHRoaXMuZ2V0Tm9kZVJvdGF0ZU1hdHJpeChtYWduZXQpKTtcbiAgICAgICAgY29uc3QgbWFnbmV0TWF0cml4ID0gdGhpcy5nZXROb2RlTWF0cml4KG1hZ25ldCk7XG4gICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVJlY3QocmVjdCwgdHJhbnNmb3JtTWF0cml4Lm11bHRpcGx5KG1hZ25ldE1hdHJpeCkpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlUm90YXRlTWF0cml4KG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvdGF0YWJsZU5vZGUgfHwgdGhpcy5yb3RhdGFibGVOb2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBSb3RhdGUgdHJhbnNmb3JtYXRpb24gaXMgYXBwbGllZCB0byBhbGwgbm9kZXMgd2hlbiBubyByb3RhdGFibGVHcm91cFxuICAgICAgICAgICAgLy8gaXMgcHJlc2VudCBvciB0byBub2RlcyBpbnNpZGUgdGhlIHJvdGF0YWJsZUdyb3VwIG9ubHkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb290Um90YXRlTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9kZXMgb3V0c2lkZSB0aGUgcm90YXRhYmxlIGdyb3VwXG4gICAgICAgIHJldHVybiBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuICAgIH0sXG5cbiAgICBnZXROb2RlVW5yb3RhdGVkQkJveDogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldE5vZGVCb3VuZGluZ1JlY3QobWFnbmV0KTtcbiAgICAgICAgdmFyIG1hZ25ldE1hdHJpeCA9IHRoaXMuZ2V0Tm9kZU1hdHJpeChtYWduZXQpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlTWF0cml4ID0gdGhpcy5nZXRSb290VHJhbnNsYXRlTWF0cml4KCk7XG4gICAgICAgIHJldHVybiBWLnRyYW5zZm9ybVJlY3QocmVjdCwgdHJhbnNsYXRlTWF0cml4Lm11bHRpcGx5KG1hZ25ldE1hdHJpeCkpO1xuICAgIH0sXG5cbiAgICBnZXRSb290VHJhbnNsYXRlTWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtb2RlbC5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgbXQgPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgcmV0dXJuIG10O1xuICAgIH0sXG5cbiAgICBnZXRSb290Um90YXRlTWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbXIgPSBWLmNyZWF0ZVNWR01hdHJpeCgpO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgYW5nbGUgPSBtb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gbW9kZWwuZ2V0QkJveCgpO1xuICAgICAgICAgICAgdmFyIGN4ID0gYmJveC53aWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgY3kgPSBiYm94LmhlaWdodCAvIDI7XG4gICAgICAgICAgICBtciA9IG1yLnRyYW5zbGF0ZShjeCwgY3kpLnJvdGF0ZShhbmdsZSkudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXI7XG4gICAgfSxcblxuICAgIF9ub3RpZnlIaWdobGlnaHQ6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZWwsIG9wdCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgZWw6IHJvb3ROb2RlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmZpbmROb2RlKGVsKSB8fCByb290Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFtub2RlID0gcm9vdE5vZGVdID0gdGhpcy4kKGVsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgcGFydGlhbCBmbGFnIGlmIHRoZSBoaWdobGlnaHRlZCBlbGVtZW50IGlzIG5vdCB0aGUgZW50aXJlIHZpZXcuXG4gICAgICAgIG9wdC5wYXJ0aWFsID0gKG5vZGUgIT09IHJvb3ROb2RlKTtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHR5cGUgZmxhZyBpbnRvIGEgdHlwZSBzdHJpbmdcbiAgICAgICAgaWYgKG9wdC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0eXBlO1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBvcHQuZW1iZWRkaW5nOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gSGlnaGxpZ2h0aW5nVHlwZXMuRU1CRURESU5HO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIG9wdC5jb25uZWN0aW5nOlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gSGlnaGxpZ2h0aW5nVHlwZXMuQ09OTkVDVElORztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvcHQubWFnbmV0QXZhaWxhYmlsaXR5OlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gSGlnaGxpZ2h0aW5nVHlwZXMuTUFHTkVUX0FWQUlMQUJJTElUWTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBvcHQuZWxlbWVudEF2YWlsYWJpbGl0eTpcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEhpZ2hsaWdodGluZ1R5cGVzLkVMRU1FTlRfQVZBSUxBQklMSVRZO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gSGlnaGxpZ2h0aW5nVHlwZXMuREVGQVVMVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHQudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnkoZXZlbnROYW1lLCBub2RlLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihlbCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3RpZnlIaWdobGlnaHQoJ2NlbGw6aGlnaGxpZ2h0JywgZWwsIG9wdCk7XG4gICAgfSxcblxuICAgIHVuaGlnaGxpZ2h0OiBmdW5jdGlvbihlbCwgb3B0ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdGlmeUhpZ2hsaWdodCgnY2VsbDp1bmhpZ2hsaWdodCcsIGVsLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGVsZW1lbnQgdGhhdCBoYXMgdGhlIGBtYWduZXRgIGF0dHJpYnV0ZSBzZXQgdG8gYHRydWVgLiBJZiB0aGVyZSB3YXMgbm90IHN1Y2hcbiAgICAvLyBhbiBlbGVtZW50IGZvdW5kLCByZXR1cm4gdGhlIHJvb3QgZWxlbWVudCBvZiB0aGUgY2VsbCB2aWV3LlxuICAgIGZpbmRNYWduZXQ6IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZWw7XG4gICAgICAgIGxldCBtYWduZXQgPSB0aGlzLiQoZWwpWzBdO1xuICAgICAgICBpZiAoIW1hZ25ldCkge1xuICAgICAgICAgICAgbWFnbmV0ID0gcm9vdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IG1hZ25ldEF0dHJpYnV0ZSA9IG1hZ25ldC5nZXRBdHRyaWJ1dGUoJ21hZ25ldCcpO1xuICAgICAgICAgICAgY29uc3QgaXNNYWduZXRSb290ID0gKG1hZ25ldCA9PT0gcm9vdCk7XG4gICAgICAgICAgICBpZiAoKG1hZ25ldEF0dHJpYnV0ZSB8fCBpc01hZ25ldFJvb3QpICYmIG1hZ25ldEF0dHJpYnV0ZSAhPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWduZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNNYWduZXRSb290KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG92ZXJhbGwgY2VsbCBoYXMgc2V0IGBtYWduZXQgPT09IGZhbHNlYCwgdGhlbiByZXR1cm4gYHVuZGVmaW5lZGAgdG9cbiAgICAgICAgICAgICAgICAvLyBhbm5vdW5jZSB0aGVyZSBpcyBubyBtYWduZXQgZm91bmQgZm9yIHRoaXMgY2VsbC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHRvIHNldCBvbiBjZWxscyB0aGF0IGhhdmUgJ3BvcnRzJy4gSW4gdGhpcyBjYXNlLFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgdGhlIHBvcnRzIGhhdmUgc2V0IGBtYWduZXQgPT09IHRydWVgIGFuZCB0aGUgb3ZlcmFsbCBlbGVtZW50IGhhcyBgbWFnbmV0ID09PSBmYWxzZWAuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hZ25ldCA9IG1hZ25ldC5wYXJlbnROb2RlO1xuICAgICAgICB9IHdoaWxlIChtYWduZXQpO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIGZpbmRQcm94eU5vZGU6IGZ1bmN0aW9uKGVsLCB0eXBlKSB7XG4gICAgICAgIGVsIHx8IChlbCA9IHRoaXMuZWwpO1xuICAgICAgICBjb25zdCBub2RlU2VsZWN0b3IgPSBlbC5nZXRBdHRyaWJ1dGUoYCR7dHlwZX0tc2VsZWN0b3JgKTtcbiAgICAgICAgaWYgKG5vZGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY29uc3QgcHJveHlOb2RlID0gdGhpcy5maW5kTm9kZShub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKHByb3h5Tm9kZSkgcmV0dXJuIHByb3h5Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8vIENvbnN0cnVjdCBhIHVuaXF1ZSBzZWxlY3RvciBmb3IgdGhlIGBlbGAgZWxlbWVudCB3aXRoaW4gdGhpcyB2aWV3LlxuICAgIC8vIGBwcmV2U2VsZWN0b3JgIGlzIGJlaW5nIGNvbGxlY3RlZCB0aHJvdWdoIHRoZSByZWN1cnNpdmUgY2FsbC5cbiAgICAvLyBObyB2YWx1ZSBmb3IgYHByZXZTZWxlY3RvcmAgaXMgZXhwZWN0ZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICBnZXRTZWxlY3RvcjogZnVuY3Rpb24oZWwsIHByZXZTZWxlY3Rvcikge1xuXG4gICAgICAgIHZhciBzZWxlY3RvcjtcblxuICAgICAgICBpZiAoZWwgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldlNlbGVjdG9yID09PSAnc3RyaW5nJykgc2VsZWN0b3IgPSAnOnNjb3BlID4gJyArIHByZXZTZWxlY3RvcjtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbCkge1xuXG4gICAgICAgICAgICB2YXIgbnRoQ2hpbGQgPSBWKGVsKS5pbmRleCgpICsgMTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gZWwudGFnTmFtZSArICc6bnRoLWNoaWxkKCcgKyBudGhDaGlsZCArICcpJztcblxuICAgICAgICAgICAgaWYgKHByZXZTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9ICcgPiAnICsgcHJldlNlbGVjdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3IoZWwucGFyZW50Tm9kZSwgc2VsZWN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgIH0sXG5cbiAgICBhZGRMaW5rRnJvbU1hZ25ldDogZnVuY3Rpb24obWFnbmV0LCB4LCB5KSB7XG5cbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgdmFyIGdyYXBoID0gcGFwZXIubW9kZWw7XG5cbiAgICAgICAgdmFyIGxpbmsgPSBwYXBlci5nZXREZWZhdWx0TGluayh0aGlzLCBtYWduZXQpO1xuICAgICAgICBsaW5rLnNldCh7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0TGlua0VuZChtYWduZXQsIHgsIHksIGxpbmssICdzb3VyY2UnKSxcbiAgICAgICAgICAgIHRhcmdldDogeyB4OiB4LCB5OiB5IH1cbiAgICAgICAgfSkuYWRkVG8oZ3JhcGgsIHtcbiAgICAgICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgICAgIHVpOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsaW5rLmZpbmRWaWV3KHBhcGVyKTtcbiAgICB9LFxuXG4gICAgZ2V0TGlua0VuZDogZnVuY3Rpb24obWFnbmV0LCAuLi5hcmdzKSB7XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCBpZCA9IG1vZGVsLmlkO1xuICAgICAgICAvLyBGaW5kIGEgbm9kZSB3aXRoIHRoZSBgcG9ydGAgYXR0cmlidXRlIHNldCBvbiBpdC5cbiAgICAgICAgY29uc3QgcG9ydE5vZGUgPSB0aGlzLmZpbmRBdHRyaWJ1dGVOb2RlKCdwb3J0JywgbWFnbmV0KTtcbiAgICAgICAgLy8gRmluZCBhIHVuaXF1ZSBgc2VsZWN0b3JgIG9mIHRoZSBlbGVtZW50IHVuZGVyIHBvaW50ZXIgdGhhdCBpcyBhIG1hZ25ldC5cbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBtYWduZXQuZ2V0QXR0cmlidXRlKCdqb2ludC1zZWxlY3RvcicpO1xuXG4gICAgICAgIGNvbnN0IGVuZCA9IHsgaWQ6IGlkIH07XG4gICAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSBlbmQubWFnbmV0ID0gc2VsZWN0b3I7XG4gICAgICAgIGlmIChwb3J0Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcG9ydCA9IHBvcnROb2RlLmdldEF0dHJpYnV0ZSgncG9ydCcpO1xuICAgICAgICAgICAgaWYgKHBvcnROb2RlLmdldEF0dHJpYnV0ZSgncG9ydC1pZC10eXBlJykgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KHBvcnQsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVuZC5wb3J0ID0gcG9ydDtcbiAgICAgICAgICAgIGlmICghbW9kZWwuaGFzUG9ydChwb3J0KSAmJiAhc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBwb3J0IGNyZWF0ZWQgdmlhIHRoZSBgcG9ydGAgYXR0cmlidXRlIChub3QgQVBJKVxuICAgICAgICAgICAgICAgIGVuZC5zZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3IobWFnbmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RvciA9PSBudWxsICYmIHRoaXMuZWwgIT09IG1hZ25ldCkge1xuICAgICAgICAgICAgZW5kLnNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvcihtYWduZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9taXplTGlua0VuZChlbmQsIG1hZ25ldCwgLi4uYXJncyk7XG4gICAgfSxcblxuICAgIGN1c3RvbWl6ZUxpbmtFbmQ6IGZ1bmN0aW9uKGVuZCwgbWFnbmV0LCB4LCB5LCBsaW5rLCBlbmRUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvblN0cmF0ZWd5IH0gPSBwYXBlci5vcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3Rpb25TdHJhdGVneSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHN0cmF0ZWd5ID0gY29ubmVjdGlvblN0cmF0ZWd5LmNhbGwocGFwZXIsIGVuZCwgdGhpcywgbWFnbmV0LCBuZXcgUG9pbnQoeCwgeSksIGxpbmssIGVuZFR5cGUsIHBhcGVyKTtcbiAgICAgICAgICAgIGlmIChzdHJhdGVneSkgcmV0dXJuIHN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfSxcblxuICAgIGdldE1hZ25ldEZyb21MaW5rRW5kOiBmdW5jdGlvbihlbmQpIHtcblxuICAgICAgICB2YXIgcG9ydCA9IGVuZC5wb3J0O1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbmQubWFnbmV0O1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbWFnbmV0O1xuICAgICAgICBpZiAocG9ydCAhPSBudWxsICYmIG1vZGVsLmlzRWxlbWVudCgpICYmIG1vZGVsLmhhc1BvcnQocG9ydCkpIHtcbiAgICAgICAgICAgIG1hZ25ldCA9IHRoaXMuZmluZFBvcnROb2RlKHBvcnQsIHNlbGVjdG9yKSB8fCB0aGlzLmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikgc2VsZWN0b3IgPSBlbmQuc2VsZWN0b3I7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yICYmIHBvcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxpbmsgZW5kIGhhcyBvbmx5IGBpZGAgYW5kIGBwb3J0YCBwcm9wZXJ0eSByZWZlcmVuY2luZ1xuICAgICAgICAgICAgICAgIC8vIGEgcG9ydCBjcmVhdGVkIHZpYSB0aGUgYHBvcnRgIGF0dHJpYnV0ZSAobm90IEFQSSkuXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSAnW3BvcnQ9XCInICsgcG9ydCArICdcIl0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFnbmV0ID0gdGhpcy5maW5kTm9kZShzZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5maW5kUHJveHlOb2RlKG1hZ25ldCwgJ21hZ25ldCcpO1xuICAgIH0sXG5cbiAgICBkcmFnTGlua1N0YXJ0OiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuICAgICAgICB0aGlzLm1vZGVsLnN0YXJ0QmF0Y2goJ2FkZC1saW5rJyk7XG4gICAgICAgIGNvbnN0IGxpbmtWaWV3ID0gdGhpcy5hZGRMaW5rRnJvbU1hZ25ldChtYWduZXQsIHgsIHkpO1xuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBldmVudHNcbiAgICAgICAgbGlua1ZpZXcubm90aWZ5UG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcbiAgICAgICAgbGlua1ZpZXcuZXZlbnREYXRhKGV2dCwgbGlua1ZpZXcuc3RhcnRBcnJvd2hlYWRNb3ZlKCd0YXJnZXQnLCB7IHdoZW5Ob3RBbGxvd2VkOiAncmVtb3ZlJyB9KSk7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgeyBsaW5rVmlldyB9KTtcbiAgICB9LFxuXG4gICAgZHJhZ0xpbms6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHZhciBsaW5rVmlldyA9IGRhdGEubGlua1ZpZXc7XG4gICAgICAgIGlmIChsaW5rVmlldykge1xuICAgICAgICAgICAgbGlua1ZpZXcucG9pbnRlcm1vdmUoZXZ0LCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgICAgICB2YXIgbWFnbmV0VGhyZXNob2xkID0gcGFwZXIub3B0aW9ucy5tYWduZXRUaHJlc2hvbGQ7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRhcmdldCA9IHRoaXMuZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYWduZXQgPSBkYXRhLnRhcmdldE1hZ25ldDtcbiAgICAgICAgICAgIGlmIChtYWduZXRUaHJlc2hvbGQgPT09ICdvbmxlYXZlJykge1xuICAgICAgICAgICAgICAgIC8vIG1hZ25ldFRocmVzaG9sZCB3aGVuIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgbWFnbmV0XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldE1hZ25ldCA9PT0gY3VycmVudFRhcmdldCB8fCBWKHRhcmdldE1hZ25ldCkuY29udGFpbnMoY3VycmVudFRhcmdldCkpIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbWFnbmV0VGhyZXNob2xkIGRlZmluZWQgYXMgYSBudW1iZXIgb2YgbW92ZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHBhcGVyLmV2ZW50RGF0YShldnQpLm1vdXNlbW92ZWQgPD0gbWFnbmV0VGhyZXNob2xkKSByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYWdMaW5rU3RhcnQoZXZ0LCB0YXJnZXRNYWduZXQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRyYWdMaW5rRW5kOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgbGlua1ZpZXcgPSBkYXRhLmxpbmtWaWV3O1xuICAgICAgICBpZiAoIWxpbmtWaWV3KSByZXR1cm47XG4gICAgICAgIGxpbmtWaWV3LnBvaW50ZXJ1cChldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLm1vZGVsLnN0b3BCYXRjaCgnYWRkLWxpbmsnKTtcbiAgICB9LFxuXG4gICAgZ2V0QXR0cmlidXRlRGVmaW5pdGlvbjogZnVuY3Rpb24oYXR0ck5hbWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb25zdHJ1Y3Rvci5nZXRBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJOYW1lKTtcbiAgICB9LFxuXG4gICAgc2V0Tm9kZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKG5vZGUsIGF0dHJzKSB7XG5cbiAgICAgICAgaWYgKCFpc0VtcHR5KGF0dHJzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgVihub2RlKS5hdHRyKGF0dHJzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChub2RlKS5hdHRyKGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwcm9jZXNzTm9kZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKG5vZGUsIGF0dHJzKSB7XG5cbiAgICAgICAgdmFyIGF0dHJOYW1lLCBhdHRyVmFsLCBkZWYsIGksIG47XG4gICAgICAgIHZhciBub3JtYWxBdHRycywgc2V0QXR0cnMsIHBvc2l0aW9uQXR0cnMsIG9mZnNldEF0dHJzO1xuICAgICAgICB2YXIgcmVsYXRpdmVzID0gW107XG4gICAgICAgIGNvbnN0IHJhd0F0dHJzID0ge307XG4gICAgICAgIGZvciAoYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJhd0F0dHJzW1YuYXR0cmlidXRlTmFtZXNbYXR0ck5hbWVdXSA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXZpZGUgdGhlIGF0dHJpYnV0ZXMgYmV0d2VlbiBub3JtYWwgYW5kIHNwZWNpYWxcbiAgICAgICAgZm9yIChhdHRyTmFtZSBpbiByYXdBdHRycykge1xuICAgICAgICAgICAgaWYgKCFyYXdBdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyTmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYXR0clZhbCA9IHJhd0F0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGRlZiA9IHRoaXMuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSB1bnNldCBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuc2V0QXR0ck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGRlZi51bnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc2V0QXR0ck5hbWUgPSBkZWYudW5zZXQuY2FsbCh0aGlzLCBub2RlLCByYXdBdHRycywgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNldEF0dHJOYW1lID0gZGVmLnVuc2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdW5zZXRBdHRyTmFtZSAmJiBpc1N0cmluZyhkZWYuc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgdW5zZXQgYW4gYWxpYXMgYXR0cmlidXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zZXRBdHRyTmFtZSA9IGRlZi5zZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1bnNldEF0dHJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBhbGlhcyBmb3IgdGhlIGF0dHJpYnV0ZS4gV2UgdW5zZXQgdGhlIGF0dHJpYnV0ZSBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNldEF0dHJOYW1lID0gYXR0ck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5zZXQgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHVuc2V0QXR0ck5hbWUpICYmIHVuc2V0QXR0ck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuc2V0IGEgc2luZ2xlIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzIHx8IChub3JtYWxBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdW5zZXQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5zZXRBdHRyTmFtZSBpbiBub3JtYWxBdHRycykgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRyc1t1bnNldEF0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bnNldEF0dHJOYW1lKSAmJiB1bnNldEF0dHJOYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuc2V0IG11bHRpcGxlIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRycyB8fCAobm9ybWFsQXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gdW5zZXRBdHRyTmFtZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHVuc2V0QXR0ck5hbWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB1bnNldCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ck5hbWUgaW4gbm9ybWFsQXR0cnMpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzW2F0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVuc2V0IHZhbHVlIGlzIG5laXRoZXIgYSBzdHJpbmcgbm9yIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYXR0cmlidXRlIGlzIG5vdCB1bnNldC5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZGVmLnF1YWxpZnkpIHx8IGRlZi5xdWFsaWZ5LmNhbGwodGhpcywgYXR0clZhbCwgbm9kZSwgcmF3QXR0cnMsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZGVmLnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbiBhbGlhcyBlLmcgJ3hsaW5rOmhyZWYnIC0+ICdocmVmJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzIHx8IChub3JtYWxBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxBdHRyc1tkZWYuc2V0XSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZXMucHVzaChhdHRyTmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzIHx8IChub3JtYWxBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzW2F0dHJOYW1lXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1hbEF0dHJzIHx8IChub3JtYWxBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICBub3JtYWxBdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSByZXN0IG9mIGF0dHJpYnV0ZXMgdmlhIHJlbGF0ZWQgbWV0aG9kXG4gICAgICAgIC8vIGZyb20gdGhlIHNwZWNpYWwgYXR0cmlidXRlcyBuYW1lc3BhY2UuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSByZWxhdGl2ZXMubGVuZ3RoOyBpIDwgbjsgaSs9Mikge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSByZWxhdGl2ZXNbaV07XG4gICAgICAgICAgICBkZWYgPSByZWxhdGl2ZXNbaSsxXTtcbiAgICAgICAgICAgIGF0dHJWYWwgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkZWYuc2V0KSkge1xuICAgICAgICAgICAgICAgIHNldEF0dHJzIHx8IChzZXRBdHRycyA9IHt9KTtcbiAgICAgICAgICAgICAgICBzZXRBdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGVmLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQXR0cnMgfHwgKHBvc2l0aW9uQXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGVmLm9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRBdHRycyB8fCAob2Zmc2V0QXR0cnMgPSB7fSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0QXR0cnNbYXR0ck5hbWVdID0gYXR0clZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXc6IHJhd0F0dHJzLFxuICAgICAgICAgICAgbm9ybWFsOiBub3JtYWxBdHRycyxcbiAgICAgICAgICAgIHNldDogc2V0QXR0cnMsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25BdHRycyxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0QXR0cnNcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgdXBkYXRlUmVsYXRpdmVBdHRyaWJ1dGVzOiBmdW5jdGlvbihub2RlLCBhdHRycywgcmVmQkJveCwgb3B0KSB7XG5cbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgdmFyIGF0dHJOYW1lLCBhdHRyVmFsLCBkZWY7XG4gICAgICAgIHZhciBldmFsQXR0cnMgPSBldmFsQXR0cmlidXRlcyhhdHRycy5yYXcgfHwge30sIHJlZkJCb3gpO1xuICAgICAgICB2YXIgbm9kZUF0dHJzID0gYXR0cnMubm9ybWFsIHx8IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVBdHRyTmFtZSBpbiBub2RlQXR0cnMpIHtcbiAgICAgICAgICAgIG5vZGVBdHRyc1tub2RlQXR0ck5hbWVdID0gZXZhbEF0dHJzW25vZGVBdHRyTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNldEF0dHJzID0gYXR0cnMuc2V0O1xuICAgICAgICB2YXIgcG9zaXRpb25BdHRycyA9IGF0dHJzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgb2Zmc2V0QXR0cnMgPSBhdHRycy5vZmZzZXQ7XG5cbiAgICAgICAgZm9yIChhdHRyTmFtZSBpbiBzZXRBdHRycykge1xuICAgICAgICAgICAgYXR0clZhbCA9IGV2YWxBdHRyc1thdHRyTmFtZV07XG4gICAgICAgICAgICBkZWYgPSB0aGlzLmdldEF0dHJpYnV0ZURlZmluaXRpb24oYXR0ck5hbWUpO1xuICAgICAgICAgICAgLy8gU0VUIC0gc2V0IGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYXR0cmlidXRlcyB0byBiZSBzZXQgb24gdGhlIG5vZGUsXG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIGFmZmVjdCB0aGUgbm9kZSBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSByZWZlcmVuY2UgYm91bmRpbmdcbiAgICAgICAgICAgIC8vIGJveC4gZS5nLiBgd2lkdGhgLCBgaGVpZ2h0YCwgYGRgLCBgcnhgLCBgcnlgLCBgcG9pbnRzXG4gICAgICAgICAgICB2YXIgc2V0UmVzdWx0ID0gZGVmLnNldC5jYWxsKHRoaXMsIGF0dHJWYWwsIHJlZkJCb3guY2xvbmUoKSwgbm9kZSwgZXZhbEF0dHJzLCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc09iamVjdChzZXRSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduKG5vZGVBdHRycywgc2V0UmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlQXR0cnNbYXR0ck5hbWVdID0gc2V0UmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gVE9ETzogc2V0dGluZyB0aGUgYHRyYW5zZm9ybWAgYXR0cmlidXRlIG9uIEhUTUxFbGVtZW50c1xuICAgICAgICAgICAgLy8gdmlhIGBub2RlLnN0eWxlLnRyYW5zZm9ybSA9ICdtYXRyaXgoLi4uKSc7YCB3b3VsZCBpbnRyb2R1Y2VcbiAgICAgICAgICAgIC8vIGEgYnJlYWtpbmcgY2hhbmdlIChlLmcuIGJhc2ljLlRleHRCbG9jaykuXG4gICAgICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGVzKG5vZGUsIG5vZGVBdHRycyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZmluYWwgdHJhbnNsYXRpb24gb2YgdGhlIHN1YmVsZW1lbnQuXG4gICAgICAgIHZhciBub2RlVHJhbnNmb3JtID0gbm9kZUF0dHJzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIG5vZGVNYXRyaXggPSBWLnRyYW5zZm9ybVN0cmluZ1RvTWF0cml4KG5vZGVUcmFuc2Zvcm0pO1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gUG9pbnQobm9kZU1hdHJpeC5lLCBub2RlTWF0cml4LmYpO1xuICAgICAgICBpZiAobm9kZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgbm9kZUF0dHJzID0gb21pdChub2RlQXR0cnMsICd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIG5vZGVNYXRyaXguZSA9IG5vZGVNYXRyaXguZiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjdWxhdGUgbm9kZSBzY2FsZSBkZXRlcm1pbmVkIGJ5IHRoZSBzY2FsYWJsZSBncm91cFxuICAgICAgICAvLyBvbmx5IGlmIGxhdGVyIG5lZWRlZC5cbiAgICAgICAgdmFyIHN4LCBzeSwgdHJhbnNsYXRpb247XG4gICAgICAgIGlmIChwb3NpdGlvbkF0dHJzIHx8IG9mZnNldEF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZVNjYWxlID0gdGhpcy5nZXROb2RlU2NhbGUobm9kZSwgb3B0LnNjYWxhYmxlTm9kZSk7XG4gICAgICAgICAgICBzeCA9IG5vZGVTY2FsZS5zeDtcbiAgICAgICAgICAgIHN5ID0gbm9kZVNjYWxlLnN5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChhdHRyTmFtZSBpbiBwb3NpdGlvbkF0dHJzKSB7XG4gICAgICAgICAgICBhdHRyVmFsID0gZXZhbEF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgIGRlZiA9IHRoaXMuZ2V0QXR0cmlidXRlRGVmaW5pdGlvbihhdHRyTmFtZSk7XG4gICAgICAgICAgICAvLyBQT1NJVElPTiAtIHBvc2l0aW9uIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBwb2ludCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIGJvdW5kaW5nIGJveC4gVGhlIGRlZmF1bHQgcG9zaXRpb24gb2YgdGhlIG5vZGUgaXMgeDowLCB5OjAgb2ZcbiAgICAgICAgICAgIC8vIHRoZSByZWZlcmVuY2UgYm91bmRpbmcgYm94IG9yIGNvdWxkIGJlIGZ1cnRoZXIgc3BlY2lmeSBieSBzb21lXG4gICAgICAgICAgICAvLyBTVkcgYXR0cmlidXRlcyBlLmcuIGB4YCwgYHlgXG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9IGRlZi5wb3NpdGlvbi5jYWxsKHRoaXMsIGF0dHJWYWwsIHJlZkJCb3guY2xvbmUoKSwgbm9kZSwgZXZhbEF0dHJzLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgIG5vZGVQb3NpdGlvbi5vZmZzZXQoUG9pbnQodHJhbnNsYXRpb24pLnNjYWxlKHN4LCBzeSkpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uZWQgfHwgKHBvc2l0aW9uZWQgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBub2RlIGJvdW5kaW5nIGJveCBjb3VsZCBkZXBlbmQgb24gdGhlIGBzaXplYCBzZXQgZnJvbSB0aGUgcHJldmlvdXMgbG9vcC5cbiAgICAgICAgLy8gSGVyZSB3ZSBrbm93LCB0aGF0IGFsbCB0aGUgc2l6ZSBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBhbHJlYWR5IHNldC5cbiAgICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlcyhub2RlLCBub2RlQXR0cnMpO1xuXG4gICAgICAgIHZhciBvZmZzZXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob2Zmc2V0QXR0cnMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGlzIHZpc2libGVcbiAgICAgICAgICAgIHZhciBub2RlQm91bmRpbmdSZWN0ID0gdGhpcy5nZXROb2RlQm91bmRpbmdSZWN0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5vZGVCb3VuZGluZ1JlY3Qud2lkdGggPiAwICYmIG5vZGVCb3VuZGluZ1JlY3QuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlQkJveCA9IFYudHJhbnNmb3JtUmVjdChub2RlQm91bmRpbmdSZWN0LCBub2RlTWF0cml4KS5zY2FsZSgxIC8gc3gsIDEgLyBzeSk7XG4gICAgICAgICAgICAgICAgZm9yIChhdHRyTmFtZSBpbiBvZmZzZXRBdHRycykge1xuICAgICAgICAgICAgICAgICAgICBhdHRyVmFsID0gZXZhbEF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gdGhpcy5nZXRBdHRyaWJ1dGVEZWZpbml0aW9uKGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT0ZGU0VUIC0gb2Zmc2V0IGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBwb2ludCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGJvdW5kaW5nIGJveC4gVGhlIGRlZmF1bHQgb2Zmc2V0IHBvaW50IGlzIHg6MCwgeTowIChvcmlnaW4pIG9yIGNvdWxkIGJlIGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmeSB3aXRoIHNvbWUgU1ZHIGF0dHJpYnV0ZXMgZS5nLiBgdGV4dC1hbmNob3JgLCBgY3hgLCBgY3lgXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gZGVmLm9mZnNldC5jYWxsKHRoaXMsIGF0dHJWYWwsIG5vZGVCQm94LCBub2RlLCBldmFsQXR0cnMsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVQb3NpdGlvbi5vZmZzZXQoUG9pbnQodHJhbnNsYXRpb24pLnNjYWxlKHN4LCBzeSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ZWQgfHwgKG9mZnNldGVkID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEbyBub3QgdG91Y2ggbm9kZSdzIHRyYW5zZm9ybSBhdHRyaWJ1dGUgaWYgdGhlcmUgaXMgbm8gdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cbiAgICAgICAgaWYgKG5vZGVUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbmVkIHx8IG9mZnNldGVkKSB7XG4gICAgICAgICAgICAvLyBSb3VuZCB0aGUgY29vcmRpbmF0ZXMgdG8gMSBkZWNpbWFsIHBvaW50LlxuICAgICAgICAgICAgbm9kZVBvc2l0aW9uLnJvdW5kKDEpO1xuICAgICAgICAgICAgbm9kZU1hdHJpeC5lID0gbm9kZVBvc2l0aW9uLng7XG4gICAgICAgICAgICBub2RlTWF0cml4LmYgPSBub2RlUG9zaXRpb24ueTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKG5vZGVNYXRyaXgpKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHN0b3JlIG5vZGVNYXRyaXggbWV0cmljcz9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXROb2RlU2NhbGU6IGZ1bmN0aW9uKG5vZGUsIHNjYWxhYmxlTm9kZSkge1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgc2NhbGFibGUgZ3JvdXAuXG4gICAgICAgIHZhciBzeCwgc3k7XG4gICAgICAgIGlmIChzY2FsYWJsZU5vZGUgJiYgc2NhbGFibGVOb2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBzY2FsYWJsZU5vZGUuc2NhbGUoKTtcbiAgICAgICAgICAgIHN4ID0gMSAvIHNjYWxlLnN4O1xuICAgICAgICAgICAgc3kgPSAxIC8gc2NhbGUuc3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzeCA9IDE7XG4gICAgICAgICAgICBzeSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBzeDogc3gsIHN5OiBzeSB9O1xuICAgIH0sXG5cbiAgICBjbGVhbk5vZGVzQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1ldHJpY3MgPSB7fTtcbiAgICB9LFxuXG4gICAgY2xlYW5Ob2RlQ2FjaGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgY29uc3QgaWQgPSBub2RlLmlkO1xuICAgICAgICBpZiAoIWlkKSByZXR1cm47XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ldHJpY3NbaWRdO1xuICAgIH0sXG5cbiAgICBub2RlQ2FjaGU6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5tZXRyaWNzO1xuICAgICAgICAvLyBEb24ndCB1c2UgY2FjaGU/IEl0IG1vc3QgbGlrZWx5IGEgY3VzdG9tIHZpZXcgd2l0aCBvdmVycmlkZGVuIHVwZGF0ZS5cbiAgICAgICAgaWYgKCFtZXRyaWNzKSByZXR1cm4ge307XG4gICAgICAgIHZhciBpZCA9IFYuZW5zdXJlSWQobWFnbmV0KTtcbiAgICAgICAgdmFyIHZhbHVlID0gbWV0cmljc1tpZF07XG4gICAgICAgIGlmICghdmFsdWUpIHZhbHVlID0gbWV0cmljc1tpZF0gPSB7fTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXROb2RlRGF0YTogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aGlzLm5vZGVDYWNoZShtYWduZXQpO1xuICAgICAgICBpZiAoIW1ldHJpY3MuZGF0YSkgbWV0cmljcy5kYXRhID0ge307XG4gICAgICAgIHJldHVybiBtZXRyaWNzLmRhdGE7XG4gICAgfSxcblxuICAgIGdldE5vZGVCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uKG1hZ25ldCkge1xuXG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5ub2RlQ2FjaGUobWFnbmV0KTtcbiAgICAgICAgaWYgKG1ldHJpY3MuYm91bmRpbmdSZWN0ID09PSB1bmRlZmluZWQpIG1ldHJpY3MuYm91bmRpbmdSZWN0ID0gVihtYWduZXQpLmdldEJCb3goKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KG1ldHJpY3MuYm91bmRpbmdSZWN0KTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZU1hdHJpeDogZnVuY3Rpb24obWFnbmV0KSB7XG5cbiAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMubm9kZUNhY2hlKG1hZ25ldCk7XG4gICAgICAgIGlmIChtZXRyaWNzLm1hZ25ldE1hdHJpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvdGF0YWJsZU5vZGUsIGVsIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChyb3RhdGFibGVOb2RlICYmIHJvdGF0YWJsZU5vZGUuY29udGFpbnMobWFnbmV0KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHJvdGF0YWJsZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0cmljcy5tYWduZXRNYXRyaXggPSBWKG1hZ25ldCkuZ2V0VHJhbnNmb3JtVG9FbGVtZW50KHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFYuY3JlYXRlU1ZHTWF0cml4KG1ldHJpY3MubWFnbmV0TWF0cml4KTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZVNoYXBlOiBmdW5jdGlvbihtYWduZXQpIHtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubm9kZUNhY2hlKG1hZ25ldCk7XG4gICAgICAgIGlmIChtZXRyaWNzLmdlb21ldHJ5U2hhcGUgPT09IHVuZGVmaW5lZCkgbWV0cmljcy5nZW9tZXRyeVNoYXBlID0gVihtYWduZXQpLnRvR2VvbWV0cnlTaGFwZSgpO1xuICAgICAgICByZXR1cm4gbWV0cmljcy5nZW9tZXRyeVNoYXBlLmNsb25lKCk7XG4gICAgfSxcblxuICAgIGlzTm9kZUNvbm5lY3Rpb246IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaXNMaW5rKCkgJiYgKCFub2RlIHx8IG5vZGUgPT09IHRoaXMuZWwpO1xuICAgIH0sXG5cbiAgICBmaW5kTm9kZXNBdHRyaWJ1dGVzOiBmdW5jdGlvbihhdHRycywgcm9vdCwgc2VsZWN0b3JDYWNoZSwgc2VsZWN0b3JzKSB7XG5cbiAgICAgICAgdmFyIGksIG4sIG5vZGVBdHRycywgbm9kZUlkO1xuICAgICAgICB2YXIgbm9kZXNBdHRycyA9IHt9O1xuICAgICAgICB2YXIgbWVyZ2VJZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGlmICghYXR0cnMuaGFzT3duUHJvcGVydHkoc2VsZWN0b3IpKSBjb250aW51ZTtcbiAgICAgICAgICAgIG5vZGVBdHRycyA9IGF0dHJzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgIGlmICghaXNQbGFpbk9iamVjdChub2RlQXR0cnMpKSBjb250aW51ZTsgLy8gTm90IGEgdmFsaWQgc2VsZWN0b3ItYXR0cmlidXRlcyBwYWlyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RvckNhY2hlW3NlbGVjdG9yXSA9IHRoaXMuZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3IsIHJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gc2VsZWN0ZWQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3RlZFtpXTtcbiAgICAgICAgICAgICAgICBub2RlSWQgPSBWLmVuc3VyZUlkKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIFwidW5pcXVlXCIgc2VsZWN0b3JzIGFyZSBzZWxlY3RvcnMgdGhhdCByZWZlcmVuY2luZyBhIHNpbmdsZSBub2RlIChkZWZpbmVkIGJ5IGBzZWxlY3RvcmApXG4gICAgICAgICAgICAgICAgLy8gZ3JvdXBTZWxlY3RvciByZWZlcmVuY2luZyBhIHNpbmdsZSBub2RlIGlzIG5vdCBcInVuaXF1ZVwiXG4gICAgICAgICAgICAgICAgdmFyIHVuaXF1ZSA9IChzZWxlY3RvcnMgJiYgc2VsZWN0b3JzW3NlbGVjdG9yXSA9PT0gbm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZOb2RlQXR0cnMgPSBub2Rlc0F0dHJzW25vZGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKHByZXZOb2RlQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSwgdGhhdCBub2RlcyByZWZlcmVuY2VkIGJ5IGRlcHJlY2F0ZWQgYENTUyBzZWxlY3RvcnNgIGFyZSBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIGNzczpgLmNpcmNsZWAgYW5kIHNlbGVjdG9yOmBjaXJjbGVgIGNhbiBiZSBhcHBsaWVkIGluIGEgcmFuZG9tIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldk5vZGVBdHRycy5hcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VJZHMucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGVBdHRycy5hcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZUF0dHJzLmF0dHJpYnV0ZXMgPSBbcHJldk5vZGVBdHRycy5hdHRyaWJ1dGVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZOb2RlQXR0cnMuc2VsZWN0ZWRMZW5ndGggPSBbcHJldk5vZGVBdHRycy5zZWxlY3RlZExlbmd0aF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBwcmV2Tm9kZUF0dHJzLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZExlbmd0aCA9IHByZXZOb2RlQXR0cnMuc2VsZWN0ZWRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmlxdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgcmVmZXJlbmNlZCBieSBgc2VsZWN0b3JgXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnVuc2hpZnQobm9kZUF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTGVuZ3RoLnVuc2hpZnQoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSByZWZlcmVuY2VkIGJ5IGBncm91cFNlbGVjdG9yYFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRJbmRleCA9IHNvcnRlZEluZGV4KHNlbGVjdGVkTGVuZ3RoLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3BsaWNlKHNvcnRJbmRleCwgMCwgbm9kZUF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTGVuZ3RoLnNwbGljZShzb3J0SW5kZXgsIDAsIG4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNBdHRyc1tub2RlSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogbm9kZUF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRMZW5ndGg6IHVuaXF1ZSA/IC0xIDogbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gbWVyZ2VJZHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBub2RlSWQgPSBtZXJnZUlkc1tpXTtcbiAgICAgICAgICAgIG5vZGVBdHRycyA9IG5vZGVzQXR0cnNbbm9kZUlkXTtcbiAgICAgICAgICAgIG5vZGVBdHRycy5hdHRyaWJ1dGVzID0gbWVyZ2Uoe30sIC4uLm5vZGVBdHRycy5hdHRyaWJ1dGVzLnJldmVyc2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZXNBdHRycztcbiAgICB9LFxuXG4gICAgZ2V0RXZlbnRUYXJnZXQ6IGZ1bmN0aW9uKGV2dCwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIHR5cGUsIGNsaWVudFggPSAwLCBjbGllbnRZID0gMCB9ID0gZXZ0O1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGRlZmluZWQgYGZyb21Qb2ludGAgb3B0aW9uXG4gICAgICAgICAgICBvcHQuZnJvbVBvaW50IHx8XG4gICAgICAgICAgICAvLyBUb3VjaG1vdmUvVG91Y2hlbmQgZXZlbnQncyB0YXJnZXQgaXMgbm90IHJlZmxlY3RpbmcgdGhlIGVsZW1lbnQgdW5kZXIgdGhlIGNvb3JkaW5hdGVzIGFzIG1vdXNlbW92ZSBkb2VzLlxuICAgICAgICAgICAgLy8gSXQgaG9sZHMgdGhlIGVsZW1lbnQgd2hlbiBhIHRvdWNoc3RhcnQgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgdHlwZSA9PT0gJ3RvdWNobW92ZScgfHwgdHlwZSA9PT0gJ3RvdWNoZW5kJyB8fFxuICAgICAgICAgICAgLy8gUG9pbnRlcm1vdmUvUG9pbnRlcnVwIGV2ZW50IHdpdGggdGhlIHBvaW50ZXIgY2FwdHVyZWRcbiAgICAgICAgICAgICgncG9pbnRlcklkJyBpbiBldnQgJiYgdGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGV2dC5wb2ludGVySWQpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLy8gRGVmYXVsdCBpcyB0byBwcm9jZXNzIHRoZSBgbW9kZWwuYXR0cmlidXRlcy5hdHRyc2Agb2JqZWN0IGFuZCBzZXQgYXR0cmlidXRlcyBvbiBzdWJlbGVtZW50cyBiYXNlZCBvbiB0aGUgc2VsZWN0b3JzLFxuICAgIC8vIHVubGVzcyBgYXR0cnNgIHBhcmFtZXRlciB3YXMgcGFzc2VkLlxuICAgIHVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzOiBmdW5jdGlvbihyb290Tm9kZSwgYXR0cnMsIG9wdCkge1xuXG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICBvcHQucm9vdEJCb3ggfHwgKG9wdC5yb290QkJveCA9IFJlY3QoKSk7XG4gICAgICAgIG9wdC5zZWxlY3RvcnMgfHwgKG9wdC5zZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9ycyk7IC8vIHNlbGVjdG9yIGNvbGxlY3Rpb24gdG8gdXNlXG5cbiAgICAgICAgLy8gQ2FjaGUgdGFibGUgZm9yIHF1ZXJ5IHJlc3VsdHMgYW5kIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbi5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGBzZWxlY3RvckNhY2hlYCBuZWVkcyB0byBiZSBpbnZhbGlkYXRlZCBmb3IgYWxsXG4gICAgICAgIC8vIGB1cGRhdGVBdHRyaWJ1dGVzYCBjYWxscywgYXMgdGhlIHNlbGVjdG9ycyBtaWdodCBwb2ludGluZ1xuICAgICAgICAvLyB0byBub2RlcyBkZXNpZ25hdGVkIGJ5IGFuIGF0dHJpYnV0ZSBvciBlbGVtZW50cyBkeW5hbWljYWxseVxuICAgICAgICAvLyBjcmVhdGVkLlxuICAgICAgICB2YXIgc2VsZWN0b3JDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgYmJveENhY2hlID0ge307XG4gICAgICAgIHZhciByZWxhdGl2ZUl0ZW1zID0gW107XG4gICAgICAgIHZhciByZWxhdGl2ZVJlZkl0ZW1zID0gW107XG4gICAgICAgIHZhciBpdGVtLCBub2RlLCBub2RlQXR0cnMsIG5vZGVEYXRhLCBwcm9jZXNzZWRBdHRycztcblxuICAgICAgICB2YXIgcm9BdHRycyA9IG9wdC5yb0F0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBub2Rlc0F0dHJzID0gdGhpcy5maW5kTm9kZXNBdHRyaWJ1dGVzKHJvQXR0cnMgfHwgYXR0cnMsIHJvb3ROb2RlLCBzZWxlY3RvckNhY2hlLCBvcHQuc2VsZWN0b3JzKTtcbiAgICAgICAgLy8gYG5vZGVzQXR0cnNgIGFyZSBkaWZmZXJlbnQgZnJvbSBhbGwgYXR0cmlidXRlcywgd2hlblxuICAgICAgICAvLyByZW5kZXJpbmcgb25seSAgYXR0cmlidXRlcyBzZW50IHRvIHRoaXMgbWV0aG9kLlxuICAgICAgICB2YXIgbm9kZXNBbGxBdHRycyA9IChyb0F0dHJzKVxuICAgICAgICAgICAgPyB0aGlzLmZpbmROb2Rlc0F0dHJpYnV0ZXMoYXR0cnMsIHJvb3ROb2RlLCBzZWxlY3RvckNhY2hlLCBvcHQuc2VsZWN0b3JzKVxuICAgICAgICAgICAgOiBub2Rlc0F0dHJzO1xuXG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBub2Rlc0F0dHJzKSB7XG4gICAgICAgICAgICBub2RlRGF0YSA9IG5vZGVzQXR0cnNbbm9kZUlkXTtcbiAgICAgICAgICAgIG5vZGVBdHRycyA9IG5vZGVEYXRhLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBub2RlID0gbm9kZURhdGEubm9kZTtcbiAgICAgICAgICAgIHByb2Nlc3NlZEF0dHJzID0gdGhpcy5wcm9jZXNzTm9kZUF0dHJpYnV0ZXMobm9kZSwgbm9kZUF0dHJzKTtcblxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWRBdHRycy5zZXQgJiYgIXByb2Nlc3NlZEF0dHJzLnBvc2l0aW9uICYmICFwcm9jZXNzZWRBdHRycy5vZmZzZXQgJiYgIXByb2Nlc3NlZEF0dHJzLnJhdy5yZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgYWxsIHRoZSBub3JtYWwgYXR0cmlidXRlcyByaWdodCBvbiB0aGUgU1ZHL0hUTUwgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGVzKG5vZGUsIGV2YWxBdHRyaWJ1dGVzKHByb2Nlc3NlZEF0dHJzLm5vcm1hbCwgb3B0LnJvb3RCQm94KSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZUFsbEF0dHJzID0gbm9kZXNBbGxBdHRyc1tub2RlSWRdICYmIG5vZGVzQWxsQXR0cnNbbm9kZUlkXS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIHZhciByZWZTZWxlY3RvciA9IChub2RlQWxsQXR0cnMgJiYgKG5vZGVBdHRycy5yZWYgPT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZUFsbEF0dHJzLnJlZlxuICAgICAgICAgICAgICAgICAgICA6IG5vZGVBdHRycy5yZWY7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVmTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocmVmU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmTm9kZSA9IChzZWxlY3RvckNhY2hlW3JlZlNlbGVjdG9yXSB8fCB0aGlzLmZpbmRCeVNlbGVjdG9yKHJlZlNlbGVjdG9yLCByb290Tm9kZSwgb3B0LnNlbGVjdG9ycykpWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkNlbGxWaWV3OiBcIicgKyByZWZTZWxlY3RvciArICdcIiByZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICByZWZOb2RlOiByZWZOb2RlLFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRBdHRyaWJ1dGVzOiBwcm9jZXNzZWRBdHRycyxcbiAgICAgICAgICAgICAgICAgICAgYWxsQXR0cmlidXRlczogbm9kZUFsbEF0dHJzXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgaW4gdGhlIGxpc3QgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGlzIG9uZSwgdGhlblxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIGluc2VydCB0aGlzIG9uZSBiZWZvcmUgaXQgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSW5kZXggPSByZWxhdGl2ZVJlZkl0ZW1zLmZpbmRJbmRleChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5yZWZOb2RlID09PSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUmVmSXRlbXMuc3BsaWNlKGl0ZW1JbmRleCwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVJlZkl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIG5vZGUgd2l0aCBubyByZWYgYXR0cmlidXRlLiBUbyBiZSB1cGRhdGVkIGJlZm9yZSB0aGUgbm9kZXMgcmVmZXJlbmNpbmcgb3RoZXIgbm9kZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBuby1yZWYtaXRlbXMgaXMgbm90IHNwZWNpZmllZC9pbXBvcnRhbnQuXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlSXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWxhdGl2ZUl0ZW1zLnB1c2goLi4ucmVsYXRpdmVSZWZJdGVtcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSByZWxhdGl2ZUl0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaXRlbSA9IHJlbGF0aXZlSXRlbXNbaV07XG4gICAgICAgICAgICBub2RlID0gaXRlbS5ub2RlO1xuICAgICAgICAgICAgcmVmTm9kZSA9IGl0ZW0ucmVmTm9kZTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYm91bmRpbmcgYm94LiBJZiBubyByZWZlcmVuY2Ugd2FzIHByb3ZpZGVkLCB3ZVxuICAgICAgICAgICAgLy8gdXNlIHRoZSBvcHRpb25hbCBib3VuZGluZyBib3guXG4gICAgICAgICAgICBjb25zdCByZWZOb2RlSWQgPSByZWZOb2RlID8gVi5lbnN1cmVJZChyZWZOb2RlKSA6ICcnO1xuICAgICAgICAgICAgbGV0IHJlZkJCb3ggPSBiYm94Q2FjaGVbcmVmTm9kZUlkXTtcbiAgICAgICAgICAgIGlmICghcmVmQkJveCkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2luZyB0byB0aGUgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtYXRpb24gc3BhY2UuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBAZXhhbXBsZSAxXG4gICAgICAgICAgICAgICAgLy8gPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDExLCAxMylcIj5cbiAgICAgICAgICAgICAgICAvLyAgICAgPHJlY3QgQHNlbGVjdG9yPVwiYlwiIHg9XCIxXCIgeT1cIjJcIiB3aWR0aD1cIjNcIiBoZWlnaHQ9XCI0XCIvPlxuICAgICAgICAgICAgICAgIC8vICAgICA8cmVjdCBAc2VsZWN0b3I9XCJhXCIvPlxuICAgICAgICAgICAgICAgIC8vIDwvZz5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHJlZmVyZW5jZSBib3VuZGluZyBib3ggY2FuIG5vdCBiZSBhZmZlY3RlZFxuICAgICAgICAgICAgICAgIC8vIGJ5IHRoZSBgdHJhbnNmb3JtYCBhdHRyaWJ1dGUgb2YgdGhlIGA8Zz5gIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGUgZXhhY3QgdHJhbnNmb3JtYXRpb24gd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBgYWAgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGFzIHdlbGwgYXMgdG8gdGhlIGBiYCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQGV4YW1wbGUgMlxuICAgICAgICAgICAgICAgIC8vIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMSwgMTMpXCI+XG4gICAgICAgICAgICAgICAgLy8gICAgIDxyZWN0IEBzZWxlY3Rvcj1cImJcIiB4PVwiMVwiIHk9XCIyXCIgd2lkdGg9XCIzXCIgaGVpZ2h0PVwiNFwiLz5cbiAgICAgICAgICAgICAgICAvLyA8L2c+XG4gICAgICAgICAgICAgICAgLy8gPHJlY3QgQHNlbGVjdG9yPVwiYVwiLz5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHJlZmVyZW5jZSBib3VuZGluZyBib3ggaGF2ZSB0byBiZSBhZmZlY3RlZCBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBgdHJhbnNmb3JtYCBhdHRyaWJ1dGUgb2YgdGhlIGA8Zz5gIGVsZW1lbnQsIGJlY2F1c2UgdGhlIGBhYCBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IGRlc2NlbmRhbnQgb2YgdGhlIGA8Zz5gIGVsZW1lbnQgYW5kIHdpbGwgbm90IGJlIGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgLy8gYnkgdGhlIHRyYW5zZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgIHJlZkJCb3ggPSBiYm94Q2FjaGVbcmVmTm9kZUlkXSA9IChyZWZOb2RlKVxuICAgICAgICAgICAgICAgICAgICA/IFYocmVmTm9kZSkuZ2V0QkJveCh7IHRhcmdldDogZ2V0Q29tbW9uQW5jZXN0b3JOb2RlKG5vZGUsIHJlZk5vZGUpIH0pXG4gICAgICAgICAgICAgICAgICAgIDogb3B0LnJvb3RCQm94O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocm9BdHRycykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhIHNwZWNpYWwgYXR0cmlidXRlIGFmZmVjdGluZyB0aGUgcG9zaXRpb24gYW1vbmdzdCBwYXNzZWQtaW4gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gbWVyZ2UgaXQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMgYXMgdGhleSBhcmUgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgLy8gdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiByZWxhdGl2ZWx5IChpLmUgYHJlZi14YCAmJiAncmVmLWR4JylcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRBdHRycyA9IHRoaXMucHJvY2Vzc05vZGVBdHRyaWJ1dGVzKG5vZGUsIGl0ZW0uYWxsQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZVByb2Nlc3NlZEF0dHJpYnV0ZXMocHJvY2Vzc2VkQXR0cnMsIGl0ZW0ucHJvY2Vzc2VkQXR0cmlidXRlcyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkQXR0cnMgPSBpdGVtLnByb2Nlc3NlZEF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUmVsYXRpdmVBdHRyaWJ1dGVzKG5vZGUsIHByb2Nlc3NlZEF0dHJzLCByZWZCQm94LCBvcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lcmdlUHJvY2Vzc2VkQXR0cmlidXRlczogZnVuY3Rpb24ocHJvY2Vzc2VkQXR0cnMsIHJvUHJvY2Vzc2VkQXR0cnMpIHtcblxuICAgICAgICBwcm9jZXNzZWRBdHRycy5zZXQgfHwgKHByb2Nlc3NlZEF0dHJzLnNldCA9IHt9KTtcbiAgICAgICAgcHJvY2Vzc2VkQXR0cnMucG9zaXRpb24gfHwgKHByb2Nlc3NlZEF0dHJzLnBvc2l0aW9uID0ge30pO1xuICAgICAgICBwcm9jZXNzZWRBdHRycy5vZmZzZXQgfHwgKHByb2Nlc3NlZEF0dHJzLm9mZnNldCA9IHt9KTtcblxuICAgICAgICBhc3NpZ24ocHJvY2Vzc2VkQXR0cnMuc2V0LCByb1Byb2Nlc3NlZEF0dHJzLnNldCk7XG4gICAgICAgIGFzc2lnbihwcm9jZXNzZWRBdHRycy5wb3NpdGlvbiwgcm9Qcm9jZXNzZWRBdHRycy5wb3NpdGlvbik7XG4gICAgICAgIGFzc2lnbihwcm9jZXNzZWRBdHRycy5vZmZzZXQsIHJvUHJvY2Vzc2VkQXR0cnMub2Zmc2V0KTtcblxuICAgICAgICAvLyBIYW5kbGUgYWxzbyB0aGUgc3BlY2lhbCB0cmFuc2Zvcm0gcHJvcGVydHkuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBwcm9jZXNzZWRBdHRycy5ub3JtYWwgJiYgcHJvY2Vzc2VkQXR0cnMubm9ybWFsLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSAhPT0gdW5kZWZpbmVkICYmIHJvUHJvY2Vzc2VkQXR0cnMubm9ybWFsKSB7XG4gICAgICAgICAgICByb1Byb2Nlc3NlZEF0dHJzLm5vcm1hbC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc2VkQXR0cnMubm9ybWFsID0gcm9Qcm9jZXNzZWRBdHRycy5ub3JtYWw7XG4gICAgfSxcblxuICAgIC8vIExpZmVjeWNsZSBtZXRob2RzXG5cbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgdmlldyBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLFxuICAgIC8vIGFzIHJlc3VsdCBvZiBgY2VsbC5hZGRUbyhncmFwaClgIGJlaW5nIGNhbGxlZCAoaXNJbml0aWFsTW91bnQgPT09IHRydWUpXG4gICAgLy8gb3IgYHBhcGVyLm9wdGlvbnMudmlld3BvcnRgIHJldHVybmluZyBgdHJ1ZWAgKGlzSW5pdGlhbE1vdW50ID09PSBmYWxzZSkuXG4gICAgb25Nb3VudChpc0luaXRpYWxNb3VudCkge1xuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5tb3VudFRvb2xzKCk7XG4gICAgICAgIEhpZ2hsaWdodGVyVmlldy5tb3VudCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gdGhlIHZpZXcgaXMgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLFxuICAgIC8vIGFzIHJlc3VsdCBvZiBgcGFwZXIub3B0aW9ucy52aWV3cG9ydGAgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgb25EZXRhY2goKSB7XG4gICAgICAgIHRoaXMudW5tb3VudFRvb2xzKCk7XG4gICAgICAgIEhpZ2hsaWdodGVyVmlldy51bm1vdW50KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgdmlldyBpcyByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgIC8vIGFzIHJlc3VsdCBvZiBgY2VsbC5yZW1vdmUoKWAuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZVRvb2xzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlSGlnaGxpZ2h0ZXJzKCk7XG4gICAgfSxcblxuICAgIF90b29sc1ZpZXc6IG51bGwsXG5cbiAgICBoYXNUb29sczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAoIXRvb2xzVmlldykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIW5hbWUpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gKHRvb2xzVmlldy5nZXROYW1lKCkgPT09IG5hbWUpO1xuICAgIH0sXG5cbiAgICBhZGRUb29sczogZnVuY3Rpb24odG9vbHNWaWV3KSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmVUb29scygpO1xuXG4gICAgICAgIGlmICh0b29sc1ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2xzVmlldyA9IHRvb2xzVmlldztcbiAgICAgICAgICAgIHRvb2xzVmlldy5jb25maWd1cmUoeyByZWxhdGVkVmlldzogdGhpcyB9KTtcbiAgICAgICAgICAgIHRvb2xzVmlldy5saXN0ZW5Ubyh0aGlzLnBhcGVyLCAndG9vbHM6ZXZlbnQnLCB0aGlzLm9uVG9vbEV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB1bm1vdW50VG9vbHMoKSB7XG4gICAgICAgIGNvbnN0IHRvb2xzVmlldyA9IHRoaXMuX3Rvb2xzVmlldztcbiAgICAgICAgaWYgKHRvb2xzVmlldykgdG9vbHNWaWV3LnVubW91bnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG1vdW50VG9vbHMoKSB7XG4gICAgICAgIGNvbnN0IHRvb2xzVmlldyA9IHRoaXMuX3Rvb2xzVmlldztcbiAgICAgICAgLy8gUHJldmVudCB1bm5lY2Vzc2FyeSByZS1hcHBlbmRpbmcgb2YgdGhlIHRvb2xzLlxuICAgICAgICBpZiAodG9vbHNWaWV3ICYmICF0b29sc1ZpZXcuaXNNb3VudGVkKCkpIHRvb2xzVmlldy5tb3VudCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdXBkYXRlVG9vbHM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIGlmICh0b29sc1ZpZXcpIHRvb2xzVmlldy51cGRhdGUob3B0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVRvb2xzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdG9vbHNWaWV3ID0gdGhpcy5fdG9vbHNWaWV3O1xuICAgICAgICBpZiAodG9vbHNWaWV3KSB7XG4gICAgICAgICAgICB0b29sc1ZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLl90b29sc1ZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBoaWRlVG9vbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIGlmICh0b29sc1ZpZXcpIHRvb2xzVmlldy5oaWRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaG93VG9vbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciB0b29sc1ZpZXcgPSB0aGlzLl90b29sc1ZpZXc7XG4gICAgICAgIGlmICh0b29sc1ZpZXcpIHRvb2xzVmlldy5zaG93KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblRvb2xFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRvb2xzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoaWRlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVUb29scygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2hvdyc6XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93VG9vbHMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVIaWdobGlnaHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIaWdobGlnaHRlclZpZXcucmVtb3ZlKHRoaXMpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVIaWdobGlnaHRlcnM6IGZ1bmN0aW9uKGRpcnR5ID0gZmFsc2UpIHtcbiAgICAgICAgSGlnaGxpZ2h0ZXJWaWV3LnVwZGF0ZSh0aGlzLCBudWxsLCBkaXJ0eSk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybUhpZ2hsaWdodGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhpZ2hsaWdodGVyVmlldy50cmFuc2Zvcm0odGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVyYWN0aW9uLiBUaGUgY29udHJvbGxlciBwYXJ0LlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgcHJldmVudERlZmF1bHRJbnRlcmFjdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IGRlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZDogdHJ1ZSAgfSk7XG4gICAgfSxcblxuICAgIGlzRGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkKGV2dCkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRJbnRlcmFjdGlvblByZXZlbnRlZCA9IGZhbHNlIH0gPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdEludGVyYWN0aW9uUHJldmVudGVkO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcmFjdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBwYXBlciBhbmQgZGVsZWdhdGVkIHRvIHRoZSB2aWV3IGluIGludGVyZXN0LlxuICAgIC8vIGB4YCAmIGB5YCBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGVzZSBmdW5jdGlvbnMgcmVwcmVzZW50IHRoZSBjb29yZGluYXRlcyBhbHJlYWR5IHNuYXBwZWQgdG8gdGhlIHBhcGVyIGdyaWQuXG4gICAgLy8gSWYgbmVjZXNzYXJ5LCByZWFsIGNvb3JkaW5hdGVzIGNhbiBiZSBvYnRhaW5lZCBmcm9tIHRoZSBgZXZ0YCBldmVudCBvYmplY3QuXG5cbiAgICAvLyBUaGVzZSBmdW5jdGlvbnMgYXJlIHN1cHBvc2VkIHRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHZpZXdzIHRoYXQgaW5oZXJpdCBmcm9tIGBqb2ludC5kaWEuQ2VsbGAsXG4gICAgLy8gaS5lLiBgam9pbnQuZGlhLkVsZW1lbnRgIGFuZCBgam9pbnQuZGlhLkxpbmtgLlxuXG4gICAgcG9pbnRlcmRibGNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpwb2ludGVyZGJsY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyY2xpY2s6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOnBvaW50ZXJjbGljaycsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpjb250ZXh0bWVudScsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCB7IG1vZGVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGdyYXBoIH0gPSBtb2RlbDtcbiAgICAgICAgaWYgKGdyYXBoKSB7XG4gICAgICAgICAgICBtb2RlbC5zdGFydEJhdGNoKCdwb2ludGVyJyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgZ3JhcGggfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpwb2ludGVyZG93bicsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpwb2ludGVybW92ZScsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBncmFwaCB9ID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnY2VsbDpwb2ludGVydXAnLCBldnQsIHgsIHkpO1xuXG4gICAgICAgIGlmIChncmFwaCkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGV2ZW50IG9uIG1vZGVsIGFzIG1vZGVsIGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgbWVtYmVyIG9mIGNvbGxlY3Rpb24gYW55bW9yZSAocmVtb3ZlKVxuICAgICAgICAgICAgZ3JhcGguc3RvcEJhdGNoKCdwb2ludGVyJywgeyBjZWxsOiB0aGlzLm1vZGVsIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6bW91c2VvdmVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNlb3V0JywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VlbnRlcjogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6bW91c2VlbnRlcicsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlbGVhdmU6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdjZWxsOm1vdXNlbGVhdmUnLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZXdoZWVsOiBmdW5jdGlvbihldnQsIHgsIHksIGRlbHRhKSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoJ2NlbGw6bW91c2V3aGVlbCcsIGV2dCwgeCwgeSwgZGVsdGEpO1xuICAgIH0sXG5cbiAgICBvbmV2ZW50OiBmdW5jdGlvbihldnQsIGV2ZW50TmFtZSwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KGV2ZW50TmFtZSwgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgb25tYWduZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgbWFnbmV0cG9pbnRlcmRibGNsaWNrOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIG1hZ25ldGNvbnRleHRtZW51OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBub29wXG4gICAgfSxcblxuICAgIGNoZWNrTW91c2VsZWF2ZShldnQpIHtcbiAgICAgICAgY29uc3QgeyBwYXBlciwgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwYXBlci5pc0FzeW5jKCkpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc291cmNlL3RhcmdldCB2aWV3cyBhcmUgdXBkYXRlZCBiZWZvcmUgdGhpcyB2aWV3LlxuICAgICAgICAgICAgLy8gSXQncyBub3QgMTAwJSBidWxsZXRwcm9vZiAoc2VlIGJlbG93KSBidXQgaXQncyBhIGdvb2QgZW5vdWdoIHNvbHV0aW9uIGZvciBub3cuXG4gICAgICAgICAgICAvLyBUaGUgY29ubmVjdGVkIGNlbGxzIGNvdWxkIGJlIGxpbmtzIGFzIHdlbGwuIEluIHRoYXQgY2FzZSwgd2Ugd291bGRcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gcmVjdXJzaXZlbHkgZ28gdGhyb3VnaCBhbGwgdGhlIGNvbm5lY3RlZCBsaW5rcyBhbmQgdXBkYXRlXG4gICAgICAgICAgICAvLyB0aGVpciBzb3VyY2UvdGFyZ2V0IHZpZXdzIGFzIHdlbGwuXG4gICAgICAgICAgICBpZiAobW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHRoaXMuc291cmNlVmlld2AgYW5kIGB0aGlzLnRhcmdldFZpZXdgIG1pZ2h0IG5vdCBiZSB1cGRhdGVkIHlldC5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZpbmQgdGhlIHZpZXcgYnkgdGhlIG1vZGVsLlxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBtb2RlbC5nZXRTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlVmlldyA9IHBhcGVyLmZpbmRWaWV3QnlNb2RlbChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcGVyLmR1bXBWaWV3KHNvdXJjZVZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFwZXIuY2hlY2tWaWV3VmlzaWJpbGl0eShzb3VyY2VWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gbW9kZWwuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFZpZXcgPSBwYXBlci5maW5kVmlld0J5TW9kZWwodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXBlci5kdW1wVmlldyh0YXJnZXRWaWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcGVyLmNoZWNrVmlld1Zpc2liaWxpdHkodGFyZ2V0Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyB0aGUgdXBkYXRlcyBvZiB0aGUgY3VycmVudCB2aWV3IHN5bmNocm9ub3VzbHkgbm93XG4gICAgICAgICAgICBwYXBlci5kdW1wVmlldyh0aGlzKTtcbiAgICAgICAgICAgIHBhcGVyLmNoZWNrVmlld1Zpc2liaWxpdHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRFdmVudFRhcmdldChldnQsIHsgZnJvbVBvaW50OiB0cnVlIH0pO1xuICAgICAgICBjb25zdCB2aWV3ID0gcGFwZXIuZmluZFZpZXcodGFyZ2V0KTtcbiAgICAgICAgaWYgKHZpZXcgPT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgLy8gTGVhdmluZyB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgIHRoaXMubW91c2VsZWF2ZShldnQpO1xuICAgICAgICBpZiAoIXZpZXcpIHJldHVybjtcbiAgICAgICAgLy8gRW50ZXJpbmcgYW5vdGhlciB2aWV3XG4gICAgICAgIHZpZXcubW91c2VlbnRlcihldnQpO1xuICAgIH0sXG5cbiAgICBzZXRJbnRlcmFjdGl2aXR5OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICBpc0ludGVyc2VjdGluZzogZnVuY3Rpb24oZ2VvbWV0cnlTaGFwZSwgZ2VvbWV0cnlEYXRhKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uZXhpc3RzKGdlb21ldHJ5U2hhcGUsIHRoaXMuZ2V0Tm9kZUJCb3godGhpcy5lbCksIGdlb21ldHJ5RGF0YSk7XG4gICAgfSxcblxuICAgIGlzRW5jbG9zZWRJbjogZnVuY3Rpb24oZ2VvbWV0cnlSZWN0KSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeVJlY3QuY29udGFpbnNSZWN0KHRoaXMuZ2V0Tm9kZUJCb3godGhpcy5lbCkpO1xuICAgIH0sXG5cbiAgICBpc0luQXJlYTogZnVuY3Rpb24oZ2VvbWV0cnlSZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0VuY2xvc2VkSW4oZ2VvbWV0cnlSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0ludGVyc2VjdGluZyhnZW9tZXRyeVJlY3QpO1xuICAgIH0sXG5cbiAgICBpc0F0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5vZGVCQm94KHRoaXMuZWwpLmNvbnRhaW5zUG9pbnQocG9pbnQsIG9wdGlvbnMpO1xuICAgIH1cblxufSwge1xuXG4gICAgRmxhZ3MsXG5cbiAgICBIaWdobGlnaHRpbmc6IEhpZ2hsaWdodGluZ1R5cGVzLFxuXG4gICAgYWRkUHJlc2VudGF0aW9uQXR0cmlidXRlczogZnVuY3Rpb24ocHJlc2VudGF0aW9uQXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIHJlc3VsdCh0aGlzLnByb3RvdHlwZSwgJ3ByZXNlbnRhdGlvbkF0dHJpYnV0ZXMnKSwgcHJlc2VudGF0aW9uQXR0cmlidXRlcywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSBhID0gW2FdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiID09PSAnc3RyaW5nJykgYiA9IFtiXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHJldHVybiB1bmlxKGEuY29uY2F0KGIpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGV2YWxBdHRyaWJ1dGUsXG5cbn0pO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDZWxsVmlldy5wcm90b3R5cGUsICd1c2VDU1NTZWxlY3RvcnMnLCB7XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCBsb2NhbFVzZSA9IHRoaXMubW9kZWwudXNlQ1NTU2VsZWN0b3JzO1xuICAgICAgICBpZiAobG9jYWxVc2UgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGxvY2FsVXNlO1xuICAgICAgICByZXR1cm4gY29uZmlnLnVzZUNTU1NlbGVjdG9ycztcbiAgICB9XG59KTtcblxuLy8gVE9ETzogTW92ZSB0byBWZWN0b3JpemVyIGxpYnJhcnkuXG5mdW5jdGlvbiBnZXRDb21tb25BbmNlc3Rvck5vZGUobm9kZTEsIG5vZGUyKSB7XG4gICAgbGV0IHBhcmVudCA9IG5vZGUxO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHBhcmVudC5jb250YWlucyhub2RlMikpIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKHBhcmVudCk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/Element.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Element.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Element: function() { return /* binding */ Element; }\n/* harmony export */ });\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _ports_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ports.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ports.mjs\");\n\n\n\n\n\n// Element base model.\n// -----------------------------\n\nconst Element = _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.extend({\n\n    defaults: {\n        position: { x: 0, y: 0 },\n        size: { width: 1, height: 1 },\n        angle: 0\n    },\n\n    initialize: function() {\n\n        this._initializePorts();\n        _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.prototype.initialize.apply(this, arguments);\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    _refreshPorts: function() {\n        // implemented in ports.js\n    },\n\n    isElement: function() {\n\n        return true;\n    },\n\n    position: function(x, y, opt) {\n\n        const isSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(y);\n        opt = (isSetter ? opt : x) || {};\n        const { parentRelative, deep, restrictedArea } = opt;\n\n\n        // option `parentRelative` for setting the position relative to the element's parent.\n        let parentPosition;\n        if (parentRelative) {\n\n            // Getting the parent's position requires the collection.\n            // Cell.parent() holds cell id only.\n            if (!this.graph) throw new Error('Element must be part of a graph.');\n\n            const parent = this.getParentCell();\n            if (parent && !parent.isLink()) {\n                parentPosition = parent.get('position');\n            }\n        }\n\n        if (isSetter) {\n\n            if (parentPosition) {\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n\n            if (deep || restrictedArea) {\n                const { x: x0, y: y0 } = this.get('position');\n                this.translate(x - x0, y - y0, opt);\n            } else {\n                this.set('position', { x, y }, opt);\n            }\n\n            return this;\n\n        } else { // Getter returns a geometry point.\n\n            const elementPosition = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(this.get('position'));\n            return parentRelative\n                ? elementPosition.difference(parentPosition)\n                : elementPosition;\n        }\n    },\n\n    translate: function(tx, ty, opt) {\n\n        tx = tx || 0;\n        ty = ty || 0;\n\n        if (tx === 0 && ty === 0) {\n            // Like nothing has happened.\n            return this;\n        }\n\n        opt = opt || {};\n        // Pass the initiator of the translation.\n        opt.translateBy = opt.translateBy || this.id;\n\n        var position = this.get('position') || { x: 0, y: 0 };\n        var ra = opt.restrictedArea;\n        if (ra && opt.translateBy === this.id) {\n\n            if (typeof ra === 'function') {\n\n                var newPosition = ra.call(this, position.x + tx, position.y + ty, opt);\n\n                tx = newPosition.x - position.x;\n                ty = newPosition.y - position.y;\n\n            } else  {\n                // We are restricting the translation for the element itself only. We get\n                // the bounding box of the element including all its embeds.\n                // All embeds have to be translated the exact same way as the element.\n                var bbox = this.getBBox({ deep: true });\n                //- - - - - - - - - - - - -> ra.x + ra.width\n                // - - - -> position.x      |\n                // -> bbox.x\n                //                   |\n                //         \n                //                 |\n                //   \n                //                  |\n                //   <-dx->                     | restricted area right border\n                //         <-width->        |    translated element\n                //   <- - bbox.width - ->        embedded element\n                var dx = position.x - bbox.x;\n                var dy = position.y - bbox.y;\n                // Find the maximal/minimal coordinates that the element can be translated\n                // while complies the restrictions.\n                var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n                var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n                // recalculate the translation taking the restrictions into account.\n                tx = x - position.x;\n                ty = y - position.y;\n            }\n        }\n\n        var translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty\n        };\n\n        // To find out by how much an element was translated in event 'change:position' handlers.\n        opt.tx = tx;\n        opt.ty = ty;\n\n        if (opt.transition) {\n\n            if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(opt.transition)) opt.transition = {};\n\n            this.transition('position', translatedPosition, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, opt.transition, {\n                valueFunction: _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.interpolate.object\n            }));\n\n            // Recursively call `translate()` on all the embeds cells.\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n\n        } else {\n\n            this.startBatch('translate', opt);\n            this.set('position', translatedPosition, opt);\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(this.getEmbeddedCells(), 'translate', tx, ty, opt);\n            this.stopBatch('translate', opt);\n        }\n\n        return this;\n    },\n\n    size: function(width, height, opt) {\n\n        var currentSize = this.get('size');\n        // Getter\n        // () signature\n        if (width === undefined) {\n            return {\n                width: currentSize.width,\n                height: currentSize.height\n            };\n        }\n        // Setter\n        // (size, opt) signature\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(width)) {\n            opt = height;\n            height = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(width.height) ? width.height : currentSize.height;\n            width = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(width.width) ? width.width : currentSize.width;\n        }\n\n        return this.resize(width, height, opt);\n    },\n\n    resize: function(width, height, opt) {\n\n        opt = opt || {};\n\n        this.startBatch('resize', opt);\n\n        if (opt.direction) {\n\n            var currentSize = this.get('size');\n\n            switch (opt.direction) {\n\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height;\n                    break;\n\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width;\n                    break;\n            }\n\n            // Get the angle and clamp its value between 0 and 360 degrees.\n            var angle = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle)(this.get('angle') || 0);\n\n            // This is a rectangle in size of the un-rotated element.\n            var bbox = this.getBBox();\n\n            var origin;\n\n            if (angle) {\n\n                var quadrant = {\n                    'top-right': 0,\n                    'right': 0,\n                    'top-left': 1,\n                    'top': 1,\n                    'bottom-left': 2,\n                    'left': 2,\n                    'bottom-right': 3,\n                    'bottom': 3\n                }[opt.direction];\n\n                if (opt.absolute) {\n\n                    // We are taking the element's rotation into account\n                    quadrant += Math.floor((angle + 45) / 90);\n                    quadrant %= 4;\n                }\n\n                // Pick the corner point on the element, which meant to stay on its place before and\n                // after the rotation.\n                var fixedPoint = bbox[['bottomLeft', 'corner', 'topRight', 'origin'][quadrant]]();\n\n                // Find  an image of the previous indent point. This is the position, where is the\n                // point actually located on the screen.\n                var imageFixedPoint = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(fixedPoint).rotate(bbox.center(), -angle);\n\n                // Every point on the element rotates around a circle with the centre of rotation\n                // in the middle of the element while the whole element is being rotated. That means\n                // that the distance from a point in the corner of the element (supposed its always rect) to\n                // the center of the element doesn't change during the rotation and therefore it equals\n                // to a distance on un-rotated element.\n                // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n                var radius = Math.sqrt((width * width) + (height * height)) / 2;\n\n                // Now we are looking for an angle between x-axis and the line starting at image of fixed point\n                // and ending at the center of the element. We call this angle `alpha`.\n\n                // The image of a fixed point is located in n-th quadrant. For each quadrant passed\n                // going anti-clockwise we have to add 90 degrees. Note that the first quadrant has index 0.\n                //\n                // 3 | 2\n                // --c-- Quadrant positions around the element's center `c`\n                // 0 | 1\n                //\n                var alpha = quadrant * Math.PI / 2;\n\n                // Add an angle between the beginning of the current quadrant (line parallel with x-axis or y-axis\n                // going through the center of the element) and line crossing the indent of the fixed point and the center\n                // of the element. This is the angle we need but on the un-rotated element.\n                alpha += Math.atan(quadrant % 2 == 0 ? height / width : width / height);\n\n                // Lastly we have to deduct the original angle the element was rotated by and that's it.\n                alpha -= (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.toRad)(angle);\n\n                // With this angle and distance we can easily calculate the centre of the un-rotated element.\n                // Note that fromPolar constructor accepts an angle in radians.\n                var center = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point.fromPolar(radius, alpha, imageFixedPoint);\n\n                // The top left corner on the un-rotated element has to be half a width on the left\n                // and half a height to the top from the center. This will be the origin of rectangle\n                // we were looking for.\n                origin = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(center).offset(width / -2, height / -2);\n\n            } else {\n                // calculation for the origin Point when there is no rotation of the element\n                origin = bbox.topLeft();\n\n                switch (opt.direction) {\n                    case 'top':\n                    case 'top-right':\n                        origin.offset(0, bbox.height - height);\n                        break;\n                    case 'left':\n                    case 'bottom-left':\n                        origin.offset(bbox.width -width, 0);\n                        break;\n                    case 'top-left':\n                        origin.offset(bbox.width - width, bbox.height - height);\n                        break;\n                }\n            }\n\n            // Resize the element (before re-positioning it).\n            this.set('size', { width: width, height: height }, opt);\n\n            // Finally, re-position the element.\n            this.position(origin.x, origin.y, opt);\n\n        } else {\n\n            // Resize the element.\n            this.set('size', { width: width, height: height }, opt);\n        }\n\n        this.stopBatch('resize', opt);\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        var scaledBBox = this.getBBox().scale(sx, sy, origin);\n        this.startBatch('scale', opt);\n        this.position(scaledBBox.x, scaledBBox.y, opt);\n        this.resize(scaledBBox.width, scaledBBox.height, opt);\n        this.stopBatch('scale');\n        return this;\n    },\n\n    fitEmbeds: function(opt) {\n\n        return this.fitToChildren(opt);\n    },\n\n    fitToChildren: function(opt = {}) {\n\n        // Getting the children's size and position requires the collection.\n        // Cell.get('embeds') holds an array of cell ids only.\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        const childElements = this.getEmbeddedCells().filter(cell => cell.isElement());\n        if (childElements.length === 0) return this;\n\n        this.startBatch('fit-embeds', opt);\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit to all descendants\".\n            // As the first action of the fitting algorithm, recursively apply `fitToChildren()` on all descendants.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant, then go up (= this element).\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke)(childElements, 'fitToChildren', opt);\n        }\n\n        // Set new size and position of this element, based on:\n        // - union of bboxes of all children\n        // - inflated by given `opt.padding`\n        this._fitToElements(Object.assign({ elements: childElements }, opt));\n\n        this.stopBatch('fit-embeds');\n\n        return this;\n    },\n\n    fitParent: function(opt = {}) {\n\n        const { graph } = this;\n        if (!graph) throw new Error('Element must be part of a graph.');\n\n        // When `opt.deep = true`, we want `opt.terminator` to be the last ancestor processed.\n        // If the current element is `opt.terminator`, it means that this element has already been processed as parent so we can exit now.\n        if (opt.deep && opt.terminator && ((opt.terminator === this) || (opt.terminator === this.id))) return this;\n\n        const parentElement = this.getParentCell();\n        if (!parentElement || !parentElement.isElement()) return this;\n\n        // Get all children of parent element (i.e. this element + any sibling elements).\n        const siblingElements = parentElement.getEmbeddedCells().filter(cell => cell.isElement());\n        if (siblingElements.length === 0) return this;\n\n        this.startBatch('fit-parent', opt);\n\n        // Set new size and position of parent element, based on:\n        // - union of bboxes of all children of parent element (i.e. this element + any sibling elements)\n        // - inflated by given `opt.padding`\n        parentElement._fitToElements(Object.assign({ elements: siblingElements }, opt));\n\n        if (opt.deep) {\n            // `opt.deep = true` means \"fit all ancestors to their respective children\".\n            // As the last action of the fitting algorithm, recursively apply `fitParent()` on all ancestors.\n            // - i.e. the algorithm is applied in reverse-depth order - start from deepest descendant (= this element), then go up.\n            parentElement.fitParent(opt);\n        }\n\n        this.stopBatch('fit-parent');\n\n        return this;\n    },\n\n    // Assumption: This element is part of a graph.\n    _fitToElements: function(opt = {}) {\n\n        const elementsBBox = this.graph.getCellsBBox(opt.elements);\n        // If no `opt.elements` were provided, do nothing.\n        if (!elementsBBox) return;\n\n        const { expandOnly, shrinkOnly } = opt;\n        // This combination is meaningless, do nothing.\n        if (expandOnly && shrinkOnly) return;\n\n        // Calculate new size and position of this element based on:\n        // - union of bboxes of `opt.elements`\n        // - inflated by `opt.padding` (if not provided, all four properties = 0)\n        let { x, y, width, height } = elementsBBox;\n        const { left, right, top, bottom } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeSides)(opt.padding);\n        x -= left;\n        y -= top;\n        width += left + right;\n        height += bottom + top;\n        let resultBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(x, y, width, height);\n\n        if (expandOnly) {\n            // Non-shrinking is enforced by taking union of this element's current bbox with bbox calculated from `opt.elements`.\n            resultBBox = this.getBBox().union(resultBBox);\n\n        } else if (shrinkOnly) {\n            // Non-expansion is enforced by taking intersection of this element's current bbox with bbox calculated from `opt.elements`.\n            const intersectionBBox = this.getBBox().intersect(resultBBox);\n            // If all children are outside this element's current bbox, then `intersectionBBox` is `null` - does not make sense, do nothing.\n            if (!intersectionBBox) return;\n\n            resultBBox =  intersectionBBox;\n        }\n\n        // Set the new size and position of this element.\n        this.set({\n            position: { x: resultBBox.x, y: resultBBox.y },\n            size: { width: resultBBox.width, height: resultBBox.height }\n        }, opt);\n    },\n\n    // Rotate element by `angle` degrees, optionally around `origin` point.\n    // If `origin` is not provided, it is considered to be the center of the element.\n    // If `absolute` is `true`, the `angle` is considered is absolute, i.e. it is not\n    // the difference from the previous angle.\n    rotate: function(angle, absolute, origin, opt) {\n\n        if (origin) {\n\n            var center = this.getBBox().center();\n            var size = this.get('size');\n            var position = this.get('position');\n            center.rotate(origin, this.get('angle') - angle);\n            var dx = center.x - size.width / 2 - position.x;\n            var dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle: angle, absolute: absolute, origin: origin });\n            this.position(position.x + dx, position.y + dy, opt);\n            this.rotate(angle, absolute, null, opt);\n            this.stopBatch('rotate');\n\n        } else {\n\n            this.set('angle', absolute ? angle : (this.get('angle') + angle) % 360, opt);\n        }\n\n        return this;\n    },\n\n    angle: function() {\n        return (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeAngle)(this.get('angle') || 0);\n    },\n\n    getBBox: function(opt = {}) {\n\n        const { graph, attributes } = this;\n        const { deep, rotate } = opt;\n\n        if (deep && graph) {\n            // Get all the embedded elements using breadth first algorithm.\n            const elements = this.getEmbeddedCells({ deep: true, breadthFirst: true });\n            // Add the model itself.\n            elements.push(this);\n            // Note: the default of getCellsBBox() is rotate=true and can't be\n            // changed without a breaking change\n            return graph.getCellsBBox(elements, opt);\n        }\n\n        const { angle = 0, position: { x, y }, size: { width, height }} = attributes;\n        const bbox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(x, y, width, height);\n        if (rotate) {\n            bbox.rotateAroundCenter(angle);\n        }\n        return bbox;\n    },\n\n    getPointFromConnectedLink: function(link, endType) {\n        // Center of the model\n        var bbox = this.getBBox();\n        var center = bbox.center();\n        // Center of a port\n        var endDef = link.get(endType);\n        if (!endDef) return center;\n        var portId = endDef.port;\n        if (!portId || !this.hasPort(portId)) return center;\n        var portGroup = this.portProp(portId, ['group']);\n        var portsPositions = this.getPortsPositions(portGroup);\n        var portCenter = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(portsPositions[portId]).offset(bbox.origin());\n        var angle = this.angle();\n        if (angle) portCenter.rotate(center, -angle);\n        return portCenter;\n    }\n});\n\n(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(Element.prototype, _ports_mjs__WEBPACK_IMPORTED_MODULE_6__.elementPortPrototype);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0VsZW1lbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ2tDO0FBQ2dDO0FBQ2pEOztBQUVuRDtBQUNBOztBQUVPLGdCQUFnQiwyQ0FBSTs7QUFFM0I7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLFFBQVEsMkNBQUk7QUFDWixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSx5QkFBeUIseURBQVE7QUFDakM7QUFDQSxnQkFBZ0IsdUNBQXVDOzs7QUFHdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQSxjQUFjO0FBQ2QsdUNBQXVDLE1BQU07QUFDN0M7O0FBRUE7O0FBRUEsVUFBVSxPQUFPOztBQUVqQixvQ0FBb0MsbURBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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VjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsNERBQWM7QUFDN0IsS0FBSzs7QUFFTCw4QkFBOEI7O0FBRTlCLGdCQUFnQixvQkFBb0I7QUFDcEMsZ0JBQWdCLGVBQWU7O0FBRS9CO0FBQ0E7QUFDQSxxREFBcUQsZ0NBQWdDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsdUJBQXVCLE1BQU0sVUFBVSxpQkFBaUI7QUFDeEUseUJBQXlCLDhDQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtDQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1REFBTSxvQkFBb0IsNERBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0VsZW1lbnQubWpzP2IyNDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbC5tanMnO1xuaW1wb3J0IHsgUG9pbnQsIHRvUmFkLCBub3JtYWxpemVBbmdsZSwgUmVjdCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzTnVtYmVyLCBpc09iamVjdCwgaW50ZXJwb2xhdGUsIGFzc2lnbiwgaW52b2tlLCBub3JtYWxpemVTaWRlcyB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IGVsZW1lbnRQb3J0UHJvdG90eXBlIH0gZnJvbSAnLi9wb3J0cy5tanMnO1xuXG4vLyBFbGVtZW50IGJhc2UgbW9kZWwuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgRWxlbWVudCA9IENlbGwuZXh0ZW5kKHtcblxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgc2l6ZTogeyB3aWR0aDogMSwgaGVpZ2h0OiAxIH0sXG4gICAgICAgIGFuZ2xlOiAwXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQb3J0cygpO1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpbXBsZW1lbnRlZCBpbiBwb3J0cy5qc1xuICAgIH0sXG5cbiAgICBfcmVmcmVzaFBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgaW4gcG9ydHMuanNcbiAgICB9LFxuXG4gICAgaXNFbGVtZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKHgsIHksIG9wdCkge1xuXG4gICAgICAgIGNvbnN0IGlzU2V0dGVyID0gaXNOdW1iZXIoeSk7XG4gICAgICAgIG9wdCA9IChpc1NldHRlciA/IG9wdCA6IHgpIHx8IHt9O1xuICAgICAgICBjb25zdCB7IHBhcmVudFJlbGF0aXZlLCBkZWVwLCByZXN0cmljdGVkQXJlYSB9ID0gb3B0O1xuXG5cbiAgICAgICAgLy8gb3B0aW9uIGBwYXJlbnRSZWxhdGl2ZWAgZm9yIHNldHRpbmcgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50J3MgcGFyZW50LlxuICAgICAgICBsZXQgcGFyZW50UG9zaXRpb247XG4gICAgICAgIGlmIChwYXJlbnRSZWxhdGl2ZSkge1xuXG4gICAgICAgICAgICAvLyBHZXR0aW5nIHRoZSBwYXJlbnQncyBwb3NpdGlvbiByZXF1aXJlcyB0aGUgY29sbGVjdGlvbi5cbiAgICAgICAgICAgIC8vIENlbGwucGFyZW50KCkgaG9sZHMgY2VsbCBpZCBvbmx5LlxuICAgICAgICAgICAgaWYgKCF0aGlzLmdyYXBoKSB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgbXVzdCBiZSBwYXJ0IG9mIGEgZ3JhcGguJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50UG9zaXRpb24gPSBwYXJlbnQuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzU2V0dGVyKSB7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHggKz0gcGFyZW50UG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICB5ICs9IHBhcmVudFBvc2l0aW9uLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWVwIHx8IHJlc3RyaWN0ZWRBcmVhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiB4MCwgeTogeTAgfSA9IHRoaXMuZ2V0KCdwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHggLSB4MCwgeSAtIHkwLCBvcHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCgncG9zaXRpb24nLCB7IHgsIHkgfSwgb3B0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gR2V0dGVyIHJldHVybnMgYSBnZW9tZXRyeSBwb2ludC5cblxuICAgICAgICAgICAgY29uc3QgZWxlbWVudFBvc2l0aW9uID0gUG9pbnQodGhpcy5nZXQoJ3Bvc2l0aW9uJykpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFJlbGF0aXZlXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50UG9zaXRpb24uZGlmZmVyZW5jZShwYXJlbnRQb3NpdGlvbilcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSwgb3B0KSB7XG5cbiAgICAgICAgdHggPSB0eCB8fCAwO1xuICAgICAgICB0eSA9IHR5IHx8IDA7XG5cbiAgICAgICAgaWYgKHR4ID09PSAwICYmIHR5ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBMaWtlIG5vdGhpbmcgaGFzIGhhcHBlbmVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIC8vIFBhc3MgdGhlIGluaXRpYXRvciBvZiB0aGUgdHJhbnNsYXRpb24uXG4gICAgICAgIG9wdC50cmFuc2xhdGVCeSA9IG9wdC50cmFuc2xhdGVCeSB8fCB0aGlzLmlkO1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZ2V0KCdwb3NpdGlvbicpIHx8IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB2YXIgcmEgPSBvcHQucmVzdHJpY3RlZEFyZWE7XG4gICAgICAgIGlmIChyYSAmJiBvcHQudHJhbnNsYXRlQnkgPT09IHRoaXMuaWQpIHtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByYSA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gcmEuY2FsbCh0aGlzLCBwb3NpdGlvbi54ICsgdHgsIHBvc2l0aW9uLnkgKyB0eSwgb3B0KTtcblxuICAgICAgICAgICAgICAgIHR4ID0gbmV3UG9zaXRpb24ueCAtIHBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgdHkgPSBuZXdQb3NpdGlvbi55IC0gcG9zaXRpb24ueTtcblxuICAgICAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHJlc3RyaWN0aW5nIHRoZSB0cmFuc2xhdGlvbiBmb3IgdGhlIGVsZW1lbnQgaXRzZWxmIG9ubHkuIFdlIGdldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGVsZW1lbnQgaW5jbHVkaW5nIGFsbCBpdHMgZW1iZWRzLlxuICAgICAgICAgICAgICAgIC8vIEFsbCBlbWJlZHMgaGF2ZSB0byBiZSB0cmFuc2xhdGVkIHRoZSBleGFjdCBzYW1lIHdheSBhcyB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0QkJveCh7IGRlZXA6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgLy8tIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtPiByYS54ICsgcmEud2lkdGhcbiAgICAgICAgICAgICAgICAvLyAtIC0gLSAtPiBwb3NpdGlvbi54ICAgICAgfFxuICAgICAgICAgICAgICAgIC8vIC0+IGJib3gueFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIOKWk+KWk+KWk+KWk+KWk+KWk+KWkyAgIHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIOKWkeKWkeKWkeKWkeKWkeKWkeKWkeKWk+KWk+KWk+KWk+KWk+KWk+KWk1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAg4paR4paR4paR4paR4paR4paR4paR4paR4paRICAgICAgICB8XG4gICAgICAgICAgICAgICAgLy8gICDilpPilpPilpPilpPilpPilpPilpPilpPilpHilpHilpHilpHilpHilpHilpFcbiAgICAgICAgICAgICAgICAvLyAgIOKWk+KWk+KWk+KWk+KWk+KWk+KWk+KWkyAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAvLyAgIDwtZHgtPiAgICAgICAgICAgICAgICAgICAgIHwgcmVzdHJpY3RlZCBhcmVhIHJpZ2h0IGJvcmRlclxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgPC13aWR0aC0+ICAgICAgICB8ICAg4paRIHRyYW5zbGF0ZWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vICAgPC0gLSBiYm94LndpZHRoIC0gLT4gICAgICAg4paTIGVtYmVkZGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBwb3NpdGlvbi54IC0gYmJveC54O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHBvc2l0aW9uLnkgLSBiYm94Lnk7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF4aW1hbC9taW5pbWFsIGNvb3JkaW5hdGVzIHRoYXQgdGhlIGVsZW1lbnQgY2FuIGJlIHRyYW5zbGF0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBjb21wbGllcyB0aGUgcmVzdHJpY3Rpb25zLlxuICAgICAgICAgICAgICAgIHZhciB4ID0gTWF0aC5tYXgocmEueCArIGR4LCBNYXRoLm1pbihyYS54ICsgcmEud2lkdGggKyBkeCAtIGJib3gud2lkdGgsIHBvc2l0aW9uLnggKyB0eCkpO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gTWF0aC5tYXgocmEueSArIGR5LCBNYXRoLm1pbihyYS55ICsgcmEuaGVpZ2h0ICsgZHkgLSBiYm94LmhlaWdodCwgcG9zaXRpb24ueSArIHR5KSk7XG4gICAgICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9uIHRha2luZyB0aGUgcmVzdHJpY3Rpb25zIGludG8gYWNjb3VudC5cbiAgICAgICAgICAgICAgICB0eCA9IHggLSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgIHR5ID0geSAtIHBvc2l0aW9uLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNsYXRlZFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogcG9zaXRpb24ueCArIHR4LFxuICAgICAgICAgICAgeTogcG9zaXRpb24ueSArIHR5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVG8gZmluZCBvdXQgYnkgaG93IG11Y2ggYW4gZWxlbWVudCB3YXMgdHJhbnNsYXRlZCBpbiBldmVudCAnY2hhbmdlOnBvc2l0aW9uJyBoYW5kbGVycy5cbiAgICAgICAgb3B0LnR4ID0gdHg7XG4gICAgICAgIG9wdC50eSA9IHR5O1xuXG4gICAgICAgIGlmIChvcHQudHJhbnNpdGlvbikge1xuXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9wdC50cmFuc2l0aW9uKSkgb3B0LnRyYW5zaXRpb24gPSB7fTtcblxuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKCdwb3NpdGlvbicsIHRyYW5zbGF0ZWRQb3NpdGlvbiwgYXNzaWduKHt9LCBvcHQudHJhbnNpdGlvbiwge1xuICAgICAgICAgICAgICAgIHZhbHVlRnVuY3Rpb246IGludGVycG9sYXRlLm9iamVjdFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjYWxsIGB0cmFuc2xhdGUoKWAgb24gYWxsIHRoZSBlbWJlZHMgY2VsbHMuXG4gICAgICAgICAgICBpbnZva2UodGhpcy5nZXRFbWJlZGRlZENlbGxzKCksICd0cmFuc2xhdGUnLCB0eCwgdHksIG9wdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5zdGFydEJhdGNoKCd0cmFuc2xhdGUnLCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5zZXQoJ3Bvc2l0aW9uJywgdHJhbnNsYXRlZFBvc2l0aW9uLCBvcHQpO1xuICAgICAgICAgICAgaW52b2tlKHRoaXMuZ2V0RW1iZWRkZWRDZWxscygpLCAndHJhbnNsYXRlJywgdHgsIHR5LCBvcHQpO1xuICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3RyYW5zbGF0ZScsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gdGhpcy5nZXQoJ3NpemUnKTtcbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgIC8vICgpIHNpZ25hdHVyZVxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogY3VycmVudFNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBjdXJyZW50U2l6ZS5oZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dGVyXG4gICAgICAgIC8vIChzaXplLCBvcHQpIHNpZ25hdHVyZVxuICAgICAgICBpZiAoaXNPYmplY3Qod2lkdGgpKSB7XG4gICAgICAgICAgICBvcHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSBpc051bWJlcih3aWR0aC5oZWlnaHQpID8gd2lkdGguaGVpZ2h0IDogY3VycmVudFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSBpc051bWJlcih3aWR0aC53aWR0aCkgPyB3aWR0aC53aWR0aCA6IGN1cnJlbnRTaXplLndpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIG9wdCk7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncmVzaXplJywgb3B0KTtcblxuICAgICAgICBpZiAob3B0LmRpcmVjdGlvbikge1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFNpemUgPSB0aGlzLmdldCgnc2l6ZScpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdC5kaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIGhlaWdodCB3aGVuIHJlc2l6aW5nIGhvcml6b250YWxseS5cbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gY3VycmVudFNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2hhbmdlIHdpZHRoIHdoZW4gcmVzaXppbmcgdmVydGljYWxseS5cbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBjdXJyZW50U2l6ZS53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdldCB0aGUgYW5nbGUgYW5kIGNsYW1wIGl0cyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzLlxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gbm9ybWFsaXplQW5nbGUodGhpcy5nZXQoJ2FuZ2xlJykgfHwgMCk7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZWN0YW5nbGUgaW4gc2l6ZSBvZiB0aGUgdW4tcm90YXRlZCBlbGVtZW50LlxuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLmdldEJCb3goKTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbjtcblxuICAgICAgICAgICAgaWYgKGFuZ2xlKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgcXVhZHJhbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICd0b3AtcmlnaHQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAncmlnaHQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAndG9wLWxlZnQnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndG9wJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbS1sZWZ0JzogMixcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiAyLFxuICAgICAgICAgICAgICAgICAgICAnYm90dG9tLXJpZ2h0JzogMyxcbiAgICAgICAgICAgICAgICAgICAgJ2JvdHRvbSc6IDNcbiAgICAgICAgICAgICAgICB9W29wdC5kaXJlY3Rpb25dO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdC5hYnNvbHV0ZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSB0YWtpbmcgdGhlIGVsZW1lbnQncyByb3RhdGlvbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhbnQgKz0gTWF0aC5mbG9vcigoYW5nbGUgKyA0NSkgLyA5MCk7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYW50ICU9IDQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUGljayB0aGUgY29ybmVyIHBvaW50IG9uIHRoZSBlbGVtZW50LCB3aGljaCBtZWFudCB0byBzdGF5IG9uIGl0cyBwbGFjZSBiZWZvcmUgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHJvdGF0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBmaXhlZFBvaW50ID0gYmJveFtbJ2JvdHRvbUxlZnQnLCAnY29ybmVyJywgJ3RvcFJpZ2h0JywgJ29yaWdpbiddW3F1YWRyYW50XV0oKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgIGFuIGltYWdlIG9mIHRoZSBwcmV2aW91cyBpbmRlbnQgcG9pbnQuIFRoaXMgaXMgdGhlIHBvc2l0aW9uLCB3aGVyZSBpcyB0aGVcbiAgICAgICAgICAgICAgICAvLyBwb2ludCBhY3R1YWxseSBsb2NhdGVkIG9uIHRoZSBzY3JlZW4uXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlRml4ZWRQb2ludCA9IFBvaW50KGZpeGVkUG9pbnQpLnJvdGF0ZShiYm94LmNlbnRlcigpLCAtYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gRXZlcnkgcG9pbnQgb24gdGhlIGVsZW1lbnQgcm90YXRlcyBhcm91bmQgYSBjaXJjbGUgd2l0aCB0aGUgY2VudHJlIG9mIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIG1pZGRsZSBvZiB0aGUgZWxlbWVudCB3aGlsZSB0aGUgd2hvbGUgZWxlbWVudCBpcyBiZWluZyByb3RhdGVkLiBUaGF0IG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IGluIHRoZSBjb3JuZXIgb2YgdGhlIGVsZW1lbnQgKHN1cHBvc2VkIGl0cyBhbHdheXMgcmVjdCkgdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgY2VudGVyIG9mIHRoZSBlbGVtZW50IGRvZXNuJ3QgY2hhbmdlIGR1cmluZyB0aGUgcm90YXRpb24gYW5kIHRoZXJlZm9yZSBpdCBlcXVhbHNcbiAgICAgICAgICAgICAgICAvLyB0byBhIGRpc3RhbmNlIG9uIHVuLXJvdGF0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gZmluZCB0aGUgZGlzdGFuY2UgYXMgRElTVEFOQ0UgPSAoRUxFTUVOVFdJRFRILzIpXjIgKyAoRUxFTUVOVEhFSUdIVC8yKV4yKV4wLjUuXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguc3FydCgod2lkdGggKiB3aWR0aCkgKyAoaGVpZ2h0ICogaGVpZ2h0KSkgLyAyO1xuXG4gICAgICAgICAgICAgICAgLy8gTm93IHdlIGFyZSBsb29raW5nIGZvciBhbiBhbmdsZSBiZXR3ZWVuIHgtYXhpcyBhbmQgdGhlIGxpbmUgc3RhcnRpbmcgYXQgaW1hZ2Ugb2YgZml4ZWQgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgZW5kaW5nIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQuIFdlIGNhbGwgdGhpcyBhbmdsZSBgYWxwaGFgLlxuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGltYWdlIG9mIGEgZml4ZWQgcG9pbnQgaXMgbG9jYXRlZCBpbiBuLXRoIHF1YWRyYW50LiBGb3IgZWFjaCBxdWFkcmFudCBwYXNzZWRcbiAgICAgICAgICAgICAgICAvLyBnb2luZyBhbnRpLWNsb2Nrd2lzZSB3ZSBoYXZlIHRvIGFkZCA5MCBkZWdyZWVzLiBOb3RlIHRoYXQgdGhlIGZpcnN0IHF1YWRyYW50IGhhcyBpbmRleCAwLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gMyB8IDJcbiAgICAgICAgICAgICAgICAvLyAtLWMtLSBRdWFkcmFudCBwb3NpdGlvbnMgYXJvdW5kIHRoZSBlbGVtZW50J3MgY2VudGVyIGBjYFxuICAgICAgICAgICAgICAgIC8vIDAgfCAxXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBxdWFkcmFudCAqIE1hdGguUEkgLyAyO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGFuIGFuZ2xlIGJldHdlZW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBxdWFkcmFudCAobGluZSBwYXJhbGxlbCB3aXRoIHgtYXhpcyBvciB5LWF4aXNcbiAgICAgICAgICAgICAgICAvLyBnb2luZyB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQpIGFuZCBsaW5lIGNyb3NzaW5nIHRoZSBpbmRlbnQgb2YgdGhlIGZpeGVkIHBvaW50IGFuZCB0aGUgY2VudGVyXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIGVsZW1lbnQuIFRoaXMgaXMgdGhlIGFuZ2xlIHdlIG5lZWQgYnV0IG9uIHRoZSB1bi1yb3RhdGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgYWxwaGEgKz0gTWF0aC5hdGFuKHF1YWRyYW50ICUgMiA9PSAwID8gaGVpZ2h0IC8gd2lkdGggOiB3aWR0aCAvIGhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICAvLyBMYXN0bHkgd2UgaGF2ZSB0byBkZWR1Y3QgdGhlIG9yaWdpbmFsIGFuZ2xlIHRoZSBlbGVtZW50IHdhcyByb3RhdGVkIGJ5IGFuZCB0aGF0J3MgaXQuXG4gICAgICAgICAgICAgICAgYWxwaGEgLT0gdG9SYWQoYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gV2l0aCB0aGlzIGFuZ2xlIGFuZCBkaXN0YW5jZSB3ZSBjYW4gZWFzaWx5IGNhbGN1bGF0ZSB0aGUgY2VudHJlIG9mIHRoZSB1bi1yb3RhdGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGZyb21Qb2xhciBjb25zdHJ1Y3RvciBhY2NlcHRzIGFuIGFuZ2xlIGluIHJhZGlhbnMuXG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IFBvaW50LmZyb21Qb2xhcihyYWRpdXMsIGFscGhhLCBpbWFnZUZpeGVkUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHRvcCBsZWZ0IGNvcm5lciBvbiB0aGUgdW4tcm90YXRlZCBlbGVtZW50IGhhcyB0byBiZSBoYWxmIGEgd2lkdGggb24gdGhlIGxlZnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgaGFsZiBhIGhlaWdodCB0byB0aGUgdG9wIGZyb20gdGhlIGNlbnRlci4gVGhpcyB3aWxsIGJlIHRoZSBvcmlnaW4gb2YgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgLy8gd2Ugd2VyZSBsb29raW5nIGZvci5cbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBQb2ludChjZW50ZXIpLm9mZnNldCh3aWR0aCAvIC0yLCBoZWlnaHQgLyAtMik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRpb24gZm9yIHRoZSBvcmlnaW4gUG9pbnQgd2hlbiB0aGVyZSBpcyBubyByb3RhdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIG9yaWdpbiA9IGJib3gudG9wTGVmdCgpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcHQuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4ub2Zmc2V0KDAsIGJib3guaGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm9mZnNldChiYm94LndpZHRoIC13aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm9mZnNldChiYm94LndpZHRoIC0gd2lkdGgsIGJib3guaGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzaXplIHRoZSBlbGVtZW50IChiZWZvcmUgcmUtcG9zaXRpb25pbmcgaXQpLlxuICAgICAgICAgICAgdGhpcy5zZXQoJ3NpemUnLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSwgb3B0KTtcblxuICAgICAgICAgICAgLy8gRmluYWxseSwgcmUtcG9zaXRpb24gdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKG9yaWdpbi54LCBvcmlnaW4ueSwgb3B0KTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBSZXNpemUgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICB0aGlzLnNldCgnc2l6ZScsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9LCBvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3Jlc2l6ZScsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbiwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNjYWxlZEJCb3ggPSB0aGlzLmdldEJCb3goKS5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgnc2NhbGUnLCBvcHQpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKHNjYWxlZEJCb3gueCwgc2NhbGVkQkJveC55LCBvcHQpO1xuICAgICAgICB0aGlzLnJlc2l6ZShzY2FsZWRCQm94LndpZHRoLCBzY2FsZWRCQm94LmhlaWdodCwgb3B0KTtcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3NjYWxlJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmaXRFbWJlZHM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZpdFRvQ2hpbGRyZW4ob3B0KTtcbiAgICB9LFxuXG4gICAgZml0VG9DaGlsZHJlbjogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICAvLyBHZXR0aW5nIHRoZSBjaGlsZHJlbidzIHNpemUgYW5kIHBvc2l0aW9uIHJlcXVpcmVzIHRoZSBjb2xsZWN0aW9uLlxuICAgICAgICAvLyBDZWxsLmdldCgnZW1iZWRzJykgaG9sZHMgYW4gYXJyYXkgb2YgY2VsbCBpZHMgb25seS5cbiAgICAgICAgY29uc3QgeyBncmFwaCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFncmFwaCkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG11c3QgYmUgcGFydCBvZiBhIGdyYXBoLicpO1xuXG4gICAgICAgIGNvbnN0IGNoaWxkRWxlbWVudHMgPSB0aGlzLmdldEVtYmVkZGVkQ2VsbHMoKS5maWx0ZXIoY2VsbCA9PiBjZWxsLmlzRWxlbWVudCgpKTtcbiAgICAgICAgaWYgKGNoaWxkRWxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ2ZpdC1lbWJlZHMnLCBvcHQpO1xuXG4gICAgICAgIGlmIChvcHQuZGVlcCkge1xuICAgICAgICAgICAgLy8gYG9wdC5kZWVwID0gdHJ1ZWAgbWVhbnMgXCJmaXQgdG8gYWxsIGRlc2NlbmRhbnRzXCIuXG4gICAgICAgICAgICAvLyBBcyB0aGUgZmlyc3QgYWN0aW9uIG9mIHRoZSBmaXR0aW5nIGFsZ29yaXRobSwgcmVjdXJzaXZlbHkgYXBwbHkgYGZpdFRvQ2hpbGRyZW4oKWAgb24gYWxsIGRlc2NlbmRhbnRzLlxuICAgICAgICAgICAgLy8gLSBpLmUuIHRoZSBhbGdvcml0aG0gaXMgYXBwbGllZCBpbiByZXZlcnNlLWRlcHRoIG9yZGVyIC0gc3RhcnQgZnJvbSBkZWVwZXN0IGRlc2NlbmRhbnQsIHRoZW4gZ28gdXAgKD0gdGhpcyBlbGVtZW50KS5cbiAgICAgICAgICAgIGludm9rZShjaGlsZEVsZW1lbnRzLCAnZml0VG9DaGlsZHJlbicsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgbmV3IHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCwgYmFzZWQgb246XG4gICAgICAgIC8vIC0gdW5pb24gb2YgYmJveGVzIG9mIGFsbCBjaGlsZHJlblxuICAgICAgICAvLyAtIGluZmxhdGVkIGJ5IGdpdmVuIGBvcHQucGFkZGluZ2BcbiAgICAgICAgdGhpcy5fZml0VG9FbGVtZW50cyhPYmplY3QuYXNzaWduKHsgZWxlbWVudHM6IGNoaWxkRWxlbWVudHMgfSwgb3B0KSk7XG5cbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ2ZpdC1lbWJlZHMnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZml0UGFyZW50OiBmdW5jdGlvbihvcHQgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IHsgZ3JhcGggfSA9IHRoaXM7XG4gICAgICAgIGlmICghZ3JhcGgpIHRocm93IG5ldyBFcnJvcignRWxlbWVudCBtdXN0IGJlIHBhcnQgb2YgYSBncmFwaC4nKTtcblxuICAgICAgICAvLyBXaGVuIGBvcHQuZGVlcCA9IHRydWVgLCB3ZSB3YW50IGBvcHQudGVybWluYXRvcmAgdG8gYmUgdGhlIGxhc3QgYW5jZXN0b3IgcHJvY2Vzc2VkLlxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGBvcHQudGVybWluYXRvcmAsIGl0IG1lYW5zIHRoYXQgdGhpcyBlbGVtZW50IGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkIGFzIHBhcmVudCBzbyB3ZSBjYW4gZXhpdCBub3cuXG4gICAgICAgIGlmIChvcHQuZGVlcCAmJiBvcHQudGVybWluYXRvciAmJiAoKG9wdC50ZXJtaW5hdG9yID09PSB0aGlzKSB8fCAob3B0LnRlcm1pbmF0b3IgPT09IHRoaXMuaWQpKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50Q2VsbCgpO1xuICAgICAgICBpZiAoIXBhcmVudEVsZW1lbnQgfHwgIXBhcmVudEVsZW1lbnQuaXNFbGVtZW50KCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIEdldCBhbGwgY2hpbGRyZW4gb2YgcGFyZW50IGVsZW1lbnQgKGkuZS4gdGhpcyBlbGVtZW50ICsgYW55IHNpYmxpbmcgZWxlbWVudHMpLlxuICAgICAgICBjb25zdCBzaWJsaW5nRWxlbWVudHMgPSBwYXJlbnRFbGVtZW50LmdldEVtYmVkZGVkQ2VsbHMoKS5maWx0ZXIoY2VsbCA9PiBjZWxsLmlzRWxlbWVudCgpKTtcbiAgICAgICAgaWYgKHNpYmxpbmdFbGVtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHRoaXMuc3RhcnRCYXRjaCgnZml0LXBhcmVudCcsIG9wdCk7XG5cbiAgICAgICAgLy8gU2V0IG5ldyBzaXplIGFuZCBwb3NpdGlvbiBvZiBwYXJlbnQgZWxlbWVudCwgYmFzZWQgb246XG4gICAgICAgIC8vIC0gdW5pb24gb2YgYmJveGVzIG9mIGFsbCBjaGlsZHJlbiBvZiBwYXJlbnQgZWxlbWVudCAoaS5lLiB0aGlzIGVsZW1lbnQgKyBhbnkgc2libGluZyBlbGVtZW50cylcbiAgICAgICAgLy8gLSBpbmZsYXRlZCBieSBnaXZlbiBgb3B0LnBhZGRpbmdgXG4gICAgICAgIHBhcmVudEVsZW1lbnQuX2ZpdFRvRWxlbWVudHMoT2JqZWN0LmFzc2lnbih7IGVsZW1lbnRzOiBzaWJsaW5nRWxlbWVudHMgfSwgb3B0KSk7XG5cbiAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICAvLyBgb3B0LmRlZXAgPSB0cnVlYCBtZWFucyBcImZpdCBhbGwgYW5jZXN0b3JzIHRvIHRoZWlyIHJlc3BlY3RpdmUgY2hpbGRyZW5cIi5cbiAgICAgICAgICAgIC8vIEFzIHRoZSBsYXN0IGFjdGlvbiBvZiB0aGUgZml0dGluZyBhbGdvcml0aG0sIHJlY3Vyc2l2ZWx5IGFwcGx5IGBmaXRQYXJlbnQoKWAgb24gYWxsIGFuY2VzdG9ycy5cbiAgICAgICAgICAgIC8vIC0gaS5lLiB0aGUgYWxnb3JpdGhtIGlzIGFwcGxpZWQgaW4gcmV2ZXJzZS1kZXB0aCBvcmRlciAtIHN0YXJ0IGZyb20gZGVlcGVzdCBkZXNjZW5kYW50ICg9IHRoaXMgZWxlbWVudCksIHRoZW4gZ28gdXAuXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50LmZpdFBhcmVudChvcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ2ZpdC1wYXJlbnQnKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQXNzdW1wdGlvbjogVGhpcyBlbGVtZW50IGlzIHBhcnQgb2YgYSBncmFwaC5cbiAgICBfZml0VG9FbGVtZW50czogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCBlbGVtZW50c0JCb3ggPSB0aGlzLmdyYXBoLmdldENlbGxzQkJveChvcHQuZWxlbWVudHMpO1xuICAgICAgICAvLyBJZiBubyBgb3B0LmVsZW1lbnRzYCB3ZXJlIHByb3ZpZGVkLCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoIWVsZW1lbnRzQkJveCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHsgZXhwYW5kT25seSwgc2hyaW5rT25seSB9ID0gb3B0O1xuICAgICAgICAvLyBUaGlzIGNvbWJpbmF0aW9uIGlzIG1lYW5pbmdsZXNzLCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoZXhwYW5kT25seSAmJiBzaHJpbmtPbmx5KSByZXR1cm47XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGlzIGVsZW1lbnQgYmFzZWQgb246XG4gICAgICAgIC8vIC0gdW5pb24gb2YgYmJveGVzIG9mIGBvcHQuZWxlbWVudHNgXG4gICAgICAgIC8vIC0gaW5mbGF0ZWQgYnkgYG9wdC5wYWRkaW5nYCAoaWYgbm90IHByb3ZpZGVkLCBhbGwgZm91ciBwcm9wZXJ0aWVzID0gMClcbiAgICAgICAgbGV0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gZWxlbWVudHNCQm94O1xuICAgICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gbm9ybWFsaXplU2lkZXMob3B0LnBhZGRpbmcpO1xuICAgICAgICB4IC09IGxlZnQ7XG4gICAgICAgIHkgLT0gdG9wO1xuICAgICAgICB3aWR0aCArPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgIGhlaWdodCArPSBib3R0b20gKyB0b3A7XG4gICAgICAgIGxldCByZXN1bHRCQm94ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKGV4cGFuZE9ubHkpIHtcbiAgICAgICAgICAgIC8vIE5vbi1zaHJpbmtpbmcgaXMgZW5mb3JjZWQgYnkgdGFraW5nIHVuaW9uIG9mIHRoaXMgZWxlbWVudCdzIGN1cnJlbnQgYmJveCB3aXRoIGJib3ggY2FsY3VsYXRlZCBmcm9tIGBvcHQuZWxlbWVudHNgLlxuICAgICAgICAgICAgcmVzdWx0QkJveCA9IHRoaXMuZ2V0QkJveCgpLnVuaW9uKHJlc3VsdEJCb3gpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2hyaW5rT25seSkge1xuICAgICAgICAgICAgLy8gTm9uLWV4cGFuc2lvbiBpcyBlbmZvcmNlZCBieSB0YWtpbmcgaW50ZXJzZWN0aW9uIG9mIHRoaXMgZWxlbWVudCdzIGN1cnJlbnQgYmJveCB3aXRoIGJib3ggY2FsY3VsYXRlZCBmcm9tIGBvcHQuZWxlbWVudHNgLlxuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uQkJveCA9IHRoaXMuZ2V0QkJveCgpLmludGVyc2VjdChyZXN1bHRCQm94KTtcbiAgICAgICAgICAgIC8vIElmIGFsbCBjaGlsZHJlbiBhcmUgb3V0c2lkZSB0aGlzIGVsZW1lbnQncyBjdXJyZW50IGJib3gsIHRoZW4gYGludGVyc2VjdGlvbkJCb3hgIGlzIGBudWxsYCAtIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICBpZiAoIWludGVyc2VjdGlvbkJCb3gpIHJldHVybjtcblxuICAgICAgICAgICAgcmVzdWx0QkJveCA9ICBpbnRlcnNlY3Rpb25CQm94O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBuZXcgc2l6ZSBhbmQgcG9zaXRpb24gb2YgdGhpcyBlbGVtZW50LlxuICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogeyB4OiByZXN1bHRCQm94LngsIHk6IHJlc3VsdEJCb3gueSB9LFxuICAgICAgICAgICAgc2l6ZTogeyB3aWR0aDogcmVzdWx0QkJveC53aWR0aCwgaGVpZ2h0OiByZXN1bHRCQm94LmhlaWdodCB9XG4gICAgICAgIH0sIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJvdGF0ZSBlbGVtZW50IGJ5IGBhbmdsZWAgZGVncmVlcywgb3B0aW9uYWxseSBhcm91bmQgYG9yaWdpbmAgcG9pbnQuXG4gICAgLy8gSWYgYG9yaWdpbmAgaXMgbm90IHByb3ZpZGVkLCBpdCBpcyBjb25zaWRlcmVkIHRvIGJlIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQuXG4gICAgLy8gSWYgYGFic29sdXRlYCBpcyBgdHJ1ZWAsIHRoZSBgYW5nbGVgIGlzIGNvbnNpZGVyZWQgaXMgYWJzb2x1dGUsIGkuZS4gaXQgaXMgbm90XG4gICAgLy8gdGhlIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXMgYW5nbGUuXG4gICAgcm90YXRlOiBmdW5jdGlvbihhbmdsZSwgYWJzb2x1dGUsIG9yaWdpbiwgb3B0KSB7XG5cbiAgICAgICAgaWYgKG9yaWdpbikge1xuXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5nZXRCQm94KCkuY2VudGVyKCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0KCdzaXplJyk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldCgncG9zaXRpb24nKTtcbiAgICAgICAgICAgIGNlbnRlci5yb3RhdGUob3JpZ2luLCB0aGlzLmdldCgnYW5nbGUnKSAtIGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbnRlci54IC0gc2l6ZS53aWR0aCAvIDIgLSBwb3NpdGlvbi54O1xuICAgICAgICAgICAgdmFyIGR5ID0gY2VudGVyLnkgLSBzaXplLmhlaWdodCAvIDIgLSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdyb3RhdGUnLCB7IGFuZ2xlOiBhbmdsZSwgYWJzb2x1dGU6IGFic29sdXRlLCBvcmlnaW46IG9yaWdpbiB9KTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24ocG9zaXRpb24ueCArIGR4LCBwb3NpdGlvbi55ICsgZHksIG9wdCk7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZShhbmdsZSwgYWJzb2x1dGUsIG51bGwsIG9wdCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BCYXRjaCgncm90YXRlJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5zZXQoJ2FuZ2xlJywgYWJzb2x1dGUgPyBhbmdsZSA6ICh0aGlzLmdldCgnYW5nbGUnKSArIGFuZ2xlKSAlIDM2MCwgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhbmdsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVBbmdsZSh0aGlzLmdldCgnYW5nbGUnKSB8fCAwKTtcbiAgICB9LFxuXG4gICAgZ2V0QkJveDogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB7IGdyYXBoLCBhdHRyaWJ1dGVzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZXAsIHJvdGF0ZSB9ID0gb3B0O1xuXG4gICAgICAgIGlmIChkZWVwICYmIGdyYXBoKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIHRoZSBlbWJlZGRlZCBlbGVtZW50cyB1c2luZyBicmVhZHRoIGZpcnN0IGFsZ29yaXRobS5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5nZXRFbWJlZGRlZENlbGxzKHsgZGVlcDogdHJ1ZSwgYnJlYWR0aEZpcnN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBtb2RlbCBpdHNlbGYuXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlIGRlZmF1bHQgb2YgZ2V0Q2VsbHNCQm94KCkgaXMgcm90YXRlPXRydWUgYW5kIGNhbid0IGJlXG4gICAgICAgICAgICAvLyBjaGFuZ2VkIHdpdGhvdXQgYSBicmVha2luZyBjaGFuZ2VcbiAgICAgICAgICAgIHJldHVybiBncmFwaC5nZXRDZWxsc0JCb3goZWxlbWVudHMsIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGFuZ2xlID0gMCwgcG9zaXRpb246IHsgeCwgeSB9LCBzaXplOiB7IHdpZHRoLCBoZWlnaHQgfX0gPSBhdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBiYm94ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgICAgIGJib3gucm90YXRlQXJvdW5kQ2VudGVyKGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluazogZnVuY3Rpb24obGluaywgZW5kVHlwZSkge1xuICAgICAgICAvLyBDZW50ZXIgb2YgdGhlIG1vZGVsXG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICAgIHZhciBjZW50ZXIgPSBiYm94LmNlbnRlcigpO1xuICAgICAgICAvLyBDZW50ZXIgb2YgYSBwb3J0XG4gICAgICAgIHZhciBlbmREZWYgPSBsaW5rLmdldChlbmRUeXBlKTtcbiAgICAgICAgaWYgKCFlbmREZWYpIHJldHVybiBjZW50ZXI7XG4gICAgICAgIHZhciBwb3J0SWQgPSBlbmREZWYucG9ydDtcbiAgICAgICAgaWYgKCFwb3J0SWQgfHwgIXRoaXMuaGFzUG9ydChwb3J0SWQpKSByZXR1cm4gY2VudGVyO1xuICAgICAgICB2YXIgcG9ydEdyb3VwID0gdGhpcy5wb3J0UHJvcChwb3J0SWQsIFsnZ3JvdXAnXSk7XG4gICAgICAgIHZhciBwb3J0c1Bvc2l0aW9ucyA9IHRoaXMuZ2V0UG9ydHNQb3NpdGlvbnMocG9ydEdyb3VwKTtcbiAgICAgICAgdmFyIHBvcnRDZW50ZXIgPSBuZXcgUG9pbnQocG9ydHNQb3NpdGlvbnNbcG9ydElkXSkub2Zmc2V0KGJib3gub3JpZ2luKCkpO1xuICAgICAgICB2YXIgYW5nbGUgPSB0aGlzLmFuZ2xlKCk7XG4gICAgICAgIGlmIChhbmdsZSkgcG9ydENlbnRlci5yb3RhdGUoY2VudGVyLCAtYW5nbGUpO1xuICAgICAgICByZXR1cm4gcG9ydENlbnRlcjtcbiAgICB9XG59KTtcblxuYXNzaWduKEVsZW1lbnQucHJvdG90eXBlLCBlbGVtZW50UG9ydFByb3RvdHlwZSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/Element.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/ElementView.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ElementView.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ElementView: function() { return /* binding */ ElementView; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Cell.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _ports_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ports.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ports.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n\n\n\n\n\n\n\nconst Flags = {\n    TOOLS: _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Flags.TOOLS,\n    UPDATE: 'UPDATE',\n    TRANSLATE: 'TRANSLATE',\n    RESIZE: 'RESIZE',\n    PORTS: 'PORTS',\n    ROTATE: 'ROTATE',\n    RENDER: 'RENDER'\n};\n\nconst DragActions = {\n    MOVE: 'move',\n    MAGNET: 'magnet',\n};\n// Element base view and controller.\n// -------------------------------------------\n\nconst ElementView = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.extend({\n\n    /**\n     * @abstract\n     */\n    _removePorts: function() {\n        // implemented in ports.js\n    },\n\n    /**\n     *\n     * @abstract\n     */\n    _renderPorts: function() {\n        // implemented in ports.js\n    },\n\n    className: function() {\n\n        var classNames = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('element');\n\n        return classNames.join(' ');\n    },\n\n    initialize: function() {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.initialize.apply(this, arguments);\n\n        this._initializePorts();\n    },\n\n    presentationAttributes: {\n        'attrs': [Flags.UPDATE],\n        'position': [Flags.TRANSLATE, Flags.TOOLS],\n        'size': [Flags.RESIZE, Flags.PORTS, Flags.TOOLS],\n        'angle': [Flags.ROTATE, Flags.TOOLS],\n        'markup': [Flags.RENDER],\n        'ports': [Flags.PORTS],\n    },\n\n    initFlag: [Flags.RENDER],\n\n    UPDATE_PRIORITY: 0,\n\n    confirmUpdate: function(flag, opt) {\n\n        const { useCSSSelectors } = this;\n        if (this.hasFlag(flag, Flags.PORTS)) {\n            this._removePorts();\n            this._cleanPortsCache();\n        }\n        let transformHighlighters = false;\n        if (this.hasFlag(flag, Flags.RENDER)) {\n            this.render();\n            this.updateTools(opt);\n            this.updateHighlighters(true);\n            transformHighlighters = true;\n            flag = this.removeFlag(flag, [Flags.RENDER, Flags.UPDATE, Flags.RESIZE, Flags.TRANSLATE, Flags.ROTATE, Flags.PORTS, Flags.TOOLS]);\n        } else {\n            let updateHighlighters = false;\n\n            // Skip this branch if render is required\n            if (this.hasFlag(flag, Flags.RESIZE)) {\n                this.resize(opt);\n                updateHighlighters = true;\n                // Resize method is calling `update()` internally\n                flag = this.removeFlag(flag, [Flags.RESIZE, Flags.UPDATE]);\n                if (useCSSSelectors) {\n                    // `resize()` rendered the ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.UPDATE)) {\n                this.update(this.model, null, opt);\n                flag = this.removeFlag(flag, Flags.UPDATE);\n                updateHighlighters = true;\n                if (useCSSSelectors) {\n                    // `update()` will render ports when useCSSSelectors are enabled\n                    flag = this.removeFlag(flag, Flags.PORTS);\n                }\n            }\n            if (this.hasFlag(flag, Flags.TRANSLATE)) {\n                this.translate();\n                flag = this.removeFlag(flag, Flags.TRANSLATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.ROTATE)) {\n                this.rotate();\n                flag = this.removeFlag(flag, Flags.ROTATE);\n                transformHighlighters = true;\n            }\n            if (this.hasFlag(flag, Flags.PORTS)) {\n                this._renderPorts();\n                updateHighlighters = true;\n                flag = this.removeFlag(flag, Flags.PORTS);\n            }\n\n            if (updateHighlighters) {\n                this.updateHighlighters(false);\n            }\n        }\n\n        if (transformHighlighters) {\n            this.transformHighlighters();\n        }\n\n        if (this.hasFlag(flag, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flag = this.removeFlag(flag, Flags.TOOLS);\n        }\n\n        return flag;\n    },\n\n    /**\n     * @abstract\n     */\n    _initializePorts: function() {\n        // implemented in ports.js\n    },\n\n    update: function(_, renderingOnlyAttrs) {\n\n        this.cleanNodesCache();\n\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        const { useCSSSelectors } = this;\n        if (useCSSSelectors) this._removePorts();\n\n        var model = this.model;\n        var modelAttrs = model.attr();\n        this.updateDOMSubtreeAttributes(this.el, modelAttrs, {\n            rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(model.size()),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n            // Use rendering only attributes if they differs from the model attributes\n            roAttributes: (renderingOnlyAttrs === modelAttrs) ? null : renderingOnlyAttrs\n        });\n\n        if (useCSSSelectors) {\n            this._renderPorts();\n        }\n    },\n\n    rotatableSelector: 'rotatable',\n    scalableSelector: 'scalable',\n    scalableNode: null,\n    rotatableNode: null,\n\n    // `prototype.markup` is rendered by default. Set the `markup` attribute on the model if the\n    // default markup is not desirable.\n    renderMarkup: function() {\n\n        var element = this.model;\n        var markup = element.get('markup') || element.markup;\n        if (!markup) throw new Error('dia.ElementView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.ElementView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        var selectors = this.selectors = doc.selectors;\n        this.rotatableNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(selectors[this.rotatableSelector]) || null;\n        this.scalableNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(selectors[this.scalableSelector]) || null;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        var vel = this.vel;\n        vel.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markup));\n        // Cache transformation groups\n        this.rotatableNode = vel.findOne('.rotatable');\n        this.scalableNode = vel.findOne('.scalable');\n\n        var selectors = this.selectors = {};\n        selectors[this.selector] = this.el;\n    },\n\n    render: function() {\n\n        this.vel.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the resize() triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            // Translate transformation is applied on `this.el` while the rotation transformation\n            // on `this.rotatableNode`\n            this.rotate();\n            this.translate();\n        } else {\n            this.updateTransformation();\n        }\n        if (!this.useCSSSelectors) this._renderPorts();\n        return this;\n    },\n\n    resize: function(opt) {\n\n        if (this.scalableNode) return this.sgResize(opt);\n        if (this.model.attributes.angle) this.rotate();\n        this.update();\n    },\n\n    translate: function() {\n\n        if (this.rotatableNode) return this.rgTranslate();\n        this.updateTransformation();\n    },\n\n    rotate: function() {\n\n        if (this.rotatableNode) {\n            this.rgRotate();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransformation();\n    },\n\n    updateTransformation: function() {\n\n        var transformation = this.getTranslateString();\n        var rotateString = this.getRotateString();\n        if (rotateString) transformation += ' ' + rotateString;\n        this.vel.attr('transform', transformation);\n    },\n\n    getTranslateString: function() {\n\n        const { x, y } = this.model.position();\n        return `translate(${x},${y})`;\n    },\n\n    getRotateString: function() {\n\n        const angle = this.model.angle();\n        if (!angle) return null;\n        const { width, height } = this.model.size();\n        return `rotate(${angle},${width / 2},${height / 2})`;\n    },\n\n    // Rotatable & Scalable Group\n    // always slower, kept mainly for backwards compatibility\n\n    rgRotate: function() {\n\n        this.rotatableNode.attr('transform', this.getRotateString());\n    },\n\n    rgTranslate: function() {\n\n        this.vel.attr('transform', this.getTranslateString());\n    },\n\n    sgResize: function(opt) {\n\n        var model = this.model;\n        var angle = model.angle();\n        var size = model.size();\n        var scalable = this.scalableNode;\n\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path elements inside the scalable group.\n        var recursive = false;\n        if (scalable.node.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need to switch to recursive bbox calculation.\n            // If there are no path descendants, group bbox calculation works and so we can use the (faster) native function directly.\n            recursive = true;\n        }\n        var scalableBBox = scalable.getBBox({ recursive: recursive });\n\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero which can happen if the element does not have any content. By making\n        // the width/height 1, we prevent HTML errors of the type `scale(Infinity, Infinity)`.\n        var sx = (size.width / (scalableBBox.width || 1));\n        var sy = (size.height / (scalableBBox.height || 1));\n        scalable.attr('transform', 'scale(' + sx + ',' + sy + ')');\n\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        var rotatable = this.rotatableNode;\n        var rotation = rotatable && rotatable.attr('transform');\n        if (rotation) {\n\n            rotatable.attr('transform', rotation + ' rotate(' + (-angle) + ',' + (size.width / 2) + ',' + (size.height / 2) + ')');\n            var rotatableBBox = scalable.getBBox({ target: this.paper.cells });\n\n            // Store new x, y and perform rotate() again against the new rotation origin.\n            model.set('position', { x: rotatableBBox.x, y: rotatableBBox.y }, (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign)({ updateHandled: true }, opt));\n            this.translate();\n            this.rotate();\n        }\n\n        // Update must always be called on non-rotated element. Otherwise, relative positioning\n        // would work with wrong (rotated) bounding boxes.\n        this.update();\n    },\n\n    // Embedding mode methods.\n    // -----------------------\n\n    prepareEmbedding: function(data = {}) {\n\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n\n        const initialZIndices = data.initialZIndices = {};\n        const embeddedCells = element.getEmbeddedCells({ deep: true });\n        const connectedLinks = graph.getConnectedLinks(element, { deep: true, includeEnclosed: true });\n\n        // Note: an embedded cell can be a connect link, but it's fine\n        // to iterate over the cell twice.\n        [\n            element,\n            ...embeddedCells,\n            ...connectedLinks\n        ].forEach(cell => initialZIndices[cell.id] = cell.attributes.z);\n\n        element.startBatch('to-front');\n\n        // Bring the model to the front with all his embeds.\n        element.toFront({ deep: true, ui: true });\n\n        // Note that at this point cells in the collection are not sorted by z index (it's running in the batch, see\n        // the dia.Graph._sortOnChangeZ), so we can't assume that the last cell in the collection has the highest z.\n        const maxZ = graph.getElements().reduce((max, cell) => Math.max(max, cell.attributes.z || 0), 0);\n\n        // Move to front also all the inbound and outbound links that are connected\n        // to any of the element descendant. If we bring to front only embedded elements,\n        // links connected to them would stay in the background.\n        connectedLinks.forEach((link) => {\n            if (link.attributes.z <= maxZ) {\n                link.set('z', maxZ + 1, { ui: true });\n            }\n        });\n\n        element.stopBatch('to-front');\n\n        // Before we start looking for suitable parent we remove the current one.\n        const parentId = element.parent();\n        if (parentId) {\n            const parent = graph.getCell(parentId);\n            parent.unembed(element, { ui: true });\n            data.initialParentId = parentId;\n        } else {\n            data.initialParentId = null;\n        }\n    },\n\n    processEmbedding: function(data = {}, evt, x, y) {\n\n        const model = data.model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        const { findParentBy, frontParentOnly, validateEmbedding } = paper.options;\n\n        let candidates;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(findParentBy)) {\n            candidates = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray)(findParentBy.call(graph, this, evt, x, y));\n        } else if (findParentBy === 'pointer') {\n            candidates = graph.findElementsAtPoint({ x, y });\n        } else {\n            candidates = graph.findElementsUnderElement(model, { searchBy: findParentBy });\n        }\n\n        candidates = candidates.filter((el) => {\n            return (el instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_4__.Cell) && (model.id !== el.id) && !el.isEmbeddedIn(model);\n        });\n\n        if (frontParentOnly) {\n            // pick the element with the highest `z` index\n            candidates = candidates.slice(-1);\n        }\n\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n\n        // iterate over all candidates starting from the last one (has the highest z-index).\n        for (let i = candidates.length - 1; i >= 0; i--) {\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.model.id == candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            } else {\n                const view = candidate.findView(paper);\n                if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(validateEmbedding) || validateEmbedding.call(paper, this, view)) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n\n        if (newCandidateView && newCandidateView != prevCandidateView) {\n            // A new candidate view found. Highlight the new one.\n            this.clearEmbedding(data);\n            data.candidateEmbedView = newCandidateView.highlight(\n                newCandidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n        }\n\n        if (!newCandidateView && prevCandidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            this.clearEmbedding(data);\n        }\n    },\n\n    clearEmbedding: function(data) {\n\n        data || (data = {});\n\n        var candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // No candidate view found. Unhighlight the previous candidate.\n            candidateView.unhighlight(\n                candidateView.findProxyNode(null, 'container'),\n                { embedding: true }\n            );\n            data.candidateEmbedView = null;\n        }\n    },\n\n    finalizeEmbedding: function(data = {}) {\n\n        const candidateView = data.candidateEmbedView;\n        const element = data.model || this.model;\n        const paper = data.paper || this.paper;\n\n        if (candidateView) {\n\n            // We finished embedding. Candidate view is chosen to become the parent of the model.\n            candidateView.model.embed(element, { ui: true });\n            candidateView.unhighlight(candidateView.findProxyNode(null, 'container'), { embedding: true });\n\n            data.candidateEmbedView = null;\n\n        } else {\n\n            const { validateUnembedding } = paper.options;\n            const { initialParentId } = data;\n            // The element was originally embedded into another element.\n            // The interaction would unembed the element. Let's validate\n            // if the element can be unembedded.\n            if (\n                initialParentId &&\n                typeof validateUnembedding === 'function' &&\n                !validateUnembedding.call(paper, this)\n            ) {\n                this._disallowUnembed(data);\n                return;\n            }\n        }\n\n        paper.model.getConnectedLinks(element, { deep: true }).forEach(link => {\n            link.reparent({ ui: true });\n        });\n    },\n\n    _disallowUnembed: function(data) {\n        const { model, whenNotAllowed = 'revert' } = data;\n        const element = model || this.model;\n        const paper = data.paper || this.paper;\n        const graph = paper.model;\n        switch (whenNotAllowed) {\n            case 'remove': {\n                element.remove({ ui: true });\n                break;\n            }\n            case 'revert': {\n                const { initialParentId, initialPosition, initialZIndices } = data;\n                // Revert the element's position (and the position of its embedded cells if any)\n                if (initialPosition) {\n                    const { x, y } = initialPosition;\n                    element.position(x, y, { deep: true, ui: true });\n                }\n                // Revert all the z-indices changed during the embedding\n                if (initialZIndices) {\n                    Object.keys(initialZIndices).forEach(id => {\n                        const cell = graph.getCell(id);\n                        if (cell) {\n                            cell.set('z', initialZIndices[id], { ui: true });\n                        }\n                    });\n                }\n                // Revert the original parent\n                const parent = graph.getCell(initialParentId);\n                if (parent) {\n                    parent.embed(element, { ui: true });\n                }\n                break;\n            }\n        }\n    },\n\n    getTargetParentView: function(evt) {\n        const { candidateEmbedView = null } = this.eventData(evt);\n        return candidateEmbedView;\n    },\n\n    getDelegatedView: function() {\n\n        var view = this;\n        var model = view.model;\n        var paper = view.paper;\n\n        while (view) {\n            if (model.isLink()) break;\n            if (!model.isEmbedded() || view.can('stopDelegation')) return view;\n            model = model.getParentCell();\n            view = paper.findViewByModel(model);\n        }\n\n        return null;\n    },\n\n    findProxyNode: function(el, type) {\n        el || (el = this.el);\n        const nodeSelector = el.getAttribute(`${type}-selector`);\n        if (nodeSelector) {\n            const port = this.findAttribute('port', el);\n            if (port) {\n                const proxyPortNode = this.findPortNode(port, nodeSelector);\n                if (proxyPortNode) return proxyPortNode;\n            } else {\n                const proxyNode = this.findNode(nodeSelector);\n                if (proxyNode) return proxyNode;\n            }\n        }\n        return el;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('element:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('element:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('element:pointerup', evt, x, y);\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('element:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('element:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('element:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointermove(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnet(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).drag(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointermove(evt, x, y);\n                break;\n        }\n\n        // Make sure the element view data is passed along.\n        // It could have been wiped out in the handlers above.\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        const data = this.eventData(evt);\n        const { targetMagnet, action, delegatedView } = data;\n\n        if (targetMagnet) {\n            this.magnetpointerup(evt, targetMagnet, x, y);\n        }\n\n        switch (action) {\n            case DragActions.MAGNET:\n                this.dragMagnetEnd(evt, x, y);\n                break;\n            case DragActions.MOVE:\n                (delegatedView || this).dragEnd(evt, x, y);\n            // eslint: no-fallthrough=false\n            default:\n                if (data.preventPointerEvents) break;\n                this.notifyPointerup(evt, x, y);\n        }\n\n        if (targetMagnet) {\n            this.magnetpointerclick(evt, targetMagnet, x, y);\n        }\n\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('element:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('element:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('element:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('element:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('element:mousewheel', evt, x, y, delta);\n    },\n\n    onmagnet: function(evt, x, y) {\n\n        const { currentTarget: targetMagnet } = evt;\n        this.magnetpointerdown(evt, targetMagnet, x, y);\n        this.eventData(evt, { targetMagnet });\n        this.dragMagnetStart(evt, x, y);\n    },\n\n    magnetpointerdown: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdown', evt, magnet, x, y);\n    },\n\n    magnetpointermove: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointermove', evt, magnet, x, y);\n    },\n\n    magnetpointerup: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerup', evt, magnet, x, y);\n    },\n\n    magnetpointerdblclick: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:pointerdblclick', evt, magnet, x, y);\n    },\n\n    magnetcontextmenu: function(evt, magnet, x, y) {\n\n        this.notify('element:magnet:contextmenu', evt, magnet, x, y);\n    },\n\n    // Drag Start Handlers\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        var view = this.getDelegatedView();\n        if (!view || !view.can('elementMove')) return;\n\n        this.eventData(evt, {\n            action: DragActions.MOVE,\n            delegatedView: view\n        });\n\n        const position = view.model.position();\n        view.eventData(evt, {\n            initialPosition: position,\n            pointerOffset: position.difference(x, y),\n            restrictedArea: this.paper.getRestrictedArea(view, x, y)\n        });\n    },\n\n    dragMagnetStart: function(evt, x, y) {\n\n        const { paper } = this;\n        const isPropagationAlreadyStopped = evt.isPropagationStopped();\n        if (isPropagationAlreadyStopped) {\n            // Special case when the propagation was already stopped\n            // on the `element:magnet:pointerdown` event.\n            // Do not trigger any `element:pointer*` events\n            // but still start the magnet dragging.\n            this.eventData(evt, { preventPointerEvents: true });\n        }\n\n        if (this.isDefaultInteractionPrevented(evt) || !this.can('addLinkFromMagnet')) {\n            // Stop the default action, which is to start dragging a link.\n            return;\n        }\n\n        const { targetMagnet = evt.currentTarget } = this.eventData(evt);\n        evt.stopPropagation();\n\n        // Invalid (Passive) magnet. Start dragging the element.\n        if (!paper.options.validateMagnet.call(paper, this, targetMagnet, evt)) {\n            if (isPropagationAlreadyStopped) {\n                // Do not trigger `element:pointerdown` and start element dragging\n                // if the propagation was stopped.\n                this.dragStart(evt, x, y);\n                // The `element:pointerdown` event is not triggered because\n                // of `preventPointerEvents` flag.\n            } else {\n                // We need to reset the action\n                // to `MOVE` so that the element is dragged.\n                this.pointerdown(evt, x, y);\n            }\n            return;\n        }\n\n        // Valid magnet. Start dragging a link.\n        if (paper.options.magnetThreshold <= 0) {\n            this.dragLinkStart(evt, targetMagnet, x, y);\n        }\n        this.eventData(evt, { action: DragActions.MAGNET });\n    },\n\n    // Drag Handlers\n\n    snapToGrid: function(evt, x, y) {\n        const grid = this.paper.options.gridSize;\n        return {\n            x: (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.snapToGrid)(x, grid),\n            y: (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.snapToGrid)(y, grid)\n        };\n    },\n\n    drag: function(evt, x, y) {\n\n        var paper = this.paper;\n        var element = this.model;\n        var data = this.eventData(evt);\n        var { pointerOffset, restrictedArea, embedding } = data;\n\n        // Make sure the new element's position always snaps to the current grid\n        const { x: elX, y: elY } = this.snapToGrid(evt, x + pointerOffset.x, y + pointerOffset.y);\n\n        element.position(elX, elY, { restrictedArea, deep: true, ui: true });\n\n        if (paper.options.embeddingMode) {\n            if (!embedding) {\n                // Prepare the element for embedding only if the pointer moves.\n                // We don't want to do unnecessary action with the element\n                // if an user only clicks/dblclicks on it.\n                this.prepareEmbedding(data);\n                embedding = true;\n            }\n            this.processEmbedding(data, evt, x, y);\n        }\n\n        this.eventData(evt, {\n            embedding\n        });\n    },\n\n    dragMagnet: function(evt, x, y) {\n        this.dragLink(evt, x, y);\n    },\n\n    // Drag End Handlers\n\n    dragEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        if (data.embedding) this.finalizeEmbedding(data);\n    },\n\n    dragMagnetEnd: function(evt, x, y) {\n        this.dragLinkEnd(evt, x, y);\n    },\n\n    magnetpointerclick: function(evt, magnet, x, y) {\n        var paper = this.paper;\n        if (paper.eventData(evt).mousemoved > paper.options.clickThreshold) return;\n        this.notify('element:magnet:pointerclick', evt, magnet, x, y);\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\n(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign)(ElementView.prototype, _ports_mjs__WEBPACK_IMPORTED_MODULE_6__.elementViewPortPrototype);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0VsZW1lbnRWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFnRTtBQUN0QjtBQUNSO0FBQ0g7QUFDd0I7QUFDTDs7QUFFbEQ7QUFDQSxXQUFXLG1EQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxvQkFBb0IsbURBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEseUJBQXlCLG1EQUFROztBQUVqQzs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsUUFBUSxtREFBUTs7QUFFaEI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLGtCQUFr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LFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMOztBQUVBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw0QkFBNEI7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1DQUFtQztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFVO0FBQ3pCLGVBQWUsd0RBQVU7QUFDekI7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQTJDOztBQUV6RDtBQUNBLGdCQUFnQixpQkFBaUI7O0FBRWpDLHFDQUFxQyxzQ0FBc0M7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQSxDQUFDOztBQUVELHVEQUFNLHdCQUF3QixnRUFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvRWxlbWVudFZpZXcubWpzPzQzZWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzaWduLCBpc0Z1bmN0aW9uLCB0b0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ2VsbFZpZXcgfSBmcm9tICcuL0NlbGxWaWV3Lm1qcyc7XG5pbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi9DZWxsLm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBlbGVtZW50Vmlld1BvcnRQcm90b3R5cGUgfSBmcm9tICcuL3BvcnRzLm1qcyc7XG5pbXBvcnQgeyBSZWN0LCBzbmFwVG9HcmlkIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5jb25zdCBGbGFncyA9IHtcbiAgICBUT09MUzogQ2VsbFZpZXcuRmxhZ3MuVE9PTFMsXG4gICAgVVBEQVRFOiAnVVBEQVRFJyxcbiAgICBUUkFOU0xBVEU6ICdUUkFOU0xBVEUnLFxuICAgIFJFU0laRTogJ1JFU0laRScsXG4gICAgUE9SVFM6ICdQT1JUUycsXG4gICAgUk9UQVRFOiAnUk9UQVRFJyxcbiAgICBSRU5ERVI6ICdSRU5ERVInXG59O1xuXG5jb25zdCBEcmFnQWN0aW9ucyA9IHtcbiAgICBNT1ZFOiAnbW92ZScsXG4gICAgTUFHTkVUOiAnbWFnbmV0Jyxcbn07XG4vLyBFbGVtZW50IGJhc2UgdmlldyBhbmQgY29udHJvbGxlci5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IEVsZW1lbnRWaWV3ID0gQ2VsbFZpZXcuZXh0ZW5kKHtcblxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIF9yZW1vdmVQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGltcGxlbWVudGVkIGluIHBvcnRzLmpzXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgX3JlbmRlclBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgaW4gcG9ydHMuanNcbiAgICB9LFxuXG4gICAgY2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IENlbGxWaWV3LnByb3RvdHlwZS5jbGFzc05hbWUuYXBwbHkodGhpcykuc3BsaXQoJyAnKTtcblxuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2VsZW1lbnQnKTtcblxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVBvcnRzKCk7XG4gICAgfSxcblxuICAgIHByZXNlbnRhdGlvbkF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ2F0dHJzJzogW0ZsYWdzLlVQREFURV0sXG4gICAgICAgICdwb3NpdGlvbic6IFtGbGFncy5UUkFOU0xBVEUsIEZsYWdzLlRPT0xTXSxcbiAgICAgICAgJ3NpemUnOiBbRmxhZ3MuUkVTSVpFLCBGbGFncy5QT1JUUywgRmxhZ3MuVE9PTFNdLFxuICAgICAgICAnYW5nbGUnOiBbRmxhZ3MuUk9UQVRFLCBGbGFncy5UT09MU10sXG4gICAgICAgICdtYXJrdXAnOiBbRmxhZ3MuUkVOREVSXSxcbiAgICAgICAgJ3BvcnRzJzogW0ZsYWdzLlBPUlRTXSxcbiAgICB9LFxuXG4gICAgaW5pdEZsYWc6IFtGbGFncy5SRU5ERVJdLFxuXG4gICAgVVBEQVRFX1BSSU9SSVRZOiAwLFxuXG4gICAgY29uZmlybVVwZGF0ZTogZnVuY3Rpb24oZmxhZywgb3B0KSB7XG5cbiAgICAgICAgY29uc3QgeyB1c2VDU1NTZWxlY3RvcnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuUE9SVFMpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVQb3J0cygpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5Qb3J0c0NhY2hlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYW5zZm9ybUhpZ2hsaWdodGVycyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlJFTkRFUikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2xzKG9wdCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodGVycyh0cnVlKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUhpZ2hsaWdodGVycyA9IHRydWU7XG4gICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIFtGbGFncy5SRU5ERVIsIEZsYWdzLlVQREFURSwgRmxhZ3MuUkVTSVpFLCBGbGFncy5UUkFOU0xBVEUsIEZsYWdzLlJPVEFURSwgRmxhZ3MuUE9SVFMsIEZsYWdzLlRPT0xTXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlSGlnaGxpZ2h0ZXJzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFNraXAgdGhpcyBicmFuY2ggaWYgcmVuZGVyIGlzIHJlcXVpcmVkXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlJFU0laRSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZShvcHQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUhpZ2hsaWdodGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVzaXplIG1ldGhvZCBpcyBjYWxsaW5nIGB1cGRhdGUoKWAgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgW0ZsYWdzLlJFU0laRSwgRmxhZ3MuVVBEQVRFXSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZUNTU1NlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBgcmVzaXplKClgIHJlbmRlcmVkIHRoZSBwb3J0cyB3aGVuIHVzZUNTU1NlbGVjdG9ycyBhcmUgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlVQREFURSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLm1vZGVsLCBudWxsLCBvcHQpO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgRmxhZ3MuVVBEQVRFKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh1c2VDU1NTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHVwZGF0ZSgpYCB3aWxsIHJlbmRlciBwb3J0cyB3aGVuIHVzZUNTU1NlbGVjdG9ycyBhcmUgZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlBPUlRTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWcsIEZsYWdzLlRSQU5TTEFURSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgRmxhZ3MuVFJBTlNMQVRFKTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1IaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxhZyhmbGFnLCBGbGFncy5ST1RBVEUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGUoKTtcbiAgICAgICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlJPVEFURSk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSGlnaGxpZ2h0ZXJzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuUE9SVFMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyUG9ydHMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZsYWcgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZywgRmxhZ3MuUE9SVFMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXBkYXRlSGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHRlcnMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zZm9ybUhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1IaWdobGlnaHRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZywgRmxhZ3MuVE9PTFMpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2xzKG9wdCk7XG4gICAgICAgICAgICBmbGFnID0gdGhpcy5yZW1vdmVGbGFnKGZsYWcsIEZsYWdzLlRPT0xTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgaW4gcG9ydHMuanNcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbihfLCByZW5kZXJpbmdPbmx5QXR0cnMpIHtcblxuICAgICAgICB0aGlzLmNsZWFuTm9kZXNDYWNoZSgpO1xuXG4gICAgICAgIC8vIFdoZW4gQ1NTIHNlbGVjdG9yIHN0cmluZ3MgYXJlIHVzZWQsIG1ha2Ugc3VyZSBubyBydWxlIG1hdGNoZXMgcG9ydCBub2Rlcy5cbiAgICAgICAgY29uc3QgeyB1c2VDU1NTZWxlY3RvcnMgfSA9IHRoaXM7XG4gICAgICAgIGlmICh1c2VDU1NTZWxlY3RvcnMpIHRoaXMuX3JlbW92ZVBvcnRzKCk7XG5cbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgdmFyIG1vZGVsQXR0cnMgPSBtb2RlbC5hdHRyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NU3VidHJlZUF0dHJpYnV0ZXModGhpcy5lbCwgbW9kZWxBdHRycywge1xuICAgICAgICAgICAgcm9vdEJCb3g6IG5ldyBSZWN0KG1vZGVsLnNpemUoKSksXG4gICAgICAgICAgICBzZWxlY3RvcnM6IHRoaXMuc2VsZWN0b3JzLFxuICAgICAgICAgICAgc2NhbGFibGVOb2RlOiB0aGlzLnNjYWxhYmxlTm9kZSxcbiAgICAgICAgICAgIHJvdGF0YWJsZU5vZGU6IHRoaXMucm90YXRhYmxlTm9kZSxcbiAgICAgICAgICAgIC8vIFVzZSByZW5kZXJpbmcgb25seSBhdHRyaWJ1dGVzIGlmIHRoZXkgZGlmZmVycyBmcm9tIHRoZSBtb2RlbCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICByb0F0dHJpYnV0ZXM6IChyZW5kZXJpbmdPbmx5QXR0cnMgPT09IG1vZGVsQXR0cnMpID8gbnVsbCA6IHJlbmRlcmluZ09ubHlBdHRyc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodXNlQ1NTU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJQb3J0cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJvdGF0YWJsZVNlbGVjdG9yOiAncm90YXRhYmxlJyxcbiAgICBzY2FsYWJsZVNlbGVjdG9yOiAnc2NhbGFibGUnLFxuICAgIHNjYWxhYmxlTm9kZTogbnVsbCxcbiAgICByb3RhdGFibGVOb2RlOiBudWxsLFxuXG4gICAgLy8gYHByb3RvdHlwZS5tYXJrdXBgIGlzIHJlbmRlcmVkIGJ5IGRlZmF1bHQuIFNldCB0aGUgYG1hcmt1cGAgYXR0cmlidXRlIG9uIHRoZSBtb2RlbCBpZiB0aGVcbiAgICAvLyBkZWZhdWx0IG1hcmt1cCBpcyBub3QgZGVzaXJhYmxlLlxuICAgIHJlbmRlck1hcmt1cDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbWFya3VwID0gZWxlbWVudC5nZXQoJ21hcmt1cCcpIHx8IGVsZW1lbnQubWFya3VwO1xuICAgICAgICBpZiAoIW1hcmt1cCkgdGhyb3cgbmV3IEVycm9yKCdkaWEuRWxlbWVudFZpZXc6IG1hcmt1cCByZXF1aXJlZCcpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXJrdXApKSByZXR1cm4gdGhpcy5yZW5kZXJKU09OTWFya3VwKG1hcmt1cCk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykgcmV0dXJuIHRoaXMucmVuZGVyU3RyaW5nTWFya3VwKG1hcmt1cCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkVsZW1lbnRWaWV3OiBpbnZhbGlkIG1hcmt1cCcpO1xuICAgIH0sXG5cbiAgICByZW5kZXJKU09OTWFya3VwOiBmdW5jdGlvbihtYXJrdXApIHtcblxuICAgICAgICB2YXIgZG9jID0gdGhpcy5wYXJzZURPTUpTT04obWFya3VwLCB0aGlzLmVsKTtcbiAgICAgICAgdmFyIHNlbGVjdG9ycyA9IHRoaXMuc2VsZWN0b3JzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5yb3RhdGFibGVOb2RlID0gVihzZWxlY3RvcnNbdGhpcy5yb3RhdGFibGVTZWxlY3Rvcl0pIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc2NhbGFibGVOb2RlID0gVihzZWxlY3RvcnNbdGhpcy5zY2FsYWJsZVNlbGVjdG9yXSkgfHwgbnVsbDtcbiAgICAgICAgLy8gRnJhZ21lbnRcbiAgICAgICAgdGhpcy52ZWwuYXBwZW5kKGRvYy5mcmFnbWVudCk7XG4gICAgfSxcblxuICAgIHJlbmRlclN0cmluZ01hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgdmFyIHZlbCA9IHRoaXMudmVsO1xuICAgICAgICB2ZWwuYXBwZW5kKFYobWFya3VwKSk7XG4gICAgICAgIC8vIENhY2hlIHRyYW5zZm9ybWF0aW9uIGdyb3Vwc1xuICAgICAgICB0aGlzLnJvdGF0YWJsZU5vZGUgPSB2ZWwuZmluZE9uZSgnLnJvdGF0YWJsZScpO1xuICAgICAgICB0aGlzLnNjYWxhYmxlTm9kZSA9IHZlbC5maW5kT25lKCcuc2NhbGFibGUnKTtcblxuICAgICAgICB2YXIgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgc2VsZWN0b3JzW3RoaXMuc2VsZWN0b3JdID0gdGhpcy5lbDtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnZlbC5lbXB0eSgpO1xuICAgICAgICB0aGlzLnJlbmRlck1hcmt1cCgpO1xuICAgICAgICBpZiAodGhpcy5zY2FsYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIC8vIERvdWJsZSB1cGRhdGUgaXMgbmVjZXNzYXJ5IGZvciBlbGVtZW50cyB3aXRoIHRoZSBzY2FsYWJsZSBncm91cCBvbmx5XG4gICAgICAgICAgICAvLyBOb3RlIHRoZSByZXNpemUoKSB0cmlnZ2VycyB0aGUgb3RoZXIgYHVwZGF0ZWAuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIGlmICh0aGlzLnJvdGF0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0cmFuc2Zvcm1hdGlvbiBpcyBhcHBsaWVkIG9uIGB0aGlzLmVsYCB3aGlsZSB0aGUgcm90YXRpb24gdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgIC8vIG9uIGB0aGlzLnJvdGF0YWJsZU5vZGVgXG4gICAgICAgICAgICB0aGlzLnJvdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudXNlQ1NTU2VsZWN0b3JzKSB0aGlzLl9yZW5kZXJQb3J0cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBpZiAodGhpcy5zY2FsYWJsZU5vZGUpIHJldHVybiB0aGlzLnNnUmVzaXplKG9wdCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMuYW5nbGUpIHRoaXMucm90YXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucm90YXRhYmxlTm9kZSkgcmV0dXJuIHRoaXMucmdUcmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm1hdGlvbigpO1xuICAgIH0sXG5cbiAgICByb3RhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnJvdGF0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucmdSb3RhdGUoKTtcbiAgICAgICAgICAgIC8vIEl0J3MgbmVjZXNzYXJ5IHRvIGNhbGwgdGhlIHVwZGF0ZSBmb3IgdGhlIG5vZGVzIG91dHNpZGVcbiAgICAgICAgICAgIC8vIHRoZSByb3RhdGFibGUgZ3JvdXAgcmVmZXJlbmNpbmcgbm9kZXMgaW5zaWRlIHRoZSBncm91cFxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVRyYW5zZm9ybWF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb24gPSB0aGlzLmdldFRyYW5zbGF0ZVN0cmluZygpO1xuICAgICAgICB2YXIgcm90YXRlU3RyaW5nID0gdGhpcy5nZXRSb3RhdGVTdHJpbmcoKTtcbiAgICAgICAgaWYgKHJvdGF0ZVN0cmluZykgdHJhbnNmb3JtYXRpb24gKz0gJyAnICsgcm90YXRlU3RyaW5nO1xuICAgICAgICB0aGlzLnZlbC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1hdGlvbik7XG4gICAgfSxcblxuICAgIGdldFRyYW5zbGF0ZVN0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLm1vZGVsLnBvc2l0aW9uKCk7XG4gICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sJHt5fSlgO1xuICAgIH0sXG5cbiAgICBnZXRSb3RhdGVTdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdGhpcy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAoIWFuZ2xlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLm1vZGVsLnNpemUoKTtcbiAgICAgICAgcmV0dXJuIGByb3RhdGUoJHthbmdsZX0sJHt3aWR0aCAvIDJ9LCR7aGVpZ2h0IC8gMn0pYDtcbiAgICB9LFxuXG4gICAgLy8gUm90YXRhYmxlICYgU2NhbGFibGUgR3JvdXBcbiAgICAvLyBhbHdheXMgc2xvd2VyLCBrZXB0IG1haW5seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICAgIHJnUm90YXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnJvdGF0YWJsZU5vZGUuYXR0cigndHJhbnNmb3JtJywgdGhpcy5nZXRSb3RhdGVTdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIHJnVHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnZlbC5hdHRyKCd0cmFuc2Zvcm0nLCB0aGlzLmdldFRyYW5zbGF0ZVN0cmluZygpKTtcbiAgICB9LFxuXG4gICAgc2dSZXNpemU6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBhbmdsZSA9IG1vZGVsLmFuZ2xlKCk7XG4gICAgICAgIHZhciBzaXplID0gbW9kZWwuc2l6ZSgpO1xuICAgICAgICB2YXIgc2NhbGFibGUgPSB0aGlzLnNjYWxhYmxlTm9kZTtcblxuICAgICAgICAvLyBHZXR0aW5nIHNjYWxhYmxlIGdyb3VwJ3MgYmJveC5cbiAgICAgICAgLy8gRHVlIHRvIGEgYnVnIGluIHdlYmtpdCdzIG5hdGl2ZSBTVkcgLmdldEJCb3ggaW1wbGVtZW50YXRpb24sIHRoZSBiYm94IG9mIGdyb3VwcyB3aXRoIHBhdGggY2hpbGRyZW4gaW5jbHVkZXMgdGhlIHBhdGhzJyBjb250cm9sIHBvaW50cy5cbiAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhlIGlzc3VlLCB3ZSBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBwYXRoIGVsZW1lbnRzIGluc2lkZSB0aGUgc2NhbGFibGUgZ3JvdXAuXG4gICAgICAgIHZhciByZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNjYWxhYmxlLm5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhdGgnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiBzY2FsYWJsZSBoYXMgYXQgbGVhc3Qgb25lIGRlc2NlbmRhbnQgdGhhdCBpcyBhIHBhdGgsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIHJlY3Vyc2l2ZSBiYm94IGNhbGN1bGF0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhdGggZGVzY2VuZGFudHMsIGdyb3VwIGJib3ggY2FsY3VsYXRpb24gd29ya3MgYW5kIHNvIHdlIGNhbiB1c2UgdGhlIChmYXN0ZXIpIG5hdGl2ZSBmdW5jdGlvbiBkaXJlY3RseS5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjYWxhYmxlQkJveCA9IHNjYWxhYmxlLmdldEJCb3goeyByZWN1cnNpdmU6IHJlY3Vyc2l2ZSB9KTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgYHNjYWxhYmxlQmJveC53aWR0aGAgYW5kIGBzY2FsYWJsZUJib3guaGVpZ2h0YCBhcmUgbm90IHplcm8gd2hpY2ggY2FuIGhhcHBlbiBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFueSBjb250ZW50LiBCeSBtYWtpbmdcbiAgICAgICAgLy8gdGhlIHdpZHRoL2hlaWdodCAxLCB3ZSBwcmV2ZW50IEhUTUwgZXJyb3JzIG9mIHRoZSB0eXBlIGBzY2FsZShJbmZpbml0eSwgSW5maW5pdHkpYC5cbiAgICAgICAgdmFyIHN4ID0gKHNpemUud2lkdGggLyAoc2NhbGFibGVCQm94LndpZHRoIHx8IDEpKTtcbiAgICAgICAgdmFyIHN5ID0gKHNpemUuaGVpZ2h0IC8gKHNjYWxhYmxlQkJveC5oZWlnaHQgfHwgMSkpO1xuICAgICAgICBzY2FsYWJsZS5hdHRyKCd0cmFuc2Zvcm0nLCAnc2NhbGUoJyArIHN4ICsgJywnICsgc3kgKyAnKScpO1xuXG4gICAgICAgIC8vIE5vdyB0aGUgaW50ZXJlc3RpbmcgcGFydC4gVGhlIGdvYWwgaXMgdG8gYmUgYWJsZSB0byBzdG9yZSB0aGUgb2JqZWN0IGdlb21ldHJ5IHZpYSBqdXN0IGB4YCwgYHlgLCBgYW5nbGVgLCBgd2lkdGhgIGFuZCBgaGVpZ2h0YFxuICAgICAgICAvLyBPcmRlciBvZiB0cmFuc2Zvcm1hdGlvbnMgaXMgc2lnbmlmaWNhbnQgYnV0IHdlIHdhbnQgdG8gcmVjb25zdHJ1Y3QgdGhlIG9iamVjdCBhbHdheXMgaW4gdGhlIG9yZGVyOlxuICAgICAgICAvLyByZXNpemUoKSwgcm90YXRlKCksIHRyYW5zbGF0ZSgpIG5vIG1hdHRlciBvZiBob3cgdGhlIG9iamVjdCB3YXMgdHJhbnNmb3JtZWQuIEZvciB0aGF0IHRvIHdvcmssXG4gICAgICAgIC8vIHdlIG11c3QgYWRqdXN0IHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBvZiB0aGUgb2JqZWN0IHdoZW5ldmVyIHdlIHJlc2l6ZSBpdCAoYmVjYXVzZSB0aGUgb3JpZ2luIG9mIHRoZVxuICAgICAgICAvLyByb3RhdGlvbiBjaGFuZ2VzKS4gVGhlIG5ldyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBhcmUgY29tcHV0ZWQgYnkgY2FuY2VsaW5nIHRoZSBwcmV2aW91cyByb3RhdGlvblxuICAgICAgICAvLyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgcmVzaXplZCBvYmplY3QgKHdoaWNoIGlzIGEgZGlmZmVyZW50IG9yaWdpbiB0aGVuIHRoZSBvcmlnaW4gb2YgdGhlIHByZXZpb3VzIHJvdGF0aW9uKVxuICAgICAgICAvLyBhbmQgZ2V0dGluZyB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LiBUaGVuIHdlIGNsZWFuIHVwIHRoZSByb3RhdGlvbiBiYWNrIHRvIHdoYXQgaXQgb3JpZ2luYWxseSB3YXMuXG5cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSByb3RhdGlvbiBidXQgbm93IGFyb3VuZCBhIGRpZmZlcmVudCBvcmlnaW4sIHdoaWNoIGlzIHRoZSBjZW50ZXIgb2YgdGhlIHNjYWxlZCBvYmplY3QuXG4gICAgICAgIHZhciByb3RhdGFibGUgPSB0aGlzLnJvdGF0YWJsZU5vZGU7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHJvdGF0YWJsZSAmJiByb3RhdGFibGUuYXR0cigndHJhbnNmb3JtJyk7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuXG4gICAgICAgICAgICByb3RhdGFibGUuYXR0cigndHJhbnNmb3JtJywgcm90YXRpb24gKyAnIHJvdGF0ZSgnICsgKC1hbmdsZSkgKyAnLCcgKyAoc2l6ZS53aWR0aCAvIDIpICsgJywnICsgKHNpemUuaGVpZ2h0IC8gMikgKyAnKScpO1xuICAgICAgICAgICAgdmFyIHJvdGF0YWJsZUJCb3ggPSBzY2FsYWJsZS5nZXRCQm94KHsgdGFyZ2V0OiB0aGlzLnBhcGVyLmNlbGxzIH0pO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBuZXcgeCwgeSBhbmQgcGVyZm9ybSByb3RhdGUoKSBhZ2FpbiBhZ2FpbnN0IHRoZSBuZXcgcm90YXRpb24gb3JpZ2luLlxuICAgICAgICAgICAgbW9kZWwuc2V0KCdwb3NpdGlvbicsIHsgeDogcm90YXRhYmxlQkJveC54LCB5OiByb3RhdGFibGVCQm94LnkgfSwgYXNzaWduKHsgdXBkYXRlSGFuZGxlZDogdHJ1ZSB9LCBvcHQpKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIG11c3QgYWx3YXlzIGJlIGNhbGxlZCBvbiBub24tcm90YXRlZCBlbGVtZW50LiBPdGhlcndpc2UsIHJlbGF0aXZlIHBvc2l0aW9uaW5nXG4gICAgICAgIC8vIHdvdWxkIHdvcmsgd2l0aCB3cm9uZyAocm90YXRlZCkgYm91bmRpbmcgYm94ZXMuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIC8vIEVtYmVkZGluZyBtb2RlIG1ldGhvZHMuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHByZXBhcmVFbWJlZGRpbmc6IGZ1bmN0aW9uKGRhdGEgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhLm1vZGVsIHx8IHRoaXMubW9kZWw7XG4gICAgICAgIGNvbnN0IHBhcGVyID0gZGF0YS5wYXBlciB8fCB0aGlzLnBhcGVyO1xuICAgICAgICBjb25zdCBncmFwaCA9IHBhcGVyLm1vZGVsO1xuXG4gICAgICAgIGNvbnN0IGluaXRpYWxaSW5kaWNlcyA9IGRhdGEuaW5pdGlhbFpJbmRpY2VzID0ge307XG4gICAgICAgIGNvbnN0IGVtYmVkZGVkQ2VsbHMgPSBlbGVtZW50LmdldEVtYmVkZGVkQ2VsbHMoeyBkZWVwOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRMaW5rcyA9IGdyYXBoLmdldENvbm5lY3RlZExpbmtzKGVsZW1lbnQsIHsgZGVlcDogdHJ1ZSwgaW5jbHVkZUVuY2xvc2VkOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIE5vdGU6IGFuIGVtYmVkZGVkIGNlbGwgY2FuIGJlIGEgY29ubmVjdCBsaW5rLCBidXQgaXQncyBmaW5lXG4gICAgICAgIC8vIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2VsbCB0d2ljZS5cbiAgICAgICAgW1xuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIC4uLmVtYmVkZGVkQ2VsbHMsXG4gICAgICAgICAgICAuLi5jb25uZWN0ZWRMaW5rc1xuICAgICAgICBdLmZvckVhY2goY2VsbCA9PiBpbml0aWFsWkluZGljZXNbY2VsbC5pZF0gPSBjZWxsLmF0dHJpYnV0ZXMueik7XG5cbiAgICAgICAgZWxlbWVudC5zdGFydEJhdGNoKCd0by1mcm9udCcpO1xuXG4gICAgICAgIC8vIEJyaW5nIHRoZSBtb2RlbCB0byB0aGUgZnJvbnQgd2l0aCBhbGwgaGlzIGVtYmVkcy5cbiAgICAgICAgZWxlbWVudC50b0Zyb250KHsgZGVlcDogdHJ1ZSwgdWk6IHRydWUgfSk7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGF0IHRoaXMgcG9pbnQgY2VsbHMgaW4gdGhlIGNvbGxlY3Rpb24gYXJlIG5vdCBzb3J0ZWQgYnkgeiBpbmRleCAoaXQncyBydW5uaW5nIGluIHRoZSBiYXRjaCwgc2VlXG4gICAgICAgIC8vIHRoZSBkaWEuR3JhcGguX3NvcnRPbkNoYW5nZVopLCBzbyB3ZSBjYW4ndCBhc3N1bWUgdGhhdCB0aGUgbGFzdCBjZWxsIGluIHRoZSBjb2xsZWN0aW9uIGhhcyB0aGUgaGlnaGVzdCB6LlxuICAgICAgICBjb25zdCBtYXhaID0gZ3JhcGguZ2V0RWxlbWVudHMoKS5yZWR1Y2UoKG1heCwgY2VsbCkgPT4gTWF0aC5tYXgobWF4LCBjZWxsLmF0dHJpYnV0ZXMueiB8fCAwKSwgMCk7XG5cbiAgICAgICAgLy8gTW92ZSB0byBmcm9udCBhbHNvIGFsbCB0aGUgaW5ib3VuZCBhbmQgb3V0Ym91bmQgbGlua3MgdGhhdCBhcmUgY29ubmVjdGVkXG4gICAgICAgIC8vIHRvIGFueSBvZiB0aGUgZWxlbWVudCBkZXNjZW5kYW50LiBJZiB3ZSBicmluZyB0byBmcm9udCBvbmx5IGVtYmVkZGVkIGVsZW1lbnRzLFxuICAgICAgICAvLyBsaW5rcyBjb25uZWN0ZWQgdG8gdGhlbSB3b3VsZCBzdGF5IGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAgICBjb25uZWN0ZWRMaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICBpZiAobGluay5hdHRyaWJ1dGVzLnogPD0gbWF4Wikge1xuICAgICAgICAgICAgICAgIGxpbmsuc2V0KCd6JywgbWF4WiArIDEsIHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGVsZW1lbnQuc3RvcEJhdGNoKCd0by1mcm9udCcpO1xuXG4gICAgICAgIC8vIEJlZm9yZSB3ZSBzdGFydCBsb29raW5nIGZvciBzdWl0YWJsZSBwYXJlbnQgd2UgcmVtb3ZlIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgY29uc3QgcGFyZW50SWQgPSBlbGVtZW50LnBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGdyYXBoLmdldENlbGwocGFyZW50SWQpO1xuICAgICAgICAgICAgcGFyZW50LnVuZW1iZWQoZWxlbWVudCwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRhdGEuaW5pdGlhbFBhcmVudElkID0gcGFyZW50SWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmluaXRpYWxQYXJlbnRJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJvY2Vzc0VtYmVkZGluZzogZnVuY3Rpb24oZGF0YSA9IHt9LCBldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCBtb2RlbCA9IGRhdGEubW9kZWwgfHwgdGhpcy5tb2RlbDtcbiAgICAgICAgY29uc3QgcGFwZXIgPSBkYXRhLnBhcGVyIHx8IHRoaXMucGFwZXI7XG4gICAgICAgIGNvbnN0IGdyYXBoID0gcGFwZXIubW9kZWw7XG4gICAgICAgIGNvbnN0IHsgZmluZFBhcmVudEJ5LCBmcm9udFBhcmVudE9ubHksIHZhbGlkYXRlRW1iZWRkaW5nIH0gPSBwYXBlci5vcHRpb25zO1xuXG4gICAgICAgIGxldCBjYW5kaWRhdGVzO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmaW5kUGFyZW50QnkpKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdG9BcnJheShmaW5kUGFyZW50QnkuY2FsbChncmFwaCwgdGhpcywgZXZ0LCB4LCB5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmluZFBhcmVudEJ5ID09PSAncG9pbnRlcicpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBncmFwaC5maW5kRWxlbWVudHNBdFBvaW50KHsgeCwgeSB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBncmFwaC5maW5kRWxlbWVudHNVbmRlckVsZW1lbnQobW9kZWwsIHsgc2VhcmNoQnk6IGZpbmRQYXJlbnRCeSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcigoZWwpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZWwgaW5zdGFuY2VvZiBDZWxsKSAmJiAobW9kZWwuaWQgIT09IGVsLmlkKSAmJiAhZWwuaXNFbWJlZGRlZEluKG1vZGVsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGZyb250UGFyZW50T25seSkge1xuICAgICAgICAgICAgLy8gcGljayB0aGUgZWxlbWVudCB3aXRoIHRoZSBoaWdoZXN0IGB6YCBpbmRleFxuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuc2xpY2UoLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5ld0NhbmRpZGF0ZVZpZXcgPSBudWxsO1xuICAgICAgICBjb25zdCBwcmV2Q2FuZGlkYXRlVmlldyA9IGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3O1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgY2FuZGlkYXRlcyBzdGFydGluZyBmcm9tIHRoZSBsYXN0IG9uZSAoaGFzIHRoZSBoaWdoZXN0IHotaW5kZXgpLlxuICAgICAgICBmb3IgKGxldCBpID0gY2FuZGlkYXRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmV2Q2FuZGlkYXRlVmlldyAmJiBwcmV2Q2FuZGlkYXRlVmlldy5tb2RlbC5pZCA9PSBjYW5kaWRhdGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW5kaWRhdGUgcmVtYWlucyB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIG5ld0NhbmRpZGF0ZVZpZXcgPSBwcmV2Q2FuZGlkYXRlVmlldztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGNhbmRpZGF0ZS5maW5kVmlldyhwYXBlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHZhbGlkYXRlRW1iZWRkaW5nKSB8fCB2YWxpZGF0ZUVtYmVkZGluZy5jYWxsKHBhcGVyLCB0aGlzLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmbGlwIHRvIHRoZSBuZXcgY2FuZGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIG5ld0NhbmRpZGF0ZVZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3Q2FuZGlkYXRlVmlldyAmJiBuZXdDYW5kaWRhdGVWaWV3ICE9IHByZXZDYW5kaWRhdGVWaWV3KSB7XG4gICAgICAgICAgICAvLyBBIG5ldyBjYW5kaWRhdGUgdmlldyBmb3VuZC4gSGlnaGxpZ2h0IHRoZSBuZXcgb25lLlxuICAgICAgICAgICAgdGhpcy5jbGVhckVtYmVkZGluZyhkYXRhKTtcbiAgICAgICAgICAgIGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3ID0gbmV3Q2FuZGlkYXRlVmlldy5oaWdobGlnaHQoXG4gICAgICAgICAgICAgICAgbmV3Q2FuZGlkYXRlVmlldy5maW5kUHJveHlOb2RlKG51bGwsICdjb250YWluZXInKSxcbiAgICAgICAgICAgICAgICB7IGVtYmVkZGluZzogdHJ1ZSB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXdDYW5kaWRhdGVWaWV3ICYmIHByZXZDYW5kaWRhdGVWaWV3KSB7XG4gICAgICAgICAgICAvLyBObyBjYW5kaWRhdGUgdmlldyBmb3VuZC4gVW5oaWdobGlnaHQgdGhlIHByZXZpb3VzIGNhbmRpZGF0ZS5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJFbWJlZGRpbmcoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXJFbWJlZGRpbmc6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICBkYXRhIHx8IChkYXRhID0ge30pO1xuXG4gICAgICAgIHZhciBjYW5kaWRhdGVWaWV3ID0gZGF0YS5jYW5kaWRhdGVFbWJlZFZpZXc7XG4gICAgICAgIGlmIChjYW5kaWRhdGVWaWV3KSB7XG4gICAgICAgICAgICAvLyBObyBjYW5kaWRhdGUgdmlldyBmb3VuZC4gVW5oaWdobGlnaHQgdGhlIHByZXZpb3VzIGNhbmRpZGF0ZS5cbiAgICAgICAgICAgIGNhbmRpZGF0ZVZpZXcudW5oaWdobGlnaHQoXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlVmlldy5maW5kUHJveHlOb2RlKG51bGwsICdjb250YWluZXInKSxcbiAgICAgICAgICAgICAgICB7IGVtYmVkZGluZzogdHJ1ZSB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGF0YS5jYW5kaWRhdGVFbWJlZFZpZXcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbmFsaXplRW1iZWRkaW5nOiBmdW5jdGlvbihkYXRhID0ge30pIHtcblxuICAgICAgICBjb25zdCBjYW5kaWRhdGVWaWV3ID0gZGF0YS5jYW5kaWRhdGVFbWJlZFZpZXc7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhLm1vZGVsIHx8IHRoaXMubW9kZWw7XG4gICAgICAgIGNvbnN0IHBhcGVyID0gZGF0YS5wYXBlciB8fCB0aGlzLnBhcGVyO1xuXG4gICAgICAgIGlmIChjYW5kaWRhdGVWaWV3KSB7XG5cbiAgICAgICAgICAgIC8vIFdlIGZpbmlzaGVkIGVtYmVkZGluZy4gQ2FuZGlkYXRlIHZpZXcgaXMgY2hvc2VuIHRvIGJlY29tZSB0aGUgcGFyZW50IG9mIHRoZSBtb2RlbC5cbiAgICAgICAgICAgIGNhbmRpZGF0ZVZpZXcubW9kZWwuZW1iZWQoZWxlbWVudCwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVZpZXcudW5oaWdobGlnaHQoY2FuZGlkYXRlVmlldy5maW5kUHJveHlOb2RlKG51bGwsICdjb250YWluZXInKSwgeyBlbWJlZGRpbmc6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIGRhdGEuY2FuZGlkYXRlRW1iZWRWaWV3ID0gbnVsbDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkYXRlVW5lbWJlZGRpbmcgfSA9IHBhcGVyLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCB7IGluaXRpYWxQYXJlbnRJZCB9ID0gZGF0YTtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IHdhcyBvcmlnaW5hbGx5IGVtYmVkZGVkIGludG8gYW5vdGhlciBlbGVtZW50LlxuICAgICAgICAgICAgLy8gVGhlIGludGVyYWN0aW9uIHdvdWxkIHVuZW1iZWQgdGhlIGVsZW1lbnQuIExldCdzIHZhbGlkYXRlXG4gICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBjYW4gYmUgdW5lbWJlZGRlZC5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBpbml0aWFsUGFyZW50SWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsaWRhdGVVbmVtYmVkZGluZyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICF2YWxpZGF0ZVVuZW1iZWRkaW5nLmNhbGwocGFwZXIsIHRoaXMpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhbGxvd1VuZW1iZWQoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFwZXIubW9kZWwuZ2V0Q29ubmVjdGVkTGlua3MoZWxlbWVudCwgeyBkZWVwOiB0cnVlIH0pLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICBsaW5rLnJlcGFyZW50KHsgdWk6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZGlzYWxsb3dVbmVtYmVkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHdoZW5Ob3RBbGxvd2VkID0gJ3JldmVydCcgfSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtb2RlbCB8fCB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCBwYXBlciA9IGRhdGEucGFwZXIgfHwgdGhpcy5wYXBlcjtcbiAgICAgICAgY29uc3QgZ3JhcGggPSBwYXBlci5tb2RlbDtcbiAgICAgICAgc3dpdGNoICh3aGVuTm90QWxsb3dlZCkge1xuICAgICAgICAgICAgY2FzZSAncmVtb3ZlJzoge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlKHsgdWk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdyZXZlcnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbml0aWFsUGFyZW50SWQsIGluaXRpYWxQb3NpdGlvbiwgaW5pdGlhbFpJbmRpY2VzIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgZWxlbWVudCdzIHBvc2l0aW9uIChhbmQgdGhlIHBvc2l0aW9uIG9mIGl0cyBlbWJlZGRlZCBjZWxscyBpZiBhbnkpXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGluaXRpYWxQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5wb3NpdGlvbih4LCB5LCB7IGRlZXA6IHRydWUsIHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXZlcnQgYWxsIHRoZSB6LWluZGljZXMgY2hhbmdlZCBkdXJpbmcgdGhlIGVtYmVkZGluZ1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsWkluZGljZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaW5pdGlhbFpJbmRpY2VzKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBncmFwaC5nZXRDZWxsKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5zZXQoJ3onLCBpbml0aWFsWkluZGljZXNbaWRdLCB7IHVpOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBvcmlnaW5hbCBwYXJlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBncmFwaC5nZXRDZWxsKGluaXRpYWxQYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZW1iZWQoZWxlbWVudCwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VGFyZ2V0UGFyZW50VmlldzogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgY2FuZGlkYXRlRW1iZWRWaWV3ID0gbnVsbCB9ID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUVtYmVkVmlldztcbiAgICB9LFxuXG4gICAgZ2V0RGVsZWdhdGVkVmlldzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzO1xuICAgICAgICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICB2YXIgcGFwZXIgPSB2aWV3LnBhcGVyO1xuXG4gICAgICAgIHdoaWxlICh2aWV3KSB7XG4gICAgICAgICAgICBpZiAobW9kZWwuaXNMaW5rKCkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCFtb2RlbC5pc0VtYmVkZGVkKCkgfHwgdmlldy5jYW4oJ3N0b3BEZWxlZ2F0aW9uJykpIHJldHVybiB2aWV3O1xuICAgICAgICAgICAgbW9kZWwgPSBtb2RlbC5nZXRQYXJlbnRDZWxsKCk7XG4gICAgICAgICAgICB2aWV3ID0gcGFwZXIuZmluZFZpZXdCeU1vZGVsKG1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBmaW5kUHJveHlOb2RlOiBmdW5jdGlvbihlbCwgdHlwZSkge1xuICAgICAgICBlbCB8fCAoZWwgPSB0aGlzLmVsKTtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdG9yID0gZWwuZ2V0QXR0cmlidXRlKGAke3R5cGV9LXNlbGVjdG9yYCk7XG4gICAgICAgIGlmIChub2RlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSB0aGlzLmZpbmRBdHRyaWJ1dGUoJ3BvcnQnLCBlbCk7XG4gICAgICAgICAgICBpZiAocG9ydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5UG9ydE5vZGUgPSB0aGlzLmZpbmRQb3J0Tm9kZShwb3J0LCBub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcm94eVBvcnROb2RlKSByZXR1cm4gcHJveHlQb3J0Tm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHlOb2RlID0gdGhpcy5maW5kTm9kZShub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChwcm94eU5vZGUpIHJldHVybiBwcm94eU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcmFjdGlvbi4gVGhlIGNvbnRyb2xsZXIgcGFydC5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIG5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcmRvd24uY2FsbCh0aGlzLCBldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpwb2ludGVyZG93bicsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG5vdGlmeVBvaW50ZXJtb3ZlKGV2dCwgeCwgeSkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcm1vdmUuY2FsbCh0aGlzLCBldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpwb2ludGVybW92ZScsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG5vdGlmeVBvaW50ZXJ1cChldnQsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcnVwJywgZXZ0LCB4LCB5KTtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJ1cC5jYWxsKHRoaXMsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJkYmxjbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpwb2ludGVyZGJsY2xpY2snLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyY2xpY2s6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVyY2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6cG9pbnRlcmNsaWNrJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgY29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5jb250ZXh0bWVudS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDpjb250ZXh0bWVudScsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJkb3duKGV2dCwgeCwgeSk7XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0KGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgY29uc3QgeyB0YXJnZXRNYWduZXQsIGFjdGlvbiwgZGVsZWdhdGVkVmlldyB9ID0gZGF0YTtcblxuICAgICAgICBpZiAodGFyZ2V0TWFnbmV0KSB7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldHBvaW50ZXJtb3ZlKGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIERyYWdBY3Rpb25zLk1BR05FVDpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdNYWduZXQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0FjdGlvbnMuTU9WRTpcbiAgICAgICAgICAgICAgICAoZGVsZWdhdGVkVmlldyB8fCB0aGlzKS5kcmFnKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQ6IG5vLWZhbGx0aHJvdWdoPWZhbHNlXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnByZXZlbnRQb2ludGVyRXZlbnRzKSBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJtb3ZlKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgdmlldyBkYXRhIGlzIHBhc3NlZCBhbG9uZy5cbiAgICAgICAgLy8gSXQgY291bGQgaGF2ZSBiZWVuIHdpcGVkIG91dCBpbiB0aGUgaGFuZGxlcnMgYWJvdmUuXG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgZGF0YSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0TWFnbmV0LCBhY3Rpb24sIGRlbGVnYXRlZFZpZXcgfSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKHRhcmdldE1hZ25ldCkge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRwb2ludGVydXAoZXZ0LCB0YXJnZXRNYWduZXQsIHgsIHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgRHJhZ0FjdGlvbnMuTUFHTkVUOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ01hZ25ldEVuZChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEcmFnQWN0aW9ucy5NT1ZFOlxuICAgICAgICAgICAgICAgIChkZWxlZ2F0ZWRWaWV3IHx8IHRoaXMpLmRyYWdFbmQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIC8vIGVzbGludDogbm8tZmFsbHRocm91Z2g9ZmFsc2VcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucHJldmVudFBvaW50ZXJFdmVudHMpIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5UG9pbnRlcnVwKGV2dCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0TWFnbmV0KSB7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldHBvaW50ZXJjbGljayhldnQsIHRhcmdldE1hZ25ldCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrTW91c2VsZWF2ZShldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZW92ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2VsZW1lbnQ6bW91c2VvdmVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZW91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptb3VzZW91dCcsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZWVudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1vdXNlZW50ZXInLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VsZWF2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptb3VzZWxlYXZlJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0LCB4LCB5LCBkZWx0YSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZXdoZWVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1vdXNld2hlZWwnLCBldnQsIHgsIHksIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgb25tYWduZXQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRhcmdldDogdGFyZ2V0TWFnbmV0IH0gPSBldnQ7XG4gICAgICAgIHRoaXMubWFnbmV0cG9pbnRlcmRvd24oZXZ0LCB0YXJnZXRNYWduZXQsIHgsIHkpO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgdGFyZ2V0TWFnbmV0IH0pO1xuICAgICAgICB0aGlzLmRyYWdNYWduZXRTdGFydChldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcmRvd24nLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJtb3ZlOiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1hZ25ldDpwb2ludGVybW92ZScsIGV2dCwgbWFnbmV0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgbWFnbmV0cG9pbnRlcnVwOiBmdW5jdGlvbihldnQsIG1hZ25ldCwgeCwgeSkge1xuXG4gICAgICAgIHRoaXMubm90aWZ5KCdlbGVtZW50Om1hZ25ldDpwb2ludGVydXAnLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0LCBtYWduZXQsIHgsIHkpIHtcblxuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6Y29udGV4dG1lbnUnLCBldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgU3RhcnQgSGFuZGxlcnNcblxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQoZXZ0KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5nZXREZWxlZ2F0ZWRWaWV3KCk7XG4gICAgICAgIGlmICghdmlldyB8fCAhdmlldy5jYW4oJ2VsZW1lbnRNb3ZlJykpIHJldHVybjtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGFjdGlvbjogRHJhZ0FjdGlvbnMuTU9WRSxcbiAgICAgICAgICAgIGRlbGVnYXRlZFZpZXc6IHZpZXdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB2aWV3Lm1vZGVsLnBvc2l0aW9uKCk7XG4gICAgICAgIHZpZXcuZXZlbnREYXRhKGV2dCwge1xuICAgICAgICAgICAgaW5pdGlhbFBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIHBvaW50ZXJPZmZzZXQ6IHBvc2l0aW9uLmRpZmZlcmVuY2UoeCwgeSksXG4gICAgICAgICAgICByZXN0cmljdGVkQXJlYTogdGhpcy5wYXBlci5nZXRSZXN0cmljdGVkQXJlYSh2aWV3LCB4LCB5KVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZHJhZ01hZ25ldFN0YXJ0OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCB7IHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpc1Byb3BhZ2F0aW9uQWxyZWFkeVN0b3BwZWQgPSBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgICAgaWYgKGlzUHJvcGFnYXRpb25BbHJlYWR5U3RvcHBlZCkge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gdGhlIHByb3BhZ2F0aW9uIHdhcyBhbHJlYWR5IHN0b3BwZWRcbiAgICAgICAgICAgIC8vIG9uIHRoZSBgZWxlbWVudDptYWduZXQ6cG9pbnRlcmRvd25gIGV2ZW50LlxuICAgICAgICAgICAgLy8gRG8gbm90IHRyaWdnZXIgYW55IGBlbGVtZW50OnBvaW50ZXIqYCBldmVudHNcbiAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCBzdGFydCB0aGUgbWFnbmV0IGRyYWdnaW5nLlxuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IHByZXZlbnRQb2ludGVyRXZlbnRzOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQoZXZ0KSB8fCAhdGhpcy5jYW4oJ2FkZExpbmtGcm9tTWFnbmV0JykpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYWN0aW9uLCB3aGljaCBpcyB0byBzdGFydCBkcmFnZ2luZyBhIGxpbmsuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHRhcmdldE1hZ25ldCA9IGV2dC5jdXJyZW50VGFyZ2V0IH0gPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgLy8gSW52YWxpZCAoUGFzc2l2ZSkgbWFnbmV0LiBTdGFydCBkcmFnZ2luZyB0aGUgZWxlbWVudC5cbiAgICAgICAgaWYgKCFwYXBlci5vcHRpb25zLnZhbGlkYXRlTWFnbmV0LmNhbGwocGFwZXIsIHRoaXMsIHRhcmdldE1hZ25ldCwgZXZ0KSkge1xuICAgICAgICAgICAgaWYgKGlzUHJvcGFnYXRpb25BbHJlYWR5U3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGBlbGVtZW50OnBvaW50ZXJkb3duYCBhbmQgc3RhcnQgZWxlbWVudCBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wYWdhdGlvbiB3YXMgc3RvcHBlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdTdGFydChldnQsIHgsIHkpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgZWxlbWVudDpwb2ludGVyZG93bmAgZXZlbnQgaXMgbm90IHRyaWdnZXJlZCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gb2YgYHByZXZlbnRQb2ludGVyRXZlbnRzYCBmbGFnLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlc2V0IHRoZSBhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyB0byBgTU9WRWAgc28gdGhhdCB0aGUgZWxlbWVudCBpcyBkcmFnZ2VkLlxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRlcmRvd24oZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkIG1hZ25ldC4gU3RhcnQgZHJhZ2dpbmcgYSBsaW5rLlxuICAgICAgICBpZiAocGFwZXIub3B0aW9ucy5tYWduZXRUaHJlc2hvbGQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnTGlua1N0YXJ0KGV2dCwgdGFyZ2V0TWFnbmV0LCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgYWN0aW9uOiBEcmFnQWN0aW9ucy5NQUdORVQgfSk7XG4gICAgfSxcblxuICAgIC8vIERyYWcgSGFuZGxlcnNcblxuICAgIHNuYXBUb0dyaWQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5wYXBlci5vcHRpb25zLmdyaWRTaXplO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogc25hcFRvR3JpZCh4LCBncmlkKSxcbiAgICAgICAgICAgIHk6IHNuYXBUb0dyaWQoeSwgZ3JpZClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZHJhZzogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdmFyIHBhcGVyID0gdGhpcy5wYXBlcjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIHZhciB7IHBvaW50ZXJPZmZzZXQsIHJlc3RyaWN0ZWRBcmVhLCBlbWJlZGRpbmcgfSA9IGRhdGE7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXcgZWxlbWVudCdzIHBvc2l0aW9uIGFsd2F5cyBzbmFwcyB0byB0aGUgY3VycmVudCBncmlkXG4gICAgICAgIGNvbnN0IHsgeDogZWxYLCB5OiBlbFkgfSA9IHRoaXMuc25hcFRvR3JpZChldnQsIHggKyBwb2ludGVyT2Zmc2V0LngsIHkgKyBwb2ludGVyT2Zmc2V0LnkpO1xuXG4gICAgICAgIGVsZW1lbnQucG9zaXRpb24oZWxYLCBlbFksIHsgcmVzdHJpY3RlZEFyZWEsIGRlZXA6IHRydWUsIHVpOiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChwYXBlci5vcHRpb25zLmVtYmVkZGluZ01vZGUpIHtcbiAgICAgICAgICAgIGlmICghZW1iZWRkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgZWxlbWVudCBmb3IgZW1iZWRkaW5nIG9ubHkgaWYgdGhlIHBvaW50ZXIgbW92ZXMuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBkbyB1bm5lY2Vzc2FyeSBhY3Rpb24gd2l0aCB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGlmIGFuIHVzZXIgb25seSBjbGlja3MvZGJsY2xpY2tzIG9uIGl0LlxuICAgICAgICAgICAgICAgIHRoaXMucHJlcGFyZUVtYmVkZGluZyhkYXRhKTtcbiAgICAgICAgICAgICAgICBlbWJlZGRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRW1iZWRkaW5nKGRhdGEsIGV2dCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGVtYmVkZGluZ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZHJhZ01hZ25ldDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIHRoaXMuZHJhZ0xpbmsoZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgLy8gRHJhZyBFbmQgSGFuZGxlcnNcblxuICAgIGRyYWdFbmQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgaWYgKGRhdGEuZW1iZWRkaW5nKSB0aGlzLmZpbmFsaXplRW1iZWRkaW5nKGRhdGEpO1xuICAgIH0sXG5cbiAgICBkcmFnTWFnbmV0RW5kOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5kcmFnTGlua0VuZChldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBtYWduZXRwb2ludGVyY2xpY2s6IGZ1bmN0aW9uKGV2dCwgbWFnbmV0LCB4LCB5KSB7XG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIGlmIChwYXBlci5ldmVudERhdGEoZXZ0KS5tb3VzZW1vdmVkID4gcGFwZXIub3B0aW9ucy5jbGlja1RocmVzaG9sZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLm5vdGlmeSgnZWxlbWVudDptYWduZXQ6cG9pbnRlcmNsaWNrJywgZXZ0LCBtYWduZXQsIHgsIHkpO1xuICAgIH1cblxufSwge1xuXG4gICAgRmxhZ3M6IEZsYWdzLFxufSk7XG5cbmFzc2lnbihFbGVtZW50Vmlldy5wcm90b3R5cGUsIGVsZW1lbnRWaWV3UG9ydFByb3RvdHlwZSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/ElementView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/Graph.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Graph.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Graph: function() { return /* binding */ Graph; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/getRectPoint.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mvc/Model.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/Collection.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Collection.mjs\");\n/* harmony import */ var _util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/wrappers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/wrappers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/cloneCells.mjs\");\n\n\n\n\n\n\n\n\nconst GraphCells = _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__.Collection.extend({\n\n    initialize: function(models, opt) {\n\n        // Set the optional namespace where all model classes are defined.\n        if (opt.cellNamespace) {\n            this.cellNamespace = opt.cellNamespace;\n        } else {\n            /* eslint-disable no-undef */\n            this.cellNamespace = typeof joint !== 'undefined' && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n\n        this.graph = opt.graph;\n    },\n\n    model: function(attrs, opt) {\n\n        const collection = opt.collection;\n        const namespace = collection.cellNamespace;\n        const { type } = attrs;\n\n        // Find the model class based on the `type` attribute in the cell namespace\n        const ModelClass = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.getByPath(namespace, type, '.');\n        if (!ModelClass) {\n            throw new Error(`dia.Graph: Could not find cell constructor for type: '${type}'. Make sure to add the constructor to 'cellNamespace'.`);\n        }\n\n        return new ModelClass(attrs, opt);\n    },\n\n    _addReference: function(model, options) {\n        _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__.Collection.prototype._addReference.apply(this, arguments);\n        // If not in `dry` mode and the model does not have a graph reference yet,\n        // set the reference.\n        if (!options.dry && !model.graph) {\n            model.graph = this.graph;\n        }\n    },\n\n    _removeReference: function(model, options) {\n        _mvc_Collection_mjs__WEBPACK_IMPORTED_MODULE_0__.Collection.prototype._removeReference.apply(this, arguments);\n        // If not in `dry` mode and the model has a reference to this exact graph,\n        // remove the reference.\n        if (!options.dry && model.graph === this.graph) {\n            model.graph = null;\n        }\n    },\n\n    // `comparator` makes it easy to sort cells based on their `z` index.\n    comparator: function(model) {\n\n        return model.get('z') || 0;\n    }\n});\n\n\nconst Graph = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.extend({\n\n    initialize: function(attrs, opt) {\n\n        opt = opt || {};\n\n        // Passing `cellModel` function in the options object to graph allows for\n        // setting models based on attribute objects. This is especially handy\n        // when processing JSON graphs that are in a different than JointJS format.\n        var cells = new GraphCells([], {\n            model: opt.cellModel,\n            cellNamespace: opt.cellNamespace,\n            graph: this\n        });\n        _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.prototype.set.call(this, 'cells', cells);\n\n        // Make all the events fired in the `cells` collection available.\n        // to the outside world.\n        cells.on('all', this.trigger, this);\n\n        // JointJS automatically doesn't trigger re-sort if models attributes are changed later when\n        // they're already in the collection. Therefore, we're triggering sort manually here.\n        this.on('change:z', this._sortOnChangeZ, this);\n\n        // `joint.dia.Graph` keeps an internal data structure (an adjacency list)\n        // for fast graph queries. All changes that affect the structure of the graph\n        // must be reflected in the `al` object. This object provides fast answers to\n        // questions such as \"what are the neighbours of this node\" or \"what\n        // are the sibling links of this link\".\n\n        // Outgoing edges per node. Note that we use a hash-table for the list\n        // of outgoing edges for a faster lookup.\n        // [nodeId] -> Object [edgeId] -> true\n        this._out = {};\n        // Ingoing edges per node.\n        // [nodeId] -> Object [edgeId] -> true\n        this._in = {};\n        // `_nodes` is useful for quick lookup of all the elements in the graph, without\n        // having to go through the whole cells array.\n        // [node ID] -> true\n        this._nodes = {};\n        // `_edges` is useful for quick lookup of all the links in the graph, without\n        // having to go through the whole cells array.\n        // [edgeId] -> true\n        this._edges = {};\n\n        this._batches = {};\n\n        cells.on('add', this._restructureOnAdd, this);\n        cells.on('remove', this._restructureOnRemove, this);\n        cells.on('reset', this._restructureOnReset, this);\n        cells.on('change:source', this._restructureOnChangeSource, this);\n        cells.on('change:target', this._restructureOnChangeTarget, this);\n        cells.on('remove', this._removeCell, this);\n    },\n\n    _sortOnChangeZ: function() {\n\n        this.get('cells').sort();\n    },\n\n    _restructureOnAdd: function(cell) {\n\n        if (cell.isLink()) {\n            this._edges[cell.id] = true;\n            var { source, target } = cell.attributes;\n            if (source.id) {\n                (this._out[source.id] || (this._out[source.id] = {}))[cell.id] = true;\n            }\n            if (target.id) {\n                (this._in[target.id] || (this._in[target.id] = {}))[cell.id] = true;\n            }\n        } else {\n            this._nodes[cell.id] = true;\n        }\n    },\n\n    _restructureOnRemove: function(cell) {\n\n        if (cell.isLink()) {\n            delete this._edges[cell.id];\n            var { source, target } = cell.attributes;\n            if (source.id && this._out[source.id] && this._out[source.id][cell.id]) {\n                delete this._out[source.id][cell.id];\n            }\n            if (target.id && this._in[target.id] && this._in[target.id][cell.id]) {\n                delete this._in[target.id][cell.id];\n            }\n        } else {\n            delete this._nodes[cell.id];\n        }\n    },\n\n    _restructureOnReset: function(cells) {\n\n        // Normalize into an array of cells. The original `cells` is GraphCells mvc collection.\n        cells = cells.models;\n\n        this._out = {};\n        this._in = {};\n        this._nodes = {};\n        this._edges = {};\n\n        cells.forEach(this._restructureOnAdd, this);\n    },\n\n    _restructureOnChangeSource: function(link) {\n\n        var prevSource = link.previous('source');\n        if (prevSource.id && this._out[prevSource.id]) {\n            delete this._out[prevSource.id][link.id];\n        }\n        var source = link.attributes.source;\n        if (source.id) {\n            (this._out[source.id] || (this._out[source.id] = {}))[link.id] = true;\n        }\n    },\n\n    _restructureOnChangeTarget: function(link) {\n\n        var prevTarget = link.previous('target');\n        if (prevTarget.id && this._in[prevTarget.id]) {\n            delete this._in[prevTarget.id][link.id];\n        }\n        var target = link.get('target');\n        if (target.id) {\n            (this._in[target.id] || (this._in[target.id] = {}))[link.id] = true;\n        }\n    },\n\n    // Return all outbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getOutboundEdges: function(node) {\n\n        return (this._out && this._out[node]) || {};\n    },\n\n    // Return all inbound edges for the node. Return value is an object\n    // of the form: [edgeId] -> true\n    getInboundEdges: function(node) {\n\n        return (this._in && this._in[node]) || {};\n    },\n\n    toJSON: function(opt = {}) {\n\n        // JointJS does not recursively call `toJSON()` on attributes that are themselves models/collections.\n        // It just clones the attributes. Therefore, we must call `toJSON()` on the cells collection explicitly.\n        var json = _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.prototype.toJSON.apply(this, arguments);\n        json.cells = this.get('cells').toJSON(opt.cellAttributes);\n        return json;\n    },\n\n    fromJSON: function(json, opt) {\n\n        if (!json.cells) {\n\n            throw new Error('Graph JSON must contain cells array.');\n        }\n\n        return this.set(json, opt);\n    },\n\n    set: function(key, val, opt) {\n\n        var attrs;\n\n        // Handle both `key`, value and {key: value} style arguments.\n        if (typeof key === 'object') {\n            attrs = key;\n            opt = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        // Make sure that `cells` attribute is handled separately via resetCells().\n        if (attrs.hasOwnProperty('cells')) {\n            this.resetCells(attrs.cells, opt);\n            attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit(attrs, 'cells');\n        }\n\n        // The rest of the attributes are applied via original set method.\n        return _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model.prototype.set.call(this, attrs, opt);\n    },\n\n    clear: function(opt) {\n\n        opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, { clear: true });\n\n        var collection = this.get('cells');\n\n        if (collection.length === 0) return this;\n\n        this.startBatch('clear', opt);\n\n        // The elements come after the links.\n        var cells = collection.sortBy(function(cell) {\n            return cell.isLink() ? 1 : 2;\n        });\n\n        do {\n\n            // Remove all the cells one by one.\n            // Note that all the links are removed first, so it's\n            // safe to remove the elements without removing the connected\n            // links first.\n            cells.shift().remove(opt);\n\n        } while (cells.length > 0);\n\n        this.stopBatch('clear');\n\n        return this;\n    },\n\n    _prepareCell: function(cell) {\n\n        let attrs;\n        if (cell instanceof _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model) {\n            attrs = cell.attributes;\n        } else {\n            attrs = cell;\n        }\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString(attrs.type)) {\n            throw new TypeError('dia.Graph: cell type must be a string.');\n        }\n\n        return cell;\n    },\n\n    minZIndex: function() {\n\n        var firstCell = this.get('cells').first();\n        return firstCell ? (firstCell.get('z') || 0) : 0;\n    },\n\n    maxZIndex: function() {\n\n        var lastCell = this.get('cells').last();\n        return lastCell ? (lastCell.get('z') || 0) : 0;\n    },\n\n    addCell: function(cell, opt) {\n\n        if (Array.isArray(cell)) {\n\n            return this.addCells(cell, opt);\n        }\n\n        if (cell instanceof _mvc_Model_mjs__WEBPACK_IMPORTED_MODULE_3__.Model) {\n\n            if (!cell.has('z')) {\n                cell.set('z', this.maxZIndex() + 1);\n            }\n\n        } else if (cell.z === undefined) {\n\n            cell.z = this.maxZIndex() + 1;\n        }\n\n        this.get('cells').add(this._prepareCell(cell, opt), opt || {});\n\n        return this;\n    },\n\n    addCells: function(cells, opt) {\n\n        if (cells.length === 0) return this;\n\n        cells = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenDeep(cells);\n        opt.maxPosition = opt.position = cells.length - 1;\n\n        this.startBatch('add', opt);\n        cells.forEach(function(cell) {\n            this.addCell(cell, opt);\n            opt.position--;\n        }, this);\n        this.stopBatch('add', opt);\n\n        return this;\n    },\n\n    // When adding a lot of cells, it is much more efficient to\n    // reset the entire cells collection in one go.\n    // Useful for bulk operations and optimizations.\n    resetCells: function(cells, opt) {\n\n        var preparedCells = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).map(function(cell) {\n            return this._prepareCell(cell, opt);\n        }, this);\n        this.get('cells').reset(preparedCells, opt);\n\n        return this;\n    },\n\n    removeCells: function(cells, opt) {\n\n        if (cells.length) {\n\n            this.startBatch('remove');\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, 'remove', opt);\n            this.stopBatch('remove');\n        }\n\n        return this;\n    },\n\n    _removeCell: function(cell, collection, options) {\n\n        options = options || {};\n\n        if (!options.clear) {\n            // Applications might provide a `disconnectLinks` option set to `true` in order to\n            // disconnect links when a cell is removed rather then removing them. The default\n            // is to remove all the associated links.\n            if (options.disconnectLinks) {\n\n                this.disconnectLinks(cell, options);\n\n            } else {\n\n                this.removeLinks(cell, options);\n            }\n        }\n        // Silently remove the cell from the cells collection. Silently, because\n        // `joint.dia.Cell.prototype.remove` already triggers the `remove` event which is\n        // then propagated to the graph model. If we didn't remove the cell silently, two `remove` events\n        // would be triggered on the graph model.\n        this.get('cells').remove(cell, { silent: true });\n    },\n\n    transferCellEmbeds: function(sourceCell, targetCell, opt = {}) {\n\n        const batchName = 'transfer-embeds';\n        this.startBatch(batchName);\n\n        // Embed children of the source cell in the target cell.\n        const children = sourceCell.getEmbeddedCells();\n        targetCell.embed(children, { ...opt, reparent: true });\n\n        this.stopBatch(batchName);\n    },\n\n    transferCellConnectedLinks: function(sourceCell, targetCell, opt = {}) {\n\n        const batchName = 'transfer-connected-links';\n        this.startBatch(batchName);\n\n        // Reconnect all the links connected to the old cell to the new cell.\n        const connectedLinks = this.getConnectedLinks(sourceCell, opt);\n        connectedLinks.forEach((link) => {\n\n            if (link.getSourceCell() === sourceCell) {\n                link.prop(['source', 'id'], targetCell.id, opt);\n            }\n\n            if (link.getTargetCell() === sourceCell) {\n                link.prop(['target', 'id'], targetCell.id, opt);\n            }\n        });\n\n        this.stopBatch(batchName);\n    },\n\n    // Get a cell by `id`.\n    getCell: function(id) {\n\n        return this.get('cells').get(id);\n    },\n\n    getCells: function() {\n\n        return this.get('cells').toArray();\n    },\n\n    getElements: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isElement());\n    },\n\n    getLinks: function() {\n\n        return this.get('cells').toArray().filter(cell => cell.isLink());\n    },\n\n    getFirstCell: function() {\n\n        return this.get('cells').first();\n    },\n\n    getLastCell: function() {\n\n        return this.get('cells').last();\n    },\n\n    // Get all inbound and outbound links connected to the cell `model`.\n    getConnectedLinks: function(model, opt) {\n\n        opt = opt || {};\n\n        var indirect = opt.indirect;\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        // the final array of connected link models\n        var links = [];\n        // a hash table of connected edges of the form: [edgeId] -> true\n        // used for quick lookups to check if we already added a link\n        var edges = {};\n\n        if (outbound) {\n            addOutbounds(this, model);\n        }\n        if (inbound) {\n            addInbounds(this, model);\n        }\n\n        function addOutbounds(graph, model) {\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(graph.getOutboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var outCell = model.getTargetCell();\n                if (outCell && outCell.isLink()) {\n                    if (!edges[outCell.id]) {\n                        links.push(outCell);\n                        addOutbounds(graph, outCell);\n                    }\n                }\n            }\n        }\n\n        function addInbounds(graph, model) {\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(graph.getInboundEdges(model.id), function(_, edge) {\n                // skip links that were already added\n                // (those must be self-loop links)\n                // (because they are inbound and outbound edges of the same two elements)\n                if (edges[edge]) return;\n                var link = graph.getCell(edge);\n                links.push(link);\n                edges[edge] = true;\n                if (indirect) {\n                    if (inbound) addInbounds(graph, link);\n                    if (outbound) addOutbounds(graph, link);\n                }\n            }.bind(graph));\n            if (indirect && model.isLink()) {\n                var inCell = model.getSourceCell();\n                if (inCell && inCell.isLink()) {\n                    if (!edges[inCell.id]) {\n                        links.push(inCell);\n                        addInbounds(graph, inCell);\n                    }\n                }\n            }\n        }\n\n        // if `deep` option is `true`, check also all the links that are connected to any of the descendant cells\n        if (opt.deep) {\n\n            var embeddedCells = model.getEmbeddedCells({ deep: true });\n\n            // in the first round, we collect all the embedded elements\n            var embeddedElements = {};\n            embeddedCells.forEach(function(cell) {\n                if (cell.isElement()) {\n                    embeddedElements[cell.id] = true;\n                }\n            });\n\n            embeddedCells.forEach(function(cell) {\n                if (cell.isLink()) return;\n                if (outbound) {\n                    _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this.getOutboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n                if (inbound) {\n                    _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this.getInboundEdges(cell.id), function(exists, edge) {\n                        if (!edges[edge]) {\n                            var edgeCell = this.getCell(edge);\n                            var { source, target } = edgeCell.attributes;\n                            var sourceId = source.id;\n                            var targetId = target.id;\n\n                            // if `includeEnclosed` option is falsy, skip enclosed links\n                            if (!opt.includeEnclosed\n                                && (sourceId && embeddedElements[sourceId])\n                                && (targetId && embeddedElements[targetId])) {\n                                return;\n                            }\n\n                            links.push(this.getCell(edge));\n                            edges[edge] = true;\n                        }\n                    }.bind(this));\n                }\n            }, this);\n        }\n\n        return links;\n    },\n\n    getNeighbors: function(model, opt) {\n\n        opt || (opt = {});\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if (inbound === undefined && outbound === undefined) {\n            inbound = outbound = true;\n        }\n\n        var neighbors = this.getConnectedLinks(model, opt).reduce(function(res, link) {\n\n            var { source, target } = link.attributes;\n            var loop = link.hasLoop(opt);\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (inbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(source, 'id') && !res[source.id]) {\n\n                var sourceElement = this.getCell(source.id);\n                if (sourceElement.isElement()) {\n                    if (loop || (sourceElement && sourceElement !== model && (!opt.deep || !sourceElement.isEmbeddedIn(model)))) {\n                        res[source.id] = sourceElement;\n                    }\n                }\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(target, 'id') && !res[target.id]) {\n\n                var targetElement = this.getCell(target.id);\n                if (targetElement.isElement()) {\n                    if (loop || (targetElement && targetElement !== model && (!opt.deep || !targetElement.isEmbeddedIn(model)))) {\n                        res[target.id] = targetElement;\n                    }\n                }\n            }\n\n            return res;\n        }.bind(this), {});\n\n        if (model.isLink()) {\n            if (inbound) {\n                var sourceCell = model.getSourceCell();\n                if (sourceCell && sourceCell.isElement() && !neighbors[sourceCell.id]) {\n                    neighbors[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outbound) {\n                var targetCell = model.getTargetCell();\n                if (targetCell && targetCell.isElement() && !neighbors[targetCell.id]) {\n                    neighbors[targetCell.id] = targetCell;\n                }\n            }\n        }\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(neighbors);\n    },\n\n    getCommonAncestor: function(/* cells */) {\n\n        var cellsAncestors = Array.from(arguments).map(function(cell) {\n\n            var ancestors = [];\n            var parentId = cell.get('parent');\n\n            while (parentId) {\n\n                ancestors.push(parentId);\n                parentId = this.getCell(parentId).get('parent');\n            }\n\n            return ancestors;\n\n        }, this);\n\n        cellsAncestors = cellsAncestors.sort(function(a, b) {\n            return a.length - b.length;\n        });\n\n        var commonAncestor = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cellsAncestors.shift()).find(function(ancestor) {\n            return cellsAncestors.every(function(cellAncestors) {\n                return cellAncestors.includes(ancestor);\n            });\n        });\n\n        return this.getCell(commonAncestor);\n    },\n\n    // Find the whole branch starting at `element`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getSuccessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `outbound` neighbors only. In other words, search forwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, { outbound: true }));\n        return res;\n    },\n\n    cloneCells: _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.cloneCells,\n    // Clone the whole subgraph (including all the connected links whose source/target is in the subgraph).\n    // If `opt.deep` is `true`, also take into account all the embedded cells of all the subgraph cells.\n    // Return a map of the form: [original cell ID] -> [clone].\n    cloneSubgraph: function(cells, opt) {\n\n        var subgraph = this.getSubgraph(cells, opt);\n        return this.cloneCells(subgraph);\n    },\n\n    // Return `cells` and all the connected links that connect cells in the `cells` array.\n    // If `opt.deep` is `true`, return all the cells including all their embedded cells\n    // and all the links that connect any of the returned cells.\n    // For example, for a single shallow element, the result is that very same element.\n    // For two elements connected with a link: `A --- L ---> B`, the result for\n    // `getSubgraph([A, B])` is `[A, L, B]`. The same goes for `getSubgraph([L])`, the result is again `[A, L, B]`.\n    getSubgraph: function(cells, opt) {\n\n        opt = opt || {};\n\n        var subgraph = [];\n        // `cellMap` is used for a quick lookup of existence of a cell in the `cells` array.\n        var cellMap = {};\n        var elements = [];\n        var links = [];\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).forEach(function(cell) {\n            if (!cellMap[cell.id]) {\n                subgraph.push(cell);\n                cellMap[cell.id] = cell;\n                if (cell.isLink()) {\n                    links.push(cell);\n                } else {\n                    elements.push(cell);\n                }\n            }\n\n            if (opt.deep) {\n                var embeds = cell.getEmbeddedCells({ deep: true });\n                embeds.forEach(function(embed) {\n                    if (!cellMap[embed.id]) {\n                        subgraph.push(embed);\n                        cellMap[embed.id] = embed;\n                        if (embed.isLink()) {\n                            links.push(embed);\n                        } else {\n                            elements.push(embed);\n                        }\n                    }\n                });\n            }\n        });\n\n        links.forEach(function(link) {\n            // For links, return their source & target (if they are elements - not points).\n            var { source, target } = link.attributes;\n            if (source.id && !cellMap[source.id]) {\n                var sourceElement = this.getCell(source.id);\n                subgraph.push(sourceElement);\n                cellMap[sourceElement.id] = sourceElement;\n                elements.push(sourceElement);\n            }\n            if (target.id && !cellMap[target.id]) {\n                var targetElement = this.getCell(target.id);\n                subgraph.push(this.getCell(target.id));\n                cellMap[targetElement.id] = targetElement;\n                elements.push(targetElement);\n            }\n        }, this);\n\n        elements.forEach(function(element) {\n            // For elements, include their connected links if their source/target is in the subgraph;\n            var links = this.getConnectedLinks(element, opt);\n            links.forEach(function(link) {\n                var { source, target } = link.attributes;\n                if (!cellMap[link.id] && source.id && cellMap[source.id] && target.id && cellMap[target.id]) {\n                    subgraph.push(link);\n                    cellMap[link.id] = link;\n                }\n            });\n        }, this);\n\n        return subgraph;\n    },\n\n    // Find all the predecessors of `element`. This is a reverse operation of `getSuccessors()`.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first search algorithm, otherwise use Depth-first search.\n    getPredecessors: function(element, opt) {\n\n        opt = opt || {};\n        var res = [];\n        // Modify the options so that it includes the `inbound` neighbors only. In other words, search backwards.\n        this.search(element, function(el) {\n            if (el !== element) {\n                res.push(el);\n            }\n        }, _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, opt, { inbound: true }));\n        return res;\n    },\n\n    // Perform search on the graph.\n    // If `opt.breadthFirst` is `true`, use the Breadth-first Search algorithm, otherwise use Depth-first search.\n    // By setting `opt.inbound` to `true`, you can reverse the direction of the search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // `iteratee` is a function of the form `function(element) {}`.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    search: function(element, iteratee, opt) {\n\n        opt = opt || {};\n        if (opt.breadthFirst) {\n            this.bfs(element, iteratee, opt);\n        } else {\n            this.dfs(element, iteratee, opt);\n        }\n    },\n\n    // Breadth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // where `element` is the currently visited element and `distance` is the distance of that element\n    // from the root `element` passed the `bfs()`, i.e. the element we started the search from.\n    // Note that the `distance` is not the shortest or longest distance, it is simply the number of levels\n    // crossed till we visited the `element` for the first time. It is especially useful for tree graphs.\n    // If `iteratee` explicitly returns `false`, the searching stops.\n    bfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            var next = queue.shift();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            }\n        }\n    },\n\n    // Depth-first search.\n    // If `opt.deep` is `true`, take into account embedded elements too.\n    // If `opt.inbound` is `true`, reverse the search direction (it's like reversing all the link directions).\n    // `iteratee` is a function of the form `function(element, distance) {}`.\n    // If `iteratee` explicitly returns `false`, the search stops.\n    dfs: function(element, iteratee, opt = {}) {\n\n        const visited = {};\n        const distance = {};\n        const queue = [];\n\n        queue.push(element);\n        distance[element.id] = 0;\n\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (visited[next.id]) continue;\n            visited[next.id] = true;\n            if (iteratee.call(this, next, distance[next.id]) === false) continue;\n            const neighbors = this.getNeighbors(next, opt);\n            const lastIndex = queue.length;\n            for (let i = 0, n = neighbors.length; i < n; i++) {\n                const neighbor = neighbors[i];\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            }\n        }\n    },\n\n    // Get all the roots of the graph. Time complexity: O(|V|).\n    getSources: function() {\n\n        var sources = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this._nodes, function(exists, node) {\n            if (!this._in[node] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._in[node])) {\n                sources.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sources;\n    },\n\n    // Get all the leafs of the graph. Time complexity: O(|V|).\n    getSinks: function() {\n\n        var sinks = [];\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn(this._nodes, function(exists, node) {\n            if (!this._out[node] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._out[node])) {\n                sinks.push(this.getCell(node));\n            }\n        }.bind(this));\n        return sinks;\n    },\n\n    // Return `true` if `element` is a root. Time complexity: O(1).\n    isSource: function(element) {\n\n        return !this._in[element.id] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._in[element.id]);\n    },\n\n    // Return `true` if `element` is a leaf. Time complexity: O(1).\n    isSink: function(element) {\n\n        return !this._out[element.id] || _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty(this._out[element.id]);\n    },\n\n    // Return `true` is `elementB` is a successor of `elementA`. Return `false` otherwise.\n    isSuccessor: function(elementA, elementB) {\n\n        var isSuccessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isSuccessor = true;\n                return false;\n            }\n        }, { outbound: true });\n        return isSuccessor;\n    },\n\n    // Return `true` is `elementB` is a predecessor of `elementA`. Return `false` otherwise.\n    isPredecessor: function(elementA, elementB) {\n\n        var isPredecessor = false;\n        this.search(elementA, function(element) {\n            if (element === elementB && element !== elementA) {\n                isPredecessor = true;\n                return false;\n            }\n        }, { inbound: true });\n        return isPredecessor;\n    },\n\n    // Return `true` is `elementB` is a neighbor of `elementA`. Return `false` otherwise.\n    // `opt.deep` controls whether to take into account embedded elements as well. See `getNeighbors()`\n    // for more details.\n    // If `opt.outbound` is set to `true`, return `true` only if `elementB` is a successor neighbor.\n    // Similarly, if `opt.inbound` is set to `true`, return `true` only if `elementB` is a predecessor neighbor.\n    isNeighbor: function(elementA, elementB, opt) {\n\n        opt = opt || {};\n\n        var inbound = opt.inbound;\n        var outbound = opt.outbound;\n        if ((inbound === undefined) && (outbound === undefined)) {\n            inbound = outbound = true;\n        }\n\n        var isNeighbor = false;\n\n        this.getConnectedLinks(elementA, opt).forEach(function(link) {\n\n            var { source, target } = link.attributes;\n\n            // Discard if it is a point.\n            if (inbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(source, 'id') && (source.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n\n            // Discard if it is a point, or if the neighbor was already added.\n            if (outbound && _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.has(target, 'id') && (target.id === elementB.id)) {\n                isNeighbor = true;\n                return false;\n            }\n        });\n\n        return isNeighbor;\n    },\n\n    // Disconnect links connected to the cell `model`.\n    disconnectLinks: function(model, opt) {\n\n        this.getConnectedLinks(model).forEach(function(link) {\n\n            link.set((link.attributes.source.id === model.id ? 'source' : 'target'), { x: 0, y: 0 }, opt);\n        });\n    },\n\n    // Remove links connected to the cell `model` completely.\n    removeLinks: function(model, opt) {\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(this.getConnectedLinks(model), 'remove', opt);\n    },\n\n    // Find all cells at given point\n\n    findElementsAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getElements(), point, opt);\n    },\n\n    findLinksAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getLinks(), point, opt);\n    },\n\n    findCellsAtPoint: function(point, opt) {\n        return this._filterAtPoint(this.getCells(), point, opt);\n    },\n\n    _filterAtPoint: function(cells, point, opt = {}) {\n        return cells.filter(el => el.getBBox({ rotate: true }).containsPoint(point, opt));\n    },\n\n    // Find all cells in given area\n\n    findElementsInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getElements(), area, opt);\n    },\n\n    findLinksInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getLinks(), area, opt);\n    },\n\n    findCellsInArea: function(area, opt = {}) {\n        return this._filterInArea(this.getCells(), area, opt);\n    },\n\n    _filterInArea: function(cells, area, opt = {}) {\n        const r = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(area);\n        const { strict = false } = opt;\n        const method = strict ? 'containsRect' : 'intersect';\n        return cells.filter(el => r[method](el.getBBox({ rotate: true })));\n    },\n\n    // Find all cells under the given element.\n\n    findElementsUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getElements(), element, opt);\n    },\n\n    findLinksUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getLinks(), element, opt);\n    },\n\n    findCellsUnderElement: function(element, opt) {\n        return this._filterCellsUnderElement(this.getCells(), element, opt);\n    },\n\n    _isValidElementUnderElement: function(el1, el2) {\n        return el1.id !== el2.id && !el1.isEmbeddedIn(el2);\n    },\n\n    _isValidLinkUnderElement: function(link, el) {\n        return (\n            link.source().id !== el.id &&\n            link.target().id !== el.id &&\n            !link.isEmbeddedIn(el)\n        );\n    },\n\n    _validateCellsUnderElement: function(cells, element) {\n        return cells.filter(cell => {\n            return cell.isLink()\n                ? this._isValidLinkUnderElement(cell, element)\n                : this._isValidElementUnderElement(cell, element);\n        });\n    },\n\n    _getFindUnderElementGeometry: function(element, searchBy = 'bbox') {\n        const bbox = element.getBBox({ rotate: true });\n        return (searchBy !== 'bbox') ? _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.getRectPoint(bbox, searchBy) : bbox;\n    },\n\n    _filterCellsUnderElement: function(cells, element, opt = {}) {\n        const geometry = this._getFindUnderElementGeometry(element, opt.searchBy);\n        const filteredCells = (geometry.type === _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.types.Point)\n            ? this._filterAtPoint(cells, geometry)\n            : this._filterInArea(cells, geometry, opt);\n        return this._validateCellsUnderElement(filteredCells, element);\n    },\n\n    // @deprecated use `findElementsInArea` instead\n    findModelsInArea: function(area, opt) {\n        return this.findElementsInArea(area, opt);\n    },\n\n    // @deprecated use `findElementsAtPoint` instead\n    findModelsFromPoint: function(point) {\n        return this.findElementsAtPoint(point);\n    },\n\n    // @deprecated use `findModelsUnderElement` instead\n    findModelsUnderElement: function(element, opt) {\n        return this.findElementsUnderElement(element, opt);\n    },\n\n    // Return bounding box of all elements.\n    getBBox: function() {\n\n        return this.getCellsBBox(this.getCells());\n    },\n\n    // Return the bounding box of all cells in array provided.\n    getCellsBBox: function(cells, opt = {}) {\n        const { rotate = true } = opt;\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray(cells).reduce(function(memo, cell) {\n            const rect = cell.getBBox({ rotate });\n            if (!rect) return memo;\n            if (memo) {\n                return memo.union(rect);\n            }\n            return rect;\n        }, null);\n    },\n\n    translate: function(dx, dy, opt) {\n\n        // Don't translate cells that are embedded in any other cell.\n        var cells = this.getCells().filter(function(cell) {\n            return !cell.isEmbedded();\n        });\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, 'translate', dx, dy, opt);\n\n        return this;\n    },\n\n    resize: function(width, height, opt) {\n\n        return this.resizeCells(width, height, this.getCells(), opt);\n    },\n\n    resizeCells: function(width, height, cells, opt) {\n\n        // `getBBox` method returns `null` if no elements provided.\n        // i.e. cells can be an array of links\n        var bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            var sx = Math.max(width / bbox.width, 0);\n            var sy = Math.max(height / bbox.height, 0);\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke(cells, 'scale', sx, sy, bbox.origin(), opt);\n        }\n\n        return this;\n    },\n\n    startBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) + 1;\n\n        return this.trigger('batch:start', _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, data, { batchName: name }));\n    },\n\n    stopBatch: function(name, data) {\n\n        data = data || {};\n        this._batches[name] = (this._batches[name] || 0) - 1;\n\n        return this.trigger('batch:stop', _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign({}, data, { batchName: name }));\n    },\n\n    hasActiveBatch: function(name) {\n\n        const batches = this._batches;\n        let names;\n\n        if (arguments.length === 0) {\n            names = Object.keys(batches);\n        } else if (Array.isArray(name)) {\n            names = name;\n        } else {\n            names = [name];\n        }\n\n        return names.some((batch) => batches[batch] > 0);\n    }\n\n}, {\n\n    validations: {\n\n        multiLinks: function(graph, link) {\n\n            // Do not allow multiple links to have the same source and target.\n            var { source, target } = link.attributes;\n\n            if (source.id && target.id) {\n\n                var sourceModel = link.getSourceCell();\n                if (sourceModel) {\n\n                    var connectedLinks = graph.getConnectedLinks(sourceModel, { outbound: true });\n                    var sameLinks = connectedLinks.filter(function(_link) {\n\n                        var { source: _source, target: _target } = _link.attributes;\n                        return _source && _source.id === source.id &&\n                            (!_source.port || (_source.port === source.port)) &&\n                            _target && _target.id === target.id &&\n                            (!_target.port || (_target.port === target.port));\n\n                    });\n\n                    if (sameLinks.length > 1) {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        },\n\n        linkPinning: function(_graph, link) {\n            var { source, target } = link.attributes;\n            return source.id && target.id;\n        }\n    }\n\n});\n\n(0,_util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__.wrapWith)(Graph.prototype, ['resetCells', 'addCells', 'removeCells'], _util_wrappers_mjs__WEBPACK_IMPORTED_MODULE_8__.wrappers.cells);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0dyYXBoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ047O0FBRUs7QUFDVTtBQUNPO0FBQ1g7O0FBRS9DLG1CQUFtQiwyREFBVTs7QUFFN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsaUVBQWlFLGdEQUFRO0FBQ3pFO0FBQ0E7OztBQUdBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87O0FBRXZCO0FBQ0EsMkJBQTJCLHNEQUFjO0FBQ3pDO0FBQ0EscUZBQXFGLEtBQUs7QUFDMUY7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsUUFBUSwyREFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFFBQVEsMkRBQVU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR00sY0FBYyxpREFBSzs7QUFFMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSxpREFBSzs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtB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Szs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsMENBQTBDO0FBQzFDLGdCQUFnQixnQkFBZ0I7QUFDaEMsZUFBZSxvREFBWTtBQUMzQix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxRQUFRLG1EQUFXOztBQUVuQjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQVc7QUFDdkI7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLG1EQUFXLEdBQUcsVUFBVSxpQkFBaUI7QUFDcEYsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxtREFBVyxHQUFHLFVBQVUsaUJBQWlCO0FBQ25GLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjs7QUFFbkM7O0FBRUE7QUFDQTs7QUFFQSxnRkFBZ0YsZ0JBQWdCO0FBQ2hHOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsNERBQVEsNkRBQTZELHdEQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0dyYXBoLm1qcz9lMWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbmltcG9ydCB7IE1vZGVsIH0gZnJvbSAnLi4vbXZjL01vZGVsLm1qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vbXZjL0NvbGxlY3Rpb24ubWpzJztcbmltcG9ydCB7IHdyYXBwZXJzLCB3cmFwV2l0aCB9IGZyb20gJy4uL3V0aWwvd3JhcHBlcnMubWpzJztcbmltcG9ydCB7IGNsb25lQ2VsbHMgfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbmNvbnN0IEdyYXBoQ2VsbHMgPSBDb2xsZWN0aW9uLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihtb2RlbHMsIG9wdCkge1xuXG4gICAgICAgIC8vIFNldCB0aGUgb3B0aW9uYWwgbmFtZXNwYWNlIHdoZXJlIGFsbCBtb2RlbCBjbGFzc2VzIGFyZSBkZWZpbmVkLlxuICAgICAgICBpZiAob3B0LmNlbGxOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbE5hbWVzcGFjZSA9IG9wdC5jZWxsTmFtZXNwYWNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICAgICAgICAgIHRoaXMuY2VsbE5hbWVzcGFjZSA9IHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgdXRpbC5oYXMoam9pbnQsICdzaGFwZXMnKSA/IGpvaW50LnNoYXBlcyA6IG51bGw7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuZ3JhcGggPSBvcHQuZ3JhcGg7XG4gICAgfSxcblxuICAgIG1vZGVsOiBmdW5jdGlvbihhdHRycywgb3B0KSB7XG5cbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IG9wdC5jb2xsZWN0aW9uO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBjb2xsZWN0aW9uLmNlbGxOYW1lc3BhY2U7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gYXR0cnM7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgbW9kZWwgY2xhc3MgYmFzZWQgb24gdGhlIGB0eXBlYCBhdHRyaWJ1dGUgaW4gdGhlIGNlbGwgbmFtZXNwYWNlXG4gICAgICAgIGNvbnN0IE1vZGVsQ2xhc3MgPSB1dGlsLmdldEJ5UGF0aChuYW1lc3BhY2UsIHR5cGUsICcuJyk7XG4gICAgICAgIGlmICghTW9kZWxDbGFzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWEuR3JhcGg6IENvdWxkIG5vdCBmaW5kIGNlbGwgY29uc3RydWN0b3IgZm9yIHR5cGU6ICcke3R5cGV9Jy4gTWFrZSBzdXJlIHRvIGFkZCB0aGUgY29uc3RydWN0b3IgdG8gJ2NlbGxOYW1lc3BhY2UnLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBNb2RlbENsYXNzKGF0dHJzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBfYWRkUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZS5fYWRkUmVmZXJlbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIC8vIElmIG5vdCBpbiBgZHJ5YCBtb2RlIGFuZCB0aGUgbW9kZWwgZG9lcyBub3QgaGF2ZSBhIGdyYXBoIHJlZmVyZW5jZSB5ZXQsXG4gICAgICAgIC8vIHNldCB0aGUgcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW9wdGlvbnMuZHJ5ICYmICFtb2RlbC5ncmFwaCkge1xuICAgICAgICAgICAgbW9kZWwuZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlLl9yZW1vdmVSZWZlcmVuY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gSWYgbm90IGluIGBkcnlgIG1vZGUgYW5kIHRoZSBtb2RlbCBoYXMgYSByZWZlcmVuY2UgdG8gdGhpcyBleGFjdCBncmFwaCxcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSByZWZlcmVuY2UuXG4gICAgICAgIGlmICghb3B0aW9ucy5kcnkgJiYgbW9kZWwuZ3JhcGggPT09IHRoaXMuZ3JhcGgpIHtcbiAgICAgICAgICAgIG1vZGVsLmdyYXBoID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBgY29tcGFyYXRvcmAgbWFrZXMgaXQgZWFzeSB0byBzb3J0IGNlbGxzIGJhc2VkIG9uIHRoZWlyIGB6YCBpbmRleC5cbiAgICBjb21wYXJhdG9yOiBmdW5jdGlvbihtb2RlbCkge1xuXG4gICAgICAgIHJldHVybiBtb2RlbC5nZXQoJ3onKSB8fCAwO1xuICAgIH1cbn0pO1xuXG5cbmV4cG9ydCBjb25zdCBHcmFwaCA9IE1vZGVsLmV4dGVuZCh7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRycywgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIC8vIFBhc3NpbmcgYGNlbGxNb2RlbGAgZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHRvIGdyYXBoIGFsbG93cyBmb3JcbiAgICAgICAgLy8gc2V0dGluZyBtb2RlbHMgYmFzZWQgb24gYXR0cmlidXRlIG9iamVjdHMuIFRoaXMgaXMgZXNwZWNpYWxseSBoYW5keVxuICAgICAgICAvLyB3aGVuIHByb2Nlc3NpbmcgSlNPTiBncmFwaHMgdGhhdCBhcmUgaW4gYSBkaWZmZXJlbnQgdGhhbiBKb2ludEpTIGZvcm1hdC5cbiAgICAgICAgdmFyIGNlbGxzID0gbmV3IEdyYXBoQ2VsbHMoW10sIHtcbiAgICAgICAgICAgIG1vZGVsOiBvcHQuY2VsbE1vZGVsLFxuICAgICAgICAgICAgY2VsbE5hbWVzcGFjZTogb3B0LmNlbGxOYW1lc3BhY2UsXG4gICAgICAgICAgICBncmFwaDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgTW9kZWwucHJvdG90eXBlLnNldC5jYWxsKHRoaXMsICdjZWxscycsIGNlbGxzKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCB0aGUgZXZlbnRzIGZpcmVkIGluIHRoZSBgY2VsbHNgIGNvbGxlY3Rpb24gYXZhaWxhYmxlLlxuICAgICAgICAvLyB0byB0aGUgb3V0c2lkZSB3b3JsZC5cbiAgICAgICAgY2VsbHMub24oJ2FsbCcsIHRoaXMudHJpZ2dlciwgdGhpcyk7XG5cbiAgICAgICAgLy8gSm9pbnRKUyBhdXRvbWF0aWNhbGx5IGRvZXNuJ3QgdHJpZ2dlciByZS1zb3J0IGlmIG1vZGVscyBhdHRyaWJ1dGVzIGFyZSBjaGFuZ2VkIGxhdGVyIHdoZW5cbiAgICAgICAgLy8gdGhleSdyZSBhbHJlYWR5IGluIHRoZSBjb2xsZWN0aW9uLiBUaGVyZWZvcmUsIHdlJ3JlIHRyaWdnZXJpbmcgc29ydCBtYW51YWxseSBoZXJlLlxuICAgICAgICB0aGlzLm9uKCdjaGFuZ2U6eicsIHRoaXMuX3NvcnRPbkNoYW5nZVosIHRoaXMpO1xuXG4gICAgICAgIC8vIGBqb2ludC5kaWEuR3JhcGhgIGtlZXBzIGFuIGludGVybmFsIGRhdGEgc3RydWN0dXJlIChhbiBhZGphY2VuY3kgbGlzdClcbiAgICAgICAgLy8gZm9yIGZhc3QgZ3JhcGggcXVlcmllcy4gQWxsIGNoYW5nZXMgdGhhdCBhZmZlY3QgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ3JhcGhcbiAgICAgICAgLy8gbXVzdCBiZSByZWZsZWN0ZWQgaW4gdGhlIGBhbGAgb2JqZWN0LiBUaGlzIG9iamVjdCBwcm92aWRlcyBmYXN0IGFuc3dlcnMgdG9cbiAgICAgICAgLy8gcXVlc3Rpb25zIHN1Y2ggYXMgXCJ3aGF0IGFyZSB0aGUgbmVpZ2hib3VycyBvZiB0aGlzIG5vZGVcIiBvciBcIndoYXRcbiAgICAgICAgLy8gYXJlIHRoZSBzaWJsaW5nIGxpbmtzIG9mIHRoaXMgbGlua1wiLlxuXG4gICAgICAgIC8vIE91dGdvaW5nIGVkZ2VzIHBlciBub2RlLiBOb3RlIHRoYXQgd2UgdXNlIGEgaGFzaC10YWJsZSBmb3IgdGhlIGxpc3RcbiAgICAgICAgLy8gb2Ygb3V0Z29pbmcgZWRnZXMgZm9yIGEgZmFzdGVyIGxvb2t1cC5cbiAgICAgICAgLy8gW25vZGVJZF0gLT4gT2JqZWN0IFtlZGdlSWRdIC0+IHRydWVcbiAgICAgICAgdGhpcy5fb3V0ID0ge307XG4gICAgICAgIC8vIEluZ29pbmcgZWRnZXMgcGVyIG5vZGUuXG4gICAgICAgIC8vIFtub2RlSWRdIC0+IE9iamVjdCBbZWRnZUlkXSAtPiB0cnVlXG4gICAgICAgIHRoaXMuX2luID0ge307XG4gICAgICAgIC8vIGBfbm9kZXNgIGlzIHVzZWZ1bCBmb3IgcXVpY2sgbG9va3VwIG9mIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlIGdyYXBoLCB3aXRob3V0XG4gICAgICAgIC8vIGhhdmluZyB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSBjZWxscyBhcnJheS5cbiAgICAgICAgLy8gW25vZGUgSURdIC0+IHRydWVcbiAgICAgICAgdGhpcy5fbm9kZXMgPSB7fTtcbiAgICAgICAgLy8gYF9lZGdlc2AgaXMgdXNlZnVsIGZvciBxdWljayBsb29rdXAgb2YgYWxsIHRoZSBsaW5rcyBpbiB0aGUgZ3JhcGgsIHdpdGhvdXRcbiAgICAgICAgLy8gaGF2aW5nIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIGNlbGxzIGFycmF5LlxuICAgICAgICAvLyBbZWRnZUlkXSAtPiB0cnVlXG4gICAgICAgIHRoaXMuX2VkZ2VzID0ge307XG5cbiAgICAgICAgdGhpcy5fYmF0Y2hlcyA9IHt9O1xuXG4gICAgICAgIGNlbGxzLm9uKCdhZGQnLCB0aGlzLl9yZXN0cnVjdHVyZU9uQWRkLCB0aGlzKTtcbiAgICAgICAgY2VsbHMub24oJ3JlbW92ZScsIHRoaXMuX3Jlc3RydWN0dXJlT25SZW1vdmUsIHRoaXMpO1xuICAgICAgICBjZWxscy5vbigncmVzZXQnLCB0aGlzLl9yZXN0cnVjdHVyZU9uUmVzZXQsIHRoaXMpO1xuICAgICAgICBjZWxscy5vbignY2hhbmdlOnNvdXJjZScsIHRoaXMuX3Jlc3RydWN0dXJlT25DaGFuZ2VTb3VyY2UsIHRoaXMpO1xuICAgICAgICBjZWxscy5vbignY2hhbmdlOnRhcmdldCcsIHRoaXMuX3Jlc3RydWN0dXJlT25DaGFuZ2VUYXJnZXQsIHRoaXMpO1xuICAgICAgICBjZWxscy5vbigncmVtb3ZlJywgdGhpcy5fcmVtb3ZlQ2VsbCwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9zb3J0T25DaGFuZ2VaOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmdldCgnY2VsbHMnKS5zb3J0KCk7XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uQWRkOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICAgICAgaWYgKGNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VkZ2VzW2NlbGwuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBjZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBpZiAoc291cmNlLmlkKSB7XG4gICAgICAgICAgICAgICAgKHRoaXMuX291dFtzb3VyY2UuaWRdIHx8ICh0aGlzLl9vdXRbc291cmNlLmlkXSA9IHt9KSlbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5pZCkge1xuICAgICAgICAgICAgICAgICh0aGlzLl9pblt0YXJnZXQuaWRdIHx8ICh0aGlzLl9pblt0YXJnZXQuaWRdID0ge30pKVtjZWxsLmlkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ub2Rlc1tjZWxsLmlkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Jlc3RydWN0dXJlT25SZW1vdmU6IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICBpZiAoY2VsbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2VkZ2VzW2NlbGwuaWRdO1xuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGNlbGwuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgJiYgdGhpcy5fb3V0W3NvdXJjZS5pZF0gJiYgdGhpcy5fb3V0W3NvdXJjZS5pZF1bY2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb3V0W3NvdXJjZS5pZF1bY2VsbC5pZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmlkICYmIHRoaXMuX2luW3RhcmdldC5pZF0gJiYgdGhpcy5faW5bdGFyZ2V0LmlkXVtjZWxsLmlkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pblt0YXJnZXQuaWRdW2NlbGwuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX25vZGVzW2NlbGwuaWRdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uUmVzZXQ6IGZ1bmN0aW9uKGNlbGxzKSB7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIGludG8gYW4gYXJyYXkgb2YgY2VsbHMuIFRoZSBvcmlnaW5hbCBgY2VsbHNgIGlzIEdyYXBoQ2VsbHMgbXZjIGNvbGxlY3Rpb24uXG4gICAgICAgIGNlbGxzID0gY2VsbHMubW9kZWxzO1xuXG4gICAgICAgIHRoaXMuX291dCA9IHt9O1xuICAgICAgICB0aGlzLl9pbiA9IHt9O1xuICAgICAgICB0aGlzLl9ub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLl9lZGdlcyA9IHt9O1xuXG4gICAgICAgIGNlbGxzLmZvckVhY2godGhpcy5fcmVzdHJ1Y3R1cmVPbkFkZCwgdGhpcyk7XG4gICAgfSxcblxuICAgIF9yZXN0cnVjdHVyZU9uQ2hhbmdlU291cmNlOiBmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgdmFyIHByZXZTb3VyY2UgPSBsaW5rLnByZXZpb3VzKCdzb3VyY2UnKTtcbiAgICAgICAgaWYgKHByZXZTb3VyY2UuaWQgJiYgdGhpcy5fb3V0W3ByZXZTb3VyY2UuaWRdKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fb3V0W3ByZXZTb3VyY2UuaWRdW2xpbmsuaWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSBsaW5rLmF0dHJpYnV0ZXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLmlkKSB7XG4gICAgICAgICAgICAodGhpcy5fb3V0W3NvdXJjZS5pZF0gfHwgKHRoaXMuX291dFtzb3VyY2UuaWRdID0ge30pKVtsaW5rLmlkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Jlc3RydWN0dXJlT25DaGFuZ2VUYXJnZXQ6IGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICB2YXIgcHJldlRhcmdldCA9IGxpbmsucHJldmlvdXMoJ3RhcmdldCcpO1xuICAgICAgICBpZiAocHJldlRhcmdldC5pZCAmJiB0aGlzLl9pbltwcmV2VGFyZ2V0LmlkXSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luW3ByZXZUYXJnZXQuaWRdW2xpbmsuaWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXQgPSBsaW5rLmdldCgndGFyZ2V0Jyk7XG4gICAgICAgIGlmICh0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICh0aGlzLl9pblt0YXJnZXQuaWRdIHx8ICh0aGlzLl9pblt0YXJnZXQuaWRdID0ge30pKVtsaW5rLmlkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGFsbCBvdXRib3VuZCBlZGdlcyBmb3IgdGhlIG5vZGUuIFJldHVybiB2YWx1ZSBpcyBhbiBvYmplY3RcbiAgICAvLyBvZiB0aGUgZm9ybTogW2VkZ2VJZF0gLT4gdHJ1ZVxuICAgIGdldE91dGJvdW5kRWRnZXM6IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX291dCAmJiB0aGlzLl9vdXRbbm9kZV0pIHx8IHt9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYWxsIGluYm91bmQgZWRnZXMgZm9yIHRoZSBub2RlLiBSZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgLy8gb2YgdGhlIGZvcm06IFtlZGdlSWRdIC0+IHRydWVcbiAgICBnZXRJbmJvdW5kRWRnZXM6IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgICAgICByZXR1cm4gKHRoaXMuX2luICYmIHRoaXMuX2luW25vZGVdKSB8fCB7fTtcbiAgICB9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHQgPSB7fSkge1xuXG4gICAgICAgIC8vIEpvaW50SlMgZG9lcyBub3QgcmVjdXJzaXZlbHkgY2FsbCBgdG9KU09OKClgIG9uIGF0dHJpYnV0ZXMgdGhhdCBhcmUgdGhlbXNlbHZlcyBtb2RlbHMvY29sbGVjdGlvbnMuXG4gICAgICAgIC8vIEl0IGp1c3QgY2xvbmVzIHRoZSBhdHRyaWJ1dGVzLiBUaGVyZWZvcmUsIHdlIG11c3QgY2FsbCBgdG9KU09OKClgIG9uIHRoZSBjZWxscyBjb2xsZWN0aW9uIGV4cGxpY2l0bHkuXG4gICAgICAgIHZhciBqc29uID0gTW9kZWwucHJvdG90eXBlLnRvSlNPTi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBqc29uLmNlbGxzID0gdGhpcy5nZXQoJ2NlbGxzJykudG9KU09OKG9wdC5jZWxsQXR0cmlidXRlcyk7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24oanNvbiwgb3B0KSB7XG5cbiAgICAgICAgaWYgKCFqc29uLmNlbGxzKSB7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR3JhcGggSlNPTiBtdXN0IGNvbnRhaW4gY2VsbHMgYXJyYXkuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoanNvbiwgb3B0KTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGF0dHJzO1xuXG4gICAgICAgIC8vIEhhbmRsZSBib3RoIGBrZXlgLCB2YWx1ZSBhbmQge2tleTogdmFsdWV9IHN0eWxlIGFyZ3VtZW50cy5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgICAgIG9wdCA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYGNlbGxzYCBhdHRyaWJ1dGUgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IHZpYSByZXNldENlbGxzKCkuXG4gICAgICAgIGlmIChhdHRycy5oYXNPd25Qcm9wZXJ0eSgnY2VsbHMnKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldENlbGxzKGF0dHJzLmNlbGxzLCBvcHQpO1xuICAgICAgICAgICAgYXR0cnMgPSB1dGlsLm9taXQoYXR0cnMsICdjZWxscycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlc3Qgb2YgdGhlIGF0dHJpYnV0ZXMgYXJlIGFwcGxpZWQgdmlhIG9yaWdpbmFsIHNldCBtZXRob2QuXG4gICAgICAgIHJldHVybiBNb2RlbC5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgYXR0cnMsIG9wdCk7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSB1dGlsLmFzc2lnbih7fSwgb3B0LCB7IGNsZWFyOiB0cnVlIH0pO1xuXG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5nZXQoJ2NlbGxzJyk7XG5cbiAgICAgICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goJ2NsZWFyJywgb3B0KTtcblxuICAgICAgICAvLyBUaGUgZWxlbWVudHMgY29tZSBhZnRlciB0aGUgbGlua3MuXG4gICAgICAgIHZhciBjZWxscyA9IGNvbGxlY3Rpb24uc29ydEJ5KGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsLmlzTGluaygpID8gMSA6IDI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvIHtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCB0aGUgY2VsbHMgb25lIGJ5IG9uZS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBhbGwgdGhlIGxpbmtzIGFyZSByZW1vdmVkIGZpcnN0LCBzbyBpdCdzXG4gICAgICAgICAgICAvLyBzYWZlIHRvIHJlbW92ZSB0aGUgZWxlbWVudHMgd2l0aG91dCByZW1vdmluZyB0aGUgY29ubmVjdGVkXG4gICAgICAgICAgICAvLyBsaW5rcyBmaXJzdC5cbiAgICAgICAgICAgIGNlbGxzLnNoaWZ0KCkucmVtb3ZlKG9wdCk7XG5cbiAgICAgICAgfSB3aGlsZSAoY2VsbHMubGVuZ3RoID4gMCk7XG5cbiAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ2NsZWFyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9wcmVwYXJlQ2VsbDogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIGxldCBhdHRycztcbiAgICAgICAgaWYgKGNlbGwgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgYXR0cnMgPSBjZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRycyA9IGNlbGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcoYXR0cnMudHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5HcmFwaDogY2VsbCB0eXBlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgbWluWkluZGV4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZmlyc3RDZWxsID0gdGhpcy5nZXQoJ2NlbGxzJykuZmlyc3QoKTtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2VsbCA/IChmaXJzdENlbGwuZ2V0KCd6JykgfHwgMCkgOiAwO1xuICAgIH0sXG5cbiAgICBtYXhaSW5kZXg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBsYXN0Q2VsbCA9IHRoaXMuZ2V0KCdjZWxscycpLmxhc3QoKTtcbiAgICAgICAgcmV0dXJuIGxhc3RDZWxsID8gKGxhc3RDZWxsLmdldCgneicpIHx8IDApIDogMDtcbiAgICB9LFxuXG4gICAgYWRkQ2VsbDogZnVuY3Rpb24oY2VsbCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ2VsbHMoY2VsbCwgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgTW9kZWwpIHtcblxuICAgICAgICAgICAgaWYgKCFjZWxsLmhhcygneicpKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5zZXQoJ3onLCB0aGlzLm1heFpJbmRleCgpICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChjZWxsLnogPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBjZWxsLnogPSB0aGlzLm1heFpJbmRleCgpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0KCdjZWxscycpLmFkZCh0aGlzLl9wcmVwYXJlQ2VsbChjZWxsLCBvcHQpLCBvcHQgfHwge30pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRDZWxsczogZnVuY3Rpb24oY2VsbHMsIG9wdCkge1xuXG4gICAgICAgIGlmIChjZWxscy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGNlbGxzID0gdXRpbC5mbGF0dGVuRGVlcChjZWxscyk7XG4gICAgICAgIG9wdC5tYXhQb3NpdGlvbiA9IG9wdC5wb3NpdGlvbiA9IGNlbGxzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdhZGQnLCBvcHQpO1xuICAgICAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2VsbChjZWxsLCBvcHQpO1xuICAgICAgICAgICAgb3B0LnBvc2l0aW9uLS07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB0aGlzLnN0b3BCYXRjaCgnYWRkJywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gV2hlbiBhZGRpbmcgYSBsb3Qgb2YgY2VsbHMsIGl0IGlzIG11Y2ggbW9yZSBlZmZpY2llbnQgdG9cbiAgICAvLyByZXNldCB0aGUgZW50aXJlIGNlbGxzIGNvbGxlY3Rpb24gaW4gb25lIGdvLlxuICAgIC8vIFVzZWZ1bCBmb3IgYnVsayBvcGVyYXRpb25zIGFuZCBvcHRpbWl6YXRpb25zLlxuICAgIHJlc2V0Q2VsbHM6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICB2YXIgcHJlcGFyZWRDZWxscyA9IHV0aWwudG9BcnJheShjZWxscykubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVwYXJlQ2VsbChjZWxsLCBvcHQpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdGhpcy5nZXQoJ2NlbGxzJykucmVzZXQocHJlcGFyZWRDZWxscywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2VsbHM6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnRCYXRjaCgncmVtb3ZlJyk7XG4gICAgICAgICAgICB1dGlsLmludm9rZShjZWxscywgJ3JlbW92ZScsIG9wdCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BCYXRjaCgncmVtb3ZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX3JlbW92ZUNlbGw6IGZ1bmN0aW9uKGNlbGwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuY2xlYXIpIHtcbiAgICAgICAgICAgIC8vIEFwcGxpY2F0aW9ucyBtaWdodCBwcm92aWRlIGEgYGRpc2Nvbm5lY3RMaW5rc2Agb3B0aW9uIHNldCB0byBgdHJ1ZWAgaW4gb3JkZXIgdG9cbiAgICAgICAgICAgIC8vIGRpc2Nvbm5lY3QgbGlua3Mgd2hlbiBhIGNlbGwgaXMgcmVtb3ZlZCByYXRoZXIgdGhlbiByZW1vdmluZyB0aGVtLiBUaGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gaXMgdG8gcmVtb3ZlIGFsbCB0aGUgYXNzb2NpYXRlZCBsaW5rcy5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc2Nvbm5lY3RMaW5rcykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlua3MoY2VsbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmtzKGNlbGwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNpbGVudGx5IHJlbW92ZSB0aGUgY2VsbCBmcm9tIHRoZSBjZWxscyBjb2xsZWN0aW9uLiBTaWxlbnRseSwgYmVjYXVzZVxuICAgICAgICAvLyBgam9pbnQuZGlhLkNlbGwucHJvdG90eXBlLnJlbW92ZWAgYWxyZWFkeSB0cmlnZ2VycyB0aGUgYHJlbW92ZWAgZXZlbnQgd2hpY2ggaXNcbiAgICAgICAgLy8gdGhlbiBwcm9wYWdhdGVkIHRvIHRoZSBncmFwaCBtb2RlbC4gSWYgd2UgZGlkbid0IHJlbW92ZSB0aGUgY2VsbCBzaWxlbnRseSwgdHdvIGByZW1vdmVgIGV2ZW50c1xuICAgICAgICAvLyB3b3VsZCBiZSB0cmlnZ2VyZWQgb24gdGhlIGdyYXBoIG1vZGVsLlxuICAgICAgICB0aGlzLmdldCgnY2VsbHMnKS5yZW1vdmUoY2VsbCwgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgfSxcblxuICAgIHRyYW5zZmVyQ2VsbEVtYmVkczogZnVuY3Rpb24oc291cmNlQ2VsbCwgdGFyZ2V0Q2VsbCwgb3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCBiYXRjaE5hbWUgPSAndHJhbnNmZXItZW1iZWRzJztcbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKGJhdGNoTmFtZSk7XG5cbiAgICAgICAgLy8gRW1iZWQgY2hpbGRyZW4gb2YgdGhlIHNvdXJjZSBjZWxsIGluIHRoZSB0YXJnZXQgY2VsbC5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzb3VyY2VDZWxsLmdldEVtYmVkZGVkQ2VsbHMoKTtcbiAgICAgICAgdGFyZ2V0Q2VsbC5lbWJlZChjaGlsZHJlbiwgeyAuLi5vcHQsIHJlcGFyZW50OiB0cnVlIH0pO1xuXG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKGJhdGNoTmFtZSk7XG4gICAgfSxcblxuICAgIHRyYW5zZmVyQ2VsbENvbm5lY3RlZExpbmtzOiBmdW5jdGlvbihzb3VyY2VDZWxsLCB0YXJnZXRDZWxsLCBvcHQgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGJhdGNoTmFtZSA9ICd0cmFuc2Zlci1jb25uZWN0ZWQtbGlua3MnO1xuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2goYmF0Y2hOYW1lKTtcblxuICAgICAgICAvLyBSZWNvbm5lY3QgYWxsIHRoZSBsaW5rcyBjb25uZWN0ZWQgdG8gdGhlIG9sZCBjZWxsIHRvIHRoZSBuZXcgY2VsbC5cbiAgICAgICAgY29uc3QgY29ubmVjdGVkTGlua3MgPSB0aGlzLmdldENvbm5lY3RlZExpbmtzKHNvdXJjZUNlbGwsIG9wdCk7XG4gICAgICAgIGNvbm5lY3RlZExpbmtzLmZvckVhY2goKGxpbmspID0+IHtcblxuICAgICAgICAgICAgaWYgKGxpbmsuZ2V0U291cmNlQ2VsbCgpID09PSBzb3VyY2VDZWxsKSB7XG4gICAgICAgICAgICAgICAgbGluay5wcm9wKFsnc291cmNlJywgJ2lkJ10sIHRhcmdldENlbGwuaWQsIG9wdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW5rLmdldFRhcmdldENlbGwoKSA9PT0gc291cmNlQ2VsbCkge1xuICAgICAgICAgICAgICAgIGxpbmsucHJvcChbJ3RhcmdldCcsICdpZCddLCB0YXJnZXRDZWxsLmlkLCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnN0b3BCYXRjaChiYXRjaE5hbWUpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYSBjZWxsIGJ5IGBpZGAuXG4gICAgZ2V0Q2VsbDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NlbGxzJykuZ2V0KGlkKTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS50b0FycmF5KCk7XG4gICAgfSxcblxuICAgIGdldEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NlbGxzJykudG9BcnJheSgpLmZpbHRlcihjZWxsID0+IGNlbGwuaXNFbGVtZW50KCkpO1xuICAgIH0sXG5cbiAgICBnZXRMaW5rczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdjZWxscycpLnRvQXJyYXkoKS5maWx0ZXIoY2VsbCA9PiBjZWxsLmlzTGluaygpKTtcbiAgICB9LFxuXG4gICAgZ2V0Rmlyc3RDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoJ2NlbGxzJykuZmlyc3QoKTtcbiAgICB9LFxuXG4gICAgZ2V0TGFzdENlbGw6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnY2VsbHMnKS5sYXN0KCk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbGwgaW5ib3VuZCBhbmQgb3V0Ym91bmQgbGlua3MgY29ubmVjdGVkIHRvIHRoZSBjZWxsIGBtb2RlbGAuXG4gICAgZ2V0Q29ubmVjdGVkTGlua3M6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIGluZGlyZWN0ID0gb3B0LmluZGlyZWN0O1xuICAgICAgICB2YXIgaW5ib3VuZCA9IG9wdC5pbmJvdW5kO1xuICAgICAgICB2YXIgb3V0Ym91bmQgPSBvcHQub3V0Ym91bmQ7XG4gICAgICAgIGlmICgoaW5ib3VuZCA9PT0gdW5kZWZpbmVkKSAmJiAob3V0Ym91bmQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGluYm91bmQgPSBvdXRib3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZmluYWwgYXJyYXkgb2YgY29ubmVjdGVkIGxpbmsgbW9kZWxzXG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICAvLyBhIGhhc2ggdGFibGUgb2YgY29ubmVjdGVkIGVkZ2VzIG9mIHRoZSBmb3JtOiBbZWRnZUlkXSAtPiB0cnVlXG4gICAgICAgIC8vIHVzZWQgZm9yIHF1aWNrIGxvb2t1cHMgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSBhZGRlZCBhIGxpbmtcbiAgICAgICAgdmFyIGVkZ2VzID0ge307XG5cbiAgICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgICAgICBhZGRPdXRib3VuZHModGhpcywgbW9kZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmJvdW5kKSB7XG4gICAgICAgICAgICBhZGRJbmJvdW5kcyh0aGlzLCBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRPdXRib3VuZHMoZ3JhcGgsIG1vZGVsKSB7XG4gICAgICAgICAgICB1dGlsLmZvckluKGdyYXBoLmdldE91dGJvdW5kRWRnZXMobW9kZWwuaWQpLCBmdW5jdGlvbihfLCBlZGdlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBsaW5rcyB0aGF0IHdlcmUgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgICAgIC8vICh0aG9zZSBtdXN0IGJlIHNlbGYtbG9vcCBsaW5rcylcbiAgICAgICAgICAgICAgICAvLyAoYmVjYXVzZSB0aGV5IGFyZSBpbmJvdW5kIGFuZCBvdXRib3VuZCBlZGdlcyBvZiB0aGUgc2FtZSB0d28gZWxlbWVudHMpXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2VkZ2VdKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSBncmFwaC5nZXRDZWxsKGVkZ2UpO1xuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgZWRnZXNbZWRnZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5ib3VuZCkgYWRkSW5ib3VuZHMoZ3JhcGgsIGxpbmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpIGFkZE91dGJvdW5kcyhncmFwaCwgbGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKGdyYXBoKSk7XG4gICAgICAgICAgICBpZiAoaW5kaXJlY3QgJiYgbW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Q2VsbCA9IG1vZGVsLmdldFRhcmdldENlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0Q2VsbCAmJiBvdXRDZWxsLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWRnZXNbb3V0Q2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gob3V0Q2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPdXRib3VuZHMoZ3JhcGgsIG91dENlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkSW5ib3VuZHMoZ3JhcGgsIG1vZGVsKSB7XG4gICAgICAgICAgICB1dGlsLmZvckluKGdyYXBoLmdldEluYm91bmRFZGdlcyhtb2RlbC5pZCksIGZ1bmN0aW9uKF8sIGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGxpbmtzIHRoYXQgd2VyZSBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICAgICAgLy8gKHRob3NlIG11c3QgYmUgc2VsZi1sb29wIGxpbmtzKVxuICAgICAgICAgICAgICAgIC8vIChiZWNhdXNlIHRoZXkgYXJlIGluYm91bmQgYW5kIG91dGJvdW5kIGVkZ2VzIG9mIHRoZSBzYW1lIHR3byBlbGVtZW50cylcbiAgICAgICAgICAgICAgICBpZiAoZWRnZXNbZWRnZV0pIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IGdyYXBoLmdldENlbGwoZWRnZSk7XG4gICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICBlZGdlc1tlZGdlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGluZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJvdW5kKSBhZGRJbmJvdW5kcyhncmFwaCwgbGluayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRib3VuZCkgYWRkT3V0Ym91bmRzKGdyYXBoLCBsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQoZ3JhcGgpKTtcbiAgICAgICAgICAgIGlmIChpbmRpcmVjdCAmJiBtb2RlbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbkNlbGwgPSBtb2RlbC5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKGluQ2VsbCAmJiBpbkNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGdlc1tpbkNlbGwuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGluQ2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJbmJvdW5kcyhncmFwaCwgaW5DZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGBkZWVwYCBvcHRpb24gaXMgYHRydWVgLCBjaGVjayBhbHNvIGFsbCB0aGUgbGlua3MgdGhhdCBhcmUgY29ubmVjdGVkIHRvIGFueSBvZiB0aGUgZGVzY2VuZGFudCBjZWxsc1xuICAgICAgICBpZiAob3B0LmRlZXApIHtcblxuICAgICAgICAgICAgdmFyIGVtYmVkZGVkQ2VsbHMgPSBtb2RlbC5nZXRFbWJlZGRlZENlbGxzKHsgZGVlcDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIGZpcnN0IHJvdW5kLCB3ZSBjb2xsZWN0IGFsbCB0aGUgZW1iZWRkZWQgZWxlbWVudHNcbiAgICAgICAgICAgIHZhciBlbWJlZGRlZEVsZW1lbnRzID0ge307XG4gICAgICAgICAgICBlbWJlZGRlZENlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtYmVkZGVkRWxlbWVudHNbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbWJlZGRlZENlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjZWxsLmlzTGluaygpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZm9ySW4odGhpcy5nZXRPdXRib3VuZEVkZ2VzKGNlbGwuaWQpLCBmdW5jdGlvbihleGlzdHMsIGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZWRnZXNbZWRnZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZUNlbGwgPSB0aGlzLmdldENlbGwoZWRnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGVkZ2VDZWxsLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gc291cmNlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJZCA9IHRhcmdldC5pZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGBpbmNsdWRlRW5jbG9zZWRgIG9wdGlvbiBpcyBmYWxzeSwgc2tpcCBlbmNsb3NlZCBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0LmluY2x1ZGVFbmNsb3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc291cmNlSWQgJiYgZW1iZWRkZWRFbGVtZW50c1tzb3VyY2VJZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0YXJnZXRJZCAmJiBlbWJlZGRlZEVsZW1lbnRzW3RhcmdldElkXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtzLnB1c2godGhpcy5nZXRDZWxsKGVkZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1tlZGdlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuZm9ySW4odGhpcy5nZXRJbmJvdW5kRWRnZXMoY2VsbC5pZCksIGZ1bmN0aW9uKGV4aXN0cywgZWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGdlc1tlZGdlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlQ2VsbCA9IHRoaXMuZ2V0Q2VsbChlZGdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gZWRnZUNlbGwuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSWQgPSBzb3VyY2UuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldElkID0gdGFyZ2V0LmlkO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgYGluY2x1ZGVFbmNsb3NlZGAgb3B0aW9uIGlzIGZhbHN5LCBza2lwIGVuY2xvc2VkIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHQuaW5jbHVkZUVuY2xvc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChzb3VyY2VJZCAmJiBlbWJlZGRlZEVsZW1lbnRzW3NvdXJjZUlkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHRhcmdldElkICYmIGVtYmVkZGVkRWxlbWVudHNbdGFyZ2V0SWRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaCh0aGlzLmdldENlbGwoZWRnZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzW2VkZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5rcztcbiAgICB9LFxuXG4gICAgZ2V0TmVpZ2hib3JzOiBmdW5jdGlvbihtb2RlbCwgb3B0KSB7XG5cbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgdmFyIGluYm91bmQgPSBvcHQuaW5ib3VuZDtcbiAgICAgICAgdmFyIG91dGJvdW5kID0gb3B0Lm91dGJvdW5kO1xuICAgICAgICBpZiAoaW5ib3VuZCA9PT0gdW5kZWZpbmVkICYmIG91dGJvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluYm91bmQgPSBvdXRib3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhtb2RlbCwgb3B0KS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBsaW5rKSB7XG5cbiAgICAgICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBsaW5rLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICB2YXIgbG9vcCA9IGxpbmsuaGFzTG9vcChvcHQpO1xuXG4gICAgICAgICAgICAvLyBEaXNjYXJkIGlmIGl0IGlzIGEgcG9pbnQsIG9yIGlmIHRoZSBuZWlnaGJvciB3YXMgYWxyZWFkeSBhZGRlZC5cbiAgICAgICAgICAgIGlmIChpbmJvdW5kICYmIHV0aWwuaGFzKHNvdXJjZSwgJ2lkJykgJiYgIXJlc1tzb3VyY2UuaWRdKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRWxlbWVudCA9IHRoaXMuZ2V0Q2VsbChzb3VyY2UuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29wIHx8IChzb3VyY2VFbGVtZW50ICYmIHNvdXJjZUVsZW1lbnQgIT09IG1vZGVsICYmICghb3B0LmRlZXAgfHwgIXNvdXJjZUVsZW1lbnQuaXNFbWJlZGRlZEluKG1vZGVsKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbc291cmNlLmlkXSA9IHNvdXJjZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgaXQgaXMgYSBwb2ludCwgb3IgaWYgdGhlIG5laWdoYm9yIHdhcyBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHV0aWwuaGFzKHRhcmdldCwgJ2lkJykgJiYgIXJlc1t0YXJnZXQuaWRdKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0Q2VsbCh0YXJnZXQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LmlzRWxlbWVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29wIHx8ICh0YXJnZXRFbGVtZW50ICYmIHRhcmdldEVsZW1lbnQgIT09IG1vZGVsICYmICghb3B0LmRlZXAgfHwgIXRhcmdldEVsZW1lbnQuaXNFbWJlZGRlZEluKG1vZGVsKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbdGFyZ2V0LmlkXSA9IHRhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0uYmluZCh0aGlzKSwge30pO1xuXG4gICAgICAgIGlmIChtb2RlbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgaWYgKGluYm91bmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ2VsbCA9IG1vZGVsLmdldFNvdXJjZUNlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlQ2VsbCAmJiBzb3VyY2VDZWxsLmlzRWxlbWVudCgpICYmICFuZWlnaGJvcnNbc291cmNlQ2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzW3NvdXJjZUNlbGwuaWRdID0gc291cmNlQ2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0Ym91bmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2VsbCA9IG1vZGVsLmdldFRhcmdldENlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Q2VsbCAmJiB0YXJnZXRDZWxsLmlzRWxlbWVudCgpICYmICFuZWlnaGJvcnNbdGFyZ2V0Q2VsbC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzW3RhcmdldENlbGwuaWRdID0gdGFyZ2V0Q2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC50b0FycmF5KG5laWdoYm9ycyk7XG4gICAgfSxcblxuICAgIGdldENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbigvKiBjZWxscyAqLykge1xuXG4gICAgICAgIHZhciBjZWxsc0FuY2VzdG9ycyA9IEFycmF5LmZyb20oYXJndW1lbnRzKS5tYXAoZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgICAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBjZWxsLmdldCgncGFyZW50Jyk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRJZCkge1xuXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50SWQpO1xuICAgICAgICAgICAgICAgIHBhcmVudElkID0gdGhpcy5nZXRDZWxsKHBhcmVudElkKS5nZXQoJ3BhcmVudCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5jZXN0b3JzO1xuXG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGNlbGxzQW5jZXN0b3JzID0gY2VsbHNBbmNlc3RvcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNvbW1vbkFuY2VzdG9yID0gdXRpbC50b0FycmF5KGNlbGxzQW5jZXN0b3JzLnNoaWZ0KCkpLmZpbmQoZnVuY3Rpb24oYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjZWxsc0FuY2VzdG9ycy5ldmVyeShmdW5jdGlvbihjZWxsQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxBbmNlc3RvcnMuaW5jbHVkZXMoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGwoY29tbW9uQW5jZXN0b3IpO1xuICAgIH0sXG5cbiAgICAvLyBGaW5kIHRoZSB3aG9sZSBicmFuY2ggc3RhcnRpbmcgYXQgYGVsZW1lbnRgLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gSWYgYG9wdC5icmVhZHRoRmlyc3RgIGlzIGB0cnVlYCwgdXNlIHRoZSBCcmVhZHRoLWZpcnN0IHNlYXJjaCBhbGdvcml0aG0sIG90aGVyd2lzZSB1c2UgRGVwdGgtZmlyc3Qgc2VhcmNoLlxuICAgIGdldFN1Y2Nlc3NvcnM6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAvLyBNb2RpZnkgdGhlIG9wdGlvbnMgc28gdGhhdCBpdCBpbmNsdWRlcyB0aGUgYG91dGJvdW5kYCBuZWlnaGJvcnMgb25seS4gSW4gb3RoZXIgd29yZHMsIHNlYXJjaCBmb3J3YXJkcy5cbiAgICAgICAgdGhpcy5zZWFyY2goZWxlbWVudCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXRpbC5hc3NpZ24oe30sIG9wdCwgeyBvdXRib3VuZDogdHJ1ZSB9KSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcblxuICAgIGNsb25lQ2VsbHM6IGNsb25lQ2VsbHMsXG4gICAgLy8gQ2xvbmUgdGhlIHdob2xlIHN1YmdyYXBoIChpbmNsdWRpbmcgYWxsIHRoZSBjb25uZWN0ZWQgbGlua3Mgd2hvc2Ugc291cmNlL3RhcmdldCBpcyBpbiB0aGUgc3ViZ3JhcGgpLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCBhbHNvIHRha2UgaW50byBhY2NvdW50IGFsbCB0aGUgZW1iZWRkZWQgY2VsbHMgb2YgYWxsIHRoZSBzdWJncmFwaCBjZWxscy5cbiAgICAvLyBSZXR1cm4gYSBtYXAgb2YgdGhlIGZvcm06IFtvcmlnaW5hbCBjZWxsIElEXSAtPiBbY2xvbmVdLlxuICAgIGNsb25lU3ViZ3JhcGg6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICB2YXIgc3ViZ3JhcGggPSB0aGlzLmdldFN1YmdyYXBoKGNlbGxzLCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZUNlbGxzKHN1YmdyYXBoKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGBjZWxsc2AgYW5kIGFsbCB0aGUgY29ubmVjdGVkIGxpbmtzIHRoYXQgY29ubmVjdCBjZWxscyBpbiB0aGUgYGNlbGxzYCBhcnJheS5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgcmV0dXJuIGFsbCB0aGUgY2VsbHMgaW5jbHVkaW5nIGFsbCB0aGVpciBlbWJlZGRlZCBjZWxsc1xuICAgIC8vIGFuZCBhbGwgdGhlIGxpbmtzIHRoYXQgY29ubmVjdCBhbnkgb2YgdGhlIHJldHVybmVkIGNlbGxzLlxuICAgIC8vIEZvciBleGFtcGxlLCBmb3IgYSBzaW5nbGUgc2hhbGxvdyBlbGVtZW50LCB0aGUgcmVzdWx0IGlzIHRoYXQgdmVyeSBzYW1lIGVsZW1lbnQuXG4gICAgLy8gRm9yIHR3byBlbGVtZW50cyBjb25uZWN0ZWQgd2l0aCBhIGxpbms6IGBBIC0tLSBMIC0tLT4gQmAsIHRoZSByZXN1bHQgZm9yXG4gICAgLy8gYGdldFN1YmdyYXBoKFtBLCBCXSlgIGlzIGBbQSwgTCwgQl1gLiBUaGUgc2FtZSBnb2VzIGZvciBgZ2V0U3ViZ3JhcGgoW0xdKWAsIHRoZSByZXN1bHQgaXMgYWdhaW4gYFtBLCBMLCBCXWAuXG4gICAgZ2V0U3ViZ3JhcGg6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgdmFyIHN1YmdyYXBoID0gW107XG4gICAgICAgIC8vIGBjZWxsTWFwYCBpcyB1c2VkIGZvciBhIHF1aWNrIGxvb2t1cCBvZiBleGlzdGVuY2Ugb2YgYSBjZWxsIGluIHRoZSBgY2VsbHNgIGFycmF5LlxuICAgICAgICB2YXIgY2VsbE1hcCA9IHt9O1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmtzID0gW107XG5cbiAgICAgICAgdXRpbC50b0FycmF5KGNlbGxzKS5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICAgIGlmICghY2VsbE1hcFtjZWxsLmlkXSkge1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgY2VsbE1hcFtjZWxsLmlkXSA9IGNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwuaXNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChjZWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGNlbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdC5kZWVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtYmVkcyA9IGNlbGwuZ2V0RW1iZWRkZWRDZWxscyh7IGRlZXA6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZW1iZWRzLmZvckVhY2goZnVuY3Rpb24oZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjZWxsTWFwW2VtYmVkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaChlbWJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsTWFwW2VtYmVkLmlkXSA9IGVtYmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtYmVkLmlzTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChlbWJlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZW1iZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuICAgICAgICAgICAgLy8gRm9yIGxpbmtzLCByZXR1cm4gdGhlaXIgc291cmNlICYgdGFyZ2V0IChpZiB0aGV5IGFyZSBlbGVtZW50cyAtIG5vdCBwb2ludHMpLlxuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgJiYgIWNlbGxNYXBbc291cmNlLmlkXSkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VFbGVtZW50ID0gdGhpcy5nZXRDZWxsKHNvdXJjZS5pZCk7XG4gICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjZWxsTWFwW3NvdXJjZUVsZW1lbnQuaWRdID0gc291cmNlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhcmdldC5pZCAmJiAhY2VsbE1hcFt0YXJnZXQuaWRdKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldENlbGwodGFyZ2V0LmlkKTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5wdXNoKHRoaXMuZ2V0Q2VsbCh0YXJnZXQuaWQpKTtcbiAgICAgICAgICAgICAgICBjZWxsTWFwW3RhcmdldEVsZW1lbnQuaWRdID0gdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEZvciBlbGVtZW50cywgaW5jbHVkZSB0aGVpciBjb25uZWN0ZWQgbGlua3MgaWYgdGhlaXIgc291cmNlL3RhcmdldCBpcyBpbiB0aGUgc3ViZ3JhcGg7XG4gICAgICAgICAgICB2YXIgbGlua3MgPSB0aGlzLmdldENvbm5lY3RlZExpbmtzKGVsZW1lbnQsIG9wdCk7XG4gICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbE1hcFtsaW5rLmlkXSAmJiBzb3VyY2UuaWQgJiYgY2VsbE1hcFtzb3VyY2UuaWRdICYmIHRhcmdldC5pZCAmJiBjZWxsTWFwW3RhcmdldC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbE1hcFtsaW5rLmlkXSA9IGxpbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBzdWJncmFwaDtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbGwgdGhlIHByZWRlY2Vzc29ycyBvZiBgZWxlbWVudGAuIFRoaXMgaXMgYSByZXZlcnNlIG9wZXJhdGlvbiBvZiBgZ2V0U3VjY2Vzc29ycygpYC5cbiAgICAvLyBJZiBgb3B0LmRlZXBgIGlzIGB0cnVlYCwgdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgdG9vLlxuICAgIC8vIElmIGBvcHQuYnJlYWR0aEZpcnN0YCBpcyBgdHJ1ZWAsIHVzZSB0aGUgQnJlYWR0aC1maXJzdCBzZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2UgdXNlIERlcHRoLWZpcnN0IHNlYXJjaC5cbiAgICBnZXRQcmVkZWNlc3NvcnM6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAvLyBNb2RpZnkgdGhlIG9wdGlvbnMgc28gdGhhdCBpdCBpbmNsdWRlcyB0aGUgYGluYm91bmRgIG5laWdoYm9ycyBvbmx5LiBJbiBvdGhlciB3b3Jkcywgc2VhcmNoIGJhY2t3YXJkcy5cbiAgICAgICAgdGhpcy5zZWFyY2goZWxlbWVudCwgZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGlmIChlbCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdXRpbC5hc3NpZ24oe30sIG9wdCwgeyBpbmJvdW5kOiB0cnVlIH0pKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuXG4gICAgLy8gUGVyZm9ybSBzZWFyY2ggb24gdGhlIGdyYXBoLlxuICAgIC8vIElmIGBvcHQuYnJlYWR0aEZpcnN0YCBpcyBgdHJ1ZWAsIHVzZSB0aGUgQnJlYWR0aC1maXJzdCBTZWFyY2ggYWxnb3JpdGhtLCBvdGhlcndpc2UgdXNlIERlcHRoLWZpcnN0IHNlYXJjaC5cbiAgICAvLyBCeSBzZXR0aW5nIGBvcHQuaW5ib3VuZGAgdG8gYHRydWVgLCB5b3UgY2FuIHJldmVyc2UgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VhcmNoLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gYGl0ZXJhdGVlYCBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBmb3JtIGBmdW5jdGlvbihlbGVtZW50KSB7fWAuXG4gICAgLy8gSWYgYGl0ZXJhdGVlYCBleHBsaWNpdGx5IHJldHVybnMgYGZhbHNlYCwgdGhlIHNlYXJjaGluZyBzdG9wcy5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uKGVsZW1lbnQsIGl0ZXJhdGVlLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIGlmIChvcHQuYnJlYWR0aEZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLmJmcyhlbGVtZW50LCBpdGVyYXRlZSwgb3B0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGZzKGVsZW1lbnQsIGl0ZXJhdGVlLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEJyZWFkdGgtZmlyc3Qgc2VhcmNoLlxuICAgIC8vIElmIGBvcHQuZGVlcGAgaXMgYHRydWVgLCB0YWtlIGludG8gYWNjb3VudCBlbWJlZGRlZCBlbGVtZW50cyB0b28uXG4gICAgLy8gSWYgYG9wdC5pbmJvdW5kYCBpcyBgdHJ1ZWAsIHJldmVyc2UgdGhlIHNlYXJjaCBkaXJlY3Rpb24gKGl0J3MgbGlrZSByZXZlcnNpbmcgYWxsIHRoZSBsaW5rIGRpcmVjdGlvbnMpLlxuICAgIC8vIGBpdGVyYXRlZWAgaXMgYSBmdW5jdGlvbiBvZiB0aGUgZm9ybSBgZnVuY3Rpb24oZWxlbWVudCwgZGlzdGFuY2UpIHt9YC5cbiAgICAvLyB3aGVyZSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnRseSB2aXNpdGVkIGVsZW1lbnQgYW5kIGBkaXN0YW5jZWAgaXMgdGhlIGRpc3RhbmNlIG9mIHRoYXQgZWxlbWVudFxuICAgIC8vIGZyb20gdGhlIHJvb3QgYGVsZW1lbnRgIHBhc3NlZCB0aGUgYGJmcygpYCwgaS5lLiB0aGUgZWxlbWVudCB3ZSBzdGFydGVkIHRoZSBzZWFyY2ggZnJvbS5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIGBkaXN0YW5jZWAgaXMgbm90IHRoZSBzaG9ydGVzdCBvciBsb25nZXN0IGRpc3RhbmNlLCBpdCBpcyBzaW1wbHkgdGhlIG51bWJlciBvZiBsZXZlbHNcbiAgICAvLyBjcm9zc2VkIHRpbGwgd2UgdmlzaXRlZCB0aGUgYGVsZW1lbnRgIGZvciB0aGUgZmlyc3QgdGltZS4gSXQgaXMgZXNwZWNpYWxseSB1c2VmdWwgZm9yIHRyZWUgZ3JhcGhzLlxuICAgIC8vIElmIGBpdGVyYXRlZWAgZXhwbGljaXRseSByZXR1cm5zIGBmYWxzZWAsIHRoZSBzZWFyY2hpbmcgc3RvcHMuXG4gICAgYmZzOiBmdW5jdGlvbihlbGVtZW50LCBpdGVyYXRlZSwgb3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW107XG5cbiAgICAgICAgcXVldWUucHVzaChlbGVtZW50KTtcbiAgICAgICAgZGlzdGFuY2VbZWxlbWVudC5pZF0gPSAwO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtuZXh0LmlkXSkgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkW25leHQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRlZS5jYWxsKHRoaXMsIG5leHQsIGRpc3RhbmNlW25leHQuaWRdKSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMobmV4dCwgb3B0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlW25laWdoYm9yLmlkXSA9IGRpc3RhbmNlW25leHQuaWRdICsgMTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBEZXB0aC1maXJzdCBzZWFyY2guXG4gICAgLy8gSWYgYG9wdC5kZWVwYCBpcyBgdHJ1ZWAsIHRha2UgaW50byBhY2NvdW50IGVtYmVkZGVkIGVsZW1lbnRzIHRvby5cbiAgICAvLyBJZiBgb3B0LmluYm91bmRgIGlzIGB0cnVlYCwgcmV2ZXJzZSB0aGUgc2VhcmNoIGRpcmVjdGlvbiAoaXQncyBsaWtlIHJldmVyc2luZyBhbGwgdGhlIGxpbmsgZGlyZWN0aW9ucykuXG4gICAgLy8gYGl0ZXJhdGVlYCBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBmb3JtIGBmdW5jdGlvbihlbGVtZW50LCBkaXN0YW5jZSkge31gLlxuICAgIC8vIElmIGBpdGVyYXRlZWAgZXhwbGljaXRseSByZXR1cm5zIGBmYWxzZWAsIHRoZSBzZWFyY2ggc3RvcHMuXG4gICAgZGZzOiBmdW5jdGlvbihlbGVtZW50LCBpdGVyYXRlZSwgb3B0ID0ge30pIHtcblxuICAgICAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW107XG5cbiAgICAgICAgcXVldWUucHVzaChlbGVtZW50KTtcbiAgICAgICAgZGlzdGFuY2VbZWxlbWVudC5pZF0gPSAwO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZFtuZXh0LmlkXSkgY29udGludWU7XG4gICAgICAgICAgICB2aXNpdGVkW25leHQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRlZS5jYWxsKHRoaXMsIG5leHQsIGRpc3RhbmNlW25leHQuaWRdKSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvcnMobmV4dCwgb3B0KTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmVpZ2hib3JzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlW25laWdoYm9yLmlkXSA9IGRpc3RhbmNlW25leHQuaWRdICsgMTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5zcGxpY2UobGFzdEluZGV4LCAwLCBuZWlnaGJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCB0aGUgcm9vdHMgb2YgdGhlIGdyYXBoLiBUaW1lIGNvbXBsZXhpdHk6IE8ofFZ8KS5cbiAgICBnZXRTb3VyY2VzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICB1dGlsLmZvckluKHRoaXMuX25vZGVzLCBmdW5jdGlvbihleGlzdHMsIG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5bbm9kZV0gfHwgdXRpbC5pc0VtcHR5KHRoaXMuX2luW25vZGVdKSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLmdldENlbGwobm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gc291cmNlcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCB0aGUgbGVhZnMgb2YgdGhlIGdyYXBoLiBUaW1lIGNvbXBsZXhpdHk6IE8ofFZ8KS5cbiAgICBnZXRTaW5rczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNpbmtzID0gW107XG4gICAgICAgIHV0aWwuZm9ySW4odGhpcy5fbm9kZXMsIGZ1bmN0aW9uKGV4aXN0cywgbm9kZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXRbbm9kZV0gfHwgdXRpbC5pc0VtcHR5KHRoaXMuX291dFtub2RlXSkpIHtcbiAgICAgICAgICAgICAgICBzaW5rcy5wdXNoKHRoaXMuZ2V0Q2VsbChub2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBzaW5rcztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpZiBgZWxlbWVudGAgaXMgYSByb290LiBUaW1lIGNvbXBsZXhpdHk6IE8oMSkuXG4gICAgaXNTb3VyY2U6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblxuICAgICAgICByZXR1cm4gIXRoaXMuX2luW2VsZW1lbnQuaWRdIHx8IHV0aWwuaXNFbXB0eSh0aGlzLl9pbltlbGVtZW50LmlkXSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaWYgYGVsZW1lbnRgIGlzIGEgbGVhZi4gVGltZSBjb21wbGV4aXR5OiBPKDEpLlxuICAgIGlzU2luazogZnVuY3Rpb24oZWxlbWVudCkge1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5fb3V0W2VsZW1lbnQuaWRdIHx8IHV0aWwuaXNFbXB0eSh0aGlzLl9vdXRbZWxlbWVudC5pZF0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gYHRydWVgIGlzIGBlbGVtZW50QmAgaXMgYSBzdWNjZXNzb3Igb2YgYGVsZW1lbnRBYC4gUmV0dXJuIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIGlzU3VjY2Vzc29yOiBmdW5jdGlvbihlbGVtZW50QSwgZWxlbWVudEIpIHtcblxuICAgICAgICB2YXIgaXNTdWNjZXNzb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWFyY2goZWxlbWVudEEsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBlbGVtZW50QiAmJiBlbGVtZW50ICE9PSBlbGVtZW50QSkge1xuICAgICAgICAgICAgICAgIGlzU3VjY2Vzc29yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBpc1N1Y2Nlc3NvcjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGB0cnVlYCBpcyBgZWxlbWVudEJgIGlzIGEgcHJlZGVjZXNzb3Igb2YgYGVsZW1lbnRBYC4gUmV0dXJuIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgIGlzUHJlZGVjZXNzb3I6IGZ1bmN0aW9uKGVsZW1lbnRBLCBlbGVtZW50Qikge1xuXG4gICAgICAgIHZhciBpc1ByZWRlY2Vzc29yID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VhcmNoKGVsZW1lbnRBLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gZWxlbWVudEIgJiYgZWxlbWVudCAhPT0gZWxlbWVudEEpIHtcbiAgICAgICAgICAgICAgICBpc1ByZWRlY2Vzc29yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHsgaW5ib3VuZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGlzUHJlZGVjZXNzb3I7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBgdHJ1ZWAgaXMgYGVsZW1lbnRCYCBpcyBhIG5laWdoYm9yIG9mIGBlbGVtZW50QWAuIFJldHVybiBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAvLyBgb3B0LmRlZXBgIGNvbnRyb2xzIHdoZXRoZXIgdG8gdGFrZSBpbnRvIGFjY291bnQgZW1iZWRkZWQgZWxlbWVudHMgYXMgd2VsbC4gU2VlIGBnZXROZWlnaGJvcnMoKWBcbiAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIElmIGBvcHQub3V0Ym91bmRgIGlzIHNldCB0byBgdHJ1ZWAsIHJldHVybiBgdHJ1ZWAgb25seSBpZiBgZWxlbWVudEJgIGlzIGEgc3VjY2Vzc29yIG5laWdoYm9yLlxuICAgIC8vIFNpbWlsYXJseSwgaWYgYG9wdC5pbmJvdW5kYCBpcyBzZXQgdG8gYHRydWVgLCByZXR1cm4gYHRydWVgIG9ubHkgaWYgYGVsZW1lbnRCYCBpcyBhIHByZWRlY2Vzc29yIG5laWdoYm9yLlxuICAgIGlzTmVpZ2hib3I6IGZ1bmN0aW9uKGVsZW1lbnRBLCBlbGVtZW50Qiwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBpbmJvdW5kID0gb3B0LmluYm91bmQ7XG4gICAgICAgIHZhciBvdXRib3VuZCA9IG9wdC5vdXRib3VuZDtcbiAgICAgICAgaWYgKChpbmJvdW5kID09PSB1bmRlZmluZWQpICYmIChvdXRib3VuZCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgaW5ib3VuZCA9IG91dGJvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc05laWdoYm9yID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5nZXRDb25uZWN0ZWRMaW5rcyhlbGVtZW50QSwgb3B0KS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgdmFyIHsgc291cmNlLCB0YXJnZXQgfSA9IGxpbmsuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgLy8gRGlzY2FyZCBpZiBpdCBpcyBhIHBvaW50LlxuICAgICAgICAgICAgaWYgKGluYm91bmQgJiYgdXRpbC5oYXMoc291cmNlLCAnaWQnKSAmJiAoc291cmNlLmlkID09PSBlbGVtZW50Qi5pZCkpIHtcbiAgICAgICAgICAgICAgICBpc05laWdoYm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc2NhcmQgaWYgaXQgaXMgYSBwb2ludCwgb3IgaWYgdGhlIG5laWdoYm9yIHdhcyBhbHJlYWR5IGFkZGVkLlxuICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIHV0aWwuaGFzKHRhcmdldCwgJ2lkJykgJiYgKHRhcmdldC5pZCA9PT0gZWxlbWVudEIuaWQpKSB7XG4gICAgICAgICAgICAgICAgaXNOZWlnaGJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaXNOZWlnaGJvcjtcbiAgICB9LFxuXG4gICAgLy8gRGlzY29ubmVjdCBsaW5rcyBjb25uZWN0ZWQgdG8gdGhlIGNlbGwgYG1vZGVsYC5cbiAgICBkaXNjb25uZWN0TGlua3M6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcblxuICAgICAgICB0aGlzLmdldENvbm5lY3RlZExpbmtzKG1vZGVsKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcblxuICAgICAgICAgICAgbGluay5zZXQoKGxpbmsuYXR0cmlidXRlcy5zb3VyY2UuaWQgPT09IG1vZGVsLmlkID8gJ3NvdXJjZScgOiAndGFyZ2V0JyksIHsgeDogMCwgeTogMCB9LCBvcHQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGxpbmtzIGNvbm5lY3RlZCB0byB0aGUgY2VsbCBgbW9kZWxgIGNvbXBsZXRlbHkuXG4gICAgcmVtb3ZlTGlua3M6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcblxuICAgICAgICB1dGlsLmludm9rZSh0aGlzLmdldENvbm5lY3RlZExpbmtzKG1vZGVsKSwgJ3JlbW92ZScsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIGNlbGxzIGF0IGdpdmVuIHBvaW50XG5cbiAgICBmaW5kRWxlbWVudHNBdFBvaW50OiBmdW5jdGlvbihwb2ludCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJBdFBvaW50KHRoaXMuZ2V0RWxlbWVudHMoKSwgcG9pbnQsIG9wdCk7XG4gICAgfSxcblxuICAgIGZpbmRMaW5rc0F0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckF0UG9pbnQodGhpcy5nZXRMaW5rcygpLCBwb2ludCwgb3B0KTtcbiAgICB9LFxuXG4gICAgZmluZENlbGxzQXRQb2ludDogZnVuY3Rpb24ocG9pbnQsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyQXRQb2ludCh0aGlzLmdldENlbGxzKCksIHBvaW50LCBvcHQpO1xuICAgIH0sXG5cbiAgICBfZmlsdGVyQXRQb2ludDogZnVuY3Rpb24oY2VsbHMsIHBvaW50LCBvcHQgPSB7fSkge1xuICAgICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGVsID0+IGVsLmdldEJCb3goeyByb3RhdGU6IHRydWUgfSkuY29udGFpbnNQb2ludChwb2ludCwgb3B0KSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIGNlbGxzIGluIGdpdmVuIGFyZWFcblxuICAgIGZpbmRFbGVtZW50c0luQXJlYTogZnVuY3Rpb24oYXJlYSwgb3B0ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckluQXJlYSh0aGlzLmdldEVsZW1lbnRzKCksIGFyZWEsIG9wdCk7XG4gICAgfSxcblxuICAgIGZpbmRMaW5rc0luQXJlYTogZnVuY3Rpb24oYXJlYSwgb3B0ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckluQXJlYSh0aGlzLmdldExpbmtzKCksIGFyZWEsIG9wdCk7XG4gICAgfSxcblxuICAgIGZpbmRDZWxsc0luQXJlYTogZnVuY3Rpb24oYXJlYSwgb3B0ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckluQXJlYSh0aGlzLmdldENlbGxzKCksIGFyZWEsIG9wdCk7XG4gICAgfSxcblxuICAgIF9maWx0ZXJJbkFyZWE6IGZ1bmN0aW9uKGNlbGxzLCBhcmVhLCBvcHQgPSB7fSkge1xuICAgICAgICBjb25zdCByID0gbmV3IGcuUmVjdChhcmVhKTtcbiAgICAgICAgY29uc3QgeyBzdHJpY3QgPSBmYWxzZSB9ID0gb3B0O1xuICAgICAgICBjb25zdCBtZXRob2QgPSBzdHJpY3QgPyAnY29udGFpbnNSZWN0JyA6ICdpbnRlcnNlY3QnO1xuICAgICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGVsID0+IHJbbWV0aG9kXShlbC5nZXRCQm94KHsgcm90YXRlOiB0cnVlIH0pKSk7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYWxsIGNlbGxzIHVuZGVyIHRoZSBnaXZlbiBlbGVtZW50LlxuXG4gICAgZmluZEVsZW1lbnRzVW5kZXJFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckNlbGxzVW5kZXJFbGVtZW50KHRoaXMuZ2V0RWxlbWVudHMoKSwgZWxlbWVudCwgb3B0KTtcbiAgICB9LFxuXG4gICAgZmluZExpbmtzVW5kZXJFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckNlbGxzVW5kZXJFbGVtZW50KHRoaXMuZ2V0TGlua3MoKSwgZWxlbWVudCwgb3B0KTtcbiAgICB9LFxuXG4gICAgZmluZENlbGxzVW5kZXJFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlckNlbGxzVW5kZXJFbGVtZW50KHRoaXMuZ2V0Q2VsbHMoKSwgZWxlbWVudCwgb3B0KTtcbiAgICB9LFxuXG4gICAgX2lzVmFsaWRFbGVtZW50VW5kZXJFbGVtZW50OiBmdW5jdGlvbihlbDEsIGVsMikge1xuICAgICAgICByZXR1cm4gZWwxLmlkICE9PSBlbDIuaWQgJiYgIWVsMS5pc0VtYmVkZGVkSW4oZWwyKTtcbiAgICB9LFxuXG4gICAgX2lzVmFsaWRMaW5rVW5kZXJFbGVtZW50OiBmdW5jdGlvbihsaW5rLCBlbCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbGluay5zb3VyY2UoKS5pZCAhPT0gZWwuaWQgJiZcbiAgICAgICAgICAgIGxpbmsudGFyZ2V0KCkuaWQgIT09IGVsLmlkICYmXG4gICAgICAgICAgICAhbGluay5pc0VtYmVkZGVkSW4oZWwpXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIF92YWxpZGF0ZUNlbGxzVW5kZXJFbGVtZW50OiBmdW5jdGlvbihjZWxscywgZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGNlbGwgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuaXNMaW5rKClcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2lzVmFsaWRMaW5rVW5kZXJFbGVtZW50KGNlbGwsIGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9pc1ZhbGlkRWxlbWVudFVuZGVyRWxlbWVudChjZWxsLCBlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9nZXRGaW5kVW5kZXJFbGVtZW50R2VvbWV0cnk6IGZ1bmN0aW9uKGVsZW1lbnQsIHNlYXJjaEJ5ID0gJ2Jib3gnKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBlbGVtZW50LmdldEJCb3goeyByb3RhdGU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiAoc2VhcmNoQnkgIT09ICdiYm94JykgPyB1dGlsLmdldFJlY3RQb2ludChiYm94LCBzZWFyY2hCeSkgOiBiYm94O1xuICAgIH0sXG5cbiAgICBfZmlsdGVyQ2VsbHNVbmRlckVsZW1lbnQ6IGZ1bmN0aW9uKGNlbGxzLCBlbGVtZW50LCBvcHQgPSB7fSkge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMuX2dldEZpbmRVbmRlckVsZW1lbnRHZW9tZXRyeShlbGVtZW50LCBvcHQuc2VhcmNoQnkpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZENlbGxzID0gKGdlb21ldHJ5LnR5cGUgPT09IGcudHlwZXMuUG9pbnQpXG4gICAgICAgICAgICA/IHRoaXMuX2ZpbHRlckF0UG9pbnQoY2VsbHMsIGdlb21ldHJ5KVxuICAgICAgICAgICAgOiB0aGlzLl9maWx0ZXJJbkFyZWEoY2VsbHMsIGdlb21ldHJ5LCBvcHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVDZWxsc1VuZGVyRWxlbWVudChmaWx0ZXJlZENlbGxzLCBlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLy8gQGRlcHJlY2F0ZWQgdXNlIGBmaW5kRWxlbWVudHNJbkFyZWFgIGluc3RlYWRcbiAgICBmaW5kTW9kZWxzSW5BcmVhOiBmdW5jdGlvbihhcmVhLCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEVsZW1lbnRzSW5BcmVhKGFyZWEsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIEBkZXByZWNhdGVkIHVzZSBgZmluZEVsZW1lbnRzQXRQb2ludGAgaW5zdGVhZFxuICAgIGZpbmRNb2RlbHNGcm9tUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50c0F0UG9pbnQocG9pbnQpO1xuICAgIH0sXG5cbiAgICAvLyBAZGVwcmVjYXRlZCB1c2UgYGZpbmRNb2RlbHNVbmRlckVsZW1lbnRgIGluc3RlYWRcbiAgICBmaW5kTW9kZWxzVW5kZXJFbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEVsZW1lbnRzVW5kZXJFbGVtZW50KGVsZW1lbnQsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBib3VuZGluZyBib3ggb2YgYWxsIGVsZW1lbnRzLlxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldENlbGxzQkJveCh0aGlzLmdldENlbGxzKCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiBhbGwgY2VsbHMgaW4gYXJyYXkgcHJvdmlkZWQuXG4gICAgZ2V0Q2VsbHNCQm94OiBmdW5jdGlvbihjZWxscywgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgeyByb3RhdGUgPSB0cnVlIH0gPSBvcHQ7XG4gICAgICAgIHJldHVybiB1dGlsLnRvQXJyYXkoY2VsbHMpLnJlZHVjZShmdW5jdGlvbihtZW1vLCBjZWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gY2VsbC5nZXRCQm94KHsgcm90YXRlIH0pO1xuICAgICAgICAgICAgaWYgKCFyZWN0KSByZXR1cm4gbWVtbztcbiAgICAgICAgICAgIGlmIChtZW1vKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW8udW5pb24ocmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjdDtcbiAgICAgICAgfSwgbnVsbCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oZHgsIGR5LCBvcHQpIHtcblxuICAgICAgICAvLyBEb24ndCB0cmFuc2xhdGUgY2VsbHMgdGhhdCBhcmUgZW1iZWRkZWQgaW4gYW55IG90aGVyIGNlbGwuXG4gICAgICAgIHZhciBjZWxscyA9IHRoaXMuZ2V0Q2VsbHMoKS5maWx0ZXIoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuICFjZWxsLmlzRW1iZWRkZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdXRpbC5pbnZva2UoY2VsbHMsICd0cmFuc2xhdGUnLCBkeCwgZHksIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplQ2VsbHMod2lkdGgsIGhlaWdodCwgdGhpcy5nZXRDZWxscygpLCBvcHQpO1xuICAgIH0sXG5cbiAgICByZXNpemVDZWxsczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgY2VsbHMsIG9wdCkge1xuXG4gICAgICAgIC8vIGBnZXRCQm94YCBtZXRob2QgcmV0dXJucyBgbnVsbGAgaWYgbm8gZWxlbWVudHMgcHJvdmlkZWQuXG4gICAgICAgIC8vIGkuZS4gY2VsbHMgY2FuIGJlIGFuIGFycmF5IG9mIGxpbmtzXG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5nZXRDZWxsc0JCb3goY2VsbHMpO1xuICAgICAgICBpZiAoYmJveCkge1xuICAgICAgICAgICAgdmFyIHN4ID0gTWF0aC5tYXgod2lkdGggLyBiYm94LndpZHRoLCAwKTtcbiAgICAgICAgICAgIHZhciBzeSA9IE1hdGgubWF4KGhlaWdodCAvIGJib3guaGVpZ2h0LCAwKTtcbiAgICAgICAgICAgIHV0aWwuaW52b2tlKGNlbGxzLCAnc2NhbGUnLCBzeCwgc3ksIGJib3gub3JpZ2luKCksIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RhcnRCYXRjaDogZnVuY3Rpb24obmFtZSwgZGF0YSkge1xuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgICB0aGlzLl9iYXRjaGVzW25hbWVdID0gKHRoaXMuX2JhdGNoZXNbbmFtZV0gfHwgMCkgKyAxO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2JhdGNoOnN0YXJ0JywgdXRpbC5hc3NpZ24oe30sIGRhdGEsIHsgYmF0Y2hOYW1lOiBuYW1lIH0pKTtcbiAgICB9LFxuXG4gICAgc3RvcEJhdGNoOiBmdW5jdGlvbihuYW1lLCBkYXRhKSB7XG5cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIHRoaXMuX2JhdGNoZXNbbmFtZV0gPSAodGhpcy5fYmF0Y2hlc1tuYW1lXSB8fCAwKSAtIDE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignYmF0Y2g6c3RvcCcsIHV0aWwuYXNzaWduKHt9LCBkYXRhLCB7IGJhdGNoTmFtZTogbmFtZSB9KSk7XG4gICAgfSxcblxuICAgIGhhc0FjdGl2ZUJhdGNoOiBmdW5jdGlvbihuYW1lKSB7XG5cbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IHRoaXMuX2JhdGNoZXM7XG4gICAgICAgIGxldCBuYW1lcztcblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmFtZXMgPSBPYmplY3Qua2V5cyhiYXRjaGVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lcyA9IG5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lcyA9IFtuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lcy5zb21lKChiYXRjaCkgPT4gYmF0Y2hlc1tiYXRjaF0gPiAwKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIHZhbGlkYXRpb25zOiB7XG5cbiAgICAgICAgbXVsdGlMaW5rczogZnVuY3Rpb24oZ3JhcGgsIGxpbmspIHtcblxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IG11bHRpcGxlIGxpbmtzIHRvIGhhdmUgdGhlIHNhbWUgc291cmNlIGFuZCB0YXJnZXQuXG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICBpZiAoc291cmNlLmlkICYmIHRhcmdldC5pZCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1vZGVsID0gbGluay5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZU1vZGVsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbm5lY3RlZExpbmtzID0gZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3Moc291cmNlTW9kZWwsIHsgb3V0Ym91bmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYW1lTGlua3MgPSBjb25uZWN0ZWRMaW5rcy5maWx0ZXIoZnVuY3Rpb24oX2xpbmspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgc291cmNlOiBfc291cmNlLCB0YXJnZXQ6IF90YXJnZXQgfSA9IF9saW5rLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NvdXJjZSAmJiBfc291cmNlLmlkID09PSBzb3VyY2UuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIV9zb3VyY2UucG9ydCB8fCAoX3NvdXJjZS5wb3J0ID09PSBzb3VyY2UucG9ydCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldCAmJiBfdGFyZ2V0LmlkID09PSB0YXJnZXQuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIV90YXJnZXQucG9ydCB8fCAoX3RhcmdldC5wb3J0ID09PSB0YXJnZXQucG9ydCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1lTGlua3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBsaW5rUGlubmluZzogZnVuY3Rpb24oX2dyYXBoLCBsaW5rKSB7XG4gICAgICAgICAgICB2YXIgeyBzb3VyY2UsIHRhcmdldCB9ID0gbGluay5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5pZCAmJiB0YXJnZXQuaWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG53cmFwV2l0aChHcmFwaC5wcm90b3R5cGUsIFsncmVzZXRDZWxscycsICdhZGRDZWxscycsICdyZW1vdmVDZWxscyddLCB3cmFwcGVycy5jZWxscyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/Graph.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/HighlighterView.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HighlighterView: function() { return /* binding */ HighlighterView; }\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\nfunction toArray(obj) {\n    if (!obj) return [];\n    if (Array.isArray(obj)) return obj;\n    return [obj];\n}\n\nconst HighlighterView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n\n    tagName: 'g',\n    svgElement: true,\n    className: 'highlight',\n\n    HIGHLIGHT_FLAG: 1,\n    UPDATE_PRIORITY: 3,\n    DETACHABLE: false,\n    UPDATABLE: true,\n    MOUNTABLE: true,\n\n    cellView: null,\n    nodeSelector: null,\n    node: null,\n    updateRequested: false,\n    postponedUpdate: false,\n    transformGroup: null,\n    detachedTransformGroup: null,\n\n    requestUpdate(cellView, nodeSelector) {\n        const { paper } = cellView;\n        this.cellView = cellView;\n        this.nodeSelector = nodeSelector;\n        if (paper) {\n            this.updateRequested = true;\n            paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n        }\n    },\n\n    confirmUpdate() {\n        // The cellView is now rendered/updated since it has a higher update priority.\n        this.updateRequested = false;\n        const { cellView, nodeSelector } = this;\n        if (cellView.isMounted()) {\n            this.update(cellView, nodeSelector);\n            this.mount();\n            this.transform();\n        } else {\n            this.postponedUpdate = true;\n        }\n        return 0;\n    },\n\n    findNode(cellView, nodeSelector = null) {\n        let el;\n        if (typeof nodeSelector === 'string') {\n            el = cellView.findNode(nodeSelector);\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(nodeSelector)) {\n            const isLink = cellView.model.isLink();\n            const { label = null, port, selector } = nodeSelector;\n            if (isLink && label !== null) {\n                // Link Label Selector\n                el = cellView.findLabelNode(label, selector);\n            } else if (!isLink && port) {\n                // Element Port Selector\n                el = cellView.findPortNode(port, selector);\n            } else {\n                // Cell Selector\n                el = cellView.findNode(selector);\n            }\n        } else if (nodeSelector) {\n            el = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].toNode(nodeSelector);\n            if (!(el instanceof SVGElement)) el = null;\n        }\n        return el ? el : null;\n    },\n\n    getNodeMatrix(cellView, node) {\n        const { options } = this;\n        const { layer } = options;\n        const { rotatableNode } = cellView;\n        const nodeMatrix = cellView.getNodeMatrix(node);\n        if (rotatableNode) {\n            if (layer) {\n                if (rotatableNode.contains(node)) {\n                    return nodeMatrix;\n                }\n                // The node is outside of the rotatable group.\n                // Compensate the rotation set by transformGroup.\n                return cellView.getRootRotateMatrix().inverse().multiply(nodeMatrix);\n            } else {\n                return cellView.getNodeRotateMatrix(node).multiply(nodeMatrix);\n            }\n        }\n        return nodeMatrix;\n    },\n\n    mount() {\n        const { MOUNTABLE, cellView, el, options, transformGroup, detachedTransformGroup, postponedUpdate, nodeSelector } = this;\n        if (!MOUNTABLE || transformGroup) return;\n        if (postponedUpdate) {\n            // The cellView was not mounted when the update was requested.\n            // The update was postponed until the cellView is mounted.\n            this.update(cellView, nodeSelector);\n            this.transform();\n            return;\n        }\n        const { vel: cellViewRoot, paper } = cellView;\n        const { layer: layerName } = options;\n        if (layerName) {\n            let vGroup;\n            if (detachedTransformGroup) {\n                vGroup = detachedTransformGroup;\n                this.detachedTransformGroup = null;\n            } else {\n                vGroup = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('g').addClass('highlight-transform').append(el);\n            }\n            this.transformGroup = vGroup;\n            paper.getLayerView(layerName).insertSortedNode(vGroup.node, options.z);\n        } else {\n            // TODO: prepend vs append\n            if (!el.parentNode || el.nextSibling) {\n                // Not appended yet or not the last child\n                cellViewRoot.append(el);\n            }\n        }\n    },\n\n    unmount() {\n        const { MOUNTABLE, transformGroup, vel } = this;\n        if (!MOUNTABLE) return;\n        if (transformGroup) {\n            this.transformGroup = null;\n            this.detachedTransformGroup = transformGroup;\n            transformGroup.remove();\n        } else {\n            vel.remove();\n        }\n    },\n\n    transform() {\n        const { transformGroup, cellView, updateRequested } = this;\n        if (!transformGroup || cellView.model.isLink() || updateRequested) return;\n        const translateMatrix = cellView.getRootTranslateMatrix();\n        const rotateMatrix = cellView.getRootRotateMatrix();\n        const transformMatrix = translateMatrix.multiply(rotateMatrix);\n        transformGroup.attr('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].matrixToTransformString(transformMatrix));\n    },\n\n    update() {\n        const { node: prevNode, cellView, nodeSelector, updateRequested, id } = this;\n        if (updateRequested) return;\n        this.postponedUpdate = false;\n        const node = this.node = this.findNode(cellView, nodeSelector);\n        if (prevNode) {\n            this.unhighlight(cellView, prevNode);\n        }\n        if (node) {\n            this.highlight(cellView, node);\n            this.mount();\n        } else {\n            this.unmount();\n            cellView.notify('cell:highlight:invalid', id, this);\n        }\n    },\n\n    onRemove() {\n        const { node, cellView, id, constructor } = this;\n        if (node) {\n            this.unhighlight(cellView, node);\n        }\n        this.unmount();\n        constructor._removeRef(cellView, id);\n    },\n\n    highlight(_cellView, _node) {\n        // to be overridden\n    },\n\n    unhighlight(_cellView, _node) {\n        // to be overridden\n    },\n\n    // Update Attributes\n\n    listenToUpdateAttributes(cellView) {\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'UPDATE_ATTRIBUTES');\n        if (!Array.isArray(attributes) || attributes.length === 0) return;\n        this.listenTo(cellView.model, 'change', this.onCellAttributeChange);\n    },\n\n    onCellAttributeChange() {\n        const { cellView } = this;\n        if (!cellView) return;\n        const { model, paper } = cellView;\n        const attributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.result)(this, 'UPDATE_ATTRIBUTES');\n        if (!attributes.some(attribute => model.hasChanged(attribute))) return;\n        paper.requestViewUpdate(this, this.HIGHLIGHT_FLAG, this.UPDATE_PRIORITY);\n    }\n\n}, {\n\n    _views: {},\n\n    // Used internally by CellView highlight()\n    highlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.add(cellView, node, id, opt);\n    },\n\n    // Used internally by CellView unhighlight()\n    unhighlight: function(cellView, node, opt) {\n        const id = this.uniqueId(node, opt);\n        this.remove(cellView, id);\n    },\n\n    get(cellView, id = null) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (id === null) {\n            // all highlighters\n            const views = [];\n            if (!refs) return views;\n            for (let hid in refs) {\n                const ref = refs[hid];\n                if (ref instanceof this) {\n                    views.push(ref);\n                }\n            }\n            return views;\n        } else {\n            // single highlighter\n            if (!refs) return null;\n            if (id in refs) {\n                const ref = refs[id];\n                if (ref instanceof this) return ref;\n            }\n            return null;\n        }\n    },\n\n    add(cellView, nodeSelector, id, opt = {}) {\n        if (!id) throw new Error('dia.HighlighterView: An ID required.');\n        // Search the existing view amongst all the highlighters\n        const previousView = HighlighterView.get(cellView, id);\n        if (previousView) previousView.remove();\n        const view = new this(opt);\n        view.id = id;\n        this._addRef(cellView, id, view);\n        view.requestUpdate(cellView, nodeSelector);\n        view.listenToUpdateAttributes(cellView);\n        return view;\n    },\n\n    _addRef(cellView, id, view) {\n        const { cid } = cellView;\n        const { _views } = this;\n        let refs = _views[cid];\n        if (!refs) refs = _views[cid] = {};\n        refs[id] = view;\n    },\n\n    _removeRef(cellView, id) {\n        const { cid } = cellView;\n        const { _views } = this;\n        const refs = _views[cid];\n        if (!refs) return;\n        if (id) delete refs[id];\n        for (let _ in refs) return;\n        delete _views[cid];\n    },\n\n    remove(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            view.remove();\n        });\n    },\n\n    getAll(paper, id = null) {\n        const views = [];\n        const { _views } = this;\n        for (let cid in _views) {\n            for (let hid in _views[cid]) {\n                const view = _views[cid][hid];\n                if (view.cellView.paper === paper && view instanceof this && (id === null || hid === id)) {\n                    views.push(view);\n                }\n            }\n        }\n        return views;\n    },\n\n    removeAll(paper, id = null) {\n        this.getAll(paper, id).forEach(view => view.remove());\n    },\n\n    update(cellView, id = null, dirty = false) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            if (dirty || view.UPDATABLE) view.update();\n        });\n    },\n\n    transform(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => {\n            if (view.UPDATABLE) view.transform();\n        });\n    },\n\n    unmount(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => view.unmount());\n    },\n\n    mount(cellView, id = null) {\n        toArray(this.get(cellView, id)).forEach(view => view.mount());\n    },\n\n    uniqueId(node, opt = '') {\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].ensureId(node) + JSON.stringify(opt);\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0hpZ2hsaWdodGVyVmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNUO0FBQzBCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLHdCQUF3QixnREFBUTs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUyw2REFBYTtBQUNoQztBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlCQUFpQixvREFBQztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLDBHQUEwRztBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQyxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QseUJBQXlCLHdEQUFDO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLDRDQUE0QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvREFBQztBQUMxQyxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLDhEQUE4RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSwyQkFBMkIsc0RBQU07QUFDakM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLDJCQUEyQixzREFBTTtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsb0RBQUM7QUFDaEI7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9IaWdobGlnaHRlclZpZXcubWpzPzI4ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbXZjIGZyb20gJy4uL212Yy9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCwgcmVzdWx0IH0gZnJvbSAnLi4vdXRpbC91dGlsLm1qcyc7XG5cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBbb2JqXTtcbn1cblxuZXhwb3J0IGNvbnN0IEhpZ2hsaWdodGVyVmlldyA9IG12Yy5WaWV3LmV4dGVuZCh7XG5cbiAgICB0YWdOYW1lOiAnZycsXG4gICAgc3ZnRWxlbWVudDogdHJ1ZSxcbiAgICBjbGFzc05hbWU6ICdoaWdobGlnaHQnLFxuXG4gICAgSElHSExJR0hUX0ZMQUc6IDEsXG4gICAgVVBEQVRFX1BSSU9SSVRZOiAzLFxuICAgIERFVEFDSEFCTEU6IGZhbHNlLFxuICAgIFVQREFUQUJMRTogdHJ1ZSxcbiAgICBNT1VOVEFCTEU6IHRydWUsXG5cbiAgICBjZWxsVmlldzogbnVsbCxcbiAgICBub2RlU2VsZWN0b3I6IG51bGwsXG4gICAgbm9kZTogbnVsbCxcbiAgICB1cGRhdGVSZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgIHBvc3Rwb25lZFVwZGF0ZTogZmFsc2UsXG4gICAgdHJhbnNmb3JtR3JvdXA6IG51bGwsXG4gICAgZGV0YWNoZWRUcmFuc2Zvcm1Hcm91cDogbnVsbCxcblxuICAgIHJlcXVlc3RVcGRhdGUoY2VsbFZpZXcsIG5vZGVTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCB7IHBhcGVyIH0gPSBjZWxsVmlldztcbiAgICAgICAgdGhpcy5jZWxsVmlldyA9IGNlbGxWaWV3O1xuICAgICAgICB0aGlzLm5vZGVTZWxlY3RvciA9IG5vZGVTZWxlY3RvcjtcbiAgICAgICAgaWYgKHBhcGVyKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICBwYXBlci5yZXF1ZXN0Vmlld1VwZGF0ZSh0aGlzLCB0aGlzLkhJR0hMSUdIVF9GTEFHLCB0aGlzLlVQREFURV9QUklPUklUWSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29uZmlybVVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVGhlIGNlbGxWaWV3IGlzIG5vdyByZW5kZXJlZC91cGRhdGVkIHNpbmNlIGl0IGhhcyBhIGhpZ2hlciB1cGRhdGUgcHJpb3JpdHkuXG4gICAgICAgIHRoaXMudXBkYXRlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY2VsbFZpZXcsIG5vZGVTZWxlY3RvciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGNlbGxWaWV3LmlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShjZWxsVmlldywgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMubW91bnQoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvc3Rwb25lZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIGZpbmROb2RlKGNlbGxWaWV3LCBub2RlU2VsZWN0b3IgPSBudWxsKSB7XG4gICAgICAgIGxldCBlbDtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbCA9IGNlbGxWaWV3LmZpbmROb2RlKG5vZGVTZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChub2RlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0xpbmsgPSBjZWxsVmlldy5tb2RlbC5pc0xpbmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGFiZWwgPSBudWxsLCBwb3J0LCBzZWxlY3RvciB9ID0gbm9kZVNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKGlzTGluayAmJiBsYWJlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIExpbmsgTGFiZWwgU2VsZWN0b3JcbiAgICAgICAgICAgICAgICBlbCA9IGNlbGxWaWV3LmZpbmRMYWJlbE5vZGUobGFiZWwsIHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTGluayAmJiBwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy8gRWxlbWVudCBQb3J0IFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWwgPSBjZWxsVmlldy5maW5kUG9ydE5vZGUocG9ydCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDZWxsIFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgZWwgPSBjZWxsVmlldy5maW5kTm9kZShzZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBlbCA9IFYudG9Ob2RlKG5vZGVTZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoIShlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpKSBlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsID8gZWwgOiBudWxsO1xuICAgIH0sXG5cbiAgICBnZXROb2RlTWF0cml4KGNlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBsYXllciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgeyByb3RhdGFibGVOb2RlIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3Qgbm9kZU1hdHJpeCA9IGNlbGxWaWV3LmdldE5vZGVNYXRyaXgobm9kZSk7XG4gICAgICAgIGlmIChyb3RhdGFibGVOb2RlKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAocm90YXRhYmxlTm9kZS5jb250YWlucyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU1hdHJpeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIG5vZGUgaXMgb3V0c2lkZSBvZiB0aGUgcm90YXRhYmxlIGdyb3VwLlxuICAgICAgICAgICAgICAgIC8vIENvbXBlbnNhdGUgdGhlIHJvdGF0aW9uIHNldCBieSB0cmFuc2Zvcm1Hcm91cC5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2VsbFZpZXcuZ2V0Um9vdFJvdGF0ZU1hdHJpeCgpLmludmVyc2UoKS5tdWx0aXBseShub2RlTWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxWaWV3LmdldE5vZGVSb3RhdGVNYXRyaXgobm9kZSkubXVsdGlwbHkobm9kZU1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVNYXRyaXg7XG4gICAgfSxcblxuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCB7IE1PVU5UQUJMRSwgY2VsbFZpZXcsIGVsLCBvcHRpb25zLCB0cmFuc2Zvcm1Hcm91cCwgZGV0YWNoZWRUcmFuc2Zvcm1Hcm91cCwgcG9zdHBvbmVkVXBkYXRlLCBub2RlU2VsZWN0b3IgfSA9IHRoaXM7XG4gICAgICAgIGlmICghTU9VTlRBQkxFIHx8IHRyYW5zZm9ybUdyb3VwKSByZXR1cm47XG4gICAgICAgIGlmIChwb3N0cG9uZWRVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjZWxsVmlldyB3YXMgbm90IG1vdW50ZWQgd2hlbiB0aGUgdXBkYXRlIHdhcyByZXF1ZXN0ZWQuXG4gICAgICAgICAgICAvLyBUaGUgdXBkYXRlIHdhcyBwb3N0cG9uZWQgdW50aWwgdGhlIGNlbGxWaWV3IGlzIG1vdW50ZWQuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShjZWxsVmlldywgbm9kZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB2ZWw6IGNlbGxWaWV3Um9vdCwgcGFwZXIgfSA9IGNlbGxWaWV3O1xuICAgICAgICBjb25zdCB7IGxheWVyOiBsYXllck5hbWUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChsYXllck5hbWUpIHtcbiAgICAgICAgICAgIGxldCB2R3JvdXA7XG4gICAgICAgICAgICBpZiAoZGV0YWNoZWRUcmFuc2Zvcm1Hcm91cCkge1xuICAgICAgICAgICAgICAgIHZHcm91cCA9IGRldGFjaGVkVHJhbnNmb3JtR3JvdXA7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hlZFRyYW5zZm9ybUdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdkdyb3VwID0gVignZycpLmFkZENsYXNzKCdoaWdobGlnaHQtdHJhbnNmb3JtJykuYXBwZW5kKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtR3JvdXAgPSB2R3JvdXA7XG4gICAgICAgICAgICBwYXBlci5nZXRMYXllclZpZXcobGF5ZXJOYW1lKS5pbnNlcnRTb3J0ZWROb2RlKHZHcm91cC5ub2RlLCBvcHRpb25zLnopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogcHJlcGVuZCB2cyBhcHBlbmRcbiAgICAgICAgICAgIGlmICghZWwucGFyZW50Tm9kZSB8fCBlbC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhcHBlbmRlZCB5ZXQgb3Igbm90IHRoZSBsYXN0IGNoaWxkXG4gICAgICAgICAgICAgICAgY2VsbFZpZXdSb290LmFwcGVuZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBNT1VOVEFCTEUsIHRyYW5zZm9ybUdyb3VwLCB2ZWwgfSA9IHRoaXM7XG4gICAgICAgIGlmICghTU9VTlRBQkxFKSByZXR1cm47XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Hcm91cCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRldGFjaGVkVHJhbnNmb3JtR3JvdXAgPSB0cmFuc2Zvcm1Hcm91cDtcbiAgICAgICAgICAgIHRyYW5zZm9ybUdyb3VwLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm1Hcm91cCwgY2VsbFZpZXcsIHVwZGF0ZVJlcXVlc3RlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF0cmFuc2Zvcm1Hcm91cCB8fCBjZWxsVmlldy5tb2RlbC5pc0xpbmsoKSB8fCB1cGRhdGVSZXF1ZXN0ZWQpIHJldHVybjtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlTWF0cml4ID0gY2VsbFZpZXcuZ2V0Um9vdFRyYW5zbGF0ZU1hdHJpeCgpO1xuICAgICAgICBjb25zdCByb3RhdGVNYXRyaXggPSBjZWxsVmlldy5nZXRSb290Um90YXRlTWF0cml4KCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRyYW5zbGF0ZU1hdHJpeC5tdWx0aXBseShyb3RhdGVNYXRyaXgpO1xuICAgICAgICB0cmFuc2Zvcm1Hcm91cC5hdHRyKCd0cmFuc2Zvcm0nLCBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKHRyYW5zZm9ybU1hdHJpeCkpO1xuICAgIH0sXG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgbm9kZTogcHJldk5vZGUsIGNlbGxWaWV3LCBub2RlU2VsZWN0b3IsIHVwZGF0ZVJlcXVlc3RlZCwgaWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICh1cGRhdGVSZXF1ZXN0ZWQpIHJldHVybjtcbiAgICAgICAgdGhpcy5wb3N0cG9uZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZSA9IHRoaXMuZmluZE5vZGUoY2VsbFZpZXcsIG5vZGVTZWxlY3Rvcik7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy51bmhpZ2hsaWdodChjZWxsVmlldywgcHJldk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChjZWxsVmlldywgbm9kZSk7XG4gICAgICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVubW91bnQoKTtcbiAgICAgICAgICAgIGNlbGxWaWV3Lm5vdGlmeSgnY2VsbDpoaWdobGlnaHQ6aW52YWxpZCcsIGlkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvblJlbW92ZSgpIHtcbiAgICAgICAgY29uc3QgeyBub2RlLCBjZWxsVmlldywgaWQsIGNvbnN0cnVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy51bmhpZ2hsaWdodChjZWxsVmlldywgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bm1vdW50KCk7XG4gICAgICAgIGNvbnN0cnVjdG9yLl9yZW1vdmVSZWYoY2VsbFZpZXcsIGlkKTtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0KF9jZWxsVmlldywgX25vZGUpIHtcbiAgICAgICAgLy8gdG8gYmUgb3ZlcnJpZGRlblxuICAgIH0sXG5cbiAgICB1bmhpZ2hsaWdodChfY2VsbFZpZXcsIF9ub2RlKSB7XG4gICAgICAgIC8vIHRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIEF0dHJpYnV0ZXNcblxuICAgIGxpc3RlblRvVXBkYXRlQXR0cmlidXRlcyhjZWxsVmlldykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcmVzdWx0KHRoaXMsICdVUERBVEVfQVRUUklCVVRFUycpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykgfHwgYXR0cmlidXRlcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhjZWxsVmlldy5tb2RlbCwgJ2NoYW5nZScsIHRoaXMub25DZWxsQXR0cmlidXRlQ2hhbmdlKTtcbiAgICB9LFxuXG4gICAgb25DZWxsQXR0cmlidXRlQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCB7IGNlbGxWaWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWNlbGxWaWV3KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHBhcGVyIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHJlc3VsdCh0aGlzLCAnVVBEQVRFX0FUVFJJQlVURVMnKTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnNvbWUoYXR0cmlidXRlID0+IG1vZGVsLmhhc0NoYW5nZWQoYXR0cmlidXRlKSkpIHJldHVybjtcbiAgICAgICAgcGFwZXIucmVxdWVzdFZpZXdVcGRhdGUodGhpcywgdGhpcy5ISUdITElHSFRfRkxBRywgdGhpcy5VUERBVEVfUFJJT1JJVFkpO1xuICAgIH1cblxufSwge1xuXG4gICAgX3ZpZXdzOiB7fSxcblxuICAgIC8vIFVzZWQgaW50ZXJuYWxseSBieSBDZWxsVmlldyBoaWdobGlnaHQoKVxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oY2VsbFZpZXcsIG5vZGUsIG9wdCkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMudW5pcXVlSWQobm9kZSwgb3B0KTtcbiAgICAgICAgdGhpcy5hZGQoY2VsbFZpZXcsIG5vZGUsIGlkLCBvcHQpO1xuICAgIH0sXG5cbiAgICAvLyBVc2VkIGludGVybmFsbHkgYnkgQ2VsbFZpZXcgdW5oaWdobGlnaHQoKVxuICAgIHVuaGlnaGxpZ2h0OiBmdW5jdGlvbihjZWxsVmlldywgbm9kZSwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy51bmlxdWVJZChub2RlLCBvcHQpO1xuICAgICAgICB0aGlzLnJlbW92ZShjZWxsVmlldywgaWQpO1xuICAgIH0sXG5cbiAgICBnZXQoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IGNpZCB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByZWZzID0gX3ZpZXdzW2NpZF07XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYWxsIGhpZ2hsaWdodGVyc1xuICAgICAgICAgICAgY29uc3Qgdmlld3MgPSBbXTtcbiAgICAgICAgICAgIGlmICghcmVmcykgcmV0dXJuIHZpZXdzO1xuICAgICAgICAgICAgZm9yIChsZXQgaGlkIGluIHJlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSByZWZzW2hpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2aWV3cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbmdsZSBoaWdobGlnaHRlclxuICAgICAgICAgICAgaWYgKCFyZWZzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChpZCBpbiByZWZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gcmVmc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIHRoaXMpIHJldHVybiByZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGQoY2VsbFZpZXcsIG5vZGVTZWxlY3RvciwgaWQsIG9wdCA9IHt9KSB7XG4gICAgICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignZGlhLkhpZ2hsaWdodGVyVmlldzogQW4gSUQgcmVxdWlyZWQuJyk7XG4gICAgICAgIC8vIFNlYXJjaCB0aGUgZXhpc3RpbmcgdmlldyBhbW9uZ3N0IGFsbCB0aGUgaGlnaGxpZ2h0ZXJzXG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmlldyA9IEhpZ2hsaWdodGVyVmlldy5nZXQoY2VsbFZpZXcsIGlkKTtcbiAgICAgICAgaWYgKHByZXZpb3VzVmlldykgcHJldmlvdXNWaWV3LnJlbW92ZSgpO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IHRoaXMob3B0KTtcbiAgICAgICAgdmlldy5pZCA9IGlkO1xuICAgICAgICB0aGlzLl9hZGRSZWYoY2VsbFZpZXcsIGlkLCB2aWV3KTtcbiAgICAgICAgdmlldy5yZXF1ZXN0VXBkYXRlKGNlbGxWaWV3LCBub2RlU2VsZWN0b3IpO1xuICAgICAgICB2aWV3Lmxpc3RlblRvVXBkYXRlQXR0cmlidXRlcyhjZWxsVmlldyk7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG5cbiAgICBfYWRkUmVmKGNlbGxWaWV3LCBpZCwgdmlldykge1xuICAgICAgICBjb25zdCB7IGNpZCB9ID0gY2VsbFZpZXc7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVmcyA9IF92aWV3c1tjaWRdO1xuICAgICAgICBpZiAoIXJlZnMpIHJlZnMgPSBfdmlld3NbY2lkXSA9IHt9O1xuICAgICAgICByZWZzW2lkXSA9IHZpZXc7XG4gICAgfSxcblxuICAgIF9yZW1vdmVSZWYoY2VsbFZpZXcsIGlkKSB7XG4gICAgICAgIGNvbnN0IHsgY2lkIH0gPSBjZWxsVmlldztcbiAgICAgICAgY29uc3QgeyBfdmlld3MgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlZnMgPSBfdmlld3NbY2lkXTtcbiAgICAgICAgaWYgKCFyZWZzKSByZXR1cm47XG4gICAgICAgIGlmIChpZCkgZGVsZXRlIHJlZnNbaWRdO1xuICAgICAgICBmb3IgKGxldCBfIGluIHJlZnMpIHJldHVybjtcbiAgICAgICAgZGVsZXRlIF92aWV3c1tjaWRdO1xuICAgIH0sXG5cbiAgICByZW1vdmUoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICB0b0FycmF5KHRoaXMuZ2V0KGNlbGxWaWV3LCBpZCkpLmZvckVhY2godmlldyA9PiB7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZ2V0QWxsKHBhcGVyLCBpZCA9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgdmlld3MgPSBbXTtcbiAgICAgICAgY29uc3QgeyBfdmlld3MgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGNpZCBpbiBfdmlld3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGhpZCBpbiBfdmlld3NbY2lkXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBfdmlld3NbY2lkXVtoaWRdO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmNlbGxWaWV3LnBhcGVyID09PSBwYXBlciAmJiB2aWV3IGluc3RhbmNlb2YgdGhpcyAmJiAoaWQgPT09IG51bGwgfHwgaGlkID09PSBpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld3MucHVzaCh2aWV3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXdzO1xuICAgIH0sXG5cbiAgICByZW1vdmVBbGwocGFwZXIsIGlkID0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldEFsbChwYXBlciwgaWQpLmZvckVhY2godmlldyA9PiB2aWV3LnJlbW92ZSgpKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlKGNlbGxWaWV3LCBpZCA9IG51bGwsIGRpcnR5ID0gZmFsc2UpIHtcbiAgICAgICAgdG9BcnJheSh0aGlzLmdldChjZWxsVmlldywgaWQpKS5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgaWYgKGRpcnR5IHx8IHZpZXcuVVBEQVRBQkxFKSB2aWV3LnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtKGNlbGxWaWV3LCBpZCA9IG51bGwpIHtcbiAgICAgICAgdG9BcnJheSh0aGlzLmdldChjZWxsVmlldywgaWQpKS5mb3JFYWNoKHZpZXcgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuVVBEQVRBQkxFKSB2aWV3LnRyYW5zZm9ybSgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdW5tb3VudChjZWxsVmlldywgaWQgPSBudWxsKSB7XG4gICAgICAgIHRvQXJyYXkodGhpcy5nZXQoY2VsbFZpZXcsIGlkKSkuZm9yRWFjaCh2aWV3ID0+IHZpZXcudW5tb3VudCgpKTtcbiAgICB9LFxuXG4gICAgbW91bnQoY2VsbFZpZXcsIGlkID0gbnVsbCkge1xuICAgICAgICB0b0FycmF5KHRoaXMuZ2V0KGNlbGxWaWV3LCBpZCkpLmZvckVhY2godmlldyA9PiB2aWV3Lm1vdW50KCkpO1xuICAgIH0sXG5cbiAgICB1bmlxdWVJZChub2RlLCBvcHQgPSAnJykge1xuICAgICAgICByZXR1cm4gVi5lbnN1cmVJZChub2RlKSArIEpTT04uc3RyaW5naWZ5KG9wdCk7XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/Link.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Link.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Link: function() { return /* binding */ Link; }\n/* harmony export */ });\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n\n\n\n\n// Link base model.\n// --------------------------\n\nconst Link = _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell.extend({\n\n    // may be overwritten by user to change default label (its markup, size, attrs, position)\n    defaultLabel: undefined,\n\n    // deprecated\n    // may be overwritten by user to change default label markup\n    // lower priority than defaultLabel.markup\n    labelMarkup: undefined,\n\n    // private\n    _builtins: {\n        defaultLabel: {\n            // builtin default markup:\n            // used if neither defaultLabel.markup\n            // nor label.markup is set\n            markup: [\n                {\n                    tagName: 'rect',\n                    selector: 'rect' // faster than tagName CSS selector\n                }, {\n                    tagName: 'text',\n                    selector: 'text' // faster than tagName CSS selector\n                }\n            ],\n            // builtin default attributes:\n            // applied only if builtin default markup is used\n            attrs: {\n                text: {\n                    fill: '#000000',\n                    fontSize: 14,\n                    textAnchor: 'middle',\n                    textVerticalAnchor: 'middle',\n                    pointerEvents: 'none'\n                },\n                rect: {\n                    ref: 'text',\n                    fill: '#ffffff',\n                    rx: 3,\n                    ry: 3,\n                    x: 'calc(x)',\n                    y: 'calc(y)',\n                    width: 'calc(w)',\n                    height: 'calc(h)'\n                }\n            },\n            // builtin default position:\n            // used if neither defaultLabel.position\n            // nor label.position is set\n            position: {\n                distance: 0.5\n            }\n        }\n    },\n\n    defaults: {\n        source: {},\n        target: {}\n    },\n\n    isLink: function() {\n\n        return true;\n    },\n\n    disconnect: function(opt) {\n\n        return this.set({\n            source: { x: 0, y: 0 },\n            target: { x: 0, y: 0 }\n        }, opt);\n    },\n\n    source: function(source, args, opt) {\n\n        // getter\n        if (source === undefined) {\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(this.get('source'));\n        }\n\n        // setter\n        var setSource;\n        var setOpt;\n\n        // `source` is a cell\n        // take only its `id` and combine with `args`\n        var isCellProvided = source instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell;\n        if (isCellProvided) { // three arguments\n            setSource = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setSource.id = source.id;\n            setOpt = opt;\n            return this.set('source', setSource, setOpt);\n        }\n\n        // `source` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(source);\n        if (isPointProvided) { // three arguments\n            setSource = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setSource.x = source.x;\n            setSource.y = source.y;\n            setOpt = opt;\n            return this.set('source', setSource, setOpt);\n        }\n\n        // `source` is an object\n        // no checking\n        // two arguments\n        setSource = source;\n        setOpt = args;\n        return this.set('source', setSource, setOpt);\n    },\n\n    target: function(target, args, opt) {\n\n        // getter\n        if (target === undefined) {\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(this.get('target'));\n        }\n\n        // setter\n        var setTarget;\n        var setOpt;\n\n        // `target` is a cell\n        // take only its `id` argument and combine with `args`\n        var isCellProvided = target instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_0__.Cell;\n        if (isCellProvided) { // three arguments\n            setTarget = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setTarget.id = target.id;\n            setOpt = opt;\n            return this.set('target', setTarget, setOpt);\n        }\n\n        // `target` is a point-like object\n        // for example, a g.Point\n        // take only its `x` and `y` and combine with `args`\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(target);\n        if (isPointProvided) { // three arguments\n            setTarget = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(args) || {};\n            setTarget.x = target.x;\n            setTarget.y = target.y;\n            setOpt = opt;\n            return this.set('target', setTarget, setOpt);\n        }\n\n        // `target` is an object\n        // no checking\n        // two arguments\n        setTarget = target;\n        setOpt = args;\n        return this.set('target', setTarget, setOpt);\n    },\n\n    router: function(name, args, opt) {\n\n        // getter\n        if (name === undefined) {\n            var router = this.get('router');\n            if (!router) {\n                return null;\n            }\n            if (typeof router === 'object') return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(router);\n            return router; // e.g. a function\n        }\n\n        // setter\n        var isRouterProvided = ((typeof name === 'object') || (typeof name === 'function'));\n        var localRouter = isRouterProvided ? name : { name: name, args: args };\n        var localOpt = isRouterProvided ? args : opt;\n\n        return this.set('router', localRouter, localOpt);\n    },\n\n    connector: function(name, args, opt) {\n\n        // getter\n        if (name === undefined) {\n            var connector = this.get('connector');\n            if (!connector) {\n                return null;\n            }\n            if (typeof connector === 'object') return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.clone)(connector);\n            return connector; // e.g. a function\n        }\n\n        // setter\n        var isConnectorProvided = ((typeof name === 'object' || typeof name === 'function'));\n        var localConnector = isConnectorProvided ? name : { name: name, args: args };\n        var localOpt = isConnectorProvided ? args : opt;\n\n        return this.set('connector', localConnector, localOpt);\n    },\n\n    // Labels API\n\n    // A convenient way to set labels. Currently set values will be mixined with `value` if used as a setter.\n    label: function(idx, label, opt) {\n\n        var labels = this.labels();\n\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n        if (idx < 0) idx = labels.length + idx;\n\n        // getter\n        if (arguments.length <= 1) return this.prop(['labels', idx]);\n        // setter\n        return this.prop(['labels', idx], label, opt);\n    },\n\n    labels: function(labels, opt) {\n\n        // getter\n        if (arguments.length === 0) {\n            labels = this.get('labels');\n            if (!Array.isArray(labels)) return [];\n            return labels.slice();\n        }\n        // setter\n        if (!Array.isArray(labels)) labels = [];\n        return this.set('labels', labels, opt);\n    },\n\n    hasLabels: function() {\n        const { labels } = this.attributes;\n        return Array.isArray(labels) && labels.length > 0;\n    },\n\n    insertLabel: function(idx, label, opt) {\n\n        if (!label) throw new Error('dia.Link: no label provided');\n\n        var labels = this.labels();\n        var n = labels.length;\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n        if (idx < 0) idx = n + idx + 1;\n\n        labels.splice(idx, 0, label);\n        return this.labels(labels, opt);\n    },\n\n    // convenience function\n    // add label to end of labels array\n    appendLabel: function(label, opt) {\n\n        return this.insertLabel(-1, label, opt);\n    },\n\n    removeLabel: function(idx, opt) {\n\n        var labels = this.labels();\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n        labels.splice(idx, 1);\n        return this.labels(labels, opt);\n    },\n\n    // Vertices API\n\n    vertex: function(idx, vertex, opt) {\n\n        var vertices = this.vertices();\n\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : 0;\n        if (idx < 0) idx = vertices.length + idx;\n\n        // getter\n        if (arguments.length <= 1) return this.prop(['vertices', idx]);\n\n        // setter\n        var setVertex = this._normalizeVertex(vertex);\n        return this.prop(['vertices', idx], setVertex, opt);\n    },\n\n    vertices: function(vertices, opt) {\n\n        // getter\n        if (arguments.length === 0) {\n            vertices = this.get('vertices');\n            if (!Array.isArray(vertices)) return [];\n            return vertices.slice();\n        }\n\n        // setter\n        if (!Array.isArray(vertices)) vertices = [];\n        var setVertices = [];\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            var setVertex = this._normalizeVertex(vertex);\n            setVertices.push(setVertex);\n        }\n        return this.set('vertices', setVertices, opt);\n    },\n\n    insertVertex: function(idx, vertex, opt) {\n\n        if (!vertex) throw new Error('dia.Link: no vertex provided');\n\n        var vertices = this.vertices();\n        var n = vertices.length;\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : n;\n        if (idx < 0) idx = n + idx + 1;\n\n        var setVertex = this._normalizeVertex(vertex);\n        vertices.splice(idx, 0, setVertex);\n        return this.vertices(vertices, opt);\n    },\n\n    removeVertex: function(idx, opt) {\n\n        var vertices = this.vertices();\n        idx = (isFinite(idx) && idx !== null) ? (idx | 0) : -1;\n\n        vertices.splice(idx, 1);\n        return this.vertices(vertices, opt);\n    },\n\n    _normalizeVertex: function(vertex) {\n\n        // is vertex a point-like object?\n        // for example, a g.Point\n        var isPointProvided = !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(vertex);\n        if (isPointProvided) return { x: vertex.x, y: vertex.y };\n\n        // else: return vertex unchanged\n        return vertex;\n    },\n\n    // Transformations\n\n    translate: function(tx, ty, opt) {\n\n        // enrich the option object\n        opt = opt || {};\n        opt.translateBy = opt.translateBy || this.id;\n        opt.tx = tx;\n        opt.ty = ty;\n\n        return this.applyToPoints(function(p) {\n            return { x: (p.x || 0) + tx, y: (p.y || 0) + ty };\n        }, opt);\n    },\n\n    scale: function(sx, sy, origin, opt) {\n\n        return this.applyToPoints(function(p) {\n            return (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point)(p).scale(sx, sy, origin).toJSON();\n        }, opt);\n    },\n\n    applyToPoints: function(fn, opt) {\n\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fn)) {\n            throw new TypeError('dia.Link: applyToPoints expects its first parameter to be a function.');\n        }\n\n        var attrs = {};\n\n        var { source, target } = this.attributes;\n        if (!source.id) {\n            attrs.source = fn(source);\n        }\n        if (!target.id) {\n            attrs.target = fn(target);\n        }\n\n        var vertices = this.vertices();\n        if (vertices.length > 0) {\n            attrs.vertices = vertices.map(fn);\n        }\n\n        return this.set(attrs, opt);\n    },\n\n    getSourcePoint: function() {\n        var sourceCell = this.getSourceCell();\n        if (!sourceCell) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(this.source());\n        return sourceCell.getPointFromConnectedLink(this, 'source');\n    },\n\n    getTargetPoint: function() {\n        var targetCell = this.getTargetCell();\n        if (!targetCell) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(this.target());\n        return targetCell.getPointFromConnectedLink(this, 'target');\n    },\n\n    getPointFromConnectedLink: function(/* link, endType */) {\n        return this.getPolyline().pointAt(0.5);\n    },\n\n    getPolyline: function() {\n        const points = [\n            this.getSourcePoint(),\n            ...this.vertices().map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point),\n            this.getTargetPoint()\n        ];\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline(points);\n    },\n\n    getBBox: function() {\n        return this.getPolyline().bbox();\n    },\n\n    reparent: function(opt) {\n\n        var newParent;\n\n        if (this.graph) {\n\n            var source = this.getSourceElement();\n            var target = this.getTargetElement();\n            var prevParent = this.getParentCell();\n\n            if (source && target) {\n                if (source === target || source.isEmbeddedIn(target)) {\n                    newParent = target;\n                } else if (target.isEmbeddedIn(source)) {\n                    newParent = source;\n                } else {\n                    newParent = this.graph.getCommonAncestor(source, target);\n                }\n            }\n\n            if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n                // Unembed the link if source and target has no common ancestor\n                // or common ancestor changed\n                prevParent.unembed(this, opt);\n            }\n\n            if (newParent) {\n                newParent.embed(this, opt);\n            }\n        }\n\n        return newParent;\n    },\n\n    hasLoop: function(opt) {\n\n        opt = opt || {};\n\n        var { source, target } = this.attributes;\n        var sourceId = source.id;\n        var targetId = target.id;\n\n        if (!sourceId || !targetId) {\n            // Link \"pinned\" to the paper does not have a loop.\n            return false;\n        }\n\n        var loop = sourceId === targetId;\n\n        // Note that there in the deep mode a link can have a loop,\n        // even if it connects only a parent and its embed.\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\n        if (!loop && opt.deep && this.graph) {\n\n            var sourceElement = this.getSourceCell();\n            var targetElement = this.getTargetCell();\n\n            loop = sourceElement.isEmbeddedIn(targetElement) || targetElement.isEmbeddedIn(sourceElement);\n        }\n\n        return loop;\n    },\n\n    // unlike source(), this method returns null if source is a point\n    getSourceCell: function() {\n\n        const { graph, attributes } = this;\n        var source = attributes.source;\n        return (source && source.id && graph && graph.getCell(source.id)) || null;\n    },\n\n    getSourceElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getSourceCell();\n        } while (cell && cell.isLink());\n        return cell;\n    },\n\n    // unlike target(), this method returns null if target is a point\n    getTargetCell: function() {\n\n        const { graph, attributes } = this;\n        var target = attributes.target;\n        return (target && target.id && graph && graph.getCell(target.id)) || null;\n    },\n\n    getTargetElement: function() {\n        var cell = this;\n        var visited = {};\n        do {\n            if (visited[cell.id]) return null;\n            visited[cell.id] = true;\n            cell = cell.getTargetCell();\n        } while (cell && cell.isLink());\n        return cell;\n    },\n\n    // Returns the common ancestor for the source element,\n    // target element and the link itself.\n    getRelationshipAncestor: function() {\n\n        var connectionAncestor;\n\n        if (this.graph) {\n\n            var cells = [\n                this,\n                this.getSourceElement(), // null if source is a point\n                this.getTargetElement() // null if target is a point\n            ].filter(function(item) {\n                return !!item;\n            });\n\n            connectionAncestor = this.graph.getCommonAncestor.apply(this.graph, cells);\n        }\n\n        return connectionAncestor || null;\n    },\n\n    // Is source, target and the link itself embedded in a given cell?\n    isRelationshipEmbeddedIn: function(cell) {\n\n        var cellId = ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(cell) || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber)(cell)) ? cell : cell.id;\n        var ancestor = this.getRelationshipAncestor();\n\n        return !!ancestor && (ancestor.id === cellId || ancestor.isEmbeddedIn(cellId));\n    },\n\n    // Get resolved default label.\n    _getDefaultLabel: function() {\n\n        var defaultLabel = this.get('defaultLabel') || this.defaultLabel || {};\n\n        var label = {};\n        label.markup = defaultLabel.markup || this.get('labelMarkup') || this.labelMarkup;\n        label.position = defaultLabel.position;\n        label.attrs = defaultLabel.attrs;\n        label.size = defaultLabel.size;\n\n        return label;\n    }\n}, {\n\n    endsEqual: function(a, b) {\n\n        var portsEqual = a.port === b.port || !a.port && !b.port;\n        return a.id === b.id && portsEqual;\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0xpbmsubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWtDO0FBQ3VEO0FBQ3hDOztBQUVqRDtBQUNBOztBQUVPLGFBQWEsMkNBQUk7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxzQkFBc0I7QUFDdEIsU0FBUztBQUNULEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzREFBSztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQywyQ0FBSTtBQUNuRCw4QkFBOEI7QUFDOUIsd0JBQXdCLHNEQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4REFBYTtBQUM1QywrQkFBK0I7QUFDL0Isd0JBQXdCLHNEQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLHNEQUFLO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLDJDQUFJO0FBQ25ELDhCQUE4QjtBQUM5Qix3QkFBd0Isc0RBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhEQUFhO0FBQzVDLCtCQUErQjtBQUMvQix3QkFBd0Isc0RBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzREFBSztBQUN4RCwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHNEQUFLO0FBQzNELDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDhEQUFhO0FBQzVDLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLG1CQUFtQixtREFBSztBQUN4QixTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQSxhQUFhLDJEQUFVO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFLO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esb0NBQW9DLCtDQUFLO0FBQ3pDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQUs7QUFDeEM7QUFDQTtBQUNBLG1CQUFtQixrREFBUTtBQUMzQixLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSxzQkFBc0IseURBQVEsVUFBVSx5REFBUTtBQUNoRDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvTGluay5tanM/MTcxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsIH0gZnJvbSAnLi9DZWxsLm1qcyc7XG5pbXBvcnQgeyBjbG9uZSwgaXNQbGFpbk9iamVjdCwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgUG9pbnQsIFBvbHlsaW5lIH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG4vLyBMaW5rIGJhc2UgbW9kZWwuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgTGluayA9IENlbGwuZXh0ZW5kKHtcblxuICAgIC8vIG1heSBiZSBvdmVyd3JpdHRlbiBieSB1c2VyIHRvIGNoYW5nZSBkZWZhdWx0IGxhYmVsIChpdHMgbWFya3VwLCBzaXplLCBhdHRycywgcG9zaXRpb24pXG4gICAgZGVmYXVsdExhYmVsOiB1bmRlZmluZWQsXG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgLy8gbWF5IGJlIG92ZXJ3cml0dGVuIGJ5IHVzZXIgdG8gY2hhbmdlIGRlZmF1bHQgbGFiZWwgbWFya3VwXG4gICAgLy8gbG93ZXIgcHJpb3JpdHkgdGhhbiBkZWZhdWx0TGFiZWwubWFya3VwXG4gICAgbGFiZWxNYXJrdXA6IHVuZGVmaW5lZCxcblxuICAgIC8vIHByaXZhdGVcbiAgICBfYnVpbHRpbnM6IHtcbiAgICAgICAgZGVmYXVsdExhYmVsOiB7XG4gICAgICAgICAgICAvLyBidWlsdGluIGRlZmF1bHQgbWFya3VwOlxuICAgICAgICAgICAgLy8gdXNlZCBpZiBuZWl0aGVyIGRlZmF1bHRMYWJlbC5tYXJrdXBcbiAgICAgICAgICAgIC8vIG5vciBsYWJlbC5tYXJrdXAgaXMgc2V0XG4gICAgICAgICAgICBtYXJrdXA6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdyZWN0JyAvLyBmYXN0ZXIgdGhhbiB0YWdOYW1lIENTUyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3RleHQnIC8vIGZhc3RlciB0aGFuIHRhZ05hbWUgQ1NTIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8vIGJ1aWx0aW4gZGVmYXVsdCBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgLy8gYXBwbGllZCBvbmx5IGlmIGJ1aWx0aW4gZGVmYXVsdCBtYXJrdXAgaXMgdXNlZFxuICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICAgIHJ4OiAzLFxuICAgICAgICAgICAgICAgICAgICByeTogMyxcbiAgICAgICAgICAgICAgICAgICAgeDogJ2NhbGMoeCknLFxuICAgICAgICAgICAgICAgICAgICB5OiAnY2FsYyh5KScsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaCknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGJ1aWx0aW4gZGVmYXVsdCBwb3NpdGlvbjpcbiAgICAgICAgICAgIC8vIHVzZWQgaWYgbmVpdGhlciBkZWZhdWx0TGFiZWwucG9zaXRpb25cbiAgICAgICAgICAgIC8vIG5vciBsYWJlbC5wb3NpdGlvbiBpcyBzZXRcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IDAuNVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHNvdXJjZToge30sXG4gICAgICAgIHRhcmdldDoge31cbiAgICB9LFxuXG4gICAgaXNMaW5rOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZGlzY29ubmVjdDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICAgIHNvdXJjZTogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICB0YXJnZXQ6IHsgeDogMCwgeTogMCB9XG4gICAgICAgIH0sIG9wdCk7XG4gICAgfSxcblxuICAgIHNvdXJjZTogZnVuY3Rpb24oc291cmNlLCBhcmdzLCBvcHQpIHtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUodGhpcy5nZXQoJ3NvdXJjZScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgc2V0U291cmNlO1xuICAgICAgICB2YXIgc2V0T3B0O1xuXG4gICAgICAgIC8vIGBzb3VyY2VgIGlzIGEgY2VsbFxuICAgICAgICAvLyB0YWtlIG9ubHkgaXRzIGBpZGAgYW5kIGNvbWJpbmUgd2l0aCBgYXJnc2BcbiAgICAgICAgdmFyIGlzQ2VsbFByb3ZpZGVkID0gc291cmNlIGluc3RhbmNlb2YgQ2VsbDtcbiAgICAgICAgaWYgKGlzQ2VsbFByb3ZpZGVkKSB7IC8vIHRocmVlIGFyZ3VtZW50c1xuICAgICAgICAgICAgc2V0U291cmNlID0gY2xvbmUoYXJncykgfHwge307XG4gICAgICAgICAgICBzZXRTb3VyY2UuaWQgPSBzb3VyY2UuaWQ7XG4gICAgICAgICAgICBzZXRPcHQgPSBvcHQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3NvdXJjZScsIHNldFNvdXJjZSwgc2V0T3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBzb3VyY2VgIGlzIGEgcG9pbnQtbGlrZSBvYmplY3RcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgZy5Qb2ludFxuICAgICAgICAvLyB0YWtlIG9ubHkgaXRzIGB4YCBhbmQgYHlgIGFuZCBjb21iaW5lIHdpdGggYGFyZ3NgXG4gICAgICAgIHZhciBpc1BvaW50UHJvdmlkZWQgPSAhaXNQbGFpbk9iamVjdChzb3VyY2UpO1xuICAgICAgICBpZiAoaXNQb2ludFByb3ZpZGVkKSB7IC8vIHRocmVlIGFyZ3VtZW50c1xuICAgICAgICAgICAgc2V0U291cmNlID0gY2xvbmUoYXJncykgfHwge307XG4gICAgICAgICAgICBzZXRTb3VyY2UueCA9IHNvdXJjZS54O1xuICAgICAgICAgICAgc2V0U291cmNlLnkgPSBzb3VyY2UueTtcbiAgICAgICAgICAgIHNldE9wdCA9IG9wdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCgnc291cmNlJywgc2V0U291cmNlLCBzZXRPcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHNvdXJjZWAgaXMgYW4gb2JqZWN0XG4gICAgICAgIC8vIG5vIGNoZWNraW5nXG4gICAgICAgIC8vIHR3byBhcmd1bWVudHNcbiAgICAgICAgc2V0U291cmNlID0gc291cmNlO1xuICAgICAgICBzZXRPcHQgPSBhcmdzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3NvdXJjZScsIHNldFNvdXJjZSwgc2V0T3B0KTtcbiAgICB9LFxuXG4gICAgdGFyZ2V0OiBmdW5jdGlvbih0YXJnZXQsIGFyZ3MsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZSh0aGlzLmdldCgndGFyZ2V0JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0dGVyXG4gICAgICAgIHZhciBzZXRUYXJnZXQ7XG4gICAgICAgIHZhciBzZXRPcHQ7XG5cbiAgICAgICAgLy8gYHRhcmdldGAgaXMgYSBjZWxsXG4gICAgICAgIC8vIHRha2Ugb25seSBpdHMgYGlkYCBhcmd1bWVudCBhbmQgY29tYmluZSB3aXRoIGBhcmdzYFxuICAgICAgICB2YXIgaXNDZWxsUHJvdmlkZWQgPSB0YXJnZXQgaW5zdGFuY2VvZiBDZWxsO1xuICAgICAgICBpZiAoaXNDZWxsUHJvdmlkZWQpIHsgLy8gdGhyZWUgYXJndW1lbnRzXG4gICAgICAgICAgICBzZXRUYXJnZXQgPSBjbG9uZShhcmdzKSB8fCB7fTtcbiAgICAgICAgICAgIHNldFRhcmdldC5pZCA9IHRhcmdldC5pZDtcbiAgICAgICAgICAgIHNldE9wdCA9IG9wdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldCgndGFyZ2V0Jywgc2V0VGFyZ2V0LCBzZXRPcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHRhcmdldGAgaXMgYSBwb2ludC1saWtlIG9iamVjdFxuICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBnLlBvaW50XG4gICAgICAgIC8vIHRha2Ugb25seSBpdHMgYHhgIGFuZCBgeWAgYW5kIGNvbWJpbmUgd2l0aCBgYXJnc2BcbiAgICAgICAgdmFyIGlzUG9pbnRQcm92aWRlZCA9ICFpc1BsYWluT2JqZWN0KHRhcmdldCk7XG4gICAgICAgIGlmIChpc1BvaW50UHJvdmlkZWQpIHsgLy8gdGhyZWUgYXJndW1lbnRzXG4gICAgICAgICAgICBzZXRUYXJnZXQgPSBjbG9uZShhcmdzKSB8fCB7fTtcbiAgICAgICAgICAgIHNldFRhcmdldC54ID0gdGFyZ2V0Lng7XG4gICAgICAgICAgICBzZXRUYXJnZXQueSA9IHRhcmdldC55O1xuICAgICAgICAgICAgc2V0T3B0ID0gb3B0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCd0YXJnZXQnLCBzZXRUYXJnZXQsIHNldE9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBgdGFyZ2V0YCBpcyBhbiBvYmplY3RcbiAgICAgICAgLy8gbm8gY2hlY2tpbmdcbiAgICAgICAgLy8gdHdvIGFyZ3VtZW50c1xuICAgICAgICBzZXRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHNldE9wdCA9IGFyZ3M7XG4gICAgICAgIHJldHVybiB0aGlzLnNldCgndGFyZ2V0Jywgc2V0VGFyZ2V0LCBzZXRPcHQpO1xuICAgIH0sXG5cbiAgICByb3V0ZXI6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5nZXQoJ3JvdXRlcicpO1xuICAgICAgICAgICAgaWYgKCFyb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygcm91dGVyID09PSAnb2JqZWN0JykgcmV0dXJuIGNsb25lKHJvdXRlcik7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyOyAvLyBlLmcuIGEgZnVuY3Rpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgaXNSb3V0ZXJQcm92aWRlZCA9ICgodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB8fCAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpKTtcbiAgICAgICAgdmFyIGxvY2FsUm91dGVyID0gaXNSb3V0ZXJQcm92aWRlZCA/IG5hbWUgOiB7IG5hbWU6IG5hbWUsIGFyZ3M6IGFyZ3MgfTtcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0gaXNSb3V0ZXJQcm92aWRlZCA/IGFyZ3MgOiBvcHQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KCdyb3V0ZXInLCBsb2NhbFJvdXRlciwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICBjb25uZWN0b3I6IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdCkge1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdG9yID0gdGhpcy5nZXQoJ2Nvbm5lY3RvcicpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29ubmVjdG9yID09PSAnb2JqZWN0JykgcmV0dXJuIGNsb25lKGNvbm5lY3Rvcik7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdG9yOyAvLyBlLmcuIGEgZnVuY3Rpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICB2YXIgaXNDb25uZWN0b3JQcm92aWRlZCA9ICgodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSk7XG4gICAgICAgIHZhciBsb2NhbENvbm5lY3RvciA9IGlzQ29ubmVjdG9yUHJvdmlkZWQgPyBuYW1lIDogeyBuYW1lOiBuYW1lLCBhcmdzOiBhcmdzIH07XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IGlzQ29ubmVjdG9yUHJvdmlkZWQgPyBhcmdzIDogb3B0O1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldCgnY29ubmVjdG9yJywgbG9jYWxDb25uZWN0b3IsIGxvY2FsT3B0KTtcbiAgICB9LFxuXG4gICAgLy8gTGFiZWxzIEFQSVxuXG4gICAgLy8gQSBjb252ZW5pZW50IHdheSB0byBzZXQgbGFiZWxzLiBDdXJyZW50bHkgc2V0IHZhbHVlcyB3aWxsIGJlIG1peGluZWQgd2l0aCBgdmFsdWVgIGlmIHVzZWQgYXMgYSBzZXR0ZXIuXG4gICAgbGFiZWw6IGZ1bmN0aW9uKGlkeCwgbGFiZWwsIG9wdCkge1xuXG4gICAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscygpO1xuXG4gICAgICAgIGlkeCA9IChpc0Zpbml0ZShpZHgpICYmIGlkeCAhPT0gbnVsbCkgPyAoaWR4IHwgMCkgOiAwO1xuICAgICAgICBpZiAoaWR4IDwgMCkgaWR4ID0gbGFiZWxzLmxlbmd0aCArIGlkeDtcblxuICAgICAgICAvLyBnZXR0ZXJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkgcmV0dXJuIHRoaXMucHJvcChbJ2xhYmVscycsIGlkeF0pO1xuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcChbJ2xhYmVscycsIGlkeF0sIGxhYmVsLCBvcHQpO1xuICAgIH0sXG5cbiAgICBsYWJlbHM6IGZ1bmN0aW9uKGxhYmVscywgb3B0KSB7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsYWJlbHMgPSB0aGlzLmdldCgnbGFiZWxzJyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFiZWxzKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVscy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGFiZWxzKSkgbGFiZWxzID0gW107XG4gICAgICAgIHJldHVybiB0aGlzLnNldCgnbGFiZWxzJywgbGFiZWxzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBoYXNMYWJlbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGxhYmVscyB9ID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShsYWJlbHMpICYmIGxhYmVscy5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICBpbnNlcnRMYWJlbDogZnVuY3Rpb24oaWR4LCBsYWJlbCwgb3B0KSB7XG5cbiAgICAgICAgaWYgKCFsYWJlbCkgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGluazogbm8gbGFiZWwgcHJvdmlkZWQnKTtcblxuICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5sYWJlbHMoKTtcbiAgICAgICAgdmFyIG4gPSBsYWJlbHMubGVuZ3RoO1xuICAgICAgICBpZHggPSAoaXNGaW5pdGUoaWR4KSAmJiBpZHggIT09IG51bGwpID8gKGlkeCB8IDApIDogbjtcbiAgICAgICAgaWYgKGlkeCA8IDApIGlkeCA9IG4gKyBpZHggKyAxO1xuXG4gICAgICAgIGxhYmVscy5zcGxpY2UoaWR4LCAwLCBsYWJlbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVscyhsYWJlbHMsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9uXG4gICAgLy8gYWRkIGxhYmVsIHRvIGVuZCBvZiBsYWJlbHMgYXJyYXlcbiAgICBhcHBlbmRMYWJlbDogZnVuY3Rpb24obGFiZWwsIG9wdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydExhYmVsKC0xLCBsYWJlbCwgb3B0KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTGFiZWw6IGZ1bmN0aW9uKGlkeCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzKCk7XG4gICAgICAgIGlkeCA9IChpc0Zpbml0ZShpZHgpICYmIGlkeCAhPT0gbnVsbCkgPyAoaWR4IHwgMCkgOiAtMTtcblxuICAgICAgICBsYWJlbHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVscyhsYWJlbHMsIG9wdCk7XG4gICAgfSxcblxuICAgIC8vIFZlcnRpY2VzIEFQSVxuXG4gICAgdmVydGV4OiBmdW5jdGlvbihpZHgsIHZlcnRleCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcygpO1xuXG4gICAgICAgIGlkeCA9IChpc0Zpbml0ZShpZHgpICYmIGlkeCAhPT0gbnVsbCkgPyAoaWR4IHwgMCkgOiAwO1xuICAgICAgICBpZiAoaWR4IDwgMCkgaWR4ID0gdmVydGljZXMubGVuZ3RoICsgaWR4O1xuXG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSByZXR1cm4gdGhpcy5wcm9wKFsndmVydGljZXMnLCBpZHhdKTtcblxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgdmFyIHNldFZlcnRleCA9IHRoaXMuX25vcm1hbGl6ZVZlcnRleCh2ZXJ0ZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wKFsndmVydGljZXMnLCBpZHhdLCBzZXRWZXJ0ZXgsIG9wdCk7XG4gICAgfSxcblxuICAgIHZlcnRpY2VzOiBmdW5jdGlvbih2ZXJ0aWNlcywgb3B0KSB7XG5cbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IHRoaXMuZ2V0KCd2ZXJ0aWNlcycpO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZlcnRpY2VzKSkgcmV0dXJuIFtdO1xuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZlcnRpY2VzKSkgdmVydGljZXMgPSBbXTtcbiAgICAgICAgdmFyIHNldFZlcnRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciBzZXRWZXJ0ZXggPSB0aGlzLl9ub3JtYWxpemVWZXJ0ZXgodmVydGV4KTtcbiAgICAgICAgICAgIHNldFZlcnRpY2VzLnB1c2goc2V0VmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoJ3ZlcnRpY2VzJywgc2V0VmVydGljZXMsIG9wdCk7XG4gICAgfSxcblxuICAgIGluc2VydFZlcnRleDogZnVuY3Rpb24oaWR4LCB2ZXJ0ZXgsIG9wdCkge1xuXG4gICAgICAgIGlmICghdmVydGV4KSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rOiBubyB2ZXJ0ZXggcHJvdmlkZWQnKTtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzKCk7XG4gICAgICAgIHZhciBuID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICBpZHggPSAoaXNGaW5pdGUoaWR4KSAmJiBpZHggIT09IG51bGwpID8gKGlkeCB8IDApIDogbjtcbiAgICAgICAgaWYgKGlkeCA8IDApIGlkeCA9IG4gKyBpZHggKyAxO1xuXG4gICAgICAgIHZhciBzZXRWZXJ0ZXggPSB0aGlzLl9ub3JtYWxpemVWZXJ0ZXgodmVydGV4KTtcbiAgICAgICAgdmVydGljZXMuc3BsaWNlKGlkeCwgMCwgc2V0VmVydGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXModmVydGljZXMsIG9wdCk7XG4gICAgfSxcblxuICAgIHJlbW92ZVZlcnRleDogZnVuY3Rpb24oaWR4LCBvcHQpIHtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzKCk7XG4gICAgICAgIGlkeCA9IChpc0Zpbml0ZShpZHgpICYmIGlkeCAhPT0gbnVsbCkgPyAoaWR4IHwgMCkgOiAtMTtcblxuICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXModmVydGljZXMsIG9wdCk7XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemVWZXJ0ZXg6IGZ1bmN0aW9uKHZlcnRleCkge1xuXG4gICAgICAgIC8vIGlzIHZlcnRleCBhIHBvaW50LWxpa2Ugb2JqZWN0P1xuICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBnLlBvaW50XG4gICAgICAgIHZhciBpc1BvaW50UHJvdmlkZWQgPSAhaXNQbGFpbk9iamVjdCh2ZXJ0ZXgpO1xuICAgICAgICBpZiAoaXNQb2ludFByb3ZpZGVkKSByZXR1cm4geyB4OiB2ZXJ0ZXgueCwgeTogdmVydGV4LnkgfTtcblxuICAgICAgICAvLyBlbHNlOiByZXR1cm4gdmVydGV4IHVuY2hhbmdlZFxuICAgICAgICByZXR1cm4gdmVydGV4O1xuICAgIH0sXG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnNcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5LCBvcHQpIHtcblxuICAgICAgICAvLyBlbnJpY2ggdGhlIG9wdGlvbiBvYmplY3RcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICBvcHQudHJhbnNsYXRlQnkgPSBvcHQudHJhbnNsYXRlQnkgfHwgdGhpcy5pZDtcbiAgICAgICAgb3B0LnR4ID0gdHg7XG4gICAgICAgIG9wdC50eSA9IHR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VG9Qb2ludHMoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogKHAueCB8fCAwKSArIHR4LCB5OiAocC55IHx8IDApICsgdHkgfTtcbiAgICAgICAgfSwgb3B0KTtcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgb3JpZ2luLCBvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRvUG9pbnRzKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludChwKS5zY2FsZShzeCwgc3ksIG9yaWdpbikudG9KU09OKCk7XG4gICAgICAgIH0sIG9wdCk7XG4gICAgfSxcblxuICAgIGFwcGx5VG9Qb2ludHM6IGZ1bmN0aW9uKGZuLCBvcHQpIHtcblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuTGluazogYXBwbHlUb1BvaW50cyBleHBlY3RzIGl0cyBmaXJzdCBwYXJhbWV0ZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuXG4gICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmICghc291cmNlLmlkKSB7XG4gICAgICAgICAgICBhdHRycy5zb3VyY2UgPSBmbihzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0LmlkKSB7XG4gICAgICAgICAgICBhdHRycy50YXJnZXQgPSBmbih0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcygpO1xuICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXR0cnMudmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAoZm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBnZXRTb3VyY2VQb2ludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzb3VyY2VDZWxsID0gdGhpcy5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgIGlmICghc291cmNlQ2VsbCkgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnNvdXJjZSgpKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZUNlbGwuZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluayh0aGlzLCAnc291cmNlJyk7XG4gICAgfSxcblxuICAgIGdldFRhcmdldFBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRhcmdldENlbGwgPSB0aGlzLmdldFRhcmdldENlbGwoKTtcbiAgICAgICAgaWYgKCF0YXJnZXRDZWxsKSByZXR1cm4gbmV3IFBvaW50KHRoaXMudGFyZ2V0KCkpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0Q2VsbC5nZXRQb2ludEZyb21Db25uZWN0ZWRMaW5rKHRoaXMsICd0YXJnZXQnKTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRGcm9tQ29ubmVjdGVkTGluazogZnVuY3Rpb24oLyogbGluaywgZW5kVHlwZSAqLykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2x5bGluZSgpLnBvaW50QXQoMC41KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9seWxpbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICAgICAgICB0aGlzLmdldFNvdXJjZVBvaW50KCksXG4gICAgICAgICAgICAuLi50aGlzLnZlcnRpY2VzKCkubWFwKFBvaW50KSxcbiAgICAgICAgICAgIHRoaXMuZ2V0VGFyZ2V0UG9pbnQoKVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlsaW5lKHBvaW50cyk7XG4gICAgfSxcblxuICAgIGdldEJCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2x5bGluZSgpLmJib3goKTtcbiAgICB9LFxuXG4gICAgcmVwYXJlbnQ6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBuZXdQYXJlbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JhcGgpIHtcblxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlRWxlbWVudCgpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgdmFyIHByZXZQYXJlbnQgPSB0aGlzLmdldFBhcmVudENlbGwoKTtcblxuICAgICAgICAgICAgaWYgKHNvdXJjZSAmJiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlID09PSB0YXJnZXQgfHwgc291cmNlLmlzRW1iZWRkZWRJbih0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5pc0VtYmVkZGVkSW4oc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQgPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50ID0gdGhpcy5ncmFwaC5nZXRDb21tb25BbmNlc3Rvcihzb3VyY2UsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldlBhcmVudCAmJiAoIW5ld1BhcmVudCB8fCBuZXdQYXJlbnQuaWQgIT09IHByZXZQYXJlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5lbWJlZCB0aGUgbGluayBpZiBzb3VyY2UgYW5kIHRhcmdldCBoYXMgbm8gY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgLy8gb3IgY29tbW9uIGFuY2VzdG9yIGNoYW5nZWRcbiAgICAgICAgICAgICAgICBwcmV2UGFyZW50LnVuZW1iZWQodGhpcywgb3B0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1BhcmVudCkge1xuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5lbWJlZCh0aGlzLCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1BhcmVudDtcbiAgICB9LFxuXG4gICAgaGFzTG9vcDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciB7IHNvdXJjZSwgdGFyZ2V0IH0gPSB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBzb3VyY2VJZCA9IHNvdXJjZS5pZDtcbiAgICAgICAgdmFyIHRhcmdldElkID0gdGFyZ2V0LmlkO1xuXG4gICAgICAgIGlmICghc291cmNlSWQgfHwgIXRhcmdldElkKSB7XG4gICAgICAgICAgICAvLyBMaW5rIFwicGlubmVkXCIgdG8gdGhlIHBhcGVyIGRvZXMgbm90IGhhdmUgYSBsb29wLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvb3AgPSBzb3VyY2VJZCA9PT0gdGFyZ2V0SWQ7XG5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoZXJlIGluIHRoZSBkZWVwIG1vZGUgYSBsaW5rIGNhbiBoYXZlIGEgbG9vcCxcbiAgICAgICAgLy8gZXZlbiBpZiBpdCBjb25uZWN0cyBvbmx5IGEgcGFyZW50IGFuZCBpdHMgZW1iZWQuXG4gICAgICAgIC8vIEEgbG9vcCBcInRhcmdldCBlcXVhbHMgc291cmNlXCIgaXMgdmFsaWQgaW4gYm90aCBzaGFsbG93IGFuZCBkZWVwIG1vZGUuXG4gICAgICAgIGlmICghbG9vcCAmJiBvcHQuZGVlcCAmJiB0aGlzLmdyYXBoKSB7XG5cbiAgICAgICAgICAgIHZhciBzb3VyY2VFbGVtZW50ID0gdGhpcy5nZXRTb3VyY2VDZWxsKCk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0Q2VsbCgpO1xuXG4gICAgICAgICAgICBsb29wID0gc291cmNlRWxlbWVudC5pc0VtYmVkZGVkSW4odGFyZ2V0RWxlbWVudCkgfHwgdGFyZ2V0RWxlbWVudC5pc0VtYmVkZGVkSW4oc291cmNlRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9vcDtcbiAgICB9LFxuXG4gICAgLy8gdW5saWtlIHNvdXJjZSgpLCB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwgaWYgc291cmNlIGlzIGEgcG9pbnRcbiAgICBnZXRTb3VyY2VDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCB7IGdyYXBoLCBhdHRyaWJ1dGVzIH0gPSB0aGlzO1xuICAgICAgICB2YXIgc291cmNlID0gYXR0cmlidXRlcy5zb3VyY2U7XG4gICAgICAgIHJldHVybiAoc291cmNlICYmIHNvdXJjZS5pZCAmJiBncmFwaCAmJiBncmFwaC5nZXRDZWxsKHNvdXJjZS5pZCkpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldFNvdXJjZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXM7XG4gICAgICAgIHZhciB2aXNpdGVkID0ge307XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2NlbGwuaWRdKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZpc2l0ZWRbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwuZ2V0U291cmNlQ2VsbCgpO1xuICAgICAgICB9IHdoaWxlIChjZWxsICYmIGNlbGwuaXNMaW5rKCkpO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgLy8gdW5saWtlIHRhcmdldCgpLCB0aGlzIG1ldGhvZCByZXR1cm5zIG51bGwgaWYgdGFyZ2V0IGlzIGEgcG9pbnRcbiAgICBnZXRUYXJnZXRDZWxsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCB7IGdyYXBoLCBhdHRyaWJ1dGVzIH0gPSB0aGlzO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gYXR0cmlidXRlcy50YXJnZXQ7XG4gICAgICAgIHJldHVybiAodGFyZ2V0ICYmIHRhcmdldC5pZCAmJiBncmFwaCAmJiBncmFwaC5nZXRDZWxsKHRhcmdldC5pZCkpIHx8IG51bGw7XG4gICAgfSxcblxuICAgIGdldFRhcmdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXM7XG4gICAgICAgIHZhciB2aXNpdGVkID0ge307XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2NlbGwuaWRdKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZpc2l0ZWRbY2VsbC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgY2VsbCA9IGNlbGwuZ2V0VGFyZ2V0Q2VsbCgpO1xuICAgICAgICB9IHdoaWxlIChjZWxsICYmIGNlbGwuaXNMaW5rKCkpO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgY29tbW9uIGFuY2VzdG9yIGZvciB0aGUgc291cmNlIGVsZW1lbnQsXG4gICAgLy8gdGFyZ2V0IGVsZW1lbnQgYW5kIHRoZSBsaW5rIGl0c2VsZi5cbiAgICBnZXRSZWxhdGlvbnNoaXBBbmNlc3RvcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25BbmNlc3RvcjtcblxuICAgICAgICBpZiAodGhpcy5ncmFwaCkge1xuXG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBbXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICB0aGlzLmdldFNvdXJjZUVsZW1lbnQoKSwgLy8gbnVsbCBpZiBzb3VyY2UgaXMgYSBwb2ludFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGFyZ2V0RWxlbWVudCgpIC8vIG51bGwgaWYgdGFyZ2V0IGlzIGEgcG9pbnRcbiAgICAgICAgICAgIF0uZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFpdGVtO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb25BbmNlc3RvciA9IHRoaXMuZ3JhcGguZ2V0Q29tbW9uQW5jZXN0b3IuYXBwbHkodGhpcy5ncmFwaCwgY2VsbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25BbmNlc3RvciB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBJcyBzb3VyY2UsIHRhcmdldCBhbmQgdGhlIGxpbmsgaXRzZWxmIGVtYmVkZGVkIGluIGEgZ2l2ZW4gY2VsbD9cbiAgICBpc1JlbGF0aW9uc2hpcEVtYmVkZGVkSW46IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICB2YXIgY2VsbElkID0gKGlzU3RyaW5nKGNlbGwpIHx8IGlzTnVtYmVyKGNlbGwpKSA/IGNlbGwgOiBjZWxsLmlkO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSB0aGlzLmdldFJlbGF0aW9uc2hpcEFuY2VzdG9yKCk7XG5cbiAgICAgICAgcmV0dXJuICEhYW5jZXN0b3IgJiYgKGFuY2VzdG9yLmlkID09PSBjZWxsSWQgfHwgYW5jZXN0b3IuaXNFbWJlZGRlZEluKGNlbGxJZCkpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgcmVzb2x2ZWQgZGVmYXVsdCBsYWJlbC5cbiAgICBfZ2V0RGVmYXVsdExhYmVsOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZGVmYXVsdExhYmVsID0gdGhpcy5nZXQoJ2RlZmF1bHRMYWJlbCcpIHx8IHRoaXMuZGVmYXVsdExhYmVsIHx8IHt9O1xuXG4gICAgICAgIHZhciBsYWJlbCA9IHt9O1xuICAgICAgICBsYWJlbC5tYXJrdXAgPSBkZWZhdWx0TGFiZWwubWFya3VwIHx8IHRoaXMuZ2V0KCdsYWJlbE1hcmt1cCcpIHx8IHRoaXMubGFiZWxNYXJrdXA7XG4gICAgICAgIGxhYmVsLnBvc2l0aW9uID0gZGVmYXVsdExhYmVsLnBvc2l0aW9uO1xuICAgICAgICBsYWJlbC5hdHRycyA9IGRlZmF1bHRMYWJlbC5hdHRycztcbiAgICAgICAgbGFiZWwuc2l6ZSA9IGRlZmF1bHRMYWJlbC5zaXplO1xuXG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9XG59LCB7XG5cbiAgICBlbmRzRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgICB2YXIgcG9ydHNFcXVhbCA9IGEucG9ydCA9PT0gYi5wb3J0IHx8ICFhLnBvcnQgJiYgIWIucG9ydDtcbiAgICAgICAgcmV0dXJuIGEuaWQgPT09IGIuaWQgJiYgcG9ydHNFcXVhbDtcbiAgICB9XG59KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/Link.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/LinkView.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/LinkView.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinkView: function() { return /* binding */ LinkView; }\n/* harmony export */ });\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Link.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Link.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _routers_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../routers/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/index.mjs\");\n/* harmony import */ var _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../connectors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectors/index.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/env/index.mjs\");\n\n\n\n\n\n\n\n\n\nconst Flags = {\n    TOOLS: _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Flags.TOOLS,\n    RENDER: 'RENDER',\n    UPDATE: 'UPDATE',\n    LABELS: 'LABELS',\n    SOURCE: 'SOURCE',\n    TARGET: 'TARGET',\n    CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nconst LinkView = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.extend({\n\n    className: function() {\n\n        var classNames = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n\n    presentationAttributes: {\n        markup: [Flags.RENDER],\n        attrs: [Flags.UPDATE],\n        router: [Flags.UPDATE],\n        connector: [Flags.CONNECTOR],\n        labels: [Flags.LABELS, Flags.TOOLS],\n        labelMarkup: [Flags.LABELS],\n        vertices: [Flags.UPDATE],\n        source: [Flags.SOURCE, Flags.UPDATE],\n        target: [Flags.TARGET, Flags.UPDATE]\n    },\n\n    initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\n    UPDATE_PRIORITY: 1,\n    EPSILON: 1e-6,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n\n            if (_env_index_mjs__WEBPACK_IMPORTED_MODULE_1__.env.test('isSafari')) {\n                this.__fixSafariBug268376();\n            }\n\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n            updateLabels = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n\n        return flags;\n    },\n\n    __fixSafariBug268376: function() {\n        // Safari has a bug where any change after the first render is not reflected in the DOM.\n        // https://bugs.webkit.org/show_bug.cgi?id=268376\n        const { el } = this;\n        const childNodes = Array.from(el.childNodes);\n        const fragment = document.createDocumentFragment();\n        for (let i = 0, n = childNodes.length; i < n; i++) {\n            el.removeChild(childNodes[i]);\n            fragment.appendChild(childNodes[i]);\n        }\n        el.appendChild(fragment);\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('g').append(fragment);\n        } else {\n            vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('g').addClass('labels');\n            if (this.options.labelsLayer) {\n                vLabels.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.addClassNamePrefix)((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.result)(this, 'className')));\n                vLabels.attr('model-id', model.id);\n            }\n        }\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n\n    findLabelNodes: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return [];\n        const labelSelectors = this._labelSelectors[labelIndex];\n        return this.findBySelector(selector, labelRoot, labelSelectors);\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const [node = null] = this.findLabelNodes(labelIndex, selector);\n        return node;\n    },\n\n    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelAttrs, labelAttrs);\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    // merge default label size into label size (no built-in default)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n\n        if (labelSize === null) return null;\n        if (labelSize === undefined) {\n\n            if (defaultLabelSize === null) return null;\n            if (defaultLabelSize === undefined) return undefined;\n\n            return defaultLabelSize;\n        }\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelSize, labelSize);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        if (!this.paper.options.labelLayer) {\n            // If there is no label layer, the cache needs to be cleared\n            // of the root node because the labels are attached\n            // to it and could affect the bounding box.\n            this.cleanNodeCache(this.el);\n        }\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n        var defaultLabelSize = defaultLabel.size;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n            var labelSize = label.size;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            var size = this._mergeLabelSize(\n                labelSize,\n                defaultLabelSize\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.sourceAnchor);\n            case 'target':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.sourcePoint);\n            case 'target':\n                return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n\n    // Updating.\n    // ---------\n\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_6__.Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and anchor points.\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n\n    updateDOM() {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors });\n        // update the label position etc.\n        this.updateLabelPositions();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 4. Find Connection\n        const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n        this.path = path;\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_8__.Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (this.options.perpendicular) {\n                    // Backwards compatibility\n                    // See `manhattan` router for more details\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    isIntersecting: function(geometryShape, geometryData) {\n        const connection = this.getConnection();\n        if (!connection) return false;\n        return _g_index_mjs__WEBPACK_IMPORTED_MODULE_9__.intersection.exists(\n            geometryShape,\n            connection,\n            geometryData,\n            { segmentSubdivisions: this.getConnectionSubdivisions() },\n        );\n    },\n\n    isEnclosedIn: function(geometryRect) {\n        const connection = this.getConnection();\n        if (!connection) return false;\n        const bbox = connection.bbox();\n        if (!bbox) return false;\n        return geometryRect.containsRect(bbox);\n    },\n\n    isAtPoint: function(point /*, options */) {\n        // Note: `strict` option is not applicable for links.\n        // There is currently no method to determine if a path contains a point.\n        const area = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(point);\n        // Intersection with a zero-size area is not possible.\n        area.inflate(this.EPSILON);\n        return this.isIntersecting(area);\n    },\n\n    // combine default label position with built-in default label position\n    _getDefaultLabelPositionProperty: function() {\n\n        var model = this.model;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, builtinDefaultLabelPosition, defaultLabelPosition);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    // expects normalized position properties\n    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\n        if (normalizedLabelPosition === null) return null;\n        if (normalizedLabelPosition === undefined) {\n\n            if (normalizedDefaultLabelPosition === null) return null;\n            return normalizedDefaultLabelPosition;\n        }\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _getLabelPositionProperty: function(idx) {\n\n        return (this.model.label(idx).position || {});\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.merge)({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isObject)(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findNode(selector);\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = this.paper.options.routerNamespace || _routers_index_mjs__WEBPACK_IMPORTED_MODULE_10__;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point); // no router specified\n        }\n\n        var routerFn = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(router) ? router : namespace[router.name];\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = this.paper.options.connectorNamespace || _connectors_index_mjs__WEBPACK_IMPORTED_MODULE_11__;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(connector) ? connector : namespace[connector.name];\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isFunction)(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.clone)(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_12__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start.clone();\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_13__.normalizeAngle)(((angle + 90) % 180) - 90);\n                }\n            }\n\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start.clone();\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragLabelStart: function(evt, x, y) {\n\n        if (this.can('labelMove')) {\n\n            if (this.isDefaultInteractionPrevented(evt)) return;\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\n            var coords = this.getLabelCoordinates(position);\n            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                dx: dx,\n                dy: dy,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition((x + data.dx), (y + data.dy), data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        // The `touchmove' events are not fired\n        // when the original event target is removed from the DOM.\n        // The labels are currently re-rendered completely when only\n        // the position changes. This is why we need to make sure that\n        // the label is updated synchronously.\n        // TODO: replace `touchmove` with `pointermove` (breaking change).\n        const setOptions = { ui: true };\n        if (this.paper.isAsync() && evt.type === 'touchmove') {\n            setOptions.async = false;\n        }\n        this.model.label(data.labelIdx, label, setOptions);\n    },\n\n    dragArrowhead: function(evt, x, y) {\n        if (this.paper.options.snapLinks) {\n            const isSnapped = this._snapArrowhead(evt, x, y);\n            if (!isSnapped && this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            }\n        } else {\n            if (this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            } else {\n                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n            }\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !_Link_mjs__WEBPACK_IMPORTED_MODULE_14__.Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapToPoints: function(snapPoint, points, radius) {\n        let closestPointX = null;\n        let closestDistanceX = Infinity;\n\n        let closestPointY = null;\n        let closestDistanceY = Infinity;\n\n        let x = snapPoint.x;\n        let y = snapPoint.y;\n\n        for (let i = 0; i < points.length; i++) {\n            const distX = Math.abs(points[i].x - snapPoint.x);\n            if (distX < closestDistanceX) {\n                closestDistanceX = distX;\n                closestPointX = points[i];\n            }\n\n            const distY = Math.abs(points[i].y - snapPoint.y);\n            if (distY < closestDistanceY) {\n                closestDistanceY = distY;\n                closestPointY = points[i];\n            }\n        }\n\n        if (closestDistanceX < radius) {\n            x = closestPointX.x;\n        }\n        if (closestDistanceY < radius) {\n            y = closestPointY.y;\n        }\n\n        return { x, y };\n    },\n\n    _snapArrowheadSelf: function(evt, x, y) {\n\n        const { paper, model } = this;\n        const { snapLinksSelf } = paper.options;\n        const data = this.eventData(evt);\n        const radius = snapLinksSelf.radius || 20;\n\n        const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n        const vertices = model.vertices();\n        const points = [anchor, ...vertices];\n\n        const snapPoint = this._snapToPoints({ x: x, y: y }, points, radius);\n\n        const point = paper.localToClientPoint(snapPoint);\n        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        let isSnapped = false;\n        // checking view in close area of the pointer\n\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findElementViewsInArea(\n            { x: x - r, y: y - r, width: 2 * r, height: 2 * r },\n            snapLinks.findInAreaOptions\n        );\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Point(x, y);\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n            isSnapped = true;\n\n            if (!newClosestMagnet)  {\n                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n            }\n\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isEqual)(prevEnd, end)) {\n                // the source/target json has not changed\n                return isSnapped;\n            }\n\n            data.prevEnd = end;\n\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n\n        return isSnapped;\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.clone)(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    },\n\n    // Lifecycle methods\n\n    onMount: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.onMount.apply(this, arguments);\n        this.mountLabels();\n    },\n\n    onDetach: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.onDetach.apply(this, arguments);\n        this.unmountLabels();\n    },\n\n    onRemove: function() {\n        _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL0xpbmtWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBDO0FBQ1I7QUFDSDtBQUNtRztBQUNqQztBQUNqRDtBQUNNO0FBQ2Y7O0FBRXZDO0FBQ0EsV0FBVyxtREFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPLGlCQUFpQixtREFBUTs7QUFFaEM7O0FBRUEseUJBQXlCLG1EQUFROztBQUVqQzs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1EQUFROztBQUVoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLCtDQUFHO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsYUFBYTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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UUFBUSxtREFBUTtBQUNoQjtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBSTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOENBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9MaW5rVmlldy5tanM/ZjAyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDZWxsVmlldyB9IGZyb20gJy4vQ2VsbFZpZXcubWpzJztcbmltcG9ydCB7IExpbmsgfSBmcm9tICcuL0xpbmsubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZVByZWZpeCwgbWVyZ2UsIGFzc2lnbiwgaXNPYmplY3QsIGlzRnVuY3Rpb24sIGNsb25lLCBpc1BlcmNlbnRhZ2UsIHJlc3VsdCwgaXNFcXVhbCB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFBvaW50LCBMaW5lLCBQYXRoLCBub3JtYWxpemVBbmdsZSwgUmVjdCwgUG9seWxpbmUsIGludGVyc2VjdGlvbiB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHJvdXRlcnMgZnJvbSAnLi4vcm91dGVycy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgY29ubmVjdG9ycyBmcm9tICcuLi9jb25uZWN0b3JzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi9lbnYvaW5kZXgubWpzJztcblxuY29uc3QgRmxhZ3MgPSB7XG4gICAgVE9PTFM6IENlbGxWaWV3LkZsYWdzLlRPT0xTLFxuICAgIFJFTkRFUjogJ1JFTkRFUicsXG4gICAgVVBEQVRFOiAnVVBEQVRFJyxcbiAgICBMQUJFTFM6ICdMQUJFTFMnLFxuICAgIFNPVVJDRTogJ1NPVVJDRScsXG4gICAgVEFSR0VUOiAnVEFSR0VUJyxcbiAgICBDT05ORUNUT1I6ICdDT05ORUNUT1InXG59O1xuXG4vLyBMaW5rIGJhc2UgdmlldyBhbmQgY29udHJvbGxlci5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IExpbmtWaWV3ID0gQ2VsbFZpZXcuZXh0ZW5kKHtcblxuICAgIGNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBDZWxsVmlldy5wcm90b3R5cGUuY2xhc3NOYW1lLmFwcGx5KHRoaXMpLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdsaW5rJyk7XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH0sXG5cbiAgICBfbGFiZWxDYWNoZTogbnVsbCxcbiAgICBfbGFiZWxTZWxlY3RvcnM6IG51bGwsXG4gICAgX1Y6IG51bGwsXG4gICAgX2RyYWdEYXRhOiBudWxsLCAvLyBkZXByZWNhdGVkXG5cbiAgICBtZXRyaWNzOiBudWxsLFxuICAgIGRlY2ltYWxzUm91bmRpbmc6IDIsXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIGBfLmxhYmVsQ2FjaGVgIGlzIGEgbWFwcGluZyBvZiBpbmRleGVzIG9mIGxhYmVscyBpbiB0aGUgYHRoaXMuZ2V0KCdsYWJlbHMnKWAgYXJyYXkgdG9cbiAgICAgICAgLy8gYDxnIGNsYXNzPVwibGFiZWxcIj5gIG5vZGVzIHdyYXBwZWQgYnkgVmVjdG9yaXplci4gVGhpcyBhbGxvd3MgZm9yIHF1aWNrIGFjY2VzcyB0byB0aGVcbiAgICAgICAgLy8gbm9kZXMgaW4gYHVwZGF0ZUxhYmVsUG9zaXRpb24oKWAgaW4gb3JkZXIgdG8gdXBkYXRlIHRoZSBsYWJlbCBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuX2xhYmVsQ2FjaGUgPSB7fTtcblxuICAgICAgICAvLyBhIGNhY2hlIG9mIGxhYmVsIHNlbGVjdG9yc1xuICAgICAgICB0aGlzLl9sYWJlbFNlbGVjdG9ycyA9IHt9O1xuXG4gICAgICAgIC8vIGNhY2hlIG9mIGRlZmF1bHQgbWFya3VwIG5vZGVzXG4gICAgICAgIHRoaXMuX1YgPSB7fTtcblxuICAgICAgICAvLyBjb25uZWN0aW9uIHBhdGggbWV0cmljc1xuICAgICAgICB0aGlzLmNsZWFuTm9kZXNDYWNoZSgpO1xuICAgIH0sXG5cbiAgICBwcmVzZW50YXRpb25BdHRyaWJ1dGVzOiB7XG4gICAgICAgIG1hcmt1cDogW0ZsYWdzLlJFTkRFUl0sXG4gICAgICAgIGF0dHJzOiBbRmxhZ3MuVVBEQVRFXSxcbiAgICAgICAgcm91dGVyOiBbRmxhZ3MuVVBEQVRFXSxcbiAgICAgICAgY29ubmVjdG9yOiBbRmxhZ3MuQ09OTkVDVE9SXSxcbiAgICAgICAgbGFiZWxzOiBbRmxhZ3MuTEFCRUxTLCBGbGFncy5UT09MU10sXG4gICAgICAgIGxhYmVsTWFya3VwOiBbRmxhZ3MuTEFCRUxTXSxcbiAgICAgICAgdmVydGljZXM6IFtGbGFncy5VUERBVEVdLFxuICAgICAgICBzb3VyY2U6IFtGbGFncy5TT1VSQ0UsIEZsYWdzLlVQREFURV0sXG4gICAgICAgIHRhcmdldDogW0ZsYWdzLlRBUkdFVCwgRmxhZ3MuVVBEQVRFXVxuICAgIH0sXG5cbiAgICBpbml0RmxhZzogW0ZsYWdzLlJFTkRFUiwgRmxhZ3MuU09VUkNFLCBGbGFncy5UQVJHRVQsIEZsYWdzLlRPT0xTXSxcblxuICAgIFVQREFURV9QUklPUklUWTogMSxcbiAgICBFUFNJTE9OOiAxZS02LFxuXG4gICAgY29uZmlybVVwZGF0ZTogZnVuY3Rpb24oZmxhZ3MsIG9wdCkge1xuXG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlNPVVJDRSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51cGRhdGVFbmRQcm9wZXJ0aWVzKCdzb3VyY2UnKSkgcmV0dXJuIGZsYWdzO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIEZsYWdzLlNPVVJDRSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5UQVJHRVQpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlRW5kUHJvcGVydGllcygndGFyZ2V0JykpIHJldHVybiBmbGFncztcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBGbGFncy5UQVJHRVQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBwYXBlciwgc291cmNlVmlldywgdGFyZ2V0VmlldyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBhcGVyICYmICgoc291cmNlVmlldyAmJiAhcGFwZXIuaXNWaWV3TW91bnRlZChzb3VyY2VWaWV3KSkgfHwgKHRhcmdldFZpZXcgJiYgIXBhcGVyLmlzVmlld01vdW50ZWQodGFyZ2V0VmlldykpKSkge1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHNvdXJjZVZpZXcgYW5kIHRhcmdldFZpZXcgdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICAgIHJldHVybiBmbGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlJFTkRFUikpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhpZ2hsaWdodGVycyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHMob3B0KTtcbiAgICAgICAgICAgIGZsYWdzID0gdGhpcy5yZW1vdmVGbGFnKGZsYWdzLCBbRmxhZ3MuUkVOREVSLCBGbGFncy5VUERBVEUsIEZsYWdzLkxBQkVMUywgRmxhZ3MuVE9PTFMsIEZsYWdzLkNPTk5FQ1RPUl0pO1xuXG4gICAgICAgICAgICBpZiAoZW52LnRlc3QoJ2lzU2FmYXJpJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fZml4U2FmYXJpQnVnMjY4Mzc2KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB1cGRhdGVIaWdobGlnaHRlcnMgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCB7IG1vZGVsIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZXMgfSA9IG1vZGVsO1xuICAgICAgICBsZXQgdXBkYXRlTGFiZWxzID0gdGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5MQUJFTFMpO1xuXG4gICAgICAgIGlmICh1cGRhdGVMYWJlbHMpIHtcbiAgICAgICAgICAgIHRoaXMub25MYWJlbHNDaGFuZ2UobW9kZWwsIGF0dHJpYnV0ZXMubGFiZWxzLCBvcHQpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIEZsYWdzLkxBQkVMUyk7XG4gICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBkYXRlQWxsID0gdGhpcy5oYXNGbGFnKGZsYWdzLCBGbGFncy5VUERBVEUpO1xuICAgICAgICBjb25zdCB1cGRhdGVDb25uZWN0b3IgPSB0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLkNPTk5FQ1RPUik7XG4gICAgICAgIGlmICh1cGRhdGVBbGwgfHwgdXBkYXRlQ29ubmVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoIXVwZGF0ZUFsbCkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIGN1cnJlbnQgcm91dGUgYW5kIHVwZGF0ZSB0aGUgZ2VvbWV0cnlcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBhdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURPTSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHQudHJhbnNsYXRlQnkgJiYgbW9kZWwuaXNSZWxhdGlvbnNoaXBFbWJlZGRlZEluKG9wdC50cmFuc2xhdGVCeSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbGluayBpcyBiZWluZyB0cmFuc2xhdGVkIGJ5IGFuIGFuY2VzdG9yIHRoYXQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHNvdXJjZSBwb2ludCwgdGFyZ2V0IHBvaW50IGFuZCBhbGwgdmVydGljZXNcbiAgICAgICAgICAgICAgICAvLyBieSBhbiBlcXVhbCBkaXN0YW5jZS5cbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZShvcHQudHgsIG9wdC50eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2xzKG9wdCk7XG4gICAgICAgICAgICBmbGFncyA9IHRoaXMucmVtb3ZlRmxhZyhmbGFncywgW0ZsYWdzLlVQREFURSwgRmxhZ3MuVE9PTFMsIEZsYWdzLkNPTk5FQ1RPUl0pO1xuICAgICAgICAgICAgdXBkYXRlTGFiZWxzID0gZmFsc2U7XG4gICAgICAgICAgICB1cGRhdGVIaWdobGlnaHRlcnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZUxhYmVscykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYWJlbFBvc2l0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZUhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0ZsYWcoZmxhZ3MsIEZsYWdzLlRPT0xTKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29scyhvcHQpO1xuICAgICAgICAgICAgZmxhZ3MgPSB0aGlzLnJlbW92ZUZsYWcoZmxhZ3MsIEZsYWdzLlRPT0xTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9LFxuXG4gICAgX19maXhTYWZhcmlCdWcyNjgzNzY6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBTYWZhcmkgaGFzIGEgYnVnIHdoZXJlIGFueSBjaGFuZ2UgYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBpcyBub3QgcmVmbGVjdGVkIGluIHRoZSBET00uXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yNjgzNzZcbiAgICAgICAgY29uc3QgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IEFycmF5LmZyb20oZWwuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkTm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdENvbm5lY3Rpb25VcGRhdGU6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RVcGRhdGUodGhpcy5nZXRGbGFnKEZsYWdzLlVQREFURSksIG9wdCk7XG4gICAgfSxcblxuICAgIGlzTGFiZWxzUmVuZGVyUmVxdWlyZWQ6IGZ1bmN0aW9uKG9wdCA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgcHJldmlvdXNMYWJlbHMgPSB0aGlzLm1vZGVsLnByZXZpb3VzKCdsYWJlbHMnKTtcbiAgICAgICAgaWYgKCFwcmV2aW91c0xhYmVscykgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgLy8gSGVyZSBpcyBhbiBvcHRpbWl6YXRpb24gZm9yIGNhc2VzIHdoZW4gd2Uga25vdywgdGhhdCBjaGFuZ2UgZG9lc1xuICAgICAgICAvLyBub3QgcmVxdWlyZSByZS1yZW5kZXJpbmcgb2YgYWxsIGxhYmVscy5cbiAgICAgICAgaWYgKCgncHJvcGVydHlQYXRoQXJyYXknIGluIG9wdCkgJiYgKCdwcm9wZXJ0eVZhbHVlJyBpbiBvcHQpKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFiZWwgaXMgc2V0dGluZyBieSBgcHJvcCgpYCBtZXRob2RcbiAgICAgICAgICAgIHZhciBwYXRoQXJyYXkgPSBvcHQucHJvcGVydHlQYXRoQXJyYXkgfHwgW107XG4gICAgICAgICAgICB2YXIgcGF0aExlbmd0aCA9IHBhdGhBcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocGF0aExlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hhbmdpbmcgYSBzaW5nbGUgbGFiZWwgaGVyZSBlLmcuICdsYWJlbHMvMC9wb3NpdGlvbidcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxFeGlzdHMgPSAhIXByZXZpb3VzTGFiZWxzW3BhdGhBcnJheVsxXV07XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoTGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgY2hhbmdpbmcgdGhlIGVudGlyZSBsYWJlbC4gTmVlZCB0byBjaGVjayBpZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hcmt1cCBpcyBhbHNvIGJlaW5nIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCdtYXJrdXAnIGluIE9iamVjdChvcHQucHJvcGVydHlWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhdGhBcnJheVsyXSAhPT0gJ21hcmt1cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBjaGFuZ2luZyBhIGxhYmVsIHByb3BlcnR5IGJ1dCBub3QgdGhlIG1hcmt1cFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIG9uTGFiZWxzQ2hhbmdlOiBmdW5jdGlvbihfbGluaywgX2xhYmVscywgb3B0KSB7XG5cbiAgICAgICAgLy8gTm90ZTogdGhpcyBvcHRpbWl6YXRpb24gd29ya3MgaW4gYXN5bmM9ZmFsc2UgbW9kZSBvbmx5XG4gICAgICAgIGlmICh0aGlzLmlzTGFiZWxzUmVuZGVyUmVxdWlyZWQob3B0KSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJMYWJlbHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyaW5nLlxuICAgIC8vIC0tLS0tLS0tLS1cblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy52ZWwuZW1wdHkoKTtcbiAgICAgICAgdGhpcy51bm1vdW50TGFiZWxzKCk7XG4gICAgICAgIHRoaXMuX1YgPSB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJNYXJrdXAoKTtcbiAgICAgICAgLy8gcmVuZGVyaW5nIGxhYmVscyBoYXMgdG8gYmUgcnVuIGFmdGVyIHRoZSBsaW5rIGlzIGFwcGVuZGVkIHRvIERPTSB0cmVlLiAob3RoZXJ3aXNlIDxUZXh0PiBiYm94XG4gICAgICAgIC8vIHJldHVybnMgemVybyB2YWx1ZXMpXG4gICAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlck1hcmt1cDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbWFya3VwID0gbGluay5nZXQoJ21hcmt1cCcpIHx8IGxpbmsubWFya3VwO1xuICAgICAgICBpZiAoIW1hcmt1cCkgdGhyb3cgbmV3IEVycm9yKCdkaWEuTGlua1ZpZXc6IG1hcmt1cCByZXF1aXJlZCcpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXJrdXApKSByZXR1cm4gdGhpcy5yZW5kZXJKU09OTWFya3VwKG1hcmt1cCk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJykgcmV0dXJuIHRoaXMucmVuZGVyU3RyaW5nTWFya3VwKG1hcmt1cCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiBpbnZhbGlkIG1hcmt1cCcpO1xuICAgIH0sXG5cbiAgICByZW5kZXJKU09OTWFya3VwOiBmdW5jdGlvbihtYXJrdXApIHtcblxuICAgICAgICB2YXIgZG9jID0gdGhpcy5wYXJzZURPTUpTT04obWFya3VwLCB0aGlzLmVsKTtcbiAgICAgICAgLy8gU2VsZWN0b3JzXG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gZG9jLnNlbGVjdG9ycztcbiAgICAgICAgLy8gRnJhZ21lbnRcbiAgICAgICAgdGhpcy52ZWwuYXBwZW5kKGRvYy5mcmFnbWVudCk7XG4gICAgfSxcblxuICAgIHJlbmRlclN0cmluZ01hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG5cbiAgICAgICAgLy8gQSBzcGVjaWFsIG1hcmt1cCBjYW4gYmUgZ2l2ZW4gaW4gdGhlIGBwcm9wZXJ0aWVzLm1hcmt1cGAgcHJvcGVydHkuIFRoaXMgbWlnaHQgYmUgaGFuZHlcbiAgICAgICAgLy8gaWYgZS5nLiBhcnJvd2hlYWQgbWFya2VycyBzaG91bGQgYmUgYDxpbWFnZT5gIGVsZW1lbnRzIG9yIGFueSBvdGhlciBlbGVtZW50IHRoYW4gYDxwYXRoPmBzLlxuICAgICAgICAvLyBgLmNvbm5lY3Rpb25gLCBgLmNvbm5lY3Rpb24td3JhcGAsIGAubWFya2VyLXNvdXJjZWAgYW5kIGAubWFya2VyLXRhcmdldGAgc2VsZWN0b3JzXG4gICAgICAgIC8vIG9mIGVsZW1lbnRzIHdpdGggc3BlY2lhbCBtZWFuaW5nIHRob3VnaC4gVGhlcmVmb3JlLCB0aG9zZSBjbGFzc2VzIHNob3VsZCBiZSBwcmVzZXJ2ZWQgaW4gYW55XG4gICAgICAgIC8vIHNwZWNpYWwgbWFya3VwIHBhc3NlZCBpbiBgcHJvcGVydGllcy5tYXJrdXBgLlxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBWKG1hcmt1cCk7XG4gICAgICAgIC8vIGN1c3RvbSBtYXJrdXAgbWF5IGNvbnRhaW4gb25seSBvbmUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuXG4gICAgICAgIHRoaXMudmVsLmFwcGVuZChjaGlsZHJlbik7XG4gICAgfSxcblxuICAgIF9nZXRMYWJlbE1hcmt1cDogZnVuY3Rpb24obGFiZWxNYXJrdXApIHtcblxuICAgICAgICBpZiAoIWxhYmVsTWFya3VwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxhYmVsTWFya3VwKSkgcmV0dXJuIHRoaXMucGFyc2VET01KU09OKGxhYmVsTWFya3VwLCBudWxsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbE1hcmt1cCA9PT0gJ3N0cmluZycpIHJldHVybiB0aGlzLl9nZXRMYWJlbFN0cmluZ01hcmt1cChsYWJlbE1hcmt1cCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLmxpbmtWaWV3OiBpbnZhbGlkIGxhYmVsIG1hcmt1cCcpO1xuICAgIH0sXG5cbiAgICBfZ2V0TGFiZWxTdHJpbmdNYXJrdXA6IGZ1bmN0aW9uKGxhYmVsTWFya3VwKSB7XG5cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gVihsYWJlbE1hcmt1cCk7XG4gICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZHJlbi5ub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENoaWxkID0gY2hpbGRyZW5baV0ubm9kZTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjdXJyZW50Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZnJhZ21lbnQ6IGZyYWdtZW50LCBzZWxlY3RvcnM6IHt9fTsgLy8gbm8gc2VsZWN0b3JzXG4gICAgfSxcblxuICAgIC8vIExhYmVsIG1hcmt1cCBmcmFnbWVudCBtYXkgY29tZSB3cmFwcGVkIGluIDxnIGNsYXNzPVwibGFiZWxcIiAvPiwgb3Igbm90LlxuICAgIC8vIElmIGl0IGRvZXNuJ3QsIGFkZCB0aGUgPGcgLz4gY29udGFpbmVyIGhlcmUuXG4gICAgX25vcm1hbGl6ZUxhYmVsTWFya3VwOiBmdW5jdGlvbihtYXJrdXApIHtcblxuICAgICAgICBpZiAoIW1hcmt1cCkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgICB2YXIgZnJhZ21lbnQgPSBtYXJrdXAuZnJhZ21lbnQ7XG4gICAgICAgIGlmICghKG1hcmt1cC5mcmFnbWVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHx8ICFtYXJrdXAuZnJhZ21lbnQuaGFzQ2hpbGROb2RlcygpKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogaW52YWxpZCBsYWJlbCBtYXJrdXAuJyk7XG5cbiAgICAgICAgdmFyIHZOb2RlO1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IGZyYWdtZW50LmNoaWxkTm9kZXM7XG5cbiAgICAgICAgaWYgKChjaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHx8IGNoaWxkTm9kZXNbMF0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0cnKSB7XG4gICAgICAgICAgICAvLyBkZWZhdWx0IG1hcmt1cCBmcmFnbWVudCBpcyBub3Qgd3JhcHBlZCBpbiA8ZyAvPlxuICAgICAgICAgICAgLy8gYWRkIGEgPGcgLz4gY29udGFpbmVyXG4gICAgICAgICAgICB2Tm9kZSA9IFYoJ2cnKS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdk5vZGUgPSBWKGNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdk5vZGUuYWRkQ2xhc3MoJ2xhYmVsJyk7XG5cbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdk5vZGUubm9kZSwgc2VsZWN0b3JzOiBtYXJrdXAuc2VsZWN0b3JzIH07XG4gICAgfSxcblxuICAgIHJlbmRlckxhYmVsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5fVjtcbiAgICAgICAgdmFyIHZMYWJlbHMgPSBjYWNoZS5sYWJlbHM7XG4gICAgICAgIHZhciBsYWJlbENhY2hlID0gdGhpcy5fbGFiZWxDYWNoZSA9IHt9O1xuICAgICAgICB2YXIgbGFiZWxTZWxlY3RvcnMgPSB0aGlzLl9sYWJlbFNlbGVjdG9ycyA9IHt9O1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbGFiZWxzID0gbW9kZWwuYXR0cmlidXRlcy5sYWJlbHMgfHwgW107XG4gICAgICAgIHZhciBsYWJlbHNDb3VudCA9IGxhYmVscy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxhYmVsc0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodkxhYmVscykgdkxhYmVscy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZMYWJlbHMpIHtcbiAgICAgICAgICAgIHZMYWJlbHMuZW1wdHkoKTtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBsYWJlbCBjb250YWluZXIgaW4gdGhlIG1hcmt1cCBidXQgc29tZSBsYWJlbHMgYXJlIGRlZmluZWRcbiAgICAgICAgICAgIC8vIGFkZCBhIDxnIGNsYXNzPVwibGFiZWxzXCIgLz4gY29udGFpbmVyXG4gICAgICAgICAgICB2TGFiZWxzID0gY2FjaGUubGFiZWxzID0gVignZycpLmFkZENsYXNzKCdsYWJlbHMnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWxzTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2TGFiZWxzLmFkZENsYXNzKGFkZENsYXNzTmFtZVByZWZpeChyZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpKSk7XG4gICAgICAgICAgICAgICAgdkxhYmVscy5hdHRyKCdtb2RlbC1pZCcsIG1vZGVsLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWxzQ291bnQ7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICAgICAgICB2YXIgbGFiZWxNYXJrdXAgPSB0aGlzLl9ub3JtYWxpemVMYWJlbE1hcmt1cCh0aGlzLl9nZXRMYWJlbE1hcmt1cChsYWJlbC5tYXJrdXApKTtcbiAgICAgICAgICAgIHZhciBsYWJlbE5vZGU7XG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JzO1xuICAgICAgICAgICAgaWYgKGxhYmVsTWFya3VwKSB7XG5cbiAgICAgICAgICAgICAgICBsYWJlbE5vZGUgPSBsYWJlbE1hcmt1cC5ub2RlO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IGxhYmVsTWFya3VwLnNlbGVjdG9ycztcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsID0gIG1vZGVsLl9idWlsdGlucy5kZWZhdWx0TGFiZWw7XG4gICAgICAgICAgICAgICAgdmFyIGJ1aWx0aW5EZWZhdWx0TGFiZWxNYXJrdXAgPSB0aGlzLl9ub3JtYWxpemVMYWJlbE1hcmt1cCh0aGlzLl9nZXRMYWJlbE1hcmt1cChidWlsdGluRGVmYXVsdExhYmVsLm1hcmt1cCkpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSBtb2RlbC5fZ2V0RGVmYXVsdExhYmVsKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRMYWJlbE1hcmt1cCA9IHRoaXMuX25vcm1hbGl6ZUxhYmVsTWFya3VwKHRoaXMuX2dldExhYmVsTWFya3VwKGRlZmF1bHRMYWJlbC5tYXJrdXApKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE1hcmt1cCA9IGRlZmF1bHRMYWJlbE1hcmt1cCB8fCBidWlsdGluRGVmYXVsdExhYmVsTWFya3VwO1xuXG4gICAgICAgICAgICAgICAgbGFiZWxOb2RlID0gZGVmYXVsdE1hcmt1cC5ub2RlO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IGRlZmF1bHRNYXJrdXAuc2VsZWN0b3JzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYWJlbE5vZGUuc2V0QXR0cmlidXRlKCdsYWJlbC1pZHgnLCBpKTsgLy8gYXNzaWduIGxhYmVsLWlkeFxuICAgICAgICAgICAgdkxhYmVscy5hcHBlbmQobGFiZWxOb2RlKTtcbiAgICAgICAgICAgIGxhYmVsQ2FjaGVbaV0gPSBsYWJlbE5vZGU7IC8vIGNhY2hlIG5vZGUgZm9yIGB1cGRhdGVMYWJlbHMoKWAgc28gaXQgY2FuIGp1c3QgdXBkYXRlIGxhYmVsIG5vZGUgcG9zaXRpb25zXG5cbiAgICAgICAgICAgIHZhciByb290U2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yc1tyb290U2VsZWN0b3JdKSB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogYW1iaWd1b3VzIGxhYmVsIHJvb3Qgc2VsZWN0b3IuJyk7XG4gICAgICAgICAgICBzZWxlY3RvcnNbcm9vdFNlbGVjdG9yXSA9IGxhYmVsTm9kZTtcblxuICAgICAgICAgICAgbGFiZWxTZWxlY3RvcnNbaV0gPSBzZWxlY3RvcnM7IC8vIGNhY2hlIGxhYmVsIHNlbGVjdG9ycyBmb3IgYHVwZGF0ZUxhYmVscygpYFxuICAgICAgICB9XG4gICAgICAgIGlmICghdkxhYmVscy5wYXJlbnQoKSkge1xuICAgICAgICAgICAgdGhpcy5tb3VudExhYmVscygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbHMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbW91bnRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGVsLCBwYXBlciwgbW9kZWwsIF9WLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGxhYmVsczogdkxhYmVscyB9ID0gX1Y7XG4gICAgICAgIGlmICghdkxhYmVscyB8fCAhbW9kZWwuaGFzTGFiZWxzKCkpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBub2RlIH0gPSB2TGFiZWxzO1xuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbHNMYXllcikge1xuICAgICAgICAgICAgcGFwZXIuZ2V0TGF5ZXJWaWV3KG9wdGlvbnMubGFiZWxzTGF5ZXIpLmluc2VydFNvcnRlZE5vZGUobm9kZSwgbW9kZWwuZ2V0KCd6JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1bm1vdW50TGFiZWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCBfViB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFfVikgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGxhYmVsczogdkxhYmVscyB9ID0gX1Y7XG4gICAgICAgIGlmICh2TGFiZWxzICYmIG9wdGlvbnMubGFiZWxzTGF5ZXIpIHtcbiAgICAgICAgICAgIHZMYWJlbHMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluZExhYmVsTm9kZXM6IGZ1bmN0aW9uKGxhYmVsSW5kZXgsIHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsUm9vdCA9IHRoaXMuX2xhYmVsQ2FjaGVbbGFiZWxJbmRleF07XG4gICAgICAgIGlmICghbGFiZWxSb290KSByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGxhYmVsU2VsZWN0b3JzID0gdGhpcy5fbGFiZWxTZWxlY3RvcnNbbGFiZWxJbmRleF07XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRCeVNlbGVjdG9yKHNlbGVjdG9yLCBsYWJlbFJvb3QsIGxhYmVsU2VsZWN0b3JzKTtcbiAgICB9LFxuXG4gICAgZmluZExhYmVsTm9kZTogZnVuY3Rpb24obGFiZWxJbmRleCwgc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgW25vZGUgPSBudWxsXSA9IHRoaXMuZmluZExhYmVsTm9kZXMobGFiZWxJbmRleCwgc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgLy8gbWVyZ2UgZGVmYXVsdCBsYWJlbCBhdHRycyBpbnRvIGxhYmVsIGF0dHJzIChvciB1c2UgYnVpbHQtaW4gZGVmYXVsdCBsYWJlbCBhdHRycyBpZiBuZWl0aGVyIGlzIHByb3ZpZGVkKVxuICAgIC8vIGtlZXAgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY2F1c2UgYHt9YCBtZWFucyBzb21ldGhpbmcgZWxzZVxuICAgIF9tZXJnZUxhYmVsQXR0cnM6IGZ1bmN0aW9uKGhhc0N1c3RvbU1hcmt1cCwgbGFiZWxBdHRycywgZGVmYXVsdExhYmVsQXR0cnMsIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycykge1xuXG4gICAgICAgIGlmIChsYWJlbEF0dHJzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGxhYmVsQXR0cnMgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsQXR0cnMgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYWJlbEF0dHJzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNDdXN0b21NYXJrdXApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhc0N1c3RvbU1hcmt1cCkgcmV0dXJuIGRlZmF1bHRMYWJlbEF0dHJzO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBidWlsdGluRGVmYXVsdExhYmVsQXR0cnMsIGRlZmF1bHRMYWJlbEF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDdXN0b21NYXJrdXApIHJldHVybiBtZXJnZSh7fSwgZGVmYXVsdExhYmVsQXR0cnMsIGxhYmVsQXR0cnMpO1xuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycywgZGVmYXVsdExhYmVsQXR0cnMsIGxhYmVsQXR0cnMpO1xuICAgIH0sXG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IGxhYmVsIHNpemUgaW50byBsYWJlbCBzaXplIChubyBidWlsdC1pbiBkZWZhdWx0KVxuICAgIC8vIGtlZXAgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGJlY2F1c2UgYHt9YCBtZWFucyBzb21ldGhpbmcgZWxzZVxuICAgIF9tZXJnZUxhYmVsU2l6ZTogZnVuY3Rpb24obGFiZWxTaXplLCBkZWZhdWx0TGFiZWxTaXplKSB7XG5cbiAgICAgICAgaWYgKGxhYmVsU2l6ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChsYWJlbFNpemUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsU2l6ZSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsU2l6ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExhYmVsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXJnZSh7fSwgZGVmYXVsdExhYmVsU2l6ZSwgbGFiZWxTaXplKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlTGFiZWxzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX1YubGFiZWxzKSByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAoIXRoaXMucGFwZXIub3B0aW9ucy5sYWJlbExheWVyKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBsYWJlbCBsYXllciwgdGhlIGNhY2hlIG5lZWRzIHRvIGJlIGNsZWFyZWRcbiAgICAgICAgICAgIC8vIG9mIHRoZSByb290IG5vZGUgYmVjYXVzZSB0aGUgbGFiZWxzIGFyZSBhdHRhY2hlZFxuICAgICAgICAgICAgLy8gdG8gaXQgYW5kIGNvdWxkIGFmZmVjdCB0aGUgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgdGhpcy5jbGVhbk5vZGVDYWNoZSh0aGlzLmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBsYWJlbHMgPSBtb2RlbC5nZXQoJ2xhYmVscycpIHx8IFtdO1xuICAgICAgICB2YXIgY2FuTGFiZWxNb3ZlID0gdGhpcy5jYW4oJ2xhYmVsTW92ZScpO1xuXG4gICAgICAgIHZhciBidWlsdGluRGVmYXVsdExhYmVsID0gbW9kZWwuX2J1aWx0aW5zLmRlZmF1bHRMYWJlbDtcbiAgICAgICAgdmFyIGJ1aWx0aW5EZWZhdWx0TGFiZWxBdHRycyA9IGJ1aWx0aW5EZWZhdWx0TGFiZWwuYXR0cnM7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbCA9IG1vZGVsLl9nZXREZWZhdWx0TGFiZWwoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbE1hcmt1cCA9IGRlZmF1bHRMYWJlbC5tYXJrdXA7XG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxBdHRycyA9IGRlZmF1bHRMYWJlbC5hdHRycztcbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFNpemUgPSBkZWZhdWx0TGFiZWwuc2l6ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGxhYmVsTm9kZSA9IHRoaXMuX2xhYmVsQ2FjaGVbaV07XG4gICAgICAgICAgICBsYWJlbE5vZGUuc2V0QXR0cmlidXRlKCdjdXJzb3InLCAoY2FuTGFiZWxNb3ZlID8gJ21vdmUnIDogJ2RlZmF1bHQnKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSB0aGlzLl9sYWJlbFNlbGVjdG9yc1tpXTtcblxuICAgICAgICAgICAgdmFyIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgICAgICAgdmFyIGxhYmVsTWFya3VwID0gbGFiZWwubWFya3VwO1xuICAgICAgICAgICAgdmFyIGxhYmVsQXR0cnMgPSBsYWJlbC5hdHRycztcbiAgICAgICAgICAgIHZhciBsYWJlbFNpemUgPSBsYWJlbC5zaXplO1xuXG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB0aGlzLl9tZXJnZUxhYmVsQXR0cnMoXG4gICAgICAgICAgICAgICAgKGxhYmVsTWFya3VwIHx8IGRlZmF1bHRMYWJlbE1hcmt1cCksXG4gICAgICAgICAgICAgICAgbGFiZWxBdHRycyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGFiZWxBdHRycyxcbiAgICAgICAgICAgICAgICBidWlsdGluRGVmYXVsdExhYmVsQXR0cnNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5fbWVyZ2VMYWJlbFNpemUoXG4gICAgICAgICAgICAgICAgbGFiZWxTaXplLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMYWJlbFNpemVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRE9NU3VidHJlZUF0dHJpYnV0ZXMobGFiZWxOb2RlLCBhdHRycywge1xuICAgICAgICAgICAgICAgIHJvb3RCQm94OiBuZXcgUmVjdChzaXplKSxcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9yc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gcmVtb3ZlIHZlcnRpY2VzIHRoYXQgbGllIG9uIChvciBuZWFybHkgb24pIHN0cmFpZ2h0IGxpbmVzIHdpdGhpbiB0aGUgbGlua1xuICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHJlbW92ZWQgcG9pbnRzXG4gICAgcmVtb3ZlUmVkdW5kYW50TGluZWFyVmVydGljZXM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIGNvbnN0IFNJTVBMSUZZX1RIUkVTSE9MRCA9IDAuMDAxO1xuXG4gICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLm1vZGVsO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IGxpbmsudmVydGljZXMoKTtcbiAgICAgICAgY29uc3Qgcm91dGVQb2ludHMgPSBbdGhpcy5zb3VyY2VBbmNob3IsIC4uLnZlcnRpY2VzLCB0aGlzLnRhcmdldEFuY2hvcl07XG4gICAgICAgIGNvbnN0IG51bVJvdXRlUG9pbnRzID0gcm91dGVQb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIC8vIHB1dCByb3V0ZVBvaW50cyBpbnRvIGEgcG9seWxpbmUgYW5kIHRyeSB0byBzaW1wbGlmeVxuICAgICAgICBjb25zdCBwb2x5bGluZSA9IG5ldyBQb2x5bGluZShyb3V0ZVBvaW50cyk7XG4gICAgICAgIHBvbHlsaW5lLnNpbXBsaWZ5KHsgdGhyZXNob2xkOiBTSU1QTElGWV9USFJFU0hPTEQgfSk7XG4gICAgICAgIGNvbnN0IHBvbHlsaW5lUG9pbnRzID0gcG9seWxpbmUucG9pbnRzLm1hcCgocG9pbnQpID0+IChwb2ludC50b0pTT04oKSkpOyAvLyBKU09OIG9mIHBvaW50cyBhZnRlciBzaW1wbGlmaWNhdGlvblxuICAgICAgICBjb25zdCBudW1Qb2x5bGluZVBvaW50cyA9IHBvbHlsaW5lUG9pbnRzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIHBvaW50cyBhZnRlciBzaW1wbGlmaWNhdGlvblxuXG4gICAgICAgIC8vIHNob3J0Y3V0IGlmIHNpbXBsaWZpY2F0aW9uIGRpZCBub3QgcmVtb3ZlIGFueSByZWR1bmRhbnQgdmVydGljZXM6XG4gICAgICAgIGlmIChudW1Sb3V0ZVBvaW50cyA9PT0gbnVtUG9seWxpbmVQb2ludHMpIHJldHVybiAwO1xuXG4gICAgICAgIC8vIGVsc2U6IHNldCBzaW1wbGlmaWVkIHBvbHlsaW5lIHBvaW50cyBhcyBsaW5rIHZlcnRpY2VzXG4gICAgICAgIC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBwb2x5bGluZSBwb2ludHMgYWdhaW4gKD0gc291cmNlL3RhcmdldCBhbmNob3JzKVxuICAgICAgICBsaW5rLnZlcnRpY2VzKHBvbHlsaW5lUG9pbnRzLnNsaWNlKDEsIG51bVBvbHlsaW5lUG9pbnRzIC0gMSksIG9wdCk7XG4gICAgICAgIHJldHVybiAobnVtUm91dGVQb2ludHMgLSBudW1Qb2x5bGluZVBvaW50cyk7XG4gICAgfSxcblxuICAgIGdldEVuZFZpZXc6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZVZpZXcgfHwgbnVsbDtcbiAgICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0VmlldyB8fCBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdHlwZSBwYXJhbWV0ZXIgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0RW5kQW5jaG9yOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuc291cmNlQW5jaG9yKTtcbiAgICAgICAgICAgIGNhc2UgJ3RhcmdldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiB0eXBlIHBhcmFtZXRlciByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFbmRDb25uZWN0aW9uUG9pbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5zb3VyY2VQb2ludCk7XG4gICAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy50YXJnZXRQb2ludCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiB0eXBlIHBhcmFtZXRlciByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFbmRNYWduZXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VWaWV3ID0gdGhpcy5zb3VyY2VWaWV3O1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlVmlldykgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTWFnbmV0IHx8IHNvdXJjZVZpZXcuZWw7XG4gICAgICAgICAgICBjYXNlICd0YXJnZXQnOlxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRWaWV3ID0gdGhpcy50YXJnZXRWaWV3O1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0VmlldykgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0TWFnbmV0IHx8IHRhcmdldFZpZXcuZWw7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiB0eXBlIHBhcmFtZXRlciByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG5cbiAgICAvLyBVcGRhdGluZy5cbiAgICAvLyAtLS0tLS0tLS1cblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUm91dGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4ID0gMCwgdHkgPSAwKSB7XG4gICAgICAgIGNvbnN0IHsgcm91dGUsIHBhdGggfSA9IHRoaXM7XG4gICAgICAgIGlmICghcm91dGUgfHwgIXBhdGgpIHJldHVybjtcbiAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSByb3V0ZVxuICAgICAgICBjb25zdCBwb2x5bGluZSA9IG5ldyBQb2x5bGluZShyb3V0ZSk7XG4gICAgICAgIHBvbHlsaW5lLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLnJvdXRlID0gcG9seWxpbmUucG9pbnRzO1xuICAgICAgICAvLyB0cmFuc2xhdGUgc291cmNlIGFuZCB0YXJnZXQgY29ubmVjdGlvbiBhbmQgYW5jaG9yIHBvaW50cy5cbiAgICAgICAgdGhpcy5zb3VyY2VQb2ludC5vZmZzZXQodHgsIHR5KTtcbiAgICAgICAgdGhpcy50YXJnZXRQb2ludC5vZmZzZXQodHgsIHR5KTtcbiAgICAgICAgdGhpcy5zb3VyY2VBbmNob3Iub2Zmc2V0KHR4LCB0eSk7XG4gICAgICAgIHRoaXMudGFyZ2V0QW5jaG9yLm9mZnNldCh0eCwgdHkpO1xuICAgICAgICAvLyB0cmFuc2xhdGUgdGhlIGdlb21ldHJ5IHBhdGhcbiAgICAgICAgcGF0aC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy51cGRhdGVET00oKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRE9NKCkge1xuICAgICAgICBjb25zdCB7IGVsLCBtb2RlbCwgc2VsZWN0b3JzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFuTm9kZXNDYWNoZSgpO1xuICAgICAgICAvLyB1cGRhdGUgU1ZHIGF0dHJpYnV0ZXMgZGVmaW5lZCBieSAnYXR0cnMvJy5cbiAgICAgICAgdGhpcy51cGRhdGVET01TdWJ0cmVlQXR0cmlidXRlcyhlbCwgbW9kZWwuYXR0cigpLCB7IHNlbGVjdG9ycyB9KTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBsYWJlbCBwb3NpdGlvbiBldGMuXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbnMoKTtcbiAgICAgICAgLy8gKkRlcHJlY2F0ZWQqXG4gICAgICAgIC8vIExvY2FsIHBlcnBlbmRpY3VsYXIgZmxhZyAoYXMgb3Bwb3NlZCB0byBvbmUgZGVmaW5lZCBvbiBwYXBlcikuXG4gICAgICAgIC8vIENvdWxkIGJlIGVuYWJsZWQgaW5zaWRlIGEgY29ubmVjdG9yL3JvdXRlci4gSXQncyB2YWxpZCBvbmx5XG4gICAgICAgIC8vIGR1cmluZyB0aGUgdXBkYXRlIGV4ZWN1dGlvbi5cbiAgICAgICAgdGhpcy5vcHRpb25zLnBlcnBlbmRpY3VsYXIgPSBudWxsO1xuICAgIH0sXG5cbiAgICB1cGRhdGVSb3V0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbW9kZWwudmVydGljZXMoKTtcbiAgICAgICAgLy8gMS4gRmluZCBBbmNob3JzXG4gICAgICAgIGNvbnN0IGFuY2hvcnMgPSB0aGlzLmZpbmRBbmNob3JzKHZlcnRpY2VzKTtcbiAgICAgICAgY29uc3Qgc291cmNlQW5jaG9yID0gdGhpcy5zb3VyY2VBbmNob3IgPSBhbmNob3JzLnNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0QW5jaG9yID0gdGhpcy50YXJnZXRBbmNob3IgPSBhbmNob3JzLnRhcmdldDtcbiAgICAgICAgLy8gMi4gRmluZCBSb3V0ZVxuICAgICAgICBjb25zdCByb3V0ZSA9IHRoaXMuZmluZFJvdXRlKHZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICAvLyAzLiBGaW5kIENvbm5lY3Rpb24gUG9pbnRzXG4gICAgICAgIHZhciBjb25uZWN0aW9uUG9pbnRzID0gdGhpcy5maW5kQ29ubmVjdGlvblBvaW50cyhyb3V0ZSwgc291cmNlQW5jaG9yLCB0YXJnZXRBbmNob3IpO1xuICAgICAgICB0aGlzLnNvdXJjZVBvaW50ID0gY29ubmVjdGlvblBvaW50cy5zb3VyY2U7XG4gICAgICAgIHRoaXMudGFyZ2V0UG9pbnQgPSBjb25uZWN0aW9uUG9pbnRzLnRhcmdldDtcbiAgICB9LFxuXG4gICAgdXBkYXRlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgcm91dGUsIHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCB9ID0gdGhpcztcbiAgICAgICAgLy8gNC4gRmluZCBDb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmZpbmRQYXRoKHJvdXRlLCBzb3VyY2VQb2ludC5jbG9uZSgpLCB0YXJnZXRQb2ludC5jbG9uZSgpKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9LFxuXG4gICAgZmluZEFuY2hvcnNPcmRlcmVkOiBmdW5jdGlvbihmaXJzdEVuZFR5cGUsIGZpcnN0UmVmLCBzZWNvbmRFbmRUeXBlLCBzZWNvbmRSZWYpIHtcblxuICAgICAgICB2YXIgZmlyc3RBbmNob3IsIHNlY29uZEFuY2hvcjtcbiAgICAgICAgdmFyIGZpcnN0QW5jaG9yUmVmLCBzZWNvbmRBbmNob3JSZWY7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBmaXJzdERlZiA9IG1vZGVsLmdldChmaXJzdEVuZFR5cGUpO1xuICAgICAgICB2YXIgc2Vjb25kRGVmID0gbW9kZWwuZ2V0KHNlY29uZEVuZFR5cGUpO1xuICAgICAgICB2YXIgZmlyc3RWaWV3ID0gdGhpcy5nZXRFbmRWaWV3KGZpcnN0RW5kVHlwZSk7XG4gICAgICAgIHZhciBzZWNvbmRWaWV3ID0gdGhpcy5nZXRFbmRWaWV3KHNlY29uZEVuZFR5cGUpO1xuICAgICAgICB2YXIgZmlyc3RNYWduZXQgPSB0aGlzLmdldEVuZE1hZ25ldChmaXJzdEVuZFR5cGUpO1xuICAgICAgICB2YXIgc2Vjb25kTWFnbmV0ID0gdGhpcy5nZXRFbmRNYWduZXQoc2Vjb25kRW5kVHlwZSk7XG5cbiAgICAgICAgLy8gQW5jaG9yIGZpcnN0XG4gICAgICAgIGlmIChmaXJzdFZpZXcpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFJlZikge1xuICAgICAgICAgICAgICAgIGZpcnN0QW5jaG9yUmVmID0gbmV3IFBvaW50KGZpcnN0UmVmKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kVmlldykge1xuICAgICAgICAgICAgICAgIGZpcnN0QW5jaG9yUmVmID0gc2Vjb25kTWFnbmV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdEFuY2hvclJlZiA9IG5ldyBQb2ludChzZWNvbmREZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RBbmNob3IgPSB0aGlzLmdldEFuY2hvcihmaXJzdERlZi5hbmNob3IsIGZpcnN0VmlldywgZmlyc3RNYWduZXQsIGZpcnN0QW5jaG9yUmVmLCBmaXJzdEVuZFR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlyc3RBbmNob3IgPSBuZXcgUG9pbnQoZmlyc3REZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5jaG9yIHNlY29uZFxuICAgICAgICBpZiAoc2Vjb25kVmlldykge1xuICAgICAgICAgICAgc2Vjb25kQW5jaG9yUmVmID0gbmV3IFBvaW50KHNlY29uZFJlZiB8fCBmaXJzdEFuY2hvcik7XG4gICAgICAgICAgICBzZWNvbmRBbmNob3IgPSB0aGlzLmdldEFuY2hvcihzZWNvbmREZWYuYW5jaG9yLCBzZWNvbmRWaWV3LCBzZWNvbmRNYWduZXQsIHNlY29uZEFuY2hvclJlZiwgc2Vjb25kRW5kVHlwZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWNvbmRBbmNob3IgPSBuZXcgUG9pbnQoc2Vjb25kRGVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgcmVzW2ZpcnN0RW5kVHlwZV0gPSBmaXJzdEFuY2hvcjtcbiAgICAgICAgcmVzW3NlY29uZEVuZFR5cGVdID0gc2Vjb25kQW5jaG9yO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICBmaW5kQW5jaG9yczogZnVuY3Rpb24odmVydGljZXMpIHtcblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgZmlyc3RWZXJ0ZXggPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgdmFyIGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc1t2ZXJ0aWNlcy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAobW9kZWwudGFyZ2V0KCkucHJpb3JpdHkgJiYgIW1vZGVsLnNvdXJjZSgpLnByaW9yaXR5KSB7XG4gICAgICAgICAgICAvLyBSZXZlcnNlZCBvcmRlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZEFuY2hvcnNPcmRlcmVkKCd0YXJnZXQnLCBsYXN0VmVydGV4LCAnc291cmNlJywgZmlyc3RWZXJ0ZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXN1YWwgb3JkZXJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEFuY2hvcnNPcmRlcmVkKCdzb3VyY2UnLCBmaXJzdFZlcnRleCwgJ3RhcmdldCcsIGxhc3RWZXJ0ZXgpO1xuICAgIH0sXG5cbiAgICBmaW5kQ29ubmVjdGlvblBvaW50czogZnVuY3Rpb24ocm91dGUsIHNvdXJjZUFuY2hvciwgdGFyZ2V0QW5jaG9yKSB7XG5cbiAgICAgICAgdmFyIGZpcnN0V2F5cG9pbnQgPSByb3V0ZVswXTtcbiAgICAgICAgdmFyIGxhc3RXYXlwb2ludCA9IHJvdXRlW3JvdXRlLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgc291cmNlRGVmID0gbW9kZWwuZ2V0KCdzb3VyY2UnKTtcbiAgICAgICAgdmFyIHRhcmdldERlZiA9IG1vZGVsLmdldCgndGFyZ2V0Jyk7XG4gICAgICAgIHZhciBzb3VyY2VWaWV3ID0gdGhpcy5zb3VyY2VWaWV3O1xuICAgICAgICB2YXIgdGFyZ2V0VmlldyA9IHRoaXMudGFyZ2V0VmlldztcbiAgICAgICAgdmFyIHBhcGVyT3B0aW9ucyA9IHRoaXMucGFwZXIub3B0aW9ucztcbiAgICAgICAgdmFyIHNvdXJjZU1hZ25ldCwgdGFyZ2V0TWFnbmV0O1xuXG4gICAgICAgIC8vIENvbm5lY3Rpb24gUG9pbnQgU291cmNlXG4gICAgICAgIHZhciBzb3VyY2VQb2ludDtcbiAgICAgICAgaWYgKHNvdXJjZVZpZXcgJiYgIXNvdXJjZVZpZXcuaXNOb2RlQ29ubmVjdGlvbih0aGlzLnNvdXJjZU1hZ25ldCkpIHtcbiAgICAgICAgICAgIHNvdXJjZU1hZ25ldCA9ICh0aGlzLnNvdXJjZU1hZ25ldCB8fCBzb3VyY2VWaWV3LmVsKTtcbiAgICAgICAgICAgIHZhciBzb3VyY2VDb25uZWN0aW9uUG9pbnREZWYgPSBzb3VyY2VEZWYuY29ubmVjdGlvblBvaW50IHx8IHBhcGVyT3B0aW9ucy5kZWZhdWx0Q29ubmVjdGlvblBvaW50O1xuICAgICAgICAgICAgdmFyIHNvdXJjZVBvaW50UmVmID0gZmlyc3RXYXlwb2ludCB8fCB0YXJnZXRBbmNob3I7XG4gICAgICAgICAgICB2YXIgc291cmNlTGluZSA9IG5ldyBMaW5lKHNvdXJjZVBvaW50UmVmLCBzb3VyY2VBbmNob3IpO1xuICAgICAgICAgICAgc291cmNlUG9pbnQgPSB0aGlzLmdldENvbm5lY3Rpb25Qb2ludChcbiAgICAgICAgICAgICAgICBzb3VyY2VDb25uZWN0aW9uUG9pbnREZWYsXG4gICAgICAgICAgICAgICAgc291cmNlVmlldyxcbiAgICAgICAgICAgICAgICBzb3VyY2VNYWduZXQsXG4gICAgICAgICAgICAgICAgc291cmNlTGluZSxcbiAgICAgICAgICAgICAgICAnc291cmNlJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVBvaW50ID0gc291cmNlQW5jaG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbm5lY3Rpb24gUG9pbnQgVGFyZ2V0XG4gICAgICAgIHZhciB0YXJnZXRQb2ludDtcbiAgICAgICAgaWYgKHRhcmdldFZpZXcgJiYgIXRhcmdldFZpZXcuaXNOb2RlQ29ubmVjdGlvbih0aGlzLnRhcmdldE1hZ25ldCkpIHtcbiAgICAgICAgICAgIHRhcmdldE1hZ25ldCA9ICh0aGlzLnRhcmdldE1hZ25ldCB8fCB0YXJnZXRWaWV3LmVsKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRDb25uZWN0aW9uUG9pbnREZWYgPSB0YXJnZXREZWYuY29ubmVjdGlvblBvaW50IHx8IHBhcGVyT3B0aW9ucy5kZWZhdWx0Q29ubmVjdGlvblBvaW50O1xuICAgICAgICAgICAgdmFyIHRhcmdldFBvaW50UmVmID0gbGFzdFdheXBvaW50IHx8IHNvdXJjZUFuY2hvcjtcbiAgICAgICAgICAgIHZhciB0YXJnZXRMaW5lID0gbmV3IExpbmUodGFyZ2V0UG9pbnRSZWYsIHRhcmdldEFuY2hvcik7XG4gICAgICAgICAgICB0YXJnZXRQb2ludCA9IHRoaXMuZ2V0Q29ubmVjdGlvblBvaW50KFxuICAgICAgICAgICAgICAgIHRhcmdldENvbm5lY3Rpb25Qb2ludERlZixcbiAgICAgICAgICAgICAgICB0YXJnZXRWaWV3LFxuICAgICAgICAgICAgICAgIHRhcmdldE1hZ25ldCxcbiAgICAgICAgICAgICAgICB0YXJnZXRMaW5lLFxuICAgICAgICAgICAgICAgICd0YXJnZXQnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0UG9pbnQgPSB0YXJnZXRBbmNob3I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2VQb2ludCxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0UG9pbnRcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0QW5jaG9yOiBmdW5jdGlvbihhbmNob3JEZWYsIGNlbGxWaWV3LCBtYWduZXQsIHJlZiwgZW5kVHlwZSkge1xuXG4gICAgICAgIHZhciBpc0Nvbm5lY3Rpb24gPSBjZWxsVmlldy5pc05vZGVDb25uZWN0aW9uKG1hZ25ldCk7XG4gICAgICAgIHZhciBwYXBlck9wdGlvbnMgPSB0aGlzLnBhcGVyLm9wdGlvbnM7XG4gICAgICAgIGlmICghYW5jaG9yRGVmKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yRGVmID0gcGFwZXJPcHRpb25zLmRlZmF1bHRMaW5rQW5jaG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlcnBlbmRpY3VsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGBtYW5oYXR0YW5gIHJvdXRlciBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICAgICAgICAgICAgICAgIGFuY2hvckRlZiA9IHsgbmFtZTogJ3BlcnBlbmRpY3VsYXInIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yRGVmID0gcGFwZXJPcHRpb25zLmRlZmF1bHRBbmNob3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbmNob3JEZWYpIHRocm93IG5ldyBFcnJvcignQW5jaG9yIHJlcXVpcmVkLicpO1xuICAgICAgICB2YXIgYW5jaG9yRm47XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhbmNob3JGbiA9IGFuY2hvckRlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhbmNob3JOYW1lID0gYW5jaG9yRGVmLm5hbWU7XG4gICAgICAgICAgICB2YXIgYW5jaG9yTmFtZXNwYWNlID0gaXNDb25uZWN0aW9uID8gJ2xpbmtBbmNob3JOYW1lc3BhY2UnIDogJ2FuY2hvck5hbWVzcGFjZSc7XG4gICAgICAgICAgICBhbmNob3JGbiA9IHBhcGVyT3B0aW9uc1thbmNob3JOYW1lc3BhY2VdW2FuY2hvck5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFuY2hvcjogJyArIGFuY2hvck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmNob3IgPSBhbmNob3JGbi5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGNlbGxWaWV3LFxuICAgICAgICAgICAgbWFnbmV0LFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgYW5jaG9yRGVmLmFyZ3MgfHwge30sXG4gICAgICAgICAgICBlbmRUeXBlLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgICBpZiAoIWFuY2hvcikgcmV0dXJuIG5ldyBQb2ludCgpO1xuICAgICAgICByZXR1cm4gYW5jaG9yLnJvdW5kKHRoaXMuZGVjaW1hbHNSb3VuZGluZyk7XG4gICAgfSxcblxuXG4gICAgZ2V0Q29ubmVjdGlvblBvaW50OiBmdW5jdGlvbihjb25uZWN0aW9uUG9pbnREZWYsIHZpZXcsIG1hZ25ldCwgbGluZSwgZW5kVHlwZSkge1xuXG4gICAgICAgIHZhciBjb25uZWN0aW9uUG9pbnQ7XG4gICAgICAgIHZhciBhbmNob3IgPSBsaW5lLmVuZDtcbiAgICAgICAgdmFyIHBhcGVyT3B0aW9ucyA9IHRoaXMucGFwZXIub3B0aW9ucztcblxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25Qb2ludERlZikgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb25Qb2ludEZuO1xuICAgICAgICBpZiAodHlwZW9mIGNvbm5lY3Rpb25Qb2ludERlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Rm4gPSBjb25uZWN0aW9uUG9pbnREZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvblBvaW50TmFtZSA9IGNvbm5lY3Rpb25Qb2ludERlZi5uYW1lO1xuICAgICAgICAgICAgY29ubmVjdGlvblBvaW50Rm4gPSBwYXBlck9wdGlvbnMuY29ubmVjdGlvblBvaW50TmFtZXNwYWNlW2Nvbm5lY3Rpb25Qb2ludE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uUG9pbnRGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbm5lY3Rpb24gcG9pbnQ6ICcgKyBjb25uZWN0aW9uUG9pbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uUG9pbnQgPSBjb25uZWN0aW9uUG9pbnRGbi5jYWxsKHRoaXMsIGxpbmUsIHZpZXcsIG1hZ25ldCwgY29ubmVjdGlvblBvaW50RGVmLmFyZ3MgfHwge30sIGVuZFR5cGUsIHRoaXMpO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25Qb2ludCkgcmV0dXJuIGFuY2hvcjtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25Qb2ludC5yb3VuZCh0aGlzLmRlY2ltYWxzUm91bmRpbmcpO1xuICAgIH0sXG5cbiAgICBpc0ludGVyc2VjdGluZzogZnVuY3Rpb24oZ2VvbWV0cnlTaGFwZSwgZ2VvbWV0cnlEYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb24uZXhpc3RzKFxuICAgICAgICAgICAgZ2VvbWV0cnlTaGFwZSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb24sXG4gICAgICAgICAgICBnZW9tZXRyeURhdGEsXG4gICAgICAgICAgICB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0sXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGlzRW5jbG9zZWRJbjogZnVuY3Rpb24oZ2VvbWV0cnlSZWN0KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGJib3ggPSBjb25uZWN0aW9uLmJib3goKTtcbiAgICAgICAgaWYgKCFiYm94KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeVJlY3QuY29udGFpbnNSZWN0KGJib3gpO1xuICAgIH0sXG5cbiAgICBpc0F0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50IC8qLCBvcHRpb25zICovKSB7XG4gICAgICAgIC8vIE5vdGU6IGBzdHJpY3RgIG9wdGlvbiBpcyBub3QgYXBwbGljYWJsZSBmb3IgbGlua3MuXG4gICAgICAgIC8vIFRoZXJlIGlzIGN1cnJlbnRseSBubyBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIGEgcGF0aCBjb250YWlucyBhIHBvaW50LlxuICAgICAgICBjb25zdCBhcmVhID0gbmV3IFJlY3QocG9pbnQpO1xuICAgICAgICAvLyBJbnRlcnNlY3Rpb24gd2l0aCBhIHplcm8tc2l6ZSBhcmVhIGlzIG5vdCBwb3NzaWJsZS5cbiAgICAgICAgYXJlYS5pbmZsYXRlKHRoaXMuRVBTSUxPTik7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSW50ZXJzZWN0aW5nKGFyZWEpO1xuICAgIH0sXG5cbiAgICAvLyBjb21iaW5lIGRlZmF1bHQgbGFiZWwgcG9zaXRpb24gd2l0aCBidWlsdC1pbiBkZWZhdWx0IGxhYmVsIHBvc2l0aW9uXG4gICAgX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uUHJvcGVydHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgICAgICAgdmFyIGJ1aWx0aW5EZWZhdWx0TGFiZWwgPSBtb2RlbC5fYnVpbHRpbnMuZGVmYXVsdExhYmVsO1xuICAgICAgICB2YXIgYnVpbHRpbkRlZmF1bHRMYWJlbFBvc2l0aW9uID0gYnVpbHRpbkRlZmF1bHRMYWJlbC5wb3NpdGlvbjtcblxuICAgICAgICB2YXIgZGVmYXVsdExhYmVsID0gbW9kZWwuX2dldERlZmF1bHRMYWJlbCgpO1xuICAgICAgICB2YXIgZGVmYXVsdExhYmVsUG9zaXRpb24gPSB0aGlzLl9ub3JtYWxpemVMYWJlbFBvc2l0aW9uKGRlZmF1bHRMYWJlbC5wb3NpdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlKHt9LCBidWlsdGluRGVmYXVsdExhYmVsUG9zaXRpb24sIGRlZmF1bHRMYWJlbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLy8gaWYgbGFiZWwgcG9zaXRpb24gaXMgYSBudW1iZXIsIG5vcm1hbGl6ZSBpdCB0byBhIHBvc2l0aW9uIG9iamVjdFxuICAgIC8vIHRoaXMgbWFrZXMgc3VyZSB0aGF0IGxhYmVsIHBvc2l0aW9ucyBjYW4gYmUgbWVyZ2VkIHByb3Blcmx5XG4gICAgX25vcm1hbGl6ZUxhYmVsUG9zaXRpb246IGZ1bmN0aW9uKGxhYmVsUG9zaXRpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIGxhYmVsUG9zaXRpb24gPT09ICdudW1iZXInKSByZXR1cm4geyBkaXN0YW5jZTogbGFiZWxQb3NpdGlvbiwgb2Zmc2V0OiBudWxsLCBhbmdsZTogMCwgYXJnczogbnVsbCB9O1xuICAgICAgICByZXR1cm4gbGFiZWxQb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgLy8gZXhwZWN0cyBub3JtYWxpemVkIHBvc2l0aW9uIHByb3BlcnRpZXNcbiAgICAvLyBlLmcuIGB0aGlzLl9ub3JtYWxpemVMYWJlbFBvc2l0aW9uKGxhYmVsUG9zaXRpb24pYCBhbmQgYHRoaXMuX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uUHJvcGVydHkoKWBcbiAgICBfbWVyZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHk6IGZ1bmN0aW9uKG5vcm1hbGl6ZWRMYWJlbFBvc2l0aW9uLCBub3JtYWxpemVkRGVmYXVsdExhYmVsUG9zaXRpb24pIHtcblxuICAgICAgICBpZiAobm9ybWFsaXplZExhYmVsUG9zaXRpb24gPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobm9ybWFsaXplZExhYmVsUG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZERlZmF1bHRMYWJlbFBvc2l0aW9uID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRGVmYXVsdExhYmVsUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIG5vcm1hbGl6ZWREZWZhdWx0TGFiZWxQb3NpdGlvbiwgbm9ybWFsaXplZExhYmVsUG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICB1cGRhdGVMYWJlbFBvc2l0aW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9WLmxhYmVscykgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgYXNzdW1lcyBhbGwgdGhlIGxhYmVsIG5vZGVzIGFyZSBzdG9yZWQgaW4gdGhlIGB0aGlzLl9sYWJlbENhY2hlYCBoYXNoIHRhYmxlXG4gICAgICAgIC8vIGJ5IHRoZWlyIGluZGljZXMgaW4gdGhlIGB0aGlzLmdldCgnbGFiZWxzJylgIGFycmF5LiBUaGlzIGlzIGRvbmUgaW4gdGhlIGByZW5kZXJMYWJlbHMoKWAgbWV0aG9kLlxuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciBsYWJlbHMgPSBtb2RlbC5nZXQoJ2xhYmVscycpIHx8IFtdO1xuICAgICAgICBpZiAoIWxhYmVscy5sZW5ndGgpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbiA9IHRoaXMuX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uUHJvcGVydHkoKTtcblxuICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBuID0gbGFiZWxzLmxlbmd0aDsgaWR4IDwgbjsgaWR4KyspIHtcbiAgICAgICAgICAgIHZhciBsYWJlbE5vZGUgPSB0aGlzLl9sYWJlbENhY2hlW2lkeF07XG4gICAgICAgICAgICBpZiAoIWxhYmVsTm9kZSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBsYWJlbHNbaWR4XTtcbiAgICAgICAgICAgIHZhciBsYWJlbFBvc2l0aW9uID0gdGhpcy5fbm9ybWFsaXplTGFiZWxQb3NpdGlvbihsYWJlbC5wb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9tZXJnZUxhYmVsUG9zaXRpb25Qcm9wZXJ0eShsYWJlbFBvc2l0aW9uLCBkZWZhdWx0TGFiZWxQb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB0aGlzLl9nZXRMYWJlbFRyYW5zZm9ybWF0aW9uTWF0cml4KHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGxhYmVsTm9kZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcodHJhbnNmb3JtYXRpb25NYXRyaXgpKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFuTGFiZWxNYXRyaWNlcyhpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9jbGVhbkxhYmVsTWF0cmljZXM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIC8vIENsZWFuIG1hZ25ldE1hdHJpeCBmb3IgYWxsIG5vZGVzIG9mIHRoZSBsYWJlbC5cbiAgICAgICAgLy8gQ2FjaGVkIEJvdW5kaW5nUmVjdCBkb2VzIG5vdCBuZWVkIHRvIHVwZGF0ZWQgd2hlbiB0aGUgcG9zaXRpb24gY2hhbmdlc1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3Qgd29yayBmb3IgbGFiZWxzIHdpdGggWE1MIFN0cmluZyBtYXJrdXBzLlxuICAgICAgICBjb25zdCB7IG1ldHJpY3MsIF9sYWJlbFNlbGVjdG9ycyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JzID0gX2xhYmVsU2VsZWN0b3JzW2luZGV4XTtcbiAgICAgICAgaWYgKCFzZWxlY3RvcnMpIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgc2VsZWN0b3IgaW4gc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBzZWxlY3RvcnNbc2VsZWN0b3JdO1xuICAgICAgICAgICAgaWYgKGlkICYmIChpZCBpbiBtZXRyaWNzKSkgZGVsZXRlIG1ldHJpY3NbaWRdLm1hZ25ldE1hdHJpeDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVFbmRQcm9wZXJ0aWVzOiBmdW5jdGlvbihlbmRUeXBlKSB7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbCwgcGFwZXIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGVuZFZpZXdQcm9wZXJ0eSA9IGAke2VuZFR5cGV9Vmlld2A7XG4gICAgICAgIGNvbnN0IGVuZERlZiA9IG1vZGVsLmdldChlbmRUeXBlKTtcbiAgICAgICAgY29uc3QgZW5kSWQgPSBlbmREZWYgJiYgZW5kRGVmLmlkO1xuXG4gICAgICAgIGlmICghZW5kSWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBsaW5rIGVuZCBpcyBhIHBvaW50IH4gcmVjdCAweDBcbiAgICAgICAgICAgIHRoaXNbZW5kVmlld1Byb3BlcnR5XSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1hZ25ldChlbmRUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW5kTW9kZWwgPSBwYXBlci5nZXRNb2RlbEJ5SWQoZW5kSWQpO1xuICAgICAgICBpZiAoIWVuZE1vZGVsKSB0aHJvdyBuZXcgRXJyb3IoJ0xpbmtWaWV3OiBpbnZhbGlkICcgKyBlbmRUeXBlICsgJyBjZWxsLicpO1xuXG4gICAgICAgIGNvbnN0IGVuZFZpZXcgPSBlbmRNb2RlbC5maW5kVmlldyhwYXBlcik7XG4gICAgICAgIGlmICghZW5kVmlldykge1xuICAgICAgICAgICAgLy8gQSB2aWV3IGZvciBhIG1vZGVsIHNob3VsZCBhbHdheXMgZXhpc3RcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbZW5kVmlld1Byb3BlcnR5XSA9IGVuZFZpZXc7XG4gICAgICAgIHRoaXMudXBkYXRlRW5kTWFnbmV0KGVuZFR5cGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRW5kTWFnbmV0OiBmdW5jdGlvbihlbmRUeXBlKSB7XG5cbiAgICAgICAgY29uc3QgZW5kTWFnbmV0UHJvcGVydHkgPSBgJHtlbmRUeXBlfU1hZ25ldGA7XG4gICAgICAgIGNvbnN0IGVuZFZpZXcgPSB0aGlzLmdldEVuZFZpZXcoZW5kVHlwZSk7XG4gICAgICAgIGlmIChlbmRWaWV3KSB7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGVkTWFnbmV0ID0gZW5kVmlldy5nZXRNYWduZXRGcm9tTGlua0VuZCh0aGlzLm1vZGVsLmdldChlbmRUeXBlKSk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGVkTWFnbmV0ID09PSBlbmRWaWV3LmVsKSBjb25uZWN0ZWRNYWduZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpc1tlbmRNYWduZXRQcm9wZXJ0eV0gPSBjb25uZWN0ZWRNYWduZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2VuZE1hZ25ldFByb3BlcnR5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2dldExhYmVsUG9zaXRpb25Qcm9wZXJ0eTogZnVuY3Rpb24oaWR4KSB7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGVsLmxhYmVsKGlkeCkucG9zaXRpb24gfHwge30pO1xuICAgIH0sXG5cbiAgICBfZ2V0TGFiZWxQb3NpdGlvbkFuZ2xlOiBmdW5jdGlvbihpZHgpIHtcblxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IHRoaXMuX2dldExhYmVsUG9zaXRpb25Qcm9wZXJ0eShpZHgpO1xuICAgICAgICByZXR1cm4gKGxhYmVsUG9zaXRpb24uYW5nbGUgfHwgMCk7XG4gICAgfSxcblxuICAgIF9nZXRMYWJlbFBvc2l0aW9uQXJnczogZnVuY3Rpb24oaWR4KSB7XG5cbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSB0aGlzLl9nZXRMYWJlbFBvc2l0aW9uUHJvcGVydHkoaWR4KTtcbiAgICAgICAgcmV0dXJuIGxhYmVsUG9zaXRpb24uYXJncztcbiAgICB9LFxuXG4gICAgX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uQXJnczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbCA9IHRoaXMubW9kZWwuX2dldERlZmF1bHRMYWJlbCgpO1xuICAgICAgICB2YXIgZGVmYXVsdExhYmVsUG9zaXRpb24gPSBkZWZhdWx0TGFiZWwucG9zaXRpb24gfHwge307XG4gICAgICAgIHJldHVybiBkZWZhdWx0TGFiZWxQb3NpdGlvbi5hcmdzO1xuICAgIH0sXG5cbiAgICAvLyBtZXJnZSBkZWZhdWx0IGxhYmVsIHBvc2l0aW9uIGFyZ3MgaW50byBsYWJlbCBwb3NpdGlvbiBhcmdzXG4gICAgLy8ga2VlcCBgdW5kZWZpbmVkYCBvciBgbnVsbGAgYmVjYXVzZSBge31gIG1lYW5zIHNvbWV0aGluZyBlbHNlXG4gICAgX21lcmdlTGFiZWxQb3NpdGlvbkFyZ3M6IGZ1bmN0aW9uKGxhYmVsUG9zaXRpb25BcmdzLCBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MpIHtcblxuICAgICAgICBpZiAobGFiZWxQb3NpdGlvbkFyZ3MgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAobGFiZWxQb3NpdGlvbkFyZ3MgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBpZiAoZGVmYXVsdExhYmVsUG9zaXRpb25BcmdzID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVyZ2Uoe30sIGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncywgbGFiZWxQb3NpdGlvbkFyZ3MpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgZGVmYXVsdCBsYWJlbCBhdCBnaXZlbiBwb3NpdGlvbiBhdCBlbmQgb2YgYGxhYmVsc2AgYXJyYXkuXG4gICAgLy8gRm91ciBzaWduYXR1cmVzOlxuICAgIC8vIC0gb2JqLCBvYmogPSBwb2ludCwgb3B0XG4gICAgLy8gLSBvYmosIG51bSwgb2JqID0gcG9pbnQsIGFuZ2xlLCBvcHRcbiAgICAvLyAtIG51bSwgbnVtLCBvYmogPSB4LCB5LCBvcHRcbiAgICAvLyAtIG51bSwgbnVtLCBudW0sIG9iaiA9IHgsIHksIGFuZ2xlLCBvcHRcbiAgICAvLyBBc3NpZ25zIHJlbGF0aXZlIGNvb3JkaW5hdGVzIGJ5IGRlZmF1bHQ6XG4gICAgLy8gYG9wdC5hYnNvbHV0ZURpc3RhbmNlYCBmb3JjZXMgYWJzb2x1dGUgY29vcmRpbmF0ZXMuXG4gICAgLy8gYG9wdC5yZXZlcnNlRGlzdGFuY2VgIGZvcmNlcyByZXZlcnNlIGFic29sdXRlIGNvb3JkaW5hdGVzIChpZiBhYnNvbHV0ZURpc3RhbmNlID0gdHJ1ZSkuXG4gICAgLy8gYG9wdC5hYnNvbHV0ZU9mZnNldGAgZm9yY2VzIGFic29sdXRlIGNvb3JkaW5hdGVzIGZvciBvZmZzZXQuXG4gICAgLy8gQWRkaXRpb25hbCBhcmdzOlxuICAgIC8vIGBvcHQua2VlcEdyYWRpZW50YCBhdXRvLWFkanVzdHMgdGhlIGFuZ2xlIG9mIHRoZSBsYWJlbCB0byBtYXRjaCBwYXRoIGdyYWRpZW50IGF0IHBvc2l0aW9uLlxuICAgIC8vIGBvcHQuZW5zdXJlTGVnaWJpbGl0eWAgcm90YXRlcyBsYWJlbHMgc28gdGhleSBhcmUgbmV2ZXIgdXBzaWRlLWRvd24uXG4gICAgYWRkTGFiZWw6IGZ1bmN0aW9uKHAxLCBwMiwgcDMsIHA0KSB7XG5cbiAgICAgICAgLy8gbm9ybWFsaXplIGRhdGEgZnJvbSB0aGUgZm91ciBwb3NzaWJsZSBzaWduYXR1cmVzXG4gICAgICAgIHZhciBsb2NhbFg7XG4gICAgICAgIHZhciBsb2NhbFk7XG4gICAgICAgIHZhciBsb2NhbEFuZ2xlID0gMDtcbiAgICAgICAgdmFyIGxvY2FsT3B0O1xuICAgICAgICBpZiAodHlwZW9mIHAxICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8ge3gsIHl9IG9iamVjdCBwcm92aWRlZCBhcyBmaXJzdCBwYXJhbWV0ZXJcbiAgICAgICAgICAgIGxvY2FsWCA9IHAxLng7XG4gICAgICAgICAgICBsb2NhbFkgPSBwMS55O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwMiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBhbmdsZSBhbmQgb3B0IHByb3ZpZGVkIGFzIHNlY29uZCBhbmQgdGhpcmQgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgIGxvY2FsQW5nbGUgPSBwMjtcbiAgICAgICAgICAgICAgICBsb2NhbE9wdCA9IHAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvcHQgcHJvdmlkZWQgYXMgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgIGxvY2FsT3B0ID0gcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB4IGFuZCB5IHByb3ZpZGVkIGFzIGZpcnN0IGFuZCBzZWNvbmQgcGFyYW1ldGVyc1xuICAgICAgICAgICAgbG9jYWxYID0gcDE7XG4gICAgICAgICAgICBsb2NhbFkgPSBwMjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcDMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gYW5nbGUgYW5kIG9wdCBwcm92aWRlZCBhcyB0aGlyZCBhbmQgZm91cnRoIHBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICBsb2NhbEFuZ2xlID0gcDM7XG4gICAgICAgICAgICAgICAgbG9jYWxPcHQgPSBwNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0IHByb3ZpZGVkIGFzIHRoaXJkIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgIGxvY2FsT3B0ID0gcDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtZXJnZSBsYWJlbCBwb3NpdGlvbiBhcmd1bWVudHNcbiAgICAgICAgdmFyIGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncyA9IHRoaXMuX2dldERlZmF1bHRMYWJlbFBvc2l0aW9uQXJncygpO1xuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbkFyZ3MgPSBsb2NhbE9wdDtcbiAgICAgICAgdmFyIHBvc2l0aW9uQXJncyA9IHRoaXMuX21lcmdlTGFiZWxQb3NpdGlvbkFyZ3MobGFiZWxQb3NpdGlvbkFyZ3MsIGRlZmF1bHRMYWJlbFBvc2l0aW9uQXJncyk7XG5cbiAgICAgICAgLy8gYXBwZW5kIGxhYmVsIHRvIGxhYmVscyBhcnJheVxuICAgICAgICB2YXIgbGFiZWwgPSB7IHBvc2l0aW9uOiB0aGlzLmdldExhYmVsUG9zaXRpb24obG9jYWxYLCBsb2NhbFksIGxvY2FsQW5nbGUsIHBvc2l0aW9uQXJncykgfTtcbiAgICAgICAgdmFyIGlkeCA9IC0xO1xuICAgICAgICB0aGlzLm1vZGVsLmluc2VydExhYmVsKGlkeCwgbGFiZWwsIGxvY2FsT3B0KTtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbmV3IHZlcnRleCBhdCBjYWxjdWxhdGVkIGluZGV4IHRvIHRoZSBgdmVydGljZXNgIGFycmF5LlxuICAgIGFkZFZlcnRleDogZnVuY3Rpb24oeCwgeSwgb3B0KSB7XG5cbiAgICAgICAgLy8gYWNjZXB0IGlucHV0IGluIGZvcm0gYHsgeCwgeSB9LCBvcHRgIG9yIGB4LCB5LCBvcHRgXG4gICAgICAgIHZhciBpc1BvaW50UHJvdmlkZWQgPSAodHlwZW9mIHggIT09ICdudW1iZXInKTtcbiAgICAgICAgdmFyIGxvY2FsWCA9IGlzUG9pbnRQcm92aWRlZCA/IHgueCA6IHg7XG4gICAgICAgIHZhciBsb2NhbFkgPSBpc1BvaW50UHJvdmlkZWQgPyB4LnkgOiB5O1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSBpc1BvaW50UHJvdmlkZWQgPyB5IDogb3B0O1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB7IHg6IGxvY2FsWCwgeTogbG9jYWxZIH07XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmdldFZlcnRleEluZGV4KGxvY2FsWCwgbG9jYWxZKTtcbiAgICAgICAgdGhpcy5tb2RlbC5pbnNlcnRWZXJ0ZXgoaWR4LCB2ZXJ0ZXgsIGxvY2FsT3B0KTtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgLy8gU2VuZCBhIHRva2VuIChhbiBTVkcgZWxlbWVudCwgdXN1YWxseSBhIGNpcmNsZSkgYWxvbmcgdGhlIGNvbm5lY3Rpb24gcGF0aC5cbiAgICAvLyBFeGFtcGxlOiBgbGluay5maW5kVmlldyhwYXBlcikuc2VuZFRva2VuKFYoJ2NpcmNsZScsIHsgcjogNywgZmlsbDogJ2dyZWVuJyB9KS5ub2RlKWBcbiAgICAvLyBgb3B0LmR1cmF0aW9uYCBpcyBvcHRpb25hbCBhbmQgaXMgYSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGF0IHRoZSB0b2tlbiB0cmF2ZWxzIGZyb20gdGhlIHNvdXJjZSB0byB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rLiBEZWZhdWx0IGlzIGAxMDAwYC5cbiAgICAvLyBgb3B0LmRpcmVjdGlvbmAgaXMgb3B0aW9uYWwgYW5kIGl0IGRldGVybWluZXMgd2hldGhlciB0aGUgdG9rZW4gZ29lcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgb3Igb3RoZXIgd2F5IHJvdW5kIChgcmV2ZXJzZWApXG4gICAgLy8gYG9wdC5jb25uZWN0aW9uYCBpcyBhbiBvcHRpb25hbCBzZWxlY3RvciB0byB0aGUgY29ubmVjdGlvbiBwYXRoLlxuICAgIC8vIGBjYWxsYmFja2AgaXMgb3B0aW9uYWwgYW5kIGlzIGEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgdGhlIHRva2VuIHJlYWNoZXMgdGhlIHRhcmdldC5cbiAgICBzZW5kVG9rZW46IGZ1bmN0aW9uKHRva2VuLCBvcHQsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gb25BbmltYXRpb25FbmQodlRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZUb2tlbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkdXJhdGlvbiwgaXNSZXZlcnNlZCwgc2VsZWN0b3I7XG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IG9wdC5kdXJhdGlvbjtcbiAgICAgICAgICAgIGlzUmV2ZXJzZWQgPSAob3B0LmRpcmVjdGlvbiA9PT0gJ3JldmVyc2UnKTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gb3B0LmNvbm5lY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgZHVyYXRpb24gPSBvcHQ7XG4gICAgICAgICAgICBpc1JldmVyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDEwMDA7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBkdXI6IGR1cmF0aW9uICsgJ21zJyxcbiAgICAgICAgICAgIHJlcGVhdENvdW50OiAxLFxuICAgICAgICAgICAgY2FsY01vZGU6ICdsaW5lYXInLFxuICAgICAgICAgICAgZmlsbDogJ2ZyZWV6ZSdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNSZXZlcnNlZCkge1xuICAgICAgICAgICAgYW5pbWF0aW9uQXR0cmlidXRlcy5rZXlQb2ludHMgPSAnMTswJztcbiAgICAgICAgICAgIGFuaW1hdGlvbkF0dHJpYnV0ZXMua2V5VGltZXMgPSAnMDsxJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2VG9rZW4gPSBWKHRva2VuKTtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBVc2UgY3VzdG9tIGNvbm5lY3Rpb24gcGF0aC5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLmZpbmROb2RlKHNlbGVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdCBjb25uZWN0aW9uIHBhdGggYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHRoaXMuX1Y7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gKGNhY2hlLmNvbm5lY3Rpb24pID8gY2FjaGUuY29ubmVjdGlvbi5ub2RlIDogdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdwYXRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShjb25uZWN0aW9uIGluc3RhbmNlb2YgU1ZHUGF0aEVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdG9rZW4gYW5pbWF0aW9uIHJlcXVpcmVzIGEgdmFsaWQgY29ubmVjdGlvbiBwYXRoLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdlRva2VuXG4gICAgICAgICAgICAuYXBwZW5kVG8odGhpcy5wYXBlci5jZWxscylcbiAgICAgICAgICAgIC5hbmltYXRlQWxvbmdQYXRoKGFuaW1hdGlvbkF0dHJpYnV0ZXMsIGNvbm5lY3Rpb24pO1xuXG4gICAgICAgIHNldFRpbWVvdXQob25BbmltYXRpb25FbmQodlRva2VuLCBjYWxsYmFjayksIGR1cmF0aW9uKTtcbiAgICB9LFxuXG4gICAgZmluZFJvdXRlOiBmdW5jdGlvbih2ZXJ0aWNlcykge1xuXG4gICAgICAgIHZlcnRpY2VzIHx8ICh2ZXJ0aWNlcyA9IFtdKTtcblxuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5wYXBlci5vcHRpb25zLnJvdXRlck5hbWVzcGFjZSB8fCByb3V0ZXJzO1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5tb2RlbC5yb3V0ZXIoKTtcbiAgICAgICAgdmFyIGRlZmF1bHRSb3V0ZXIgPSB0aGlzLnBhcGVyLm9wdGlvbnMuZGVmYXVsdFJvdXRlcjtcblxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRSb3V0ZXIpIHJvdXRlciA9IGRlZmF1bHRSb3V0ZXI7XG4gICAgICAgICAgICBlbHNlIHJldHVybiB2ZXJ0aWNlcy5tYXAoUG9pbnQpOyAvLyBubyByb3V0ZXIgc3BlY2lmaWVkXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm91dGVyRm4gPSBpc0Z1bmN0aW9uKHJvdXRlcikgPyByb3V0ZXIgOiBuYW1lc3BhY2Vbcm91dGVyLm5hbWVdO1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24ocm91dGVyRm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdW5rbm93biByb3V0ZXI6IFwiJyArIHJvdXRlci5uYW1lICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSByb3V0ZXIuYXJncyB8fCB7fTtcblxuICAgICAgICB2YXIgcm91dGUgPSByb3V0ZXJGbi5jYWxsKFxuICAgICAgICAgICAgdGhpcywgLy8gY29udGV4dFxuICAgICAgICAgICAgdmVydGljZXMsIC8vIHZlcnRpY2VzXG4gICAgICAgICAgICBhcmdzLCAvLyBvcHRpb25zXG4gICAgICAgICAgICB0aGlzIC8vIGxpbmtWaWV3XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIHZlcnRpY2VzLm1hcChQb2ludCk7XG4gICAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBgZGAgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBgPHBhdGg+YCBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgbGlua1xuICAgIC8vIGJldHdlZW4gYHNvdXJjZWAgYW5kIGB0YXJnZXRgLlxuICAgIGZpbmRQYXRoOiBmdW5jdGlvbihyb3V0ZSwgc291cmNlUG9pbnQsIHRhcmdldFBvaW50KSB7XG5cbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMucGFwZXIub3B0aW9ucy5jb25uZWN0b3JOYW1lc3BhY2UgfHwgY29ubmVjdG9ycztcbiAgICAgICAgdmFyIGNvbm5lY3RvciA9IHRoaXMubW9kZWwuY29ubmVjdG9yKCk7XG4gICAgICAgIHZhciBkZWZhdWx0Q29ubmVjdG9yID0gdGhpcy5wYXBlci5vcHRpb25zLmRlZmF1bHRDb25uZWN0b3I7XG5cbiAgICAgICAgaWYgKCFjb25uZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbm5lY3RvciA9IGRlZmF1bHRDb25uZWN0b3IgfHwge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29ubmVjdG9yRm4gPSBpc0Z1bmN0aW9uKGNvbm5lY3RvcikgPyBjb25uZWN0b3IgOiBuYW1lc3BhY2VbY29ubmVjdG9yLm5hbWVdO1xuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oY29ubmVjdG9yRm4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpYS5MaW5rVmlldzogdW5rbm93biBjb25uZWN0b3I6IFwiJyArIGNvbm5lY3Rvci5uYW1lICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBjbG9uZShjb25uZWN0b3IuYXJncyB8fCB7fSk7XG4gICAgICAgIGFyZ3MucmF3ID0gdHJ1ZTsgLy8gUmVxdWVzdCByYXcgZy5QYXRoIGFzIHRoZSByZXN1bHQuXG5cbiAgICAgICAgdmFyIHBhdGggPSBjb25uZWN0b3JGbi5jYWxsKFxuICAgICAgICAgICAgdGhpcywgLy8gY29udGV4dFxuICAgICAgICAgICAgc291cmNlUG9pbnQsIC8vIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICB0YXJnZXRQb2ludCwgLy8gZW5kIHBvaW50XG4gICAgICAgICAgICByb3V0ZSwgLy8gdmVydGljZXNcbiAgICAgICAgICAgIGFyZ3MsIC8vIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMgLy8gbGlua1ZpZXdcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgY29ubmVjdG9ycyBub3Qgc3VwcG9ydGluZyBgcmF3YCBvcHRpb24uXG4gICAgICAgICAgICBwYXRoID0gbmV3IFBhdGgoVi5ub3JtYWxpemVQYXRoRGF0YShwYXRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLy8gUHVibGljIEFQSS5cbiAgICAvLyAtLS0tLS0tLS0tLVxuXG4gICAgZ2V0Q29ubmVjdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHBhdGguY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VyaWFsaXplZENvbm5lY3Rpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5tZXRyaWNzO1xuICAgICAgICBpZiAobWV0cmljcy5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSByZXR1cm4gbWV0cmljcy5kYXRhO1xuICAgICAgICB2YXIgZGF0YSA9IHBhdGguc2VyaWFsaXplKCk7XG4gICAgICAgIG1ldHJpY3MuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICBnZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgbWV0cmljcyA9IHRoaXMubWV0cmljcztcbiAgICAgICAgaWYgKG1ldHJpY3MuaGFzT3duUHJvcGVydHkoJ3NlZ21lbnRTdWJkaXZpc2lvbnMnKSkgcmV0dXJuIG1ldHJpY3Muc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHBhdGguZ2V0U2VnbWVudFN1YmRpdmlzaW9ucygpO1xuICAgICAgICBtZXRyaWNzLnNlZ21lbnRTdWJkaXZpc2lvbnMgPSBzdWJkaXZpc2lvbnM7XG4gICAgICAgIHJldHVybiBzdWJkaXZpc2lvbnM7XG4gICAgfSxcblxuICAgIGdldENvbm5lY3Rpb25MZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiAwO1xuXG4gICAgICAgIHZhciBtZXRyaWNzID0gdGhpcy5tZXRyaWNzO1xuICAgICAgICBpZiAobWV0cmljcy5oYXNPd25Qcm9wZXJ0eSgnbGVuZ3RoJykpIHJldHVybiBtZXRyaWNzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoKHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgICAgIG1ldHJpY3MubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC5wb2ludEF0TGVuZ3RoKGxlbmd0aCwgeyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9KTtcbiAgICB9LFxuXG4gICAgZ2V0UG9pbnRBdFJhdGlvOiBmdW5jdGlvbihyYXRpbykge1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoaXNQZXJjZW50YWdlKHJhdGlvKSkgcmF0aW8gPSBwYXJzZUZsb2F0KHJhdGlvKSAvIDEwMDtcbiAgICAgICAgcmV0dXJuIHBhdGgucG9pbnRBdChyYXRpbywgeyBzZWdtZW50U3ViZGl2aXNpb25zOiB0aGlzLmdldENvbm5lY3Rpb25TdWJkaXZpc2lvbnMoKSB9KTtcbiAgICB9LFxuXG4gICAgZ2V0VGFuZ2VudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC50YW5nZW50QXRMZW5ndGgobGVuZ3RoLCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH0pO1xuICAgIH0sXG5cbiAgICBnZXRUYW5nZW50QXRSYXRpbzogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC50YW5nZW50QXQocmF0aW8sIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldENsb3Nlc3RQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC5jbG9zZXN0UG9pbnQocG9pbnQsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldENsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcblxuICAgICAgICByZXR1cm4gcGF0aC5jbG9zZXN0UG9pbnRMZW5ndGgocG9pbnQsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIGdldENsb3Nlc3RQb2ludFJhdGlvOiBmdW5jdGlvbihwb2ludCkge1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiBwYXRoLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocG9pbnQsIHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCBsYWJlbCBwb3NpdGlvbiBvYmplY3QgYmFzZWQgb24gdHdvIHByb3ZpZGVkIGNvb3JkaW5hdGVzLCB4IGFuZCB5LlxuICAgIC8vIChVc2VkIGJlaGluZCB0aGUgc2NlbmVzIHdoZW4gdXNlciBtb3ZlcyBsYWJlbHMgYXJvdW5kLilcbiAgICAvLyBUd28gc2lnbmF0dXJlczpcbiAgICAvLyAtIG51bSwgbnVtLCBvYmogPSB4LCB5LCBvcHRpb25zXG4gICAgLy8gLSBudW0sIG51bSwgbnVtLCBvYmogPSB4LCB5LCBhbmdsZSwgb3B0aW9uc1xuICAgIC8vIEFjY2VwdHMgZGlzdGFuY2Uvb2Zmc2V0IG9wdGlvbnMgPSBgYWJzb2x1dGVEaXN0YW5jZTogYm9vbGVhbmAsIGByZXZlcnNlRGlzdGFuY2U6IGJvb2xlYW5gLCBgYWJzb2x1dGVPZmZzZXQ6IGJvb2xlYW5gXG4gICAgLy8gLSBgYWJzb2x1dGVPZmZzZXRgIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBtb3ZlIGJleW9uZCBjb25uZWN0aW9uIGVuZHBvaW50c1xuICAgIC8vIEFkZGl0aW9uYWwgb3B0aW9ucyA9IGBrZWVwR3JhZGllbnQ6IGJvb2xlYW5gLCBgZW5zdXJlTGVnaWJpbGl0eTogYm9vbGVhbmBcbiAgICBnZXRMYWJlbFBvc2l0aW9uOiBmdW5jdGlvbih4LCB5LCBwMywgcDQpIHtcblxuICAgICAgICB2YXIgcG9zaXRpb24gPSB7fTtcblxuICAgICAgICAvLyBub3JtYWxpemUgZGF0YSBmcm9tIHRoZSB0d28gcG9zc2libGUgc2lnbmF0dXJlc1xuICAgICAgICB2YXIgbG9jYWxBbmdsZSA9IDA7XG4gICAgICAgIHZhciBsb2NhbE9wdDtcbiAgICAgICAgaWYgKHR5cGVvZiBwMyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGFuZ2xlIGFuZCBvcHQgcHJvdmlkZWQgYXMgdGhpcmQgYW5kIGZvdXJ0aCBhcmd1bWVudFxuICAgICAgICAgICAgbG9jYWxBbmdsZSA9IHAzO1xuICAgICAgICAgICAgbG9jYWxPcHQgPSBwNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG9wdCBwcm92aWRlZCBhcyB0aGlyZCBhcmd1bWVudFxuICAgICAgICAgICAgbG9jYWxPcHQgPSBwMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgbG9jYWxPcHQgYXMgYGFyZ3NgIG9mIHRoZSBwb3NpdGlvbiBvYmplY3QgdGhhdCBpcyBwYXNzZWQgYWxvbmdcbiAgICAgICAgaWYgKGxvY2FsT3B0KSBwb3NpdGlvbi5hcmdzID0gbG9jYWxPcHQ7XG5cbiAgICAgICAgLy8gaWRlbnRpZnkgZGlzdGFuY2Uvb2Zmc2V0IHNldHRpbmdzXG4gICAgICAgIHZhciBpc0Rpc3RhbmNlUmVsYXRpdmUgPSAhKGxvY2FsT3B0ICYmIGxvY2FsT3B0LmFic29sdXRlRGlzdGFuY2UpOyAvLyByZWxhdGl2ZSBieSBkZWZhdWx0XG4gICAgICAgIHZhciBpc0Rpc3RhbmNlQWJzb2x1dGVSZXZlcnNlID0gKGxvY2FsT3B0ICYmIGxvY2FsT3B0LmFic29sdXRlRGlzdGFuY2UgJiYgbG9jYWxPcHQucmV2ZXJzZURpc3RhbmNlKTsgLy8gbm9uLXJldmVyc2UgYnkgZGVmYXVsdFxuICAgICAgICB2YXIgaXNPZmZzZXRBYnNvbHV0ZSA9IGxvY2FsT3B0ICYmIGxvY2FsT3B0LmFic29sdXRlT2Zmc2V0OyAvLyBvZmZzZXQgaXMgbm9uLWFic29sdXRlIGJ5IGRlZmF1bHRcblxuICAgICAgICAvLyBmaW5kIGNsb3Nlc3QgcG9pbnQgdFxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgdmFyIHBhdGhPcHQgPSB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHRoaXMuZ2V0Q29ubmVjdGlvblN1YmRpdmlzaW9ucygpIH07XG4gICAgICAgIHZhciBsYWJlbFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB2YXIgdCA9IHBhdGguY2xvc2VzdFBvaW50VChsYWJlbFBvaW50LCBwYXRoT3B0KTtcblxuICAgICAgICAvLyBESVNUQU5DRTpcbiAgICAgICAgdmFyIGxhYmVsRGlzdGFuY2UgPSBwYXRoLmxlbmd0aEF0VCh0LCBwYXRoT3B0KTtcbiAgICAgICAgaWYgKGlzRGlzdGFuY2VSZWxhdGl2ZSkgbGFiZWxEaXN0YW5jZSA9IChsYWJlbERpc3RhbmNlIC8gdGhpcy5nZXRDb25uZWN0aW9uTGVuZ3RoKCkpIHx8IDA7IC8vIGZpeCB0byBwcmV2ZW50IE5hTiBmb3IgMCBsZW5ndGhcbiAgICAgICAgaWYgKGlzRGlzdGFuY2VBYnNvbHV0ZVJldmVyc2UpIGxhYmVsRGlzdGFuY2UgPSAoLTEgKiAodGhpcy5nZXRDb25uZWN0aW9uTGVuZ3RoKCkgLSBsYWJlbERpc3RhbmNlKSkgfHwgMTsgLy8gZml4IGZvciBlbmQgcG9pbnQgKC0wID0+IDEpXG4gICAgICAgIHBvc2l0aW9uLmRpc3RhbmNlID0gbGFiZWxEaXN0YW5jZTtcblxuICAgICAgICAvLyBPRkZTRVQ6XG4gICAgICAgIC8vIHVzZSBhYnNvbHV0ZSBvZmZzZXQgaWY6XG4gICAgICAgIC8vIC0gb3B0LmFic29sdXRlT2Zmc2V0IGlzIHRydWUsXG4gICAgICAgIC8vIC0gb3B0LmFic29sdXRlT2Zmc2V0IGlzIG5vdCB0cnVlIGJ1dCB0aGVyZSBpcyBubyB0YW5nZW50XG4gICAgICAgIHZhciB0YW5nZW50O1xuICAgICAgICBpZiAoIWlzT2Zmc2V0QWJzb2x1dGUpIHRhbmdlbnQgPSBwYXRoLnRhbmdlbnRBdFQodCk7XG4gICAgICAgIHZhciBsYWJlbE9mZnNldDtcbiAgICAgICAgaWYgKHRhbmdlbnQpIHtcbiAgICAgICAgICAgIGxhYmVsT2Zmc2V0ID0gdGFuZ2VudC5wb2ludE9mZnNldChsYWJlbFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSBwYXRoLnBvaW50QXRUKHQpO1xuICAgICAgICAgICAgdmFyIGxhYmVsT2Zmc2V0RGlmZiA9IGxhYmVsUG9pbnQuZGlmZmVyZW5jZShjbG9zZXN0UG9pbnQpO1xuICAgICAgICAgICAgbGFiZWxPZmZzZXQgPSB7IHg6IGxhYmVsT2Zmc2V0RGlmZi54LCB5OiBsYWJlbE9mZnNldERpZmYueSB9O1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9uLm9mZnNldCA9IGxhYmVsT2Zmc2V0O1xuXG4gICAgICAgIC8vIEFOR0xFOlxuICAgICAgICBwb3NpdGlvbi5hbmdsZSA9IGxvY2FsQW5nbGU7XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICBfZ2V0TGFiZWxUcmFuc2Zvcm1hdGlvbk1hdHJpeDogZnVuY3Rpb24obGFiZWxQb3NpdGlvbikge1xuXG4gICAgICAgIHZhciBsYWJlbERpc3RhbmNlO1xuICAgICAgICB2YXIgbGFiZWxBbmdsZSA9IDA7XG4gICAgICAgIHZhciBhcmdzID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWxQb3NpdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGxhYmVsRGlzdGFuY2UgPSBsYWJlbFBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbFBvc2l0aW9uLmRpc3RhbmNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYXJncyA9IGxhYmVsUG9zaXRpb24uYXJncyB8fCB7fTtcbiAgICAgICAgICAgIGxhYmVsRGlzdGFuY2UgPSBsYWJlbFBvc2l0aW9uLmRpc3RhbmNlO1xuICAgICAgICAgICAgbGFiZWxBbmdsZSA9IGxhYmVsUG9zaXRpb24uYW5nbGUgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkxpbmtWaWV3OiBpbnZhbGlkIGxhYmVsIHBvc2l0aW9uIGRpc3RhbmNlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzRGlzdGFuY2VSZWxhdGl2ZSA9ICgobGFiZWxEaXN0YW5jZSA+IDApICYmIChsYWJlbERpc3RhbmNlIDw9IDEpKTtcblxuICAgICAgICB2YXIgbGFiZWxPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgbGFiZWxPZmZzZXRDb29yZGluYXRlcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBpZiAobGFiZWxQb3NpdGlvbi5vZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbk9mZnNldCA9IGxhYmVsUG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbk9mZnNldCA9PT0gJ251bWJlcicpIGxhYmVsT2Zmc2V0ID0gcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25PZmZzZXQueCkgbGFiZWxPZmZzZXRDb29yZGluYXRlcy54ID0gcG9zaXRpb25PZmZzZXQueDtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbk9mZnNldC55KSBsYWJlbE9mZnNldENvb3JkaW5hdGVzLnkgPSBwb3NpdGlvbk9mZnNldC55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzT2Zmc2V0QWJzb2x1dGUgPSAoKGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMueCAhPT0gMCkgfHwgKGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMueSAhPT0gMCkgfHwgbGFiZWxPZmZzZXQgPT09IDApO1xuXG4gICAgICAgIHZhciBpc0tlZXBHcmFkaWVudCA9IGFyZ3Mua2VlcEdyYWRpZW50O1xuICAgICAgICB2YXIgaXNFbnN1cmVMZWdpYmlsaXR5ID0gYXJncy5lbnN1cmVMZWdpYmlsaXR5O1xuXG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICB2YXIgcGF0aE9wdCA9IHsgc2VnbWVudFN1YmRpdmlzaW9uczogdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCkgfTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpc0Rpc3RhbmNlUmVsYXRpdmUgPyAobGFiZWxEaXN0YW5jZSAqIHRoaXMuZ2V0Q29ubmVjdGlvbkxlbmd0aCgpKSA6IGxhYmVsRGlzdGFuY2U7XG4gICAgICAgIHZhciB0YW5nZW50ID0gcGF0aC50YW5nZW50QXRMZW5ndGgoZGlzdGFuY2UsIHBhdGhPcHQpO1xuXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIGFuZ2xlID0gbGFiZWxBbmdsZTtcbiAgICAgICAgaWYgKHRhbmdlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc09mZnNldEFic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSB0YW5nZW50LnN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb24ub2Zmc2V0KGxhYmVsT2Zmc2V0Q29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gdGFuZ2VudC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5vcm1hbC5yb3RhdGUodGFuZ2VudC5zdGFydCwgLTkwKTtcbiAgICAgICAgICAgICAgICBub3JtYWwuc2V0TGVuZ3RoKGxhYmVsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IG5vcm1hbC5lbmQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0tlZXBHcmFkaWVudCkge1xuICAgICAgICAgICAgICAgIGFuZ2xlID0gKHRhbmdlbnQuYW5nbGUoKSArIGxhYmVsQW5nbGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Vuc3VyZUxlZ2liaWxpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBub3JtYWxpemVBbmdsZSgoKGFuZ2xlICsgOTApICUgMTgwKSAtIDkwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIC0gdGhlIGNvbm5lY3Rpb24gaGFzIHplcm8gbGVuZ3RoXG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9IHBhdGguc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmIChpc09mZnNldEFic29sdXRlKSB0cmFuc2xhdGlvbi5vZmZzZXQobGFiZWxPZmZzZXRDb29yZGluYXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgoKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55KVxuICAgICAgICAgICAgLnJvdGF0ZShhbmdsZSk7XG4gICAgfSxcblxuICAgIGdldExhYmVsQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKGxhYmVsUG9zaXRpb24pIHtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB0aGlzLl9nZXRMYWJlbFRyYW5zZm9ybWF0aW9uTWF0cml4KGxhYmVsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRyYW5zZm9ybWF0aW9uTWF0cml4LmUsIHRyYW5zZm9ybWF0aW9uTWF0cml4LmYpO1xuICAgIH0sXG5cbiAgICBnZXRWZXJ0ZXhJbmRleDogZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IG1vZGVsLnZlcnRpY2VzKCk7XG5cbiAgICAgICAgdmFyIHZlcnRleExlbmd0aCA9IHRoaXMuZ2V0Q2xvc2VzdFBvaW50TGVuZ3RoKG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIGZvciAodmFyIG4gPSB2ZXJ0aWNlcy5sZW5ndGg7IGlkeCA8IG47IGlkeCsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZlcnRleCA9IHZlcnRpY2VzW2lkeF07XG4gICAgICAgICAgICB2YXIgY3VycmVudFZlcnRleExlbmd0aCA9IHRoaXMuZ2V0Q2xvc2VzdFBvaW50TGVuZ3RoKGN1cnJlbnRWZXJ0ZXgpO1xuICAgICAgICAgICAgaWYgKHZlcnRleExlbmd0aCA8IGN1cnJlbnRWZXJ0ZXhMZW5ndGgpIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJhY3Rpb24uIFRoZSBjb250cm9sbGVyIHBhcnQuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBub3RpZnlQb2ludGVyZG93bihldnQsIHgsIHkpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJkb3duLmNhbGwodGhpcywgZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6cG9pbnRlcmRvd24nLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBub3RpZnlQb2ludGVybW92ZShldnQsIHgsIHkpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLnBvaW50ZXJtb3ZlLmNhbGwodGhpcywgZXZ0LCB4LCB5KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6cG9pbnRlcm1vdmUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBub3RpZnlQb2ludGVydXAoZXZ0LCB4LCB5KSB7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJ1cCcsIGV2dCwgeCwgeSk7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVydXAuY2FsbCh0aGlzLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyZGJsY2xpY2s6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5wb2ludGVyZGJsY2xpY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6cG9pbnRlcmRibGNsaWNrJywgZXZ0LCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcG9pbnRlcmNsaWNrOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUucG9pbnRlcmNsaWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOnBvaW50ZXJjbGljaycsIGV2dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUuY29udGV4dG1lbnUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6Y29udGV4dG1lbnUnLCBldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVyZG93bihldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLmRyYWdTdGFydChldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVybW92ZTogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdmFyIGRyYWdEYXRhID0gdGhpcy5fZHJhZ0RhdGE7XG4gICAgICAgIGlmIChkcmFnRGF0YSkgdGhpcy5ldmVudERhdGEoZXZ0LCBkcmFnRGF0YSk7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBzd2l0Y2ggKGRhdGEuYWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2xhYmVsLW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0xhYmVsKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Fycm93aGVhZC1tb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdBcnJvd2hlYWQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAoZHJhZ0RhdGEpIGFzc2lnbihkcmFnRGF0YSwgdGhpcy5ldmVudERhdGEoZXZ0KSk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVybW92ZShldnQsIHgsIHkpO1xuICAgIH0sXG5cbiAgICBwb2ludGVydXA6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHZhciBkcmFnRGF0YSA9IHRoaXMuX2RyYWdEYXRhO1xuICAgICAgICBpZiAoZHJhZ0RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgZHJhZ0RhdGEpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ0RhdGEgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBzd2l0Y2ggKGRhdGEuYWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2xhYmVsLW1vdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0xhYmVsRW5kKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Fycm93aGVhZC1tb3ZlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdBcnJvd2hlYWRFbmQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRW5kKGV2dCwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vdGlmeVBvaW50ZXJ1cChldnQsIHgsIHkpO1xuICAgICAgICB0aGlzLmNoZWNrTW91c2VsZWF2ZShldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZW92ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6bW91c2VvdmVyJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZW91dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazptb3VzZW91dCcsIGV2dCk7XG4gICAgfSxcblxuICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZWVudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOm1vdXNlZW50ZXInLCBldnQpO1xuICAgIH0sXG5cbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUubW91c2VsZWF2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5vdGlmeSgnbGluazptb3VzZWxlYXZlJywgZXZ0KTtcbiAgICB9LFxuXG4gICAgbW91c2V3aGVlbDogZnVuY3Rpb24oZXZ0LCB4LCB5LCBkZWx0YSkge1xuXG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5tb3VzZXdoZWVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOm1vdXNld2hlZWwnLCBldnQsIHgsIHksIGRlbHRhKTtcbiAgICB9LFxuXG4gICAgb25sYWJlbDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdGhpcy5ub3RpZnlQb2ludGVyZG93bihldnQsIHgsIHkpO1xuXG4gICAgICAgIHRoaXMuZHJhZ0xhYmVsU3RhcnQoZXZ0LCB4LCB5KTtcblxuICAgICAgICB2YXIgc3RvcFByb3BhZ2F0aW9uID0gdGhpcy5ldmVudERhdGEoZXZ0KS5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24pIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgLy8gRHJhZyBTdGFydCBIYW5kbGVyc1xuXG4gICAgZHJhZ0xhYmVsU3RhcnQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGlmICh0aGlzLmNhbignbGFiZWxNb3ZlJykpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQoZXZ0KSkgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWxOb2RlID0gZXZ0LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICB2YXIgbGFiZWxJZHggPSBwYXJzZUludChsYWJlbE5vZGUuZ2V0QXR0cmlidXRlKCdsYWJlbC1pZHgnKSwgMTApO1xuXG4gICAgICAgICAgICB2YXIgZGVmYXVsdExhYmVsUG9zaXRpb24gPSB0aGlzLl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvblByb3BlcnR5KCk7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbExhYmVsUG9zaXRpb24gPSB0aGlzLl9ub3JtYWxpemVMYWJlbFBvc2l0aW9uKHRoaXMuX2dldExhYmVsUG9zaXRpb25Qcm9wZXJ0eShsYWJlbElkeCkpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fbWVyZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHkoaW5pdGlhbExhYmVsUG9zaXRpb24sIGRlZmF1bHRMYWJlbFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuZ2V0TGFiZWxDb29yZGluYXRlcyhwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgZHggPSBjb29yZHMueCAtIHg7IC8vIGhvdyBtdWNoIG5lZWRzIHRvIGJlIGFkZGVkIHRvIGN1cnNvciB4IHRvIGdldCB0byBsYWJlbCB4XG4gICAgICAgICAgICB2YXIgZHkgPSBjb29yZHMueSAtIHk7IC8vIGhvdyBtdWNoIG5lZWRzIHRvIGJlIGFkZGVkIHRvIGN1cnNvciB5IHRvIGdldCB0byBsYWJlbCB5XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFuZ2xlID0gdGhpcy5fZ2V0TGFiZWxQb3NpdGlvbkFuZ2xlKGxhYmVsSWR4KTtcbiAgICAgICAgICAgIHZhciBsYWJlbFBvc2l0aW9uQXJncyA9IHRoaXMuX2dldExhYmVsUG9zaXRpb25BcmdzKGxhYmVsSWR4KTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MgPSB0aGlzLl9nZXREZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MoKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFyZ3MgPSB0aGlzLl9tZXJnZUxhYmVsUG9zaXRpb25BcmdzKGxhYmVsUG9zaXRpb25BcmdzLCBkZWZhdWx0TGFiZWxQb3NpdGlvbkFyZ3MpO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdsYWJlbC1tb3ZlJyxcbiAgICAgICAgICAgICAgICBsYWJlbElkeDogbGFiZWxJZHgsXG4gICAgICAgICAgICAgICAgZHg6IGR4LFxuICAgICAgICAgICAgICAgIGR5OiBkeSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFuZ2xlOiBwb3NpdGlvbkFuZ2xlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQXJnczogcG9zaXRpb25BcmdzLFxuICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG4gICAgICAgICAgICAvLyBJZiBsYWJlbHMgY2FuJ3QgYmUgZHJhZ2dlZCBubyBkZWZhdWx0IGFjdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHsgc3RvcFByb3BhZ2F0aW9uOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXBlci5kZWxlZ2F0ZURyYWdFdmVudHModGhpcywgZXZ0LmRhdGEpO1xuICAgIH0sXG5cbiAgICBkcmFnQXJyb3doZWFkU3RhcnQ6IGZ1bmN0aW9uKGV2dCwgeCwgeSkge1xuXG4gICAgICAgIGlmICghdGhpcy5jYW4oJ2Fycm93aGVhZE1vdmUnKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBhcnJvd2hlYWROb2RlID0gZXZ0LnRhcmdldDtcbiAgICAgICAgdmFyIGFycm93aGVhZFR5cGUgPSBhcnJvd2hlYWROb2RlLmdldEF0dHJpYnV0ZSgnZW5kJyk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5zdGFydEFycm93aGVhZE1vdmUoYXJyb3doZWFkVHlwZSwgeyBpZ25vcmVCYWNrd2FyZHNDb21wYXRpYmlsaXR5OiB0cnVlIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgZGF0YSk7XG4gICAgfSxcblxuICAgIGRyYWdTdGFydDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0SW50ZXJhY3Rpb25QcmV2ZW50ZWQoZXZ0KSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGhpcy5jYW4oJ2xpbmtNb3ZlJykpIHJldHVybjtcblxuICAgICAgICB0aGlzLmV2ZW50RGF0YShldnQsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ21vdmUnLFxuICAgICAgICAgICAgZHg6IHgsXG4gICAgICAgICAgICBkeTogeVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRHJhZyBIYW5kbGVyc1xuICAgIGRyYWdMYWJlbDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgbGFiZWwgPSB7IHBvc2l0aW9uOiB0aGlzLmdldExhYmVsUG9zaXRpb24oKHggKyBkYXRhLmR4KSwgKHkgKyBkYXRhLmR5KSwgZGF0YS5wb3NpdGlvbkFuZ2xlLCBkYXRhLnBvc2l0aW9uQXJncykgfTtcbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5zbmFwTGFiZWxzKSBkZWxldGUgbGFiZWwucG9zaXRpb24ub2Zmc2V0O1xuICAgICAgICAvLyBUaGUgYHRvdWNobW92ZScgZXZlbnRzIGFyZSBub3QgZmlyZWRcbiAgICAgICAgLy8gd2hlbiB0aGUgb3JpZ2luYWwgZXZlbnQgdGFyZ2V0IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgICAgICAvLyBUaGUgbGFiZWxzIGFyZSBjdXJyZW50bHkgcmUtcmVuZGVyZWQgY29tcGxldGVseSB3aGVuIG9ubHlcbiAgICAgICAgLy8gdGhlIHBvc2l0aW9uIGNoYW5nZXMuIFRoaXMgaXMgd2h5IHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgLy8gdGhlIGxhYmVsIGlzIHVwZGF0ZWQgc3luY2hyb25vdXNseS5cbiAgICAgICAgLy8gVE9ETzogcmVwbGFjZSBgdG91Y2htb3ZlYCB3aXRoIGBwb2ludGVybW92ZWAgKGJyZWFraW5nIGNoYW5nZSkuXG4gICAgICAgIGNvbnN0IHNldE9wdGlvbnMgPSB7IHVpOiB0cnVlIH07XG4gICAgICAgIGlmICh0aGlzLnBhcGVyLmlzQXN5bmMoKSAmJiBldnQudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICAgIHNldE9wdGlvbnMuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsLmxhYmVsKGRhdGEubGFiZWxJZHgsIGxhYmVsLCBzZXRPcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZHJhZ0Fycm93aGVhZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLnBhcGVyLm9wdGlvbnMuc25hcExpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBpc1NuYXBwZWQgPSB0aGlzLl9zbmFwQXJyb3doZWFkKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoIWlzU25hcHBlZCAmJiB0aGlzLnBhcGVyLm9wdGlvbnMuc25hcExpbmtzU2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NuYXBBcnJvd2hlYWRTZWxmKGV2dCwgeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXBlci5vcHRpb25zLnNuYXBMaW5rc1NlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zbmFwQXJyb3doZWFkU2VsZihldnQsIHgsIHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0QXJyb3doZWFkKHRoaXMuZ2V0RXZlbnRUYXJnZXQoZXZ0KSwgeCwgeSwgdGhpcy5ldmVudERhdGEoZXZ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhZzogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB0aGlzLm1vZGVsLnRyYW5zbGF0ZSh4IC0gZGF0YS5keCwgeSAtIGRhdGEuZHksIHsgdWk6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwge1xuICAgICAgICAgICAgZHg6IHgsXG4gICAgICAgICAgICBkeTogeVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRHJhZyBFbmQgSGFuZGxlcnNcblxuICAgIGRyYWdMYWJlbEVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgZHJhZ0Fycm93aGVhZEVuZDogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgcGFwZXIgPSB0aGlzLnBhcGVyO1xuXG4gICAgICAgIGlmIChwYXBlci5vcHRpb25zLnNuYXBMaW5rcykge1xuICAgICAgICAgICAgdGhpcy5fc25hcEFycm93aGVhZEVuZChkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RBcnJvd2hlYWRFbmQoZGF0YSwgeCwgeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcGVyLmxpbmtBbGxvd2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhbmdlZCBsaW5rIGlzIG5vdCBhbGxvd2VkLCByZXZlcnQgdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgdGhpcy5fZGlzYWxsb3coZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hFbWJlZGRpbmcoZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlDb25uZWN0RXZlbnQoZGF0YSwgZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FmdGVyQXJyb3doZWFkTW92ZShkYXRhKTtcbiAgICB9LFxuXG4gICAgZHJhZ0VuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9LFxuXG4gICAgX2Rpc2FsbG93OiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLndoZW5Ob3RBbGxvd2VkKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5yZW1vdmUoeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmV2ZXJ0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5zZXQoZGF0YS5hcnJvd2hlYWQsIGRhdGEuaW5pdGlhbEVuZCwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmluaXNoRW1iZWRkaW5nOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgLy8gUmVwYXJlbnQgdGhlIGxpbmsgaWYgZW1iZWRkaW5nIGlzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMucGFwZXIub3B0aW9ucy5lbWJlZGRpbmdNb2RlICYmIHRoaXMubW9kZWwucmVwYXJlbnQoKSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJldmVyc2UgdG8gdGhlIG9yaWdpbmFsICd6JyBpbmRleCAoc2VlIGFmdGVyQXJyb3doZWFkTW92ZSgpKS5cbiAgICAgICAgICAgIGRhdGEueiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX25vdGlmeUNvbm5lY3RFdmVudDogZnVuY3Rpb24oZGF0YSwgZXZ0KSB7XG5cbiAgICAgICAgdmFyIGFycm93aGVhZCA9IGRhdGEuYXJyb3doZWFkO1xuICAgICAgICB2YXIgaW5pdGlhbEVuZCA9IGRhdGEuaW5pdGlhbEVuZDtcbiAgICAgICAgdmFyIGN1cnJlbnRFbmQgPSB0aGlzLm1vZGVsLnByb3AoYXJyb3doZWFkKTtcbiAgICAgICAgdmFyIGVuZENoYW5nZWQgPSBjdXJyZW50RW5kICYmICFMaW5rLmVuZHNFcXVhbChpbml0aWFsRW5kLCBjdXJyZW50RW5kKTtcbiAgICAgICAgaWYgKGVuZENoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEVuZC5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KCdsaW5rOmRpc2Nvbm5lY3QnLCBldnQsIHBhcGVyLmZpbmRWaWV3QnlNb2RlbChpbml0aWFsRW5kLmlkKSwgZGF0YS5pbml0aWFsTWFnbmV0LCBhcnJvd2hlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRFbmQuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpjb25uZWN0JywgZXZ0LCBwYXBlci5maW5kVmlld0J5TW9kZWwoY3VycmVudEVuZC5pZCksIGRhdGEubWFnbmV0VW5kZXJQb2ludGVyLCBhcnJvd2hlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zbmFwVG9Qb2ludHM6IGZ1bmN0aW9uKHNuYXBQb2ludCwgcG9pbnRzLCByYWRpdXMpIHtcbiAgICAgICAgbGV0IGNsb3Nlc3RQb2ludFggPSBudWxsO1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlWCA9IEluZmluaXR5O1xuXG4gICAgICAgIGxldCBjbG9zZXN0UG9pbnRZID0gbnVsbDtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZVkgPSBJbmZpbml0eTtcblxuICAgICAgICBsZXQgeCA9IHNuYXBQb2ludC54O1xuICAgICAgICBsZXQgeSA9IHNuYXBQb2ludC55O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaXN0WCA9IE1hdGguYWJzKHBvaW50c1tpXS54IC0gc25hcFBvaW50LngpO1xuICAgICAgICAgICAgaWYgKGRpc3RYIDwgY2xvc2VzdERpc3RhbmNlWCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZVggPSBkaXN0WDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UG9pbnRYID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkaXN0WSA9IE1hdGguYWJzKHBvaW50c1tpXS55IC0gc25hcFBvaW50LnkpO1xuICAgICAgICAgICAgaWYgKGRpc3RZIDwgY2xvc2VzdERpc3RhbmNlWSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZVkgPSBkaXN0WTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UG9pbnRZID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb3Nlc3REaXN0YW5jZVggPCByYWRpdXMpIHtcbiAgICAgICAgICAgIHggPSBjbG9zZXN0UG9pbnRYLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb3Nlc3REaXN0YW5jZVkgPCByYWRpdXMpIHtcbiAgICAgICAgICAgIHkgPSBjbG9zZXN0UG9pbnRZLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSxcblxuICAgIF9zbmFwQXJyb3doZWFkU2VsZjogZnVuY3Rpb24oZXZ0LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBwYXBlciwgbW9kZWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc25hcExpbmtzU2VsZiB9ID0gcGFwZXIub3B0aW9ucztcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZXZlbnREYXRhKGV2dCk7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IHNuYXBMaW5rc1NlbGYucmFkaXVzIHx8IDIwO1xuXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuZ2V0RW5kQW5jaG9yKGRhdGEuYXJyb3doZWFkID09PSAnc291cmNlJyA/ICd0YXJnZXQnIDogJ3NvdXJjZScpO1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IG1vZGVsLnZlcnRpY2VzKCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFthbmNob3IsIC4uLnZlcnRpY2VzXTtcblxuICAgICAgICBjb25zdCBzbmFwUG9pbnQgPSB0aGlzLl9zbmFwVG9Qb2ludHMoeyB4OiB4LCB5OiB5IH0sIHBvaW50cywgcmFkaXVzKTtcblxuICAgICAgICBjb25zdCBwb2ludCA9IHBhcGVyLmxvY2FsVG9DbGllbnRQb2ludChzbmFwUG9pbnQpO1xuICAgICAgICB0aGlzLl9jb25uZWN0QXJyb3doZWFkKGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQocG9pbnQueCwgcG9pbnQueSksIHNuYXBQb2ludC54LCBzbmFwUG9pbnQueSwgdGhpcy5ldmVudERhdGEoZXZ0KSk7XG4gICAgfSxcblxuICAgIF9zbmFwQXJyb3doZWFkOiBmdW5jdGlvbihldnQsIHgsIHkpIHtcblxuICAgICAgICBjb25zdCB7IHBhcGVyIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHNuYXBMaW5rcywgY29ubmVjdGlvblN0cmF0ZWd5IH0gPSBwYXBlci5vcHRpb25zO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgbGV0IGlzU25hcHBlZCA9IGZhbHNlO1xuICAgICAgICAvLyBjaGVja2luZyB2aWV3IGluIGNsb3NlIGFyZWEgb2YgdGhlIHBvaW50ZXJcblxuICAgICAgICB2YXIgciA9IHNuYXBMaW5rcy5yYWRpdXMgfHwgNTA7XG4gICAgICAgIHZhciB2aWV3c0luQXJlYSA9IHBhcGVyLmZpbmRFbGVtZW50Vmlld3NJbkFyZWEoXG4gICAgICAgICAgICB7IHg6IHggLSByLCB5OiB5IC0gciwgd2lkdGg6IDIgKiByLCBoZWlnaHQ6IDIgKiByIH0sXG4gICAgICAgICAgICBzbmFwTGlua3MuZmluZEluQXJlYU9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgcHJldkNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0VmlldyB8fCBudWxsO1xuICAgICAgICB2YXIgcHJldkNsb3Nlc3RNYWduZXQgPSBkYXRhLmNsb3Nlc3RNYWduZXQgfHwgbnVsbDtcbiAgICAgICAgdmFyIHByZXZNYWduZXRQcm94eSA9IGRhdGEubWFnbmV0UHJveHkgfHwgbnVsbDtcblxuICAgICAgICBkYXRhLmNsb3Nlc3RWaWV3ID0gZGF0YS5jbG9zZXN0TWFnbmV0ID0gZGF0YS5tYWduZXRQcm94eSA9IG51bGw7XG5cbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgUG9pbnQoeCwgeSk7XG5cbiAgICAgICAgdmlld3NJbkFyZWEuZm9yRWFjaChmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gICAgICAgICAgICAvLyBza2lwIGNvbm5lY3RpbmcgdG8gdGhlIGVsZW1lbnQgaW4gY2FzZSAnLic6IHsgbWFnbmV0OiBmYWxzZSB9IGF0dHJpYnV0ZSBwcmVzZW50XG4gICAgICAgICAgICBpZiAodmlldy5lbC5nZXRBdHRyaWJ1dGUoJ21hZ25ldCcpICE9PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYmJveDogdmlldy5tb2RlbC5nZXRCQm94KCksXG4gICAgICAgICAgICAgICAgICAgIG1hZ25ldDogdmlldy5lbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3LiQoJ1ttYWduZXRdJykudG9BcnJheSgpLmZvckVhY2gobWFnbmV0ID0+IHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBiYm94OiB2aWV3LmdldE5vZGVCQm94KG1hZ25ldCksXG4gICAgICAgICAgICAgICAgICAgIG1hZ25ldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhbmRpZGF0ZXMuZm9yRWFjaChjYW5kaWRhdGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWFnbmV0LCBiYm94IH0gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIG1vZGVsIHRvIHBvaW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGJib3guY2VudGVyKCkuc3F1YXJlZERpc3RhbmNlKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIGlzIGxvb2tlZCB1cCBpbiBhIGNpcmNsZSBhcmVhIGJ5IGBkaXN0YW5jZSA8IHJgXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBbHJlYWR5VmFsaWRhdGVkID0gcHJldkNsb3Nlc3RNYWduZXQgPT09IG1hZ25ldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxyZWFkeVZhbGlkYXRlZCB8fCBwYXBlci5vcHRpb25zLnZhbGlkYXRlQ29ubmVjdGlvbi5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcGVyLCBkYXRhLnZhbGlkYXRlQ29ubmVjdGlvbkFyZ3ModmlldywgKHZpZXcuZWwgPT09IG1hZ25ldCkgPyBudWxsIDogbWFnbmV0KVxuICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jbG9zZXN0VmlldyA9IHZpZXc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNsb3Nlc3RNYWduZXQgPSBtYWduZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB2YXIgZW5kO1xuICAgICAgICB2YXIgbWFnbmV0UHJveHkgPSBudWxsO1xuICAgICAgICB2YXIgY2xvc2VzdFZpZXcgPSBkYXRhLmNsb3Nlc3RWaWV3O1xuICAgICAgICB2YXIgY2xvc2VzdE1hZ25ldCA9IGRhdGEuY2xvc2VzdE1hZ25ldDtcbiAgICAgICAgaWYgKGNsb3Nlc3RNYWduZXQpIHtcbiAgICAgICAgICAgIG1hZ25ldFByb3h5ID0gZGF0YS5tYWduZXRQcm94eSA9IGNsb3Nlc3RWaWV3LmZpbmRQcm94eU5vZGUoY2xvc2VzdE1hZ25ldCwgJ2hpZ2hsaWdodGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuZFR5cGUgPSBkYXRhLmFycm93aGVhZDtcbiAgICAgICAgdmFyIG5ld0Nsb3Nlc3RNYWduZXQgPSAocHJldkNsb3Nlc3RNYWduZXQgIT09IGNsb3Nlc3RNYWduZXQpO1xuICAgICAgICBpZiAocHJldkNsb3Nlc3RWaWV3ICYmIG5ld0Nsb3Nlc3RNYWduZXQpIHtcbiAgICAgICAgICAgIHByZXZDbG9zZXN0Vmlldy51bmhpZ2hsaWdodChwcmV2TWFnbmV0UHJveHksIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNuYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZXN0Vmlldykge1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2RW5kLCBwcmV2WCwgcHJldlkgfSA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhLnByZXZYID0geDtcbiAgICAgICAgICAgIGRhdGEucHJldlkgPSB5O1xuICAgICAgICAgICAgaXNTbmFwcGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFuZXdDbG9zZXN0TWFnbmV0KSAge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvblN0cmF0ZWd5ICE9PSAnZnVuY3Rpb24nIHx8IChwcmV2WCA9PT0geCAmJiBwcmV2WSA9PT0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG1hZ25ldCBoYXMgbm90IGNoYW5nZWQgYW5kIHRoZSBsaW5rJ3MgZW5kIGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgeCBhbmQgeVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTbmFwcGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW5kID0gY2xvc2VzdFZpZXcuZ2V0TGlua0VuZChjbG9zZXN0TWFnbmV0LCB4LCB5LCB0aGlzLm1vZGVsLCBlbmRUeXBlKTtcbiAgICAgICAgICAgIGlmICghbmV3Q2xvc2VzdE1hZ25ldCAmJiBpc0VxdWFsKHByZXZFbmQsIGVuZCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgc291cmNlL3RhcmdldCBqc29uIGhhcyBub3QgY2hhbmdlZFxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NuYXBwZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEucHJldkVuZCA9IGVuZDtcblxuICAgICAgICAgICAgaWYgKG5ld0Nsb3Nlc3RNYWduZXQpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Vmlldy5oaWdobGlnaHQobWFnbmV0UHJveHksIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc25hcHBpbmc6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBlbmQgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWwuc2V0KGVuZFR5cGUsIGVuZCB8fCB7IHg6IHgsIHk6IHkgfSwgeyB1aTogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAocHJldkNsb3Nlc3RWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgnbGluazpzbmFwOmRpc2Nvbm5lY3QnLCBldnQsIHByZXZDbG9zZXN0VmlldywgcHJldkNsb3Nlc3RNYWduZXQsIGVuZFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zZXN0Vmlldykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoJ2xpbms6c25hcDpjb25uZWN0JywgZXZ0LCBjbG9zZXN0VmlldywgY2xvc2VzdE1hZ25ldCwgZW5kVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNTbmFwcGVkO1xuICAgIH0sXG5cbiAgICBfc25hcEFycm93aGVhZEVuZDogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIC8vIEZpbmlzaCBvZmYgbGluayBzbmFwcGluZy5cbiAgICAgICAgLy8gRXZlcnl0aGluZyBleGNlcHQgdmlldyB1bmhpZ2hsaWdodGluZyB3YXMgYWxyZWFkeSBkb25lIG9uIHBvaW50ZXJtb3ZlLlxuICAgICAgICB2YXIgY2xvc2VzdFZpZXcgPSBkYXRhLmNsb3Nlc3RWaWV3O1xuICAgICAgICB2YXIgY2xvc2VzdE1hZ25ldCA9IGRhdGEuY2xvc2VzdE1hZ25ldDtcbiAgICAgICAgaWYgKGNsb3Nlc3RWaWV3ICYmIGNsb3Nlc3RNYWduZXQpIHtcblxuICAgICAgICAgICAgY2xvc2VzdFZpZXcudW5oaWdobGlnaHQoZGF0YS5tYWduZXRQcm94eSwgeyBjb25uZWN0aW5nOiB0cnVlLCBzbmFwcGluZzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRhdGEubWFnbmV0VW5kZXJQb2ludGVyID0gY2xvc2VzdFZpZXcuZmluZE1hZ25ldChjbG9zZXN0TWFnbmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuY2xvc2VzdFZpZXcgPSBkYXRhLmNsb3Nlc3RNYWduZXQgPSBudWxsO1xuICAgIH0sXG5cbiAgICBfY29ubmVjdEFycm93aGVhZDogZnVuY3Rpb24odGFyZ2V0LCB4LCB5LCBkYXRhKSB7XG5cbiAgICAgICAgLy8gY2hlY2tpbmcgdmlld3MgcmlnaHQgdW5kZXIgdGhlIHBvaW50ZXJcbiAgICAgICAgY29uc3QgeyBwYXBlciwgbW9kZWwgfSA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEuZXZlbnRUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgLy8gVW5oaWdobGlnaHQgdGhlIHByZXZpb3VzIHZpZXcgdW5kZXIgcG9pbnRlciBpZiB0aGVyZSB3YXMgb25lLlxuICAgICAgICAgICAgaWYgKGRhdGEubWFnbmV0UHJveHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZpZXdVbmRlclBvaW50ZXIudW5oaWdobGlnaHQoZGF0YS5tYWduZXRQcm94eSwge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZpZXdVbmRlclBvaW50ZXIgPSBkYXRhLnZpZXdVbmRlclBvaW50ZXIgPSBwYXBlci5maW5kVmlldyh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHZpZXdVbmRlclBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIHZpZXcgdGhhdCBpcyB1bmRlciB0aGUgcG9pbnRlciwgd2UgbmVlZCB0byBmaW5kIHRoZSBjbG9zZXN0XG4gICAgICAgICAgICAgICAgLy8gbWFnbmV0IGJhc2VkIG9uIHRoZSByZWFsIHRhcmdldCBlbGVtZW50IG9mIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICBjb25zdCBtYWduZXRVbmRlclBvaW50ZXIgPSBkYXRhLm1hZ25ldFVuZGVyUG9pbnRlciA9IHZpZXdVbmRlclBvaW50ZXIuZmluZE1hZ25ldCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hZ25ldFByb3h5ID0gZGF0YS5tYWduZXRQcm94eSA9IHZpZXdVbmRlclBvaW50ZXIuZmluZFByb3h5Tm9kZShtYWduZXRVbmRlclBvaW50ZXIsICdoaWdobGlnaHRlcicpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hZ25ldFVuZGVyUG9pbnRlciAmJiB0aGlzLnBhcGVyLm9wdGlvbnMudmFsaWRhdGVDb25uZWN0aW9uLmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICBwYXBlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YS52YWxpZGF0ZUNvbm5lY3Rpb25BcmdzKHZpZXdVbmRlclBvaW50ZXIsIG1hZ25ldFVuZGVyUG9pbnRlcilcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBtYWduZXQgZm91bmQsIGRvIG5vdCBoaWdobGlnaHQgYW55dGhpbmcgYW5kIGFzc3VtZSB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBubyB2aWV3IHVuZGVyIHBvaW50ZXIgd2UncmUgaW50ZXJlc3RlZCBpbiByZWNvbm5lY3RpbmcgdG8uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBvdmVyYWxsIGVsZW1lbnQgaGFzIHRoZSBhdHRyaWJ1dGUgYCcuJzogeyBtYWduZXQ6IGZhbHNlIH1gLlxuICAgICAgICAgICAgICAgICAgICBpZiAobWFnbmV0UHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdVbmRlclBvaW50ZXIuaGlnaGxpZ2h0KG1hZ25ldFByb3h5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGluZzogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHR5cGUgb2YgY29ubmVjdGlvbiBpcyBub3QgdmFsaWQuIERpc3JlZ2FyZCB0aGlzIG1hZ25ldC5cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYWduZXRVbmRlclBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm1hZ25ldFByb3h5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdsbCB1bnNldCBwcmV2aW91cyBtYWduZXQuXG4gICAgICAgICAgICAgICAgZGF0YS5tYWduZXRVbmRlclBvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRhdGEubWFnbmV0UHJveHkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5ldmVudFRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICBtb2RlbC5zZXQoZGF0YS5hcnJvd2hlYWQsIHsgeDogeCwgeTogeSB9LCB7IHVpOiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICBfY29ubmVjdEFycm93aGVhZEVuZDogZnVuY3Rpb24oZGF0YSA9IHt9LCB4LCB5KSB7XG5cbiAgICAgICAgY29uc3QgeyBtb2RlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3VW5kZXJQb2ludGVyLCBtYWduZXRVbmRlclBvaW50ZXIsIG1hZ25ldFByb3h5LCBhcnJvd2hlYWQgfSA9IGRhdGE7XG5cbiAgICAgICAgaWYgKCFtYWduZXRVbmRlclBvaW50ZXIgfHwgIW1hZ25ldFByb3h5IHx8ICF2aWV3VW5kZXJQb2ludGVyKSByZXR1cm47XG5cbiAgICAgICAgdmlld1VuZGVyUG9pbnRlci51bmhpZ2hsaWdodChtYWduZXRQcm94eSwgeyBjb25uZWN0aW5nOiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIFRoZSBsaW5rIGVuZCBpcyB0YWtlbiBmcm9tIHRoZSBtYWduZXQgdW5kZXIgdGhlIHBvaW50ZXIsIG5vdCB0aGUgcHJveHkuXG4gICAgICAgIGNvbnN0IGVuZCA9IHZpZXdVbmRlclBvaW50ZXIuZ2V0TGlua0VuZChtYWduZXRVbmRlclBvaW50ZXIsIHgsIHksIG1vZGVsLCBhcnJvd2hlYWQpO1xuICAgICAgICBtb2RlbC5zZXQoYXJyb3doZWFkLCBlbmQsIHsgdWk6IHRydWUgfSk7XG4gICAgfSxcblxuICAgIF9iZWZvcmVBcnJvd2hlYWRNb3ZlOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgZGF0YS56ID0gdGhpcy5tb2RlbC5nZXQoJ3onKTtcbiAgICAgICAgdGhpcy5tb2RlbC50b0Zyb250KCk7XG5cbiAgICAgICAgLy8gTGV0IHRoZSBwb2ludGVyIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSBsaW5rIHZpZXcgZWxlbWVudHMgc28gdGhhdFxuICAgICAgICAvLyB0aGUgYGV2dC50YXJnZXRgIGlzIGFub3RoZXIgZWxlbWVudCB1bmRlciB0aGUgcG9pbnRlciwgbm90IHRoZSBsaW5rIGl0c2VsZi5cbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5lbC5zdHlsZTtcbiAgICAgICAgZGF0YS5wb2ludGVyRXZlbnRzID0gc3R5bGUucG9pbnRlckV2ZW50cztcbiAgICAgICAgc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcblxuICAgICAgICBpZiAodGhpcy5wYXBlci5vcHRpb25zLm1hcmtBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtBdmFpbGFibGVNYWduZXRzKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9hZnRlckFycm93aGVhZE1vdmU6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICBpZiAoZGF0YS56ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNldCgneicsIGRhdGEueiwgeyB1aTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRhdGEueiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdXQgYHBvaW50ZXItZXZlbnRzYCBiYWNrIHRvIGl0cyBvcmlnaW5hbCB2YWx1ZS4gU2VlIGBfYmVmb3JlQXJyb3doZWFkTW92ZSgpYCBmb3IgZXhwbGFuYXRpb24uXG4gICAgICAgIHRoaXMuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRhdGEucG9pbnRlckV2ZW50cztcblxuICAgICAgICBpZiAodGhpcy5wYXBlci5vcHRpb25zLm1hcmtBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFya0F2YWlsYWJsZU1hZ25ldHMoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NyZWF0ZVZhbGlkYXRlQ29ubmVjdGlvbkFyZ3M6IGZ1bmN0aW9uKGFycm93aGVhZCkge1xuICAgICAgICAvLyBJdCBtYWtlcyBzdXJlIHRoZSBhcmd1bWVudHMgZm9yIHZhbGlkYXRlQ29ubmVjdGlvbiBoYXZlIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAgLy8gKHNvdXJjZSB2aWV3LCBzb3VyY2UgbWFnbmV0LCB0YXJnZXQgdmlldywgdGFyZ2V0IG1hZ25ldCBhbmQgbGluayB2aWV3KVxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgIGFyZ3NbNF0gPSBhcnJvd2hlYWQ7XG4gICAgICAgIGFyZ3NbNV0gPSB0aGlzO1xuXG4gICAgICAgIHZhciBvcHBvc2l0ZUFycm93aGVhZDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaiA9IDA7XG5cbiAgICAgICAgaWYgKGFycm93aGVhZCA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgICAgIGkgPSAyO1xuICAgICAgICAgICAgb3Bwb3NpdGVBcnJvd2hlYWQgPSAndGFyZ2V0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGogPSAyO1xuICAgICAgICAgICAgb3Bwb3NpdGVBcnJvd2hlYWQgPSAnc291cmNlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLm1vZGVsLmdldChvcHBvc2l0ZUFycm93aGVhZCk7XG5cbiAgICAgICAgaWYgKGVuZC5pZCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSBhcmdzW2ldID0gdGhpcy5wYXBlci5maW5kVmlld0J5TW9kZWwoZW5kLmlkKTtcbiAgICAgICAgICAgIHZhciBtYWduZXQgPSB2aWV3LmdldE1hZ25ldEZyb21MaW5rRW5kKGVuZCk7XG4gICAgICAgICAgICBpZiAobWFnbmV0ID09PSB2aWV3LmVsKSBtYWduZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhcmdzW2kgKyAxXSA9IG1hZ25ldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ29ubmVjdGlvbkFyZ3MoY2VsbFZpZXcsIG1hZ25ldCkge1xuICAgICAgICAgICAgYXJnc1tqXSA9IGNlbGxWaWV3O1xuICAgICAgICAgICAgYXJnc1tqICsgMV0gPSBjZWxsVmlldy5lbCA9PT0gbWFnbmV0ID8gdW5kZWZpbmVkIDogbWFnbmV0O1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWRhdGVDb25uZWN0aW9uQXJncztcbiAgICB9LFxuXG4gICAgX21hcmtBdmFpbGFibGVNYWduZXRzOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNNYWduZXRBdmFpbGFibGUodmlldywgbWFnbmV0KSB7XG4gICAgICAgICAgICB2YXIgcGFwZXIgPSB2aWV3LnBhcGVyO1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRlID0gcGFwZXIub3B0aW9ucy52YWxpZGF0ZUNvbm5lY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGUuYXBwbHkocGFwZXIsIHRoaXMudmFsaWRhdGVDb25uZWN0aW9uQXJncyh2aWV3LCBtYWduZXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXBlciA9IHRoaXMucGFwZXI7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHBhcGVyLm1vZGVsLmdldENlbGxzKCk7XG4gICAgICAgIGRhdGEubWFya2VkID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gZWxlbWVudHNbaV0uZmluZFZpZXcocGFwZXIpO1xuXG4gICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1hZ25ldHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh2aWV3LmVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ1ttYWduZXRdJykpO1xuICAgICAgICAgICAgaWYgKHZpZXcuZWwuZ2V0QXR0cmlidXRlKCdtYWduZXQnKSAhPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIC8vIEVsZW1lbnQgd3JhcHBpbmcgZ3JvdXAgaXMgYWxzbyBhIG1hZ25ldFxuICAgICAgICAgICAgICAgIG1hZ25ldHMucHVzaCh2aWV3LmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZU1hZ25ldHMgPSBtYWduZXRzLmZpbHRlcihpc01hZ25ldEF2YWlsYWJsZS5iaW5kKGRhdGEsIHZpZXcpKTtcblxuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZU1hZ25ldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGhpZ2hsaWdodCBhbGwgYXZhaWxhYmxlIG1hZ25ldHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbSA9IGF2YWlsYWJsZU1hZ25ldHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaGlnaGxpZ2h0KGF2YWlsYWJsZU1hZ25ldHNbal0sIHsgbWFnbmV0QXZhaWxhYmlsaXR5OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIGVudGlyZSB2aWV3XG4gICAgICAgICAgICAgICAgdmlldy5oaWdobGlnaHQobnVsbCwgeyBlbGVtZW50QXZhaWxhYmlsaXR5OiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJrZWRbdmlldy5tb2RlbC5pZF0gPSBhdmFpbGFibGVNYWduZXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91bm1hcmtBdmFpbGFibGVNYWduZXRzOiBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgdmFyIG1hcmtlZEtleXMgPSBPYmplY3Qua2V5cyhkYXRhLm1hcmtlZCk7XG4gICAgICAgIHZhciBpZDtcbiAgICAgICAgdmFyIG1hcmtlZE1hZ25ldHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBtYXJrZWRLZXlzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWQgPSBtYXJrZWRLZXlzW2ldO1xuICAgICAgICAgICAgbWFya2VkTWFnbmV0cyA9IGRhdGEubWFya2VkW2lkXTtcblxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnBhcGVyLmZpbmRWaWV3QnlNb2RlbChpZCk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gbWFya2VkTWFnbmV0cy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodChtYXJrZWRNYWduZXRzW2pdLCB7IG1hZ25ldEF2YWlsYWJpbGl0eTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlldy51bmhpZ2hsaWdodChudWxsLCB7IGVsZW1lbnRBdmFpbGFiaWxpdHk6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLm1hcmtlZCA9IG51bGw7XG4gICAgfSxcblxuICAgIHN0YXJ0QXJyb3doZWFkTW92ZTogZnVuY3Rpb24oZW5kLCBvcHQpIHtcblxuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcblxuICAgICAgICAvLyBBbGxvdyB0byBkZWxlZ2F0ZSBldmVudHMgZnJvbSBhbiBhbm90aGVyIHZpZXcgdG8gdGhpcyBsaW5rVmlldyBpbiBvcmRlciB0byB0cmlnZ2VyIGFycm93aGVhZFxuICAgICAgICAvLyBtb3ZlIHdpdGhvdXQgbmVlZCB0byBjbGljayBvbiB0aGUgYWN0dWFsIGFycm93aGVhZCBkb20gZWxlbWVudC5cbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY3Rpb246ICdhcnJvd2hlYWQtbW92ZScsXG4gICAgICAgICAgICBhcnJvd2hlYWQ6IGVuZCxcbiAgICAgICAgICAgIHdoZW5Ob3RBbGxvd2VkOiBvcHQud2hlbk5vdEFsbG93ZWQgfHwgJ3JldmVydCcsXG4gICAgICAgICAgICBpbml0aWFsTWFnbmV0OiB0aGlzW2VuZCArICdNYWduZXQnXSB8fCAodGhpc1tlbmQgKyAnVmlldyddID8gdGhpc1tlbmQgKyAnVmlldyddLmVsIDogbnVsbCksXG4gICAgICAgICAgICBpbml0aWFsRW5kOiBjbG9uZSh0aGlzLm1vZGVsLmdldChlbmQpKSxcbiAgICAgICAgICAgIHZhbGlkYXRlQ29ubmVjdGlvbkFyZ3M6IHRoaXMuX2NyZWF0ZVZhbGlkYXRlQ29ubmVjdGlvbkFyZ3MoZW5kKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2JlZm9yZUFycm93aGVhZE1vdmUoZGF0YSk7XG5cbiAgICAgICAgaWYgKG9wdC5pZ25vcmVCYWNrd2FyZHNDb21wYXRpYmlsaXR5ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmFnRGF0YSA9IGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLy8gTGlmZWN5Y2xlIG1ldGhvZHNcblxuICAgIG9uTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBDZWxsVmlldy5wcm90b3R5cGUub25Nb3VudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1vdW50TGFiZWxzKCk7XG4gICAgfSxcblxuICAgIG9uRGV0YWNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgQ2VsbFZpZXcucHJvdG90eXBlLm9uRGV0YWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudW5tb3VudExhYmVscygpO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIENlbGxWaWV3LnByb3RvdHlwZS5vblJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVubW91bnRMYWJlbHMoKTtcbiAgICB9XG5cbn0sIHtcblxuICAgIEZsYWdzOiBGbGFncyxcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGlua1ZpZXcucHJvdG90eXBlLCAnc291cmNlQkJveCcsIHtcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc291cmNlVmlldyA9IHRoaXMuc291cmNlVmlldztcbiAgICAgICAgaWYgKCFzb3VyY2VWaWV3KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlRGVmID0gdGhpcy5tb2RlbC5zb3VyY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdChzb3VyY2VEZWYueCwgc291cmNlRGVmLnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2VNYWduZXQgPSB0aGlzLnNvdXJjZU1hZ25ldDtcbiAgICAgICAgaWYgKHNvdXJjZVZpZXcuaXNOb2RlQ29ubmVjdGlvbihzb3VyY2VNYWduZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy5zb3VyY2VBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VWaWV3LmdldE5vZGVCQm94KHNvdXJjZU1hZ25ldCB8fCBzb3VyY2VWaWV3LmVsKTtcbiAgICB9XG5cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTGlua1ZpZXcucHJvdG90eXBlLCAndGFyZ2V0QkJveCcsIHtcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFyZ2V0VmlldyA9IHRoaXMudGFyZ2V0VmlldztcbiAgICAgICAgaWYgKCF0YXJnZXRWaWV3KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RGVmID0gdGhpcy5tb2RlbC50YXJnZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVjdCh0YXJnZXREZWYueCwgdGFyZ2V0RGVmLnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnZXRNYWduZXQgPSB0aGlzLnRhcmdldE1hZ25ldDtcbiAgICAgICAgaWYgKHRhcmdldFZpZXcuaXNOb2RlQ29ubmVjdGlvbih0YXJnZXRNYWduZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcy50YXJnZXRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRWaWV3LmdldE5vZGVCQm94KHRhcmdldE1hZ25ldCB8fCB0YXJnZXRWaWV3LmVsKTtcbiAgICB9XG59KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/LinkView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/Paper.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/Paper.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paper: function() { return /* binding */ Paper; }\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_ViewBase_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../mvc/ViewBase.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CellView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ElementView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ElementView.mjs\");\n/* harmony import */ var _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LinkView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/LinkView.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Cell.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _Graph_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Graph.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Graph.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../highlighters/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/index.mjs\");\n/* harmony import */ var _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../linkAnchors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkAnchors/index.mjs\");\n/* harmony import */ var _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../connectionPoints/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/connectionPoints/index.mjs\");\n/* harmony import */ var _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../anchors/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/anchors/index.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _layers_GridLayer_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./layers/GridLayer.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/layers/GridLayer.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst sortingTypes = {\n    NONE: 'sorting-none',\n    APPROX: 'sorting-approximate',\n    EXACT: 'sorting-exact'\n};\n\nconst WHEEL_CAP = 50;\nconst WHEEL_WAIT_MS = 20;\nconst MOUNT_BATCH_SIZE = 1000;\nconst UPDATE_BATCH_SIZE = Infinity;\nconst MIN_PRIORITY = 9007199254740991; // Number.MAX_SAFE_INTEGER\n\nconst HighlightingTypes = _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView.Highlighting;\n\nconst defaultHighlighting = {\n    [HighlightingTypes.DEFAULT]: {\n        name: 'stroke',\n        options: {\n            padding: 3\n        }\n    },\n    [HighlightingTypes.MAGNET_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-magnet'\n        }\n    },\n    [HighlightingTypes.ELEMENT_AVAILABILITY]: {\n        name: 'addClass',\n        options: {\n            className: 'available-cell'\n        }\n    }\n};\n\nconst defaultLayers = [{\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.BACK,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.CELLS,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.LABELS,\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.FRONT\n}, {\n    name: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.TOOLS\n}];\n\nconst Paper = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.View.extend({\n\n    className: 'paper',\n\n    options: {\n\n        width: 800,\n        height: 600,\n        gridSize: 1,\n        // Whether or not to draw the grid lines on the paper's DOM element.\n        // e.g drawGrid: true, drawGrid: { color: 'red', thickness: 2 }\n        drawGrid: false,\n        // If not set, the size of the visual grid is the same as the `gridSize`.\n        drawGridSize: null,\n\n        // Whether or not to draw the background on the paper's DOM element.\n        // e.g. background: { color: 'lightblue', image: '/paper-background.png', repeat: 'flip-xy' }\n        background: false,\n\n        elementView: _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__.ElementView,\n        linkView: _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__.LinkView,\n        snapLabels: false, // false, true\n        snapLinks: false, // false, true, { radius: value }\n        snapLinksSelf: false, // false, true, { radius: value }\n\n        // Should the link labels be rendered into its own layer?\n        // `false` - the labels are part of the links\n        // `true` - the labels are appended to LayersName.LABELS\n        // [LayersName] - the labels are appended to the layer specified\n        labelsLayer: false,\n\n        // When set to FALSE, an element may not have more than 1 link with the same source and target element.\n        multiLinks: true,\n\n        // For adding custom guard logic.\n        guard: function(evt, view) {\n\n            // FALSE means the event isn't guarded.\n            return false;\n        },\n\n        highlighting: defaultHighlighting,\n\n        // Prevent the default context menu from being displayed.\n        preventContextMenu: true,\n\n        // Prevent the default action for blank:pointer<action>.\n        preventDefaultBlankAction: true,\n\n        // Prevent the default action for cell:pointer<action>.\n        preventDefaultViewAction: true,\n\n        // Restrict the translation of elements by given bounding box.\n        // Option accepts a boolean:\n        //  true - the translation is restricted to the paper area\n        //  false - no restrictions\n        // A method:\n        // restrictTranslate: function(elementView) {\n        //     var parentId = elementView.model.get('parent');\n        //     return parentId && this.model.getCell(parentId).getBBox();\n        // },\n        // Or a bounding box:\n        // restrictTranslate: { x: 10, y: 10, width: 790, height: 590 }\n        restrictTranslate: false,\n\n        // Marks all available magnets with 'available-magnet' class name and all available cells with\n        // 'available-cell' class name. Marks them when dragging a link is started and unmark\n        // when the dragging is stopped.\n        markAvailable: false,\n\n        // Defines what link model is added to the graph after an user clicks on an active magnet.\n        // Value could be the mvc.model or a function returning the mvc.model\n        // defaultLink: (elementView, magnet) => {\n        //   return condition ? new customLink1() : new customLink2()\n        // }\n        defaultLink: function() {\n            // Do not create hard dependency on the joint.shapes.standard namespace (by importing the standard.Link model directly)\n            const { cellNamespace } = this.model.get('cells');\n            const ctor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.getByPath)(cellNamespace, ['standard', 'Link']);\n            if (!ctor) throw new Error('dia.Paper: no default link model found. Use `options.defaultLink` to specify a default link model.');\n            return new ctor();\n        },\n\n        // A connector that is used by links with no connector defined on the model.\n        // e.g. { name: 'rounded', args: { radius: 5 }} or a function\n        defaultConnector: { name: 'normal' },\n\n        // A router that is used by links with no router defined on the model.\n        // e.g. { name: 'oneSide', args: { padding: 10 }} or a function\n        defaultRouter: { name: 'normal' },\n\n        defaultAnchor: { name: 'center' },\n\n        defaultLinkAnchor: { name: 'connectionRatio' },\n\n        defaultConnectionPoint: { name: 'boundary' },\n\n        /* CONNECTING */\n\n        connectionStrategy: null,\n\n        // Check whether to add a new link to the graph when user clicks on an a magnet.\n        validateMagnet: function(_cellView, magnet, _evt) {\n            return magnet.getAttribute('magnet') !== 'passive';\n        },\n\n        // Check whether to allow or disallow the link connection while an arrowhead end (source/target)\n        // being changed.\n        validateConnection: function(cellViewS, _magnetS, cellViewT, _magnetT, end, _linkView) {\n            return (end === 'target' ? cellViewT : cellViewS) instanceof _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__.ElementView;\n        },\n\n        /* EMBEDDING */\n\n        // Enables embedding. Re-parent the dragged element with elements under it and makes sure that\n        // all links and elements are visible taken the level of embedding into account.\n        embeddingMode: false,\n\n        // Check whether to allow or disallow the element embedding while an element being translated.\n        validateEmbedding: function(childView, parentView) {\n            // by default all elements can be in relation child-parent\n            return true;\n        },\n\n        // Check whether to allow or disallow an embedded element to be unembedded / to become a root.\n        validateUnembedding: function(childView) {\n            // by default all elements can become roots\n            return true;\n        },\n\n        // Determines the way how a cell finds a suitable parent when it's dragged over the paper.\n        // The cell with the highest z-index (visually on the top) will be chosen.\n        findParentBy: 'bbox', // 'bbox'|'center'|'origin'|'corner'|'topRight'|'bottomLeft'\n\n        // If enabled only the element on the very front is taken into account for the embedding.\n        // If disabled the elements under the dragged view are tested one by one\n        // (from front to back) until a valid parent found.\n        frontParentOnly: true,\n\n        // Interactive flags. See online docs for the complete list of interactive flags.\n        interactive: {\n            labelMove: false\n        },\n\n        // When set to true the links can be pinned to the paper.\n        // i.e. link source/target can be a point e.g. link.get('source') ==> { x: 100, y: 100 };\n        linkPinning: true,\n\n        // Custom validation after an interaction with a link ends.\n        // Recognizes a function. If `false` is returned, the link is disallowed (removed or reverted)\n        // (linkView, paper) => boolean\n        allowLink: null,\n\n        // Allowed number of mousemove events after which the pointerclick event will be still triggered.\n        clickThreshold: 0,\n\n        // Number of required mousemove events before the first pointermove event will be triggered.\n        moveThreshold: 0,\n\n        // Number of required mousemove events before a link is created out of the magnet.\n        // Or string `onleave` so the link is created when the pointer leaves the magnet\n        magnetThreshold: 0,\n\n        // Rendering Options\n\n        sorting: sortingTypes.APPROX,\n\n        frozen: false,\n\n        autoFreeze: false,\n\n        // no docs yet\n        onViewUpdate: function(view, flag, priority, opt, paper) {\n            // Do not update connected links when:\n            // 1. the view was just inserted (added to the graph and rendered)\n            // 2. the view was just mounted (added back to the paper by viewport function)\n            // 3. the change was marked as `isolate`.\n            // 4. the view model was just removed from the graph\n            if ((flag & (view.FLAG_INSERT | view.FLAG_REMOVE)) || opt.mounting || opt.isolate) return;\n            paper.requestConnectedLinksUpdate(view, priority, opt);\n        },\n\n        // no docs yet\n        onViewPostponed: function(view, flag, paper) {\n            return paper.forcePostponedViewUpdate(view, flag);\n        },\n\n        beforeRender: null, // function(opt, paper) { },\n\n        afterRender: null, // function(stats, opt, paper) {\n\n        viewport: null,\n\n        // Default namespaces\n\n        cellViewNamespace: null,\n\n        routerNamespace: null,\n\n        connectorNamespace: null,\n\n        highlighterNamespace: _highlighters_index_mjs__WEBPACK_IMPORTED_MODULE_6__,\n\n        anchorNamespace: _anchors_index_mjs__WEBPACK_IMPORTED_MODULE_7__,\n\n        linkAnchorNamespace: _linkAnchors_index_mjs__WEBPACK_IMPORTED_MODULE_8__,\n\n        connectionPointNamespace: _connectionPoints_index_mjs__WEBPACK_IMPORTED_MODULE_9__,\n\n        overflow: false\n    },\n\n    events: {\n        'dblclick': 'pointerdblclick',\n        'dbltap': 'pointerdblclick',\n        'contextmenu': 'contextmenu',\n        'mousedown': 'pointerdown',\n        'touchstart': 'pointerdown',\n        'mouseover': 'mouseover',\n        'mouseout': 'mouseout',\n        'mouseenter': 'mouseenter',\n        'mouseleave': 'mouseleave',\n        'wheel': 'mousewheel',\n        'mouseenter .joint-cell': 'mouseenter',\n        'mouseleave .joint-cell': 'mouseleave',\n        'mouseenter .joint-tools': 'mouseenter',\n        'mouseleave .joint-tools': 'mouseleave',\n        'dblclick .joint-cell [magnet]': 'magnetpointerdblclick',\n        'contextmenu .joint-cell [magnet]': 'magnetcontextmenu',\n        'mousedown .joint-link .label': 'onlabel', // interaction with link label\n        'touchstart .joint-link .label': 'onlabel',\n        'dragstart .joint-cell image': 'onImageDragStart' // firefox fix\n    },\n\n    documentEvents: {\n        'mousemove': 'pointermove',\n        'touchmove': 'pointermove',\n        'mouseup': 'pointerup',\n        'touchend': 'pointerup',\n        'touchcancel': 'pointerup'\n    },\n\n    /* CSS within the SVG document\n    * 1. Adding vector-effect: non-scaling-stroke; to prevent the stroke width from scaling for\n    *    elements that use the `scalable` group.\n    */\n    stylesheet: /*css*/`\n        .joint-element .scalable * {\n            vector-effect: non-scaling-stroke;\n        }\n    `,\n\n    svg: null,\n    viewport: null,\n    defs: null,\n    tools: null,\n    layers: null,\n\n    // For storing the current transformation matrix (CTM) of the paper's viewport.\n    _viewportMatrix: null,\n    // For verifying whether the CTM is up-to-date. The viewport transform attribute\n    // could have been manipulated directly.\n    _viewportTransformString: null,\n    // Updates data (priorities, unmounted views etc.)\n    _updates: null,\n    // Paper Layers\n    _layers: null,\n\n    SORT_DELAYING_BATCHES: ['add', 'to-front', 'to-back'],\n    UPDATE_DELAYING_BATCHES: ['translate'],\n    // If you interact with these elements,\n    // the default interaction such as `element move` is prevented.\n    FORM_CONTROL_TAG_NAMES: ['TEXTAREA', 'INPUT', 'BUTTON', 'SELECT', 'OPTION'] ,\n    // If you interact with these elements, the events are not propagated to the paper\n    // i.e. paper events such as `element:pointerdown` are not triggered.\n    GUARDED_TAG_NAMES: [\n        // Guard <select> for consistency. When you click on it:\n        // Chrome: triggers `pointerdown`, `pointerup`, `pointerclick` to open\n        // Firefox: triggers `pointerdown` on open, `pointerup` (and `pointerclick` only if you haven't moved).\n        //          on close. However, if you open and then close by clicking elsewhere on the page,\n        //           no other event is triggered.\n        // Safari: when you open it, it triggers `pointerdown`. That's it.\n        'SELECT',\n    ],\n    MIN_SCALE: 1e-6,\n\n    // Default find buffer for the findViewsInArea and findViewsAtPoint methods.\n    // The find buffer is used to extend the area of the search\n    // to mitigate the differences between the model and view geometry.\n    DEFAULT_FIND_BUFFER: 200,\n\n    init: function() {\n\n        const { options } = this;\n        if (!options.cellViewNamespace) {\n            /* eslint-disable no-undef */\n            options.cellViewNamespace = typeof joint !== 'undefined' && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.has)(joint, 'shapes') ? joint.shapes : null;\n            /* eslint-enable no-undef */\n        }\n\n        const model = this.model = options.model || new _Graph_mjs__WEBPACK_IMPORTED_MODULE_11__.Graph;\n\n        // Layers (SVGGroups)\n        this._layers = {};\n\n        this.cloneOptions();\n        this.render();\n        this._setDimensions();\n        this.startListening();\n\n        // Hash of all cell views.\n        this._views = {};\n\n        // Mouse wheel events buffer\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n\n        // Render existing cells in the graph\n        this.resetViews(model.attributes.cells.models);\n        // Start the Rendering Loop\n        if (!this.isFrozen() && this.isAsync()) this.updateViewsAsync();\n    },\n\n    _resetUpdates: function() {\n        if (this._updates && this._updates.id) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cancelFrame)(this._updates.id);\n\n        return this._updates = {\n            id: null,\n            priorities: [{}, {}, {}],\n            unmountedCids: [],\n            mountedCids: [],\n            unmounted: {},\n            mounted: {},\n            count: 0,\n            keyFrozen: false,\n            freezeKey: null,\n            sort: false,\n            disabled: false,\n            idle: false\n        };\n    },\n\n    startListening: function() {\n        var model = this.model;\n        this.listenTo(model, 'add', this.onCellAdded)\n            .listenTo(model, 'remove', this.onCellRemoved)\n            .listenTo(model, 'change', this.onCellChange)\n            .listenTo(model, 'reset', this.onGraphReset)\n            .listenTo(model, 'sort', this.onGraphSort)\n            .listenTo(model, 'batch:stop', this.onGraphBatchStop);\n        this.on('cell:highlight', this.onCellHighlight)\n            .on('cell:unhighlight', this.onCellUnhighlight)\n            .on('transform', this.update);\n    },\n\n    onCellAdded: function(cell, _, opt) {\n        var position = opt.position;\n        if (this.isAsync() || !(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(position)) {\n            this.renderView(cell, opt);\n        } else {\n            if (opt.maxPosition === position) this.freeze({ key: 'addCells' });\n            this.renderView(cell, opt);\n            if (position === 0) this.unfreeze({ key: 'addCells' });\n        }\n    },\n\n    onCellRemoved: function(cell, _, opt) {\n        const view = this.findViewByModel(cell);\n        if (view) this.requestViewUpdate(view, view.FLAG_REMOVE, view.UPDATE_PRIORITY, opt);\n    },\n\n    onCellChange: function(cell, opt) {\n        if (cell === this.model.attributes.cells) return;\n        if (cell.hasChanged('z') && this.options.sorting === sortingTypes.APPROX) {\n            const view = this.findViewByModel(cell);\n            if (view) this.requestViewUpdate(view, view.FLAG_INSERT, view.UPDATE_PRIORITY, opt);\n        }\n    },\n\n    onGraphReset: function(collection, opt) {\n        this.resetLayers();\n        this.resetViews(collection.models, opt);\n    },\n\n    onGraphSort: function() {\n        if (this.model.hasActiveBatch(this.SORT_DELAYING_BATCHES)) return;\n        this.sortViews();\n    },\n\n    onGraphBatchStop: function(data) {\n        if (this.isFrozen()) return;\n        var name = data && data.batchName;\n        var graph = this.model;\n        if (!this.isAsync()) {\n            var updateDelayingBatches = this.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) && !graph.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        var sortDelayingBatches = this.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) && !graph.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    },\n\n    cloneOptions: function() {\n\n        const { options } = this;\n        const {\n            defaultConnector,\n            defaultRouter,\n            defaultConnectionPoint,\n            defaultAnchor,\n            defaultLinkAnchor,\n            highlighting,\n            cellViewNamespace,\n            interactive\n        } = options;\n\n        // Default cellView namespace for ES5\n        /* eslint-disable no-undef */\n        if (!cellViewNamespace && typeof joint !== 'undefined' && (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.has)(joint, 'shapes')) {\n            options.cellViewNamespace = joint.shapes;\n        }\n        /* eslint-enable no-undef */\n\n        // Here if a function was provided, we can not clone it, as this would result in loosing the function.\n        // If the default is used, the cloning is necessary in order to prevent modifying the options on prototype.\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultConnector)) {\n            options.defaultConnector = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultConnector);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultRouter)) {\n            options.defaultRouter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultRouter);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultConnectionPoint)) {\n            options.defaultConnectionPoint = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultConnectionPoint);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultAnchor)) {\n            options.defaultAnchor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultAnchor);\n        }\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(defaultLinkAnchor)) {\n            options.defaultLinkAnchor = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(defaultLinkAnchor);\n        }\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isPlainObject)(interactive)) {\n            options.interactive = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.assign)({}, interactive);\n        }\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isPlainObject)(highlighting)) {\n            // Return the default highlighting options into the user specified options.\n            options.highlighting = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaultsDeep)({}, highlighting, defaultHighlighting);\n        }\n    },\n\n    children: function() {\n        var ns = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].namespace;\n        return [{\n            namespaceURI: ns.xhtml,\n            tagName: 'div',\n            className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('paper-background'),\n            selector: 'background',\n            style: {\n                position: 'absolute',\n                inset: 0\n            }\n        }, {\n            namespaceURI: ns.svg,\n            tagName: 'svg',\n            attributes: {\n                'width': '100%',\n                'height': '100%',\n                'xmlns:xlink': ns.xlink\n            },\n            selector: 'svg',\n            style: {\n                position: 'absolute',\n                inset: 0\n            },\n            children: [{\n                // Append `<defs>` element to the SVG document. This is useful for filters and gradients.\n                // It's desired to have the defs defined before the viewport (e.g. to make a PDF document pick up defs properly).\n                tagName: 'defs',\n                selector: 'defs'\n            }, {\n                tagName: 'g',\n                className: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('layers'),\n                selector: 'layers'\n            }]\n        }];\n    },\n\n    hasLayerView(layerName) {\n        return  (layerName in this._layers);\n    },\n\n    getLayerView(layerName) {\n        const { _layers } = this;\n        if (layerName in _layers) return _layers[layerName];\n        throw new Error(`dia.Paper: Unknown layer \"${layerName}\"`);\n    },\n\n    getLayerNode(layerName) {\n        return this.getLayerView(layerName).el;\n    },\n\n    render: function() {\n\n        this.renderChildren();\n        const { el, childNodes, options, stylesheet } = this;\n        const { svg, defs, layers } = childNodes;\n\n        el.style.position = 'relative';\n        svg.style.overflow = options.overflow ? 'visible' : 'hidden';\n\n        this.svg = svg;\n        this.defs = defs;\n        this.layers = layers;\n\n        this.renderLayers();\n\n        _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].ensureId(svg);\n\n        this.addStylesheet(stylesheet);\n\n        if (options.background) {\n            this.drawBackground(options.background);\n        }\n\n        if (options.drawGrid) {\n            this.setGrid(options.drawGrid);\n        }\n\n        return this;\n    },\n\n    addStylesheet: function(css) {\n        if (!css) return;\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(this.svg).prepend(_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGStyle(css));\n    },\n\n    createLayer(name) {\n        switch (name) {\n            case _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID:\n                return new _layers_GridLayer_mjs__WEBPACK_IMPORTED_MODULE_13__.GridLayer({ name, paper: this, patterns: this.constructor.gridPatterns });\n            default:\n                return new _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.PaperLayer({ name });\n        }\n    },\n\n    renderLayers: function(layers = defaultLayers) {\n        this.removeLayers();\n        // TODO: Layers to be read from the graph `layers` attribute\n        layers.forEach(({ name, sorted }) => {\n            const layerView = this.createLayer(name);\n            this.layers.appendChild(layerView.el);\n            this._layers[name] = layerView;\n        });\n        // Throws an exception if doesn't exist\n        const cellsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.CELLS);\n        const toolsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.TOOLS);\n        const labelsLayerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.LABELS);\n        // backwards compatibility\n        this.tools = toolsLayerView.el;\n        this.cells = this.viewport = cellsLayerView.el;\n        // user-select: none;\n        cellsLayerView.vel.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('viewport'));\n        labelsLayerView.vel.addClass((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.addClassNamePrefix)('viewport'));\n        cellsLayerView.el.style.webkitUserSelect = 'none';\n        cellsLayerView.el.style.userSelect = 'none';\n        labelsLayerView.el.style.webkitUserSelect = 'none';\n        labelsLayerView.el.style.userSelect = 'none';\n    },\n\n    removeLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].remove();\n            delete _layers[name];\n        });\n    },\n\n    resetLayers: function() {\n        const { _layers } = this;\n        Object.keys(_layers).forEach(name => {\n            _layers[name].removePivots();\n        });\n    },\n\n    update: function() {\n\n        if (this._background) {\n            this.updateBackgroundImage(this._background);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, data) {\n        const ctm = this.matrix();\n        // getter\n        if (sx === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToScale(ctm);\n        }\n        // setter\n        if (sy === undefined) {\n            sy = sx;\n        }\n        sx = Math.max(sx || 0, this.MIN_SCALE);\n        sy = Math.max(sy || 0, this.MIN_SCALE);\n        ctm.a = sx;\n        ctm.d = sy;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    scaleUniformAtPoint: function(scale, point, data) {\n        const { a: sx, d: sy, e: tx, f: ty } = this.matrix();\n        scale = Math.max(scale || 0, this.MIN_SCALE);\n        if (scale === sx && scale === sy) {\n            // The scale is the same as the current one.\n            return this;\n        }\n        const matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix()\n            .translate(\n                tx - point.x * (scale - sx),\n                ty - point.y * (scale - sy)\n            )\n            .scale(scale, scale);\n        this.matrix(matrix, data);\n        return this;\n    },\n\n    translate: function(tx, ty, data) {\n        const ctm = this.matrix();\n        // getter\n        if (tx === undefined) {\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToTranslate(ctm);\n        }\n        // setter\n        tx || (tx = 0);\n        ty || (ty = 0);\n        if (ctm.e === tx && ctm.f === ty) return this;\n        ctm.e = tx;\n        ctm.f = ty;\n        this.matrix(ctm, data);\n        return this;\n    },\n\n    matrix: function(ctm, data = {}) {\n\n        var viewport = this.layers;\n\n        // Getter:\n        if (ctm === undefined) {\n\n            var transformString = viewport.getAttribute('transform');\n\n            if ((this._viewportTransformString || null) === transformString) {\n                // It's ok to return the cached matrix. The transform attribute has not changed since\n                // the matrix was stored.\n                ctm = this._viewportMatrix;\n            } else {\n                // The viewport transform attribute has changed. Measure the matrix and cache again.\n                ctm = viewport.getCTM();\n                this._viewportMatrix = ctm;\n                this._viewportTransformString = transformString;\n            }\n\n            // Clone the cached current transformation matrix.\n            // If no matrix previously stored the identity matrix is returned.\n            return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix(ctm);\n        }\n\n        // Setter:\n        const prev = this.matrix();\n        const current = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix(ctm);\n        const currentTransformString = this._viewportTransformString;\n        const ctmString = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToTransformString(current);\n        if (ctmString === currentTransformString) {\n            // The new transform string is the same as the current one.\n            // No need to update the transform attribute.\n            return this;\n        }\n        if (!currentTransformString && _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].matrixToTransformString() === ctmString) {\n            // The current transform string is empty and the new one is an identity matrix.\n            // No need to update the transform attribute.\n            return this;\n        }\n\n        const { a, d, e, f } = current;\n\n        viewport.setAttribute('transform', ctmString);\n        this._viewportMatrix = current;\n        this._viewportTransformString = viewport.getAttribute('transform');\n\n        // scale event\n        if (a !== prev.a || d !== prev.d) {\n            this.trigger('scale', a, d, data);\n        }\n\n        // translate event\n        if (e !== prev.e || f !== prev.f) {\n            this.trigger('translate', e, f, data);\n        }\n\n        this.trigger('transform', current, data);\n        return this;\n    },\n\n    clientMatrix: function() {\n\n        return _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].createSVGMatrix(this.cells.getScreenCTM());\n    },\n\n    requestConnectedLinksUpdate: function(view, priority, opt) {\n        if (view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView) {\n            var model = view.model;\n            var links = this.model.getConnectedLinks(model);\n            for (var j = 0, n = links.length; j < n; j++) {\n                var link = links[j];\n                var linkView = this.findViewByModel(link);\n                if (!linkView) continue;\n                var flagLabels = ['UPDATE'];\n                if (link.getTargetCell() === model) flagLabels.push('TARGET');\n                if (link.getSourceCell() === model) flagLabels.push('SOURCE');\n                var nextPriority = Math.max(priority + 1, linkView.UPDATE_PRIORITY);\n                this.scheduleViewUpdate(linkView, linkView.getFlag(flagLabels), nextPriority, opt);\n            }\n        }\n    },\n\n    forcePostponedViewUpdate: function(view, flag) {\n        if (!view || !(view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView)) return false;\n        var model = view.model;\n        if (model.isElement()) return false;\n        if ((flag & view.getFlag(['SOURCE', 'TARGET'])) === 0) {\n            var dumpOptions = { silent: true };\n            // LinkView is waiting for the target or the source cellView to be rendered\n            // This can happen when the cells are not in the viewport.\n            var sourceFlag = 0;\n            var sourceView = this.findViewByModel(model.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView, dumpOptions);\n                view.updateEndMagnet('source');\n            }\n            var targetFlag = 0;\n            var targetView = this.findViewByModel(model.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView, dumpOptions);\n                view.updateEndMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(view, dumpOptions);\n            }\n        }\n        return false;\n    },\n\n    requestViewUpdate: function(view, flag, priority, opt) {\n        opt || (opt = {});\n        this.scheduleViewUpdate(view, flag, priority, opt);\n        var isAsync = this.isAsync();\n        if (this.isFrozen() || (isAsync && opt.async !== false)) return;\n        if (this.model.hasActiveBatch(this.UPDATE_DELAYING_BATCHES)) return;\n        var stats = this.updateViews(opt);\n        if (isAsync) this.notifyAfterRender(stats, opt);\n    },\n\n    scheduleViewUpdate: function(view, type, priority, opt) {\n        const { _updates: updates, options } = this;\n        if (updates.idle) {\n            if (options.autoFreeze) {\n                updates.idle = false;\n                this.unfreeze();\n            }\n        }\n        const { FLAG_REMOVE, FLAG_INSERT, UPDATE_PRIORITY, cid } = view;\n        let priorityUpdates = updates.priorities[priority];\n        if (!priorityUpdates) priorityUpdates = updates.priorities[priority] = {};\n        // Move higher priority updates to this priority\n        if (priority > UPDATE_PRIORITY) {\n            // Not the default priority for this view. It's most likely a link view\n            // connected to another link view, which triggered the update.\n            // TODO: If there is an update scheduled with a lower priority already, we should\n            // change the requested priority to the lowest one. Does not seem to be critical\n            // right now, as it \"only\" results in multiple updates on the same view.\n            for (let i = priority - 1; i >= UPDATE_PRIORITY; i--) {\n                const prevPriorityUpdates = updates.priorities[i];\n                if (!prevPriorityUpdates || !(cid in prevPriorityUpdates)) continue;\n                priorityUpdates[cid] |= prevPriorityUpdates[cid];\n                delete prevPriorityUpdates[cid];\n            }\n        }\n        let currentType = priorityUpdates[cid] || 0;\n        // Prevent cycling\n        if ((currentType & type) === type) return;\n        if (!currentType) updates.count++;\n        if (type & FLAG_REMOVE && currentType & FLAG_INSERT) {\n            // When a view is removed we need to remove the insert flag as this is a reinsert\n            priorityUpdates[cid] ^= FLAG_INSERT;\n        } else if (type & FLAG_INSERT && currentType & FLAG_REMOVE) {\n            // When a view is added we need to remove the remove flag as this is view was previously removed\n            priorityUpdates[cid] ^= FLAG_REMOVE;\n        }\n        priorityUpdates[cid] |= type;\n        const viewUpdateFn = options.onViewUpdate;\n        if (typeof viewUpdateFn === 'function') viewUpdateFn.call(this, view, type, priority, opt || {}, this);\n    },\n\n    dumpViewUpdate: function(view) {\n        if (!view) return 0;\n        var updates = this._updates;\n        var cid = view.cid;\n        var priorityUpdates = updates.priorities[view.UPDATE_PRIORITY];\n        var flag = this.registerMountedView(view) | priorityUpdates[cid];\n        delete priorityUpdates[cid];\n        return flag;\n    },\n\n    dumpView: function(view, opt = {}) {\n        const flag = this.dumpViewUpdate(view);\n        if (!flag) return 0;\n        const shouldNotify = !opt.silent;\n        if (shouldNotify) this.notifyBeforeRender(opt);\n        const leftover = this.updateView(view, flag, opt);\n        if (shouldNotify) {\n            const stats = { updated: 1, priority: view.UPDATE_PRIORITY };\n            this.notifyAfterRender(stats, opt);\n        }\n        return leftover;\n    },\n\n    updateView: function(view, flag, opt) {\n        if (!view) return 0;\n        const { FLAG_REMOVE, FLAG_INSERT, FLAG_INIT, model } = view;\n        if (view instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_0__.CellView) {\n            if (flag & FLAG_REMOVE) {\n                this.removeView(model);\n                return 0;\n            }\n            if (flag & FLAG_INSERT) {\n                const isInitialInsert = !!(flag & FLAG_INIT);\n                if (isInitialInsert) {\n                    flag ^= FLAG_INIT;\n                }\n                this.insertView(view, isInitialInsert);\n                flag ^= FLAG_INSERT;\n            }\n        }\n        if (!flag) return 0;\n        return view.confirmUpdate(flag, opt || {});\n    },\n\n    requireView: function(model, opt) {\n        var view = this.findViewByModel(model);\n        if (!view) return null;\n        this.dumpView(view, opt);\n        return view;\n    },\n\n    registerUnmountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.unmounted) return 0;\n        var flag = updates.unmounted[cid] |= view.FLAG_INSERT;\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    },\n\n    registerMountedView: function(view) {\n        var cid = view.cid;\n        var updates = this._updates;\n        if (cid in updates.mounted) return 0;\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        var flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    },\n\n    isViewMounted: function(view) {\n        if (!view) return false;\n        var cid = view.cid;\n        var updates = this._updates;\n        return (cid in updates.mounted);\n    },\n\n    dumpViews: function(opt) {\n        var passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)({}, opt, { viewport: null });\n        this.checkViewport(passingOpt);\n        this.updateViews(passingOpt);\n    },\n\n    // Synchronous views update\n    updateViews: function(opt) {\n        this.notifyBeforeRender(opt);\n        let batchStats;\n        let updateCount = 0;\n        let batchCount = 0;\n        let priority = MIN_PRIORITY;\n        do {\n            batchCount++;\n            batchStats = this.updateViewsBatch(opt);\n            updateCount += batchStats.updated;\n            priority = Math.min(batchStats.priority, priority);\n        } while (!batchStats.empty);\n        const stats = { updated: updateCount, batches: batchCount, priority };\n        this.notifyAfterRender(stats, opt);\n        return stats;\n    },\n\n    hasScheduledUpdates: function() {\n        const priorities = this._updates.priorities;\n        const priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        let i = priorityIndexes.length;\n        while (i > 0 && i--) {\n            // a faster way how to check if an object is empty\n            for (let _key in priorities[priorityIndexes[i]]) return true;\n        }\n        return false;\n    },\n\n    updateViewsAsync: function(opt, data) {\n        opt || (opt = {});\n        data || (data = { processed: 0, priority: MIN_PRIORITY });\n        const { _updates: updates, options } = this;\n        const id = updates.id;\n        if (id) {\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cancelFrame)(id);\n            if (data.processed === 0 && this.hasScheduledUpdates()) {\n                this.notifyBeforeRender(opt);\n            }\n            const stats = this.updateViewsBatch(opt);\n            const passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)({}, opt, {\n                mountBatchSize: MOUNT_BATCH_SIZE - stats.mounted,\n                unmountBatchSize: MOUNT_BATCH_SIZE - stats.unmounted\n            });\n            const checkStats = this.checkViewport(passingOpt);\n            const unmountCount = checkStats.unmounted;\n            const mountCount = checkStats.mounted;\n            let processed = data.processed;\n            const total = updates.count;\n            if (stats.updated > 0) {\n                // Some updates have been just processed\n                processed += stats.updated + stats.unmounted;\n                stats.processed = processed;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountCount === 0) {\n                    stats.unmounted += unmountCount;\n                    stats.mounted += mountCount;\n                    stats.priority = data.priority;\n                    this.notifyAfterRender(stats, opt);\n                    data.processed = 0;\n                    data.priority = MIN_PRIORITY;\n                    updates.count = 0;\n                } else {\n                    data.processed = processed;\n                }\n            } else {\n                if (!updates.idle) {\n                    if (options.autoFreeze) {\n                        this.freeze();\n                        updates.idle = true;\n                        this.trigger('render:idle', opt);\n                    }\n                }\n            }\n            // Progress callback\n            const progressFn = opt.progress;\n            if (total && typeof progressFn === 'function') {\n                progressFn.call(this, stats.empty, processed, total, stats, this);\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.id !== id) return;\n        }\n        if (updates.disabled) {\n            throw new Error('dia.Paper: can not unfreeze the paper after it was removed');\n        }\n        updates.id = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.nextFrame)(this.updateViewsAsync, this, opt, data);\n    },\n\n    notifyBeforeRender: function(opt = {}) {\n        let beforeFn = opt.beforeRender;\n        if (typeof beforeFn !== 'function') {\n            beforeFn = this.options.beforeRender;\n            if (typeof beforeFn !== 'function') return;\n        }\n        beforeFn.call(this, opt, this);\n    },\n\n    notifyAfterRender: function(stats, opt = {}) {\n        let afterFn = opt.afterRender;\n        if (typeof afterFn !== 'function') {\n            afterFn = this.options.afterRender;\n        }\n        if (typeof afterFn === 'function') {\n            afterFn.call(this, stats, opt, this);\n        }\n        this.trigger('render:done', stats, opt);\n    },\n\n    updateViewsBatch: function(opt) {\n        opt || (opt = {});\n        var batchSize = opt.batchSize || UPDATE_BATCH_SIZE;\n        var updates = this._updates;\n        var updateCount = 0;\n        var postponeCount = 0;\n        var unmountCount = 0;\n        var mountCount = 0;\n        var maxPriority = MIN_PRIORITY;\n        var empty = true;\n        var options = this.options;\n        var priorities = updates.priorities;\n        var viewportFn = 'viewport' in opt ? opt.viewport : options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var postponeViewFn = options.onViewPostponed;\n        if (typeof postponeViewFn !== 'function') postponeViewFn = null;\n        var priorityIndexes = Object.keys(priorities); // convert priorities to a dense array\n        main: for (var i = 0, n = priorityIndexes.length; i < n; i++) {\n            var priority = +priorityIndexes[i];\n            var priorityUpdates = priorities[priority];\n            for (var cid in priorityUpdates) {\n                if (updateCount >= batchSize) {\n                    empty = false;\n                    break main;\n                }\n                var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[cid];\n                if (!view) {\n                    // This should not occur\n                    delete priorityUpdates[cid];\n                    continue;\n                }\n                var currentFlag = priorityUpdates[cid];\n                if ((currentFlag & view.FLAG_REMOVE) === 0) {\n                    // We should never check a view for viewport if we are about to remove the view\n                    var isDetached = cid in updates.unmounted;\n                    if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, !isDetached, this)) {\n                        // Unmount View\n                        if (!isDetached) {\n                            this.registerUnmountedView(view);\n                            this.detachView(view);\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete priorityUpdates[cid];\n                        unmountCount++;\n                        continue;\n                    }\n                    // Mount View\n                    if (isDetached) {\n                        currentFlag |= view.FLAG_INSERT;\n                        mountCount++;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                var leftoverFlag = this.updateView(view, currentFlag, opt);\n                if (leftoverFlag > 0) {\n                    // View update has not finished completely\n                    priorityUpdates[cid] = leftoverFlag;\n                    if (!postponeViewFn || !postponeViewFn.call(this, view, leftoverFlag, this) || priorityUpdates[cid]) {\n                        postponeCount++;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (maxPriority > priority) maxPriority = priority;\n                updateCount++;\n                delete priorityUpdates[cid];\n            }\n        }\n        return {\n            priority: maxPriority,\n            updated: updateCount,\n            postponed: postponeCount,\n            unmounted: unmountCount,\n            mounted: mountCount,\n            empty: empty\n        };\n    },\n\n    getUnmountedViews: function() {\n        const updates = this._updates;\n        const unmountedCids = Object.keys(updates.unmounted);\n        const n = unmountedCids.length;\n        const unmountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            unmountedViews[i] = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[unmountedCids[i]];\n        }\n        return unmountedViews;\n    },\n\n    getMountedViews: function() {\n        const updates = this._updates;\n        const mountedCids = Object.keys(updates.mounted);\n        const n = mountedCids.length;\n        const mountedViews = new Array(n);\n        for (var i = 0; i < n; i++) {\n            mountedViews[i] = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[mountedCids[i]];\n        }\n        return mountedViews;\n    },\n\n    checkUnmountedViews: function(viewportFn, opt) {\n        opt || (opt  = {});\n        var mountCount = 0;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        var batchSize = 'mountBatchSize' in opt ? opt.mountBatchSize : Infinity;\n        var updates = this._updates;\n        var unmountedCids = updates.unmountedCids;\n        var unmounted = updates.unmounted;\n        for (var i = 0, n = Math.min(unmountedCids.length, batchSize); i < n; i++) {\n            var cid = unmountedCids[i];\n            if (!(cid in unmounted)) continue;\n            var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[cid];\n            if (!view) continue;\n            if (view.DETACHABLE && viewportFn && !viewportFn.call(this, view, false, this)) {\n                // Push at the end of all unmounted ids, so this can be check later again\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount++;\n            var flag = this.registerMountedView(view);\n            if (flag) this.scheduleViewUpdate(view, flag, view.UPDATE_PRIORITY, { mounting: true });\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, i);\n        return mountCount;\n    },\n\n    checkMountedViews: function(viewportFn, opt) {\n        opt || (opt = {});\n        var unmountCount = 0;\n        if (typeof viewportFn !== 'function') return unmountCount;\n        var batchSize = 'unmountBatchSize' in opt ? opt.unmountBatchSize : Infinity;\n        var updates = this._updates;\n        var mountedCids = updates.mountedCids;\n        var mounted = updates.mounted;\n        for (var i = 0, n = Math.min(mountedCids.length, batchSize); i < n; i++) {\n            var cid = mountedCids[i];\n            if (!(cid in mounted)) continue;\n            var view = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_2__.views[cid];\n            if (!view) continue;\n            if (!view.DETACHABLE || viewportFn.call(this, view, true, this)) {\n                // Push at the end of all mounted ids, so this can be check later again\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount++;\n            var flag = this.registerUnmountedView(view);\n            if (flag) this.detachView(view);\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, i);\n        return unmountCount;\n    },\n\n    checkViewVisibility: function(cellView, opt = {}) {\n        let viewportFn = 'viewport' in opt ? opt.viewport : this.options.viewport;\n        if (typeof viewportFn !== 'function') viewportFn = null;\n        const updates = this._updates;\n        const { mounted, unmounted } = updates;\n        const visible = !cellView.DETACHABLE || !viewportFn || viewportFn.call(this, cellView, false, this);\n\n        let isUnmounted = false;\n        let isMounted = false;\n\n        if (cellView.cid in mounted && !visible) {\n            const flag = this.registerUnmountedView(cellView);\n            if (flag) this.detachView(cellView);\n            const i = updates.mountedCids.indexOf(cellView.cid);\n            updates.mountedCids.splice(i, 1);\n            isUnmounted = true;\n        }\n\n        if (!isUnmounted && cellView.cid in unmounted && visible) {\n            const i = updates.unmountedCids.indexOf(cellView.cid);\n            updates.unmountedCids.splice(i, 1);\n            var flag = this.registerMountedView(cellView);\n            if (flag) this.scheduleViewUpdate(cellView, flag, cellView.UPDATE_PRIORITY, { mounting: true });\n            isMounted = true;\n        }\n\n        return {\n            mounted: isMounted ? 1 : 0,\n            unmounted: isUnmounted ? 1 : 0\n        };\n    },\n\n    checkViewport: function(opt) {\n        var passingOpt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)({}, opt, {\n            mountBatchSize: Infinity,\n            unmountBatchSize: Infinity\n        });\n        var viewportFn = 'viewport' in passingOpt ? passingOpt.viewport : this.options.viewport;\n        var unmountedCount = this.checkMountedViews(viewportFn, passingOpt);\n        if (unmountedCount > 0) {\n            // Do not check views, that have been just unmounted and pushed at the end of the cids array\n            var unmountedCids = this._updates.unmountedCids;\n            passingOpt.mountBatchSize = Math.min(unmountedCids.length - unmountedCount, passingOpt.mountBatchSize);\n        }\n        var mountedCount = this.checkUnmountedViews(viewportFn, passingOpt);\n        return {\n            mounted: mountedCount,\n            unmounted: unmountedCount\n        };\n    },\n\n    freeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var isFrozen = this.options.frozen;\n        var freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey)  {\n            // key passed, but the paper is already freezed with another key\n            if (isFrozen && freezeKey) return;\n            updates.freezeKey = key;\n            updates.keyFrozen = isFrozen;\n        }\n        this.options.frozen = true;\n        var id = updates.id;\n        updates.id = null;\n        if (this.isAsync() && id) (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cancelFrame)(id);\n    },\n\n    unfreeze: function(opt) {\n        opt || (opt = {});\n        var updates = this._updates;\n        var key = opt.key;\n        var freezeKey = updates.freezeKey;\n        // key passed, but the paper is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) return;\n        updates.freezeKey = null;\n        // key passed, but the paper is already freezed\n        if (key && key === freezeKey && updates.keyFrozen) return;\n        if (this.isAsync()) {\n            this.freeze();\n            this.updateViewsAsync(opt);\n        } else {\n            this.updateViews(opt);\n        }\n        this.options.frozen = updates.keyFrozen = false;\n        if (updates.sort) {\n            this.sortViews();\n            updates.sort = false;\n        }\n    },\n\n    isAsync: function() {\n        return !!this.options.async;\n    },\n\n    isFrozen: function() {\n        return !!this.options.frozen;\n    },\n\n    isExactSorting: function() {\n        return this.options.sorting === sortingTypes.EXACT;\n    },\n\n    onRemove: function() {\n\n        this.freeze();\n        this._updates.disabled = true;\n        //clean up all DOM elements/views to prevent memory leaks\n        this.removeLayers();\n        this.removeViews();\n    },\n\n    getComputedSize: function() {\n\n        var options = this.options;\n        var w = options.width;\n        var h = options.height;\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(w)) w = this.el.clientWidth;\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(h)) h = this.el.clientHeight;\n        return { width: w, height: h };\n    },\n\n    setDimensions: function(width, height, data = {}) {\n        const { options } = this;\n        const { width: currentWidth, height: currentHeight } = options;\n        let w = (width === undefined) ? currentWidth : width;\n        let h = (height === undefined) ? currentHeight : height;\n        if (currentWidth === w && currentHeight === h) return;\n        options.width = w;\n        options.height = h;\n        this._setDimensions();\n        const computedSize = this.getComputedSize();\n        this.trigger('resize', computedSize.width, computedSize.height, data);\n    },\n\n    _setDimensions: function() {\n        const { options } = this;\n        let w = options.width;\n        let h = options.height;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(w)) w = `${Math.round(w)}px`;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(h)) h = `${Math.round(h)}px`;\n        this.$el.css({\n            width: (w === null) ? '' : w,\n            height: (h === null) ? '' : h\n        });\n    },\n\n    // Expand/shrink the paper to fit the content.\n    // Alternatively signature function(opt)\n    fitToContent: function(gridWidth, gridHeight, padding, opt) {\n\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(gridWidth)) {\n            // first parameter is an option object\n            opt = gridWidth;\n        } else {\n            // Support for a deprecated signature\n            opt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.assign)({ gridWidth, gridHeight, padding }, opt);\n        }\n\n        const { x, y, width, height } = this.getFitToContentArea(opt);\n        const { sx, sy } = this.scale();\n\n        this.translate(-x * sx, -y * sy, opt);\n        this.setDimensions(width * sx, height * sy, opt);\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n    },\n\n    getFitToContentArea: function(opt = {}) {\n\n        // Calculate the paper size to accommodate all the graph's elements.\n\n        const gridWidth = opt.gridWidth || 1;\n        const gridHeight = opt.gridHeight || 1;\n        const padding = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeSides)(opt.padding || 0);\n\n        const minWidth = Math.max(opt.minWidth || 0, gridWidth);\n        const minHeight = Math.max(opt.minHeight || 0, gridHeight);\n        const maxWidth = opt.maxWidth || Number.MAX_VALUE;\n        const maxHeight = opt.maxHeight || Number.MAX_VALUE;\n        const newOrigin = opt.allowNewOrigin;\n\n        const area = ('contentArea' in opt) ? new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(opt.contentArea) : this.getContentArea(opt);\n        const { sx, sy } = this.scale();\n        area.x *= sx;\n        area.y *= sy;\n        area.width *= sx;\n        area.height *= sy;\n\n        let calcWidth = Math.ceil((area.width + area.x) / gridWidth);\n        let calcHeight = Math.ceil((area.height + area.y) / gridHeight);\n        if (!opt.allowNegativeBottomRight) {\n            calcWidth = Math.max(calcWidth, 1);\n            calcHeight = Math.max(calcHeight, 1);\n        }\n        calcWidth *= gridWidth;\n        calcHeight *= gridHeight;\n\n        let tx = 0;\n        if ((newOrigin === 'negative' && area.x < 0) || (newOrigin === 'positive' && area.x >= 0) || newOrigin === 'any') {\n            tx = Math.ceil(-area.x / gridWidth) * gridWidth;\n            tx += padding.left;\n            calcWidth += tx;\n        }\n\n        let ty = 0;\n        if ((newOrigin === 'negative' && area.y < 0) || (newOrigin === 'positive' && area.y >= 0) || newOrigin === 'any') {\n            ty = Math.ceil(-area.y / gridHeight) * gridHeight;\n            ty += padding.top;\n            calcHeight += ty;\n        }\n\n        calcWidth += padding.right;\n        calcHeight += padding.bottom;\n\n        // Make sure the resulting width and height are greater than minimum.\n        calcWidth = Math.max(calcWidth, minWidth);\n        calcHeight = Math.max(calcHeight, minHeight);\n\n        // Make sure the resulting width and height are lesser than maximum.\n        calcWidth = Math.min(calcWidth, maxWidth);\n        calcHeight = Math.min(calcHeight, maxHeight);\n\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(-tx / sx, -ty / sy, calcWidth / sx, calcHeight / sy);\n    },\n\n    transformToFitContent: function(opt) {\n        opt || (opt = {});\n\n        let contentBBox, contentLocalOrigin;\n        if ('contentArea' in opt) {\n            const contentArea = opt.contentArea;\n            contentBBox = this.localToPaperRect(contentArea);\n            contentLocalOrigin = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(contentArea);\n        } else {\n            contentBBox = this.getContentBBox(opt);\n            contentLocalOrigin = this.paperToLocalPoint(contentBBox);\n        }\n\n        if (!contentBBox.width || !contentBBox.height) return;\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)(opt, {\n            padding: 0,\n            preserveAspectRatio: true,\n            scaleGrid: null,\n            minScale: 0,\n            maxScale: Number.MAX_VALUE,\n            verticalAlign: 'top',\n            horizontalAlign: 'left',\n            //minScaleX\n            //minScaleY\n            //maxScaleX\n            //maxScaleY\n            //fittingBBox\n        });\n\n        const padding = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeSides)(opt.padding);\n\n        const minScaleX = opt.minScaleX || opt.minScale;\n        const maxScaleX = opt.maxScaleX || opt.maxScale;\n        const minScaleY = opt.minScaleY || opt.minScale;\n        const maxScaleY = opt.maxScaleY || opt.maxScale;\n\n        let fittingBBox;\n        if (opt.fittingBBox) {\n            fittingBBox = opt.fittingBBox;\n        } else {\n            const currentTranslate = this.translate();\n            const computedSize = this.getComputedSize();\n            fittingBBox = {\n                x: currentTranslate.tx,\n                y: currentTranslate.ty,\n                width: computedSize.width,\n                height: computedSize.height\n            };\n        }\n\n        fittingBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(fittingBBox).moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.left - padding.right,\n            height: -padding.top - padding.bottom\n        });\n\n        const ctm = this.matrix();\n        const { a: sx, d: sy, e: tx, f: ty } = ctm;\n\n        let newSx = fittingBBox.width / contentBBox.width * sx;\n        let newSy = fittingBBox.height / contentBBox.height * sy;\n\n        if (opt.preserveAspectRatio) {\n            newSx = newSy = Math.min(newSx, newSy);\n        }\n\n        // snap scale to a grid\n        if (opt.scaleGrid) {\n\n            const gridSize = opt.scaleGrid;\n\n            newSx = gridSize * Math.floor(newSx / gridSize);\n            newSy = gridSize * Math.floor(newSy / gridSize);\n        }\n\n        // scale min/max boundaries\n        newSx = Math.min(maxScaleX, Math.max(minScaleX, newSx));\n        newSy = Math.min(maxScaleY, Math.max(minScaleY, newSy));\n\n        const scaleDiff = {\n            x: newSx / sx,\n            y: newSy / sy\n        };\n\n        let newOx = fittingBBox.x - contentLocalOrigin.x * newSx - tx;\n        let newOy = fittingBBox.y - contentLocalOrigin.y * newSy - ty;\n\n        switch (opt.verticalAlign) {\n            case 'middle':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y) / 2;\n                break;\n            case 'bottom':\n                newOy = newOy + (fittingBBox.height - contentBBox.height * scaleDiff.y);\n                break;\n            case 'top':\n            default:\n                break;\n        }\n\n        switch (opt.horizontalAlign) {\n            case 'middle':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x) / 2;\n                break;\n            case 'right':\n                newOx = newOx + (fittingBBox.width - contentBBox.width * scaleDiff.x);\n                break;\n            case 'left':\n            default:\n                break;\n        }\n\n        ctm.a = newSx;\n        ctm.d = newSy;\n        ctm.e = newOx;\n        ctm.f = newOy;\n        this.matrix(ctm, opt);\n    },\n\n    scaleContentToFit: function(opt) {\n        this.transformToFitContent(opt);\n    },\n\n    // Return the dimensions of the content area in local units (without transformations).\n    getContentArea: function(opt) {\n\n        if (opt && opt.useModelGeometry) {\n            return this.model.getBBox() || new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect();\n        }\n\n        return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(this.cells).getBBox();\n    },\n\n    // Return the dimensions of the content bbox in the paper units (as it appears on screen).\n    getContentBBox: function(opt) {\n\n        return this.localToPaperRect(this.getContentArea(opt));\n    },\n\n    // Returns a geometry rectangle representing the entire\n    // paper area (coordinates from the left paper border to the right one\n    // and the top border to the bottom one).\n    getArea: function() {\n\n        return this.paperToLocalRect(this.getComputedSize());\n    },\n\n    getRestrictedArea: function(...args) {\n\n        const { restrictTranslate } = this.options;\n\n        let restrictedArea;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(restrictTranslate)) {\n            // A method returning a bounding box\n            restrictedArea = restrictTranslate.apply(this, args);\n        } else if (restrictTranslate === true) {\n            // The paper area\n            restrictedArea = this.getArea();\n        } else if (!restrictTranslate) {\n            // falsy value\n            restrictedArea = null;\n        } else {\n            // any other value\n            restrictedArea = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(restrictTranslate);\n        }\n\n        return restrictedArea;\n    },\n\n    createViewForModel: function(cell) {\n\n        const { options } = this;\n        // A class taken from the paper options.\n        var optionalViewClass;\n\n        // A default basic class (either dia.ElementView or dia.LinkView)\n        var defaultViewClass;\n\n        // A special class defined for this model in the corresponding namespace.\n        // e.g. joint.shapes.standard.Rectangle searches for joint.shapes.standard.RectangleView\n        var namespace = options.cellViewNamespace;\n        var type = cell.get('type') + 'View';\n        var namespaceViewClass = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.getByPath)(namespace, type, '.');\n\n        if (cell.isLink()) {\n            optionalViewClass = options.linkView;\n            defaultViewClass = _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__.LinkView;\n        } else {\n            optionalViewClass = options.elementView;\n            defaultViewClass = _ElementView_mjs__WEBPACK_IMPORTED_MODULE_3__.ElementView;\n        }\n\n        // a) the paper options view is a class (deprecated)\n        //  1. search the namespace for a view\n        //  2. if no view was found, use view from the paper options\n        // b) the paper options view is a function\n        //  1. call the function from the paper options\n        //  2. if no view was return, search the namespace for a view\n        //  3. if no view was found, use the default\n        var ViewClass = (optionalViewClass.prototype instanceof _mvc_ViewBase_mjs__WEBPACK_IMPORTED_MODULE_16__.ViewBase)\n            ? namespaceViewClass || optionalViewClass\n            : optionalViewClass.call(this, cell) || namespaceViewClass || defaultViewClass;\n\n        return new ViewClass({\n            model: cell,\n            interactive: options.interactive,\n            labelsLayer: options.labelsLayer === true ? _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.LABELS : options.labelsLayer\n        });\n    },\n\n    removeView: function(cell) {\n\n        const { id } = cell;\n        const { _views, _updates } = this;\n        const view = _views[id];\n        if (view) {\n            var { cid } = view;\n            const { mounted, unmounted } = _updates;\n            view.remove();\n            delete _views[id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    },\n\n    renderView: function(cell, opt) {\n\n        const { id } = cell;\n        const views = this._views;\n        let view, flag;\n        let create = true;\n        if (id in views) {\n            view = views[id];\n            if (view.model === cell) {\n                flag = view.FLAG_INSERT;\n                create = false;\n            } else {\n                // The view for this `id` already exist.\n                // The cell is a new instance of the model with identical id\n                // We simply remove the existing view and create a new one\n                this.removeView(cell);\n            }\n        }\n        if (create) {\n            view = views[id] = this.createViewForModel(cell);\n            view.paper = this;\n            flag = this.registerUnmountedView(view) | this.FLAG_INIT | view.getFlag((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.result)(view, 'initFlag'));\n        }\n        this.requestViewUpdate(view, flag, view.UPDATE_PRIORITY, opt);\n        return view;\n    },\n\n    onImageDragStart: function() {\n        // This is the only way to prevent image dragging in Firefox that works.\n        // Setting -moz-user-select: none, draggable=\"false\" attribute or user-drag: none didn't help.\n\n        return false;\n    },\n\n    resetViews: function(cells, opt) {\n        opt || (opt = {});\n        cells || (cells = []);\n        this._resetUpdates();\n        // clearing views removes any event listeners\n        this.removeViews();\n        // Allows to unfreeze normally while in the idle state using autoFreeze option\n        const key = this.options.autoFreeze ? null : 'reset';\n        this.freeze({ key });\n        for (var i = 0, n = cells.length; i < n; i++) {\n            this.renderView(cells[i], opt);\n        }\n        this.unfreeze({ key });\n        this.sortViews();\n    },\n\n    removeViews: function() {\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.invoke)(this._views, 'remove');\n\n        this._views = {};\n    },\n\n    sortViews: function() {\n\n        if (!this.isExactSorting()) {\n            // noop\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this._updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    },\n\n    sortViewsExact: function() {\n\n        // Run insertion sort algorithm in order to efficiently sort DOM elements according to their\n        // associated model `z` attribute.\n\n        var cellNodes = Array.from(this.cells.childNodes).filter(node => node.getAttribute('model-id'));\n        var cells = this.model.get('cells');\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.sortElements)(cellNodes, function(a, b) {\n            var cellA = cells.get(a.getAttribute('model-id'));\n            var cellB = cells.get(b.getAttribute('model-id'));\n            var zA = cellA.attributes.z || 0;\n            var zB = cellB.attributes.z || 0;\n            return (zA === zB) ? 0 : (zA < zB) ? -1 : 1;\n        });\n    },\n\n    insertView: function(view, isInitialInsert) {\n        const layerView = this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.CELLS);\n        const { el, model } = view;\n        switch (this.options.sorting) {\n            case sortingTypes.APPROX:\n                layerView.insertSortedNode(el, model.get('z'));\n                break;\n            case sortingTypes.EXACT:\n            default:\n                layerView.insertNode(el);\n                break;\n        }\n        view.onMount(isInitialInsert);\n    },\n\n    detachView(view) {\n        view.unmount();\n        view.onDetach();\n    },\n\n    // Find the first view climbing up the DOM tree starting at element `el`. Note that `el` can also\n    // be a selector or a jQuery object.\n    findView: function($el) {\n\n        var el = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isString)($el)\n            ? this.cells.querySelector($el)\n            : $el instanceof _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"] ? $el[0] : $el;\n\n        var id = this.findAttribute('model-id', el);\n        if (id) return this._views[id];\n\n        return undefined;\n    },\n\n    // Find a view for a model `cell`. `cell` can also be a string or number representing a model `id`.\n    findViewByModel: function(cell) {\n\n        var id = ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isString)(cell) || (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(cell)) ? cell : (cell && cell.id);\n\n        return this._views[id];\n    },\n\n    // Find all views at given point\n    findViewsFromPoint: function(p) {\n\n        p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(p);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n\n        return views.filter(function(view) {\n            return view && view.vel.getBBox({ target: this.cells }).containsPoint(p);\n        }, this);\n    },\n\n    // Find all views in given area\n    findViewsInArea: function(rect, opt) {\n\n        opt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.defaults)(opt || {}, { strict: false });\n        rect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(rect);\n\n        var views = this.model.getElements().map(this.findViewByModel, this);\n        var method = opt.strict ? 'containsRect' : 'intersect';\n\n        return views.filter(function(view) {\n            return view && rect[method](view.vel.getBBox({ target: this.cells }));\n        }, this);\n    },\n\n    findElementViewsInArea(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findElementsInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findLinkViewsInArea: function(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findLinksInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findCellViewsInArea: function(plainArea, opt) {\n        return this._filterViewsInArea(\n            plainArea,\n            (extArea, findOpt) => this.model.findCellsInArea(extArea, findOpt),\n            opt\n        );\n    },\n\n    findElementViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            (extArea) => this.model.findElementsInArea(extArea),\n            opt\n        );\n    },\n\n    findLinkViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            (extArea) => this.model.findLinksInArea(extArea),\n            opt,\n        );\n    },\n\n    findCellViewsAtPoint: function(plainPoint, opt) {\n        return this._filterViewsAtPoint(\n            plainPoint,\n            // Note: we do not want to pass `opt` to `findCellsInArea`\n            // because the `strict` option works differently for querying at a point\n            (extArea) => this.model.findCellsInArea(extArea),\n            opt\n        );\n    },\n\n    _findInExtendedArea: function(area, findCellsFn, opt = {}) {\n        const {\n            buffer = this.DEFAULT_FIND_BUFFER,\n        } = opt;\n        const extendedArea = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(area)).inflate(buffer);\n        const cellsInExtendedArea = findCellsFn(extendedArea, opt);\n        return cellsInExtendedArea.map(element => this.findViewByModel(element));\n    },\n\n    _filterViewsInArea: function(plainArea, findCells, opt = {}) {\n        const area = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(plainArea);\n        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n        const viewsInArea = viewsInExtendedArea.filter(view => {\n            if (!view) return false;\n            return view.isInArea(area, opt);\n        });\n        return viewsInArea;\n    },\n\n    _filterViewsAtPoint: function(plainPoint, findCells, opt = {}) {\n        const area = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(plainPoint); // zero-size area\n        const viewsInExtendedArea = this._findInExtendedArea(area, findCells, opt);\n        const viewsAtPoint = viewsInExtendedArea.filter(view => {\n            if (!view) return false;\n            return view.isAtPoint(plainPoint, opt);\n        });\n        return viewsAtPoint;\n    },\n\n    removeTools: function() {\n        this.dispatchToolsEvent('remove');\n        return this;\n    },\n\n    hideTools: function() {\n        this.dispatchToolsEvent('hide');\n        return this;\n    },\n\n    showTools: function() {\n        this.dispatchToolsEvent('show');\n        return this;\n    },\n\n    dispatchToolsEvent: function(event, ...args) {\n        if (typeof event !== 'string') return;\n        this.trigger('tools:event', event, ...args);\n    },\n\n\n    getModelById: function(id) {\n\n        return this.model.getCell(id);\n    },\n\n    snapToGrid: function(x, y) {\n\n        // Convert global coordinates to the local ones of the `viewport`. Otherwise,\n        // improper transformation would be applied when the viewport gets transformed (scaled/rotated).\n        return this.clientToLocalPoint(x, y).snapToGrid(this.options.gridSize);\n    },\n\n    localToPaperPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var paperPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(localPoint, this.matrix());\n        return paperPoint;\n    },\n\n    localToPaperRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var localRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var paperRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(localRect, this.matrix());\n        return paperRect;\n    },\n\n    paperToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var paperPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var localPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(paperPoint, this.matrix().inverse());\n        return localPoint;\n    },\n\n    paperToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a rectangle and rest arguments undefined\n        var paperRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var localRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(paperRect, this.matrix().inverse());\n        return localRect;\n    },\n\n    localToClientPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var localPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var clientPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(localPoint, this.clientMatrix());\n        return clientPoint;\n    },\n\n    localToClientRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var localRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var clientRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(localRect, this.clientMatrix());\n        return clientRect;\n    },\n\n    // Transform client coordinates to the paper local coordinates.\n    // Useful when you have a mouse event object and you'd like to get coordinates\n    // inside the paper that correspond to `evt.clientX` and `evt.clientY` point.\n    // Example: var localPoint = paper.clientToLocalPoint({ x: evt.clientX, y: evt.clientY });\n    clientToLocalPoint: function(x, y) {\n        // allow `x` to be a point and `y` undefined\n        var clientPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var localPoint = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformPoint(clientPoint, this.clientMatrix().inverse());\n        return localPoint;\n    },\n\n    clientToLocalRect: function(x, y, width, height) {\n        // allow `x` to be a point and `y` undefined\n        var clientRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        var localRect = _V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"].transformRect(clientRect, this.clientMatrix().inverse());\n        return localRect;\n    },\n\n    localToPagePoint: function(x, y) {\n\n        return this.localToPaperPoint(x, y).offset(this.pageOffset());\n    },\n\n    localToPageRect: function(x, y, width, height) {\n\n        return this.localToPaperRect(x, y, width, height).offset(this.pageOffset());\n    },\n\n    pageToLocalPoint: function(x, y) {\n\n        var pagePoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(x, y);\n        var paperPoint = pagePoint.difference(this.pageOffset());\n        return this.paperToLocalPoint(paperPoint);\n    },\n\n    pageToLocalRect: function(x, y, width, height) {\n\n        var pageOffset = this.pageOffset();\n        var paperRect = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(x, y, width, height);\n        paperRect.x -= pageOffset.x;\n        paperRect.y -= pageOffset.y;\n        return this.paperToLocalRect(paperRect);\n    },\n\n    clientOffset: function() {\n\n        var clientRect = this.svg.getBoundingClientRect();\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_15__.Point(clientRect.left, clientRect.top);\n    },\n\n    pageOffset: function() {\n\n        return this.clientOffset().offset(window.scrollX, window.scrollY);\n    },\n\n    linkAllowed: function(linkView) {\n\n        if (!(linkView instanceof _LinkView_mjs__WEBPACK_IMPORTED_MODULE_4__.LinkView)) {\n            throw new Error('Must provide a linkView.');\n        }\n\n        var link = linkView.model;\n        var paperOptions = this.options;\n        var graph = this.model;\n        var ns = graph.constructor.validations;\n\n        if (!paperOptions.multiLinks) {\n            if (!ns.multiLinks.call(this, graph, link)) return false;\n        }\n\n        if (!paperOptions.linkPinning) {\n            // Link pinning is not allowed and the link is not connected to the target.\n            if (!ns.linkPinning.call(this, graph, link)) return false;\n        }\n\n        if (typeof paperOptions.allowLink === 'function') {\n            if (!paperOptions.allowLink.call(this, linkView, this)) return false;\n        }\n\n        return true;\n    },\n\n    getDefaultLink: function(cellView, magnet) {\n\n        return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(this.options.defaultLink)\n        // default link is a function producing link model\n            ? this.options.defaultLink.call(this, cellView, magnet)\n        // default link is the mvc model\n            : this.options.defaultLink.clone();\n    },\n\n    // Cell highlighting.\n    // ------------------\n\n    resolveHighlighter: function(opt = {}) {\n\n        let { highlighter: highlighterDef, type } = opt;\n        const { highlighting,highlighterNamespace  } = this.options;\n\n        /*\n            Expecting opt.highlighter to have the following structure:\n            {\n                name: 'highlighter-name',\n                options: {\n                    some: 'value'\n                }\n            }\n        */\n        if (highlighterDef === undefined) {\n\n            // Is highlighting disabled?\n            if (!highlighting) return false;\n            // check for built-in types\n            if (type) {\n                highlighterDef = highlighting[type];\n                // Is a specific type highlight disabled?\n                if (highlighterDef === false) return false;\n            }\n            if (!highlighterDef) {\n                // Type not defined use default highlight\n                highlighterDef = highlighting['default'];\n            }\n        }\n\n        // Do nothing if opt.highlighter is falsy.\n        // This allows the case to not highlight cell(s) in certain cases.\n        // For example, if you want to NOT highlight when embedding elements\n        // or use a custom highlighter.\n        if (!highlighterDef) return false;\n\n        // Allow specifying a highlighter by name.\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isString)(highlighterDef)) {\n            highlighterDef = {\n                name: highlighterDef\n            };\n        }\n\n        const name = highlighterDef.name;\n        const highlighter = highlighterNamespace[name];\n\n        // Highlighter validation\n        if (!highlighter) {\n            throw new Error('Unknown highlighter (\"' + name + '\")');\n        }\n        if (typeof highlighter.highlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required highlight() method');\n        }\n        if (typeof highlighter.unhighlight !== 'function') {\n            throw new Error('Highlighter (\"' + name + '\") is missing required unhighlight() method');\n        }\n\n        return {\n            highlighter,\n            options: highlighterDef.options || {},\n            name\n        };\n    },\n\n    onCellHighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.highlight(cellView, magnetEl, options);\n    },\n\n    onCellUnhighlight: function(cellView, magnetEl, opt) {\n        const highlighterDescriptor = this.resolveHighlighter(opt);\n        if (!highlighterDescriptor) return;\n        const { highlighter, options } = highlighterDescriptor;\n        highlighter.unhighlight(cellView, magnetEl, options);\n    },\n\n    // Interaction.\n    // ------------\n\n    pointerdblclick: function(evt) {\n\n        evt.preventDefault();\n\n        // magnetpointerdblclick can stop propagation\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.pointerdblclick(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:pointerdblclick', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerclick: function(evt) {\n\n        // magnetpointerclick can stop propagation\n\n        var data = this.eventData(evt);\n        // Trigger event only if mouse has not moved.\n        if (data.mousemoved <= this.options.clickThreshold) {\n\n            evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n            var view = this.findView(evt.target);\n            if (this.guard(evt, view)) return;\n\n            var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n            if (view) {\n                view.pointerclick(evt, localPoint.x, localPoint.y);\n\n            } else {\n                this.trigger('blank:pointerclick', evt, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    contextmenu: function(evt) {\n\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.contextMenuFired) {\n            this.contextMenuFired = false;\n            return;\n        }\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        this.contextMenuTrigger(evt);\n    },\n\n    contextMenuTrigger: function(evt) {\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        if (view) {\n            view.contextmenu(evt, localPoint.x, localPoint.y);\n\n        } else {\n            this.trigger('blank:contextmenu', evt, localPoint.x, localPoint.y);\n        }\n    },\n\n    pointerdown: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const { target, button } = evt;\n        const view = this.findView(target);\n        const isContextMenu = (button === 2);\n\n        if (view) {\n\n            if (!isContextMenu && this.guard(evt, view)) return;\n\n            const isTargetFormNode = this.FORM_CONTROL_TAG_NAMES.includes(target.tagName);\n\n            if (this.options.preventDefaultViewAction && !isTargetFormNode) {\n                // If the target is a form element, we do not want to prevent the default action.\n                // For example, we want to be able to select text in a text input or\n                // to be able to click on a checkbox.\n                evt.preventDefault();\n            }\n\n            if (isTargetFormNode) {\n                // If the target is a form element, we do not want to start dragging the element.\n                // For example, we want to be able to select text by dragging the mouse.\n                view.preventDefaultInteraction(evt);\n            }\n\n            // Custom event\n            const eventEvt = this.customEventTrigger(evt, view);\n            if (eventEvt) {\n            // `onevent` could have stopped propagation\n                if (eventEvt.isPropagationStopped()) return;\n\n                evt.data = eventEvt.data;\n            }\n\n            // Element magnet\n            const magnetNode = target.closest('[magnet]');\n            if (magnetNode && view.el !== magnetNode && view.el.contains(magnetNode)) {\n                const magnetEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, {\n                    data: evt.data,\n                    // Originally the event listener was attached to the magnet element.\n                    currentTarget: magnetNode\n                }));\n                this.onmagnet(magnetEvt);\n                if (magnetEvt.isDefaultPrevented()) {\n                    evt.preventDefault();\n                }\n                // `onmagnet` stops propagation when `addLinkFromMagnet` is allowed\n                if (magnetEvt.isPropagationStopped()) {\n                    // `magnet:pointermove` and `magnet:pointerup` events must be fired\n                    if (isContextMenu) return;\n                    this.delegateDragEvents(view, magnetEvt.data);\n                    return;\n                }\n                evt.data = magnetEvt.data;\n            }\n        }\n\n        if (isContextMenu) {\n            this.contextMenuFired = true;\n            const contextmenuEvt = new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, { type: 'contextmenu', data: evt.data });\n            this.contextMenuTrigger(contextmenuEvt);\n        } else {\n            const localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n            if (view) {\n                view.pointerdown(evt, localPoint.x, localPoint.y);\n            } else {\n                if (this.options.preventDefaultBlankAction) {\n                    evt.preventDefault();\n                }\n                this.trigger('blank:pointerdown', evt, localPoint.x, localPoint.y);\n            }\n\n            this.delegateDragEvents(view, evt.data);\n        }\n\n    },\n\n    pointermove: function(evt) {\n\n        // mouse moved counter\n        var data = this.eventData(evt);\n        if (!data.mousemoved) {\n            data.mousemoved = 0;\n            // Make sure that events like `mouseenter` and `mouseleave` are\n            // not triggered while the user is dragging a cellView.\n            this.undelegateEvents();\n            // Note: the events are undelegated after the first `pointermove` event.\n            // Not on `pointerdown` to make sure that `dbltap` is recognized.\n        }\n\n        var mousemoved = ++data.mousemoved;\n\n        if (mousemoved <= this.options.moveThreshold) return;\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n\n        var view = data.sourceView;\n        if (view) {\n            view.pointermove(evt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointermove', evt, localPoint.x, localPoint.y);\n        }\n\n        this.eventData(evt, data);\n    },\n\n    pointerup: function(evt) {\n\n        this.undelegateDocumentEvents();\n\n        var normalizedEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var localPoint = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n\n        var view = this.eventData(evt).sourceView;\n        if (view) {\n            view.pointerup(normalizedEvt, localPoint.x, localPoint.y);\n        } else {\n            this.trigger('blank:pointerup', normalizedEvt, localPoint.x, localPoint.y);\n        }\n\n        if (!normalizedEvt.isPropagationStopped()) {\n            this.pointerclick(new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, { type: 'click', data: evt.data }));\n        }\n\n        this.delegateEvents();\n    },\n\n    mouseover: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseover(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseover', evt);\n        }\n    },\n\n    mouseout: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        var view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        if (view) {\n            view.mouseout(evt);\n\n        } else {\n            if (this.el === evt.target) return; // prevent border of paper from triggering this\n            this.trigger('blank:mouseout', evt);\n        }\n    },\n\n    mouseenter: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const {\n            target, // The EventTarget the pointing device entered to\n            relatedTarget, // The EventTarget the pointing device exited from\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse left a cell tool\n                return;\n            }\n            view.mouseenter(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer remains inside the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            return;\n        }\n        // prevent double `mouseenter` event if the `relatedTarget` is outside the paper\n        // (mouseenter method would be fired twice)\n        if (currentTarget === this.el) {\n            // `paper` (more descriptive), not `blank`\n            this.trigger('paper:mouseenter', evt);\n        }\n    },\n\n    mouseleave: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const {\n            target, // The EventTarget the pointing device exited from\n            relatedTarget, // The EventTarget the pointing device entered to\n            currentTarget // The EventTarget on which the event listener was registered\n        } = evt;\n        const view = this.findView(target);\n        if (this.guard(evt, view)) return;\n        const relatedView = this.findView(relatedTarget);\n        if (view) {\n            if (relatedView === view) {\n                // Mouse entered a cell tool\n                return;\n            }\n            view.mouseleave(evt);\n            if (this.el.contains(relatedTarget)) {\n                // The pointer has exited a cellView. The pointer is still inside of the paper.\n                return;\n            }\n        }\n        if (relatedView) {\n            // The pointer has entered a new cellView\n            return;\n        }\n        // prevent double `mouseleave` event if the `relatedTarget` is outside the paper\n        // (mouseleave method would be fired twice)\n        if (currentTarget === this.el) {\n            // There is no cellView under the pointer, nor the blank area of the paper\n            this.trigger('paper:mouseleave', evt);\n        }\n    },\n\n    _processMouseWheelEvtBuf: (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.debounce)(function() {\n        const { event, deltas } = this._mw_evt_buffer;\n        const deltaY = deltas.reduce((acc, deltaY) => acc + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.cap)(deltaY, WHEEL_CAP), 0);\n\n        const scale = Math.pow(0.995, deltaY); // 1.005 for inverted pinch/zoom\n        const { x, y } = this.clientToLocalPoint(event.clientX, event.clientY);\n        this.trigger('paper:pinch', event, x, y, scale);\n\n        this._mw_evt_buffer = {\n            event: null,\n            deltas: [],\n        };\n    }, WHEEL_WAIT_MS, { maxWait: WHEEL_WAIT_MS }),\n\n    mousewheel: function(evt) {\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n\n        const view = this.findView(evt.target);\n        if (this.guard(evt, view)) return;\n\n        const originalEvent = evt.originalEvent;\n        const localPoint = this.snapToGrid(originalEvent.clientX, originalEvent.clientY);\n        const { deltaX, deltaY } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeWheel)(originalEvent);\n\n        const pinchHandlers = this._events['paper:pinch'];\n\n        // Touchpad devices will send a fake CTRL press when a pinch is performed\n        //\n        // We also check if there are any subscribers to paper:pinch event. If there are none,\n        // just skip the entire block of code (we don't want to blindly call\n        // .preventDefault() if we really don't have to).\n        if (evt.ctrlKey && pinchHandlers && pinchHandlers.length > 0) {\n            // This is a pinch gesture, it's safe to assume that we must call .preventDefault()\n            originalEvent.preventDefault();\n            this._mw_evt_buffer.event = evt;\n            this._mw_evt_buffer.deltas.push(deltaY);\n            this._processMouseWheelEvtBuf();\n        } else {\n            const delta = Math.max(-1, Math.min(1, originalEvent.wheelDelta));\n            if (view) {\n                view.mousewheel(evt, localPoint.x, localPoint.y, delta);\n\n            } else {\n                this.trigger('blank:mousewheel', evt, localPoint.x, localPoint.y, delta);\n            }\n\n            this.trigger('paper:pan', evt, deltaX, deltaY);\n        }\n    },\n\n    onevent: function(evt) {\n\n        var eventNode = evt.currentTarget;\n        var eventName = eventNode.getAttribute('event');\n        if (eventName) {\n            var view = this.findView(eventNode);\n            if (view) {\n\n                evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n                if (this.guard(evt, view)) return;\n\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                view.onevent(evt, eventName, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    magnetEvent: function(evt, handler) {\n\n        var magnetNode = evt.currentTarget;\n        var magnetValue = magnetNode.getAttribute('magnet');\n        if (magnetValue) {\n            var view = this.findView(magnetNode);\n            if (view) {\n                evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n                if (this.guard(evt, view)) return;\n                var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n                handler.call(this, view, evt, magnetNode, localPoint.x, localPoint.y);\n            }\n        }\n    },\n\n    onmagnet: function(evt) {\n\n        if (evt.button === 2) {\n            this.contextMenuFired = true;\n            this.magnetContextMenuFired = true;\n            const contextmenuEvt = new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, {\n                type: 'contextmenu',\n                data: evt.data,\n                currentTarget: evt.currentTarget,\n            });\n            this.magnetContextMenuTrigger(contextmenuEvt);\n            if (contextmenuEvt.isPropagationStopped()) {\n                evt.stopPropagation();\n            }\n        } else {\n            this.magnetEvent(evt, function(view, evt, _, x, y) {\n                view.onmagnet(evt, x, y);\n            });\n        }\n    },\n\n    magnetpointerdblclick: function(evt) {\n\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetpointerdblclick(evt, magnet, x, y);\n        });\n    },\n\n    magnetcontextmenu: function(evt) {\n        if (this.options.preventContextMenu) evt.preventDefault();\n\n        if (this.magnetContextMenuFired) {\n            this.magnetContextMenuFired = false;\n            return;\n        }\n\n        this.magnetContextMenuTrigger(evt);\n    },\n\n    magnetContextMenuTrigger: function(evt) {\n        this.magnetEvent(evt, function(view, evt, magnet, x, y) {\n            view.magnetcontextmenu(evt, magnet, x, y);\n        });\n    },\n\n    onlabel: function(evt) {\n\n        var labelNode = evt.currentTarget;\n\n        var view = this.findView(labelNode);\n        if (!view) return;\n\n        evt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n        if (this.guard(evt, view)) return;\n\n        // Custom event\n        const eventEvt = this.customEventTrigger(evt, view, labelNode);\n        if (eventEvt) {\n            // `onevent` could have stopped propagation\n            if (eventEvt.isPropagationStopped()) return;\n\n            evt.data = eventEvt.data;\n        }\n\n        var localPoint = this.snapToGrid(evt.clientX, evt.clientY);\n        view.onlabel(evt, localPoint.x, localPoint.y);\n    },\n\n    getPointerArgs(evt) {\n        const normalizedEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(evt);\n        const { x, y } = this.snapToGrid(normalizedEvt.clientX, normalizedEvt.clientY);\n        return [normalizedEvt, x, y];\n    },\n\n    delegateDragEvents: function(view, data) {\n\n        data || (data = {});\n        this.eventData({ data: data }, { sourceView: view || null, mousemoved: 0 });\n        this.delegateDocumentEvents(null, data);\n    },\n\n    // Guard the specified event. If the event should be ignored, guard returns `true`.\n    // Otherwise, it returns `false`.\n    guard: function(evt, view) {\n\n        if (evt.type === 'mousedown' && evt.button === 2) {\n            // handled as `contextmenu` type\n            return true;\n        }\n\n        if (this.options.guard && this.options.guard(evt, view)) {\n            return true;\n        }\n\n        if (evt.data && evt.data.guarded !== undefined) {\n            return evt.data.guarded;\n        }\n\n        const { target } = evt;\n\n        if (this.GUARDED_TAG_NAMES.includes(target.tagName)) {\n            return true;\n        }\n\n        if (view && view.model && (view.model instanceof _Cell_mjs__WEBPACK_IMPORTED_MODULE_18__.Cell)) {\n            return false;\n        }\n\n        if (this.el === target || this.svg.contains(target)) {\n            return false;\n        }\n\n        return true;    // Event guarded. Paper should not react on it in any way.\n    },\n\n    setGridSize: function(gridSize) {\n        const { options } = this;\n        options.gridSize = gridSize;\n        if (options.drawGrid && !options.drawGridSize) {\n            // Do not redraw the grid if the `drawGridSize` is set.\n            this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID).renderGrid();\n        }\n        return this;\n    },\n\n    setGrid: function(drawGrid) {\n        this.getLayerView(_PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames.GRID).setGrid(drawGrid);\n        return this;\n    },\n\n    updateBackgroundImage: function(opt) {\n\n        opt = opt || {};\n\n        var backgroundPosition = opt.position || 'center';\n        var backgroundSize = opt.size || 'auto auto';\n\n        var currentScale = this.scale();\n        var currentTranslate = this.translate();\n\n        // backgroundPosition\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(backgroundPosition)) {\n            var x = currentTranslate.tx + (currentScale.sx * (backgroundPosition.x || 0));\n            var y = currentTranslate.ty + (currentScale.sy * (backgroundPosition.y || 0));\n            backgroundPosition = x + 'px ' + y + 'px';\n        }\n\n        // backgroundSize\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(backgroundSize)) {\n            backgroundSize = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_14__.Rect(backgroundSize).scale(currentScale.sx, currentScale.sy);\n            backgroundSize = backgroundSize.width + 'px ' + backgroundSize.height + 'px';\n        }\n\n        const { background } = this.childNodes;\n        background.style.backgroundSize = backgroundSize;\n        background.style.backgroundPosition = backgroundPosition;\n    },\n\n    drawBackgroundImage: function(img, opt) {\n\n        // Clear the background image if no image provided\n        if (!(img instanceof HTMLImageElement)) {\n            this.childNodes.background.style.backgroundImage = '';\n            return;\n        }\n\n        if (!this._background || this._background.id !== opt.id) {\n            // Draw only the last image requested (see drawBackground())\n            return;\n        }\n\n        opt = opt || {};\n\n        var backgroundImage;\n        var backgroundSize = opt.size;\n        var backgroundRepeat = opt.repeat || 'no-repeat';\n        var backgroundOpacity = opt.opacity || 1;\n        var backgroundQuality = Math.abs(opt.quality) || 1;\n        var backgroundPattern = this.constructor.backgroundPatterns[(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.camelCase)(backgroundRepeat)];\n\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isFunction)(backgroundPattern)) {\n            // 'flip-x', 'flip-y', 'flip-xy', 'watermark' and custom\n            img.width *= backgroundQuality;\n            img.height *= backgroundQuality;\n            var canvas = backgroundPattern(img, opt);\n            if (!(canvas instanceof HTMLCanvasElement)) {\n                throw new Error('dia.Paper: background pattern must return an HTML Canvas instance');\n            }\n\n            backgroundImage = canvas.toDataURL('image/png');\n            backgroundRepeat = 'repeat';\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(backgroundSize)) {\n                // recalculate the tile size if an object passed in\n                backgroundSize.width *= canvas.width / img.width;\n                backgroundSize.height *= canvas.height / img.height;\n            } else if (backgroundSize === undefined) {\n                // calculate the tile size if no provided\n                opt.size = {\n                    width: canvas.width / backgroundQuality,\n                    height: canvas.height / backgroundQuality\n                };\n            }\n        } else {\n            // backgroundRepeat:\n            // no-repeat', 'round', 'space', 'repeat', 'repeat-x', 'repeat-y'\n            backgroundImage = img.src;\n            if (backgroundSize === undefined) {\n                // pass the image size for  the backgroundSize if no size provided\n                opt.size = {\n                    width: img.width,\n                    height: img.height\n                };\n            }\n        }\n\n        this.childNodes.background.style.opacity = backgroundOpacity;\n        this.childNodes.background.style.backgroundRepeat = backgroundRepeat;\n        this.childNodes.background.style.backgroundImage = `url(${backgroundImage})`;\n\n        this.updateBackgroundImage(opt);\n    },\n\n    updateBackgroundColor: function(color) {\n\n        this.$el.css('backgroundColor', color || '');\n    },\n\n    drawBackground: function(opt) {\n\n        opt = opt || {};\n\n        this.updateBackgroundColor(opt.color);\n\n        if (opt.image) {\n            opt = this._background = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.cloneDeep)(opt);\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.guid)(opt);\n            var img = document.createElement('img');\n            img.onload = this.drawBackgroundImage.bind(this, img, opt);\n            img.src = opt.image;\n        } else {\n            this.drawBackgroundImage(null);\n            this._background = null;\n        }\n\n        return this;\n    },\n\n    setInteractivity: function(value) {\n\n        this.options.interactive = value;\n\n        (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.invoke)(this._views, 'setInteractivity', value);\n    },\n\n    // Paper definitions.\n    // ------------------\n\n    isDefined: function(defId) {\n\n        return !!this.svg.getElementById(defId);\n    },\n\n    defineFilter: function(filter) {\n\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(filter)) {\n            throw new TypeError('dia.Paper: defineFilter() requires 1. argument to be an object.');\n        }\n\n        var filterId = filter.id;\n        var name = filter.name;\n        // Generate a hash code from the stringified filter definition. This gives us\n        // a unique filter ID for different definitions.\n        if (!filterId) {\n            filterId = name + this.svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(filter));\n        }\n        // If the filter already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        // If not, create one.\n        if (!this.isDefined(filterId)) {\n\n            var namespace = _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.filter;\n            var filterSVGString = namespace[name] && namespace[name](filter.args || {});\n            if (!filterSVGString) {\n                throw new Error('Non-existing filter ' + name);\n            }\n\n            // SVG <filter/> attributes\n            var filterAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.assign)({\n                filterUnits: 'userSpaceOnUse',\n            }, filter.attrs, {\n                id: filterId\n            });\n\n            (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(filterSVGString, filterAttrs).appendTo(this.defs);\n        }\n\n        return filterId;\n    },\n\n    defineGradient: function(gradient) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(gradient)) {\n            throw new TypeError('dia.Paper: defineGradient() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            type,\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = type + svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(gradient)),\n            stops,\n            attrs = {}\n        } = gradient;\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const stopVEls = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.toArray)(stops).map(({ offset, color, opacity }) => {\n            return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('stop').attr({\n                'offset': offset,\n                'stop-color': color,\n                'stop-opacity': Number.isFinite(opacity) ? opacity : 1\n            });\n        });\n        const gradientVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(type, attrs, stopVEls);\n        gradientVEl.id = id;\n        gradientVEl.appendTo(defs);\n        return id;\n    },\n\n    definePattern: function(pattern) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(pattern)) {\n            throw new TypeError('dia.Paper: definePattern() requires 1. argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(pattern)),\n            markup,\n            attrs = {}\n        } = pattern;\n        if (!markup) {\n            throw new TypeError('dia.Paper: definePattern() requires markup.');\n        }\n        // If the gradient already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const patternVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('pattern', {\n            patternUnits: 'userSpaceOnUse'\n        });\n        patternVEl.id = id;\n        patternVEl.attr(attrs);\n        if (typeof markup === 'string') {\n            patternVEl.append((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(markup));\n        } else {\n            const { fragment } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.parseDOMJSON)(markup);\n            patternVEl.append(fragment);\n        }\n        patternVEl.appendTo(defs);\n        return id;\n    },\n\n    defineMarker: function(marker) {\n        if (!(0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isObject)(marker)) {\n            throw new TypeError('dia.Paper: defineMarker() requires the first argument to be an object.');\n        }\n        const { svg, defs } = this;\n        const {\n            // Generate a hash code from the stringified filter definition. This gives us\n            // a unique filter ID for different definitions.\n            id = svg.id + (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.hashCode)(JSON.stringify(marker)),\n            // user-provided markup\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/markup`)\n            markup,\n            // user-provided attributes\n            // (e.g. defined when creating link via `attrs/line/sourceMarker/attrs`)\n            // note: `transform` attrs are ignored by browsers\n            attrs = {},\n            // deprecated - use `attrs/markerUnits` instead (which has higher priority)\n            markerUnits = 'userSpaceOnUse'\n        } = marker;\n        // If the marker already exists in the document,\n        // we're done and we can just use it (reference it using `url()`).\n        if (this.isDefined(id)) return id;\n        // If not, create one.\n        const markerVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('marker', {\n            orient: 'auto',\n            overflow: 'visible',\n            markerUnits: markerUnits\n        });\n        markerVEl.id = id;\n        markerVEl.attr(attrs);\n        let markerContentVEl;\n        if (markup) {\n            let markupVEl;\n            if (typeof markup === 'string') {\n                // Marker object has a `markup` property of type string.\n                // - Construct V from the provided string.\n                markupVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(markup);\n                // `markupVEl` is now either a single VEl, or an array of VEls.\n                // - Coerce it to an array.\n                markupVEl = (Array.isArray(markupVEl) ? markupVEl : [markupVEl]);\n            } else {\n                // Marker object has a `markup` property of type object.\n                // - Construct V from the object by parsing it as DOM JSON.\n                const { fragment } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.parseDOMJSON)(markup);\n                markupVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(fragment).children();\n            }\n            // `markupVEl` is an array with one or more VEls inside.\n            // - If there are multiple VEls, wrap them in a newly-constructed <g> element\n            if (markupVEl.length > 1) {\n                markerContentVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])('g').append(markupVEl);\n            } else {\n                markerContentVEl = markupVEl[0];\n            }\n        } else {\n            // Marker object is a flat structure.\n            // - Construct a new V of type `marker.type`.\n            const { type = 'path' } = marker;\n            markerContentVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(type);\n        }\n        // `markerContentVEl` is a single VEl.\n        // Assign additional attributes to it (= context attributes + marker attributes):\n        // - Attribute values are taken from non-special properties of `marker`.\n        const markerAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.omit)(marker, 'type', 'id', 'markup', 'attrs', 'markerUnits');\n        const markerAttrsKeys = Object.keys(markerAttrs);\n        markerAttrsKeys.forEach((key) => {\n            const value = markerAttrs[key];\n            const markupValue = markerContentVEl.attr(key); // value coming from markupVEl (if any) = higher priority\n            if (markupValue == null) {\n                // Default logic:\n                markerContentVEl.attr(key, value);\n            } else {\n                // Properties with special logic should be added as cases to this switch block:\n                switch(key) {\n                    case 'transform':\n                        // - Prepend `transform` to existing value.\n                        markerContentVEl.attr(key, (value + ' ' + markupValue));\n                        break;\n                }\n            }\n        });\n        markerContentVEl.appendTo(markerVEl);\n        markerVEl.appendTo(defs);\n        return id;\n    },\n\n    customEventTrigger: function(evt, view, rootNode = view.el) {\n\n        const eventNode = evt.target.closest('[event]');\n\n        if (eventNode && rootNode !== eventNode && view.el.contains(eventNode)) {\n            const eventEvt = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent)(new _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_17__[\"default\"].Event(evt.originalEvent, {\n                data: evt.data,\n                // Originally the event listener was attached to the event element.\n                currentTarget: eventNode\n            }));\n\n            this.onevent(eventEvt);\n\n            if (eventEvt.isDefaultPrevented()) {\n                evt.preventDefault();\n            }\n\n            return eventEvt;\n        }\n\n        return null;\n    }\n\n}, {\n\n    sorting: sortingTypes,\n\n    Layers: _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_1__.LayersNames,\n\n    backgroundPatterns: {\n\n        flipXy: function(img) {\n            // d b\n            // q p\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = 2 * imgWidth;\n            canvas.height = 2 * imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // top-left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // xy-flipped bottom-right image\n            ctx.setTransform(-1, 0, 0, -1, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // x-flipped top-right image\n            ctx.setTransform(-1, 0, 0, 1, canvas.width, 0);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // y-flipped bottom-left image\n            ctx.setTransform(1, 0, 0, -1, 0, canvas.height);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipX: function(img) {\n            // d b\n            // d b\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth * 2;\n            canvas.height = imgHeight;\n\n            var ctx = canvas.getContext('2d');\n            // left image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped right image\n            ctx.translate(2 * imgWidth, 0);\n            ctx.scale(-1, 1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        flipY: function(img) {\n            // d d\n            // q q\n\n            var canvas = document.createElement('canvas');\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            canvas.width = imgWidth;\n            canvas.height = imgHeight * 2;\n\n            var ctx = canvas.getContext('2d');\n            // top image\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n            // flipped bottom image\n            ctx.translate(0, 2 * imgHeight);\n            ctx.scale(1, -1);\n            ctx.drawImage(img, 0, 0, imgWidth, imgHeight);\n\n            return canvas;\n        },\n\n        watermark: function(img, opt) {\n            //   d\n            // d\n\n            opt = opt || {};\n\n            var imgWidth = img.width;\n            var imgHeight = img.height;\n\n            var canvas = document.createElement('canvas');\n            canvas.width = imgWidth * 3;\n            canvas.height = imgHeight * 3;\n\n            var ctx = canvas.getContext('2d');\n            var angle = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_10__.isNumber)(opt.watermarkAngle) ? -opt.watermarkAngle : -20;\n            var radians = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_19__.toRad)(angle);\n            var stepX = canvas.width / 4;\n            var stepY = canvas.height / 4;\n\n            for (var i = 0; i < 4; i++) {\n                for (var j = 0; j < 4; j++) {\n                    if ((i + j) % 2 > 0) {\n                        // reset the current transformations\n                        ctx.setTransform(1, 0, 0, 1, (2 * i - 1) * stepX, (2 * j - 1) * stepY);\n                        ctx.rotate(radians);\n                        ctx.drawImage(img, -imgWidth / 2, -imgHeight / 2, imgWidth, imgHeight);\n                    }\n                }\n            }\n\n            return canvas;\n        }\n    },\n\n    gridPatterns: {\n        dot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({\n                    width: opt.thickness,\n                    height: opt.thickness,\n                    fill: opt.color\n                });\n            }\n        }],\n        fixedDot: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'rect',\n            render: function(el, opt) {\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ fill: opt.color });\n            },\n            update: function(el, opt, paper) {\n                const { sx, sy } = paper.scale();\n                const width = sx <= 1 ? opt.thickness : opt.thickness / sx;\n                const height = sy <= 1 ? opt.thickness : opt.thickness / sy;\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ width, height });\n            }\n        }],\n        mesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }],\n        doubleMesh: [{\n            color: '#AAAAAA',\n            thickness: 1,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }, {\n            color: '#000000',\n            thickness: 3,\n            scaleFactor: 4,\n            markup: 'path',\n            render: function(el, opt) {\n\n                var d;\n                var width = opt.width;\n                var height = opt.height;\n                var thickness = opt.thickness;\n\n                if (width - thickness >= 0 && height - thickness >= 0) {\n                    d = ['M', width, 0, 'H0 M0 0 V0', height].join(' ');\n                } else {\n                    d = 'M 0 0 0 0';\n                }\n\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(el).attr({ 'd': d, stroke: opt.color, 'stroke-width': opt.thickness });\n            }\n        }]\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL1BhcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUErQko7QUFDb0I7QUFDSztBQUNMO0FBQ0w7QUFDTTtBQUNOO0FBQ1I7QUFDRTtBQUN1QjtBQUNEO0FBQ0Y7QUFDVTtBQUNsQjs7QUFFWDtBQUNjOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QywwQkFBMEIsbURBQVE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx3REFBVztBQUNyQixDQUFDO0FBQ0QsVUFBVSx3REFBVztBQUNyQixDQUFDO0FBQ0QsVUFBVSx3REFBVztBQUNyQixDQUFDO0FBQ0QsVUFBVSx3REFBVztBQUNyQixDQUFDO0FBQ0QsVUFBVSx3REFBVztBQUNyQixDQUFDO0FBQ0QsVUFBVSx3REFBVztBQUNyQixDQUFDOztBQUVNLGNBQWMsZ0RBQUk7O0FBRXpCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQSxxQkFBcUIseURBQVc7QUFDaEMsa0JBQWtCLG1EQUFRO0FBQzFCO0FBQ0EsNENBQTRDO0FBQzVDLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LFlBQVksMERBQTBEO0FBQ3ZGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLGdCQUFnQix5REFBQyxZQUFZLDBEQUEwRDtBQUN2RjtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvUGFwZXIubWpzPzcyZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0IHtcbiAgICBpc051bWJlcixcbiAgICBhc3NpZ24sXG4gICAgbmV4dEZyYW1lLFxuICAgIGlzT2JqZWN0LFxuICAgIGNhbmNlbEZyYW1lLFxuICAgIGRlZmF1bHRzLFxuICAgIGRlZmF1bHRzRGVlcCxcbiAgICBhZGRDbGFzc05hbWVQcmVmaXgsXG4gICAgbm9ybWFsaXplU2lkZXMsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1BsYWluT2JqZWN0LFxuICAgIGdldEJ5UGF0aCxcbiAgICBzb3J0RWxlbWVudHMsXG4gICAgaXNTdHJpbmcsXG4gICAgZ3VpZCxcbiAgICBub3JtYWxpemVFdmVudCxcbiAgICBub3JtYWxpemVXaGVlbCxcbiAgICBjYXAsXG4gICAgZGVib3VuY2UsXG4gICAgb21pdCxcbiAgICByZXN1bHQsXG4gICAgY2FtZWxDYXNlLFxuICAgIGNsb25lRGVlcCxcbiAgICBpbnZva2UsXG4gICAgaGFzaENvZGUsXG4gICAgZmlsdGVyIGFzIF9maWx0ZXIsXG4gICAgcGFyc2VET01KU09OLFxuICAgIHRvQXJyYXksXG4gICAgaGFzXG59IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IFZpZXdCYXNlIH0gZnJvbSAnLi4vbXZjL1ZpZXdCYXNlLm1qcyc7XG5pbXBvcnQgeyBSZWN0LCBQb2ludCwgdG9SYWQgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBWaWV3LCB2aWV3cyB9IGZyb20gJy4uL212Yy9pbmRleC5tanMnO1xuaW1wb3J0IHsgQ2VsbFZpZXcgfSBmcm9tICcuL0NlbGxWaWV3Lm1qcyc7XG5pbXBvcnQgeyBFbGVtZW50VmlldyB9IGZyb20gJy4vRWxlbWVudFZpZXcubWpzJztcbmltcG9ydCB7IExpbmtWaWV3IH0gZnJvbSAnLi9MaW5rVmlldy5tanMnO1xuaW1wb3J0IHsgQ2VsbCB9IGZyb20gJy4vQ2VsbC5tanMnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICcuL0dyYXBoLm1qcyc7XG5pbXBvcnQgeyBMYXllcnNOYW1lcywgUGFwZXJMYXllciB9IGZyb20gJy4vUGFwZXJMYXllci5tanMnO1xuaW1wb3J0ICogYXMgaGlnaGxpZ2h0ZXJzIGZyb20gJy4uL2hpZ2hsaWdodGVycy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgbGlua0FuY2hvcnMgZnJvbSAnLi4vbGlua0FuY2hvcnMvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGNvbm5lY3Rpb25Qb2ludHMgZnJvbSAnLi4vY29ubmVjdGlvblBvaW50cy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgYW5jaG9ycyBmcm9tICcuLi9hbmNob3JzL2luZGV4Lm1qcyc7XG5cbmltcG9ydCAkIGZyb20gJy4uL212Yy9Eb20vaW5kZXgubWpzJztcbmltcG9ydCB7IEdyaWRMYXllciB9IGZyb20gJy4vbGF5ZXJzL0dyaWRMYXllci5tanMnO1xuXG5jb25zdCBzb3J0aW5nVHlwZXMgPSB7XG4gICAgTk9ORTogJ3NvcnRpbmctbm9uZScsXG4gICAgQVBQUk9YOiAnc29ydGluZy1hcHByb3hpbWF0ZScsXG4gICAgRVhBQ1Q6ICdzb3J0aW5nLWV4YWN0J1xufTtcblxuY29uc3QgV0hFRUxfQ0FQID0gNTA7XG5jb25zdCBXSEVFTF9XQUlUX01TID0gMjA7XG5jb25zdCBNT1VOVF9CQVRDSF9TSVpFID0gMTAwMDtcbmNvbnN0IFVQREFURV9CQVRDSF9TSVpFID0gSW5maW5pdHk7XG5jb25zdCBNSU5fUFJJT1JJVFkgPSA5MDA3MTk5MjU0NzQwOTkxOyAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuXG5jb25zdCBIaWdobGlnaHRpbmdUeXBlcyA9IENlbGxWaWV3LkhpZ2hsaWdodGluZztcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodGluZyA9IHtcbiAgICBbSGlnaGxpZ2h0aW5nVHlwZXMuREVGQVVMVF06IHtcbiAgICAgICAgbmFtZTogJ3N0cm9rZScsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDNcbiAgICAgICAgfVxuICAgIH0sXG4gICAgW0hpZ2hsaWdodGluZ1R5cGVzLk1BR05FVF9BVkFJTEFCSUxJVFldOiB7XG4gICAgICAgIG5hbWU6ICdhZGRDbGFzcycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2F2YWlsYWJsZS1tYWduZXQnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFtIaWdobGlnaHRpbmdUeXBlcy5FTEVNRU5UX0FWQUlMQUJJTElUWV06IHtcbiAgICAgICAgbmFtZTogJ2FkZENsYXNzJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYXZhaWxhYmxlLWNlbGwnXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCBkZWZhdWx0TGF5ZXJzID0gW3tcbiAgICBuYW1lOiBMYXllcnNOYW1lcy5HUklELFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLkJBQ0ssXG59LCB7XG4gICAgbmFtZTogTGF5ZXJzTmFtZXMuQ0VMTFMsXG59LCB7XG4gICAgbmFtZTogTGF5ZXJzTmFtZXMuTEFCRUxTLFxufSwge1xuICAgIG5hbWU6IExheWVyc05hbWVzLkZST05UXG59LCB7XG4gICAgbmFtZTogTGF5ZXJzTmFtZXMuVE9PTFNcbn1dO1xuXG5leHBvcnQgY29uc3QgUGFwZXIgPSBWaWV3LmV4dGVuZCh7XG5cbiAgICBjbGFzc05hbWU6ICdwYXBlcicsXG5cbiAgICBvcHRpb25zOiB7XG5cbiAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgaGVpZ2h0OiA2MDAsXG4gICAgICAgIGdyaWRTaXplOiAxLFxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBkcmF3IHRoZSBncmlkIGxpbmVzIG9uIHRoZSBwYXBlcidzIERPTSBlbGVtZW50LlxuICAgICAgICAvLyBlLmcgZHJhd0dyaWQ6IHRydWUsIGRyYXdHcmlkOiB7IGNvbG9yOiAncmVkJywgdGhpY2tuZXNzOiAyIH1cbiAgICAgICAgZHJhd0dyaWQ6IGZhbHNlLFxuICAgICAgICAvLyBJZiBub3Qgc2V0LCB0aGUgc2l6ZSBvZiB0aGUgdmlzdWFsIGdyaWQgaXMgdGhlIHNhbWUgYXMgdGhlIGBncmlkU2l6ZWAuXG4gICAgICAgIGRyYXdHcmlkU2l6ZTogbnVsbCxcblxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0byBkcmF3IHRoZSBiYWNrZ3JvdW5kIG9uIHRoZSBwYXBlcidzIERPTSBlbGVtZW50LlxuICAgICAgICAvLyBlLmcuIGJhY2tncm91bmQ6IHsgY29sb3I6ICdsaWdodGJsdWUnLCBpbWFnZTogJy9wYXBlci1iYWNrZ3JvdW5kLnBuZycsIHJlcGVhdDogJ2ZsaXAteHknIH1cbiAgICAgICAgYmFja2dyb3VuZDogZmFsc2UsXG5cbiAgICAgICAgZWxlbWVudFZpZXc6IEVsZW1lbnRWaWV3LFxuICAgICAgICBsaW5rVmlldzogTGlua1ZpZXcsXG4gICAgICAgIHNuYXBMYWJlbHM6IGZhbHNlLCAvLyBmYWxzZSwgdHJ1ZVxuICAgICAgICBzbmFwTGlua3M6IGZhbHNlLCAvLyBmYWxzZSwgdHJ1ZSwgeyByYWRpdXM6IHZhbHVlIH1cbiAgICAgICAgc25hcExpbmtzU2VsZjogZmFsc2UsIC8vIGZhbHNlLCB0cnVlLCB7IHJhZGl1czogdmFsdWUgfVxuXG4gICAgICAgIC8vIFNob3VsZCB0aGUgbGluayBsYWJlbHMgYmUgcmVuZGVyZWQgaW50byBpdHMgb3duIGxheWVyP1xuICAgICAgICAvLyBgZmFsc2VgIC0gdGhlIGxhYmVscyBhcmUgcGFydCBvZiB0aGUgbGlua3NcbiAgICAgICAgLy8gYHRydWVgIC0gdGhlIGxhYmVscyBhcmUgYXBwZW5kZWQgdG8gTGF5ZXJzTmFtZS5MQUJFTFNcbiAgICAgICAgLy8gW0xheWVyc05hbWVdIC0gdGhlIGxhYmVscyBhcmUgYXBwZW5kZWQgdG8gdGhlIGxheWVyIHNwZWNpZmllZFxuICAgICAgICBsYWJlbHNMYXllcjogZmFsc2UsXG5cbiAgICAgICAgLy8gV2hlbiBzZXQgdG8gRkFMU0UsIGFuIGVsZW1lbnQgbWF5IG5vdCBoYXZlIG1vcmUgdGhhbiAxIGxpbmsgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50LlxuICAgICAgICBtdWx0aUxpbmtzOiB0cnVlLFxuXG4gICAgICAgIC8vIEZvciBhZGRpbmcgY3VzdG9tIGd1YXJkIGxvZ2ljLlxuICAgICAgICBndWFyZDogZnVuY3Rpb24oZXZ0LCB2aWV3KSB7XG5cbiAgICAgICAgICAgIC8vIEZBTFNFIG1lYW5zIHRoZSBldmVudCBpc24ndCBndWFyZGVkLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZ2hsaWdodGluZzogZGVmYXVsdEhpZ2hsaWdodGluZyxcblxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGNvbnRleHQgbWVudSBmcm9tIGJlaW5nIGRpc3BsYXllZC5cbiAgICAgICAgcHJldmVudENvbnRleHRNZW51OiB0cnVlLFxuXG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBibGFuazpwb2ludGVyPGFjdGlvbj4uXG4gICAgICAgIHByZXZlbnREZWZhdWx0QmxhbmtBY3Rpb246IHRydWUsXG5cbiAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIGNlbGw6cG9pbnRlcjxhY3Rpb24+LlxuICAgICAgICBwcmV2ZW50RGVmYXVsdFZpZXdBY3Rpb246IHRydWUsXG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIHRyYW5zbGF0aW9uIG9mIGVsZW1lbnRzIGJ5IGdpdmVuIGJvdW5kaW5nIGJveC5cbiAgICAgICAgLy8gT3B0aW9uIGFjY2VwdHMgYSBib29sZWFuOlxuICAgICAgICAvLyAgdHJ1ZSAtIHRoZSB0cmFuc2xhdGlvbiBpcyByZXN0cmljdGVkIHRvIHRoZSBwYXBlciBhcmVhXG4gICAgICAgIC8vICBmYWxzZSAtIG5vIHJlc3RyaWN0aW9uc1xuICAgICAgICAvLyBBIG1ldGhvZDpcbiAgICAgICAgLy8gcmVzdHJpY3RUcmFuc2xhdGU6IGZ1bmN0aW9uKGVsZW1lbnRWaWV3KSB7XG4gICAgICAgIC8vICAgICB2YXIgcGFyZW50SWQgPSBlbGVtZW50Vmlldy5tb2RlbC5nZXQoJ3BhcmVudCcpO1xuICAgICAgICAvLyAgICAgcmV0dXJuIHBhcmVudElkICYmIHRoaXMubW9kZWwuZ2V0Q2VsbChwYXJlbnRJZCkuZ2V0QkJveCgpO1xuICAgICAgICAvLyB9LFxuICAgICAgICAvLyBPciBhIGJvdW5kaW5nIGJveDpcbiAgICAgICAgLy8gcmVzdHJpY3RUcmFuc2xhdGU6IHsgeDogMTAsIHk6IDEwLCB3aWR0aDogNzkwLCBoZWlnaHQ6IDU5MCB9XG4gICAgICAgIHJlc3RyaWN0VHJhbnNsYXRlOiBmYWxzZSxcblxuICAgICAgICAvLyBNYXJrcyBhbGwgYXZhaWxhYmxlIG1hZ25ldHMgd2l0aCAnYXZhaWxhYmxlLW1hZ25ldCcgY2xhc3MgbmFtZSBhbmQgYWxsIGF2YWlsYWJsZSBjZWxscyB3aXRoXG4gICAgICAgIC8vICdhdmFpbGFibGUtY2VsbCcgY2xhc3MgbmFtZS4gTWFya3MgdGhlbSB3aGVuIGRyYWdnaW5nIGEgbGluayBpcyBzdGFydGVkIGFuZCB1bm1hcmtcbiAgICAgICAgLy8gd2hlbiB0aGUgZHJhZ2dpbmcgaXMgc3RvcHBlZC5cbiAgICAgICAgbWFya0F2YWlsYWJsZTogZmFsc2UsXG5cbiAgICAgICAgLy8gRGVmaW5lcyB3aGF0IGxpbmsgbW9kZWwgaXMgYWRkZWQgdG8gdGhlIGdyYXBoIGFmdGVyIGFuIHVzZXIgY2xpY2tzIG9uIGFuIGFjdGl2ZSBtYWduZXQuXG4gICAgICAgIC8vIFZhbHVlIGNvdWxkIGJlIHRoZSBtdmMubW9kZWwgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG12Yy5tb2RlbFxuICAgICAgICAvLyBkZWZhdWx0TGluazogKGVsZW1lbnRWaWV3LCBtYWduZXQpID0+IHtcbiAgICAgICAgLy8gICByZXR1cm4gY29uZGl0aW9uID8gbmV3IGN1c3RvbUxpbmsxKCkgOiBuZXcgY3VzdG9tTGluazIoKVxuICAgICAgICAvLyB9XG4gICAgICAgIGRlZmF1bHRMaW5rOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgaGFyZCBkZXBlbmRlbmN5IG9uIHRoZSBqb2ludC5zaGFwZXMuc3RhbmRhcmQgbmFtZXNwYWNlIChieSBpbXBvcnRpbmcgdGhlIHN0YW5kYXJkLkxpbmsgbW9kZWwgZGlyZWN0bHkpXG4gICAgICAgICAgICBjb25zdCB7IGNlbGxOYW1lc3BhY2UgfSA9IHRoaXMubW9kZWwuZ2V0KCdjZWxscycpO1xuICAgICAgICAgICAgY29uc3QgY3RvciA9IGdldEJ5UGF0aChjZWxsTmFtZXNwYWNlLCBbJ3N0YW5kYXJkJywgJ0xpbmsnXSk7XG4gICAgICAgICAgICBpZiAoIWN0b3IpIHRocm93IG5ldyBFcnJvcignZGlhLlBhcGVyOiBubyBkZWZhdWx0IGxpbmsgbW9kZWwgZm91bmQuIFVzZSBgb3B0aW9ucy5kZWZhdWx0TGlua2AgdG8gc3BlY2lmeSBhIGRlZmF1bHQgbGluayBtb2RlbC4nKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY3RvcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEEgY29ubmVjdG9yIHRoYXQgaXMgdXNlZCBieSBsaW5rcyB3aXRoIG5vIGNvbm5lY3RvciBkZWZpbmVkIG9uIHRoZSBtb2RlbC5cbiAgICAgICAgLy8gZS5nLiB7IG5hbWU6ICdyb3VuZGVkJywgYXJnczogeyByYWRpdXM6IDUgfX0gb3IgYSBmdW5jdGlvblxuICAgICAgICBkZWZhdWx0Q29ubmVjdG9yOiB7IG5hbWU6ICdub3JtYWwnIH0sXG5cbiAgICAgICAgLy8gQSByb3V0ZXIgdGhhdCBpcyB1c2VkIGJ5IGxpbmtzIHdpdGggbm8gcm91dGVyIGRlZmluZWQgb24gdGhlIG1vZGVsLlxuICAgICAgICAvLyBlLmcuIHsgbmFtZTogJ29uZVNpZGUnLCBhcmdzOiB7IHBhZGRpbmc6IDEwIH19IG9yIGEgZnVuY3Rpb25cbiAgICAgICAgZGVmYXVsdFJvdXRlcjogeyBuYW1lOiAnbm9ybWFsJyB9LFxuXG4gICAgICAgIGRlZmF1bHRBbmNob3I6IHsgbmFtZTogJ2NlbnRlcicgfSxcblxuICAgICAgICBkZWZhdWx0TGlua0FuY2hvcjogeyBuYW1lOiAnY29ubmVjdGlvblJhdGlvJyB9LFxuXG4gICAgICAgIGRlZmF1bHRDb25uZWN0aW9uUG9pbnQ6IHsgbmFtZTogJ2JvdW5kYXJ5JyB9LFxuXG4gICAgICAgIC8qIENPTk5FQ1RJTkcgKi9cblxuICAgICAgICBjb25uZWN0aW9uU3RyYXRlZ3k6IG51bGwsXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byBhZGQgYSBuZXcgbGluayB0byB0aGUgZ3JhcGggd2hlbiB1c2VyIGNsaWNrcyBvbiBhbiBhIG1hZ25ldC5cbiAgICAgICAgdmFsaWRhdGVNYWduZXQ6IGZ1bmN0aW9uKF9jZWxsVmlldywgbWFnbmV0LCBfZXZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFnbmV0LmdldEF0dHJpYnV0ZSgnbWFnbmV0JykgIT09ICdwYXNzaXZlJztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRvIGFsbG93IG9yIGRpc2FsbG93IHRoZSBsaW5rIGNvbm5lY3Rpb24gd2hpbGUgYW4gYXJyb3doZWFkIGVuZCAoc291cmNlL3RhcmdldClcbiAgICAgICAgLy8gYmVpbmcgY2hhbmdlZC5cbiAgICAgICAgdmFsaWRhdGVDb25uZWN0aW9uOiBmdW5jdGlvbihjZWxsVmlld1MsIF9tYWduZXRTLCBjZWxsVmlld1QsIF9tYWduZXRULCBlbmQsIF9saW5rVmlldykge1xuICAgICAgICAgICAgcmV0dXJuIChlbmQgPT09ICd0YXJnZXQnID8gY2VsbFZpZXdUIDogY2VsbFZpZXdTKSBpbnN0YW5jZW9mIEVsZW1lbnRWaWV3O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIEVNQkVERElORyAqL1xuXG4gICAgICAgIC8vIEVuYWJsZXMgZW1iZWRkaW5nLiBSZS1wYXJlbnQgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoIGVsZW1lbnRzIHVuZGVyIGl0IGFuZCBtYWtlcyBzdXJlIHRoYXRcbiAgICAgICAgLy8gYWxsIGxpbmtzIGFuZCBlbGVtZW50cyBhcmUgdmlzaWJsZSB0YWtlbiB0aGUgbGV2ZWwgb2YgZW1iZWRkaW5nIGludG8gYWNjb3VudC5cbiAgICAgICAgZW1iZWRkaW5nTW9kZTogZmFsc2UsXG5cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0byBhbGxvdyBvciBkaXNhbGxvdyB0aGUgZWxlbWVudCBlbWJlZGRpbmcgd2hpbGUgYW4gZWxlbWVudCBiZWluZyB0cmFuc2xhdGVkLlxuICAgICAgICB2YWxpZGF0ZUVtYmVkZGluZzogZnVuY3Rpb24oY2hpbGRWaWV3LCBwYXJlbnRWaWV3KSB7XG4gICAgICAgICAgICAvLyBieSBkZWZhdWx0IGFsbCBlbGVtZW50cyBjYW4gYmUgaW4gcmVsYXRpb24gY2hpbGQtcGFyZW50XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRvIGFsbG93IG9yIGRpc2FsbG93IGFuIGVtYmVkZGVkIGVsZW1lbnQgdG8gYmUgdW5lbWJlZGRlZCAvIHRvIGJlY29tZSBhIHJvb3QuXG4gICAgICAgIHZhbGlkYXRlVW5lbWJlZGRpbmc6IGZ1bmN0aW9uKGNoaWxkVmlldykge1xuICAgICAgICAgICAgLy8gYnkgZGVmYXVsdCBhbGwgZWxlbWVudHMgY2FuIGJlY29tZSByb290c1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyB0aGUgd2F5IGhvdyBhIGNlbGwgZmluZHMgYSBzdWl0YWJsZSBwYXJlbnQgd2hlbiBpdCdzIGRyYWdnZWQgb3ZlciB0aGUgcGFwZXIuXG4gICAgICAgIC8vIFRoZSBjZWxsIHdpdGggdGhlIGhpZ2hlc3Qgei1pbmRleCAodmlzdWFsbHkgb24gdGhlIHRvcCkgd2lsbCBiZSBjaG9zZW4uXG4gICAgICAgIGZpbmRQYXJlbnRCeTogJ2Jib3gnLCAvLyAnYmJveCd8J2NlbnRlcid8J29yaWdpbid8J2Nvcm5lcid8J3RvcFJpZ2h0J3wnYm90dG9tTGVmdCdcblxuICAgICAgICAvLyBJZiBlbmFibGVkIG9ubHkgdGhlIGVsZW1lbnQgb24gdGhlIHZlcnkgZnJvbnQgaXMgdGFrZW4gaW50byBhY2NvdW50IGZvciB0aGUgZW1iZWRkaW5nLlxuICAgICAgICAvLyBJZiBkaXNhYmxlZCB0aGUgZWxlbWVudHMgdW5kZXIgdGhlIGRyYWdnZWQgdmlldyBhcmUgdGVzdGVkIG9uZSBieSBvbmVcbiAgICAgICAgLy8gKGZyb20gZnJvbnQgdG8gYmFjaykgdW50aWwgYSB2YWxpZCBwYXJlbnQgZm91bmQuXG4gICAgICAgIGZyb250UGFyZW50T25seTogdHJ1ZSxcblxuICAgICAgICAvLyBJbnRlcmFjdGl2ZSBmbGFncy4gU2VlIG9ubGluZSBkb2NzIGZvciB0aGUgY29tcGxldGUgbGlzdCBvZiBpbnRlcmFjdGl2ZSBmbGFncy5cbiAgICAgICAgaW50ZXJhY3RpdmU6IHtcbiAgICAgICAgICAgIGxhYmVsTW92ZTogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBXaGVuIHNldCB0byB0cnVlIHRoZSBsaW5rcyBjYW4gYmUgcGlubmVkIHRvIHRoZSBwYXBlci5cbiAgICAgICAgLy8gaS5lLiBsaW5rIHNvdXJjZS90YXJnZXQgY2FuIGJlIGEgcG9pbnQgZS5nLiBsaW5rLmdldCgnc291cmNlJykgPT0+IHsgeDogMTAwLCB5OiAxMDAgfTtcbiAgICAgICAgbGlua1Bpbm5pbmc6IHRydWUsXG5cbiAgICAgICAgLy8gQ3VzdG9tIHZhbGlkYXRpb24gYWZ0ZXIgYW4gaW50ZXJhY3Rpb24gd2l0aCBhIGxpbmsgZW5kcy5cbiAgICAgICAgLy8gUmVjb2duaXplcyBhIGZ1bmN0aW9uLiBJZiBgZmFsc2VgIGlzIHJldHVybmVkLCB0aGUgbGluayBpcyBkaXNhbGxvd2VkIChyZW1vdmVkIG9yIHJldmVydGVkKVxuICAgICAgICAvLyAobGlua1ZpZXcsIHBhcGVyKSA9PiBib29sZWFuXG4gICAgICAgIGFsbG93TGluazogbnVsbCxcblxuICAgICAgICAvLyBBbGxvd2VkIG51bWJlciBvZiBtb3VzZW1vdmUgZXZlbnRzIGFmdGVyIHdoaWNoIHRoZSBwb2ludGVyY2xpY2sgZXZlbnQgd2lsbCBiZSBzdGlsbCB0cmlnZ2VyZWQuXG4gICAgICAgIGNsaWNrVGhyZXNob2xkOiAwLFxuXG4gICAgICAgIC8vIE51bWJlciBvZiByZXF1aXJlZCBtb3VzZW1vdmUgZXZlbnRzIGJlZm9yZSB0aGUgZmlyc3QgcG9pbnRlcm1vdmUgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG4gICAgICAgIG1vdmVUaHJlc2hvbGQ6IDAsXG5cbiAgICAgICAgLy8gTnVtYmVyIG9mIHJlcXVpcmVkIG1vdXNlbW92ZSBldmVudHMgYmVmb3JlIGEgbGluayBpcyBjcmVhdGVkIG91dCBvZiB0aGUgbWFnbmV0LlxuICAgICAgICAvLyBPciBzdHJpbmcgYG9ubGVhdmVgIHNvIHRoZSBsaW5rIGlzIGNyZWF0ZWQgd2hlbiB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIG1hZ25ldFxuICAgICAgICBtYWduZXRUaHJlc2hvbGQ6IDAsXG5cbiAgICAgICAgLy8gUmVuZGVyaW5nIE9wdGlvbnNcblxuICAgICAgICBzb3J0aW5nOiBzb3J0aW5nVHlwZXMuQVBQUk9YLFxuXG4gICAgICAgIGZyb3plbjogZmFsc2UsXG5cbiAgICAgICAgYXV0b0ZyZWV6ZTogZmFsc2UsXG5cbiAgICAgICAgLy8gbm8gZG9jcyB5ZXRcbiAgICAgICAgb25WaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCBmbGFnLCBwcmlvcml0eSwgb3B0LCBwYXBlcikge1xuICAgICAgICAgICAgLy8gRG8gbm90IHVwZGF0ZSBjb25uZWN0ZWQgbGlua3Mgd2hlbjpcbiAgICAgICAgICAgIC8vIDEuIHRoZSB2aWV3IHdhcyBqdXN0IGluc2VydGVkIChhZGRlZCB0byB0aGUgZ3JhcGggYW5kIHJlbmRlcmVkKVxuICAgICAgICAgICAgLy8gMi4gdGhlIHZpZXcgd2FzIGp1c3QgbW91bnRlZCAoYWRkZWQgYmFjayB0byB0aGUgcGFwZXIgYnkgdmlld3BvcnQgZnVuY3Rpb24pXG4gICAgICAgICAgICAvLyAzLiB0aGUgY2hhbmdlIHdhcyBtYXJrZWQgYXMgYGlzb2xhdGVgLlxuICAgICAgICAgICAgLy8gNC4gdGhlIHZpZXcgbW9kZWwgd2FzIGp1c3QgcmVtb3ZlZCBmcm9tIHRoZSBncmFwaFxuICAgICAgICAgICAgaWYgKChmbGFnICYgKHZpZXcuRkxBR19JTlNFUlQgfCB2aWV3LkZMQUdfUkVNT1ZFKSkgfHwgb3B0Lm1vdW50aW5nIHx8IG9wdC5pc29sYXRlKSByZXR1cm47XG4gICAgICAgICAgICBwYXBlci5yZXF1ZXN0Q29ubmVjdGVkTGlua3NVcGRhdGUodmlldywgcHJpb3JpdHksIG9wdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbm8gZG9jcyB5ZXRcbiAgICAgICAgb25WaWV3UG9zdHBvbmVkOiBmdW5jdGlvbih2aWV3LCBmbGFnLCBwYXBlcikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcGVyLmZvcmNlUG9zdHBvbmVkVmlld1VwZGF0ZSh2aWV3LCBmbGFnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBiZWZvcmVSZW5kZXI6IG51bGwsIC8vIGZ1bmN0aW9uKG9wdCwgcGFwZXIpIHsgfSxcblxuICAgICAgICBhZnRlclJlbmRlcjogbnVsbCwgLy8gZnVuY3Rpb24oc3RhdHMsIG9wdCwgcGFwZXIpIHtcblxuICAgICAgICB2aWV3cG9ydDogbnVsbCxcblxuICAgICAgICAvLyBEZWZhdWx0IG5hbWVzcGFjZXNcblxuICAgICAgICBjZWxsVmlld05hbWVzcGFjZTogbnVsbCxcblxuICAgICAgICByb3V0ZXJOYW1lc3BhY2U6IG51bGwsXG5cbiAgICAgICAgY29ubmVjdG9yTmFtZXNwYWNlOiBudWxsLFxuXG4gICAgICAgIGhpZ2hsaWdodGVyTmFtZXNwYWNlOiBoaWdobGlnaHRlcnMsXG5cbiAgICAgICAgYW5jaG9yTmFtZXNwYWNlOiBhbmNob3JzLFxuXG4gICAgICAgIGxpbmtBbmNob3JOYW1lc3BhY2U6IGxpbmtBbmNob3JzLFxuXG4gICAgICAgIGNvbm5lY3Rpb25Qb2ludE5hbWVzcGFjZTogY29ubmVjdGlvblBvaW50cyxcblxuICAgICAgICBvdmVyZmxvdzogZmFsc2VcbiAgICB9LFxuXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdkYmxjbGljayc6ICdwb2ludGVyZGJsY2xpY2snLFxuICAgICAgICAnZGJsdGFwJzogJ3BvaW50ZXJkYmxjbGljaycsXG4gICAgICAgICdjb250ZXh0bWVudSc6ICdjb250ZXh0bWVudScsXG4gICAgICAgICdtb3VzZWRvd24nOiAncG9pbnRlcmRvd24nLFxuICAgICAgICAndG91Y2hzdGFydCc6ICdwb2ludGVyZG93bicsXG4gICAgICAgICdtb3VzZW92ZXInOiAnbW91c2VvdmVyJyxcbiAgICAgICAgJ21vdXNlb3V0JzogJ21vdXNlb3V0JyxcbiAgICAgICAgJ21vdXNlZW50ZXInOiAnbW91c2VlbnRlcicsXG4gICAgICAgICdtb3VzZWxlYXZlJzogJ21vdXNlbGVhdmUnLFxuICAgICAgICAnd2hlZWwnOiAnbW91c2V3aGVlbCcsXG4gICAgICAgICdtb3VzZWVudGVyIC5qb2ludC1jZWxsJzogJ21vdXNlZW50ZXInLFxuICAgICAgICAnbW91c2VsZWF2ZSAuam9pbnQtY2VsbCc6ICdtb3VzZWxlYXZlJyxcbiAgICAgICAgJ21vdXNlZW50ZXIgLmpvaW50LXRvb2xzJzogJ21vdXNlZW50ZXInLFxuICAgICAgICAnbW91c2VsZWF2ZSAuam9pbnQtdG9vbHMnOiAnbW91c2VsZWF2ZScsXG4gICAgICAgICdkYmxjbGljayAuam9pbnQtY2VsbCBbbWFnbmV0XSc6ICdtYWduZXRwb2ludGVyZGJsY2xpY2snLFxuICAgICAgICAnY29udGV4dG1lbnUgLmpvaW50LWNlbGwgW21hZ25ldF0nOiAnbWFnbmV0Y29udGV4dG1lbnUnLFxuICAgICAgICAnbW91c2Vkb3duIC5qb2ludC1saW5rIC5sYWJlbCc6ICdvbmxhYmVsJywgLy8gaW50ZXJhY3Rpb24gd2l0aCBsaW5rIGxhYmVsXG4gICAgICAgICd0b3VjaHN0YXJ0IC5qb2ludC1saW5rIC5sYWJlbCc6ICdvbmxhYmVsJyxcbiAgICAgICAgJ2RyYWdzdGFydCAuam9pbnQtY2VsbCBpbWFnZSc6ICdvbkltYWdlRHJhZ1N0YXJ0JyAvLyBmaXJlZm94IGZpeFxuICAgIH0sXG5cbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICAnbW91c2Vtb3ZlJzogJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgJ3RvdWNobW92ZSc6ICdwb2ludGVybW92ZScsXG4gICAgICAgICdtb3VzZXVwJzogJ3BvaW50ZXJ1cCcsXG4gICAgICAgICd0b3VjaGVuZCc6ICdwb2ludGVydXAnLFxuICAgICAgICAndG91Y2hjYW5jZWwnOiAncG9pbnRlcnVwJ1xuICAgIH0sXG5cbiAgICAvKiBDU1Mgd2l0aGluIHRoZSBTVkcgZG9jdW1lbnRcbiAgICAqIDEuIEFkZGluZyB2ZWN0b3ItZWZmZWN0OiBub24tc2NhbGluZy1zdHJva2U7IHRvIHByZXZlbnQgdGhlIHN0cm9rZSB3aWR0aCBmcm9tIHNjYWxpbmcgZm9yXG4gICAgKiAgICBlbGVtZW50cyB0aGF0IHVzZSB0aGUgYHNjYWxhYmxlYCBncm91cC5cbiAgICAqL1xuICAgIHN0eWxlc2hlZXQ6IC8qY3NzKi9gXG4gICAgICAgIC5qb2ludC1lbGVtZW50IC5zY2FsYWJsZSAqIHtcbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q6IG5vbi1zY2FsaW5nLXN0cm9rZTtcbiAgICAgICAgfVxuICAgIGAsXG5cbiAgICBzdmc6IG51bGwsXG4gICAgdmlld3BvcnQ6IG51bGwsXG4gICAgZGVmczogbnVsbCxcbiAgICB0b29sczogbnVsbCxcbiAgICBsYXllcnM6IG51bGwsXG5cbiAgICAvLyBGb3Igc3RvcmluZyB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggKENUTSkgb2YgdGhlIHBhcGVyJ3Mgdmlld3BvcnQuXG4gICAgX3ZpZXdwb3J0TWF0cml4OiBudWxsLFxuICAgIC8vIEZvciB2ZXJpZnlpbmcgd2hldGhlciB0aGUgQ1RNIGlzIHVwLXRvLWRhdGUuIFRoZSB2aWV3cG9ydCB0cmFuc2Zvcm0gYXR0cmlidXRlXG4gICAgLy8gY291bGQgaGF2ZSBiZWVuIG1hbmlwdWxhdGVkIGRpcmVjdGx5LlxuICAgIF92aWV3cG9ydFRyYW5zZm9ybVN0cmluZzogbnVsbCxcbiAgICAvLyBVcGRhdGVzIGRhdGEgKHByaW9yaXRpZXMsIHVubW91bnRlZCB2aWV3cyBldGMuKVxuICAgIF91cGRhdGVzOiBudWxsLFxuICAgIC8vIFBhcGVyIExheWVyc1xuICAgIF9sYXllcnM6IG51bGwsXG5cbiAgICBTT1JUX0RFTEFZSU5HX0JBVENIRVM6IFsnYWRkJywgJ3RvLWZyb250JywgJ3RvLWJhY2snXSxcbiAgICBVUERBVEVfREVMQVlJTkdfQkFUQ0hFUzogWyd0cmFuc2xhdGUnXSxcbiAgICAvLyBJZiB5b3UgaW50ZXJhY3Qgd2l0aCB0aGVzZSBlbGVtZW50cyxcbiAgICAvLyB0aGUgZGVmYXVsdCBpbnRlcmFjdGlvbiBzdWNoIGFzIGBlbGVtZW50IG1vdmVgIGlzIHByZXZlbnRlZC5cbiAgICBGT1JNX0NPTlRST0xfVEFHX05BTUVTOiBbJ1RFWFRBUkVBJywgJ0lOUFVUJywgJ0JVVFRPTicsICdTRUxFQ1QnLCAnT1BUSU9OJ10gLFxuICAgIC8vIElmIHlvdSBpbnRlcmFjdCB3aXRoIHRoZXNlIGVsZW1lbnRzLCB0aGUgZXZlbnRzIGFyZSBub3QgcHJvcGFnYXRlZCB0byB0aGUgcGFwZXJcbiAgICAvLyBpLmUuIHBhcGVyIGV2ZW50cyBzdWNoIGFzIGBlbGVtZW50OnBvaW50ZXJkb3duYCBhcmUgbm90IHRyaWdnZXJlZC5cbiAgICBHVUFSREVEX1RBR19OQU1FUzogW1xuICAgICAgICAvLyBHdWFyZCA8c2VsZWN0PiBmb3IgY29uc2lzdGVuY3kuIFdoZW4geW91IGNsaWNrIG9uIGl0OlxuICAgICAgICAvLyBDaHJvbWU6IHRyaWdnZXJzIGBwb2ludGVyZG93bmAsIGBwb2ludGVydXBgLCBgcG9pbnRlcmNsaWNrYCB0byBvcGVuXG4gICAgICAgIC8vIEZpcmVmb3g6IHRyaWdnZXJzIGBwb2ludGVyZG93bmAgb24gb3BlbiwgYHBvaW50ZXJ1cGAgKGFuZCBgcG9pbnRlcmNsaWNrYCBvbmx5IGlmIHlvdSBoYXZlbid0IG1vdmVkKS5cbiAgICAgICAgLy8gICAgICAgICAgb24gY2xvc2UuIEhvd2V2ZXIsIGlmIHlvdSBvcGVuIGFuZCB0aGVuIGNsb3NlIGJ5IGNsaWNraW5nIGVsc2V3aGVyZSBvbiB0aGUgcGFnZSxcbiAgICAgICAgLy8gICAgICAgICAgIG5vIG90aGVyIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgICAgLy8gU2FmYXJpOiB3aGVuIHlvdSBvcGVuIGl0LCBpdCB0cmlnZ2VycyBgcG9pbnRlcmRvd25gLiBUaGF0J3MgaXQuXG4gICAgICAgICdTRUxFQ1QnLFxuICAgIF0sXG4gICAgTUlOX1NDQUxFOiAxZS02LFxuXG4gICAgLy8gRGVmYXVsdCBmaW5kIGJ1ZmZlciBmb3IgdGhlIGZpbmRWaWV3c0luQXJlYSBhbmQgZmluZFZpZXdzQXRQb2ludCBtZXRob2RzLlxuICAgIC8vIFRoZSBmaW5kIGJ1ZmZlciBpcyB1c2VkIHRvIGV4dGVuZCB0aGUgYXJlYSBvZiB0aGUgc2VhcmNoXG4gICAgLy8gdG8gbWl0aWdhdGUgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIG1vZGVsIGFuZCB2aWV3IGdlb21ldHJ5LlxuICAgIERFRkFVTFRfRklORF9CVUZGRVI6IDIwMCxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRpb25zLmNlbGxWaWV3TmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgICAgICAgICAgb3B0aW9ucy5jZWxsVmlld05hbWVzcGFjZSA9IHR5cGVvZiBqb2ludCAhPT0gJ3VuZGVmaW5lZCcgJiYgaGFzKGpvaW50LCAnc2hhcGVzJykgPyBqb2ludC5zaGFwZXMgOiBudWxsO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbCB8fCBuZXcgR3JhcGg7XG5cbiAgICAgICAgLy8gTGF5ZXJzIChTVkdHcm91cHMpXG4gICAgICAgIHRoaXMuX2xheWVycyA9IHt9O1xuXG4gICAgICAgIHRoaXMuY2xvbmVPcHRpb25zKCk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIHRoaXMuX3NldERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5zdGFydExpc3RlbmluZygpO1xuXG4gICAgICAgIC8vIEhhc2ggb2YgYWxsIGNlbGwgdmlld3MuXG4gICAgICAgIHRoaXMuX3ZpZXdzID0ge307XG5cbiAgICAgICAgLy8gTW91c2Ugd2hlZWwgZXZlbnRzIGJ1ZmZlclxuICAgICAgICB0aGlzLl9td19ldnRfYnVmZmVyID0ge1xuICAgICAgICAgICAgZXZlbnQ6IG51bGwsXG4gICAgICAgICAgICBkZWx0YXM6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlbmRlciBleGlzdGluZyBjZWxscyBpbiB0aGUgZ3JhcGhcbiAgICAgICAgdGhpcy5yZXNldFZpZXdzKG1vZGVsLmF0dHJpYnV0ZXMuY2VsbHMubW9kZWxzKTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIFJlbmRlcmluZyBMb29wXG4gICAgICAgIGlmICghdGhpcy5pc0Zyb3plbigpICYmIHRoaXMuaXNBc3luYygpKSB0aGlzLnVwZGF0ZVZpZXdzQXN5bmMoKTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0VXBkYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVzICYmIHRoaXMuX3VwZGF0ZXMuaWQpIGNhbmNlbEZyYW1lKHRoaXMuX3VwZGF0ZXMuaWQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVzID0ge1xuICAgICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgICBwcmlvcml0aWVzOiBbe30sIHt9LCB7fV0sXG4gICAgICAgICAgICB1bm1vdW50ZWRDaWRzOiBbXSxcbiAgICAgICAgICAgIG1vdW50ZWRDaWRzOiBbXSxcbiAgICAgICAgICAgIHVubW91bnRlZDoge30sXG4gICAgICAgICAgICBtb3VudGVkOiB7fSxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAga2V5RnJvemVuOiBmYWxzZSxcbiAgICAgICAgICAgIGZyZWV6ZUtleTogbnVsbCxcbiAgICAgICAgICAgIHNvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaWRsZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgc3RhcnRMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICB0aGlzLmxpc3RlblRvKG1vZGVsLCAnYWRkJywgdGhpcy5vbkNlbGxBZGRlZClcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ3JlbW92ZScsIHRoaXMub25DZWxsUmVtb3ZlZClcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ2NoYW5nZScsIHRoaXMub25DZWxsQ2hhbmdlKVxuICAgICAgICAgICAgLmxpc3RlblRvKG1vZGVsLCAncmVzZXQnLCB0aGlzLm9uR3JhcGhSZXNldClcbiAgICAgICAgICAgIC5saXN0ZW5Ubyhtb2RlbCwgJ3NvcnQnLCB0aGlzLm9uR3JhcGhTb3J0KVxuICAgICAgICAgICAgLmxpc3RlblRvKG1vZGVsLCAnYmF0Y2g6c3RvcCcsIHRoaXMub25HcmFwaEJhdGNoU3RvcCk7XG4gICAgICAgIHRoaXMub24oJ2NlbGw6aGlnaGxpZ2h0JywgdGhpcy5vbkNlbGxIaWdobGlnaHQpXG4gICAgICAgICAgICAub24oJ2NlbGw6dW5oaWdobGlnaHQnLCB0aGlzLm9uQ2VsbFVuaGlnaGxpZ2h0KVxuICAgICAgICAgICAgLm9uKCd0cmFuc2Zvcm0nLCB0aGlzLnVwZGF0ZSk7XG4gICAgfSxcblxuICAgIG9uQ2VsbEFkZGVkOiBmdW5jdGlvbihjZWxsLCBfLCBvcHQpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gb3B0LnBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5pc0FzeW5jKCkgfHwgIWlzTnVtYmVyKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KGNlbGwsIG9wdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0Lm1heFBvc2l0aW9uID09PSBwb3NpdGlvbikgdGhpcy5mcmVlemUoeyBrZXk6ICdhZGRDZWxscycgfSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcoY2VsbCwgb3B0KTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgdGhpcy51bmZyZWV6ZSh7IGtleTogJ2FkZENlbGxzJyB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkNlbGxSZW1vdmVkOiBmdW5jdGlvbihjZWxsLCBfLCBvcHQpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuZmluZFZpZXdCeU1vZGVsKGNlbGwpO1xuICAgICAgICBpZiAodmlldykgdGhpcy5yZXF1ZXN0Vmlld1VwZGF0ZSh2aWV3LCB2aWV3LkZMQUdfUkVNT1ZFLCB2aWV3LlVQREFURV9QUklPUklUWSwgb3B0KTtcbiAgICB9LFxuXG4gICAgb25DZWxsQ2hhbmdlOiBmdW5jdGlvbihjZWxsLCBvcHQpIHtcbiAgICAgICAgaWYgKGNlbGwgPT09IHRoaXMubW9kZWwuYXR0cmlidXRlcy5jZWxscykgcmV0dXJuO1xuICAgICAgICBpZiAoY2VsbC5oYXNDaGFuZ2VkKCd6JykgJiYgdGhpcy5vcHRpb25zLnNvcnRpbmcgPT09IHNvcnRpbmdUeXBlcy5BUFBST1gpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmZpbmRWaWV3QnlNb2RlbChjZWxsKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB0aGlzLnJlcXVlc3RWaWV3VXBkYXRlKHZpZXcsIHZpZXcuRkxBR19JTlNFUlQsIHZpZXcuVVBEQVRFX1BSSU9SSVRZLCBvcHQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uR3JhcGhSZXNldDogZnVuY3Rpb24oY29sbGVjdGlvbiwgb3B0KSB7XG4gICAgICAgIHRoaXMucmVzZXRMYXllcnMoKTtcbiAgICAgICAgdGhpcy5yZXNldFZpZXdzKGNvbGxlY3Rpb24ubW9kZWxzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBvbkdyYXBoU29ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsLmhhc0FjdGl2ZUJhdGNoKHRoaXMuU09SVF9ERUxBWUlOR19CQVRDSEVTKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnNvcnRWaWV3cygpO1xuICAgIH0sXG5cbiAgICBvbkdyYXBoQmF0Y2hTdG9wOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRnJvemVuKCkpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSBkYXRhICYmIGRhdGEuYmF0Y2hOYW1lO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLm1vZGVsO1xuICAgICAgICBpZiAoIXRoaXMuaXNBc3luYygpKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlRGVsYXlpbmdCYXRjaGVzID0gdGhpcy5VUERBVEVfREVMQVlJTkdfQkFUQ0hFUztcbiAgICAgICAgICAgIGlmICh1cGRhdGVEZWxheWluZ0JhdGNoZXMuaW5jbHVkZXMobmFtZSkgJiYgIWdyYXBoLmhhc0FjdGl2ZUJhdGNoKHVwZGF0ZURlbGF5aW5nQmF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdzKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzb3J0RGVsYXlpbmdCYXRjaGVzID0gdGhpcy5TT1JUX0RFTEFZSU5HX0JBVENIRVM7XG4gICAgICAgIGlmIChzb3J0RGVsYXlpbmdCYXRjaGVzLmluY2x1ZGVzKG5hbWUpICYmICFncmFwaC5oYXNBY3RpdmVCYXRjaChzb3J0RGVsYXlpbmdCYXRjaGVzKSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Vmlld3MoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjbG9uZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGVmYXVsdENvbm5lY3RvcixcbiAgICAgICAgICAgIGRlZmF1bHRSb3V0ZXIsXG4gICAgICAgICAgICBkZWZhdWx0Q29ubmVjdGlvblBvaW50LFxuICAgICAgICAgICAgZGVmYXVsdEFuY2hvcixcbiAgICAgICAgICAgIGRlZmF1bHRMaW5rQW5jaG9yLFxuICAgICAgICAgICAgaGlnaGxpZ2h0aW5nLFxuICAgICAgICAgICAgY2VsbFZpZXdOYW1lc3BhY2UsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZVxuICAgICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgICAvLyBEZWZhdWx0IGNlbGxWaWV3IG5hbWVzcGFjZSBmb3IgRVM1XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgICAgIGlmICghY2VsbFZpZXdOYW1lc3BhY2UgJiYgdHlwZW9mIGpvaW50ICE9PSAndW5kZWZpbmVkJyAmJiBoYXMoam9pbnQsICdzaGFwZXMnKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jZWxsVmlld05hbWVzcGFjZSA9IGpvaW50LnNoYXBlcztcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICAgICAgLy8gSGVyZSBpZiBhIGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgd2UgY2FuIG5vdCBjbG9uZSBpdCwgYXMgdGhpcyB3b3VsZCByZXN1bHQgaW4gbG9vc2luZyB0aGUgZnVuY3Rpb24uXG4gICAgICAgIC8vIElmIHRoZSBkZWZhdWx0IGlzIHVzZWQsIHRoZSBjbG9uaW5nIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBwcmV2ZW50IG1vZGlmeWluZyB0aGUgb3B0aW9ucyBvbiBwcm90b3R5cGUuXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihkZWZhdWx0Q29ubmVjdG9yKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0Q29ubmVjdG9yID0gY2xvbmVEZWVwKGRlZmF1bHRDb25uZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihkZWZhdWx0Um91dGVyKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0Um91dGVyID0gY2xvbmVEZWVwKGRlZmF1bHRSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihkZWZhdWx0Q29ubmVjdGlvblBvaW50KSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0Q29ubmVjdGlvblBvaW50ID0gY2xvbmVEZWVwKGRlZmF1bHRDb25uZWN0aW9uUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihkZWZhdWx0QW5jaG9yKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0QW5jaG9yID0gY2xvbmVEZWVwKGRlZmF1bHRBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGdW5jdGlvbihkZWZhdWx0TGlua0FuY2hvcikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdExpbmtBbmNob3IgPSBjbG9uZURlZXAoZGVmYXVsdExpbmtBbmNob3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGludGVyYWN0aXZlKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5pbnRlcmFjdGl2ZSA9IGFzc2lnbih7fSwgaW50ZXJhY3RpdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGhpZ2hsaWdodGluZykpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgZGVmYXVsdCBoaWdobGlnaHRpbmcgb3B0aW9ucyBpbnRvIHRoZSB1c2VyIHNwZWNpZmllZCBvcHRpb25zLlxuICAgICAgICAgICAgb3B0aW9ucy5oaWdobGlnaHRpbmcgPSBkZWZhdWx0c0RlZXAoe30sIGhpZ2hsaWdodGluZywgZGVmYXVsdEhpZ2hsaWdodGluZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbnMgPSBWLm5hbWVzcGFjZTtcbiAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICBuYW1lc3BhY2VVUkk6IG5zLnhodG1sLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICBjbGFzc05hbWU6IGFkZENsYXNzTmFtZVByZWZpeCgncGFwZXItYmFja2dyb3VuZCcpLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgaW5zZXQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZXNwYWNlVVJJOiBucy5zdmcsXG4gICAgICAgICAgICB0YWdOYW1lOiAnc3ZnJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAneG1sbnM6eGxpbmsnOiBucy54bGlua1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnc3ZnJyxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgaW5zZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgYDxkZWZzPmAgZWxlbWVudCB0byB0aGUgU1ZHIGRvY3VtZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgZmlsdGVycyBhbmQgZ3JhZGllbnRzLlxuICAgICAgICAgICAgICAgIC8vIEl0J3MgZGVzaXJlZCB0byBoYXZlIHRoZSBkZWZzIGRlZmluZWQgYmVmb3JlIHRoZSB2aWV3cG9ydCAoZS5nLiB0byBtYWtlIGEgUERGIGRvY3VtZW50IHBpY2sgdXAgZGVmcyBwcm9wZXJseSkuXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ2RlZnMnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZGVmcydcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiAnZycsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBhZGRDbGFzc05hbWVQcmVmaXgoJ2xheWVycycpLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbGF5ZXJzJ1xuICAgICAgICAgICAgfV1cbiAgICAgICAgfV07XG4gICAgfSxcblxuICAgIGhhc0xheWVyVmlldyhsYXllck5hbWUpIHtcbiAgICAgICAgcmV0dXJuICAobGF5ZXJOYW1lIGluIHRoaXMuX2xheWVycyk7XG4gICAgfSxcblxuICAgIGdldExheWVyVmlldyhsYXllck5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBfbGF5ZXJzIH0gPSB0aGlzO1xuICAgICAgICBpZiAobGF5ZXJOYW1lIGluIF9sYXllcnMpIHJldHVybiBfbGF5ZXJzW2xheWVyTmFtZV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlhLlBhcGVyOiBVbmtub3duIGxheWVyIFwiJHtsYXllck5hbWV9XCJgKTtcbiAgICB9LFxuXG4gICAgZ2V0TGF5ZXJOb2RlKGxheWVyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllclZpZXcobGF5ZXJOYW1lKS5lbDtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHsgZWwsIGNoaWxkTm9kZXMsIG9wdGlvbnMsIHN0eWxlc2hlZXQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3ZnLCBkZWZzLCBsYXllcnMgfSA9IGNoaWxkTm9kZXM7XG5cbiAgICAgICAgZWwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICBzdmcuc3R5bGUub3ZlcmZsb3cgPSBvcHRpb25zLm92ZXJmbG93ID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG5cbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMuZGVmcyA9IGRlZnM7XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbGF5ZXJzO1xuXG4gICAgICAgIHRoaXMucmVuZGVyTGF5ZXJzKCk7XG5cbiAgICAgICAgVi5lbnN1cmVJZChzdmcpO1xuXG4gICAgICAgIHRoaXMuYWRkU3R5bGVzaGVldChzdHlsZXNoZWV0KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKG9wdGlvbnMuYmFja2dyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5kcmF3R3JpZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRHcmlkKG9wdGlvbnMuZHJhd0dyaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZFN0eWxlc2hlZXQ6IGZ1bmN0aW9uKGNzcykge1xuICAgICAgICBpZiAoIWNzcykgcmV0dXJuO1xuICAgICAgICBWKHRoaXMuc3ZnKS5wcmVwZW5kKFYuY3JlYXRlU1ZHU3R5bGUoY3NzKSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZUxheWVyKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIExheWVyc05hbWVzLkdSSUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHcmlkTGF5ZXIoeyBuYW1lLCBwYXBlcjogdGhpcywgcGF0dGVybnM6IHRoaXMuY29uc3RydWN0b3IuZ3JpZFBhdHRlcm5zIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcGVyTGF5ZXIoeyBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlckxheWVyczogZnVuY3Rpb24obGF5ZXJzID0gZGVmYXVsdExheWVycykge1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVycygpO1xuICAgICAgICAvLyBUT0RPOiBMYXllcnMgdG8gYmUgcmVhZCBmcm9tIHRoZSBncmFwaCBgbGF5ZXJzYCBhdHRyaWJ1dGVcbiAgICAgICAgbGF5ZXJzLmZvckVhY2goKHsgbmFtZSwgc29ydGVkIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyVmlldyA9IHRoaXMuY3JlYXRlTGF5ZXIobmFtZSk7XG4gICAgICAgICAgICB0aGlzLmxheWVycy5hcHBlbmRDaGlsZChsYXllclZpZXcuZWwpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW25hbWVdID0gbGF5ZXJWaWV3O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICAgIGNvbnN0IGNlbGxzTGF5ZXJWaWV3ID0gdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuQ0VMTFMpO1xuICAgICAgICBjb25zdCB0b29sc0xheWVyVmlldyA9IHRoaXMuZ2V0TGF5ZXJWaWV3KExheWVyc05hbWVzLlRPT0xTKTtcbiAgICAgICAgY29uc3QgbGFiZWxzTGF5ZXJWaWV3ID0gdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuTEFCRUxTKTtcbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdGhpcy50b29scyA9IHRvb2xzTGF5ZXJWaWV3LmVsO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy52aWV3cG9ydCA9IGNlbGxzTGF5ZXJWaWV3LmVsO1xuICAgICAgICAvLyB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgY2VsbHNMYXllclZpZXcudmVsLmFkZENsYXNzKGFkZENsYXNzTmFtZVByZWZpeCgndmlld3BvcnQnKSk7XG4gICAgICAgIGxhYmVsc0xheWVyVmlldy52ZWwuYWRkQ2xhc3MoYWRkQ2xhc3NOYW1lUHJlZml4KCd2aWV3cG9ydCcpKTtcbiAgICAgICAgY2VsbHNMYXllclZpZXcuZWwuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgY2VsbHNMYXllclZpZXcuZWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgbGFiZWxzTGF5ZXJWaWV3LmVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGxhYmVsc0xheWVyVmlldy5lbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICByZW1vdmVMYXllcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IF9sYXllcnMgfSA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKF9sYXllcnMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICBfbGF5ZXJzW25hbWVdLnJlbW92ZSgpO1xuICAgICAgICAgICAgZGVsZXRlIF9sYXllcnNbbmFtZV07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZXNldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgX2xheWVycyB9ID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmtleXMoX2xheWVycykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIF9sYXllcnNbbmFtZV0ucmVtb3ZlUGl2b3RzKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJhY2tncm91bmRJbWFnZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGN0bSA9IHRoaXMubWF0cml4KCk7XG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAoc3ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFYubWF0cml4VG9TY2FsZShjdG0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHRlclxuICAgICAgICBpZiAoc3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3kgPSBzeDtcbiAgICAgICAgfVxuICAgICAgICBzeCA9IE1hdGgubWF4KHN4IHx8IDAsIHRoaXMuTUlOX1NDQUxFKTtcbiAgICAgICAgc3kgPSBNYXRoLm1heChzeSB8fCAwLCB0aGlzLk1JTl9TQ0FMRSk7XG4gICAgICAgIGN0bS5hID0gc3g7XG4gICAgICAgIGN0bS5kID0gc3k7XG4gICAgICAgIHRoaXMubWF0cml4KGN0bSwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZVVuaWZvcm1BdFBvaW50OiBmdW5jdGlvbihzY2FsZSwgcG9pbnQsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBhOiBzeCwgZDogc3ksIGU6IHR4LCBmOiB0eSB9ID0gdGhpcy5tYXRyaXgoKTtcbiAgICAgICAgc2NhbGUgPSBNYXRoLm1heChzY2FsZSB8fCAwLCB0aGlzLk1JTl9TQ0FMRSk7XG4gICAgICAgIGlmIChzY2FsZSA9PT0gc3ggJiYgc2NhbGUgPT09IHN5KSB7XG4gICAgICAgICAgICAvLyBUaGUgc2NhbGUgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0cml4ID0gVi5jcmVhdGVTVkdNYXRyaXgoKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICB0eCAtIHBvaW50LnggKiAoc2NhbGUgLSBzeCksXG4gICAgICAgICAgICAgICAgdHkgLSBwb2ludC55ICogKHNjYWxlIC0gc3kpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgdGhpcy5tYXRyaXgobWF0cml4LCBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGN0bSA9IHRoaXMubWF0cml4KCk7XG4gICAgICAgIC8vIGdldHRlclxuICAgICAgICBpZiAodHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFYubWF0cml4VG9UcmFuc2xhdGUoY3RtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgdHggfHwgKHR4ID0gMCk7XG4gICAgICAgIHR5IHx8ICh0eSA9IDApO1xuICAgICAgICBpZiAoY3RtLmUgPT09IHR4ICYmIGN0bS5mID09PSB0eSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGN0bS5lID0gdHg7XG4gICAgICAgIGN0bS5mID0gdHk7XG4gICAgICAgIHRoaXMubWF0cml4KGN0bSwgZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtYXRyaXg6IGZ1bmN0aW9uKGN0bSwgZGF0YSA9IHt9KSB7XG5cbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5sYXllcnM7XG5cbiAgICAgICAgLy8gR2V0dGVyOlxuICAgICAgICBpZiAoY3RtID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVN0cmluZyA9IHZpZXdwb3J0LmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5fdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmcgfHwgbnVsbCkgPT09IHRyYW5zZm9ybVN0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIEl0J3Mgb2sgdG8gcmV0dXJuIHRoZSBjYWNoZWQgbWF0cml4LiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBoYXMgbm90IGNoYW5nZWQgc2luY2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWF0cml4IHdhcyBzdG9yZWQuXG4gICAgICAgICAgICAgICAgY3RtID0gdGhpcy5fdmlld3BvcnRNYXRyaXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2aWV3cG9ydCB0cmFuc2Zvcm0gYXR0cmlidXRlIGhhcyBjaGFuZ2VkLiBNZWFzdXJlIHRoZSBtYXRyaXggYW5kIGNhY2hlIGFnYWluLlxuICAgICAgICAgICAgICAgIGN0bSA9IHZpZXdwb3J0LmdldENUTSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0TWF0cml4ID0gY3RtO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0VHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtU3RyaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgY2FjaGVkIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgICAgICAgICAgLy8gSWYgbm8gbWF0cml4IHByZXZpb3VzbHkgc3RvcmVkIHRoZSBpZGVudGl0eSBtYXRyaXggaXMgcmV0dXJuZWQuXG4gICAgICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgoY3RtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldHRlcjpcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMubWF0cml4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBWLmNyZWF0ZVNWR01hdHJpeChjdG0pO1xuICAgICAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtU3RyaW5nID0gdGhpcy5fdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmc7XG4gICAgICAgIGNvbnN0IGN0bVN0cmluZyA9IFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcoY3VycmVudCk7XG4gICAgICAgIGlmIChjdG1TdHJpbmcgPT09IGN1cnJlbnRUcmFuc2Zvcm1TdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgdHJhbnNmb3JtIHN0cmluZyBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudFRyYW5zZm9ybVN0cmluZyAmJiBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKCkgPT09IGN0bVN0cmluZykge1xuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgdHJhbnNmb3JtIHN0cmluZyBpcyBlbXB0eSBhbmQgdGhlIG5ldyBvbmUgaXMgYW4gaWRlbnRpdHkgbWF0cml4LlxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byB1cGRhdGUgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgYSwgZCwgZSwgZiB9ID0gY3VycmVudDtcblxuICAgICAgICB2aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGN0bVN0cmluZyk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0TWF0cml4ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRUcmFuc2Zvcm1TdHJpbmcgPSB2aWV3cG9ydC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpO1xuXG4gICAgICAgIC8vIHNjYWxlIGV2ZW50XG4gICAgICAgIGlmIChhICE9PSBwcmV2LmEgfHwgZCAhPT0gcHJldi5kKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3NjYWxlJywgYSwgZCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2xhdGUgZXZlbnRcbiAgICAgICAgaWYgKGUgIT09IHByZXYuZSB8fCBmICE9PSBwcmV2LmYpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndHJhbnNsYXRlJywgZSwgZiwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3RyYW5zZm9ybScsIGN1cnJlbnQsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xpZW50TWF0cml4OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gVi5jcmVhdGVTVkdNYXRyaXgodGhpcy5jZWxscy5nZXRTY3JlZW5DVE0oKSk7XG4gICAgfSxcblxuICAgIHJlcXVlc3RDb25uZWN0ZWRMaW5rc1VwZGF0ZTogZnVuY3Rpb24odmlldywgcHJpb3JpdHksIG9wdCkge1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIENlbGxWaWV3KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5tb2RlbC5nZXRDb25uZWN0ZWRMaW5rcyhtb2RlbCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gbGlua3Nbal07XG4gICAgICAgICAgICAgICAgdmFyIGxpbmtWaWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwobGluayk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rVmlldykgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGZsYWdMYWJlbHMgPSBbJ1VQREFURSddO1xuICAgICAgICAgICAgICAgIGlmIChsaW5rLmdldFRhcmdldENlbGwoKSA9PT0gbW9kZWwpIGZsYWdMYWJlbHMucHVzaCgnVEFSR0VUJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsuZ2V0U291cmNlQ2VsbCgpID09PSBtb2RlbCkgZmxhZ0xhYmVscy5wdXNoKCdTT1VSQ0UnKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFByaW9yaXR5ID0gTWF0aC5tYXgocHJpb3JpdHkgKyAxLCBsaW5rVmlldy5VUERBVEVfUFJJT1JJVFkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVWaWV3VXBkYXRlKGxpbmtWaWV3LCBsaW5rVmlldy5nZXRGbGFnKGZsYWdMYWJlbHMpLCBuZXh0UHJpb3JpdHksIG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZm9yY2VQb3N0cG9uZWRWaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCBmbGFnKSB7XG4gICAgICAgIGlmICghdmlldyB8fCAhKHZpZXcgaW5zdGFuY2VvZiBDZWxsVmlldykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIG1vZGVsID0gdmlldy5tb2RlbDtcbiAgICAgICAgaWYgKG1vZGVsLmlzRWxlbWVudCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgoZmxhZyAmIHZpZXcuZ2V0RmxhZyhbJ1NPVVJDRScsICdUQVJHRVQnXSkpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgZHVtcE9wdGlvbnMgPSB7IHNpbGVudDogdHJ1ZSB9O1xuICAgICAgICAgICAgLy8gTGlua1ZpZXcgaXMgd2FpdGluZyBmb3IgdGhlIHRhcmdldCBvciB0aGUgc291cmNlIGNlbGxWaWV3IHRvIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgY2VsbHMgYXJlIG5vdCBpbiB0aGUgdmlld3BvcnQuXG4gICAgICAgICAgICB2YXIgc291cmNlRmxhZyA9IDA7XG4gICAgICAgICAgICB2YXIgc291cmNlVmlldyA9IHRoaXMuZmluZFZpZXdCeU1vZGVsKG1vZGVsLmdldFNvdXJjZUNlbGwoKSk7XG4gICAgICAgICAgICBpZiAoc291cmNlVmlldyAmJiAhdGhpcy5pc1ZpZXdNb3VudGVkKHNvdXJjZVZpZXcpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlRmxhZyA9IHRoaXMuZHVtcFZpZXcoc291cmNlVmlldywgZHVtcE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlRW5kTWFnbmV0KCdzb3VyY2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0YXJnZXRGbGFnID0gMDtcbiAgICAgICAgICAgIHZhciB0YXJnZXRWaWV3ID0gdGhpcy5maW5kVmlld0J5TW9kZWwobW9kZWwuZ2V0VGFyZ2V0Q2VsbCgpKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRWaWV3ICYmICF0aGlzLmlzVmlld01vdW50ZWQodGFyZ2V0VmlldykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRGbGFnID0gdGhpcy5kdW1wVmlldyh0YXJnZXRWaWV3LCBkdW1wT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmlldy51cGRhdGVFbmRNYWduZXQoJ3RhcmdldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZUZsYWcgPT09IDAgJiYgdGFyZ2V0RmxhZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGxlZnRvdmVyIGZsYWcgaXMgMCwgYWxsIHZpZXcgdXBkYXRlcyB3ZXJlIGRvbmUuXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmR1bXBWaWV3KHZpZXcsIGR1bXBPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlcXVlc3RWaWV3VXBkYXRlOiBmdW5jdGlvbih2aWV3LCBmbGFnLCBwcmlvcml0eSwgb3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB0aGlzLnNjaGVkdWxlVmlld1VwZGF0ZSh2aWV3LCBmbGFnLCBwcmlvcml0eSwgb3B0KTtcbiAgICAgICAgdmFyIGlzQXN5bmMgPSB0aGlzLmlzQXN5bmMoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNGcm96ZW4oKSB8fCAoaXNBc3luYyAmJiBvcHQuYXN5bmMgIT09IGZhbHNlKSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5oYXNBY3RpdmVCYXRjaCh0aGlzLlVQREFURV9ERUxBWUlOR19CQVRDSEVTKSkgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLnVwZGF0ZVZpZXdzKG9wdCk7XG4gICAgICAgIGlmIChpc0FzeW5jKSB0aGlzLm5vdGlmeUFmdGVyUmVuZGVyKHN0YXRzLCBvcHQpO1xuICAgIH0sXG5cbiAgICBzY2hlZHVsZVZpZXdVcGRhdGU6IGZ1bmN0aW9uKHZpZXcsIHR5cGUsIHByaW9yaXR5LCBvcHQpIHtcbiAgICAgICAgY29uc3QgeyBfdXBkYXRlczogdXBkYXRlcywgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHVwZGF0ZXMuaWRsZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0ZyZWV6ZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZXMuaWRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5mcmVlemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IEZMQUdfUkVNT1ZFLCBGTEFHX0lOU0VSVCwgVVBEQVRFX1BSSU9SSVRZLCBjaWQgfSA9IHZpZXc7XG4gICAgICAgIGxldCBwcmlvcml0eVVwZGF0ZXMgPSB1cGRhdGVzLnByaW9yaXRpZXNbcHJpb3JpdHldO1xuICAgICAgICBpZiAoIXByaW9yaXR5VXBkYXRlcykgcHJpb3JpdHlVcGRhdGVzID0gdXBkYXRlcy5wcmlvcml0aWVzW3ByaW9yaXR5XSA9IHt9O1xuICAgICAgICAvLyBNb3ZlIGhpZ2hlciBwcmlvcml0eSB1cGRhdGVzIHRvIHRoaXMgcHJpb3JpdHlcbiAgICAgICAgaWYgKHByaW9yaXR5ID4gVVBEQVRFX1BSSU9SSVRZKSB7XG4gICAgICAgICAgICAvLyBOb3QgdGhlIGRlZmF1bHQgcHJpb3JpdHkgZm9yIHRoaXMgdmlldy4gSXQncyBtb3N0IGxpa2VseSBhIGxpbmsgdmlld1xuICAgICAgICAgICAgLy8gY29ubmVjdGVkIHRvIGFub3RoZXIgbGluayB2aWV3LCB3aGljaCB0cmlnZ2VyZWQgdGhlIHVwZGF0ZS5cbiAgICAgICAgICAgIC8vIFRPRE86IElmIHRoZXJlIGlzIGFuIHVwZGF0ZSBzY2hlZHVsZWQgd2l0aCBhIGxvd2VyIHByaW9yaXR5IGFscmVhZHksIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSByZXF1ZXN0ZWQgcHJpb3JpdHkgdG8gdGhlIGxvd2VzdCBvbmUuIERvZXMgbm90IHNlZW0gdG8gYmUgY3JpdGljYWxcbiAgICAgICAgICAgIC8vIHJpZ2h0IG5vdywgYXMgaXQgXCJvbmx5XCIgcmVzdWx0cyBpbiBtdWx0aXBsZSB1cGRhdGVzIG9uIHRoZSBzYW1lIHZpZXcuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJpb3JpdHkgLSAxOyBpID49IFVQREFURV9QUklPUklUWTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlByaW9yaXR5VXBkYXRlcyA9IHVwZGF0ZXMucHJpb3JpdGllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZQcmlvcml0eVVwZGF0ZXMgfHwgIShjaWQgaW4gcHJldlByaW9yaXR5VXBkYXRlcykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5VXBkYXRlc1tjaWRdIHw9IHByZXZQcmlvcml0eVVwZGF0ZXNbY2lkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJldlByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VHlwZSA9IHByaW9yaXR5VXBkYXRlc1tjaWRdIHx8IDA7XG4gICAgICAgIC8vIFByZXZlbnQgY3ljbGluZ1xuICAgICAgICBpZiAoKGN1cnJlbnRUeXBlICYgdHlwZSkgPT09IHR5cGUpIHJldHVybjtcbiAgICAgICAgaWYgKCFjdXJyZW50VHlwZSkgdXBkYXRlcy5jb3VudCsrO1xuICAgICAgICBpZiAodHlwZSAmIEZMQUdfUkVNT1ZFICYmIGN1cnJlbnRUeXBlICYgRkxBR19JTlNFUlQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB2aWV3IGlzIHJlbW92ZWQgd2UgbmVlZCB0byByZW1vdmUgdGhlIGluc2VydCBmbGFnIGFzIHRoaXMgaXMgYSByZWluc2VydFxuICAgICAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gXj0gRkxBR19JTlNFUlQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAmIEZMQUdfSU5TRVJUICYmIGN1cnJlbnRUeXBlICYgRkxBR19SRU1PVkUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSB2aWV3IGlzIGFkZGVkIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZW1vdmUgZmxhZyBhcyB0aGlzIGlzIHZpZXcgd2FzIHByZXZpb3VzbHkgcmVtb3ZlZFxuICAgICAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gXj0gRkxBR19SRU1PVkU7XG4gICAgICAgIH1cbiAgICAgICAgcHJpb3JpdHlVcGRhdGVzW2NpZF0gfD0gdHlwZTtcbiAgICAgICAgY29uc3Qgdmlld1VwZGF0ZUZuID0gb3B0aW9ucy5vblZpZXdVcGRhdGU7XG4gICAgICAgIGlmICh0eXBlb2Ygdmlld1VwZGF0ZUZuID09PSAnZnVuY3Rpb24nKSB2aWV3VXBkYXRlRm4uY2FsbCh0aGlzLCB2aWV3LCB0eXBlLCBwcmlvcml0eSwgb3B0IHx8IHt9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZHVtcFZpZXdVcGRhdGU6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm4gMDtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIgY2lkID0gdmlldy5jaWQ7XG4gICAgICAgIHZhciBwcmlvcml0eVVwZGF0ZXMgPSB1cGRhdGVzLnByaW9yaXRpZXNbdmlldy5VUERBVEVfUFJJT1JJVFldO1xuICAgICAgICB2YXIgZmxhZyA9IHRoaXMucmVnaXN0ZXJNb3VudGVkVmlldyh2aWV3KSB8IHByaW9yaXR5VXBkYXRlc1tjaWRdO1xuICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICBkdW1wVmlldzogZnVuY3Rpb24odmlldywgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuZHVtcFZpZXdVcGRhdGUodmlldyk7XG4gICAgICAgIGlmICghZmxhZykgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHNob3VsZE5vdGlmeSA9ICFvcHQuc2lsZW50O1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB0aGlzLm5vdGlmeUJlZm9yZVJlbmRlcihvcHQpO1xuICAgICAgICBjb25zdCBsZWZ0b3ZlciA9IHRoaXMudXBkYXRlVmlldyh2aWV3LCBmbGFnLCBvcHQpO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IHsgdXBkYXRlZDogMSwgcHJpb3JpdHk6IHZpZXcuVVBEQVRFX1BSSU9SSVRZIH07XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFmdGVyUmVuZGVyKHN0YXRzLCBvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0b3ZlcjtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlldzogZnVuY3Rpb24odmlldywgZmxhZywgb3B0KSB7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHsgRkxBR19SRU1PVkUsIEZMQUdfSU5TRVJULCBGTEFHX0lOSVQsIG1vZGVsIH0gPSB2aWV3O1xuICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIENlbGxWaWV3KSB7XG4gICAgICAgICAgICBpZiAoZmxhZyAmIEZMQUdfUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVWaWV3KG1vZGVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFnICYgRkxBR19JTlNFUlQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luaXRpYWxJbnNlcnQgPSAhIShmbGFnICYgRkxBR19JTklUKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgXj0gRkxBR19JTklUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydFZpZXcodmlldywgaXNJbml0aWFsSW5zZXJ0KTtcbiAgICAgICAgICAgICAgICBmbGFnIF49IEZMQUdfSU5TRVJUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmxhZykgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiB2aWV3LmNvbmZpcm1VcGRhdGUoZmxhZywgb3B0IHx8IHt9KTtcbiAgICB9LFxuXG4gICAgcmVxdWlyZVZpZXc6IGZ1bmN0aW9uKG1vZGVsLCBvcHQpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3QnlNb2RlbChtb2RlbCk7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMuZHVtcFZpZXcodmlldywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfSxcblxuICAgIHJlZ2lzdGVyVW5tb3VudGVkVmlldzogZnVuY3Rpb24odmlldykge1xuICAgICAgICB2YXIgY2lkID0gdmlldy5jaWQ7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgaWYgKGNpZCBpbiB1cGRhdGVzLnVubW91bnRlZCkgcmV0dXJuIDA7XG4gICAgICAgIHZhciBmbGFnID0gdXBkYXRlcy51bm1vdW50ZWRbY2lkXSB8PSB2aWV3LkZMQUdfSU5TRVJUO1xuICAgICAgICB1cGRhdGVzLnVubW91bnRlZENpZHMucHVzaChjaWQpO1xuICAgICAgICBkZWxldGUgdXBkYXRlcy5tb3VudGVkW2NpZF07XG4gICAgICAgIHJldHVybiBmbGFnO1xuICAgIH0sXG5cbiAgICByZWdpc3Rlck1vdW50ZWRWaWV3OiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgIHZhciBjaWQgPSB2aWV3LmNpZDtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICBpZiAoY2lkIGluIHVwZGF0ZXMubW91bnRlZCkgcmV0dXJuIDA7XG4gICAgICAgIHVwZGF0ZXMubW91bnRlZFtjaWRdID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlcy5tb3VudGVkQ2lkcy5wdXNoKGNpZCk7XG4gICAgICAgIHZhciBmbGFnID0gdXBkYXRlcy51bm1vdW50ZWRbY2lkXSB8fCAwO1xuICAgICAgICBkZWxldGUgdXBkYXRlcy51bm1vdW50ZWRbY2lkXTtcbiAgICAgICAgcmV0dXJuIGZsYWc7XG4gICAgfSxcblxuICAgIGlzVmlld01vdW50ZWQ6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgaWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjaWQgPSB2aWV3LmNpZDtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICByZXR1cm4gKGNpZCBpbiB1cGRhdGVzLm1vdW50ZWQpO1xuICAgIH0sXG5cbiAgICBkdW1wVmlld3M6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB2YXIgcGFzc2luZ09wdCA9IGRlZmF1bHRzKHt9LCBvcHQsIHsgdmlld3BvcnQ6IG51bGwgfSk7XG4gICAgICAgIHRoaXMuY2hlY2tWaWV3cG9ydChwYXNzaW5nT3B0KTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cyhwYXNzaW5nT3B0KTtcbiAgICB9LFxuXG4gICAgLy8gU3luY2hyb25vdXMgdmlld3MgdXBkYXRlXG4gICAgdXBkYXRlVmlld3M6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB0aGlzLm5vdGlmeUJlZm9yZVJlbmRlcihvcHQpO1xuICAgICAgICBsZXQgYmF0Y2hTdGF0cztcbiAgICAgICAgbGV0IHVwZGF0ZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGJhdGNoQ291bnQgPSAwO1xuICAgICAgICBsZXQgcHJpb3JpdHkgPSBNSU5fUFJJT1JJVFk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGJhdGNoQ291bnQrKztcbiAgICAgICAgICAgIGJhdGNoU3RhdHMgPSB0aGlzLnVwZGF0ZVZpZXdzQmF0Y2gob3B0KTtcbiAgICAgICAgICAgIHVwZGF0ZUNvdW50ICs9IGJhdGNoU3RhdHMudXBkYXRlZDtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gTWF0aC5taW4oYmF0Y2hTdGF0cy5wcmlvcml0eSwgcHJpb3JpdHkpO1xuICAgICAgICB9IHdoaWxlICghYmF0Y2hTdGF0cy5lbXB0eSk7XG4gICAgICAgIGNvbnN0IHN0YXRzID0geyB1cGRhdGVkOiB1cGRhdGVDb3VudCwgYmF0Y2hlczogYmF0Y2hDb3VudCwgcHJpb3JpdHkgfTtcbiAgICAgICAgdGhpcy5ub3RpZnlBZnRlclJlbmRlcihzdGF0cywgb3B0KTtcbiAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH0sXG5cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcHJpb3JpdGllcyA9IHRoaXMuX3VwZGF0ZXMucHJpb3JpdGllcztcbiAgICAgICAgY29uc3QgcHJpb3JpdHlJbmRleGVzID0gT2JqZWN0LmtleXMocHJpb3JpdGllcyk7IC8vIGNvbnZlcnQgcHJpb3JpdGllcyB0byBhIGRlbnNlIGFycmF5XG4gICAgICAgIGxldCBpID0gcHJpb3JpdHlJbmRleGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIGktLSkge1xuICAgICAgICAgICAgLy8gYSBmYXN0ZXIgd2F5IGhvdyB0byBjaGVjayBpZiBhbiBvYmplY3QgaXMgZW1wdHlcbiAgICAgICAgICAgIGZvciAobGV0IF9rZXkgaW4gcHJpb3JpdGllc1twcmlvcml0eUluZGV4ZXNbaV1dKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZpZXdzQXN5bmM6IGZ1bmN0aW9uKG9wdCwgZGF0YSkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9IHsgcHJvY2Vzc2VkOiAwLCBwcmlvcml0eTogTUlOX1BSSU9SSVRZIH0pO1xuICAgICAgICBjb25zdCB7IF91cGRhdGVzOiB1cGRhdGVzLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpZCA9IHVwZGF0ZXMuaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUoaWQpO1xuICAgICAgICAgICAgaWYgKGRhdGEucHJvY2Vzc2VkID09PSAwICYmIHRoaXMuaGFzU2NoZWR1bGVkVXBkYXRlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlCZWZvcmVSZW5kZXIob3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy51cGRhdGVWaWV3c0JhdGNoKG9wdCk7XG4gICAgICAgICAgICBjb25zdCBwYXNzaW5nT3B0ID0gZGVmYXVsdHMoe30sIG9wdCwge1xuICAgICAgICAgICAgICAgIG1vdW50QmF0Y2hTaXplOiBNT1VOVF9CQVRDSF9TSVpFIC0gc3RhdHMubW91bnRlZCxcbiAgICAgICAgICAgICAgICB1bm1vdW50QmF0Y2hTaXplOiBNT1VOVF9CQVRDSF9TSVpFIC0gc3RhdHMudW5tb3VudGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrU3RhdHMgPSB0aGlzLmNoZWNrVmlld3BvcnQocGFzc2luZ09wdCk7XG4gICAgICAgICAgICBjb25zdCB1bm1vdW50Q291bnQgPSBjaGVja1N0YXRzLnVubW91bnRlZDtcbiAgICAgICAgICAgIGNvbnN0IG1vdW50Q291bnQgPSBjaGVja1N0YXRzLm1vdW50ZWQ7XG4gICAgICAgICAgICBsZXQgcHJvY2Vzc2VkID0gZGF0YS5wcm9jZXNzZWQ7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IHVwZGF0ZXMuY291bnQ7XG4gICAgICAgICAgICBpZiAoc3RhdHMudXBkYXRlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIHVwZGF0ZXMgaGF2ZSBiZWVuIGp1c3QgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkICs9IHN0YXRzLnVwZGF0ZWQgKyBzdGF0cy51bm1vdW50ZWQ7XG4gICAgICAgICAgICAgICAgc3RhdHMucHJvY2Vzc2VkID0gcHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgIGRhdGEucHJpb3JpdHkgPSBNYXRoLm1pbihzdGF0cy5wcmlvcml0eSwgZGF0YS5wcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzLmVtcHR5ICYmIG1vdW50Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMudW5tb3VudGVkICs9IHVubW91bnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMubW91bnRlZCArPSBtb3VudENvdW50O1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5wcmlvcml0eSA9IGRhdGEucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5QWZ0ZXJSZW5kZXIoc3RhdHMsIG9wdCk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcmlvcml0eSA9IE1JTl9QUklPUklUWTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5jb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZXMuaWRsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvRnJlZXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5pZGxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmVuZGVyOmlkbGUnLCBvcHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvZ3Jlc3MgY2FsbGJhY2tcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzRm4gPSBvcHQucHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAodG90YWwgJiYgdHlwZW9mIHByb2dyZXNzRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0ZuLmNhbGwodGhpcywgc3RhdHMuZW1wdHksIHByb2Nlc3NlZCwgdG90YWwsIHN0YXRzLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGZyYW1lIGNvdWxkIGhhdmUgYmVlbiBjYW5jZWxlZCBpbiBhIGNhbGxiYWNrXG4gICAgICAgICAgICBpZiAodXBkYXRlcy5pZCAhPT0gaWQpIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWEuUGFwZXI6IGNhbiBub3QgdW5mcmVlemUgdGhlIHBhcGVyIGFmdGVyIGl0IHdhcyByZW1vdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlcy5pZCA9IG5leHRGcmFtZSh0aGlzLnVwZGF0ZVZpZXdzQXN5bmMsIHRoaXMsIG9wdCwgZGF0YSk7XG4gICAgfSxcblxuICAgIG5vdGlmeUJlZm9yZVJlbmRlcjogZnVuY3Rpb24ob3B0ID0ge30pIHtcbiAgICAgICAgbGV0IGJlZm9yZUZuID0gb3B0LmJlZm9yZVJlbmRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYmVmb3JlRm4gPSB0aGlzLm9wdGlvbnMuYmVmb3JlUmVuZGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVGbiAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJlZm9yZUZuLmNhbGwodGhpcywgb3B0LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgbm90aWZ5QWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKHN0YXRzLCBvcHQgPSB7fSkge1xuICAgICAgICBsZXQgYWZ0ZXJGbiA9IG9wdC5hZnRlclJlbmRlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBhZnRlckZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhZnRlckZuID0gdGhpcy5vcHRpb25zLmFmdGVyUmVuZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYWZ0ZXJGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYWZ0ZXJGbi5jYWxsKHRoaXMsIHN0YXRzLCBvcHQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVuZGVyOmRvbmUnLCBzdGF0cywgb3B0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlld3NCYXRjaDogZnVuY3Rpb24ob3B0KSB7XG4gICAgICAgIG9wdCB8fCAob3B0ID0ge30pO1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gb3B0LmJhdGNoU2l6ZSB8fCBVUERBVEVfQkFUQ0hfU0laRTtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIgdXBkYXRlQ291bnQgPSAwO1xuICAgICAgICB2YXIgcG9zdHBvbmVDb3VudCA9IDA7XG4gICAgICAgIHZhciB1bm1vdW50Q291bnQgPSAwO1xuICAgICAgICB2YXIgbW91bnRDb3VudCA9IDA7XG4gICAgICAgIHZhciBtYXhQcmlvcml0eSA9IE1JTl9QUklPUklUWTtcbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBwcmlvcml0aWVzID0gdXBkYXRlcy5wcmlvcml0aWVzO1xuICAgICAgICB2YXIgdmlld3BvcnRGbiA9ICd2aWV3cG9ydCcgaW4gb3B0ID8gb3B0LnZpZXdwb3J0IDogb3B0aW9ucy52aWV3cG9ydDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydEZuICE9PSAnZnVuY3Rpb24nKSB2aWV3cG9ydEZuID0gbnVsbDtcbiAgICAgICAgdmFyIHBvc3Rwb25lVmlld0ZuID0gb3B0aW9ucy5vblZpZXdQb3N0cG9uZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zdHBvbmVWaWV3Rm4gIT09ICdmdW5jdGlvbicpIHBvc3Rwb25lVmlld0ZuID0gbnVsbDtcbiAgICAgICAgdmFyIHByaW9yaXR5SW5kZXhlcyA9IE9iamVjdC5rZXlzKHByaW9yaXRpZXMpOyAvLyBjb252ZXJ0IHByaW9yaXRpZXMgdG8gYSBkZW5zZSBhcnJheVxuICAgICAgICBtYWluOiBmb3IgKHZhciBpID0gMCwgbiA9IHByaW9yaXR5SW5kZXhlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmlvcml0eSA9ICtwcmlvcml0eUluZGV4ZXNbaV07XG4gICAgICAgICAgICB2YXIgcHJpb3JpdHlVcGRhdGVzID0gcHJpb3JpdGllc1twcmlvcml0eV07XG4gICAgICAgICAgICBmb3IgKHZhciBjaWQgaW4gcHJpb3JpdHlVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUNvdW50ID49IGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhayBtYWluO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW2NpZF07XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBvY2N1clxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZsYWcgPSBwcmlvcml0eVVwZGF0ZXNbY2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRGbGFnICYgdmlldy5GTEFHX1JFTU9WRSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGNoZWNrIGEgdmlldyBmb3Igdmlld3BvcnQgaWYgd2UgYXJlIGFib3V0IHRvIHJlbW92ZSB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNEZXRhY2hlZCA9IGNpZCBpbiB1cGRhdGVzLnVubW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXcuREVUQUNIQUJMRSAmJiB2aWV3cG9ydEZuICYmICF2aWV3cG9ydEZuLmNhbGwodGhpcywgdmlldywgIWlzRGV0YWNoZWQsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbm1vdW50IFZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEZXRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJVbm1vdW50ZWRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoVmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMudW5tb3VudGVkW2NpZF0gfD0gY3VycmVudEZsYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1vdW50Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdW50IFZpZXdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGV0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGbGFnIHw9IHZpZXcuRkxBR19JTlNFUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZsYWcgfD0gdGhpcy5yZWdpc3Rlck1vdW50ZWRWaWV3KHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGVmdG92ZXJGbGFnID0gdGhpcy51cGRhdGVWaWV3KHZpZXcsIGN1cnJlbnRGbGFnLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0b3ZlckZsYWcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZpZXcgdXBkYXRlIGhhcyBub3QgZmluaXNoZWQgY29tcGxldGVseVxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eVVwZGF0ZXNbY2lkXSA9IGxlZnRvdmVyRmxhZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb3N0cG9uZVZpZXdGbiB8fCAhcG9zdHBvbmVWaWV3Rm4uY2FsbCh0aGlzLCB2aWV3LCBsZWZ0b3ZlckZsYWcsIHRoaXMpIHx8IHByaW9yaXR5VXBkYXRlc1tjaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1heFByaW9yaXR5ID4gcHJpb3JpdHkpIG1heFByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnQrKztcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJpb3JpdHlVcGRhdGVzW2NpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaW9yaXR5OiBtYXhQcmlvcml0eSxcbiAgICAgICAgICAgIHVwZGF0ZWQ6IHVwZGF0ZUNvdW50LFxuICAgICAgICAgICAgcG9zdHBvbmVkOiBwb3N0cG9uZUNvdW50LFxuICAgICAgICAgICAgdW5tb3VudGVkOiB1bm1vdW50Q291bnQsXG4gICAgICAgICAgICBtb3VudGVkOiBtb3VudENvdW50LFxuICAgICAgICAgICAgZW1wdHk6IGVtcHR5XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldFVubW91bnRlZFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIGNvbnN0IHVubW91bnRlZENpZHMgPSBPYmplY3Qua2V5cyh1cGRhdGVzLnVubW91bnRlZCk7XG4gICAgICAgIGNvbnN0IG4gPSB1bm1vdW50ZWRDaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdW5tb3VudGVkVmlld3MgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB1bm1vdW50ZWRWaWV3c1tpXSA9IHZpZXdzW3VubW91bnRlZENpZHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bm1vdW50ZWRWaWV3cztcbiAgICB9LFxuXG4gICAgZ2V0TW91bnRlZFZpZXdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHRoaXMuX3VwZGF0ZXM7XG4gICAgICAgIGNvbnN0IG1vdW50ZWRDaWRzID0gT2JqZWN0LmtleXModXBkYXRlcy5tb3VudGVkKTtcbiAgICAgICAgY29uc3QgbiA9IG1vdW50ZWRDaWRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbW91bnRlZFZpZXdzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbW91bnRlZFZpZXdzW2ldID0gdmlld3NbbW91bnRlZENpZHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3VudGVkVmlld3M7XG4gICAgfSxcblxuICAgIGNoZWNrVW5tb3VudGVkVmlld3M6IGZ1bmN0aW9uKHZpZXdwb3J0Rm4sIG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCAgPSB7fSk7XG4gICAgICAgIHZhciBtb3VudENvdW50ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB2aWV3cG9ydEZuICE9PSAnZnVuY3Rpb24nKSB2aWV3cG9ydEZuID0gbnVsbDtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9ICdtb3VudEJhdGNoU2l6ZScgaW4gb3B0ID8gb3B0Lm1vdW50QmF0Y2hTaXplIDogSW5maW5pdHk7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIHVubW91bnRlZENpZHMgPSB1cGRhdGVzLnVubW91bnRlZENpZHM7XG4gICAgICAgIHZhciB1bm1vdW50ZWQgPSB1cGRhdGVzLnVubW91bnRlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBNYXRoLm1pbih1bm1vdW50ZWRDaWRzLmxlbmd0aCwgYmF0Y2hTaXplKTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGNpZCA9IHVubW91bnRlZENpZHNbaV07XG4gICAgICAgICAgICBpZiAoIShjaWQgaW4gdW5tb3VudGVkKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW2NpZF07XG4gICAgICAgICAgICBpZiAoIXZpZXcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHZpZXcuREVUQUNIQUJMRSAmJiB2aWV3cG9ydEZuICYmICF2aWV3cG9ydEZuLmNhbGwodGhpcywgdmlldywgZmFsc2UsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhdCB0aGUgZW5kIG9mIGFsbCB1bm1vdW50ZWQgaWRzLCBzbyB0aGlzIGNhbiBiZSBjaGVjayBsYXRlciBhZ2FpblxuICAgICAgICAgICAgICAgIHVubW91bnRlZENpZHMucHVzaChjaWQpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW91bnRDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLnJlZ2lzdGVyTW91bnRlZFZpZXcodmlldyk7XG4gICAgICAgICAgICBpZiAoZmxhZykgdGhpcy5zY2hlZHVsZVZpZXdVcGRhdGUodmlldywgZmxhZywgdmlldy5VUERBVEVfUFJJT1JJVFksIHsgbW91bnRpbmc6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHJpZCBvZiB2aWV3cywgdGhhdCBoYXZlIGJlZW4gbW91bnRlZFxuICAgICAgICB1bm1vdW50ZWRDaWRzLnNwbGljZSgwLCBpKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q291bnQ7XG4gICAgfSxcblxuICAgIGNoZWNrTW91bnRlZFZpZXdzOiBmdW5jdGlvbih2aWV3cG9ydEZuLCBvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIHZhciB1bm1vdW50Q291bnQgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHZpZXdwb3J0Rm4gIT09ICdmdW5jdGlvbicpIHJldHVybiB1bm1vdW50Q291bnQ7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSAndW5tb3VudEJhdGNoU2l6ZScgaW4gb3B0ID8gb3B0LnVubW91bnRCYXRjaFNpemUgOiBJbmZpbml0eTtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIgbW91bnRlZENpZHMgPSB1cGRhdGVzLm1vdW50ZWRDaWRzO1xuICAgICAgICB2YXIgbW91bnRlZCA9IHVwZGF0ZXMubW91bnRlZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBNYXRoLm1pbihtb3VudGVkQ2lkcy5sZW5ndGgsIGJhdGNoU2l6ZSk7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaWQgPSBtb3VudGVkQ2lkc1tpXTtcbiAgICAgICAgICAgIGlmICghKGNpZCBpbiBtb3VudGVkKSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmlldyA9IHZpZXdzW2NpZF07XG4gICAgICAgICAgICBpZiAoIXZpZXcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCF2aWV3LkRFVEFDSEFCTEUgfHwgdmlld3BvcnRGbi5jYWxsKHRoaXMsIHZpZXcsIHRydWUsIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHVzaCBhdCB0aGUgZW5kIG9mIGFsbCBtb3VudGVkIGlkcywgc28gdGhpcyBjYW4gYmUgY2hlY2sgbGF0ZXIgYWdhaW5cbiAgICAgICAgICAgICAgICBtb3VudGVkQ2lkcy5wdXNoKGNpZCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bm1vdW50Q291bnQrKztcbiAgICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5yZWdpc3RlclVubW91bnRlZFZpZXcodmlldyk7XG4gICAgICAgICAgICBpZiAoZmxhZykgdGhpcy5kZXRhY2hWaWV3KHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCByaWQgb2Ygdmlld3MsIHRoYXQgaGF2ZSBiZWVuIHVubW91bnRlZFxuICAgICAgICBtb3VudGVkQ2lkcy5zcGxpY2UoMCwgaSk7XG4gICAgICAgIHJldHVybiB1bm1vdW50Q291bnQ7XG4gICAgfSxcblxuICAgIGNoZWNrVmlld1Zpc2liaWxpdHk6IGZ1bmN0aW9uKGNlbGxWaWV3LCBvcHQgPSB7fSkge1xuICAgICAgICBsZXQgdmlld3BvcnRGbiA9ICd2aWV3cG9ydCcgaW4gb3B0ID8gb3B0LnZpZXdwb3J0IDogdGhpcy5vcHRpb25zLnZpZXdwb3J0O1xuICAgICAgICBpZiAodHlwZW9mIHZpZXdwb3J0Rm4gIT09ICdmdW5jdGlvbicpIHZpZXdwb3J0Rm4gPSBudWxsO1xuICAgICAgICBjb25zdCB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgY29uc3QgeyBtb3VudGVkLCB1bm1vdW50ZWQgfSA9IHVwZGF0ZXM7XG4gICAgICAgIGNvbnN0IHZpc2libGUgPSAhY2VsbFZpZXcuREVUQUNIQUJMRSB8fCAhdmlld3BvcnRGbiB8fCB2aWV3cG9ydEZuLmNhbGwodGhpcywgY2VsbFZpZXcsIGZhbHNlLCB0aGlzKTtcblxuICAgICAgICBsZXQgaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjZWxsVmlldy5jaWQgaW4gbW91bnRlZCAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMucmVnaXN0ZXJVbm1vdW50ZWRWaWV3KGNlbGxWaWV3KTtcbiAgICAgICAgICAgIGlmIChmbGFnKSB0aGlzLmRldGFjaFZpZXcoY2VsbFZpZXcpO1xuICAgICAgICAgICAgY29uc3QgaSA9IHVwZGF0ZXMubW91bnRlZENpZHMuaW5kZXhPZihjZWxsVmlldy5jaWQpO1xuICAgICAgICAgICAgdXBkYXRlcy5tb3VudGVkQ2lkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVW5tb3VudGVkICYmIGNlbGxWaWV3LmNpZCBpbiB1bm1vdW50ZWQgJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgY29uc3QgaSA9IHVwZGF0ZXMudW5tb3VudGVkQ2lkcy5pbmRleE9mKGNlbGxWaWV3LmNpZCk7XG4gICAgICAgICAgICB1cGRhdGVzLnVubW91bnRlZENpZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLnJlZ2lzdGVyTW91bnRlZFZpZXcoY2VsbFZpZXcpO1xuICAgICAgICAgICAgaWYgKGZsYWcpIHRoaXMuc2NoZWR1bGVWaWV3VXBkYXRlKGNlbGxWaWV3LCBmbGFnLCBjZWxsVmlldy5VUERBVEVfUFJJT1JJVFksIHsgbW91bnRpbmc6IHRydWUgfSk7XG4gICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vdW50ZWQ6IGlzTW91bnRlZCA/IDEgOiAwLFxuICAgICAgICAgICAgdW5tb3VudGVkOiBpc1VubW91bnRlZCA/IDEgOiAwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNoZWNrVmlld3BvcnQ6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICB2YXIgcGFzc2luZ09wdCA9IGRlZmF1bHRzKHt9LCBvcHQsIHtcbiAgICAgICAgICAgIG1vdW50QmF0Y2hTaXplOiBJbmZpbml0eSxcbiAgICAgICAgICAgIHVubW91bnRCYXRjaFNpemU6IEluZmluaXR5XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmlld3BvcnRGbiA9ICd2aWV3cG9ydCcgaW4gcGFzc2luZ09wdCA/IHBhc3NpbmdPcHQudmlld3BvcnQgOiB0aGlzLm9wdGlvbnMudmlld3BvcnQ7XG4gICAgICAgIHZhciB1bm1vdW50ZWRDb3VudCA9IHRoaXMuY2hlY2tNb3VudGVkVmlld3Modmlld3BvcnRGbiwgcGFzc2luZ09wdCk7XG4gICAgICAgIGlmICh1bm1vdW50ZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjaGVjayB2aWV3cywgdGhhdCBoYXZlIGJlZW4ganVzdCB1bm1vdW50ZWQgYW5kIHB1c2hlZCBhdCB0aGUgZW5kIG9mIHRoZSBjaWRzIGFycmF5XG4gICAgICAgICAgICB2YXIgdW5tb3VudGVkQ2lkcyA9IHRoaXMuX3VwZGF0ZXMudW5tb3VudGVkQ2lkcztcbiAgICAgICAgICAgIHBhc3NpbmdPcHQubW91bnRCYXRjaFNpemUgPSBNYXRoLm1pbih1bm1vdW50ZWRDaWRzLmxlbmd0aCAtIHVubW91bnRlZENvdW50LCBwYXNzaW5nT3B0Lm1vdW50QmF0Y2hTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW91bnRlZENvdW50ID0gdGhpcy5jaGVja1VubW91bnRlZFZpZXdzKHZpZXdwb3J0Rm4sIHBhc3NpbmdPcHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW91bnRlZDogbW91bnRlZENvdW50LFxuICAgICAgICAgICAgdW5tb3VudGVkOiB1bm1vdW50ZWRDb3VudFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBmcmVlemU6IGZ1bmN0aW9uKG9wdCkge1xuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgdmFyIHVwZGF0ZXMgPSB0aGlzLl91cGRhdGVzO1xuICAgICAgICB2YXIga2V5ID0gb3B0LmtleTtcbiAgICAgICAgdmFyIGlzRnJvemVuID0gdGhpcy5vcHRpb25zLmZyb3plbjtcbiAgICAgICAgdmFyIGZyZWV6ZUtleSA9IHVwZGF0ZXMuZnJlZXplS2V5O1xuICAgICAgICBpZiAoa2V5ICYmIGtleSAhPT0gZnJlZXplS2V5KSAge1xuICAgICAgICAgICAgLy8ga2V5IHBhc3NlZCwgYnV0IHRoZSBwYXBlciBpcyBhbHJlYWR5IGZyZWV6ZWQgd2l0aCBhbm90aGVyIGtleVxuICAgICAgICAgICAgaWYgKGlzRnJvemVuICYmIGZyZWV6ZUtleSkgcmV0dXJuO1xuICAgICAgICAgICAgdXBkYXRlcy5mcmVlemVLZXkgPSBrZXk7XG4gICAgICAgICAgICB1cGRhdGVzLmtleUZyb3plbiA9IGlzRnJvemVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB1cGRhdGVzLmlkO1xuICAgICAgICB1cGRhdGVzLmlkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpICYmIGlkKSBjYW5jZWxGcmFtZShpZCk7XG4gICAgfSxcblxuICAgIHVuZnJlZXplOiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIHZhciB1cGRhdGVzID0gdGhpcy5fdXBkYXRlcztcbiAgICAgICAgdmFyIGtleSA9IG9wdC5rZXk7XG4gICAgICAgIHZhciBmcmVlemVLZXkgPSB1cGRhdGVzLmZyZWV6ZUtleTtcbiAgICAgICAgLy8ga2V5IHBhc3NlZCwgYnV0IHRoZSBwYXBlciBpcyBhbHJlYWR5IGZyZWV6ZWQgd2l0aCBhbm90aGVyIGtleVxuICAgICAgICBpZiAoa2V5ICYmIGZyZWV6ZUtleSAmJiBrZXkgIT09IGZyZWV6ZUtleSkgcmV0dXJuO1xuICAgICAgICB1cGRhdGVzLmZyZWV6ZUtleSA9IG51bGw7XG4gICAgICAgIC8vIGtleSBwYXNzZWQsIGJ1dCB0aGUgcGFwZXIgaXMgYWxyZWFkeSBmcmVlemVkXG4gICAgICAgIGlmIChrZXkgJiYga2V5ID09PSBmcmVlemVLZXkgJiYgdXBkYXRlcy5rZXlGcm96ZW4pIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYygpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3c0FzeW5jKG9wdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdzKG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLmZyb3plbiA9IHVwZGF0ZXMua2V5RnJvemVuID0gZmFsc2U7XG4gICAgICAgIGlmICh1cGRhdGVzLnNvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFZpZXdzKCk7XG4gICAgICAgICAgICB1cGRhdGVzLnNvcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0FzeW5jOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRpb25zLmFzeW5jO1xuICAgIH0sXG5cbiAgICBpc0Zyb3plbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMub3B0aW9ucy5mcm96ZW47XG4gICAgfSxcblxuICAgIGlzRXhhY3RTb3J0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zb3J0aW5nID09PSBzb3J0aW5nVHlwZXMuRVhBQ1Q7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmZyZWV6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgLy9jbGVhbiB1cCBhbGwgRE9NIGVsZW1lbnRzL3ZpZXdzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICAgIHRoaXMucmVtb3ZlTGF5ZXJzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlVmlld3MoKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29tcHV0ZWRTaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHcgPSBvcHRpb25zLndpZHRoO1xuICAgICAgICB2YXIgaCA9IG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICBpZiAoIWlzTnVtYmVyKHcpKSB3ID0gdGhpcy5lbC5jbGllbnRXaWR0aDtcbiAgICAgICAgaWYgKCFpc051bWJlcihoKSkgaCA9IHRoaXMuZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICByZXR1cm4geyB3aWR0aDogdywgaGVpZ2h0OiBoIH07XG4gICAgfSxcblxuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGRhdGEgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IGN1cnJlbnRXaWR0aCwgaGVpZ2h0OiBjdXJyZW50SGVpZ2h0IH0gPSBvcHRpb25zO1xuICAgICAgICBsZXQgdyA9ICh3aWR0aCA9PT0gdW5kZWZpbmVkKSA/IGN1cnJlbnRXaWR0aCA6IHdpZHRoO1xuICAgICAgICBsZXQgaCA9IChoZWlnaHQgPT09IHVuZGVmaW5lZCkgPyBjdXJyZW50SGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgICBpZiAoY3VycmVudFdpZHRoID09PSB3ICYmIGN1cnJlbnRIZWlnaHQgPT09IGgpIHJldHVybjtcbiAgICAgICAgb3B0aW9ucy53aWR0aCA9IHc7XG4gICAgICAgIG9wdGlvbnMuaGVpZ2h0ID0gaDtcbiAgICAgICAgdGhpcy5fc2V0RGltZW5zaW9ucygpO1xuICAgICAgICBjb25zdCBjb21wdXRlZFNpemUgPSB0aGlzLmdldENvbXB1dGVkU2l6ZSgpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScsIGNvbXB1dGVkU2l6ZS53aWR0aCwgY29tcHV0ZWRTaXplLmhlaWdodCwgZGF0YSk7XG4gICAgfSxcblxuICAgIF9zZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgdyA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIGxldCBoID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIGlmIChpc051bWJlcih3KSkgdyA9IGAke01hdGgucm91bmQodyl9cHhgO1xuICAgICAgICBpZiAoaXNOdW1iZXIoaCkpIGggPSBgJHtNYXRoLnJvdW5kKGgpfXB4YDtcbiAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAgIHdpZHRoOiAodyA9PT0gbnVsbCkgPyAnJyA6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IChoID09PSBudWxsKSA/ICcnIDogaFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gRXhwYW5kL3NocmluayB0aGUgcGFwZXIgdG8gZml0IHRoZSBjb250ZW50LlxuICAgIC8vIEFsdGVybmF0aXZlbHkgc2lnbmF0dXJlIGZ1bmN0aW9uKG9wdClcbiAgICBmaXRUb0NvbnRlbnQ6IGZ1bmN0aW9uKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCwgcGFkZGluZywgb3B0KSB7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KGdyaWRXaWR0aCkpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBvcHRpb24gb2JqZWN0XG4gICAgICAgICAgICBvcHQgPSBncmlkV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTdXBwb3J0IGZvciBhIGRlcHJlY2F0ZWQgc2lnbmF0dXJlXG4gICAgICAgICAgICBvcHQgPSBhc3NpZ24oeyBncmlkV2lkdGgsIGdyaWRIZWlnaHQsIHBhZGRpbmcgfSwgb3B0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5nZXRGaXRUb0NvbnRlbnRBcmVhKG9wdCk7XG4gICAgICAgIGNvbnN0IHsgc3gsIHN5IH0gPSB0aGlzLnNjYWxlKCk7XG5cbiAgICAgICAgdGhpcy50cmFuc2xhdGUoLXggKiBzeCwgLXkgKiBzeSwgb3B0KTtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHdpZHRoICogc3gsIGhlaWdodCAqIHN5LCBvcHQpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZ2V0Rml0VG9Db250ZW50QXJlYTogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHBhcGVyIHNpemUgdG8gYWNjb21tb2RhdGUgYWxsIHRoZSBncmFwaCdzIGVsZW1lbnRzLlxuXG4gICAgICAgIGNvbnN0IGdyaWRXaWR0aCA9IG9wdC5ncmlkV2lkdGggfHwgMTtcbiAgICAgICAgY29uc3QgZ3JpZEhlaWdodCA9IG9wdC5ncmlkSGVpZ2h0IHx8IDE7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyB8fCAwKTtcblxuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IE1hdGgubWF4KG9wdC5taW5XaWR0aCB8fCAwLCBncmlkV2lkdGgpO1xuICAgICAgICBjb25zdCBtaW5IZWlnaHQgPSBNYXRoLm1heChvcHQubWluSGVpZ2h0IHx8IDAsIGdyaWRIZWlnaHQpO1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IG9wdC5tYXhXaWR0aCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBvcHQubWF4SGVpZ2h0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGNvbnN0IG5ld09yaWdpbiA9IG9wdC5hbGxvd05ld09yaWdpbjtcblxuICAgICAgICBjb25zdCBhcmVhID0gKCdjb250ZW50QXJlYScgaW4gb3B0KSA/IG5ldyBSZWN0KG9wdC5jb250ZW50QXJlYSkgOiB0aGlzLmdldENvbnRlbnRBcmVhKG9wdCk7XG4gICAgICAgIGNvbnN0IHsgc3gsIHN5IH0gPSB0aGlzLnNjYWxlKCk7XG4gICAgICAgIGFyZWEueCAqPSBzeDtcbiAgICAgICAgYXJlYS55ICo9IHN5O1xuICAgICAgICBhcmVhLndpZHRoICo9IHN4O1xuICAgICAgICBhcmVhLmhlaWdodCAqPSBzeTtcblxuICAgICAgICBsZXQgY2FsY1dpZHRoID0gTWF0aC5jZWlsKChhcmVhLndpZHRoICsgYXJlYS54KSAvIGdyaWRXaWR0aCk7XG4gICAgICAgIGxldCBjYWxjSGVpZ2h0ID0gTWF0aC5jZWlsKChhcmVhLmhlaWdodCArIGFyZWEueSkgLyBncmlkSGVpZ2h0KTtcbiAgICAgICAgaWYgKCFvcHQuYWxsb3dOZWdhdGl2ZUJvdHRvbVJpZ2h0KSB7XG4gICAgICAgICAgICBjYWxjV2lkdGggPSBNYXRoLm1heChjYWxjV2lkdGgsIDEpO1xuICAgICAgICAgICAgY2FsY0hlaWdodCA9IE1hdGgubWF4KGNhbGNIZWlnaHQsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGNXaWR0aCAqPSBncmlkV2lkdGg7XG4gICAgICAgIGNhbGNIZWlnaHQgKj0gZ3JpZEhlaWdodDtcblxuICAgICAgICBsZXQgdHggPSAwO1xuICAgICAgICBpZiAoKG5ld09yaWdpbiA9PT0gJ25lZ2F0aXZlJyAmJiBhcmVhLnggPCAwKSB8fCAobmV3T3JpZ2luID09PSAncG9zaXRpdmUnICYmIGFyZWEueCA+PSAwKSB8fCBuZXdPcmlnaW4gPT09ICdhbnknKSB7XG4gICAgICAgICAgICB0eCA9IE1hdGguY2VpbCgtYXJlYS54IC8gZ3JpZFdpZHRoKSAqIGdyaWRXaWR0aDtcbiAgICAgICAgICAgIHR4ICs9IHBhZGRpbmcubGVmdDtcbiAgICAgICAgICAgIGNhbGNXaWR0aCArPSB0eDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0eSA9IDA7XG4gICAgICAgIGlmICgobmV3T3JpZ2luID09PSAnbmVnYXRpdmUnICYmIGFyZWEueSA8IDApIHx8IChuZXdPcmlnaW4gPT09ICdwb3NpdGl2ZScgJiYgYXJlYS55ID49IDApIHx8IG5ld09yaWdpbiA9PT0gJ2FueScpIHtcbiAgICAgICAgICAgIHR5ID0gTWF0aC5jZWlsKC1hcmVhLnkgLyBncmlkSGVpZ2h0KSAqIGdyaWRIZWlnaHQ7XG4gICAgICAgICAgICB0eSArPSBwYWRkaW5nLnRvcDtcbiAgICAgICAgICAgIGNhbGNIZWlnaHQgKz0gdHk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjV2lkdGggKz0gcGFkZGluZy5yaWdodDtcbiAgICAgICAgY2FsY0hlaWdodCArPSBwYWRkaW5nLmJvdHRvbTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlc3VsdGluZyB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gbWluaW11bS5cbiAgICAgICAgY2FsY1dpZHRoID0gTWF0aC5tYXgoY2FsY1dpZHRoLCBtaW5XaWR0aCk7XG4gICAgICAgIGNhbGNIZWlnaHQgPSBNYXRoLm1heChjYWxjSGVpZ2h0LCBtaW5IZWlnaHQpO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcmVzdWx0aW5nIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGxlc3NlciB0aGFuIG1heGltdW0uXG4gICAgICAgIGNhbGNXaWR0aCA9IE1hdGgubWluKGNhbGNXaWR0aCwgbWF4V2lkdGgpO1xuICAgICAgICBjYWxjSGVpZ2h0ID0gTWF0aC5taW4oY2FsY0hlaWdodCwgbWF4SGVpZ2h0KTtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QoLXR4IC8gc3gsIC10eSAvIHN5LCBjYWxjV2lkdGggLyBzeCwgY2FsY0hlaWdodCAvIHN5KTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtVG9GaXRDb250ZW50OiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG5cbiAgICAgICAgbGV0IGNvbnRlbnRCQm94LCBjb250ZW50TG9jYWxPcmlnaW47XG4gICAgICAgIGlmICgnY29udGVudEFyZWEnIGluIG9wdCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudEFyZWEgPSBvcHQuY29udGVudEFyZWE7XG4gICAgICAgICAgICBjb250ZW50QkJveCA9IHRoaXMubG9jYWxUb1BhcGVyUmVjdChjb250ZW50QXJlYSk7XG4gICAgICAgICAgICBjb250ZW50TG9jYWxPcmlnaW4gPSBuZXcgUG9pbnQoY29udGVudEFyZWEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudEJCb3ggPSB0aGlzLmdldENvbnRlbnRCQm94KG9wdCk7XG4gICAgICAgICAgICBjb250ZW50TG9jYWxPcmlnaW4gPSB0aGlzLnBhcGVyVG9Mb2NhbFBvaW50KGNvbnRlbnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29udGVudEJCb3gud2lkdGggfHwgIWNvbnRlbnRCQm94LmhlaWdodCkgcmV0dXJuO1xuXG4gICAgICAgIGRlZmF1bHRzKG9wdCwge1xuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IHRydWUsXG4gICAgICAgICAgICBzY2FsZUdyaWQ6IG51bGwsXG4gICAgICAgICAgICBtaW5TY2FsZTogMCxcbiAgICAgICAgICAgIG1heFNjYWxlOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgICAgICBob3Jpem9udGFsQWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgIC8vbWluU2NhbGVYXG4gICAgICAgICAgICAvL21pblNjYWxlWVxuICAgICAgICAgICAgLy9tYXhTY2FsZVhcbiAgICAgICAgICAgIC8vbWF4U2NhbGVZXG4gICAgICAgICAgICAvL2ZpdHRpbmdCQm94XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyk7XG5cbiAgICAgICAgY29uc3QgbWluU2NhbGVYID0gb3B0Lm1pblNjYWxlWCB8fCBvcHQubWluU2NhbGU7XG4gICAgICAgIGNvbnN0IG1heFNjYWxlWCA9IG9wdC5tYXhTY2FsZVggfHwgb3B0Lm1heFNjYWxlO1xuICAgICAgICBjb25zdCBtaW5TY2FsZVkgPSBvcHQubWluU2NhbGVZIHx8IG9wdC5taW5TY2FsZTtcbiAgICAgICAgY29uc3QgbWF4U2NhbGVZID0gb3B0Lm1heFNjYWxlWSB8fCBvcHQubWF4U2NhbGU7XG5cbiAgICAgICAgbGV0IGZpdHRpbmdCQm94O1xuICAgICAgICBpZiAob3B0LmZpdHRpbmdCQm94KSB7XG4gICAgICAgICAgICBmaXR0aW5nQkJveCA9IG9wdC5maXR0aW5nQkJveDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRTaXplID0gdGhpcy5nZXRDb21wdXRlZFNpemUoKTtcbiAgICAgICAgICAgIGZpdHRpbmdCQm94ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRUcmFuc2xhdGUudHgsXG4gICAgICAgICAgICAgICAgeTogY3VycmVudFRyYW5zbGF0ZS50eSxcbiAgICAgICAgICAgICAgICB3aWR0aDogY29tcHV0ZWRTaXplLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogY29tcHV0ZWRTaXplLmhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpdHRpbmdCQm94ID0gbmV3IFJlY3QoZml0dGluZ0JCb3gpLm1vdmVBbmRFeHBhbmQoe1xuICAgICAgICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgeTogcGFkZGluZy50b3AsXG4gICAgICAgICAgICB3aWR0aDogLXBhZGRpbmcubGVmdCAtIHBhZGRpbmcucmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IC1wYWRkaW5nLnRvcCAtIHBhZGRpbmcuYm90dG9tXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGN0bSA9IHRoaXMubWF0cml4KCk7XG4gICAgICAgIGNvbnN0IHsgYTogc3gsIGQ6IHN5LCBlOiB0eCwgZjogdHkgfSA9IGN0bTtcblxuICAgICAgICBsZXQgbmV3U3ggPSBmaXR0aW5nQkJveC53aWR0aCAvIGNvbnRlbnRCQm94LndpZHRoICogc3g7XG4gICAgICAgIGxldCBuZXdTeSA9IGZpdHRpbmdCQm94LmhlaWdodCAvIGNvbnRlbnRCQm94LmhlaWdodCAqIHN5O1xuXG4gICAgICAgIGlmIChvcHQucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgbmV3U3ggPSBuZXdTeSA9IE1hdGgubWluKG5ld1N4LCBuZXdTeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzbmFwIHNjYWxlIHRvIGEgZ3JpZFxuICAgICAgICBpZiAob3B0LnNjYWxlR3JpZCkge1xuXG4gICAgICAgICAgICBjb25zdCBncmlkU2l6ZSA9IG9wdC5zY2FsZUdyaWQ7XG5cbiAgICAgICAgICAgIG5ld1N4ID0gZ3JpZFNpemUgKiBNYXRoLmZsb29yKG5ld1N4IC8gZ3JpZFNpemUpO1xuICAgICAgICAgICAgbmV3U3kgPSBncmlkU2l6ZSAqIE1hdGguZmxvb3IobmV3U3kgLyBncmlkU2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FsZSBtaW4vbWF4IGJvdW5kYXJpZXNcbiAgICAgICAgbmV3U3ggPSBNYXRoLm1pbihtYXhTY2FsZVgsIE1hdGgubWF4KG1pblNjYWxlWCwgbmV3U3gpKTtcbiAgICAgICAgbmV3U3kgPSBNYXRoLm1pbihtYXhTY2FsZVksIE1hdGgubWF4KG1pblNjYWxlWSwgbmV3U3kpKTtcblxuICAgICAgICBjb25zdCBzY2FsZURpZmYgPSB7XG4gICAgICAgICAgICB4OiBuZXdTeCAvIHN4LFxuICAgICAgICAgICAgeTogbmV3U3kgLyBzeVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBuZXdPeCA9IGZpdHRpbmdCQm94LnggLSBjb250ZW50TG9jYWxPcmlnaW4ueCAqIG5ld1N4IC0gdHg7XG4gICAgICAgIGxldCBuZXdPeSA9IGZpdHRpbmdCQm94LnkgLSBjb250ZW50TG9jYWxPcmlnaW4ueSAqIG5ld1N5IC0gdHk7XG5cbiAgICAgICAgc3dpdGNoIChvcHQudmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICBuZXdPeSA9IG5ld095ICsgKGZpdHRpbmdCQm94LmhlaWdodCAtIGNvbnRlbnRCQm94LmhlaWdodCAqIHNjYWxlRGlmZi55KSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIG5ld095ID0gbmV3T3kgKyAoZml0dGluZ0JCb3guaGVpZ2h0IC0gY29udGVudEJCb3guaGVpZ2h0ICogc2NhbGVEaWZmLnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG9wdC5ob3Jpem9udGFsQWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgbmV3T3ggPSBuZXdPeCArIChmaXR0aW5nQkJveC53aWR0aCAtIGNvbnRlbnRCQm94LndpZHRoICogc2NhbGVEaWZmLngpIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBuZXdPeCA9IG5ld094ICsgKGZpdHRpbmdCQm94LndpZHRoIC0gY29udGVudEJCb3gud2lkdGggKiBzY2FsZURpZmYueCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjdG0uYSA9IG5ld1N4O1xuICAgICAgICBjdG0uZCA9IG5ld1N5O1xuICAgICAgICBjdG0uZSA9IG5ld094O1xuICAgICAgICBjdG0uZiA9IG5ld095O1xuICAgICAgICB0aGlzLm1hdHJpeChjdG0sIG9wdCk7XG4gICAgfSxcblxuICAgIHNjYWxlQ29udGVudFRvRml0OiBmdW5jdGlvbihvcHQpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1Ub0ZpdENvbnRlbnQob3B0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb250ZW50IGFyZWEgaW4gbG9jYWwgdW5pdHMgKHdpdGhvdXQgdHJhbnNmb3JtYXRpb25zKS5cbiAgICBnZXRDb250ZW50QXJlYTogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgaWYgKG9wdCAmJiBvcHQudXNlTW9kZWxHZW9tZXRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0QkJveCgpIHx8IG5ldyBSZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVih0aGlzLmNlbGxzKS5nZXRCQm94KCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29udGVudCBiYm94IGluIHRoZSBwYXBlciB1bml0cyAoYXMgaXQgYXBwZWFycyBvbiBzY3JlZW4pLlxuICAgIGdldENvbnRlbnRCQm94OiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFRvUGFwZXJSZWN0KHRoaXMuZ2V0Q29udGVudEFyZWEob3B0KSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBnZW9tZXRyeSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIHRoZSBlbnRpcmVcbiAgICAvLyBwYXBlciBhcmVhIChjb29yZGluYXRlcyBmcm9tIHRoZSBsZWZ0IHBhcGVyIGJvcmRlciB0byB0aGUgcmlnaHQgb25lXG4gICAgLy8gYW5kIHRoZSB0b3AgYm9yZGVyIHRvIHRoZSBib3R0b20gb25lKS5cbiAgICBnZXRBcmVhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wYXBlclRvTG9jYWxSZWN0KHRoaXMuZ2V0Q29tcHV0ZWRTaXplKCkpO1xuICAgIH0sXG5cbiAgICBnZXRSZXN0cmljdGVkQXJlYTogZnVuY3Rpb24oLi4uYXJncykge1xuXG4gICAgICAgIGNvbnN0IHsgcmVzdHJpY3RUcmFuc2xhdGUgfSA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBsZXQgcmVzdHJpY3RlZEFyZWE7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHJlc3RyaWN0VHJhbnNsYXRlKSkge1xuICAgICAgICAgICAgLy8gQSBtZXRob2QgcmV0dXJuaW5nIGEgYm91bmRpbmcgYm94XG4gICAgICAgICAgICByZXN0cmljdGVkQXJlYSA9IHJlc3RyaWN0VHJhbnNsYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3RyaWN0VHJhbnNsYXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgcGFwZXIgYXJlYVxuICAgICAgICAgICAgcmVzdHJpY3RlZEFyZWEgPSB0aGlzLmdldEFyZWEoKTtcbiAgICAgICAgfSBlbHNlIGlmICghcmVzdHJpY3RUcmFuc2xhdGUpIHtcbiAgICAgICAgICAgIC8vIGZhbHN5IHZhbHVlXG4gICAgICAgICAgICByZXN0cmljdGVkQXJlYSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBhbnkgb3RoZXIgdmFsdWVcbiAgICAgICAgICAgIHJlc3RyaWN0ZWRBcmVhID0gbmV3IFJlY3QocmVzdHJpY3RUcmFuc2xhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3RyaWN0ZWRBcmVhO1xuICAgIH0sXG5cbiAgICBjcmVhdGVWaWV3Rm9yTW9kZWw6IGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIC8vIEEgY2xhc3MgdGFrZW4gZnJvbSB0aGUgcGFwZXIgb3B0aW9ucy5cbiAgICAgICAgdmFyIG9wdGlvbmFsVmlld0NsYXNzO1xuXG4gICAgICAgIC8vIEEgZGVmYXVsdCBiYXNpYyBjbGFzcyAoZWl0aGVyIGRpYS5FbGVtZW50VmlldyBvciBkaWEuTGlua1ZpZXcpXG4gICAgICAgIHZhciBkZWZhdWx0Vmlld0NsYXNzO1xuXG4gICAgICAgIC8vIEEgc3BlY2lhbCBjbGFzcyBkZWZpbmVkIGZvciB0aGlzIG1vZGVsIGluIHRoZSBjb3JyZXNwb25kaW5nIG5hbWVzcGFjZS5cbiAgICAgICAgLy8gZS5nLiBqb2ludC5zaGFwZXMuc3RhbmRhcmQuUmVjdGFuZ2xlIHNlYXJjaGVzIGZvciBqb2ludC5zaGFwZXMuc3RhbmRhcmQuUmVjdGFuZ2xlVmlld1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gb3B0aW9ucy5jZWxsVmlld05hbWVzcGFjZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjZWxsLmdldCgndHlwZScpICsgJ1ZpZXcnO1xuICAgICAgICB2YXIgbmFtZXNwYWNlVmlld0NsYXNzID0gZ2V0QnlQYXRoKG5hbWVzcGFjZSwgdHlwZSwgJy4nKTtcblxuICAgICAgICBpZiAoY2VsbC5pc0xpbmsoKSkge1xuICAgICAgICAgICAgb3B0aW9uYWxWaWV3Q2xhc3MgPSBvcHRpb25zLmxpbmtWaWV3O1xuICAgICAgICAgICAgZGVmYXVsdFZpZXdDbGFzcyA9IExpbmtWaWV3O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9uYWxWaWV3Q2xhc3MgPSBvcHRpb25zLmVsZW1lbnRWaWV3O1xuICAgICAgICAgICAgZGVmYXVsdFZpZXdDbGFzcyA9IEVsZW1lbnRWaWV3O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYSkgdGhlIHBhcGVyIG9wdGlvbnMgdmlldyBpcyBhIGNsYXNzIChkZXByZWNhdGVkKVxuICAgICAgICAvLyAgMS4gc2VhcmNoIHRoZSBuYW1lc3BhY2UgZm9yIGEgdmlld1xuICAgICAgICAvLyAgMi4gaWYgbm8gdmlldyB3YXMgZm91bmQsIHVzZSB2aWV3IGZyb20gdGhlIHBhcGVyIG9wdGlvbnNcbiAgICAgICAgLy8gYikgdGhlIHBhcGVyIG9wdGlvbnMgdmlldyBpcyBhIGZ1bmN0aW9uXG4gICAgICAgIC8vICAxLiBjYWxsIHRoZSBmdW5jdGlvbiBmcm9tIHRoZSBwYXBlciBvcHRpb25zXG4gICAgICAgIC8vICAyLiBpZiBubyB2aWV3IHdhcyByZXR1cm4sIHNlYXJjaCB0aGUgbmFtZXNwYWNlIGZvciBhIHZpZXdcbiAgICAgICAgLy8gIDMuIGlmIG5vIHZpZXcgd2FzIGZvdW5kLCB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgdmFyIFZpZXdDbGFzcyA9IChvcHRpb25hbFZpZXdDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBWaWV3QmFzZSlcbiAgICAgICAgICAgID8gbmFtZXNwYWNlVmlld0NsYXNzIHx8IG9wdGlvbmFsVmlld0NsYXNzXG4gICAgICAgICAgICA6IG9wdGlvbmFsVmlld0NsYXNzLmNhbGwodGhpcywgY2VsbCkgfHwgbmFtZXNwYWNlVmlld0NsYXNzIHx8IGRlZmF1bHRWaWV3Q2xhc3M7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q2xhc3Moe1xuICAgICAgICAgICAgbW9kZWw6IGNlbGwsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogb3B0aW9ucy5pbnRlcmFjdGl2ZSxcbiAgICAgICAgICAgIGxhYmVsc0xheWVyOiBvcHRpb25zLmxhYmVsc0xheWVyID09PSB0cnVlID8gTGF5ZXJzTmFtZXMuTEFCRUxTIDogb3B0aW9ucy5sYWJlbHNMYXllclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVmlldzogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IGNlbGw7XG4gICAgICAgIGNvbnN0IHsgX3ZpZXdzLCBfdXBkYXRlcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdmlldyA9IF92aWV3c1tpZF07XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2YXIgeyBjaWQgfSA9IHZpZXc7XG4gICAgICAgICAgICBjb25zdCB7IG1vdW50ZWQsIHVubW91bnRlZCB9ID0gX3VwZGF0ZXM7XG4gICAgICAgICAgICB2aWV3LnJlbW92ZSgpO1xuICAgICAgICAgICAgZGVsZXRlIF92aWV3c1tpZF07XG4gICAgICAgICAgICBkZWxldGUgbW91bnRlZFtjaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHVubW91bnRlZFtjaWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH0sXG5cbiAgICByZW5kZXJWaWV3OiBmdW5jdGlvbihjZWxsLCBvcHQpIHtcblxuICAgICAgICBjb25zdCB7IGlkIH0gPSBjZWxsO1xuICAgICAgICBjb25zdCB2aWV3cyA9IHRoaXMuX3ZpZXdzO1xuICAgICAgICBsZXQgdmlldywgZmxhZztcbiAgICAgICAgbGV0IGNyZWF0ZSA9IHRydWU7XG4gICAgICAgIGlmIChpZCBpbiB2aWV3cykge1xuICAgICAgICAgICAgdmlldyA9IHZpZXdzW2lkXTtcbiAgICAgICAgICAgIGlmICh2aWV3Lm1vZGVsID09PSBjZWxsKSB7XG4gICAgICAgICAgICAgICAgZmxhZyA9IHZpZXcuRkxBR19JTlNFUlQ7XG4gICAgICAgICAgICAgICAgY3JlYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB2aWV3IGZvciB0aGlzIGBpZGAgYWxyZWFkeSBleGlzdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgY2VsbCBpcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgbW9kZWwgd2l0aCBpZGVudGljYWwgaWRcbiAgICAgICAgICAgICAgICAvLyBXZSBzaW1wbHkgcmVtb3ZlIHRoZSBleGlzdGluZyB2aWV3IGFuZCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVWaWV3KGNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgIHZpZXcgPSB2aWV3c1tpZF0gPSB0aGlzLmNyZWF0ZVZpZXdGb3JNb2RlbChjZWxsKTtcbiAgICAgICAgICAgIHZpZXcucGFwZXIgPSB0aGlzO1xuICAgICAgICAgICAgZmxhZyA9IHRoaXMucmVnaXN0ZXJVbm1vdW50ZWRWaWV3KHZpZXcpIHwgdGhpcy5GTEFHX0lOSVQgfCB2aWV3LmdldEZsYWcocmVzdWx0KHZpZXcsICdpbml0RmxhZycpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3RWaWV3VXBkYXRlKHZpZXcsIGZsYWcsIHZpZXcuVVBEQVRFX1BSSU9SSVRZLCBvcHQpO1xuICAgICAgICByZXR1cm4gdmlldztcbiAgICB9LFxuXG4gICAgb25JbWFnZURyYWdTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHByZXZlbnQgaW1hZ2UgZHJhZ2dpbmcgaW4gRmlyZWZveCB0aGF0IHdvcmtzLlxuICAgICAgICAvLyBTZXR0aW5nIC1tb3otdXNlci1zZWxlY3Q6IG5vbmUsIGRyYWdnYWJsZT1cImZhbHNlXCIgYXR0cmlidXRlIG9yIHVzZXItZHJhZzogbm9uZSBkaWRuJ3QgaGVscC5cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc2V0Vmlld3M6IGZ1bmN0aW9uKGNlbGxzLCBvcHQpIHtcbiAgICAgICAgb3B0IHx8IChvcHQgPSB7fSk7XG4gICAgICAgIGNlbGxzIHx8IChjZWxscyA9IFtdKTtcbiAgICAgICAgdGhpcy5fcmVzZXRVcGRhdGVzKCk7XG4gICAgICAgIC8vIGNsZWFyaW5nIHZpZXdzIHJlbW92ZXMgYW55IGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZVZpZXdzKCk7XG4gICAgICAgIC8vIEFsbG93cyB0byB1bmZyZWV6ZSBub3JtYWxseSB3aGlsZSBpbiB0aGUgaWRsZSBzdGF0ZSB1c2luZyBhdXRvRnJlZXplIG9wdGlvblxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLm9wdGlvbnMuYXV0b0ZyZWV6ZSA/IG51bGwgOiAncmVzZXQnO1xuICAgICAgICB0aGlzLmZyZWV6ZSh7IGtleSB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhjZWxsc1tpXSwgb3B0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuZnJlZXplKHsga2V5IH0pO1xuICAgICAgICB0aGlzLnNvcnRWaWV3cygpO1xuICAgIH0sXG5cbiAgICByZW1vdmVWaWV3czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaW52b2tlKHRoaXMuX3ZpZXdzLCAncmVtb3ZlJyk7XG5cbiAgICAgICAgdGhpcy5fdmlld3MgPSB7fTtcbiAgICB9LFxuXG4gICAgc29ydFZpZXdzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNFeGFjdFNvcnRpbmcoKSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRnJvemVuKCkpIHtcbiAgICAgICAgICAgIC8vIHNvcnQgdmlld3Mgb25jZSB1bmZyb3plblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlcy5zb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvcnRWaWV3c0V4YWN0KCk7XG4gICAgfSxcblxuICAgIHNvcnRWaWV3c0V4YWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyBSdW4gaW5zZXJ0aW9uIHNvcnQgYWxnb3JpdGhtIGluIG9yZGVyIHRvIGVmZmljaWVudGx5IHNvcnQgRE9NIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGVpclxuICAgICAgICAvLyBhc3NvY2lhdGVkIG1vZGVsIGB6YCBhdHRyaWJ1dGUuXG5cbiAgICAgICAgdmFyIGNlbGxOb2RlcyA9IEFycmF5LmZyb20odGhpcy5jZWxscy5jaGlsZE5vZGVzKS5maWx0ZXIobm9kZSA9PiBub2RlLmdldEF0dHJpYnV0ZSgnbW9kZWwtaWQnKSk7XG4gICAgICAgIHZhciBjZWxscyA9IHRoaXMubW9kZWwuZ2V0KCdjZWxscycpO1xuXG4gICAgICAgIHNvcnRFbGVtZW50cyhjZWxsTm9kZXMsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBjZWxsQSA9IGNlbGxzLmdldChhLmdldEF0dHJpYnV0ZSgnbW9kZWwtaWQnKSk7XG4gICAgICAgICAgICB2YXIgY2VsbEIgPSBjZWxscy5nZXQoYi5nZXRBdHRyaWJ1dGUoJ21vZGVsLWlkJykpO1xuICAgICAgICAgICAgdmFyIHpBID0gY2VsbEEuYXR0cmlidXRlcy56IHx8IDA7XG4gICAgICAgICAgICB2YXIgekIgPSBjZWxsQi5hdHRyaWJ1dGVzLnogfHwgMDtcbiAgICAgICAgICAgIHJldHVybiAoekEgPT09IHpCKSA/IDAgOiAoekEgPCB6QikgPyAtMSA6IDE7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbnNlcnRWaWV3OiBmdW5jdGlvbih2aWV3LCBpc0luaXRpYWxJbnNlcnQpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJWaWV3ID0gdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuQ0VMTFMpO1xuICAgICAgICBjb25zdCB7IGVsLCBtb2RlbCB9ID0gdmlldztcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuc29ydGluZykge1xuICAgICAgICAgICAgY2FzZSBzb3J0aW5nVHlwZXMuQVBQUk9YOlxuICAgICAgICAgICAgICAgIGxheWVyVmlldy5pbnNlcnRTb3J0ZWROb2RlKGVsLCBtb2RlbC5nZXQoJ3onKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvcnRpbmdUeXBlcy5FWEFDVDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGF5ZXJWaWV3Lmluc2VydE5vZGUoZWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcub25Nb3VudChpc0luaXRpYWxJbnNlcnQpO1xuICAgIH0sXG5cbiAgICBkZXRhY2hWaWV3KHZpZXcpIHtcbiAgICAgICAgdmlldy51bm1vdW50KCk7XG4gICAgICAgIHZpZXcub25EZXRhY2goKTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgdmlldyBjbGltYmluZyB1cCB0aGUgRE9NIHRyZWUgc3RhcnRpbmcgYXQgZWxlbWVudCBgZWxgLiBOb3RlIHRoYXQgYGVsYCBjYW4gYWxzb1xuICAgIC8vIGJlIGEgc2VsZWN0b3Igb3IgYSBqUXVlcnkgb2JqZWN0LlxuICAgIGZpbmRWaWV3OiBmdW5jdGlvbigkZWwpIHtcblxuICAgICAgICB2YXIgZWwgPSBpc1N0cmluZygkZWwpXG4gICAgICAgICAgICA/IHRoaXMuY2VsbHMucXVlcnlTZWxlY3RvcigkZWwpXG4gICAgICAgICAgICA6ICRlbCBpbnN0YW5jZW9mICQgPyAkZWxbMF0gOiAkZWw7XG5cbiAgICAgICAgdmFyIGlkID0gdGhpcy5maW5kQXR0cmlidXRlKCdtb2RlbC1pZCcsIGVsKTtcbiAgICAgICAgaWYgKGlkKSByZXR1cm4gdGhpcy5fdmlld3NbaWRdO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgYSB2aWV3IGZvciBhIG1vZGVsIGBjZWxsYC4gYGNlbGxgIGNhbiBhbHNvIGJlIGEgc3RyaW5nIG9yIG51bWJlciByZXByZXNlbnRpbmcgYSBtb2RlbCBgaWRgLlxuICAgIGZpbmRWaWV3QnlNb2RlbDogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgICAgIHZhciBpZCA9IChpc1N0cmluZyhjZWxsKSB8fCBpc051bWJlcihjZWxsKSkgPyBjZWxsIDogKGNlbGwgJiYgY2VsbC5pZCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdzW2lkXTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbGwgdmlld3MgYXQgZ2l2ZW4gcG9pbnRcbiAgICBmaW5kVmlld3NGcm9tUG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuXG4gICAgICAgIHZhciB2aWV3cyA9IHRoaXMubW9kZWwuZ2V0RWxlbWVudHMoKS5tYXAodGhpcy5maW5kVmlld0J5TW9kZWwsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB2aWV3cy5maWx0ZXIoZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcgJiYgdmlldy52ZWwuZ2V0QkJveCh7IHRhcmdldDogdGhpcy5jZWxscyB9KS5jb250YWluc1BvaW50KHApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gRmluZCBhbGwgdmlld3MgaW4gZ2l2ZW4gYXJlYVxuICAgIGZpbmRWaWV3c0luQXJlYTogZnVuY3Rpb24ocmVjdCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gZGVmYXVsdHMob3B0IHx8IHt9LCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0KTtcblxuICAgICAgICB2YXIgdmlld3MgPSB0aGlzLm1vZGVsLmdldEVsZW1lbnRzKCkubWFwKHRoaXMuZmluZFZpZXdCeU1vZGVsLCB0aGlzKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdC5zdHJpY3QgPyAnY29udGFpbnNSZWN0JyA6ICdpbnRlcnNlY3QnO1xuXG4gICAgICAgIHJldHVybiB2aWV3cy5maWx0ZXIoZnVuY3Rpb24odmlldykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXcgJiYgcmVjdFttZXRob2RdKHZpZXcudmVsLmdldEJCb3goeyB0YXJnZXQ6IHRoaXMuY2VsbHMgfSkpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZmluZEVsZW1lbnRWaWV3c0luQXJlYShwbGFpbkFyZWEsIG9wdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyVmlld3NJbkFyZWEoXG4gICAgICAgICAgICBwbGFpbkFyZWEsXG4gICAgICAgICAgICAoZXh0QXJlYSwgZmluZE9wdCkgPT4gdGhpcy5tb2RlbC5maW5kRWxlbWVudHNJbkFyZWEoZXh0QXJlYSwgZmluZE9wdCksXG4gICAgICAgICAgICBvcHRcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZmluZExpbmtWaWV3c0luQXJlYTogZnVuY3Rpb24ocGxhaW5BcmVhLCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclZpZXdzSW5BcmVhKFxuICAgICAgICAgICAgcGxhaW5BcmVhLFxuICAgICAgICAgICAgKGV4dEFyZWEsIGZpbmRPcHQpID0+IHRoaXMubW9kZWwuZmluZExpbmtzSW5BcmVhKGV4dEFyZWEsIGZpbmRPcHQpLFxuICAgICAgICAgICAgb3B0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZpbmRDZWxsVmlld3NJbkFyZWE6IGZ1bmN0aW9uKHBsYWluQXJlYSwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJWaWV3c0luQXJlYShcbiAgICAgICAgICAgIHBsYWluQXJlYSxcbiAgICAgICAgICAgIChleHRBcmVhLCBmaW5kT3B0KSA9PiB0aGlzLm1vZGVsLmZpbmRDZWxsc0luQXJlYShleHRBcmVhLCBmaW5kT3B0KSxcbiAgICAgICAgICAgIG9wdFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBmaW5kRWxlbWVudFZpZXdzQXRQb2ludDogZnVuY3Rpb24ocGxhaW5Qb2ludCwgb3B0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJWaWV3c0F0UG9pbnQoXG4gICAgICAgICAgICBwbGFpblBvaW50LFxuICAgICAgICAgICAgKGV4dEFyZWEpID0+IHRoaXMubW9kZWwuZmluZEVsZW1lbnRzSW5BcmVhKGV4dEFyZWEpLFxuICAgICAgICAgICAgb3B0XG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZpbmRMaW5rVmlld3NBdFBvaW50OiBmdW5jdGlvbihwbGFpblBvaW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclZpZXdzQXRQb2ludChcbiAgICAgICAgICAgIHBsYWluUG9pbnQsXG4gICAgICAgICAgICAoZXh0QXJlYSkgPT4gdGhpcy5tb2RlbC5maW5kTGlua3NJbkFyZWEoZXh0QXJlYSksXG4gICAgICAgICAgICBvcHQsXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIGZpbmRDZWxsVmlld3NBdFBvaW50OiBmdW5jdGlvbihwbGFpblBvaW50LCBvcHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclZpZXdzQXRQb2ludChcbiAgICAgICAgICAgIHBsYWluUG9pbnQsXG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBkbyBub3Qgd2FudCB0byBwYXNzIGBvcHRgIHRvIGBmaW5kQ2VsbHNJbkFyZWFgXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBgc3RyaWN0YCBvcHRpb24gd29ya3MgZGlmZmVyZW50bHkgZm9yIHF1ZXJ5aW5nIGF0IGEgcG9pbnRcbiAgICAgICAgICAgIChleHRBcmVhKSA9PiB0aGlzLm1vZGVsLmZpbmRDZWxsc0luQXJlYShleHRBcmVhKSxcbiAgICAgICAgICAgIG9wdFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfZmluZEluRXh0ZW5kZWRBcmVhOiBmdW5jdGlvbihhcmVhLCBmaW5kQ2VsbHNGbiwgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYnVmZmVyID0gdGhpcy5ERUZBVUxUX0ZJTkRfQlVGRkVSLFxuICAgICAgICB9ID0gb3B0O1xuICAgICAgICBjb25zdCBleHRlbmRlZEFyZWEgPSAobmV3IFJlY3QoYXJlYSkpLmluZmxhdGUoYnVmZmVyKTtcbiAgICAgICAgY29uc3QgY2VsbHNJbkV4dGVuZGVkQXJlYSA9IGZpbmRDZWxsc0ZuKGV4dGVuZGVkQXJlYSwgb3B0KTtcbiAgICAgICAgcmV0dXJuIGNlbGxzSW5FeHRlbmRlZEFyZWEubWFwKGVsZW1lbnQgPT4gdGhpcy5maW5kVmlld0J5TW9kZWwoZWxlbWVudCkpO1xuICAgIH0sXG5cbiAgICBfZmlsdGVyVmlld3NJbkFyZWE6IGZ1bmN0aW9uKHBsYWluQXJlYSwgZmluZENlbGxzLCBvcHQgPSB7fSkge1xuICAgICAgICBjb25zdCBhcmVhID0gbmV3IFJlY3QocGxhaW5BcmVhKTtcbiAgICAgICAgY29uc3Qgdmlld3NJbkV4dGVuZGVkQXJlYSA9IHRoaXMuX2ZpbmRJbkV4dGVuZGVkQXJlYShhcmVhLCBmaW5kQ2VsbHMsIG9wdCk7XG4gICAgICAgIGNvbnN0IHZpZXdzSW5BcmVhID0gdmlld3NJbkV4dGVuZGVkQXJlYS5maWx0ZXIodmlldyA9PiB7XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmlzSW5BcmVhKGFyZWEsIG9wdCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmlld3NJbkFyZWE7XG4gICAgfSxcblxuICAgIF9maWx0ZXJWaWV3c0F0UG9pbnQ6IGZ1bmN0aW9uKHBsYWluUG9pbnQsIGZpbmRDZWxscywgb3B0ID0ge30pIHtcbiAgICAgICAgY29uc3QgYXJlYSA9IG5ldyBSZWN0KHBsYWluUG9pbnQpOyAvLyB6ZXJvLXNpemUgYXJlYVxuICAgICAgICBjb25zdCB2aWV3c0luRXh0ZW5kZWRBcmVhID0gdGhpcy5fZmluZEluRXh0ZW5kZWRBcmVhKGFyZWEsIGZpbmRDZWxscywgb3B0KTtcbiAgICAgICAgY29uc3Qgdmlld3NBdFBvaW50ID0gdmlld3NJbkV4dGVuZGVkQXJlYS5maWx0ZXIodmlldyA9PiB7XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB2aWV3LmlzQXRQb2ludChwbGFpblBvaW50LCBvcHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZpZXdzQXRQb2ludDtcbiAgICB9LFxuXG4gICAgcmVtb3ZlVG9vbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoVG9vbHNFdmVudCgncmVtb3ZlJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBoaWRlVG9vbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoVG9vbHNFdmVudCgnaGlkZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2hvd1Rvb2xzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRvb2xzRXZlbnQoJ3Nob3cnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoVG9vbHNFdmVudDogZnVuY3Rpb24oZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0b29sczpldmVudCcsIGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9LFxuXG5cbiAgICBnZXRNb2RlbEJ5SWQ6IGZ1bmN0aW9uKGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZ2V0Q2VsbChpZCk7XG4gICAgfSxcblxuICAgIHNuYXBUb0dyaWQ6IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICAvLyBDb252ZXJ0IGdsb2JhbCBjb29yZGluYXRlcyB0byB0aGUgbG9jYWwgb25lcyBvZiB0aGUgYHZpZXdwb3J0YC4gT3RoZXJ3aXNlLFxuICAgICAgICAvLyBpbXByb3BlciB0cmFuc2Zvcm1hdGlvbiB3b3VsZCBiZSBhcHBsaWVkIHdoZW4gdGhlIHZpZXdwb3J0IGdldHMgdHJhbnNmb3JtZWQgKHNjYWxlZC9yb3RhdGVkKS5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50VG9Mb2NhbFBvaW50KHgsIHkpLnNuYXBUb0dyaWQodGhpcy5vcHRpb25zLmdyaWRTaXplKTtcbiAgICB9LFxuXG4gICAgbG9jYWxUb1BhcGVyUG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcG9pbnQgYW5kIGB5YCB1bmRlZmluZWRcbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHZhciBwYXBlclBvaW50ID0gVi50cmFuc2Zvcm1Qb2ludChsb2NhbFBvaW50LCB0aGlzLm1hdHJpeCgpKTtcbiAgICAgICAgcmV0dXJuIHBhcGVyUG9pbnQ7XG4gICAgfSxcblxuICAgIGxvY2FsVG9QYXBlclJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcmVjdGFuZ2xlIGFuZCByZXN0IGFyZ3VtZW50cyB1bmRlZmluZWRcbiAgICAgICAgdmFyIGxvY2FsUmVjdCA9IG5ldyBSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgcGFwZXJSZWN0ID0gVi50cmFuc2Zvcm1SZWN0KGxvY2FsUmVjdCwgdGhpcy5tYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBwYXBlclJlY3Q7XG4gICAgfSxcblxuICAgIHBhcGVyVG9Mb2NhbFBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIC8vIGFsbG93IGB4YCB0byBiZSBhIHBvaW50IGFuZCBgeWAgdW5kZWZpbmVkXG4gICAgICAgIHZhciBwYXBlclBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IFYudHJhbnNmb3JtUG9pbnQocGFwZXJQb2ludCwgdGhpcy5tYXRyaXgoKS5pbnZlcnNlKCkpO1xuICAgICAgICByZXR1cm4gbG9jYWxQb2ludDtcbiAgICB9LFxuXG4gICAgcGFwZXJUb0xvY2FsUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSByZWN0YW5nbGUgYW5kIHJlc3QgYXJndW1lbnRzIHVuZGVmaW5lZFxuICAgICAgICB2YXIgcGFwZXJSZWN0ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBsb2NhbFJlY3QgPSBWLnRyYW5zZm9ybVJlY3QocGFwZXJSZWN0LCB0aGlzLm1hdHJpeCgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBsb2NhbFJlY3Q7XG4gICAgfSxcblxuICAgIGxvY2FsVG9DbGllbnRQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSBwb2ludCBhbmQgYHlgIHVuZGVmaW5lZFxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgdmFyIGNsaWVudFBvaW50ID0gVi50cmFuc2Zvcm1Qb2ludChsb2NhbFBvaW50LCB0aGlzLmNsaWVudE1hdHJpeCgpKTtcbiAgICAgICAgcmV0dXJuIGNsaWVudFBvaW50O1xuICAgIH0sXG5cbiAgICBsb2NhbFRvQ2xpZW50UmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSBwb2ludCBhbmQgYHlgIHVuZGVmaW5lZFxuICAgICAgICB2YXIgbG9jYWxSZWN0ID0gbmV3IFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBjbGllbnRSZWN0ID0gVi50cmFuc2Zvcm1SZWN0KGxvY2FsUmVjdCwgdGhpcy5jbGllbnRNYXRyaXgoKSk7XG4gICAgICAgIHJldHVybiBjbGllbnRSZWN0O1xuICAgIH0sXG5cbiAgICAvLyBUcmFuc2Zvcm0gY2xpZW50IGNvb3JkaW5hdGVzIHRvIHRoZSBwYXBlciBsb2NhbCBjb29yZGluYXRlcy5cbiAgICAvLyBVc2VmdWwgd2hlbiB5b3UgaGF2ZSBhIG1vdXNlIGV2ZW50IG9iamVjdCBhbmQgeW91J2QgbGlrZSB0byBnZXQgY29vcmRpbmF0ZXNcbiAgICAvLyBpbnNpZGUgdGhlIHBhcGVyIHRoYXQgY29ycmVzcG9uZCB0byBgZXZ0LmNsaWVudFhgIGFuZCBgZXZ0LmNsaWVudFlgIHBvaW50LlxuICAgIC8vIEV4YW1wbGU6IHZhciBsb2NhbFBvaW50ID0gcGFwZXIuY2xpZW50VG9Mb2NhbFBvaW50KHsgeDogZXZ0LmNsaWVudFgsIHk6IGV2dC5jbGllbnRZIH0pO1xuICAgIGNsaWVudFRvTG9jYWxQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAvLyBhbGxvdyBgeGAgdG8gYmUgYSBwb2ludCBhbmQgYHlgIHVuZGVmaW5lZFxuICAgICAgICB2YXIgY2xpZW50UG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gVi50cmFuc2Zvcm1Qb2ludChjbGllbnRQb2ludCwgdGhpcy5jbGllbnRNYXRyaXgoKS5pbnZlcnNlKCkpO1xuICAgICAgICByZXR1cm4gbG9jYWxQb2ludDtcbiAgICB9LFxuXG4gICAgY2xpZW50VG9Mb2NhbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gYWxsb3cgYHhgIHRvIGJlIGEgcG9pbnQgYW5kIGB5YCB1bmRlZmluZWRcbiAgICAgICAgdmFyIGNsaWVudFJlY3QgPSBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGxvY2FsUmVjdCA9IFYudHJhbnNmb3JtUmVjdChjbGllbnRSZWN0LCB0aGlzLmNsaWVudE1hdHJpeCgpLmludmVyc2UoKSk7XG4gICAgICAgIHJldHVybiBsb2NhbFJlY3Q7XG4gICAgfSxcblxuICAgIGxvY2FsVG9QYWdlUG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFRvUGFwZXJQb2ludCh4LCB5KS5vZmZzZXQodGhpcy5wYWdlT2Zmc2V0KCkpO1xuICAgIH0sXG5cbiAgICBsb2NhbFRvUGFnZVJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbFRvUGFwZXJSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpLm9mZnNldCh0aGlzLnBhZ2VPZmZzZXQoKSk7XG4gICAgfSxcblxuICAgIHBhZ2VUb0xvY2FsUG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgICAgICB2YXIgcGFnZVBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB2YXIgcGFwZXJQb2ludCA9IHBhZ2VQb2ludC5kaWZmZXJlbmNlKHRoaXMucGFnZU9mZnNldCgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFwZXJUb0xvY2FsUG9pbnQocGFwZXJQb2ludCk7XG4gICAgfSxcblxuICAgIHBhZ2VUb0xvY2FsUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gdGhpcy5wYWdlT2Zmc2V0KCk7XG4gICAgICAgIHZhciBwYXBlclJlY3QgPSBuZXcgUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcGFwZXJSZWN0LnggLT0gcGFnZU9mZnNldC54O1xuICAgICAgICBwYXBlclJlY3QueSAtPSBwYWdlT2Zmc2V0Lnk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcGVyVG9Mb2NhbFJlY3QocGFwZXJSZWN0KTtcbiAgICB9LFxuXG4gICAgY2xpZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IHRoaXMuc3ZnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGNsaWVudFJlY3QubGVmdCwgY2xpZW50UmVjdC50b3ApO1xuICAgIH0sXG5cbiAgICBwYWdlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPZmZzZXQoKS5vZmZzZXQod2luZG93LnNjcm9sbFgsIHdpbmRvdy5zY3JvbGxZKTtcbiAgICB9LFxuXG4gICAgbGlua0FsbG93ZWQ6IGZ1bmN0aW9uKGxpbmtWaWV3KSB7XG5cbiAgICAgICAgaWYgKCEobGlua1ZpZXcgaW5zdGFuY2VvZiBMaW5rVmlldykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgbGlua1ZpZXcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluayA9IGxpbmtWaWV3Lm1vZGVsO1xuICAgICAgICB2YXIgcGFwZXJPcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLm1vZGVsO1xuICAgICAgICB2YXIgbnMgPSBncmFwaC5jb25zdHJ1Y3Rvci52YWxpZGF0aW9ucztcblxuICAgICAgICBpZiAoIXBhcGVyT3B0aW9ucy5tdWx0aUxpbmtzKSB7XG4gICAgICAgICAgICBpZiAoIW5zLm11bHRpTGlua3MuY2FsbCh0aGlzLCBncmFwaCwgbGluaykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFwZXJPcHRpb25zLmxpbmtQaW5uaW5nKSB7XG4gICAgICAgICAgICAvLyBMaW5rIHBpbm5pbmcgaXMgbm90IGFsbG93ZWQgYW5kIHRoZSBsaW5rIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHRhcmdldC5cbiAgICAgICAgICAgIGlmICghbnMubGlua1Bpbm5pbmcuY2FsbCh0aGlzLCBncmFwaCwgbGluaykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcGFwZXJPcHRpb25zLmFsbG93TGluayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCFwYXBlck9wdGlvbnMuYWxsb3dMaW5rLmNhbGwodGhpcywgbGlua1ZpZXcsIHRoaXMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdExpbms6IGZ1bmN0aW9uKGNlbGxWaWV3LCBtYWduZXQpIHtcblxuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuZGVmYXVsdExpbmspXG4gICAgICAgIC8vIGRlZmF1bHQgbGluayBpcyBhIGZ1bmN0aW9uIHByb2R1Y2luZyBsaW5rIG1vZGVsXG4gICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5kZWZhdWx0TGluay5jYWxsKHRoaXMsIGNlbGxWaWV3LCBtYWduZXQpXG4gICAgICAgIC8vIGRlZmF1bHQgbGluayBpcyB0aGUgbXZjIG1vZGVsXG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5kZWZhdWx0TGluay5jbG9uZSgpO1xuICAgIH0sXG5cbiAgICAvLyBDZWxsIGhpZ2hsaWdodGluZy5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHJlc29sdmVIaWdobGlnaHRlcjogZnVuY3Rpb24ob3B0ID0ge30pIHtcblxuICAgICAgICBsZXQgeyBoaWdobGlnaHRlcjogaGlnaGxpZ2h0ZXJEZWYsIHR5cGUgfSA9IG9wdDtcbiAgICAgICAgY29uc3QgeyBoaWdobGlnaHRpbmcsaGlnaGxpZ2h0ZXJOYW1lc3BhY2UgIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIEV4cGVjdGluZyBvcHQuaGlnaGxpZ2h0ZXIgdG8gaGF2ZSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnaGlnaGxpZ2h0ZXItbmFtZScsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBzb21lOiAndmFsdWUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBpZiAoaGlnaGxpZ2h0ZXJEZWYgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAvLyBJcyBoaWdobGlnaHRpbmcgZGlzYWJsZWQ/XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGJ1aWx0LWluIHR5cGVzXG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVyRGVmID0gaGlnaGxpZ2h0aW5nW3R5cGVdO1xuICAgICAgICAgICAgICAgIC8vIElzIGEgc3BlY2lmaWMgdHlwZSBoaWdobGlnaHQgZGlzYWJsZWQ/XG4gICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodGVyRGVmID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlckRlZikge1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgbm90IGRlZmluZWQgdXNlIGRlZmF1bHQgaGlnaGxpZ2h0XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZXJEZWYgPSBoaWdobGlnaHRpbmdbJ2RlZmF1bHQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgb3B0LmhpZ2hsaWdodGVyIGlzIGZhbHN5LlxuICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgY2FzZSB0byBub3QgaGlnaGxpZ2h0IGNlbGwocykgaW4gY2VydGFpbiBjYXNlcy5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIE5PVCBoaWdobGlnaHQgd2hlbiBlbWJlZGRpbmcgZWxlbWVudHNcbiAgICAgICAgLy8gb3IgdXNlIGEgY3VzdG9tIGhpZ2hsaWdodGVyLlxuICAgICAgICBpZiAoIWhpZ2hsaWdodGVyRGVmKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gQWxsb3cgc3BlY2lmeWluZyBhIGhpZ2hsaWdodGVyIGJ5IG5hbWUuXG4gICAgICAgIGlmIChpc1N0cmluZyhoaWdobGlnaHRlckRlZikpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodGVyRGVmID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGhpZ2hsaWdodGVyRGVmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IGhpZ2hsaWdodGVyRGVmLm5hbWU7XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVyID0gaGlnaGxpZ2h0ZXJOYW1lc3BhY2VbbmFtZV07XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0ZXIgdmFsaWRhdGlvblxuICAgICAgICBpZiAoIWhpZ2hsaWdodGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaGlnaGxpZ2h0ZXIgKFwiJyArIG5hbWUgKyAnXCIpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoaWdobGlnaHRlci5oaWdobGlnaHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGlnaGxpZ2h0ZXIgKFwiJyArIG5hbWUgKyAnXCIpIGlzIG1pc3NpbmcgcmVxdWlyZWQgaGlnaGxpZ2h0KCkgbWV0aG9kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoaWdobGlnaHRlci51bmhpZ2hsaWdodCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIaWdobGlnaHRlciAoXCInICsgbmFtZSArICdcIikgaXMgbWlzc2luZyByZXF1aXJlZCB1bmhpZ2hsaWdodCgpIG1ldGhvZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodGVyLFxuICAgICAgICAgICAgb3B0aW9uczogaGlnaGxpZ2h0ZXJEZWYub3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb25DZWxsSGlnaGxpZ2h0OiBmdW5jdGlvbihjZWxsVmlldywgbWFnbmV0RWwsIG9wdCkge1xuICAgICAgICBjb25zdCBoaWdobGlnaHRlckRlc2NyaXB0b3IgPSB0aGlzLnJlc29sdmVIaWdobGlnaHRlcihvcHQpO1xuICAgICAgICBpZiAoIWhpZ2hsaWdodGVyRGVzY3JpcHRvcikgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGhpZ2hsaWdodGVyLCBvcHRpb25zIH0gPSBoaWdobGlnaHRlckRlc2NyaXB0b3I7XG4gICAgICAgIGhpZ2hsaWdodGVyLmhpZ2hsaWdodChjZWxsVmlldywgbWFnbmV0RWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBvbkNlbGxVbmhpZ2hsaWdodDogZnVuY3Rpb24oY2VsbFZpZXcsIG1hZ25ldEVsLCBvcHQpIHtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yID0gdGhpcy5yZXNvbHZlSGlnaGxpZ2h0ZXIob3B0KTtcbiAgICAgICAgaWYgKCFoaWdobGlnaHRlckRlc2NyaXB0b3IpIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBoaWdobGlnaHRlciwgb3B0aW9ucyB9ID0gaGlnaGxpZ2h0ZXJEZXNjcmlwdG9yO1xuICAgICAgICBoaWdobGlnaHRlci51bmhpZ2hsaWdodChjZWxsVmlldywgbWFnbmV0RWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnRlcmFjdGlvbi5cbiAgICAvLyAtLS0tLS0tLS0tLS1cblxuICAgIHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gbWFnbmV0cG9pbnRlcmRibGNsaWNrIGNhbiBzdG9wIHByb3BhZ2F0aW9uXG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuZmluZFZpZXcoZXZ0LnRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcblxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB2aWV3LnBvaW50ZXJkYmxjbGljayhldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazpwb2ludGVyZGJsY2xpY2snLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2ludGVyY2xpY2s6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIC8vIG1hZ25ldHBvaW50ZXJjbGljayBjYW4gc3RvcCBwcm9wYWdhdGlvblxuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ldmVudERhdGEoZXZ0KTtcbiAgICAgICAgLy8gVHJpZ2dlciBldmVudCBvbmx5IGlmIG1vdXNlIGhhcyBub3QgbW92ZWQuXG4gICAgICAgIGlmIChkYXRhLm1vdXNlbW92ZWQgPD0gdGhpcy5vcHRpb25zLmNsaWNrVGhyZXNob2xkKSB7XG5cbiAgICAgICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcblxuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnBvaW50ZXJjbGljayhldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOnBvaW50ZXJjbGljaycsIGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRleHRtZW51OiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnRDb250ZXh0TWVudSkgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnVGaXJlZCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudUZpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVUcmlnZ2VyKGV2dCk7XG4gICAgfSxcblxuICAgIGNvbnRleHRNZW51VHJpZ2dlcjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5maW5kVmlldyhldnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMuZ3VhcmQoZXZ0LCB2aWV3KSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKGV2dC5jbGllbnRYLCBldnQuY2xpZW50WSk7XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcuY29udGV4dG1lbnUoZXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6Y29udGV4dG1lbnUnLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBwb2ludGVyZG93bjogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICBjb25zdCB7IHRhcmdldCwgYnV0dG9uIH0gPSBldnQ7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmZpbmRWaWV3KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGlzQ29udGV4dE1lbnUgPSAoYnV0dG9uID09PSAyKTtcblxuICAgICAgICBpZiAodmlldykge1xuXG4gICAgICAgICAgICBpZiAoIWlzQ29udGV4dE1lbnUgJiYgdGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGlzVGFyZ2V0Rm9ybU5vZGUgPSB0aGlzLkZPUk1fQ09OVFJPTF9UQUdfTkFNRVMuaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0Vmlld0FjdGlvbiAmJiAhaXNUYXJnZXRGb3JtTm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBmb3JtIGVsZW1lbnQsIHdlIGRvIG5vdCB3YW50IHRvIHByZXZlbnQgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gc2VsZWN0IHRleHQgaW4gYSB0ZXh0IGlucHV0IG9yXG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgYWJsZSB0byBjbGljayBvbiBhIGNoZWNrYm94LlxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNUYXJnZXRGb3JtTm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBmb3JtIGVsZW1lbnQsIHdlIGRvIG5vdCB3YW50IHRvIHN0YXJ0IGRyYWdnaW5nIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCB3ZSB3YW50IHRvIGJlIGFibGUgdG8gc2VsZWN0IHRleHQgYnkgZHJhZ2dpbmcgdGhlIG1vdXNlLlxuICAgICAgICAgICAgICAgIHZpZXcucHJldmVudERlZmF1bHRJbnRlcmFjdGlvbihldnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDdXN0b20gZXZlbnRcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50RXZ0ID0gdGhpcy5jdXN0b21FdmVudFRyaWdnZXIoZXZ0LCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChldmVudEV2dCkge1xuICAgICAgICAgICAgLy8gYG9uZXZlbnRgIGNvdWxkIGhhdmUgc3RvcHBlZCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICAgIGlmIChldmVudEV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IGV2ZW50RXZ0LmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEVsZW1lbnQgbWFnbmV0XG4gICAgICAgICAgICBjb25zdCBtYWduZXROb2RlID0gdGFyZ2V0LmNsb3Nlc3QoJ1ttYWduZXRdJyk7XG4gICAgICAgICAgICBpZiAobWFnbmV0Tm9kZSAmJiB2aWV3LmVsICE9PSBtYWduZXROb2RlICYmIHZpZXcuZWwuY29udGFpbnMobWFnbmV0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWduZXRFdnQgPSBub3JtYWxpemVFdmVudChuZXcgJC5FdmVudChldnQub3JpZ2luYWxFdmVudCwge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBldnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSB0aGUgZXZlbnQgbGlzdGVuZXIgd2FzIGF0dGFjaGVkIHRvIHRoZSBtYWduZXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogbWFnbmV0Tm9kZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9ubWFnbmV0KG1hZ25ldEV2dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hZ25ldEV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYG9ubWFnbmV0YCBzdG9wcyBwcm9wYWdhdGlvbiB3aGVuIGBhZGRMaW5rRnJvbU1hZ25ldGAgaXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIGlmIChtYWduZXRFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgbWFnbmV0OnBvaW50ZXJtb3ZlYCBhbmQgYG1hZ25ldDpwb2ludGVydXBgIGV2ZW50cyBtdXN0IGJlIGZpcmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbnRleHRNZW51KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVEcmFnRXZlbnRzKHZpZXcsIG1hZ25ldEV2dC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IG1hZ25ldEV2dC5kYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dE1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0bWVudUV2dCA9IG5ldyAkLkV2ZW50KGV2dC5vcmlnaW5hbEV2ZW50LCB7IHR5cGU6ICdjb250ZXh0bWVudScsIGRhdGE6IGV2dC5kYXRhIH0pO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudVRyaWdnZXIoY29udGV4dG1lbnVFdnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICB2aWV3LnBvaW50ZXJkb3duKGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByZXZlbnREZWZhdWx0QmxhbmtBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6cG9pbnRlcmRvd24nLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZURyYWdFdmVudHModmlldywgZXZ0LmRhdGEpO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIC8vIG1vdXNlIG1vdmVkIGNvdW50ZXJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICBpZiAoIWRhdGEubW91c2Vtb3ZlZCkge1xuICAgICAgICAgICAgZGF0YS5tb3VzZW1vdmVkID0gMDtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGV2ZW50cyBsaWtlIGBtb3VzZWVudGVyYCBhbmQgYG1vdXNlbGVhdmVgIGFyZVxuICAgICAgICAgICAgLy8gbm90IHRyaWdnZXJlZCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZyBhIGNlbGxWaWV3LlxuICAgICAgICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUgZXZlbnRzIGFyZSB1bmRlbGVnYXRlZCBhZnRlciB0aGUgZmlyc3QgYHBvaW50ZXJtb3ZlYCBldmVudC5cbiAgICAgICAgICAgIC8vIE5vdCBvbiBgcG9pbnRlcmRvd25gIHRvIG1ha2Ugc3VyZSB0aGF0IGBkYmx0YXBgIGlzIHJlY29nbml6ZWQuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW91c2Vtb3ZlZCA9ICsrZGF0YS5tb3VzZW1vdmVkO1xuXG4gICAgICAgIGlmIChtb3VzZW1vdmVkIDw9IHRoaXMub3B0aW9ucy5tb3ZlVGhyZXNob2xkKSByZXR1cm47XG5cbiAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcblxuICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuXG4gICAgICAgIHZhciB2aWV3ID0gZGF0YS5zb3VyY2VWaWV3O1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5wb2ludGVybW92ZShldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6cG9pbnRlcm1vdmUnLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnREYXRhKGV2dCwgZGF0YSk7XG4gICAgfSxcblxuICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZEV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2dC5jbGllbnRYLCBub3JtYWxpemVkRXZ0LmNsaWVudFkpO1xuXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5ldmVudERhdGEoZXZ0KS5zb3VyY2VWaWV3O1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgdmlldy5wb2ludGVydXAobm9ybWFsaXplZEV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdibGFuazpwb2ludGVydXAnLCBub3JtYWxpemVkRXZ0LCBsb2NhbFBvaW50LngsIGxvY2FsUG9pbnQueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRFdnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyY2xpY2sobmV3ICQuRXZlbnQoZXZ0Lm9yaWdpbmFsRXZlbnQsIHsgdHlwZTogJ2NsaWNrJywgZGF0YTogZXZ0LmRhdGEgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgIH0sXG5cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KGV2dC50YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcubW91c2VvdmVyKGV2dCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsID09PSBldnQudGFyZ2V0KSByZXR1cm47IC8vIHByZXZlbnQgYm9yZGVyIG9mIHBhcGVyIGZyb20gdHJpZ2dlcmluZyB0aGlzXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOm1vdXNlb3ZlcicsIGV2dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KGV2dC50YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIHZpZXcubW91c2VvdXQoZXZ0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWwgPT09IGV2dC50YXJnZXQpIHJldHVybjsgLy8gcHJldmVudCBib3JkZXIgb2YgcGFwZXIgZnJvbSB0cmlnZ2VyaW5nIHRoaXNcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmxhbms6bW91c2VvdXQnLCBldnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0LCAvLyBUaGUgRXZlbnRUYXJnZXQgdGhlIHBvaW50aW5nIGRldmljZSBlbnRlcmVkIHRvXG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0LCAvLyBUaGUgRXZlbnRUYXJnZXQgdGhlIHBvaW50aW5nIGRldmljZSBleGl0ZWQgZnJvbVxuICAgICAgICAgICAgY3VycmVudFRhcmdldCAvLyBUaGUgRXZlbnRUYXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHdhcyByZWdpc3RlcmVkXG4gICAgICAgIH0gPSBldnQ7XG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmZpbmRWaWV3KHRhcmdldCk7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcbiAgICAgICAgY29uc3QgcmVsYXRlZFZpZXcgPSB0aGlzLmZpbmRWaWV3KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgaWYgKHJlbGF0ZWRWaWV3ID09PSB2aWV3KSB7XG4gICAgICAgICAgICAgICAgLy8gTW91c2UgbGVmdCBhIGNlbGwgdG9vbFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXcubW91c2VlbnRlcihldnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWwuY29udGFpbnMocmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcG9pbnRlciByZW1haW5zIGluc2lkZSB0aGUgcGFwZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGVkVmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGBtb3VzZWVudGVyYCBldmVudCBpZiB0aGUgYHJlbGF0ZWRUYXJnZXRgIGlzIG91dHNpZGUgdGhlIHBhcGVyXG4gICAgICAgIC8vIChtb3VzZWVudGVyIG1ldGhvZCB3b3VsZCBiZSBmaXJlZCB0d2ljZSlcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09IHRoaXMuZWwpIHtcbiAgICAgICAgICAgIC8vIGBwYXBlcmAgKG1vcmUgZGVzY3JpcHRpdmUpLCBub3QgYGJsYW5rYFxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYXBlcjptb3VzZWVudGVyJywgZXZ0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3VzZWxlYXZlOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldCwgLy8gVGhlIEV2ZW50VGFyZ2V0IHRoZSBwb2ludGluZyBkZXZpY2UgZXhpdGVkIGZyb21cbiAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQsIC8vIFRoZSBFdmVudFRhcmdldCB0aGUgcG9pbnRpbmcgZGV2aWNlIGVudGVyZWQgdG9cbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgLy8gVGhlIEV2ZW50VGFyZ2V0IG9uIHdoaWNoIHRoZSBldmVudCBsaXN0ZW5lciB3YXMgcmVnaXN0ZXJlZFxuICAgICAgICB9ID0gZXZ0O1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5maW5kVmlldyh0YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRWaWV3ID0gdGhpcy5maW5kVmlldyhyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIGlmIChyZWxhdGVkVmlldyA9PT0gdmlldykge1xuICAgICAgICAgICAgICAgIC8vIE1vdXNlIGVudGVyZWQgYSBjZWxsIHRvb2xcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aWV3Lm1vdXNlbGVhdmUoZXZ0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsLmNvbnRhaW5zKHJlbGF0ZWRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBvaW50ZXIgaGFzIGV4aXRlZCBhIGNlbGxWaWV3LiBUaGUgcG9pbnRlciBpcyBzdGlsbCBpbnNpZGUgb2YgdGhlIHBhcGVyLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRlZFZpZXcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwb2ludGVyIGhhcyBlbnRlcmVkIGEgbmV3IGNlbGxWaWV3XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldmVudCBkb3VibGUgYG1vdXNlbGVhdmVgIGV2ZW50IGlmIHRoZSBgcmVsYXRlZFRhcmdldGAgaXMgb3V0c2lkZSB0aGUgcGFwZXJcbiAgICAgICAgLy8gKG1vdXNlbGVhdmUgbWV0aG9kIHdvdWxkIGJlIGZpcmVkIHR3aWNlKVxuICAgICAgICBpZiAoY3VycmVudFRhcmdldCA9PT0gdGhpcy5lbCkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gY2VsbFZpZXcgdW5kZXIgdGhlIHBvaW50ZXIsIG5vciB0aGUgYmxhbmsgYXJlYSBvZiB0aGUgcGFwZXJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFwZXI6bW91c2VsZWF2ZScsIGV2dCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3Byb2Nlc3NNb3VzZVdoZWVsRXZ0QnVmOiBkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBldmVudCwgZGVsdGFzIH0gPSB0aGlzLl9td19ldnRfYnVmZmVyO1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBkZWx0YXMucmVkdWNlKChhY2MsIGRlbHRhWSkgPT4gYWNjICsgY2FwKGRlbHRhWSwgV0hFRUxfQ0FQKSwgMCk7XG5cbiAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygwLjk5NSwgZGVsdGFZKTsgLy8gMS4wMDUgZm9yIGludmVydGVkIHBpbmNoL3pvb21cbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmNsaWVudFRvTG9jYWxQb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwYXBlcjpwaW5jaCcsIGV2ZW50LCB4LCB5LCBzY2FsZSk7XG5cbiAgICAgICAgdGhpcy5fbXdfZXZ0X2J1ZmZlciA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LCBXSEVFTF9XQUlUX01TLCB7IG1heFdhaXQ6IFdIRUVMX1dBSVRfTVMgfSksXG5cbiAgICBtb3VzZXdoZWVsOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuXG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLmZpbmRWaWV3KGV2dC50YXJnZXQpO1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFdmVudCA9IGV2dC5vcmlnaW5hbEV2ZW50O1xuICAgICAgICBjb25zdCBsb2NhbFBvaW50ID0gdGhpcy5zbmFwVG9HcmlkKG9yaWdpbmFsRXZlbnQuY2xpZW50WCwgb3JpZ2luYWxFdmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgeyBkZWx0YVgsIGRlbHRhWSB9ID0gbm9ybWFsaXplV2hlZWwob3JpZ2luYWxFdmVudCk7XG5cbiAgICAgICAgY29uc3QgcGluY2hIYW5kbGVycyA9IHRoaXMuX2V2ZW50c1sncGFwZXI6cGluY2gnXTtcblxuICAgICAgICAvLyBUb3VjaHBhZCBkZXZpY2VzIHdpbGwgc2VuZCBhIGZha2UgQ1RSTCBwcmVzcyB3aGVuIGEgcGluY2ggaXMgcGVyZm9ybWVkXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGFsc28gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBzdWJzY3JpYmVycyB0byBwYXBlcjpwaW5jaCBldmVudC4gSWYgdGhlcmUgYXJlIG5vbmUsXG4gICAgICAgIC8vIGp1c3Qgc2tpcCB0aGUgZW50aXJlIGJsb2NrIG9mIGNvZGUgKHdlIGRvbid0IHdhbnQgdG8gYmxpbmRseSBjYWxsXG4gICAgICAgIC8vIC5wcmV2ZW50RGVmYXVsdCgpIGlmIHdlIHJlYWxseSBkb24ndCBoYXZlIHRvKS5cbiAgICAgICAgaWYgKGV2dC5jdHJsS2V5ICYmIHBpbmNoSGFuZGxlcnMgJiYgcGluY2hIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgcGluY2ggZ2VzdHVyZSwgaXQncyBzYWZlIHRvIGFzc3VtZSB0aGF0IHdlIG11c3QgY2FsbCAucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5fbXdfZXZ0X2J1ZmZlci5ldmVudCA9IGV2dDtcbiAgICAgICAgICAgIHRoaXMuX213X2V2dF9idWZmZXIuZGVsdGFzLnB1c2goZGVsdGFZKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NNb3VzZVdoZWVsRXZ0QnVmKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGEpKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdmlldy5tb3VzZXdoZWVsKGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnksIGRlbHRhKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2JsYW5rOm1vdXNld2hlZWwnLCBldnQsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55LCBkZWx0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFwZXI6cGFuJywgZXZ0LCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25ldmVudDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdmFyIGV2ZW50Tm9kZSA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnROb2RlLmdldEF0dHJpYnV0ZSgnZXZlbnQnKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KGV2ZW50Tm9kZSk7XG4gICAgICAgICAgICBpZiAodmlldykge1xuXG4gICAgICAgICAgICAgICAgZXZ0ID0gbm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ndWFyZChldnQsIHZpZXcpKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIHZpZXcub25ldmVudChldnQsIGV2ZW50TmFtZSwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hZ25ldEV2ZW50OiBmdW5jdGlvbihldnQsIGhhbmRsZXIpIHtcblxuICAgICAgICB2YXIgbWFnbmV0Tm9kZSA9IGV2dC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB2YXIgbWFnbmV0VmFsdWUgPSBtYWduZXROb2RlLmdldEF0dHJpYnV0ZSgnbWFnbmV0Jyk7XG4gICAgICAgIGlmIChtYWduZXRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KG1hZ25ldE5vZGUpO1xuICAgICAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBldnQgPSBub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxQb2ludCA9IHRoaXMuc25hcFRvR3JpZChldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB2aWV3LCBldnQsIG1hZ25ldE5vZGUsIGxvY2FsUG9pbnQueCwgbG9jYWxQb2ludC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbm1hZ25ldDogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgaWYgKGV2dC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnVGaXJlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldENvbnRleHRNZW51RmlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dG1lbnVFdnQgPSBuZXcgJC5FdmVudChldnQub3JpZ2luYWxFdmVudCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb250ZXh0bWVudScsXG4gICAgICAgICAgICAgICAgZGF0YTogZXZ0LmRhdGEsXG4gICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogZXZ0LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFnbmV0Q29udGV4dE1lbnVUcmlnZ2VyKGNvbnRleHRtZW51RXZ0KTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0bWVudUV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWduZXRFdmVudChldnQsIGZ1bmN0aW9uKHZpZXcsIGV2dCwgXywgeCwgeSkge1xuICAgICAgICAgICAgICAgIHZpZXcub25tYWduZXQoZXZ0LCB4LCB5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hZ25ldHBvaW50ZXJkYmxjbGljazogZnVuY3Rpb24oZXZ0KSB7XG5cbiAgICAgICAgdGhpcy5tYWduZXRFdmVudChldnQsIGZ1bmN0aW9uKHZpZXcsIGV2dCwgbWFnbmV0LCB4LCB5KSB7XG4gICAgICAgICAgICB2aWV3Lm1hZ25ldHBvaW50ZXJkYmxjbGljayhldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtYWduZXRjb250ZXh0bWVudTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudENvbnRleHRNZW51KSBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAodGhpcy5tYWduZXRDb250ZXh0TWVudUZpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1hZ25ldENvbnRleHRNZW51RmlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFnbmV0Q29udGV4dE1lbnVUcmlnZ2VyKGV2dCk7XG4gICAgfSxcblxuICAgIG1hZ25ldENvbnRleHRNZW51VHJpZ2dlcjogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRoaXMubWFnbmV0RXZlbnQoZXZ0LCBmdW5jdGlvbih2aWV3LCBldnQsIG1hZ25ldCwgeCwgeSkge1xuICAgICAgICAgICAgdmlldy5tYWduZXRjb250ZXh0bWVudShldnQsIG1hZ25ldCwgeCwgeSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBvbmxhYmVsOiBmdW5jdGlvbihldnQpIHtcblxuICAgICAgICB2YXIgbGFiZWxOb2RlID0gZXZ0LmN1cnJlbnRUYXJnZXQ7XG5cbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLmZpbmRWaWV3KGxhYmVsTm9kZSk7XG4gICAgICAgIGlmICghdmlldykgcmV0dXJuO1xuXG4gICAgICAgIGV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIGlmICh0aGlzLmd1YXJkKGV2dCwgdmlldykpIHJldHVybjtcblxuICAgICAgICAvLyBDdXN0b20gZXZlbnRcbiAgICAgICAgY29uc3QgZXZlbnRFdnQgPSB0aGlzLmN1c3RvbUV2ZW50VHJpZ2dlcihldnQsIHZpZXcsIGxhYmVsTm9kZSk7XG4gICAgICAgIGlmIChldmVudEV2dCkge1xuICAgICAgICAgICAgLy8gYG9uZXZlbnRgIGNvdWxkIGhhdmUgc3RvcHBlZCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgaWYgKGV2ZW50RXZ0LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVybjtcblxuICAgICAgICAgICAgZXZ0LmRhdGEgPSBldmVudEV2dC5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsUG9pbnQgPSB0aGlzLnNuYXBUb0dyaWQoZXZ0LmNsaWVudFgsIGV2dC5jbGllbnRZKTtcbiAgICAgICAgdmlldy5vbmxhYmVsKGV2dCwgbG9jYWxQb2ludC54LCBsb2NhbFBvaW50LnkpO1xuICAgIH0sXG5cbiAgICBnZXRQb2ludGVyQXJncyhldnQpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEV2dCA9IG5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdnQuY2xpZW50WCwgbm9ybWFsaXplZEV2dC5jbGllbnRZKTtcbiAgICAgICAgcmV0dXJuIFtub3JtYWxpemVkRXZ0LCB4LCB5XTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVEcmFnRXZlbnRzOiBmdW5jdGlvbih2aWV3LCBkYXRhKSB7XG5cbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9IHt9KTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEoeyBkYXRhOiBkYXRhIH0sIHsgc291cmNlVmlldzogdmlldyB8fCBudWxsLCBtb3VzZW1vdmVkOiAwIH0pO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRG9jdW1lbnRFdmVudHMobnVsbCwgZGF0YSk7XG4gICAgfSxcblxuICAgIC8vIEd1YXJkIHRoZSBzcGVjaWZpZWQgZXZlbnQuIElmIHRoZSBldmVudCBzaG91bGQgYmUgaWdub3JlZCwgZ3VhcmQgcmV0dXJucyBgdHJ1ZWAuXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgZ3VhcmQ6IGZ1bmN0aW9uKGV2dCwgdmlldykge1xuXG4gICAgICAgIGlmIChldnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZXZ0LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgICAgLy8gaGFuZGxlZCBhcyBgY29udGV4dG1lbnVgIHR5cGVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ndWFyZCAmJiB0aGlzLm9wdGlvbnMuZ3VhcmQoZXZ0LCB2aWV3KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZ0LmRhdGEgJiYgZXZ0LmRhdGEuZ3VhcmRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZ0LmRhdGEuZ3VhcmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBldnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuR1VBUkRFRF9UQUdfTkFNRVMuaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2aWV3ICYmIHZpZXcubW9kZWwgJiYgKHZpZXcubW9kZWwgaW5zdGFuY2VvZiBDZWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZWwgPT09IHRhcmdldCB8fCB0aGlzLnN2Zy5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgLy8gRXZlbnQgZ3VhcmRlZC4gUGFwZXIgc2hvdWxkIG5vdCByZWFjdCBvbiBpdCBpbiBhbnkgd2F5LlxuICAgIH0sXG5cbiAgICBzZXRHcmlkU2l6ZTogZnVuY3Rpb24oZ3JpZFNpemUpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBvcHRpb25zLmdyaWRTaXplID0gZ3JpZFNpemU7XG4gICAgICAgIGlmIChvcHRpb25zLmRyYXdHcmlkICYmICFvcHRpb25zLmRyYXdHcmlkU2l6ZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IHJlZHJhdyB0aGUgZ3JpZCBpZiB0aGUgYGRyYXdHcmlkU2l6ZWAgaXMgc2V0LlxuICAgICAgICAgICAgdGhpcy5nZXRMYXllclZpZXcoTGF5ZXJzTmFtZXMuR1JJRCkucmVuZGVyR3JpZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRHcmlkOiBmdW5jdGlvbihkcmF3R3JpZCkge1xuICAgICAgICB0aGlzLmdldExheWVyVmlldyhMYXllcnNOYW1lcy5HUklEKS5zZXRHcmlkKGRyYXdHcmlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHVwZGF0ZUJhY2tncm91bmRJbWFnZTogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHZhciBiYWNrZ3JvdW5kUG9zaXRpb24gPSBvcHQucG9zaXRpb24gfHwgJ2NlbnRlcic7XG4gICAgICAgIHZhciBiYWNrZ3JvdW5kU2l6ZSA9IG9wdC5zaXplIHx8ICdhdXRvIGF1dG8nO1xuXG4gICAgICAgIHZhciBjdXJyZW50U2NhbGUgPSB0aGlzLnNjYWxlKCk7XG4gICAgICAgIHZhciBjdXJyZW50VHJhbnNsYXRlID0gdGhpcy50cmFuc2xhdGUoKTtcblxuICAgICAgICAvLyBiYWNrZ3JvdW5kUG9zaXRpb25cbiAgICAgICAgaWYgKGlzT2JqZWN0KGJhY2tncm91bmRQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3VycmVudFRyYW5zbGF0ZS50eCArIChjdXJyZW50U2NhbGUuc3ggKiAoYmFja2dyb3VuZFBvc2l0aW9uLnggfHwgMCkpO1xuICAgICAgICAgICAgdmFyIHkgPSBjdXJyZW50VHJhbnNsYXRlLnR5ICsgKGN1cnJlbnRTY2FsZS5zeSAqIChiYWNrZ3JvdW5kUG9zaXRpb24ueSB8fCAwKSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb24gPSB4ICsgJ3B4ICcgKyB5ICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2tncm91bmRTaXplXG4gICAgICAgIGlmIChpc09iamVjdChiYWNrZ3JvdW5kU2l6ZSkpIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRTaXplID0gbmV3IFJlY3QoYmFja2dyb3VuZFNpemUpLnNjYWxlKGN1cnJlbnRTY2FsZS5zeCwgY3VycmVudFNjYWxlLnN5KTtcbiAgICAgICAgICAgIGJhY2tncm91bmRTaXplID0gYmFja2dyb3VuZFNpemUud2lkdGggKyAncHggJyArIGJhY2tncm91bmRTaXplLmhlaWdodCArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGJhY2tncm91bmQgfSA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGJhY2tncm91bmRTaXplO1xuICAgICAgICBiYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IGJhY2tncm91bmRQb3NpdGlvbjtcbiAgICB9LFxuXG4gICAgZHJhd0JhY2tncm91bmRJbWFnZTogZnVuY3Rpb24oaW1nLCBvcHQpIHtcblxuICAgICAgICAvLyBDbGVhciB0aGUgYmFja2dyb3VuZCBpbWFnZSBpZiBubyBpbWFnZSBwcm92aWRlZFxuICAgICAgICBpZiAoIShpbWcgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJyc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2JhY2tncm91bmQgfHwgdGhpcy5fYmFja2dyb3VuZC5pZCAhPT0gb3B0LmlkKSB7XG4gICAgICAgICAgICAvLyBEcmF3IG9ubHkgdGhlIGxhc3QgaW1hZ2UgcmVxdWVzdGVkIChzZWUgZHJhd0JhY2tncm91bmQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICB2YXIgYmFja2dyb3VuZEltYWdlO1xuICAgICAgICB2YXIgYmFja2dyb3VuZFNpemUgPSBvcHQuc2l6ZTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRSZXBlYXQgPSBvcHQucmVwZWF0IHx8ICduby1yZXBlYXQnO1xuICAgICAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBvcHQub3BhY2l0eSB8fCAxO1xuICAgICAgICB2YXIgYmFja2dyb3VuZFF1YWxpdHkgPSBNYXRoLmFicyhvcHQucXVhbGl0eSkgfHwgMTtcbiAgICAgICAgdmFyIGJhY2tncm91bmRQYXR0ZXJuID0gdGhpcy5jb25zdHJ1Y3Rvci5iYWNrZ3JvdW5kUGF0dGVybnNbY2FtZWxDYXNlKGJhY2tncm91bmRSZXBlYXQpXTtcblxuICAgICAgICBpZiAoaXNGdW5jdGlvbihiYWNrZ3JvdW5kUGF0dGVybikpIHtcbiAgICAgICAgICAgIC8vICdmbGlwLXgnLCAnZmxpcC15JywgJ2ZsaXAteHknLCAnd2F0ZXJtYXJrJyBhbmQgY3VzdG9tXG4gICAgICAgICAgICBpbWcud2lkdGggKj0gYmFja2dyb3VuZFF1YWxpdHk7XG4gICAgICAgICAgICBpbWcuaGVpZ2h0ICo9IGJhY2tncm91bmRRdWFsaXR5O1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGJhY2tncm91bmRQYXR0ZXJuKGltZywgb3B0KTtcbiAgICAgICAgICAgIGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLlBhcGVyOiBiYWNrZ3JvdW5kIHBhdHRlcm4gbXVzdCByZXR1cm4gYW4gSFRNTCBDYW52YXMgaW5zdGFuY2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFja2dyb3VuZEltYWdlID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0ID0gJ3JlcGVhdCc7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoYmFja2dyb3VuZFNpemUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHRpbGUgc2l6ZSBpZiBhbiBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFNpemUud2lkdGggKj0gY2FudmFzLndpZHRoIC8gaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRTaXplLmhlaWdodCAqPSBjYW52YXMuaGVpZ2h0IC8gaW1nLmhlaWdodDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmFja2dyb3VuZFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdGlsZSBzaXplIGlmIG5vIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgb3B0LnNpemUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGggLyBiYWNrZ3JvdW5kUXVhbGl0eSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0IC8gYmFja2dyb3VuZFF1YWxpdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmFja2dyb3VuZFJlcGVhdDpcbiAgICAgICAgICAgIC8vIG5vLXJlcGVhdCcsICdyb3VuZCcsICdzcGFjZScsICdyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBpbWcuc3JjO1xuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXNzIHRoZSBpbWFnZSBzaXplIGZvciAgdGhlIGJhY2tncm91bmRTaXplIGlmIG5vIHNpemUgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICBvcHQuc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hpbGROb2Rlcy5iYWNrZ3JvdW5kLnN0eWxlLm9wYWNpdHkgPSBiYWNrZ3JvdW5kT3BhY2l0eTtcbiAgICAgICAgdGhpcy5jaGlsZE5vZGVzLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZFJlcGVhdCA9IGJhY2tncm91bmRSZXBlYXQ7XG4gICAgICAgIHRoaXMuY2hpbGROb2Rlcy5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtiYWNrZ3JvdW5kSW1hZ2V9KWA7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCYWNrZ3JvdW5kSW1hZ2Uob3B0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuXG4gICAgICAgIHRoaXMuJGVsLmNzcygnYmFja2dyb3VuZENvbG9yJywgY29sb3IgfHwgJycpO1xuICAgIH0sXG5cbiAgICBkcmF3QmFja2dyb3VuZDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgICAgIHRoaXMudXBkYXRlQmFja2dyb3VuZENvbG9yKG9wdC5jb2xvcik7XG5cbiAgICAgICAgaWYgKG9wdC5pbWFnZSkge1xuICAgICAgICAgICAgb3B0ID0gdGhpcy5fYmFja2dyb3VuZCA9IGNsb25lRGVlcChvcHQpO1xuICAgICAgICAgICAgZ3VpZChvcHQpO1xuICAgICAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IHRoaXMuZHJhd0JhY2tncm91bmRJbWFnZS5iaW5kKHRoaXMsIGltZywgb3B0KTtcbiAgICAgICAgICAgIGltZy5zcmMgPSBvcHQuaW1hZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kSW1hZ2UobnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRJbnRlcmFjdGl2aXR5OiBmdW5jdGlvbih2YWx1ZSkge1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcmFjdGl2ZSA9IHZhbHVlO1xuXG4gICAgICAgIGludm9rZSh0aGlzLl92aWV3cywgJ3NldEludGVyYWN0aXZpdHknLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8vIFBhcGVyIGRlZmluaXRpb25zLlxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgaXNEZWZpbmVkOiBmdW5jdGlvbihkZWZJZCkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuc3ZnLmdldEVsZW1lbnRCeUlkKGRlZklkKTtcbiAgICB9LFxuXG4gICAgZGVmaW5lRmlsdGVyOiBmdW5jdGlvbihmaWx0ZXIpIHtcblxuICAgICAgICBpZiAoIWlzT2JqZWN0KGZpbHRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RpYS5QYXBlcjogZGVmaW5lRmlsdGVyKCkgcmVxdWlyZXMgMS4gYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbHRlcklkID0gZmlsdGVyLmlkO1xuICAgICAgICB2YXIgbmFtZSA9IGZpbHRlci5uYW1lO1xuICAgICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggY29kZSBmcm9tIHRoZSBzdHJpbmdpZmllZCBmaWx0ZXIgZGVmaW5pdGlvbi4gVGhpcyBnaXZlcyB1c1xuICAgICAgICAvLyBhIHVuaXF1ZSBmaWx0ZXIgSUQgZm9yIGRpZmZlcmVudCBkZWZpbml0aW9ucy5cbiAgICAgICAgaWYgKCFmaWx0ZXJJZCkge1xuICAgICAgICAgICAgZmlsdGVySWQgPSBuYW1lICsgdGhpcy5zdmcuaWQgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShmaWx0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZmlsdGVyIGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudCxcbiAgICAgICAgLy8gd2UncmUgZG9uZSBhbmQgd2UgY2FuIGp1c3QgdXNlIGl0IChyZWZlcmVuY2UgaXQgdXNpbmcgYHVybCgpYCkuXG4gICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZS5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGVmaW5lZChmaWx0ZXJJZCkpIHtcblxuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IF9maWx0ZXI7XG4gICAgICAgICAgICB2YXIgZmlsdGVyU1ZHU3RyaW5nID0gbmFtZXNwYWNlW25hbWVdICYmIG5hbWVzcGFjZVtuYW1lXShmaWx0ZXIuYXJncyB8fCB7fSk7XG4gICAgICAgICAgICBpZiAoIWZpbHRlclNWR1N0cmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4aXN0aW5nIGZpbHRlciAnICsgbmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNWRyA8ZmlsdGVyLz4gYXR0cmlidXRlc1xuICAgICAgICAgICAgdmFyIGZpbHRlckF0dHJzID0gYXNzaWduKHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJVbml0czogJ3VzZXJTcGFjZU9uVXNlJyxcbiAgICAgICAgICAgIH0sIGZpbHRlci5hdHRycywge1xuICAgICAgICAgICAgICAgIGlkOiBmaWx0ZXJJZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIFYoZmlsdGVyU1ZHU3RyaW5nLCBmaWx0ZXJBdHRycykuYXBwZW5kVG8odGhpcy5kZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJJZDtcbiAgICB9LFxuXG4gICAgZGVmaW5lR3JhZGllbnQ6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoZ3JhZGllbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuUGFwZXI6IGRlZmluZUdyYWRpZW50KCkgcmVxdWlyZXMgMS4gYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3ZnLCBkZWZzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBoYXNoIGNvZGUgZnJvbSB0aGUgc3RyaW5naWZpZWQgZmlsdGVyIGRlZmluaXRpb24uIFRoaXMgZ2l2ZXMgdXNcbiAgICAgICAgICAgIC8vIGEgdW5pcXVlIGZpbHRlciBJRCBmb3IgZGlmZmVyZW50IGRlZmluaXRpb25zLlxuICAgICAgICAgICAgaWQgPSB0eXBlICsgc3ZnLmlkICsgaGFzaENvZGUoSlNPTi5zdHJpbmdpZnkoZ3JhZGllbnQpKSxcbiAgICAgICAgICAgIHN0b3BzLFxuICAgICAgICAgICAgYXR0cnMgPSB7fVxuICAgICAgICB9ID0gZ3JhZGllbnQ7XG4gICAgICAgIC8vIElmIHRoZSBncmFkaWVudCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgYW5kIHdlIGNhbiBqdXN0IHVzZSBpdCAocmVmZXJlbmNlIGl0IHVzaW5nIGB1cmwoKWApLlxuICAgICAgICBpZiAodGhpcy5pc0RlZmluZWQoaWQpKSByZXR1cm4gaWQ7XG4gICAgICAgIC8vIElmIG5vdCwgY3JlYXRlIG9uZS5cbiAgICAgICAgY29uc3Qgc3RvcFZFbHMgPSB0b0FycmF5KHN0b3BzKS5tYXAoKHsgb2Zmc2V0LCBjb2xvciwgb3BhY2l0eSB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gVignc3RvcCcpLmF0dHIoe1xuICAgICAgICAgICAgICAgICdvZmZzZXQnOiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgJ3N0b3AtY29sb3InOiBjb2xvcixcbiAgICAgICAgICAgICAgICAnc3RvcC1vcGFjaXR5JzogTnVtYmVyLmlzRmluaXRlKG9wYWNpdHkpID8gb3BhY2l0eSA6IDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ3JhZGllbnRWRWwgPSBWKHR5cGUsIGF0dHJzLCBzdG9wVkVscyk7XG4gICAgICAgIGdyYWRpZW50VkVsLmlkID0gaWQ7XG4gICAgICAgIGdyYWRpZW50VkVsLmFwcGVuZFRvKGRlZnMpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIGRlZmluZVBhdHRlcm46IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlhLlBhcGVyOiBkZWZpbmVQYXR0ZXJuKCkgcmVxdWlyZXMgMS4gYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3ZnLCBkZWZzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggY29kZSBmcm9tIHRoZSBzdHJpbmdpZmllZCBmaWx0ZXIgZGVmaW5pdGlvbi4gVGhpcyBnaXZlcyB1c1xuICAgICAgICAgICAgLy8gYSB1bmlxdWUgZmlsdGVyIElEIGZvciBkaWZmZXJlbnQgZGVmaW5pdGlvbnMuXG4gICAgICAgICAgICBpZCA9IHN2Zy5pZCArIGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pKSxcbiAgICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAgIGF0dHJzID0ge31cbiAgICAgICAgfSA9IHBhdHRlcm47XG4gICAgICAgIGlmICghbWFya3VwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaWEuUGFwZXI6IGRlZmluZVBhdHRlcm4oKSByZXF1aXJlcyBtYXJrdXAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGdyYWRpZW50IGFscmVhZHkgZXhpc3RzIGluIHRoZSBkb2N1bWVudCxcbiAgICAgICAgLy8gd2UncmUgZG9uZSBhbmQgd2UgY2FuIGp1c3QgdXNlIGl0IChyZWZlcmVuY2UgaXQgdXNpbmcgYHVybCgpYCkuXG4gICAgICAgIGlmICh0aGlzLmlzRGVmaW5lZChpZCkpIHJldHVybiBpZDtcbiAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lLlxuICAgICAgICBjb25zdCBwYXR0ZXJuVkVsID0gVigncGF0dGVybicsIHtcbiAgICAgICAgICAgIHBhdHRlcm5Vbml0czogJ3VzZXJTcGFjZU9uVXNlJ1xuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVyblZFbC5pZCA9IGlkO1xuICAgICAgICBwYXR0ZXJuVkVsLmF0dHIoYXR0cnMpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhdHRlcm5WRWwuYXBwZW5kKFYobWFya3VwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGZyYWdtZW50IH0gPSBwYXJzZURPTUpTT04obWFya3VwKTtcbiAgICAgICAgICAgIHBhdHRlcm5WRWwuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBwYXR0ZXJuVkVsLmFwcGVuZFRvKGRlZnMpO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfSxcblxuICAgIGRlZmluZU1hcmtlcjogZnVuY3Rpb24obWFya2VyKSB7XG4gICAgICAgIGlmICghaXNPYmplY3QobWFya2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlhLlBhcGVyOiBkZWZpbmVNYXJrZXIoKSByZXF1aXJlcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3ZnLCBkZWZzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIGhhc2ggY29kZSBmcm9tIHRoZSBzdHJpbmdpZmllZCBmaWx0ZXIgZGVmaW5pdGlvbi4gVGhpcyBnaXZlcyB1c1xuICAgICAgICAgICAgLy8gYSB1bmlxdWUgZmlsdGVyIElEIGZvciBkaWZmZXJlbnQgZGVmaW5pdGlvbnMuXG4gICAgICAgICAgICBpZCA9IHN2Zy5pZCArIGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KG1hcmtlcikpLFxuICAgICAgICAgICAgLy8gdXNlci1wcm92aWRlZCBtYXJrdXBcbiAgICAgICAgICAgIC8vIChlLmcuIGRlZmluZWQgd2hlbiBjcmVhdGluZyBsaW5rIHZpYSBgYXR0cnMvbGluZS9zb3VyY2VNYXJrZXIvbWFya3VwYClcbiAgICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICAgIC8vIHVzZXItcHJvdmlkZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gKGUuZy4gZGVmaW5lZCB3aGVuIGNyZWF0aW5nIGxpbmsgdmlhIGBhdHRycy9saW5lL3NvdXJjZU1hcmtlci9hdHRyc2ApXG4gICAgICAgICAgICAvLyBub3RlOiBgdHJhbnNmb3JtYCBhdHRycyBhcmUgaWdub3JlZCBieSBicm93c2Vyc1xuICAgICAgICAgICAgYXR0cnMgPSB7fSxcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgLSB1c2UgYGF0dHJzL21hcmtlclVuaXRzYCBpbnN0ZWFkICh3aGljaCBoYXMgaGlnaGVyIHByaW9yaXR5KVxuICAgICAgICAgICAgbWFya2VyVW5pdHMgPSAndXNlclNwYWNlT25Vc2UnXG4gICAgICAgIH0gPSBtYXJrZXI7XG4gICAgICAgIC8vIElmIHRoZSBtYXJrZXIgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGRvY3VtZW50LFxuICAgICAgICAvLyB3ZSdyZSBkb25lIGFuZCB3ZSBjYW4ganVzdCB1c2UgaXQgKHJlZmVyZW5jZSBpdCB1c2luZyBgdXJsKClgKS5cbiAgICAgICAgaWYgKHRoaXMuaXNEZWZpbmVkKGlkKSkgcmV0dXJuIGlkO1xuICAgICAgICAvLyBJZiBub3QsIGNyZWF0ZSBvbmUuXG4gICAgICAgIGNvbnN0IG1hcmtlclZFbCA9IFYoJ21hcmtlcicsIHtcbiAgICAgICAgICAgIG9yaWVudDogJ2F1dG8nLFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgIG1hcmtlclVuaXRzOiBtYXJrZXJVbml0c1xuICAgICAgICB9KTtcbiAgICAgICAgbWFya2VyVkVsLmlkID0gaWQ7XG4gICAgICAgIG1hcmtlclZFbC5hdHRyKGF0dHJzKTtcbiAgICAgICAgbGV0IG1hcmtlckNvbnRlbnRWRWw7XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICAgIGxldCBtYXJrdXBWRWw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrZXIgb2JqZWN0IGhhcyBhIGBtYXJrdXBgIHByb3BlcnR5IG9mIHR5cGUgc3RyaW5nLlxuICAgICAgICAgICAgICAgIC8vIC0gQ29uc3RydWN0IFYgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIG1hcmt1cFZFbCA9IFYobWFya3VwKTtcbiAgICAgICAgICAgICAgICAvLyBgbWFya3VwVkVsYCBpcyBub3cgZWl0aGVyIGEgc2luZ2xlIFZFbCwgb3IgYW4gYXJyYXkgb2YgVkVscy5cbiAgICAgICAgICAgICAgICAvLyAtIENvZXJjZSBpdCB0byBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBtYXJrdXBWRWwgPSAoQXJyYXkuaXNBcnJheShtYXJrdXBWRWwpID8gbWFya3VwVkVsIDogW21hcmt1cFZFbF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNYXJrZXIgb2JqZWN0IGhhcyBhIGBtYXJrdXBgIHByb3BlcnR5IG9mIHR5cGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIC8vIC0gQ29uc3RydWN0IFYgZnJvbSB0aGUgb2JqZWN0IGJ5IHBhcnNpbmcgaXQgYXMgRE9NIEpTT04uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcmFnbWVudCB9ID0gcGFyc2VET01KU09OKG1hcmt1cCk7XG4gICAgICAgICAgICAgICAgbWFya3VwVkVsID0gVihmcmFnbWVudCkuY2hpbGRyZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGBtYXJrdXBWRWxgIGlzIGFuIGFycmF5IHdpdGggb25lIG9yIG1vcmUgVkVscyBpbnNpZGUuXG4gICAgICAgICAgICAvLyAtIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBWRWxzLCB3cmFwIHRoZW0gaW4gYSBuZXdseS1jb25zdHJ1Y3RlZCA8Zz4gZWxlbWVudFxuICAgICAgICAgICAgaWYgKG1hcmt1cFZFbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyQ29udGVudFZFbCA9IFYoJ2cnKS5hcHBlbmQobWFya3VwVkVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya2VyQ29udGVudFZFbCA9IG1hcmt1cFZFbFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1hcmtlciBvYmplY3QgaXMgYSBmbGF0IHN0cnVjdHVyZS5cbiAgICAgICAgICAgIC8vIC0gQ29uc3RydWN0IGEgbmV3IFYgb2YgdHlwZSBgbWFya2VyLnR5cGVgLlxuICAgICAgICAgICAgY29uc3QgeyB0eXBlID0gJ3BhdGgnIH0gPSBtYXJrZXI7XG4gICAgICAgICAgICBtYXJrZXJDb250ZW50VkVsID0gVih0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgbWFya2VyQ29udGVudFZFbGAgaXMgYSBzaW5nbGUgVkVsLlxuICAgICAgICAvLyBBc3NpZ24gYWRkaXRpb25hbCBhdHRyaWJ1dGVzIHRvIGl0ICg9IGNvbnRleHQgYXR0cmlidXRlcyArIG1hcmtlciBhdHRyaWJ1dGVzKTpcbiAgICAgICAgLy8gLSBBdHRyaWJ1dGUgdmFsdWVzIGFyZSB0YWtlbiBmcm9tIG5vbi1zcGVjaWFsIHByb3BlcnRpZXMgb2YgYG1hcmtlcmAuXG4gICAgICAgIGNvbnN0IG1hcmtlckF0dHJzID0gb21pdChtYXJrZXIsICd0eXBlJywgJ2lkJywgJ21hcmt1cCcsICdhdHRycycsICdtYXJrZXJVbml0cycpO1xuICAgICAgICBjb25zdCBtYXJrZXJBdHRyc0tleXMgPSBPYmplY3Qua2V5cyhtYXJrZXJBdHRycyk7XG4gICAgICAgIG1hcmtlckF0dHJzS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWFya2VyQXR0cnNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmt1cFZhbHVlID0gbWFya2VyQ29udGVudFZFbC5hdHRyKGtleSk7IC8vIHZhbHVlIGNvbWluZyBmcm9tIG1hcmt1cFZFbCAoaWYgYW55KSA9IGhpZ2hlciBwcmlvcml0eVxuICAgICAgICAgICAgaWYgKG1hcmt1cFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGxvZ2ljOlxuICAgICAgICAgICAgICAgIG1hcmtlckNvbnRlbnRWRWwuYXR0cihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyB3aXRoIHNwZWNpYWwgbG9naWMgc2hvdWxkIGJlIGFkZGVkIGFzIGNhc2VzIHRvIHRoaXMgc3dpdGNoIGJsb2NrOlxuICAgICAgICAgICAgICAgIHN3aXRjaChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gUHJlcGVuZCBgdHJhbnNmb3JtYCB0byBleGlzdGluZyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckNvbnRlbnRWRWwuYXR0cihrZXksICh2YWx1ZSArICcgJyArIG1hcmt1cFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXJDb250ZW50VkVsLmFwcGVuZFRvKG1hcmtlclZFbCk7XG4gICAgICAgIG1hcmtlclZFbC5hcHBlbmRUbyhkZWZzKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG5cbiAgICBjdXN0b21FdmVudFRyaWdnZXI6IGZ1bmN0aW9uKGV2dCwgdmlldywgcm9vdE5vZGUgPSB2aWV3LmVsKSB7XG5cbiAgICAgICAgY29uc3QgZXZlbnROb2RlID0gZXZ0LnRhcmdldC5jbG9zZXN0KCdbZXZlbnRdJyk7XG5cbiAgICAgICAgaWYgKGV2ZW50Tm9kZSAmJiByb290Tm9kZSAhPT0gZXZlbnROb2RlICYmIHZpZXcuZWwuY29udGFpbnMoZXZlbnROb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRFdnQgPSBub3JtYWxpemVFdmVudChuZXcgJC5FdmVudChldnQub3JpZ2luYWxFdmVudCwge1xuICAgICAgICAgICAgICAgIGRhdGE6IGV2dC5kYXRhLFxuICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgdGhlIGV2ZW50IGxpc3RlbmVyIHdhcyBhdHRhY2hlZCB0byB0aGUgZXZlbnQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBldmVudE5vZGVcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5vbmV2ZW50KGV2ZW50RXZ0KTtcblxuICAgICAgICAgICAgaWYgKGV2ZW50RXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBldmVudEV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxufSwge1xuXG4gICAgc29ydGluZzogc29ydGluZ1R5cGVzLFxuXG4gICAgTGF5ZXJzOiBMYXllcnNOYW1lcyxcblxuICAgIGJhY2tncm91bmRQYXR0ZXJuczoge1xuXG4gICAgICAgIGZsaXBYeTogZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAvLyBkIGJcbiAgICAgICAgICAgIC8vIHEgcFxuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgaW1nV2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gMiAqIGltZ1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IDIgKiBpbWdIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIC8vIHRvcC1sZWZ0IGltYWdlXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgICAvLyB4eS1mbGlwcGVkIGJvdHRvbS1yaWdodCBpbWFnZVxuICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgtMSwgMCwgMCwgLTEsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgICAvLyB4LWZsaXBwZWQgdG9wLXJpZ2h0IGltYWdlXG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC0xLCAwLCAwLCAxLCBjYW52YXMud2lkdGgsIDApO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8geS1mbGlwcGVkIGJvdHRvbS1sZWZ0IGltYWdlXG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfSxcblxuICAgICAgICBmbGlwWDogZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAvLyBkIGJcbiAgICAgICAgICAgIC8vIGQgYlxuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgaW1nV2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nV2lkdGggKiAyO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZ0hlaWdodDtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgLy8gbGVmdCBpbWFnZVxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgLy8gZmxpcHBlZCByaWdodCBpbWFnZVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgyICogaW1nV2lkdGgsIDApO1xuICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfSxcblxuICAgICAgICBmbGlwWTogZnVuY3Rpb24oaW1nKSB7XG4gICAgICAgICAgICAvLyBkIGRcbiAgICAgICAgICAgIC8vIHEgcVxuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgaW1nV2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gaW1nLmhlaWdodDtcblxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nV2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0ICogMjtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgLy8gdG9wIGltYWdlXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgICAvLyBmbGlwcGVkIGJvdHRvbSBpbWFnZVxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCAyICogaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2F0ZXJtYXJrOiBmdW5jdGlvbihpbWcsIG9wdCkge1xuICAgICAgICAgICAgLy8gICBkXG4gICAgICAgICAgICAvLyBkXG5cbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IGltZy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltZ1dpZHRoICogMztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWdIZWlnaHQgKiAzO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBpc051bWJlcihvcHQud2F0ZXJtYXJrQW5nbGUpID8gLW9wdC53YXRlcm1hcmtBbmdsZSA6IC0yMDtcbiAgICAgICAgICAgIHZhciByYWRpYW5zID0gdG9SYWQoYW5nbGUpO1xuICAgICAgICAgICAgdmFyIHN0ZXBYID0gY2FudmFzLndpZHRoIC8gNDtcbiAgICAgICAgICAgIHZhciBzdGVwWSA9IGNhbnZhcy5oZWlnaHQgLyA0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaSArIGopICUgMiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAoMiAqIGkgLSAxKSAqIHN0ZXBYLCAoMiAqIGogLSAxKSAqIHN0ZXBZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUocmFkaWFucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgLWltZ1dpZHRoIC8gMiwgLWltZ0hlaWdodCAvIDIsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdyaWRQYXR0ZXJuczoge1xuICAgICAgICBkb3Q6IFt7XG4gICAgICAgICAgICBjb2xvcjogJyNBQUFBQUEnLFxuICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgbWFya3VwOiAncmVjdCcsXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGVsLCBvcHQpIHtcbiAgICAgICAgICAgICAgICBWKGVsKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG9wdC50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogb3B0LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogb3B0LmNvbG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICBmaXhlZERvdDogW3tcbiAgICAgICAgICAgIGNvbG9yOiAnI0FBQUFBQScsXG4gICAgICAgICAgICB0aGlja25lc3M6IDEsXG4gICAgICAgICAgICBtYXJrdXA6ICdyZWN0JyxcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oZWwsIG9wdCkge1xuICAgICAgICAgICAgICAgIFYoZWwpLmF0dHIoeyBmaWxsOiBvcHQuY29sb3IgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihlbCwgb3B0LCBwYXBlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3gsIHN5IH0gPSBwYXBlci5zY2FsZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gc3ggPD0gMSA/IG9wdC50aGlja25lc3MgOiBvcHQudGhpY2tuZXNzIC8gc3g7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gc3kgPD0gMSA/IG9wdC50aGlja25lc3MgOiBvcHQudGhpY2tuZXNzIC8gc3k7XG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICBtZXNoOiBbe1xuICAgICAgICAgICAgY29sb3I6ICcjQUFBQUFBJyxcbiAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgIG1hcmt1cDogJ3BhdGgnLFxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihlbCwgb3B0KSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBvcHQud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IG9wdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHRoaWNrbmVzcyA9IG9wdC50aGlja25lc3M7XG5cbiAgICAgICAgICAgICAgICBpZiAod2lkdGggLSB0aGlja25lc3MgPj0gMCAmJiBoZWlnaHQgLSB0aGlja25lc3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gWydNJywgd2lkdGgsIDAsICdIMCBNMCAwIFYwJywgaGVpZ2h0XS5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9ICdNIDAgMCAwIDAnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFYoZWwpLmF0dHIoeyAnZCc6IGQsIHN0cm9rZTogb3B0LmNvbG9yLCAnc3Ryb2tlLXdpZHRoJzogb3B0LnRoaWNrbmVzcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIGRvdWJsZU1lc2g6IFt7XG4gICAgICAgICAgICBjb2xvcjogJyNBQUFBQUEnLFxuICAgICAgICAgICAgdGhpY2tuZXNzOiAxLFxuICAgICAgICAgICAgbWFya3VwOiAncGF0aCcsXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKGVsLCBvcHQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBkO1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG9wdC53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gb3B0LmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgdGhpY2tuZXNzID0gb3B0LnRoaWNrbmVzcztcblxuICAgICAgICAgICAgICAgIGlmICh3aWR0aCAtIHRoaWNrbmVzcyA+PSAwICYmIGhlaWdodCAtIHRoaWNrbmVzcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBbJ00nLCB3aWR0aCwgMCwgJ0gwIE0wIDAgVjAnLCBoZWlnaHRdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkID0gJ00gMCAwIDAgMCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgVihlbCkuYXR0cih7ICdkJzogZCwgc3Ryb2tlOiBvcHQuY29sb3IsICdzdHJva2Utd2lkdGgnOiBvcHQudGhpY2tuZXNzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgdGhpY2tuZXNzOiAzLFxuICAgICAgICAgICAgc2NhbGVGYWN0b3I6IDQsXG4gICAgICAgICAgICBtYXJrdXA6ICdwYXRoJyxcbiAgICAgICAgICAgIHJlbmRlcjogZnVuY3Rpb24oZWwsIG9wdCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gb3B0LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBvcHQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciB0aGlja25lc3MgPSBvcHQudGhpY2tuZXNzO1xuXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIC0gdGhpY2tuZXNzID49IDAgJiYgaGVpZ2h0IC0gdGhpY2tuZXNzID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IFsnTScsIHdpZHRoLCAwLCAnSDAgTTAgMCBWMCcsIGhlaWdodF0uam9pbignICcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnTSAwIDAgMCAwJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBWKGVsKS5hdHRyKHsgJ2QnOiBkLCBzdHJva2U6IG9wdC5jb2xvciwgJ3N0cm9rZS13aWR0aCc6IG9wdC50aGlja25lc3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgfVxufSk7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/Paper.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/PaperLayer.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/PaperLayer.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayersNames: function() { return /* binding */ LayersNames; },\n/* harmony export */   PaperLayer: function() { return /* binding */ PaperLayer; }\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nconst LayersNames = {\n    GRID: 'grid',\n    CELLS: 'cells',\n    BACK: 'back',\n    FRONT: 'front',\n    TOOLS: 'tools',\n    LABELS: 'labels'\n};\n\nconst PaperLayer = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n\n    tagName: 'g',\n    svgElement: true,\n    pivotNodes: null,\n    defaultTheme: null,\n\n    options: {\n        name: ''\n    },\n\n    className: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix)(`${this.options.name}-layer`);\n    },\n\n    init: function() {\n        this.pivotNodes = {};\n    },\n\n    insertSortedNode: function(node, z) {\n        this.el.insertBefore(node, this.insertPivot(z));\n    },\n\n    insertNode: function(node) {\n        const { el } = this;\n        if (node.parentNode !== el) {\n            el.appendChild(node);\n        }\n    },\n\n    insertPivot: function(z) {\n        const { el, pivotNodes } = this;\n        z = +z;\n        z || (z = 0);\n        let pivotNode = pivotNodes[z];\n        if (pivotNode) return pivotNode;\n        pivotNode = pivotNodes[z] = document.createComment('z-index:' + (z + 1));\n        let neighborZ = -Infinity;\n        for (let currentZ in pivotNodes) {\n            currentZ = +currentZ;\n            if (currentZ < z && currentZ > neighborZ) {\n                neighborZ = currentZ;\n                if (neighborZ === z - 1) continue;\n            }\n        }\n        if (neighborZ !== -Infinity) {\n            const neighborPivot = pivotNodes[neighborZ];\n            // Insert After\n            el.insertBefore(pivotNode, neighborPivot.nextSibling);\n        } else {\n            // First Child\n            el.insertBefore(pivotNode, el.firstChild);\n        }\n        return pivotNode;\n    },\n\n    removePivots: function() {\n        const { el, pivotNodes } = this;\n        for (let z in pivotNodes) el.removeChild(pivotNodes[z]);\n        this.pivotNodes = {};\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL1BhcGVyTGF5ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0M7QUFDYzs7QUFFL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxtQkFBbUIsZ0RBQUk7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxrRUFBa0IsSUFBSSxrQkFBa0I7QUFDdkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9QYXBlckxheWVyLm1qcz9jZTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZpZXcgfSBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZVByZWZpeCB9IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuXG5leHBvcnQgY29uc3QgTGF5ZXJzTmFtZXMgPSB7XG4gICAgR1JJRDogJ2dyaWQnLFxuICAgIENFTExTOiAnY2VsbHMnLFxuICAgIEJBQ0s6ICdiYWNrJyxcbiAgICBGUk9OVDogJ2Zyb250JyxcbiAgICBUT09MUzogJ3Rvb2xzJyxcbiAgICBMQUJFTFM6ICdsYWJlbHMnXG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJMYXllciA9IFZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdnJyxcbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuICAgIHBpdm90Tm9kZXM6IG51bGwsXG4gICAgZGVmYXVsdFRoZW1lOiBudWxsLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBuYW1lOiAnJ1xuICAgIH0sXG5cbiAgICBjbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYWRkQ2xhc3NOYW1lUHJlZml4KGAke3RoaXMub3B0aW9ucy5uYW1lfS1sYXllcmApO1xuICAgIH0sXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5waXZvdE5vZGVzID0ge307XG4gICAgfSxcblxuICAgIGluc2VydFNvcnRlZE5vZGU6IGZ1bmN0aW9uKG5vZGUsIHopIHtcbiAgICAgICAgdGhpcy5lbC5pbnNlcnRCZWZvcmUobm9kZSwgdGhpcy5pbnNlcnRQaXZvdCh6KSk7XG4gICAgfSxcblxuICAgIGluc2VydE5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBlbCB9ID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gZWwpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluc2VydFBpdm90OiBmdW5jdGlvbih6KSB7XG4gICAgICAgIGNvbnN0IHsgZWwsIHBpdm90Tm9kZXMgfSA9IHRoaXM7XG4gICAgICAgIHogPSArejtcbiAgICAgICAgeiB8fCAoeiA9IDApO1xuICAgICAgICBsZXQgcGl2b3ROb2RlID0gcGl2b3ROb2Rlc1t6XTtcbiAgICAgICAgaWYgKHBpdm90Tm9kZSkgcmV0dXJuIHBpdm90Tm9kZTtcbiAgICAgICAgcGl2b3ROb2RlID0gcGl2b3ROb2Rlc1t6XSA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3otaW5kZXg6JyArICh6ICsgMSkpO1xuICAgICAgICBsZXQgbmVpZ2hib3JaID0gLUluZmluaXR5O1xuICAgICAgICBmb3IgKGxldCBjdXJyZW50WiBpbiBwaXZvdE5vZGVzKSB7XG4gICAgICAgICAgICBjdXJyZW50WiA9ICtjdXJyZW50WjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50WiA8IHogJiYgY3VycmVudFogPiBuZWlnaGJvclopIHtcbiAgICAgICAgICAgICAgICBuZWlnaGJvclogPSBjdXJyZW50WjtcbiAgICAgICAgICAgICAgICBpZiAobmVpZ2hib3JaID09PSB6IC0gMSkgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5laWdoYm9yWiAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvclBpdm90ID0gcGl2b3ROb2Rlc1tuZWlnaGJvclpdO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IEFmdGVyXG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUocGl2b3ROb2RlLCBuZWlnaGJvclBpdm90Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IENoaWxkXG4gICAgICAgICAgICBlbC5pbnNlcnRCZWZvcmUocGl2b3ROb2RlLCBlbC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGl2b3ROb2RlO1xuICAgIH0sXG5cbiAgICByZW1vdmVQaXZvdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGVsLCBwaXZvdE5vZGVzIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCB6IGluIHBpdm90Tm9kZXMpIGVsLnJlbW92ZUNoaWxkKHBpdm90Tm9kZXNbel0pO1xuICAgICAgICB0aGlzLnBpdm90Tm9kZXMgPSB7fTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ToolView.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolView: function() { return /* binding */ ToolView; }\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n\n\nconst ToolView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    name: null,\n    tagName: 'g',\n    className: 'tool',\n    svgElement: true,\n    _visible: true,\n    _visibleExplicit: true,\n\n    init: function() {\n        var name = this.name;\n        if (name) this.vel.attr('data-tool-name', name);\n    },\n\n    configure: function(view, toolsView) {\n        this.relatedView = view;\n        this.paper = view.paper;\n        this.parentView = toolsView;\n        this.simulateRelatedView(this.el);\n        // Delegate events in case the ToolView was removed from the DOM and reused.\n        this.delegateEvents();\n        return this;\n    },\n\n    simulateRelatedView: function(el) {\n        if (el) el.setAttribute('model-id', this.relatedView.model.id);\n    },\n\n    getName: function() {\n        return this.name;\n    },\n\n    // Evaluate the visibility of the tool and update the `display` CSS property\n    updateVisibility: function() {\n        const isVisible = this.computeVisibility();\n        this.el.style.display = isVisible ? '' : 'none';\n        this._visible = isVisible;\n    },\n\n    // Evaluate the visibility of the tool. The method returns `true` if the tool\n    // should be visible in the DOM.\n    computeVisibility() {\n        if (!this.isExplicitlyVisible()) return false;\n        const { visibility } = this.options;\n        if (typeof visibility !== 'function') return true;\n        return !!visibility.call(this, this.relatedView, this);\n    },\n\n    show: function() {\n        this._visibleExplicit = true;\n        this.updateVisibility();\n    },\n\n    hide: function() {\n        this._visibleExplicit = false;\n        this.updateVisibility();\n    },\n\n    // The method returns `false` if the `hide()` method was called on the tool.\n    isExplicitlyVisible: function() {\n        return !!this._visibleExplicit;\n    },\n\n    // The method returns `false` if the tool is not visible (it has `display: none`).\n    // This can happen if the `hide()` method was called or the tool is not visible\n    // because of the `visibility` option was evaluated to `false`.\n    isVisible: function() {\n        return !!this._visible;\n    },\n\n    focus: function() {\n        var opacity = this.options.focusOpacity;\n        if (isFinite(opacity)) this.el.style.opacity = opacity;\n        this.parentView.focusTool(this);\n    },\n\n    blur: function() {\n        this.el.style.opacity = '';\n        this.parentView.blurTool(this);\n    },\n\n    update: function() {\n        // to be overridden\n    },\n\n    guard: function(evt) {\n        // Let the context-menu event bubble up to the relatedView\n        const { paper, relatedView } = this;\n        if (!paper || !relatedView) return true;\n        return paper.guard(evt, relatedView);\n    }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL1Rvb2xWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3Qzs7QUFFakMsaUJBQWlCLGdEQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9Ub29sVmlldy5tanM/OTFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBtdmMgZnJvbSAnLi4vbXZjL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBUb29sVmlldyA9IG12Yy5WaWV3LmV4dGVuZCh7XG4gICAgbmFtZTogbnVsbCxcbiAgICB0YWdOYW1lOiAnZycsXG4gICAgY2xhc3NOYW1lOiAndG9vbCcsXG4gICAgc3ZnRWxlbWVudDogdHJ1ZSxcbiAgICBfdmlzaWJsZTogdHJ1ZSxcbiAgICBfdmlzaWJsZUV4cGxpY2l0OiB0cnVlLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBpZiAobmFtZSkgdGhpcy52ZWwuYXR0cignZGF0YS10b29sLW5hbWUnLCBuYW1lKTtcbiAgICB9LFxuXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbih2aWV3LCB0b29sc1ZpZXcpIHtcbiAgICAgICAgdGhpcy5yZWxhdGVkVmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMucGFwZXIgPSB2aWV3LnBhcGVyO1xuICAgICAgICB0aGlzLnBhcmVudFZpZXcgPSB0b29sc1ZpZXc7XG4gICAgICAgIHRoaXMuc2ltdWxhdGVSZWxhdGVkVmlldyh0aGlzLmVsKTtcbiAgICAgICAgLy8gRGVsZWdhdGUgZXZlbnRzIGluIGNhc2UgdGhlIFRvb2xWaWV3IHdhcyByZW1vdmVkIGZyb20gdGhlIERPTSBhbmQgcmV1c2VkLlxuICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzaW11bGF0ZVJlbGF0ZWRWaWV3OiBmdW5jdGlvbihlbCkge1xuICAgICAgICBpZiAoZWwpIGVsLnNldEF0dHJpYnV0ZSgnbW9kZWwtaWQnLCB0aGlzLnJlbGF0ZWRWaWV3Lm1vZGVsLmlkKTtcbiAgICB9LFxuXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfSxcblxuICAgIC8vIEV2YWx1YXRlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSB0b29sIGFuZCB1cGRhdGUgdGhlIGBkaXNwbGF5YCBDU1MgcHJvcGVydHlcbiAgICB1cGRhdGVWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy5jb21wdXRlVmlzaWJpbGl0eSgpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSBpc1Zpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLy8gRXZhbHVhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2wuIFRoZSBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRvb2xcbiAgICAvLyBzaG91bGQgYmUgdmlzaWJsZSBpbiB0aGUgRE9NLlxuICAgIGNvbXB1dGVWaXNpYmlsaXR5KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFeHBsaWNpdGx5VmlzaWJsZSgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgdmlzaWJpbGl0eSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIHZpc2liaWxpdHkgIT09ICdmdW5jdGlvbicpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gISF2aXNpYmlsaXR5LmNhbGwodGhpcywgdGhpcy5yZWxhdGVkVmlldywgdGhpcyk7XG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl92aXNpYmxlRXhwbGljaXQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3Zpc2libGVFeHBsaWNpdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9LFxuXG4gICAgLy8gVGhlIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGBoaWRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIG9uIHRoZSB0b29sLlxuICAgIGlzRXhwbGljaXRseVZpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl92aXNpYmxlRXhwbGljaXQ7XG4gICAgfSxcblxuICAgIC8vIFRoZSBtZXRob2QgcmV0dXJucyBgZmFsc2VgIGlmIHRoZSB0b29sIGlzIG5vdCB2aXNpYmxlIChpdCBoYXMgYGRpc3BsYXk6IG5vbmVgKS5cbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGBoaWRlKClgIG1ldGhvZCB3YXMgY2FsbGVkIG9yIHRoZSB0b29sIGlzIG5vdCB2aXNpYmxlXG4gICAgLy8gYmVjYXVzZSBvZiB0aGUgYHZpc2liaWxpdHlgIG9wdGlvbiB3YXMgZXZhbHVhdGVkIHRvIGBmYWxzZWAuXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdmlzaWJsZTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IHRoaXMub3B0aW9ucy5mb2N1c09wYWNpdHk7XG4gICAgICAgIGlmIChpc0Zpbml0ZShvcGFjaXR5KSkgdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgdGhpcy5wYXJlbnRWaWV3LmZvY3VzVG9vbCh0aGlzKTtcbiAgICB9LFxuXG4gICAgYmx1cjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICB0aGlzLnBhcmVudFZpZXcuYmx1clRvb2wodGhpcyk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRvIGJlIG92ZXJyaWRkZW5cbiAgICB9LFxuXG4gICAgZ3VhcmQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAvLyBMZXQgdGhlIGNvbnRleHQtbWVudSBldmVudCBidWJibGUgdXAgdG8gdGhlIHJlbGF0ZWRWaWV3XG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIHJlbGF0ZWRWaWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXBhcGVyIHx8ICFyZWxhdGVkVmlldykgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBwYXBlci5ndWFyZChldnQsIHJlbGF0ZWRWaWV3KTtcbiAgICB9XG59KTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolsView.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ToolsView.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ToolsView: function() { return /* binding */ ToolsView; }\n/* harmony export */ });\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CellView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n\n\n\n\n\n\nconst ToolsView = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: 'g',\n    className: 'tools',\n    svgElement: true,\n    tools: null,\n    isRendered: false,\n    options: {\n        tools: null,\n        relatedView: null,\n        name: null,\n        // layer?: LayersNames.TOOLS\n        // z?: number\n    },\n\n    configure: function(options) {\n        options = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign(this.options, options);\n        var tools = options.tools;\n        if (!Array.isArray(tools)) return this;\n        var relatedView = options.relatedView;\n        if (!(relatedView instanceof _CellView_mjs__WEBPACK_IMPORTED_MODULE_2__.CellView)) return this;\n        var views = this.tools = [];\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (!(tool instanceof _ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__.ToolView)) continue;\n            tool.configure(relatedView, this);\n            this.vel.append(tool.el);\n            views.push(tool);\n        }\n        this.isRendered = false;\n        relatedView.requestUpdate(relatedView.getFlag('TOOLS'));\n        return this;\n    },\n\n    getName: function() {\n        return this.options.name;\n    },\n\n    update: function(opt) {\n\n        opt || (opt = {});\n        const tools = this.tools;\n        if (!tools) return this;\n        const n = tools.length;\n        const wasRendered = this.isRendered;\n        for (let i = 0; i < n; i++) {\n            const tool = tools[i];\n            tool.updateVisibility();\n            if (!tool.isVisible()) continue;\n            if (this.ensureToolRendered(tools, i) && opt.tool !== tool.cid) {\n                tool.update();\n            }\n        }\n        if (!this.isRendered && n > 0) {\n            // None of the tools is visible\n            // Note: ToolsView with no tools are always mounted\n            return this;\n        }\n        if (!this.isMounted()) {\n            this.mount();\n        }\n        if (!wasRendered) {\n            // Make sure tools are visible (if they were hidden and the tool removed)\n            this.blurTool();\n        }\n        return this;\n    },\n\n    ensureToolRendered(tools, i) {\n        if (!this.isRendered) {\n            // There is at least one visible tool\n            this.isRendered = Array(tools.length).fill(false);\n        }\n        if (!this.isRendered[i]) {\n            // First update executes render()\n            tools[i].render();\n            this.isRendered[i] = true;\n            return false;\n        }\n        return true;\n    },\n\n    focusTool: function(focusedTool) {\n\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (focusedTool === tool) {\n                tool.show();\n            } else {\n                tool.hide();\n            }\n        }\n        return this;\n    },\n\n    blurTool: function(blurredTool) {\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            var tool = tools[i];\n            if (tool !== blurredTool && !tool.isExplicitlyVisible()) {\n                tool.show();\n                // Check if the tool is conditionally visible too\n                if (tool.isVisible()) {\n                    this.ensureToolRendered(tools, i) && tool.update();\n                }\n            }\n        }\n        return this;\n    },\n\n    hide: function() {\n        return this.focusTool(null);\n    },\n\n    show: function() {\n        this.blurTool(null);\n        // If this the first time the tools are shown, make sure they are mounted\n        if (!this.isMounted()) {\n            this.mount();\n        }\n        return this;\n    },\n\n    onRemove: function() {\n        var tools = this.tools;\n        if (!tools) return this;\n        for (var i = 0, n = tools.length; i < n; i++) {\n            tools[i].remove();\n        }\n        this.tools = null;\n    },\n\n    mount: function() {\n        const { options, el } = this;\n        const { relatedView, layer = _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_4__.LayersNames.TOOLS, z } = options;\n        if (relatedView) {\n            if (layer) {\n                relatedView.paper.getLayerView(layer).insertSortedNode(el, z);\n            } else {\n                relatedView.el.appendChild(el);\n            }\n        }\n        return this;\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL1Rvb2xzVmlldy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXdDO0FBQ0U7QUFDQTtBQUNLO0FBQ0w7O0FBRW5DLGtCQUFrQixnREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtCQUFrQixtREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbURBQVE7QUFDN0M7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBLGtDQUFrQyxtREFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IscUJBQXFCLHdEQUFXLFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9Ub29sc1ZpZXcubWpzPzdkMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbXZjIGZyb20gJy4uL212Yy9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBDZWxsVmlldyB9IGZyb20gJy4vQ2VsbFZpZXcubWpzJztcbmltcG9ydCB7IExheWVyc05hbWVzIH0gZnJvbSAnLi9QYXBlckxheWVyLm1qcyc7XG5pbXBvcnQgeyBUb29sVmlldyB9IGZyb20gJy4vVG9vbFZpZXcubWpzJztcblxuZXhwb3J0IGNvbnN0IFRvb2xzVmlldyA9IG12Yy5WaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogJ2cnLFxuICAgIGNsYXNzTmFtZTogJ3Rvb2xzJyxcbiAgICBzdmdFbGVtZW50OiB0cnVlLFxuICAgIHRvb2xzOiBudWxsLFxuICAgIGlzUmVuZGVyZWQ6IGZhbHNlLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdG9vbHM6IG51bGwsXG4gICAgICAgIHJlbGF0ZWRWaWV3OiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAvLyBsYXllcj86IExheWVyc05hbWVzLlRPT0xTXG4gICAgICAgIC8vIHo/OiBudW1iZXJcbiAgICB9LFxuXG4gICAgY29uZmlndXJlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1dGlsLmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgdG9vbHMgPSBvcHRpb25zLnRvb2xzO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9vbHMpKSByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gb3B0aW9ucy5yZWxhdGVkVmlldztcbiAgICAgICAgaWYgKCEocmVsYXRlZFZpZXcgaW5zdGFuY2VvZiBDZWxsVmlldykpIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgdmlld3MgPSB0aGlzLnRvb2xzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG9vbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9vbCA9IHRvb2xzW2ldO1xuICAgICAgICAgICAgaWYgKCEodG9vbCBpbnN0YW5jZW9mIFRvb2xWaWV3KSkgY29udGludWU7XG4gICAgICAgICAgICB0b29sLmNvbmZpZ3VyZShyZWxhdGVkVmlldywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZlbC5hcHBlbmQodG9vbC5lbCk7XG4gICAgICAgICAgICB2aWV3cy5wdXNoKHRvb2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICByZWxhdGVkVmlldy5yZXF1ZXN0VXBkYXRlKHJlbGF0ZWRWaWV3LmdldEZsYWcoJ1RPT0xTJykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgfHwgKG9wdCA9IHt9KTtcbiAgICAgICAgY29uc3QgdG9vbHMgPSB0aGlzLnRvb2xzO1xuICAgICAgICBpZiAoIXRvb2xzKSByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgbiA9IHRvb2xzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgd2FzUmVuZGVyZWQgPSB0aGlzLmlzUmVuZGVyZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sID0gdG9vbHNbaV07XG4gICAgICAgICAgICB0b29sLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIGlmICghdG9vbC5pc1Zpc2libGUoKSkgY29udGludWU7XG4gICAgICAgICAgICBpZiAodGhpcy5lbnN1cmVUb29sUmVuZGVyZWQodG9vbHMsIGkpICYmIG9wdC50b29sICE9PSB0b29sLmNpZCkge1xuICAgICAgICAgICAgICAgIHRvb2wudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyZWQgJiYgbiA+IDApIHtcbiAgICAgICAgICAgIC8vIE5vbmUgb2YgdGhlIHRvb2xzIGlzIHZpc2libGVcbiAgICAgICAgICAgIC8vIE5vdGU6IFRvb2xzVmlldyB3aXRoIG5vIHRvb2xzIGFyZSBhbHdheXMgbW91bnRlZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YXNSZW5kZXJlZCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2xzIGFyZSB2aXNpYmxlIChpZiB0aGV5IHdlcmUgaGlkZGVuIGFuZCB0aGUgdG9vbCByZW1vdmVkKVxuICAgICAgICAgICAgdGhpcy5ibHVyVG9vbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlbnN1cmVUb29sUmVuZGVyZWQodG9vbHMsIGkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSB2aXNpYmxlIHRvb2xcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IEFycmF5KHRvb2xzLmxlbmd0aCkuZmlsbChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzUmVuZGVyZWRbaV0pIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHVwZGF0ZSBleGVjdXRlcyByZW5kZXIoKVxuICAgICAgICAgICAgdG9vbHNbaV0ucmVuZGVyKCk7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyZWRbaV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBmb2N1c1Rvb2w6IGZ1bmN0aW9uKGZvY3VzZWRUb29sKSB7XG5cbiAgICAgICAgdmFyIHRvb2xzID0gdGhpcy50b29scztcbiAgICAgICAgaWYgKCF0b29scykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG9vbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9vbCA9IHRvb2xzW2ldO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWRUb29sID09PSB0b29sKSB7XG4gICAgICAgICAgICAgICAgdG9vbC5zaG93KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb2wuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBibHVyVG9vbDogZnVuY3Rpb24oYmx1cnJlZFRvb2wpIHtcbiAgICAgICAgdmFyIHRvb2xzID0gdGhpcy50b29scztcbiAgICAgICAgaWYgKCF0b29scykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG9vbHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdG9vbCA9IHRvb2xzW2ldO1xuICAgICAgICAgICAgaWYgKHRvb2wgIT09IGJsdXJyZWRUb29sICYmICF0b29sLmlzRXhwbGljaXRseVZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHRvb2wuc2hvdygpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB0b29sIGlzIGNvbmRpdGlvbmFsbHkgdmlzaWJsZSB0b29cbiAgICAgICAgICAgICAgICBpZiAodG9vbC5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZVRvb2xSZW5kZXJlZCh0b29scywgaSkgJiYgdG9vbC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c1Rvb2wobnVsbCk7XG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJsdXJUb29sKG51bGwpO1xuICAgICAgICAvLyBJZiB0aGlzIHRoZSBmaXJzdCB0aW1lIHRoZSB0b29scyBhcmUgc2hvd24sIG1ha2Ugc3VyZSB0aGV5IGFyZSBtb3VudGVkXG4gICAgICAgIGlmICghdGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5tb3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b29scyA9IHRoaXMudG9vbHM7XG4gICAgICAgIGlmICghdG9vbHMpIHJldHVybiB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHRvb2xzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdG9vbHNbaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b29scyA9IG51bGw7XG4gICAgfSxcblxuICAgIG1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCBlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyByZWxhdGVkVmlldywgbGF5ZXIgPSBMYXllcnNOYW1lcy5UT09MUywgeiB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHJlbGF0ZWRWaWV3KSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkVmlldy5wYXBlci5nZXRMYXllclZpZXcobGF5ZXIpLmluc2VydFNvcnRlZE5vZGUoZWwsIHopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkVmlldy5lbC5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolsView.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/connection.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/connection.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\nfunction atConnectionWrapper(method, opt) {\n    var zeroVector = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(1, 0);\n    return function(value) {\n        var p, angle;\n        var tangent = this[method](value);\n        if (tangent) {\n            angle = (opt.rotate) ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        } else {\n            p = this.path.start;\n            angle = 0;\n        }\n        if (angle === 0) return { transform: 'translate(' + p.x + ',' + p.y + ')' };\n        return { transform: 'translate(' + p.x + ',' + p.y + ') rotate(' + angle + ')' };\n    };\n}\n\nfunction isLinkView() {\n    return this.model.isLink();\n}\n\nconst connectionAttributesNS = {\n\n    'connection': {\n        qualify: isLinkView,\n        unset: 'd',\n        set: function({ stubs = 0 }) {\n            let d;\n            if (isFinite(stubs) && stubs !== 0) {\n                let offset;\n                if (stubs < 0) {\n                    offset = (this.getConnectionLength() + stubs) / 2;\n                } else {\n                    offset = stubs;\n                }\n                const path = this.getConnection();\n                const segmentSubdivisions = this.getConnectionSubdivisions();\n                const sourceParts = path.divideAtLength(offset, { segmentSubdivisions });\n                const targetParts = path.divideAtLength(-offset, { segmentSubdivisions });\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n\n            return { d: d || this.getSerializedConnection() };\n        }\n    },\n\n    'at-connection-length-keep-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtLength', { rotate: true })\n    },\n\n    'at-connection-length-ignore-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtLength', { rotate: false })\n    },\n\n    'at-connection-ratio-keep-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: true })\n    },\n\n    'at-connection-ratio-ignore-gradient': {\n        qualify: isLinkView,\n        unset: 'transform',\n        set: atConnectionWrapper('getTangentAtRatio', { rotate: false })\n    }\n\n};\n\nconnectionAttributesNS['at-connection-length'] = connectionAttributesNS['at-connection-length-keep-gradient'];\nconnectionAttributesNS['at-connection-ratio'] = connectionAttributesNS['at-connection-ratio-keep-gradient'];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (connectionAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvY29ubmVjdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7QUFBMEM7O0FBRTFDO0FBQ0EseUJBQXlCLCtDQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGLG1FQUFtRSxxQkFBcUI7QUFDeEY7QUFDQSwyQkFBMkIsNEJBQTRCLEVBQUUsMkJBQTJCO0FBQ3BGO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxlQUFlO0FBQ3hFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWM7QUFDdEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLCtEQUFlLHNCQUFzQixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvY29ubmVjdGlvbi5tanM/M2VkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL2cvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gYXRDb25uZWN0aW9uV3JhcHBlcihtZXRob2QsIG9wdCkge1xuICAgIHZhciB6ZXJvVmVjdG9yID0gbmV3IFBvaW50KDEsIDApO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcCwgYW5nbGU7XG4gICAgICAgIHZhciB0YW5nZW50ID0gdGhpc1ttZXRob2RdKHZhbHVlKTtcbiAgICAgICAgaWYgKHRhbmdlbnQpIHtcbiAgICAgICAgICAgIGFuZ2xlID0gKG9wdC5yb3RhdGUpID8gdGFuZ2VudC52ZWN0b3IoKS52ZWN0b3JBbmdsZSh6ZXJvVmVjdG9yKSA6IDA7XG4gICAgICAgICAgICBwID0gdGFuZ2VudC5zdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgPSB0aGlzLnBhdGguc3RhcnQ7XG4gICAgICAgICAgICBhbmdsZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuZ2xlID09PSAwKSByZXR1cm4geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHAueCArICcsJyArIHAueSArICcpJyB9O1xuICAgICAgICByZXR1cm4geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHAueCArICcsJyArIHAueSArICcpIHJvdGF0ZSgnICsgYW5nbGUgKyAnKScgfTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0xpbmtWaWV3KCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsLmlzTGluaygpO1xufVxuXG5jb25zdCBjb25uZWN0aW9uQXR0cmlidXRlc05TID0ge1xuXG4gICAgJ2Nvbm5lY3Rpb24nOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHVuc2V0OiAnZCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24oeyBzdHVicyA9IDAgfSkge1xuICAgICAgICAgICAgbGV0IGQ7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoc3R1YnMpICYmIHN0dWJzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAoc3R1YnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9ICh0aGlzLmdldENvbm5lY3Rpb25MZW5ndGgoKSArIHN0dWJzKSAvIDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gc3R1YnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWdtZW50U3ViZGl2aXNpb25zID0gdGhpcy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlUGFydHMgPSBwYXRoLmRpdmlkZUF0TGVuZ3RoKG9mZnNldCwgeyBzZWdtZW50U3ViZGl2aXNpb25zIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhcnRzID0gcGF0aC5kaXZpZGVBdExlbmd0aCgtb2Zmc2V0LCB7IHNlZ21lbnRTdWJkaXZpc2lvbnMgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVBhcnRzICYmIHRhcmdldFBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBgJHtzb3VyY2VQYXJ0c1swXS5zZXJpYWxpemUoKX0gJHt0YXJnZXRQYXJ0c1sxXS5zZXJpYWxpemUoKX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgZDogZCB8fCB0aGlzLmdldFNlcmlhbGl6ZWRDb25uZWN0aW9uKCkgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAnYXQtY29ubmVjdGlvbi1sZW5ndGgta2VlcC1ncmFkaWVudCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNMaW5rVmlldyxcbiAgICAgICAgdW5zZXQ6ICd0cmFuc2Zvcm0nLFxuICAgICAgICBzZXQ6IGF0Q29ubmVjdGlvbldyYXBwZXIoJ2dldFRhbmdlbnRBdExlbmd0aCcsIHsgcm90YXRlOiB0cnVlIH0pXG4gICAgfSxcblxuICAgICdhdC1jb25uZWN0aW9uLWxlbmd0aC1pZ25vcmUtZ3JhZGllbnQnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzTGlua1ZpZXcsXG4gICAgICAgIHVuc2V0OiAndHJhbnNmb3JtJyxcbiAgICAgICAgc2V0OiBhdENvbm5lY3Rpb25XcmFwcGVyKCdnZXRUYW5nZW50QXRMZW5ndGgnLCB7IHJvdGF0ZTogZmFsc2UgfSlcbiAgICB9LFxuXG4gICAgJ2F0LWNvbm5lY3Rpb24tcmF0aW8ta2VlcC1ncmFkaWVudCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNMaW5rVmlldyxcbiAgICAgICAgdW5zZXQ6ICd0cmFuc2Zvcm0nLFxuICAgICAgICBzZXQ6IGF0Q29ubmVjdGlvbldyYXBwZXIoJ2dldFRhbmdlbnRBdFJhdGlvJywgeyByb3RhdGU6IHRydWUgfSlcbiAgICB9LFxuXG4gICAgJ2F0LWNvbm5lY3Rpb24tcmF0aW8taWdub3JlLWdyYWRpZW50Jzoge1xuICAgICAgICBxdWFsaWZ5OiBpc0xpbmtWaWV3LFxuICAgICAgICB1bnNldDogJ3RyYW5zZm9ybScsXG4gICAgICAgIHNldDogYXRDb25uZWN0aW9uV3JhcHBlcignZ2V0VGFuZ2VudEF0UmF0aW8nLCB7IHJvdGF0ZTogZmFsc2UgfSlcbiAgICB9XG5cbn07XG5cbmNvbm5lY3Rpb25BdHRyaWJ1dGVzTlNbJ2F0LWNvbm5lY3Rpb24tbGVuZ3RoJ10gPSBjb25uZWN0aW9uQXR0cmlidXRlc05TWydhdC1jb25uZWN0aW9uLWxlbmd0aC1rZWVwLWdyYWRpZW50J107XG5jb25uZWN0aW9uQXR0cmlidXRlc05TWydhdC1jb25uZWN0aW9uLXJhdGlvJ10gPSBjb25uZWN0aW9uQXR0cmlidXRlc05TWydhdC1jb25uZWN0aW9uLXJhdGlvLWtlZXAtZ3JhZGllbnQnXTtcblxuZXhwb3J0IGRlZmF1bHQgY29ubmVjdGlvbkF0dHJpYnV0ZXNOUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/connection.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/defs.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/defs.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\nfunction contextMarker(context) {\n    var marker = {};\n    // Stroke\n    // The context 'fill' is disregarded here. The usual case is to use the marker with a connection\n    // (for which 'fill' attribute is set to 'none').\n    var stroke = context.stroke;\n    if (typeof stroke === 'string') {\n        marker['stroke'] = stroke;\n        marker['fill'] = stroke;\n    }\n    // Opacity\n    // Again the context 'fill-opacity' is ignored.\n    var strokeOpacity = context['stroke-opacity'];\n    if (strokeOpacity === undefined) strokeOpacity = context.opacity;\n    if (strokeOpacity !== undefined) {\n        marker['stroke-opacity'] = strokeOpacity;\n        marker['fill-opacity'] = strokeOpacity;\n    }\n    return marker;\n}\n\nfunction setPaintURL(def) {\n    const { paper } = this;\n    const url = (def.type === 'pattern')\n        ? paper.definePattern(def)\n        : paper.defineGradient(def);\n    return `url(#${url})`;\n}\n\nconst defsAttributesNS = {\n\n    'source-marker': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        unset: 'marker-start',\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(contextMarker(attrs), marker);\n            return { 'marker-start': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'target-marker': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        unset: 'marker-end',\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(contextMarker(attrs), { 'transform': 'rotate(180)' }, marker);\n            return { 'marker-end': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'vertex-marker': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        unset: 'marker-mid',\n        set: function(marker, refBBox, node, attrs) {\n            marker = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(contextMarker(attrs), marker);\n            return { 'marker-mid': 'url(#' + this.paper.defineMarker(marker) + ')' };\n        }\n    },\n\n    'fill': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: setPaintURL\n    },\n\n    'stroke': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: setPaintURL\n    },\n\n    'filter': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: function(filter) {\n            return 'url(#' + this.paper.defineFilter(filter) + ')';\n        }\n    },\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (defsAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvZGVmcy5tanMiLCJtYXBwaW5ncyI6Ijs7QUFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLElBQUk7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQSxpQkFBaUIseURBQWE7QUFDOUI7QUFDQTtBQUNBLHFCQUFxQixzREFBTTtBQUMzQixxQkFBcUI7QUFDckI7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQU0seUJBQXlCLDRCQUE0QjtBQUNoRixxQkFBcUI7QUFDckI7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsc0RBQU07QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlCQUFpQix5REFBYTtBQUM5QjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQkFBaUIseURBQWE7QUFDOUI7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSwrREFBZSxnQkFBZ0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2RlZnMubWpzP2UxMzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzaWduLCBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsLm1qcyc7XG5cbmZ1bmN0aW9uIGNvbnRleHRNYXJrZXIoY29udGV4dCkge1xuICAgIHZhciBtYXJrZXIgPSB7fTtcbiAgICAvLyBTdHJva2VcbiAgICAvLyBUaGUgY29udGV4dCAnZmlsbCcgaXMgZGlzcmVnYXJkZWQgaGVyZS4gVGhlIHVzdWFsIGNhc2UgaXMgdG8gdXNlIHRoZSBtYXJrZXIgd2l0aCBhIGNvbm5lY3Rpb25cbiAgICAvLyAoZm9yIHdoaWNoICdmaWxsJyBhdHRyaWJ1dGUgaXMgc2V0IHRvICdub25lJykuXG4gICAgdmFyIHN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlO1xuICAgIGlmICh0eXBlb2Ygc3Ryb2tlID09PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrZXJbJ3N0cm9rZSddID0gc3Ryb2tlO1xuICAgICAgICBtYXJrZXJbJ2ZpbGwnXSA9IHN0cm9rZTtcbiAgICB9XG4gICAgLy8gT3BhY2l0eVxuICAgIC8vIEFnYWluIHRoZSBjb250ZXh0ICdmaWxsLW9wYWNpdHknIGlzIGlnbm9yZWQuXG4gICAgdmFyIHN0cm9rZU9wYWNpdHkgPSBjb250ZXh0WydzdHJva2Utb3BhY2l0eSddO1xuICAgIGlmIChzdHJva2VPcGFjaXR5ID09PSB1bmRlZmluZWQpIHN0cm9rZU9wYWNpdHkgPSBjb250ZXh0Lm9wYWNpdHk7XG4gICAgaWYgKHN0cm9rZU9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXJrZXJbJ3N0cm9rZS1vcGFjaXR5J10gPSBzdHJva2VPcGFjaXR5O1xuICAgICAgICBtYXJrZXJbJ2ZpbGwtb3BhY2l0eSddID0gc3Ryb2tlT3BhY2l0eTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlcjtcbn1cblxuZnVuY3Rpb24gc2V0UGFpbnRVUkwoZGVmKSB7XG4gICAgY29uc3QgeyBwYXBlciB9ID0gdGhpcztcbiAgICBjb25zdCB1cmwgPSAoZGVmLnR5cGUgPT09ICdwYXR0ZXJuJylcbiAgICAgICAgPyBwYXBlci5kZWZpbmVQYXR0ZXJuKGRlZilcbiAgICAgICAgOiBwYXBlci5kZWZpbmVHcmFkaWVudChkZWYpO1xuICAgIHJldHVybiBgdXJsKCMke3VybH0pYDtcbn1cblxuY29uc3QgZGVmc0F0dHJpYnV0ZXNOUyA9IHtcblxuICAgICdzb3VyY2UtbWFya2VyJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICB1bnNldDogJ21hcmtlci1zdGFydCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24obWFya2VyLCByZWZCQm94LCBub2RlLCBhdHRycykge1xuICAgICAgICAgICAgbWFya2VyID0gYXNzaWduKGNvbnRleHRNYXJrZXIoYXR0cnMpLCBtYXJrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgJ21hcmtlci1zdGFydCc6ICd1cmwoIycgKyB0aGlzLnBhcGVyLmRlZmluZU1hcmtlcihtYXJrZXIpICsgJyknIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3RhcmdldC1tYXJrZXInOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHVuc2V0OiAnbWFya2VyLWVuZCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24obWFya2VyLCByZWZCQm94LCBub2RlLCBhdHRycykge1xuICAgICAgICAgICAgbWFya2VyID0gYXNzaWduKGNvbnRleHRNYXJrZXIoYXR0cnMpLCB7ICd0cmFuc2Zvcm0nOiAncm90YXRlKDE4MCknIH0sIG1hcmtlcik7XG4gICAgICAgICAgICByZXR1cm4geyAnbWFya2VyLWVuZCc6ICd1cmwoIycgKyB0aGlzLnBhcGVyLmRlZmluZU1hcmtlcihtYXJrZXIpICsgJyknIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3ZlcnRleC1tYXJrZXInOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHVuc2V0OiAnbWFya2VyLW1pZCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24obWFya2VyLCByZWZCQm94LCBub2RlLCBhdHRycykge1xuICAgICAgICAgICAgbWFya2VyID0gYXNzaWduKGNvbnRleHRNYXJrZXIoYXR0cnMpLCBtYXJrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgJ21hcmtlci1taWQnOiAndXJsKCMnICsgdGhpcy5wYXBlci5kZWZpbmVNYXJrZXIobWFya2VyKSArICcpJyB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdmaWxsJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IHNldFBhaW50VVJMXG4gICAgfSxcblxuICAgICdzdHJva2UnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHNldDogc2V0UGFpbnRVUkxcbiAgICB9LFxuXG4gICAgJ2ZpbHRlcic6IHtcbiAgICAgICAgcXVhbGlmeTogaXNQbGFpbk9iamVjdCxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5wYXBlci5kZWZpbmVGaWx0ZXIoZmlsdGVyKSArICcpJztcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBkZWZzQXR0cmlidXRlc05TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/defs.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/eval.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/eval.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalAttribute: function() { return /* binding */ evalAttribute; },\n/* harmony export */   evalAttributes: function() { return /* binding */ evalAttributes; }\n/* harmony export */ });\n/* harmony import */ var _util_calc_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/calc.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\");\n\n\nconst calcAttributesList = [\n    'transform',\n    'x',\n    'y',\n    'cx',\n    'cy',\n    'dx',\n    'dy',\n    'x1',\n    'y1',\n    'x2',\n    'y2',\n    'points',\n    'd',\n    'r',\n    'rx',\n    'ry',\n    'width',\n    'height',\n    'stroke-width',\n    'font-size',\n];\n\nconst positiveValueList = [\n    'r',\n    'rx',\n    'ry',\n    'width',\n    'height',\n    'stroke-width',\n    'font-size',\n];\n\nconst calcAttributes = calcAttributesList.reduce((acc, attrName) => {\n    acc[attrName] = true;\n    return acc;\n}, {});\n\nconst positiveValueAttributes = positiveValueList.reduce((acc, attrName) => {\n    acc[attrName] = true;\n    return acc;\n}, {});\n\nfunction evalAttributes(attrs, refBBox) {\n    const evalAttrs = {};\n    for (let attrName in attrs) {\n        if (!attrs.hasOwnProperty(attrName)) continue;\n        evalAttrs[attrName] = evalAttribute(attrName, attrs[attrName], refBBox);\n    }\n    return evalAttrs;\n}\n\nfunction evalAttribute(attrName, attrValue, refBBox) {\n    if (attrName in calcAttributes && (0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_0__.isCalcExpression)(attrValue)) {\n        let evalAttrValue = (0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_0__.evalCalcExpression)(attrValue, refBBox);\n        if (attrName in positiveValueAttributes) {\n            evalAttrValue = Math.max(0, evalAttrValue);\n        }\n        return evalAttrValue;\n    }\n    return attrValue;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvZXZhbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJFOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJOztBQUVMO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFRTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1Asc0NBQXNDLGdFQUFnQjtBQUN0RCw0QkFBNEIsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvZXZhbC5tanM/ZGY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0NhbGNFeHByZXNzaW9uLCBldmFsQ2FsY0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi91dGlsL2NhbGMubWpzJztcblxuY29uc3QgY2FsY0F0dHJpYnV0ZXNMaXN0ID0gW1xuICAgICd0cmFuc2Zvcm0nLFxuICAgICd4JyxcbiAgICAneScsXG4gICAgJ2N4JyxcbiAgICAnY3knLFxuICAgICdkeCcsXG4gICAgJ2R5JyxcbiAgICAneDEnLFxuICAgICd5MScsXG4gICAgJ3gyJyxcbiAgICAneTInLFxuICAgICdwb2ludHMnLFxuICAgICdkJyxcbiAgICAncicsXG4gICAgJ3J4JyxcbiAgICAncnknLFxuICAgICd3aWR0aCcsXG4gICAgJ2hlaWdodCcsXG4gICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgJ2ZvbnQtc2l6ZScsXG5dO1xuXG5jb25zdCBwb3NpdGl2ZVZhbHVlTGlzdCA9IFtcbiAgICAncicsXG4gICAgJ3J4JyxcbiAgICAncnknLFxuICAgICd3aWR0aCcsXG4gICAgJ2hlaWdodCcsXG4gICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgJ2ZvbnQtc2l6ZScsXG5dO1xuXG5jb25zdCBjYWxjQXR0cmlidXRlcyA9IGNhbGNBdHRyaWJ1dGVzTGlzdC5yZWR1Y2UoKGFjYywgYXR0ck5hbWUpID0+IHtcbiAgICBhY2NbYXR0ck5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuXG5jb25zdCBwb3NpdGl2ZVZhbHVlQXR0cmlidXRlcyA9IHBvc2l0aXZlVmFsdWVMaXN0LnJlZHVjZSgoYWNjLCBhdHRyTmFtZSkgPT4ge1xuICAgIGFjY1thdHRyTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiBhY2M7XG59LCB7fSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsQXR0cmlidXRlcyhhdHRycywgcmVmQkJveCkge1xuICAgIGNvbnN0IGV2YWxBdHRycyA9IHt9O1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0ck5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgZXZhbEF0dHJzW2F0dHJOYW1lXSA9IGV2YWxBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJzW2F0dHJOYW1lXSwgcmVmQkJveCk7XG4gICAgfVxuICAgIHJldHVybiBldmFsQXR0cnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsQXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUsIHJlZkJCb3gpIHtcbiAgICBpZiAoYXR0ck5hbWUgaW4gY2FsY0F0dHJpYnV0ZXMgJiYgaXNDYWxjRXhwcmVzc2lvbihhdHRyVmFsdWUpKSB7XG4gICAgICAgIGxldCBldmFsQXR0clZhbHVlID0gZXZhbENhbGNFeHByZXNzaW9uKGF0dHJWYWx1ZSwgcmVmQkJveCk7XG4gICAgICAgIGlmIChhdHRyTmFtZSBpbiBwb3NpdGl2ZVZhbHVlQXR0cmlidXRlcykge1xuICAgICAgICAgICAgZXZhbEF0dHJWYWx1ZSA9IE1hdGgubWF4KDAsIGV2YWxBdHRyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmFsQXR0clZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0clZhbHVlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/eval.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/index.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   attributes: function() { return /* binding */ attributes; }\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _props_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/props.mjs\");\n/* harmony import */ var _legacy_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./legacy.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/legacy.mjs\");\n/* harmony import */ var _text_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./text.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/text.mjs\");\n/* harmony import */ var _connection_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./connection.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/connection.mjs\");\n/* harmony import */ var _shape_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shape.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/shape.mjs\");\n/* harmony import */ var _defs_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./defs.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/defs.mjs\");\n/* harmony import */ var _offset_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./offset.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/offset.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction setIfChangedWrapper(attribute) {\n    return function setIfChanged(value, _, node) {\n        const vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n        if (vel.attr(attribute) === value) return;\n        vel.attr(attribute, value);\n    };\n}\n\nconst attributesNS = {\n\n    'ref': {\n        // We do not set `ref` attribute directly on an element.\n        // The attribute itself does not qualify for relative positioning.\n    },\n\n    'href': {\n        set: setIfChangedWrapper('href')\n    },\n\n    'xlink:href': {\n        set: setIfChangedWrapper('xlink:href')\n    },\n\n    // `port` attribute contains the `id` of the port that the underlying magnet represents.\n    'port': {\n        set: function(port) {\n            return (port === null || port.id === undefined) ? port : port.id;\n        }\n    },\n\n    // `style` attribute is special in the sense that it sets the CSS style of the sub-element.\n    'style': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject,\n        set: function(styles, refBBox, node) {\n            (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).css(styles);\n        }\n    },\n\n    'html': {\n        unset: function(node) {\n            (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).empty();\n        },\n        set: function(html, refBBox, node) {\n            (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).html(html + '');\n        }\n    },\n\n    // Properties setter (set various properties on the node)\n    props: _props_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n};\n\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _legacy_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _text_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _connection_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _shape_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _defs_mjs__WEBPACK_IMPORTED_MODULE_8__[\"default\"]);\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(attributesNS, _offset_mjs__WEBPACK_IMPORTED_MODULE_9__[\"default\"]);\n\nconst attributes = attributesNS;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ3BCO0FBQ047O0FBRUY7QUFDYztBQUNKO0FBQ1k7QUFDVjtBQUNGO0FBQ0k7O0FBRTlDO0FBQ0E7QUFDQSxvQkFBb0Isd0RBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFhO0FBQzlCO0FBQ0EsWUFBWSw4REFBQztBQUNiO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsWUFBWSw4REFBQztBQUNiLFNBQVM7QUFDVDtBQUNBLFlBQVksOERBQUM7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsc0RBQU0sZUFBZSxtREFBa0I7QUFDdkMsc0RBQU0sZUFBZSxpREFBZ0I7QUFDckMsc0RBQU0sZUFBZSx1REFBc0I7QUFDM0Msc0RBQU0sZUFBZSxrREFBaUI7QUFDdEMsc0RBQU0sZUFBZSxpREFBZ0I7QUFDckMsc0RBQU0sZUFBZSxtREFBa0I7O0FBRWhDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvaW5kZXgubWpzPzhhMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzaWduLCBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsLm1qcyc7XG5pbXBvcnQgJCBmcm9tICcuLi8uLi9tdmMvRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi8uLi9WL2luZGV4Lm1qcyc7XG5cbmltcG9ydCBwcm9wcyBmcm9tICcuL3Byb3BzLm1qcyc7XG5pbXBvcnQgbGVnYWN5QXR0cmlidXRlc05TIGZyb20gJy4vbGVnYWN5Lm1qcyc7XG5pbXBvcnQgdGV4dEF0dHJpYnV0ZXNOUyBmcm9tICcuL3RleHQubWpzJztcbmltcG9ydCBjb25uZWN0aW9uQXR0cmlidXRlc05TIGZyb20gJy4vY29ubmVjdGlvbi5tanMnO1xuaW1wb3J0IHNoYXBlQXR0cmlidXRlc05TIGZyb20gJy4vc2hhcGUubWpzJztcbmltcG9ydCBkZWZzQXR0cmlidXRlc05TIGZyb20gJy4vZGVmcy5tanMnO1xuaW1wb3J0IG9mZnNldEF0dHJpYnV0ZXNOUyBmcm9tICcuL29mZnNldC5tanMnO1xuXG5mdW5jdGlvbiBzZXRJZkNoYW5nZWRXcmFwcGVyKGF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXRJZkNoYW5nZWQodmFsdWUsIF8sIG5vZGUpIHtcbiAgICAgICAgY29uc3QgdmVsID0gVihub2RlKTtcbiAgICAgICAgaWYgKHZlbC5hdHRyKGF0dHJpYnV0ZSkgPT09IHZhbHVlKSByZXR1cm47XG4gICAgICAgIHZlbC5hdHRyKGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH07XG59XG5cbmNvbnN0IGF0dHJpYnV0ZXNOUyA9IHtcblxuICAgICdyZWYnOiB7XG4gICAgICAgIC8vIFdlIGRvIG5vdCBzZXQgYHJlZmAgYXR0cmlidXRlIGRpcmVjdGx5IG9uIGFuIGVsZW1lbnQuXG4gICAgICAgIC8vIFRoZSBhdHRyaWJ1dGUgaXRzZWxmIGRvZXMgbm90IHF1YWxpZnkgZm9yIHJlbGF0aXZlIHBvc2l0aW9uaW5nLlxuICAgIH0sXG5cbiAgICAnaHJlZic6IHtcbiAgICAgICAgc2V0OiBzZXRJZkNoYW5nZWRXcmFwcGVyKCdocmVmJylcbiAgICB9LFxuXG4gICAgJ3hsaW5rOmhyZWYnOiB7XG4gICAgICAgIHNldDogc2V0SWZDaGFuZ2VkV3JhcHBlcigneGxpbms6aHJlZicpXG4gICAgfSxcblxuICAgIC8vIGBwb3J0YCBhdHRyaWJ1dGUgY29udGFpbnMgdGhlIGBpZGAgb2YgdGhlIHBvcnQgdGhhdCB0aGUgdW5kZXJseWluZyBtYWduZXQgcmVwcmVzZW50cy5cbiAgICAncG9ydCc6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHBvcnQgPT09IG51bGwgfHwgcG9ydC5pZCA9PT0gdW5kZWZpbmVkKSA/IHBvcnQgOiBwb3J0LmlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGBzdHlsZWAgYXR0cmlidXRlIGlzIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2V0cyB0aGUgQ1NTIHN0eWxlIG9mIHRoZSBzdWItZWxlbWVudC5cbiAgICAnc3R5bGUnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIHNldDogZnVuY3Rpb24oc3R5bGVzLCByZWZCQm94LCBub2RlKSB7XG4gICAgICAgICAgICAkKG5vZGUpLmNzcyhzdHlsZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgICdodG1sJzoge1xuICAgICAgICB1bnNldDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgJChub2RlKS5lbXB0eSgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGh0bWwsIHJlZkJCb3gsIG5vZGUpIHtcbiAgICAgICAgICAgICQobm9kZSkuaHRtbChodG1sICsgJycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFByb3BlcnRpZXMgc2V0dGVyIChzZXQgdmFyaW91cyBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlKVxuICAgIHByb3BzLFxufTtcblxuYXNzaWduKGF0dHJpYnV0ZXNOUywgbGVnYWN5QXR0cmlidXRlc05TKTtcbmFzc2lnbihhdHRyaWJ1dGVzTlMsIHRleHRBdHRyaWJ1dGVzTlMpO1xuYXNzaWduKGF0dHJpYnV0ZXNOUywgY29ubmVjdGlvbkF0dHJpYnV0ZXNOUyk7XG5hc3NpZ24oYXR0cmlidXRlc05TLCBzaGFwZUF0dHJpYnV0ZXNOUyk7XG5hc3NpZ24oYXR0cmlidXRlc05TLCBkZWZzQXR0cmlidXRlc05TKTtcbmFzc2lnbihhdHRyaWJ1dGVzTlMsIG9mZnNldEF0dHJpYnV0ZXNOUyk7XG5cbmV4cG9ydCBjb25zdCBhdHRyaWJ1dGVzID0gYXR0cmlidXRlc05TO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/legacy.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/legacy.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nfunction positionWrapper(axis, dimension, origin) {\n    return function(value, refBBox) {\n        var valuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value);\n        value = parseFloat(value);\n        if (valuePercentage) {\n            value /= 100;\n        }\n\n        var delta;\n        if (isFinite(value)) {\n            var refOrigin = refBBox[origin]();\n            if (valuePercentage || value > 0 && value < 1) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            } else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n\n        var point = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point)();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\n\nfunction setWrapper(attrName, dimension) {\n    return function(value, refBBox) {\n        var isValuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value);\n        value = parseFloat(value);\n        if (isValuePercentage) {\n            value /= 100;\n        }\n\n        var attrs = {};\n        if (isFinite(value)) {\n            var attrValue = (isValuePercentage || value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n\n        return attrs;\n    };\n}\n\nconst legacyAttributesNS = {\n\n    // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n    // if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n    // otherwise, `refX` is the left coordinate of the bounding box\n    'ref-x': {\n        position: positionWrapper('x', 'width', 'origin')\n    },\n\n    'ref-y': {\n        position: positionWrapper('y', 'height', 'origin')\n    },\n\n    // `ref-dx` and `ref-dy` define the offset of the sub-element relative to the right and/or bottom\n    // coordinate of the reference element.\n\n    'ref-dx': {\n        position: positionWrapper('x', 'width', 'corner')\n    },\n\n    'ref-dy': {\n        position: positionWrapper('y', 'height', 'corner')\n    },\n\n    // 'ref-width'/'ref-height' defines the width/height of the sub-element relatively to\n    // the reference element size\n    // val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n    // val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\n    'ref-width': {\n        set: setWrapper('width', 'width')\n    },\n\n    'ref-height': {\n        set: setWrapper('height', 'height')\n    },\n\n    'ref-rx': {\n        set: setWrapper('rx', 'width')\n    },\n\n    'ref-ry': {\n        set: setWrapper('ry', 'height')\n    },\n\n    'ref-cx': {\n        set: setWrapper('cx', 'width')\n    },\n\n    'ref-cy': {\n        set: setWrapper('cy', 'height')\n    },\n\n    'ref-r-inscribed': {\n        set: (function(attrName) {\n            var widthFn = setWrapper(attrName, 'width');\n            var heightFn = setWrapper(attrName, 'height');\n            return function(value, refBBox) {\n                var fn = (refBBox.height > refBBox.width) ? widthFn : heightFn;\n                return fn(value, refBBox);\n            };\n        })('r')\n    },\n\n    'ref-r-circumscribed': {\n        set: function(value, refBBox) {\n            var isValuePercentage = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value);\n            value = parseFloat(value);\n            if (isValuePercentage) {\n                value /= 100;\n            }\n\n            var diagonalLength = Math.sqrt((refBBox.height * refBBox.height) + (refBBox.width * refBBox.width));\n\n            var rValue;\n            if (isFinite(value)) {\n                if (isValuePercentage || value >= 0 && value <= 1) rValue = value * diagonalLength;\n                else rValue = Math.max(value + diagonalLength, 0);\n            }\n\n            return { r: rValue };\n        }\n    },\n};\n\n// NOTE: refX & refY are SVG attributes that define the reference point of the marker.\n// That's why we need to define both variants: `refX` and `ref-x` (and `refY` and `ref-y`).\nlegacyAttributesNS['refX'] = legacyAttributesNS['ref-x'];\nlegacyAttributesNS['refY'] = legacyAttributesNS['ref-y'];\n\n// This allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nlegacyAttributesNS['ref-x2'] = legacyAttributesNS['ref-x'];\nlegacyAttributesNS['ref-y2'] = legacyAttributesNS['ref-y'];\nlegacyAttributesNS['ref-width2'] = legacyAttributesNS['ref-width'];\nlegacyAttributesNS['ref-height2'] = legacyAttributesNS['ref-height'];\n\n// Aliases\nlegacyAttributesNS['ref-r'] = legacyAttributesNS['ref-r-inscribed'];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (legacyAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvbGVnYWN5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7QUFBMEM7QUFDUzs7QUFFbkQ7QUFDQTtBQUNBLDhCQUE4Qiw0REFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbURBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyw0REFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9DQUFvQyw0REFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxrQkFBa0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL2xlZ2FjeS5tanM/NjE2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzUGVyY2VudGFnZSB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbC5tanMnO1xuXG5mdW5jdGlvbiBwb3NpdGlvbldyYXBwZXIoYXhpcywgZGltZW5zaW9uLCBvcmlnaW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHJlZkJCb3gpIHtcbiAgICAgICAgdmFyIHZhbHVlUGVyY2VudGFnZSA9IGlzUGVyY2VudGFnZSh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWx0YTtcbiAgICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIHJlZk9yaWdpbiA9IHJlZkJCb3hbb3JpZ2luXSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlUGVyY2VudGFnZSB8fCB2YWx1ZSA+IDAgJiYgdmFsdWUgPCAxKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSByZWZPcmlnaW5bYXhpc10gKyByZWZCQm94W2RpbWVuc2lvbl0gKiB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSByZWZPcmlnaW5bYXhpc10gKyB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludCA9IFBvaW50KCk7XG4gICAgICAgIHBvaW50W2F4aXNdID0gZGVsdGEgfHwgMDtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNldFdyYXBwZXIoYXR0ck5hbWUsIGRpbWVuc2lvbikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgcmVmQkJveCkge1xuICAgICAgICB2YXIgaXNWYWx1ZVBlcmNlbnRhZ2UgPSBpc1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoaXNWYWx1ZVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRycyA9IHt9O1xuICAgICAgICBpZiAoaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgYXR0clZhbHVlID0gKGlzVmFsdWVQZXJjZW50YWdlIHx8IHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMSlcbiAgICAgICAgICAgICAgICA/IHZhbHVlICogcmVmQkJveFtkaW1lbnNpb25dXG4gICAgICAgICAgICAgICAgOiBNYXRoLm1heCh2YWx1ZSArIHJlZkJCb3hbZGltZW5zaW9uXSwgMCk7XG4gICAgICAgICAgICBhdHRyc1thdHRyTmFtZV0gPSBhdHRyVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXR0cnM7XG4gICAgfTtcbn1cblxuY29uc3QgbGVnYWN5QXR0cmlidXRlc05TID0ge1xuXG4gICAgLy8gaWYgYHJlZlhgIGlzIGluIFswLCAxXSB0aGVuIGByZWZYYCBpcyBhIGZyYWN0aW9uIG9mIGJvdW5kaW5nIGJveCB3aWR0aFxuICAgIC8vIGlmIGByZWZYYCBpcyA8IDAgdGhlbiBgcmVmWGAncyBhYnNvbHV0ZSB2YWx1ZXMgaXMgdGhlIHJpZ2h0IGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgIC8vIG90aGVyd2lzZSwgYHJlZlhgIGlzIHRoZSBsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIGJvdW5kaW5nIGJveFxuICAgICdyZWYteCc6IHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uV3JhcHBlcigneCcsICd3aWR0aCcsICdvcmlnaW4nKVxuICAgIH0sXG5cbiAgICAncmVmLXknOiB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbldyYXBwZXIoJ3knLCAnaGVpZ2h0JywgJ29yaWdpbicpXG4gICAgfSxcblxuICAgIC8vIGByZWYtZHhgIGFuZCBgcmVmLWR5YCBkZWZpbmUgdGhlIG9mZnNldCBvZiB0aGUgc3ViLWVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHJpZ2h0IGFuZC9vciBib3R0b21cbiAgICAvLyBjb29yZGluYXRlIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cblxuICAgICdyZWYtZHgnOiB7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbldyYXBwZXIoJ3gnLCAnd2lkdGgnLCAnY29ybmVyJylcbiAgICB9LFxuXG4gICAgJ3JlZi1keSc6IHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uV3JhcHBlcigneScsICdoZWlnaHQnLCAnY29ybmVyJylcbiAgICB9LFxuXG4gICAgLy8gJ3JlZi13aWR0aCcvJ3JlZi1oZWlnaHQnIGRlZmluZXMgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgc3ViLWVsZW1lbnQgcmVsYXRpdmVseSB0b1xuICAgIC8vIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzaXplXG4gICAgLy8gdmFsIGluIDAuLjEgICAgICAgICByZWYtd2lkdGggPSAwLjc1IHNldHMgdGhlIHdpZHRoIHRvIDc1JSBvZiB0aGUgcmVmLiBlbC4gd2lkdGhcbiAgICAvLyB2YWwgPCAwIHx8IHZhbCA+IDEgIHJlZi1oZWlnaHQgPSAtMjAgc2V0cyB0aGUgaGVpZ2h0IHRvIHRoZSByZWYuIGVsLiBoZWlnaHQgc2hvcnRlciBieSAyMFxuXG4gICAgJ3JlZi13aWR0aCc6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCd3aWR0aCcsICd3aWR0aCcpXG4gICAgfSxcblxuICAgICdyZWYtaGVpZ2h0Jzoge1xuICAgICAgICBzZXQ6IHNldFdyYXBwZXIoJ2hlaWdodCcsICdoZWlnaHQnKVxuICAgIH0sXG5cbiAgICAncmVmLXJ4Jzoge1xuICAgICAgICBzZXQ6IHNldFdyYXBwZXIoJ3J4JywgJ3dpZHRoJylcbiAgICB9LFxuXG4gICAgJ3JlZi1yeSc6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCdyeScsICdoZWlnaHQnKVxuICAgIH0sXG5cbiAgICAncmVmLWN4Jzoge1xuICAgICAgICBzZXQ6IHNldFdyYXBwZXIoJ2N4JywgJ3dpZHRoJylcbiAgICB9LFxuXG4gICAgJ3JlZi1jeSc6IHtcbiAgICAgICAgc2V0OiBzZXRXcmFwcGVyKCdjeScsICdoZWlnaHQnKVxuICAgIH0sXG5cbiAgICAncmVmLXItaW5zY3JpYmVkJzoge1xuICAgICAgICBzZXQ6IChmdW5jdGlvbihhdHRyTmFtZSkge1xuICAgICAgICAgICAgdmFyIHdpZHRoRm4gPSBzZXRXcmFwcGVyKGF0dHJOYW1lLCAnd2lkdGgnKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHRGbiA9IHNldFdyYXBwZXIoYXR0ck5hbWUsICdoZWlnaHQnKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgcmVmQkJveCkge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IChyZWZCQm94LmhlaWdodCA+IHJlZkJCb3gud2lkdGgpID8gd2lkdGhGbiA6IGhlaWdodEZuO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSwgcmVmQkJveCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgncicpXG4gICAgfSxcblxuICAgICdyZWYtci1jaXJjdW1zY3JpYmVkJzoge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94KSB7XG4gICAgICAgICAgICB2YXIgaXNWYWx1ZVBlcmNlbnRhZ2UgPSBpc1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRpYWdvbmFsTGVuZ3RoID0gTWF0aC5zcXJ0KChyZWZCQm94LmhlaWdodCAqIHJlZkJCb3guaGVpZ2h0KSArIChyZWZCQm94LndpZHRoICogcmVmQkJveC53aWR0aCkpO1xuXG4gICAgICAgICAgICB2YXIgclZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlUGVyY2VudGFnZSB8fCB2YWx1ZSA+PSAwICYmIHZhbHVlIDw9IDEpIHJWYWx1ZSA9IHZhbHVlICogZGlhZ29uYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgZWxzZSByVmFsdWUgPSBNYXRoLm1heCh2YWx1ZSArIGRpYWdvbmFsTGVuZ3RoLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgcjogclZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuLy8gTk9URTogcmVmWCAmIHJlZlkgYXJlIFNWRyBhdHRyaWJ1dGVzIHRoYXQgZGVmaW5lIHRoZSByZWZlcmVuY2UgcG9pbnQgb2YgdGhlIG1hcmtlci5cbi8vIFRoYXQncyB3aHkgd2UgbmVlZCB0byBkZWZpbmUgYm90aCB2YXJpYW50czogYHJlZlhgIGFuZCBgcmVmLXhgIChhbmQgYHJlZllgIGFuZCBgcmVmLXlgKS5cbmxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmWCddID0gbGVnYWN5QXR0cmlidXRlc05TWydyZWYteCddO1xubGVnYWN5QXR0cmlidXRlc05TWydyZWZZJ10gPSBsZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi15J107XG5cbi8vIFRoaXMgYWxsb3dzIHRvIGNvbWJpbmUgYm90aCBhYnNvbHV0ZSBhbmQgcmVsYXRpdmUgcG9zaXRpb25pbmdcbi8vIHJlZlg6IDUwJSwgcmVmWDI6IDIwXG5sZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi14MiddID0gbGVnYWN5QXR0cmlidXRlc05TWydyZWYteCddO1xubGVnYWN5QXR0cmlidXRlc05TWydyZWYteTInXSA9IGxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLXknXTtcbmxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLXdpZHRoMiddID0gbGVnYWN5QXR0cmlidXRlc05TWydyZWYtd2lkdGgnXTtcbmxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLWhlaWdodDInXSA9IGxlZ2FjeUF0dHJpYnV0ZXNOU1sncmVmLWhlaWdodCddO1xuXG4vLyBBbGlhc2VzXG5sZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi1yJ10gPSBsZWdhY3lBdHRyaWJ1dGVzTlNbJ3JlZi1yLWluc2NyaWJlZCddO1xuXG5leHBvcnQgZGVmYXVsdCBsZWdhY3lBdHRyaWJ1dGVzTlM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/legacy.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/offset.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/offset.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n// Offset attributes require the cell view to be rendered before they can be applied\n// (they must be appended to the DOM).\n\n\n\n\nfunction offsetWrapper(axis, dimension, corner) {\n    return function(value, nodeBBox) {\n        var delta;\n        if (value === 'middle') {\n            delta = nodeBBox[dimension] / 2;\n        } else if (value === corner) {\n            delta = nodeBBox[dimension];\n        } else if (isFinite(value)) {\n            // TODO: or not to do a breaking change?\n            delta = (value > -1 && value < 1) ? (-nodeBBox[dimension] * value) : -value;\n        } else if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPercentage)(value)) {\n            delta = nodeBBox[dimension] * parseFloat(value) / 100;\n        } else {\n            delta = 0;\n        }\n\n        var point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n        point[axis] = -(nodeBBox[axis] + delta);\n        return point;\n    };\n}\n\nconst offsetAttributesNS = {\n\n    // `x-alignment` when set to `middle` causes centering of the sub-element around its new x coordinate.\n    // `x-alignment` when set to `right` uses the x coordinate as referenced to the right of the bbox.\n    'x-alignment': {\n        offset: offsetWrapper('x', 'width', 'right')\n    },\n\n    // `y-alignment` when set to `middle` causes centering of the sub-element around its new y coordinate.\n    // `y-alignment` when set to `bottom` uses the y coordinate as referenced to the bottom of the bbox.\n    'y-alignment': {\n        offset: offsetWrapper('y', 'height', 'bottom')\n    },\n\n    'reset-offset': {\n        offset: function(val, nodeBBox) {\n            return (val)\n                ? { x: -nodeBBox.x, y: -nodeBBox.y }\n                : { x: 0, y: 0 };\n        }\n    },\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (offsetAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvb2Zmc2V0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTs7QUFFMEM7QUFDUzs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxTQUFTLDREQUFZO0FBQy9CO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsd0JBQXdCLCtDQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDs7QUFFQSwrREFBZSxrQkFBa0IsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL29mZnNldC5tanM/YWU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIE9mZnNldCBhdHRyaWJ1dGVzIHJlcXVpcmUgdGhlIGNlbGwgdmlldyB0byBiZSByZW5kZXJlZCBiZWZvcmUgdGhleSBjYW4gYmUgYXBwbGllZFxuLy8gKHRoZXkgbXVzdCBiZSBhcHBlbmRlZCB0byB0aGUgRE9NKS5cblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc1BlcmNlbnRhZ2UgfSBmcm9tICcuLi8uLi91dGlsL3V0aWwubWpzJztcblxuZnVuY3Rpb24gb2Zmc2V0V3JhcHBlcihheGlzLCBkaW1lbnNpb24sIGNvcm5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgbm9kZUJCb3gpIHtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBkZWx0YSA9IG5vZGVCQm94W2RpbWVuc2lvbl0gLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBjb3JuZXIpIHtcbiAgICAgICAgICAgIGRlbHRhID0gbm9kZUJCb3hbZGltZW5zaW9uXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG9yIG5vdCB0byBkbyBhIGJyZWFraW5nIGNoYW5nZT9cbiAgICAgICAgICAgIGRlbHRhID0gKHZhbHVlID4gLTEgJiYgdmFsdWUgPCAxKSA/ICgtbm9kZUJCb3hbZGltZW5zaW9uXSAqIHZhbHVlKSA6IC12YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BlcmNlbnRhZ2UodmFsdWUpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IG5vZGVCQm94W2RpbWVuc2lvbl0gKiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgpO1xuICAgICAgICBwb2ludFtheGlzXSA9IC0obm9kZUJCb3hbYXhpc10gKyBkZWx0YSk7XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9O1xufVxuXG5jb25zdCBvZmZzZXRBdHRyaWJ1dGVzTlMgPSB7XG5cbiAgICAvLyBgeC1hbGlnbm1lbnRgIHdoZW4gc2V0IHRvIGBtaWRkbGVgIGNhdXNlcyBjZW50ZXJpbmcgb2YgdGhlIHN1Yi1lbGVtZW50IGFyb3VuZCBpdHMgbmV3IHggY29vcmRpbmF0ZS5cbiAgICAvLyBgeC1hbGlnbm1lbnRgIHdoZW4gc2V0IHRvIGByaWdodGAgdXNlcyB0aGUgeCBjb29yZGluYXRlIGFzIHJlZmVyZW5jZWQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBiYm94LlxuICAgICd4LWFsaWdubWVudCc6IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRXcmFwcGVyKCd4JywgJ3dpZHRoJywgJ3JpZ2h0JylcbiAgICB9LFxuXG4gICAgLy8gYHktYWxpZ25tZW50YCB3aGVuIHNldCB0byBgbWlkZGxlYCBjYXVzZXMgY2VudGVyaW5nIG9mIHRoZSBzdWItZWxlbWVudCBhcm91bmQgaXRzIG5ldyB5IGNvb3JkaW5hdGUuXG4gICAgLy8gYHktYWxpZ25tZW50YCB3aGVuIHNldCB0byBgYm90dG9tYCB1c2VzIHRoZSB5IGNvb3JkaW5hdGUgYXMgcmVmZXJlbmNlZCB0byB0aGUgYm90dG9tIG9mIHRoZSBiYm94LlxuICAgICd5LWFsaWdubWVudCc6IHtcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXRXcmFwcGVyKCd5JywgJ2hlaWdodCcsICdib3R0b20nKVxuICAgIH0sXG5cbiAgICAncmVzZXQtb2Zmc2V0Jzoge1xuICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uKHZhbCwgbm9kZUJCb3gpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsKVxuICAgICAgICAgICAgICAgID8geyB4OiAtbm9kZUJCb3gueCwgeTogLW5vZGVCQm94LnkgfVxuICAgICAgICAgICAgICAgIDogeyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgb2Zmc2V0QXR0cmlidXRlc05TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/offset.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/props.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/props.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\nconst validPropertiesList = ['checked', 'selected', 'disabled', 'readOnly', 'contentEditable', 'value', 'indeterminate'];\n\nconst validProperties = validPropertiesList.reduce((acc, key) => {\n    acc[key] = true;\n    return acc;\n}, {});\n\nconst props = {\n    qualify: function(properties) {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(properties);\n    },\n    set: function(properties, _, node) {\n        Object.keys(properties).forEach(function(key) {\n            if (validProperties[key] && key in node) {\n                const value = properties[key];\n                if (node.tagName === 'SELECT' && Array.isArray(value)) {\n                    Array.from(node.options).forEach(function(option, index) {\n                        option.selected = value.includes(option.value);\n                    });\n                } else {\n                    node[key] = value;\n                }\n            }\n        });\n    }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (props);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvcHJvcHMubWpzIiwibWFwcGluZ3MiOiI7O0FBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBLGVBQWUsNkRBQWE7QUFDNUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSwrREFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvYXR0cmlidXRlcy9wcm9wcy5tanM/NDBmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsLm1qcyc7XG5cbmNvbnN0IHZhbGlkUHJvcGVydGllc0xpc3QgPSBbJ2NoZWNrZWQnLCAnc2VsZWN0ZWQnLCAnZGlzYWJsZWQnLCAncmVhZE9ubHknLCAnY29udGVudEVkaXRhYmxlJywgJ3ZhbHVlJywgJ2luZGV0ZXJtaW5hdGUnXTtcblxuY29uc3QgdmFsaWRQcm9wZXJ0aWVzID0gdmFsaWRQcm9wZXJ0aWVzTGlzdC5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSB0cnVlO1xuICAgIHJldHVybiBhY2M7XG59LCB7fSk7XG5cbmNvbnN0IHByb3BzID0ge1xuICAgIHF1YWxpZnk6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QocHJvcGVydGllcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHByb3BlcnRpZXMsIF8sIG5vZGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZFByb3BlcnRpZXNba2V5XSAmJiBrZXkgaW4gbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmZyb20obm9kZS5vcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluY2x1ZGVzKG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcHJvcHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/props.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/shape.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/shape.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\nfunction shapeWrapper(shapeConstructor, opt) {\n    var cacheName = 'joint-shape';\n    var resetOffset = opt && opt.resetOffset;\n    return function(value, refBBox, node) {\n        var cache = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].data.get(node, cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            var cachedShape = shapeConstructor(value);\n            cache = {\n                value: value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox()\n            };\n            _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].data.set(node, cacheName, cache);\n        }\n\n        var shape = cache.shape.clone();\n        var shapeBBox = cache.shapeBBox.clone();\n        var shapeOrigin = shapeBBox.origin();\n        var refOrigin = refBBox.origin();\n\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n\n        var fitScale = refBBox.maxRectScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        var sx = (shapeBBox.width === 0 || refBBox.width === 0) ? 1 : fitScale.sx;\n        var sy = (shapeBBox.height === 0 || refBBox.height === 0) ? 1 : fitScale.sy;\n\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n\n        return shape;\n    };\n}\n\n// `d` attribute for SVGPaths\nfunction dWrapper(opt) {\n    function pathConstructor(value) {\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].normalizePathData(value));\n    }\n\n    var shape = shapeWrapper(pathConstructor, opt);\n    return function(value, refBBox, node) {\n        var path = shape(value, refBBox, node);\n        return {\n            d: path.serialize()\n        };\n    };\n}\n\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(opt) {\n    var shape = shapeWrapper(_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline, opt);\n    return function(value, refBBox, node) {\n        var polyline = shape(value, refBBox, node);\n        return {\n            points: polyline.serialize()\n        };\n    };\n}\n\nconst shapeAttributesNS = {\n\n    'ref-d-reset-offset': {\n        unset: 'd',\n        set: dWrapper({ resetOffset: true })\n    },\n\n    'ref-d-keep-offset': {\n        unset: 'd',\n        set: dWrapper({ resetOffset: false })\n    },\n\n    'ref-points-reset-offset': {\n        unset: 'points',\n        set: pointsWrapper({ resetOffset: true })\n    },\n\n    'ref-points-keep-offset': {\n        unset: 'points',\n        set: pointsWrapper({ resetOffset: false })\n    },\n};\n\n// Aliases\nshapeAttributesNS['ref-d'] = shapeAttributesNS['ref-d-reset-offset'];\nshapeAttributesNS['ref-points'] = shapeAttributesNS['ref-points-reset-offset'];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (shapeAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvc2hhcGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBQ1g7QUFDTjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQUM7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOENBQUksQ0FBQyxvREFBQztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsa0RBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0MsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QyxLQUFLOztBQUVMO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hELEtBQUs7O0FBRUw7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxpQkFBaUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2RpYS9hdHRyaWJ1dGVzL3NoYXBlLm1qcz82OTliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhdGgsIFBvbHlsaW5lIH0gZnJvbSAnLi4vLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0ICQgZnJvbSAnLi4vLi4vbXZjL0RvbS9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vLi4vVi9pbmRleC5tanMnO1xuXG5mdW5jdGlvbiBzaGFwZVdyYXBwZXIoc2hhcGVDb25zdHJ1Y3Rvciwgb3B0KSB7XG4gICAgdmFyIGNhY2hlTmFtZSA9ICdqb2ludC1zaGFwZSc7XG4gICAgdmFyIHJlc2V0T2Zmc2V0ID0gb3B0ICYmIG9wdC5yZXNldE9mZnNldDtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHJlZkJCb3gsIG5vZGUpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gJC5kYXRhLmdldChub2RlLCBjYWNoZU5hbWUpO1xuICAgICAgICBpZiAoIWNhY2hlIHx8IGNhY2hlLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gb25seSByZWNhbGN1bGF0ZSBpZiB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgdmFyIGNhY2hlZFNoYXBlID0gc2hhcGVDb25zdHJ1Y3Rvcih2YWx1ZSk7XG4gICAgICAgICAgICBjYWNoZSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgc2hhcGU6IGNhY2hlZFNoYXBlLFxuICAgICAgICAgICAgICAgIHNoYXBlQkJveDogY2FjaGVkU2hhcGUuYmJveCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgJC5kYXRhLnNldChub2RlLCBjYWNoZU5hbWUsIGNhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaGFwZSA9IGNhY2hlLnNoYXBlLmNsb25lKCk7XG4gICAgICAgIHZhciBzaGFwZUJCb3ggPSBjYWNoZS5zaGFwZUJCb3guY2xvbmUoKTtcbiAgICAgICAgdmFyIHNoYXBlT3JpZ2luID0gc2hhcGVCQm94Lm9yaWdpbigpO1xuICAgICAgICB2YXIgcmVmT3JpZ2luID0gcmVmQkJveC5vcmlnaW4oKTtcblxuICAgICAgICBzaGFwZUJCb3gueCA9IHJlZk9yaWdpbi54O1xuICAgICAgICBzaGFwZUJCb3gueSA9IHJlZk9yaWdpbi55O1xuXG4gICAgICAgIHZhciBmaXRTY2FsZSA9IHJlZkJCb3gubWF4UmVjdFNjYWxlVG9GaXQoc2hhcGVCQm94LCByZWZPcmlnaW4pO1xuICAgICAgICAvLyBgbWF4UmVjdFNjYWxlVG9GaXRgIGNhbiBnaXZlIEluZmluaXR5IGlmIHdpZHRoIG9yIGhlaWdodCBpcyAwXG4gICAgICAgIHZhciBzeCA9IChzaGFwZUJCb3gud2lkdGggPT09IDAgfHwgcmVmQkJveC53aWR0aCA9PT0gMCkgPyAxIDogZml0U2NhbGUuc3g7XG4gICAgICAgIHZhciBzeSA9IChzaGFwZUJCb3guaGVpZ2h0ID09PSAwIHx8IHJlZkJCb3guaGVpZ2h0ID09PSAwKSA/IDEgOiBmaXRTY2FsZS5zeTtcblxuICAgICAgICBzaGFwZS5zY2FsZShzeCwgc3ksIHNoYXBlT3JpZ2luKTtcbiAgICAgICAgaWYgKHJlc2V0T2Zmc2V0KSB7XG4gICAgICAgICAgICBzaGFwZS50cmFuc2xhdGUoLXNoYXBlT3JpZ2luLngsIC1zaGFwZU9yaWdpbi55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9O1xufVxuXG4vLyBgZGAgYXR0cmlidXRlIGZvciBTVkdQYXRoc1xuZnVuY3Rpb24gZFdyYXBwZXIob3B0KSB7XG4gICAgZnVuY3Rpb24gcGF0aENvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChWLm5vcm1hbGl6ZVBhdGhEYXRhKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gc2hhcGVXcmFwcGVyKHBhdGhDb25zdHJ1Y3Rvciwgb3B0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHJlZkJCb3gsIG5vZGUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBzaGFwZSh2YWx1ZSwgcmVmQkJveCwgbm9kZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkOiBwYXRoLnNlcmlhbGl6ZSgpXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLy8gYHBvaW50c2AgYXR0cmlidXRlIGZvciBTVkdQb2x5bGluZXMgYW5kIFNWR1BvbHlnb25zXG5mdW5jdGlvbiBwb2ludHNXcmFwcGVyKG9wdCkge1xuICAgIHZhciBzaGFwZSA9IHNoYXBlV3JhcHBlcihQb2x5bGluZSwgb3B0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHJlZkJCb3gsIG5vZGUpIHtcbiAgICAgICAgdmFyIHBvbHlsaW5lID0gc2hhcGUodmFsdWUsIHJlZkJCb3gsIG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnRzOiBwb2x5bGluZS5zZXJpYWxpemUoKVxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmNvbnN0IHNoYXBlQXR0cmlidXRlc05TID0ge1xuXG4gICAgJ3JlZi1kLXJlc2V0LW9mZnNldCc6IHtcbiAgICAgICAgdW5zZXQ6ICdkJyxcbiAgICAgICAgc2V0OiBkV3JhcHBlcih7IHJlc2V0T2Zmc2V0OiB0cnVlIH0pXG4gICAgfSxcblxuICAgICdyZWYtZC1rZWVwLW9mZnNldCc6IHtcbiAgICAgICAgdW5zZXQ6ICdkJyxcbiAgICAgICAgc2V0OiBkV3JhcHBlcih7IHJlc2V0T2Zmc2V0OiBmYWxzZSB9KVxuICAgIH0sXG5cbiAgICAncmVmLXBvaW50cy1yZXNldC1vZmZzZXQnOiB7XG4gICAgICAgIHVuc2V0OiAncG9pbnRzJyxcbiAgICAgICAgc2V0OiBwb2ludHNXcmFwcGVyKHsgcmVzZXRPZmZzZXQ6IHRydWUgfSlcbiAgICB9LFxuXG4gICAgJ3JlZi1wb2ludHMta2VlcC1vZmZzZXQnOiB7XG4gICAgICAgIHVuc2V0OiAncG9pbnRzJyxcbiAgICAgICAgc2V0OiBwb2ludHNXcmFwcGVyKHsgcmVzZXRPZmZzZXQ6IGZhbHNlIH0pXG4gICAgfSxcbn07XG5cbi8vIEFsaWFzZXNcbnNoYXBlQXR0cmlidXRlc05TWydyZWYtZCddID0gc2hhcGVBdHRyaWJ1dGVzTlNbJ3JlZi1kLXJlc2V0LW9mZnNldCddO1xuc2hhcGVBdHRyaWJ1dGVzTlNbJ3JlZi1wb2ludHMnXSA9IHNoYXBlQXR0cmlidXRlc05TWydyZWYtcG9pbnRzLXJlc2V0LW9mZnNldCddO1xuXG5leHBvcnQgZGVmYXVsdCBzaGFwZUF0dHJpYnV0ZXNOUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/shape.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/text.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/attributes/text.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/calc.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\n\nconst textAttributesNS = {\n\n    'line-height': {\n        qualify: isTextInUse\n    },\n\n    'text-vertical-anchor': {\n        qualify: isTextInUse\n    },\n\n    'text-path': {\n        qualify: isTextInUse\n    },\n\n    'annotations': {\n        qualify: isTextInUse\n    },\n\n    'eol': {\n        qualify: isTextInUse\n    },\n\n    'display-empty': {\n        qualify: isTextInUse\n    },\n\n    'text': {\n        qualify: function(_text, _node, attrs) {\n            const textWrap = attrs['text-wrap'];\n            return !textWrap || !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(textWrap);\n        },\n        unset: function(node) {\n            node.textContent = '';\n        },\n        set: function(text, refBBox, node, attrs) {\n            const cacheName = 'joint-text';\n            const cache = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.get(node, cacheName);\n            const lineHeight = attrs['line-height'];\n            const textVerticalAnchor = attrs['text-vertical-anchor'];\n            const displayEmpty = attrs['display-empty'];\n            const fontSize = attrs['font-size'];\n            const annotations = attrs.annotations;\n            const eol = attrs.eol;\n            const x = attrs.x;\n            let textPath = attrs['text-path'];\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // <tspan> positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(textPath)) {\n                    const pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        const pathNode = this.findNode(pathSelector);\n                        if (pathNode instanceof SVGPathElement) {\n                            textPath = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).text('' + text, {\n                    lineHeight,\n                    annotations,\n                    textPath,\n                    x,\n                    textVerticalAnchor,\n                    eol,\n                    displayEmpty\n                });\n                _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.set(node, cacheName, textHash);\n            }\n        }\n    },\n\n    'text-wrap': {\n        qualify: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if ((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression)(width)) {\n                size.width = Number((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression)(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage)(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if ((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression)(height)) {\n                size.height = Number((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression)(height, refBBox));\n            } else {\n                if (value.height === null) {\n                    // if height is not specified breakText() does not\n                    // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n\n                const breakTextFn = value.breakText || _util_util_mjs__WEBPACK_IMPORTED_MODULE_3__.breakText;\n                const computedStyles = getComputedStyle(node);\n                const wrapFontAttributes = {};\n                // The font size attributes must be set on the node\n                // to get the correct text wrapping.\n                // TODO: set the native SVG attributes before special attributes\n                for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n                    const name = FONT_ATTRIBUTES[i];\n                    if (name in attrs) {\n                        node.setAttribute(name, attrs[name]);\n                    }\n                    // Note: computedStyles is a live object\n                    // i.e. the properties are evaluated when accessed.\n                    wrapFontAttributes[name] = computedStyles[name];\n                }\n\n                // The `line-height` attribute in SVG is JoinJS specific.\n                // TODO: change the `lineHeight` to breakText option.\n                wrapFontAttributes.lineHeight = attrs['line-height'];\n\n                wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    separator: value.separator,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = '';\n            }\n            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        },\n        // We expose the font attributes list to allow\n        // the user to take other custom font attributes into account\n        // when wrapping the text.\n        FONT_ATTRIBUTES\n    },\n\n    'title': {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        unset: function(node) {\n            _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.remove(node, 'joint-title');\n            const titleNode = node.firstElementChild;\n            if (titleNode) {\n                titleNode.remove();\n            }\n        },\n        set: function(title, refBBox, node) {\n            var cacheName = 'joint-title';\n            var cache = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.get(node, cacheName);\n            if (cache === undefined || cache !== title) {\n                _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.set(node, cacheName, title);\n                if (node.tagName === 'title') {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === 'title') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (textAttributesNS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2F0dHJpYnV0ZXMvdGV4dC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStGO0FBQ3BCO0FBQ25DO0FBQ047O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkRBQWE7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQiwwREFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFNLEdBQUcsaUNBQWlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3REFBQztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0IsMERBQUM7QUFDakI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQkFBaUIseURBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQVk7QUFDNUI7QUFDQSxjQUFjLFNBQVMsZ0VBQWdCO0FBQ3ZDLG9DQUFvQyxrRUFBa0I7QUFDdEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUFZO0FBQzVCO0FBQ0EsY0FBYyxTQUFTLGdFQUFnQjtBQUN2QyxxQ0FBcUMsa0VBQWtCO0FBQ3ZELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQscURBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSwwREFBQztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0IsMERBQUM7QUFDekI7QUFDQSxnQkFBZ0IsMERBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsK0RBQWUsZ0JBQWdCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvYXR0cmlidXRlcy90ZXh0Lm1qcz9iZmNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2lnbiwgaXNQbGFpbk9iamVjdCwgaXNPYmplY3QsIGlzUGVyY2VudGFnZSwgYnJlYWtUZXh0IH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsLm1qcyc7XG5pbXBvcnQgeyBpc0NhbGNFeHByZXNzaW9uLCBldmFsQ2FsY0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi91dGlsL2NhbGMubWpzJztcbmltcG9ydCAkIGZyb20gJy4uLy4uL212Yy9Eb20vaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uLy4uL1YvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gaXNUZXh0SW5Vc2UoX3ZhbHVlLCBfbm9kZSwgYXR0cnMpIHtcbiAgICByZXR1cm4gKGF0dHJzLnRleHQgIT09IHVuZGVmaW5lZCk7XG59XG5cbmNvbnN0IEZPTlRfQVRUUklCVVRFUyA9IFsnZm9udC13ZWlnaHQnLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2xldHRlci1zcGFjaW5nJywgJ3RleHQtdHJhbnNmb3JtJ107XG5cbmNvbnN0IHRleHRBdHRyaWJ1dGVzTlMgPSB7XG5cbiAgICAnbGluZS1oZWlnaHQnOiB7XG4gICAgICAgIHF1YWxpZnk6IGlzVGV4dEluVXNlXG4gICAgfSxcblxuICAgICd0ZXh0LXZlcnRpY2FsLWFuY2hvcic6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgJ3RleHQtcGF0aCc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgJ2Fubm90YXRpb25zJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1RleHRJblVzZVxuICAgIH0sXG5cbiAgICAnZW9sJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1RleHRJblVzZVxuICAgIH0sXG5cbiAgICAnZGlzcGxheS1lbXB0eSc6IHtcbiAgICAgICAgcXVhbGlmeTogaXNUZXh0SW5Vc2VcbiAgICB9LFxuXG4gICAgJ3RleHQnOiB7XG4gICAgICAgIHF1YWxpZnk6IGZ1bmN0aW9uKF90ZXh0LCBfbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRXcmFwID0gYXR0cnNbJ3RleHQtd3JhcCddO1xuICAgICAgICAgICAgcmV0dXJuICF0ZXh0V3JhcCB8fCAhaXNQbGFpbk9iamVjdCh0ZXh0V3JhcCk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuc2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odGV4dCwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlTmFtZSA9ICdqb2ludC10ZXh0JztcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gJC5kYXRhLmdldChub2RlLCBjYWNoZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IGF0dHJzWydsaW5lLWhlaWdodCddO1xuICAgICAgICAgICAgY29uc3QgdGV4dFZlcnRpY2FsQW5jaG9yID0gYXR0cnNbJ3RleHQtdmVydGljYWwtYW5jaG9yJ107XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5RW1wdHkgPSBhdHRyc1snZGlzcGxheS1lbXB0eSddO1xuICAgICAgICAgICAgY29uc3QgZm9udFNpemUgPSBhdHRyc1snZm9udC1zaXplJ107XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IGF0dHJzLmFubm90YXRpb25zO1xuICAgICAgICAgICAgY29uc3QgZW9sID0gYXR0cnMuZW9sO1xuICAgICAgICAgICAgY29uc3QgeCA9IGF0dHJzLng7XG4gICAgICAgICAgICBsZXQgdGV4dFBhdGggPSBhdHRyc1sndGV4dC1wYXRoJ107XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRleHQgb25seSBpZiB0aGVyZSB3YXMgYSBjaGFuZ2UgaW4gdGhlIHN0cmluZ1xuICAgICAgICAgICAgLy8gb3IgYW55IG9mIGl0cyBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgY29uc3QgdGV4dEhhc2ggPSBKU09OLnN0cmluZ2lmeShbdGV4dCwgbGluZUhlaWdodCwgYW5ub3RhdGlvbnMsIHRleHRWZXJ0aWNhbEFuY2hvciwgZW9sLCBkaXNwbGF5RW1wdHksIHRleHRQYXRoLCB4LCBmb250U2l6ZV0pO1xuICAgICAgICAgICAgaWYgKGNhY2hlID09PSB1bmRlZmluZWQgfHwgY2FjaGUgIT09IHRleHRIYXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGJ1ZzpcbiAgICAgICAgICAgICAgICAvLyA8dHNwYW4+IHBvc2l0aW9ucyBkZWZpbmVkIGFzIGBlbWAgYXJlIG5vdCB1cGRhdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjb250YWluZXIgYGZvbnQtc2l6ZWAgY2hhbmdlLlxuICAgICAgICAgICAgICAgIGlmIChmb250U2l6ZSkgbm9kZS5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICAgICAgICAgICAgICAvLyBUZXh0IEFsb25nIFBhdGggU2VsZWN0b3JcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodGV4dFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhTZWxlY3RvciA9IHRleHRQYXRoLnNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhTZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhOb2RlID0gdGhpcy5maW5kTm9kZShwYXRoU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhOb2RlIGluc3RhbmNlb2YgU1ZHUGF0aEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0UGF0aCA9IGFzc2lnbih7ICd4bGluazpocmVmJzogJyMnICsgcGF0aE5vZGUuaWQgfSwgdGV4dFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFYobm9kZSkudGV4dCgnJyArIHRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHRleHRQYXRoLFxuICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgIGVvbCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUVtcHR5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgJC5kYXRhLnNldChub2RlLCBjYWNoZU5hbWUsIHRleHRIYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAndGV4dC13cmFwJzoge1xuICAgICAgICBxdWFsaWZ5OiBpc1BsYWluT2JqZWN0LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlLCByZWZCQm94LCBub2RlLCBhdHRycykge1xuICAgICAgICAgICAgdmFyIHNpemUgPSB7fTtcbiAgICAgICAgICAgIC8vIG9wdGlvbiBgd2lkdGhgXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB2YWx1ZS53aWR0aCB8fCAwO1xuICAgICAgICAgICAgaWYgKGlzUGVyY2VudGFnZSh3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gcmVmQkJveC53aWR0aCAqIHBhcnNlRmxvYXQod2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGNFeHByZXNzaW9uKHdpZHRoKSkge1xuICAgICAgICAgICAgICAgIHNpemUud2lkdGggPSBOdW1iZXIoZXZhbENhbGNFeHByZXNzaW9uKHdpZHRoLCByZWZCQm94KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS53aWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBicmVha1RleHQoKSByZXF1aXJlcyB3aWR0aCB0byBiZSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIHNpemUud2lkdGggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdpZHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS53aWR0aCA9IHJlZkJCb3gud2lkdGggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaXplLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3B0aW9uIGBoZWlnaHRgXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdmFsdWUuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICBpZiAoaXNQZXJjZW50YWdlKGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzaXplLmhlaWdodCA9IHJlZkJCb3guaGVpZ2h0ICogcGFyc2VGbG9hdChoZWlnaHQpIC8gMTAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGNFeHByZXNzaW9uKGhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzaXplLmhlaWdodCA9IE51bWJlcihldmFsQ2FsY0V4cHJlc3Npb24oaGVpZ2h0LCByZWZCQm94KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oZWlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaGVpZ2h0IGlzIG5vdCBzcGVjaWZpZWQgYnJlYWtUZXh0KCkgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzdHJpY3QgdGhlIGhlaWdodCBvZiB0aGUgdGV4dC5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpemUuaGVpZ2h0ID0gcmVmQkJveC5oZWlnaHQgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3B0aW9uIGB0ZXh0YFxuICAgICAgICAgICAgdmFyIHdyYXBwZWRUZXh0O1xuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZS50ZXh0O1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkgdGV4dCA9IGF0dHJzLnRleHQ7XG4gICAgICAgICAgICBpZiAodGV4dCAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBicmVha1RleHRGbiA9IHZhbHVlLmJyZWFrVGV4dCB8fCBicmVha1RleHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBGb250QXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmb250IHNpemUgYXR0cmlidXRlcyBtdXN0IGJlIHNldCBvbiB0aGUgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRvIGdldCB0aGUgY29ycmVjdCB0ZXh0IHdyYXBwaW5nLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHNldCB0aGUgbmF0aXZlIFNWRyBhdHRyaWJ1dGVzIGJlZm9yZSBzcGVjaWFsIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZPTlRfQVRUUklCVVRFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gRk9OVF9BVFRSSUJVVEVTW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IGNvbXB1dGVkU3R5bGVzIGlzIGEgbGl2ZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gaS5lLiB0aGUgcHJvcGVydGllcyBhcmUgZXZhbHVhdGVkIHdoZW4gYWNjZXNzZWQuXG4gICAgICAgICAgICAgICAgICAgIHdyYXBGb250QXR0cmlidXRlc1tuYW1lXSA9IGNvbXB1dGVkU3R5bGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBgbGluZS1oZWlnaHRgIGF0dHJpYnV0ZSBpbiBTVkcgaXMgSm9pbkpTIHNwZWNpZmljLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGUgYGxpbmVIZWlnaHRgIHRvIGJyZWFrVGV4dCBvcHRpb24uXG4gICAgICAgICAgICAgICAgd3JhcEZvbnRBdHRyaWJ1dGVzLmxpbmVIZWlnaHQgPSBhdHRyc1snbGluZS1oZWlnaHQnXTtcblxuICAgICAgICAgICAgICAgIHdyYXBwZWRUZXh0ID0gYnJlYWtUZXh0Rm4oJycgKyB0ZXh0LCBzaXplLCB3cmFwRm9udEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBhbiBleGlzdGluZyBTVkcgRG9jdW1lbnQgaGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IG9uZSBvdmVyIGFnYWluLlxuICAgICAgICAgICAgICAgICAgICBzdmdEb2N1bWVudDogdGhpcy5wYXBlci5zdmcsXG4gICAgICAgICAgICAgICAgICAgIGVsbGlwc2lzOiB2YWx1ZS5lbGxpcHNpcyxcbiAgICAgICAgICAgICAgICAgICAgaHlwaGVuOiB2YWx1ZS5oeXBoZW4sXG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvcjogdmFsdWUuc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBtYXhMaW5lQ291bnQ6IHZhbHVlLm1heExpbmVDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVTcGFjZXM6IHZhbHVlLnByZXNlcnZlU3BhY2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRUZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0QXR0cmlidXRlc05TLnRleHQuc2V0LmNhbGwodGhpcywgd3JhcHBlZFRleHQsIHJlZkJCb3gsIG5vZGUsIGF0dHJzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2UgZXhwb3NlIHRoZSBmb250IGF0dHJpYnV0ZXMgbGlzdCB0byBhbGxvd1xuICAgICAgICAvLyB0aGUgdXNlciB0byB0YWtlIG90aGVyIGN1c3RvbSBmb250IGF0dHJpYnV0ZXMgaW50byBhY2NvdW50XG4gICAgICAgIC8vIHdoZW4gd3JhcHBpbmcgdGhlIHRleHQuXG4gICAgICAgIEZPTlRfQVRUUklCVVRFU1xuICAgIH0sXG5cbiAgICAndGl0bGUnOiB7XG4gICAgICAgIHF1YWxpZnk6IGZ1bmN0aW9uKHRpdGxlLCBub2RlKSB7XG4gICAgICAgICAgICAvLyBIVE1MRWxlbWVudCB0aXRsZSBpcyBzcGVjaWZpZWQgdmlhIGFuIGF0dHJpYnV0ZSAoaS5lLiBub3QgYW4gZWxlbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICQuZGF0YS5yZW1vdmUobm9kZSwgJ2pvaW50LXRpdGxlJyk7XG4gICAgICAgICAgICBjb25zdCB0aXRsZU5vZGUgPSBub2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgaWYgKHRpdGxlTm9kZSkge1xuICAgICAgICAgICAgICAgIHRpdGxlTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0aXRsZSwgcmVmQkJveCwgbm9kZSkge1xuICAgICAgICAgICAgdmFyIGNhY2hlTmFtZSA9ICdqb2ludC10aXRsZSc7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSAkLmRhdGEuZ2V0KG5vZGUsIGNhY2hlTmFtZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGUgPT09IHVuZGVmaW5lZCB8fCBjYWNoZSAhPT0gdGl0bGUpIHtcbiAgICAgICAgICAgICAgICAkLmRhdGEuc2V0KG5vZGUsIGNhY2hlTmFtZSwgdGl0bGUpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGlzIGEgPHRpdGxlPiBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhbGx5IDx0aXRsZT4gZWxlbWVudCBzaG91bGQgYmUgdGhlIGZpcnN0IGNoaWxkIGVsZW1lbnQgb2YgaXRzIHBhcmVudC5cbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC50YWdOYW1lID09PSAndGl0bGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbiBleGlzdGluZyB0aXRsZVxuICAgICAgICAgICAgICAgICAgICBmaXJzdENoaWxkLnRleHRDb250ZW50ID0gdGl0bGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRpdGxlXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aXRsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobm9kZS5uYW1lc3BhY2VVUkksICd0aXRsZScpO1xuICAgICAgICAgICAgICAgICAgICB0aXRsZU5vZGUudGV4dENvbnRlbnQgPSB0aXRsZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUodGl0bGVOb2RlLCBmaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGV4dEF0dHJpYnV0ZXNOUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/text.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cell: function() { return /* reexport safe */ _Cell_mjs__WEBPACK_IMPORTED_MODULE_3__.Cell; },\n/* harmony export */   CellView: function() { return /* reexport safe */ _CellView_mjs__WEBPACK_IMPORTED_MODULE_4__.CellView; },\n/* harmony export */   Element: function() { return /* reexport safe */ _Element_mjs__WEBPACK_IMPORTED_MODULE_5__.Element; },\n/* harmony export */   ElementView: function() { return /* reexport safe */ _ElementView_mjs__WEBPACK_IMPORTED_MODULE_6__.ElementView; },\n/* harmony export */   Graph: function() { return /* reexport safe */ _Graph_mjs__WEBPACK_IMPORTED_MODULE_0__.Graph; },\n/* harmony export */   HighlighterView: function() { return /* reexport safe */ _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_12__.HighlighterView; },\n/* harmony export */   LayersNames: function() { return /* reexport safe */ _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_2__.LayersNames; },\n/* harmony export */   Link: function() { return /* reexport safe */ _Link_mjs__WEBPACK_IMPORTED_MODULE_7__.Link; },\n/* harmony export */   LinkView: function() { return /* reexport safe */ _LinkView_mjs__WEBPACK_IMPORTED_MODULE_8__.LinkView; },\n/* harmony export */   Paper: function() { return /* reexport safe */ _Paper_mjs__WEBPACK_IMPORTED_MODULE_9__.Paper; },\n/* harmony export */   PaperLayer: function() { return /* reexport safe */ _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_2__.PaperLayer; },\n/* harmony export */   ToolView: function() { return /* reexport safe */ _ToolView_mjs__WEBPACK_IMPORTED_MODULE_10__.ToolView; },\n/* harmony export */   ToolsView: function() { return /* reexport safe */ _ToolsView_mjs__WEBPACK_IMPORTED_MODULE_11__.ToolsView; },\n/* harmony export */   attributes: function() { return /* reexport safe */ _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_1__.attributes; }\n/* harmony export */ });\n/* harmony import */ var _Graph_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graph.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Graph.mjs\");\n/* harmony import */ var _attributes_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attributes/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/index.mjs\");\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PaperLayer.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _Cell_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Cell.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _CellView_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CellView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/CellView.mjs\");\n/* harmony import */ var _Element_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Element.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Element.mjs\");\n/* harmony import */ var _ElementView_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ElementView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ElementView.mjs\");\n/* harmony import */ var _Link_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Link.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Link.mjs\");\n/* harmony import */ var _LinkView_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LinkView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/LinkView.mjs\");\n/* harmony import */ var _Paper_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Paper.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Paper.mjs\");\n/* harmony import */ var _ToolView_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _ToolsView_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ToolsView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolsView.mjs\");\n/* harmony import */ var _HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEI7QUFDVztBQUNOO0FBQ047QUFDSTtBQUNEO0FBQ0k7QUFDUDtBQUNJO0FBQ0g7QUFDRztBQUNDO0FBQ00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvaW5kZXgubWpzP2Y5YzgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9HcmFwaC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hdHRyaWJ1dGVzL2luZGV4Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL1BhcGVyTGF5ZXIubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vQ2VsbC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9DZWxsVmlldy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9FbGVtZW50Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0VsZW1lbnRWaWV3Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0xpbmsubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vTGlua1ZpZXcubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vUGFwZXIubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vVG9vbFZpZXcubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vVG9vbHNWaWV3Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0hpZ2hsaWdodGVyVmlldy5tanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/layers/GridLayer.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/layers/GridLayer.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GridLayer: function() { return /* binding */ GridLayer; }\n/* harmony export */ });\n/* harmony import */ var _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PaperLayer.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/PaperLayer.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\nconst GridLayer = _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_0__.PaperLayer.extend({\n\n    style: {\n        'pointer-events': 'none'\n    },\n\n    _gridCache: null,\n    _gridSettings: null,\n\n    init() {\n        _PaperLayer_mjs__WEBPACK_IMPORTED_MODULE_0__.PaperLayer.prototype.init.apply(this, arguments);\n        const { options: { paper }} = this;\n        this._gridCache = null;\n        this._gridSettings = [];\n        this.listenTo(paper, 'transform resize', this.updateGrid);\n    },\n\n    setGrid(drawGrid) {\n        this._gridSettings = this.getGridSettings(drawGrid);\n        this.renderGrid();\n    },\n\n    getGridSettings(drawGrid) {\n        const gridSettings = [];\n        if (drawGrid) {\n            const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n            optionsList.forEach((item) => {\n                gridSettings.push(...this._resolveDrawGridOption(item));\n            });\n        }\n        return gridSettings;\n    },\n\n    removeGrid() {\n        const { _gridCache: grid } = this;\n        if (!grid) return;\n        grid.root.remove();\n        this._gridCache = null;\n    },\n\n    renderGrid() {\n\n        const { options: { paper }} = this;\n        const { _gridSettings: gridSettings } = this;\n\n        this.removeGrid();\n\n        if (gridSettings.length === 0) return;\n\n        const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n        if (gridSize <= 1) {\n            return;\n        }\n\n        const refs = this._getGridRefs();\n\n        gridSettings.forEach((gridLayerSetting, index) => {\n\n            const id = this._getPatternId(index);\n            const options = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.merge)({}, gridLayerSetting);\n            const { scaleFactor = 1 } = options;\n            options.width = gridSize * scaleFactor || 1;\n            options.height = gridSize * scaleFactor || 1;\n\n            let vPattern;\n            if (!refs.exist(id)) {\n                vPattern = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(options.markup));\n                refs.add(id, vPattern);\n            } else {\n                vPattern = refs.get(id);\n            }\n\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.render)) {\n                options.render(vPattern.node.firstChild, options, paper);\n            }\n            vPattern.attr({\n                width: options.width,\n                height: options.height\n            });\n        });\n\n        refs.root.appendTo(this.el);\n        this.updateGrid();\n    },\n\n    updateGrid() {\n\n        const { _gridCache: grid, _gridSettings: gridSettings, options: { paper }} = this;\n        if (!grid) return;\n        const { root: vSvg, patterns } = grid;\n        const { x, y, width, height } = paper.getArea();\n        vSvg.attr({ x, y, width, height });\n        for (const patternId in patterns) {\n            const vPattern = patterns[patternId];\n            vPattern.attr({ x: -x, y: -y });\n        }\n        gridSettings.forEach((options, index) => {\n            if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(options.update)) {\n                const vPattern = patterns[this._getPatternId(index)];\n                options.update(vPattern.node.firstChild, options, paper);\n            }\n        });\n    },\n\n    _getPatternId(index) {\n        return `pattern_${this.options.paper.cid}_${index}`;\n    },\n\n    _getGridRefs() {\n        let { _gridCache: grid } = this;\n        if (grid) return grid;\n        const defsVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('defs');\n        const svgVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('svg', { width: '100%', height: '100%' }, [defsVEl]);\n        grid = this._gridCache = {\n            root: svgVEl,\n            patterns: {},\n            add: function(id, patternVEl) {\n                const rectVEl = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('rect', { width: '100%', height: '100%', fill: `url(#${id})` });\n                defsVEl.append(patternVEl);\n                svgVEl.append(rectVEl);\n                this.patterns[id] = patternVEl;\n            },\n            get: function(id) {\n                return this.patterns[id];\n            },\n            exist: function(id) {\n                return this.patterns[id] !== undefined;\n            }\n        };\n        return grid;\n    },\n\n    _resolveDrawGridOption(opt) {\n\n        var namespace = this.options.patterns;\n        if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isString)(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, item);\n            });\n        }\n\n        var options = opt || { args: [{}] };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n\n        if (!isArray && !name && !options.markup) {\n            name = 'dot';\n        }\n\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, item);\n            });\n\n            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n            (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.defaults)(args[0], (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.omit)(opt, 'args'));\n            for (var i = 0; i < args.length; i++) {\n                if (pattern[i]) {\n                    (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n\n        return isArray ? options : [options];\n    },\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2xheWVycy9HcmlkTGF5ZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0M7QUFRakI7QUFDSTs7QUFFM0Isa0JBQWtCLHVEQUFVOztBQUVuQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsUUFBUSx1REFBVTtBQUNsQixnQkFBZ0IsV0FBVyxTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxnQkFBZ0IsV0FBVyxTQUFTO0FBQ3BDLGdCQUFnQiw4QkFBOEI7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsNEJBQTRCLHNEQUFLLEdBQUc7QUFDcEMsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsd0RBQUMsY0FBYyx3Q0FBd0MsRUFBRSx3REFBQztBQUNyRjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLGdCQUFnQiwyREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsZ0JBQWdCLDBEQUEwRCxTQUFTO0FBQ25GO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QyxnQkFBZ0Isc0JBQXNCO0FBQ3RDLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQSxnQkFBZ0IsMkRBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQSwwQkFBMEIsdUJBQXVCLEdBQUcsTUFBTTtBQUMxRCxLQUFLOztBQUVMO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQSx3QkFBd0Isd0RBQUM7QUFDekIsdUJBQXVCLHdEQUFDLFVBQVUsK0JBQStCO0FBQ2pFO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxnQ0FBZ0Msd0RBQUMsV0FBVyw2Q0FBNkMsR0FBRyxJQUFJO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsWUFBWSx5REFBUTtBQUNwQjtBQUNBLHVCQUF1Qix1REFBTSxHQUFHO0FBQ2hDLGFBQWE7QUFDYjs7QUFFQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFNLEdBQUc7QUFDaEMsYUFBYTs7QUFFYix1RkFBdUY7O0FBRXZGLFlBQVkseURBQVEsVUFBVSxxREFBSTtBQUNsQyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0Esb0JBQW9CLHVEQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL2xheWVycy9HcmlkTGF5ZXIubWpzP2EwOWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFwZXJMYXllciB9IGZyb20gJy4uL1BhcGVyTGF5ZXIubWpzJztcbmltcG9ydCB7XG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1N0cmluZyxcbiAgICBkZWZhdWx0cyxcbiAgICBvbWl0LFxuICAgIGFzc2lnbixcbiAgICBtZXJnZSxcbn0gZnJvbSAnLi4vLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vLi4vVi9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3QgR3JpZExheWVyID0gUGFwZXJMYXllci5leHRlbmQoe1xuXG4gICAgc3R5bGU6IHtcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgfSxcblxuICAgIF9ncmlkQ2FjaGU6IG51bGwsXG4gICAgX2dyaWRTZXR0aW5nczogbnVsbCxcblxuICAgIGluaXQoKSB7XG4gICAgICAgIFBhcGVyTGF5ZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zOiB7IHBhcGVyIH19ID0gdGhpcztcbiAgICAgICAgdGhpcy5fZ3JpZENhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZ3JpZFNldHRpbmdzID0gW107XG4gICAgICAgIHRoaXMubGlzdGVuVG8ocGFwZXIsICd0cmFuc2Zvcm0gcmVzaXplJywgdGhpcy51cGRhdGVHcmlkKTtcbiAgICB9LFxuXG4gICAgc2V0R3JpZChkcmF3R3JpZCkge1xuICAgICAgICB0aGlzLl9ncmlkU2V0dGluZ3MgPSB0aGlzLmdldEdyaWRTZXR0aW5ncyhkcmF3R3JpZCk7XG4gICAgICAgIHRoaXMucmVuZGVyR3JpZCgpO1xuICAgIH0sXG5cbiAgICBnZXRHcmlkU2V0dGluZ3MoZHJhd0dyaWQpIHtcbiAgICAgICAgY29uc3QgZ3JpZFNldHRpbmdzID0gW107XG4gICAgICAgIGlmIChkcmF3R3JpZCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uc0xpc3QgPSBBcnJheS5pc0FycmF5KGRyYXdHcmlkKSA/IGRyYXdHcmlkIDogW2RyYXdHcmlkIHx8IHt9XTtcbiAgICAgICAgICAgIG9wdGlvbnNMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBncmlkU2V0dGluZ3MucHVzaCguLi50aGlzLl9yZXNvbHZlRHJhd0dyaWRPcHRpb24oaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyaWRTZXR0aW5ncztcbiAgICB9LFxuXG4gICAgcmVtb3ZlR3JpZCgpIHtcbiAgICAgICAgY29uc3QgeyBfZ3JpZENhY2hlOiBncmlkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWdyaWQpIHJldHVybjtcbiAgICAgICAgZ3JpZC5yb290LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLl9ncmlkQ2FjaGUgPSBudWxsO1xuICAgIH0sXG5cbiAgICByZW5kZXJHcmlkKCkge1xuXG4gICAgICAgIGNvbnN0IHsgb3B0aW9uczogeyBwYXBlciB9fSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgX2dyaWRTZXR0aW5nczogZ3JpZFNldHRpbmdzIH0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlR3JpZCgpO1xuXG4gICAgICAgIGlmIChncmlkU2V0dGluZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZ3JpZFNpemUgPSBwYXBlci5vcHRpb25zLmRyYXdHcmlkU2l6ZSB8fCBwYXBlci5vcHRpb25zLmdyaWRTaXplO1xuICAgICAgICBpZiAoZ3JpZFNpemUgPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IHRoaXMuX2dldEdyaWRSZWZzKCk7XG5cbiAgICAgICAgZ3JpZFNldHRpbmdzLmZvckVhY2goKGdyaWRMYXllclNldHRpbmcsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5fZ2V0UGF0dGVybklkKGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZSh7fSwgZ3JpZExheWVyU2V0dGluZyk7XG4gICAgICAgICAgICBjb25zdCB7IHNjYWxlRmFjdG9yID0gMSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMud2lkdGggPSBncmlkU2l6ZSAqIHNjYWxlRmFjdG9yIHx8IDE7XG4gICAgICAgICAgICBvcHRpb25zLmhlaWdodCA9IGdyaWRTaXplICogc2NhbGVGYWN0b3IgfHwgMTtcblxuICAgICAgICAgICAgbGV0IHZQYXR0ZXJuO1xuICAgICAgICAgICAgaWYgKCFyZWZzLmV4aXN0KGlkKSkge1xuICAgICAgICAgICAgICAgIHZQYXR0ZXJuID0gVigncGF0dGVybicsIHsgaWQ6IGlkLCBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZScgfSwgVihvcHRpb25zLm1hcmt1cCkpO1xuICAgICAgICAgICAgICAgIHJlZnMuYWRkKGlkLCB2UGF0dGVybik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZQYXR0ZXJuID0gcmVmcy5nZXQoaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnJlbmRlcikpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJlbmRlcih2UGF0dGVybi5ub2RlLmZpcnN0Q2hpbGQsIG9wdGlvbnMsIHBhcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZQYXR0ZXJuLmF0dHIoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZWZzLnJvb3QuYXBwZW5kVG8odGhpcy5lbCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVHcmlkKCkge1xuXG4gICAgICAgIGNvbnN0IHsgX2dyaWRDYWNoZTogZ3JpZCwgX2dyaWRTZXR0aW5nczogZ3JpZFNldHRpbmdzLCBvcHRpb25zOiB7IHBhcGVyIH19ID0gdGhpcztcbiAgICAgICAgaWYgKCFncmlkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgcm9vdDogdlN2ZywgcGF0dGVybnMgfSA9IGdyaWQ7XG4gICAgICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gcGFwZXIuZ2V0QXJlYSgpO1xuICAgICAgICB2U3ZnLmF0dHIoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm5JZCBpbiBwYXR0ZXJucykge1xuICAgICAgICAgICAgY29uc3QgdlBhdHRlcm4gPSBwYXR0ZXJuc1twYXR0ZXJuSWRdO1xuICAgICAgICAgICAgdlBhdHRlcm4uYXR0cih7IHg6IC14LCB5OiAteSB9KTtcbiAgICAgICAgfVxuICAgICAgICBncmlkU2V0dGluZ3MuZm9yRWFjaCgob3B0aW9ucywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMudXBkYXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZQYXR0ZXJuID0gcGF0dGVybnNbdGhpcy5fZ2V0UGF0dGVybklkKGluZGV4KV07XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51cGRhdGUodlBhdHRlcm4ubm9kZS5maXJzdENoaWxkLCBvcHRpb25zLCBwYXBlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0UGF0dGVybklkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBgcGF0dGVybl8ke3RoaXMub3B0aW9ucy5wYXBlci5jaWR9XyR7aW5kZXh9YDtcbiAgICB9LFxuXG4gICAgX2dldEdyaWRSZWZzKCkge1xuICAgICAgICBsZXQgeyBfZ3JpZENhY2hlOiBncmlkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoZ3JpZCkgcmV0dXJuIGdyaWQ7XG4gICAgICAgIGNvbnN0IGRlZnNWRWwgPSBWKCdkZWZzJyk7XG4gICAgICAgIGNvbnN0IHN2Z1ZFbCA9IFYoJ3N2ZycsIHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfSwgW2RlZnNWRWxdKTtcbiAgICAgICAgZ3JpZCA9IHRoaXMuX2dyaWRDYWNoZSA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHN2Z1ZFbCxcbiAgICAgICAgICAgIHBhdHRlcm5zOiB7fSxcbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24oaWQsIHBhdHRlcm5WRWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWN0VkVsID0gVigncmVjdCcsIHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIGZpbGw6IGB1cmwoIyR7aWR9KWAgfSk7XG4gICAgICAgICAgICAgICAgZGVmc1ZFbC5hcHBlbmQocGF0dGVyblZFbCk7XG4gICAgICAgICAgICAgICAgc3ZnVkVsLmFwcGVuZChyZWN0VkVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdHRlcm5zW2lkXSA9IHBhdHRlcm5WRWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm5zW2lkXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleGlzdDogZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuc1tpZF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgfSxcblxuICAgIF9yZXNvbHZlRHJhd0dyaWRPcHRpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMub3B0aW9ucy5wYXR0ZXJucztcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9wdCkgJiYgQXJyYXkuaXNBcnJheShuYW1lc3BhY2Vbb3B0XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc3BhY2Vbb3B0XS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3NpZ24oe30sIGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IG9wdCB8fCB7IGFyZ3M6IFt7fV0gfTtcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMpO1xuICAgICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgIW5hbWUgJiYgIW9wdGlvbnMubWFya3VwKSB7XG4gICAgICAgICAgICBuYW1lID0gJ2RvdCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZSAmJiBBcnJheS5pc0FycmF5KG5hbWVzcGFjZVtuYW1lXSkpIHtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gbmFtZXNwYWNlW25hbWVdLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzc2lnbih7fSwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXJncykgPyBvcHRpb25zLmFyZ3MgOiBbb3B0aW9ucy5hcmdzIHx8IHt9XTtcblxuICAgICAgICAgICAgZGVmYXVsdHMoYXJnc1swXSwgb21pdChvcHQsICdhcmdzJykpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKHBhdHRlcm5baV0sIGFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkgPyBvcHRpb25zIDogW29wdGlvbnNdO1xuICAgIH0sXG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/layers/GridLayer.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/dia/ports.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/dia/ports.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   elementPortPrototype: function() { return /* binding */ elementPortPrototype; },\n/* harmony export */   elementViewPortPrototype: function() { return /* binding */ elementViewPortPrototype; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../layout/ports/port.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/port.mjs\");\n/* harmony import */ var _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../layout/ports/portLabel.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs\");\n\n\n\n\n\n\nvar PortData = function(data) {\n\n    var clonedData = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(data) || {};\n    this.ports = [];\n    this.groups = {};\n    this.portLayoutNamespace = _layout_ports_port_mjs__WEBPACK_IMPORTED_MODULE_1__;\n    this.portLabelLayoutNamespace = _layout_ports_portLabel_mjs__WEBPACK_IMPORTED_MODULE_2__;\n\n    this._init(clonedData);\n};\n\nPortData.prototype = {\n\n    getPorts: function() {\n        return this.ports;\n    },\n\n    getGroup: function(name) {\n        return this.groups[name] || {};\n    },\n\n    getPortsByGroup: function(groupName) {\n\n        return this.ports.filter(function(port) {\n            return port.group === groupName;\n        });\n    },\n\n    getGroupPortsMetrics: function(groupName, elBBox) {\n\n        var group = this.getGroup(groupName);\n        var ports = this.getPortsByGroup(groupName);\n\n        var groupPosition = group.position || {};\n        var groupPositionName = groupPosition.name;\n        var namespace = this.portLayoutNamespace;\n        if (!namespace[groupPositionName]) {\n            groupPositionName = 'left';\n        }\n\n        var groupArgs = groupPosition.args || {};\n        var portsArgs = ports.map(function(port) {\n            return port && port.position && port.position.args;\n        });\n        var groupPortTransformations = namespace[groupPositionName](portsArgs, elBBox, groupArgs);\n\n        var accumulator = {\n            ports: ports,\n            result: []\n        };\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(groupPortTransformations).reduce(function(res, portTransformation, index) {\n            var port = res.ports[index];\n            res.result.push({\n                portId: port.id,\n                portTransformation: portTransformation,\n                labelTransformation: this._getPortLabelLayout(port, (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point)(portTransformation), elBBox),\n                portAttrs: port.attrs,\n                portSize: port.size,\n                labelSize: port.label.size\n            });\n            return res;\n        }.bind(this), accumulator);\n\n        return accumulator.result;\n    },\n\n    _getPortLabelLayout: function(port, portPosition, elBBox) {\n\n        var namespace = this.portLabelLayoutNamespace;\n        var labelPosition = port.label.position.name || 'left';\n\n        if (namespace[labelPosition]) {\n            return namespace[labelPosition](portPosition, elBBox, port.label.position.args);\n        }\n\n        return null;\n    },\n\n    _init: function(data) {\n\n        // prepare groups\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(data.groups)) {\n            var groups = Object.keys(data.groups);\n            for (var i = 0, n = groups.length; i < n; i++) {\n                var key = groups[i];\n                this.groups[key] = this._evaluateGroup(data.groups[key]);\n            }\n        }\n\n        // prepare ports\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(data.items);\n        for (var j = 0, m = ports.length; j < m; j++) {\n            this.ports.push(this._evaluatePort(ports[j]));\n        }\n    },\n\n    _evaluateGroup: function(group) {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge(group, {\n            position: this._getPosition(group.position, true),\n            label: this._getLabel(group, true)\n        });\n    },\n\n    _evaluatePort: function(port) {\n\n        var evaluated = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, port);\n\n        var group = this.getGroup(port.group);\n\n        evaluated.markup = evaluated.markup || group.markup;\n        evaluated.attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({}, group.attrs, evaluated.attrs);\n        evaluated.position = this._createPositionNode(group, evaluated);\n        evaluated.label = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({}, group.label, this._getLabel(evaluated));\n        evaluated.z = this._getZIndex(group, evaluated);\n        evaluated.size = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, group.size, evaluated.size);\n\n        return evaluated;\n    },\n\n    _getZIndex: function(group, port) {\n\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(port.z)) {\n            return port.z;\n        }\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(group.z) || group.z === 'auto') {\n            return group.z;\n        }\n        return 'auto';\n    },\n\n    _createPositionNode: function(group, port) {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.merge({\n            name: 'left',\n            args: {}\n        }, group.position, { args: port.args });\n    },\n\n    _getPosition: function(position, setDefault) {\n\n        var args = {};\n        var positionName;\n\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(position)) {\n            positionName = 'fn';\n            args.fn = position;\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(position)) {\n            positionName = position;\n        } else if (position === undefined) {\n            positionName = setDefault ? 'left' : null;\n        } else if (Array.isArray(position)) {\n            positionName = 'absolute';\n            args.x = position[0];\n            args.y = position[1];\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(position)) {\n            positionName = position.name;\n            _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign(args, position.args);\n        }\n\n        var result = { args: args };\n\n        if (positionName) {\n            result.name = positionName;\n        }\n        return result;\n    },\n\n    _getLabel: function(item, setDefaults) {\n\n        var label = item.label || {};\n\n        var ret = label;\n        ret.position = this._getPosition(label.position, setDefaults);\n\n        return ret;\n    }\n};\n\nconst elementPortPrototype = {\n\n    _initializePorts: function() {\n\n        this._createPortData();\n        this.on('change:ports', function() {\n\n            this._processRemovedPort();\n            this._createPortData();\n        }, this);\n    },\n\n    /**\n     * remove links tied wiht just removed element\n     * @private\n     */\n    _processRemovedPort: function() {\n\n        var current = this.get('ports') || {};\n        var currentItemsMap = {};\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(current.items).forEach(function(item) {\n            currentItemsMap[item.id] = true;\n        });\n\n        var previous = this.previous('ports') || {};\n        var removed = {};\n\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(previous.items).forEach(function(item) {\n            if (!currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n\n        var graph = this.graph;\n        if (graph && !_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty(removed)) {\n\n            var inboundLinks = graph.getConnectedLinks(this, { inbound: true });\n            inboundLinks.forEach(function(link) {\n\n                if (removed[link.get('target').port]) link.remove();\n            });\n\n            var outboundLinks = graph.getConnectedLinks(this, { outbound: true });\n            outboundLinks.forEach(function(link) {\n\n                if (removed[link.get('source').port]) link.remove();\n            });\n        }\n    },\n\n    /**\n     * @returns {boolean}\n     */\n    hasPorts: function() {\n\n        var ports = this.prop('ports/items');\n        return Array.isArray(ports) && ports.length > 0;\n    },\n\n    /**\n     * @param {string} id\n     * @returns {boolean}\n     */\n    hasPort: function(id) {\n\n        return this.getPortIndex(id) !== -1;\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getPorts: function() {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(this.prop('ports/items')) || [];\n    },\n\n    /**\n     * @returns {Array<object>}\n     */\n    getGroupPorts: function(groupName) {\n        const groupPorts = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop(['ports','items'])).filter(port => port.group === groupName);\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(groupPorts);\n    },\n\n    /**\n     * @param {string} id\n     * @returns {object}\n     */\n    getPort: function(id) {\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cloneDeep(_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop('ports/items')).find(function(port) {\n            return port.id && port.id === id;\n        }));\n    },\n\n    getPortGroupNames: function() {\n        return Object.keys(this._portSettingsData.groups);\n    },\n\n    /**\n     * @param {string} groupName\n     * @returns {Object<portId, {x: number, y: number, angle: number}>}\n     */\n    getPortsPositions: function(groupName) {\n\n        var portsMetrics = this._portSettingsData.getGroupPortsMetrics(groupName, (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect)(this.size()));\n\n        return portsMetrics.reduce(function(positions, metrics) {\n            var transformation = metrics.portTransformation;\n            positions[metrics.portId] = {\n                x: transformation.x,\n                y: transformation.y,\n                angle: transformation.angle\n            };\n            return positions;\n        }, {});\n    },\n\n    /**\n     * @param {string|Port} port port id or port\n     * @returns {number} port index\n     */\n    getPortIndex: function(port) {\n\n        var id = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) ? port.id : port;\n\n        if (!this._isValidPortId(id)) {\n            return -1;\n        }\n\n        return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.prop('ports/items')).findIndex(function(item) {\n            return item.id === id;\n        });\n    },\n\n    /**\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    addPort: function(port, opt) {\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) || Array.isArray(port)) {\n            throw new Error('Element: addPort requires an object.');\n        }\n\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop('ports/items'));\n        ports.push(port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string|Port|number} before\n     * @param {object} port\n     * @param {object} [opt]\n     * @returns {joint.dia.Element}\n     */\n    insertPort: function(before, port, opt) {\n        const index = (typeof before === 'number') ? before : this.getPortIndex(before);\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(port) || Array.isArray(port)) {\n            throw new Error('dia.Element: insertPort requires an object.');\n        }\n\n        const ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop('ports/items'));\n        ports.splice(index, 0, port);\n        this.prop('ports/items', ports, opt);\n\n        return this;\n    },\n\n    /**\n     * @param {string} portId\n     * @param {string|object=} path\n     * @param {*=} value\n     * @param {object=} opt\n     * @returns {joint.dia.Element}\n     */\n    portProp: function(portId, path, value, opt) {\n\n        var index = this.getPortIndex(portId);\n\n        if (index === -1) {\n            throw new Error('Element: unable to find port with id ' + portId);\n        }\n\n        var args = Array.prototype.slice.call(arguments, 1);\n        if (Array.isArray(path)) {\n            args[0] = ['ports', 'items', index].concat(path);\n        } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isString(path)) {\n\n            // Get/set an attribute by a special path syntax that delimits\n            // nested objects by the colon character.\n            args[0] = ['ports/items/', index, '/', path].join('');\n\n        } else {\n\n            args = ['ports/items/' + index];\n            if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(path)) {\n                args.push(path);\n                args.push(value);\n            }\n        }\n\n        return this.prop.apply(this, args);\n    },\n\n    _validatePorts: function() {\n\n        var portsAttr = this.get('ports') || {};\n\n        var errorMessages = [];\n        portsAttr = portsAttr || {};\n        var ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(portsAttr.items);\n\n        ports.forEach(function(p) {\n\n            if (typeof p !== 'object') {\n                errorMessages.push('Element: invalid port ', p);\n            }\n\n            if (!this._isValidPortId(p.id)) {\n                p.id = this.generatePortId();\n            }\n        }, this);\n\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq(ports, 'id').length !== ports.length) {\n            errorMessages.push('Element: found id duplicities in ports.');\n        }\n\n        return errorMessages;\n    },\n\n    generatePortId: function() {\n        return this.generateId();\n    },\n\n    /**\n     * @param {string} id port id\n     * @returns {boolean}\n     * @private\n     */\n    _isValidPortId: function(id) {\n\n        return id !== null && id !== undefined && !_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(id);\n    },\n\n    addPorts: function(ports, opt) {\n\n        if (ports.length) {\n            this.prop('ports/items', _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop('ports/items')).concat(ports), opt);\n        }\n\n        return this;\n    },\n\n    removePort: function(port, opt) {\n        const options = opt || {};\n        const index = this.getPortIndex(port);\n        if (index !== -1) {\n            const ports = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(['ports', 'items']));\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.startBatch('port-remove');\n            this.prop(['ports', 'items'], ports, options);\n            this.stopBatch('port-remove');\n        }\n        return this;\n    },\n\n    removePorts: function(portsForRemoval, opt) {\n        let options, newPorts;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length === 0) return this.this;\n            const currentPorts = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign([], this.prop(['ports', 'items']));\n            newPorts = currentPorts.filter(function(cp) {\n                return !portsForRemoval.some(function(rp) {\n                    const rpId = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(rp) ? rp.id : rp;\n                    return cp.id === rpId;\n                });\n            });\n        } else {\n            options = portsForRemoval || {};\n            newPorts = [];\n        }\n        this.startBatch('port-remove');\n        options.rewrite = true;\n        this.prop(['ports', 'items'], newPorts, options);\n        this.stopBatch('port-remove');\n        return this;\n    },\n\n    /**\n     * @private\n     */\n    _createPortData: function() {\n\n        var err = this._validatePorts();\n\n        if (err.length > 0) {\n            this.set('ports', this.previous('ports'));\n            throw new Error(err.join(' '));\n        }\n\n        var prevPortData;\n\n        if (this._portSettingsData) {\n\n            prevPortData = this._portSettingsData.getPorts();\n        }\n\n        this._portSettingsData = new PortData(this.get('ports'));\n\n        var curPortData = this._portSettingsData.getPorts();\n\n        if (prevPortData) {\n\n            var added = curPortData.filter(function(item) {\n                if (!prevPortData.find(function(prevPort) {\n                    return prevPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            var removed = prevPortData.filter(function(item) {\n                if (!curPortData.find(function(curPort) {\n                    return curPort.id === item.id;\n                })) {\n                    return item;\n                }\n            });\n\n            if (removed.length > 0) {\n                this.trigger('ports:remove', this, removed);\n            }\n\n            if (added.length > 0) {\n                this.trigger('ports:add', this, added);\n            }\n        }\n    }\n};\n\nconst elementViewPortPrototype = {\n\n    portContainerMarkup: 'g',\n    portMarkup: [{\n        tagName: 'circle',\n        selector: 'circle',\n        attributes: {\n            'r': 10,\n            'fill': '#FFFFFF',\n            'stroke': '#000000'\n        }\n    }],\n    portLabelMarkup: [{\n        tagName: 'text',\n        selector: 'text',\n        attributes: {\n            'fill': '#000000'\n        }\n    }],\n    /** @type {Object<string, {portElement: Vectorizer, portLabelElement: Vectorizer}>} */\n    _portElementsCache: null,\n\n    /**\n     * @private\n     */\n    _initializePorts: function() {\n        this._cleanPortsCache();\n    },\n\n    /**\n     * @typedef {Object} Port\n     *\n     * @property {string} id\n     * @property {Object} position\n     * @property {Object} label\n     * @property {Object} attrs\n     * @property {string} markup\n     * @property {string} group\n     */\n\n    /**\n     * @private\n     */\n    _refreshPorts: function() {\n\n        this._removePorts();\n        this._cleanPortsCache();\n        this._renderPorts();\n    },\n\n    _cleanPortsCache: function() {\n        this._portElementsCache = {};\n    },\n\n    /**\n     * @private\n     */\n    _renderPorts: function() {\n\n        // references to rendered elements without z-index\n        var elementReferences = [];\n        var elem = this._getContainerElement();\n\n        for (var i = 0, count = elem.node.childNodes.length; i < count; i++) {\n            elementReferences.push(elem.node.childNodes[i]);\n        }\n\n        var portsGropsByZ = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.groupBy(this.model._portSettingsData.getPorts(), 'z');\n        var withoutZKey = 'auto';\n\n        // render non-z first\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(portsGropsByZ[withoutZKey]).forEach(function(port) {\n            var portElement = this._getPortElement(port);\n            elem.append(portElement);\n            elementReferences.push(portElement);\n        }, this);\n\n        var groupNames = Object.keys(portsGropsByZ);\n        for (var k = 0; k < groupNames.length; k++) {\n            var groupName = groupNames[k];\n            if (groupName !== withoutZKey) {\n                var z = parseInt(groupName, 10);\n                this._appendPorts(portsGropsByZ[groupName], z, elementReferences);\n            }\n        }\n\n        this._updatePorts();\n    },\n\n    /**\n     * @returns {V}\n     * @private\n     */\n    _getContainerElement: function() {\n\n        return this.rotatableNode || this.vel;\n    },\n\n    /**\n     * @param {Array<Port>}ports\n     * @param {number} z\n     * @param refs\n     * @private\n     */\n    _appendPorts: function(ports, z, refs) {\n\n        var containerElement = this._getContainerElement();\n        var portElements = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(ports).map(this._getPortElement, this);\n\n        if (refs[z] || z < 0) {\n            (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(refs[Math.max(z, 0)]).before(portElements);\n        } else {\n            containerElement.append(portElements);\n        }\n    },\n\n    /**\n     * Try to get element from cache,\n     * @param port\n     * @returns {*}\n     * @private\n     */\n    _getPortElement: function(port) {\n\n        if (this._portElementsCache[port.id]) {\n            return this._portElementsCache[port.id].portElement;\n        }\n        return this._createPortElement(port);\n    },\n\n    findPortNodes: function(portId, selector) {\n        const portCache = this._portElementsCache[portId];\n        if (!portCache) return [];\n        if (!selector) return [portCache.portContentElement.node];\n        const portRoot = portCache.portElement.node;\n        const portSelectors = portCache.portSelectors;\n        return this.findBySelector(selector, portRoot, portSelectors);\n    },\n\n    findPortNode: function(portId, selector) {\n        const [node = null] = this.findPortNodes(portId, selector);\n        return node;\n    },\n\n    /**\n     * @private\n     */\n    _updatePorts: function() {\n\n        // layout ports without group\n        this._updatePortGroup(undefined);\n        // layout ports with explicit group\n        var groupsNames = Object.keys(this.model._portSettingsData.groups);\n        groupsNames.forEach(this._updatePortGroup, this);\n    },\n\n    /**\n     * @private\n     */\n    _removePorts: function() {\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.invoke(this._portElementsCache, 'portElement.remove');\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {V}\n     * @private\n     */\n    _createPortElement: function(port) {\n\n        let portElement;\n        let labelElement;\n        let labelSelectors;\n        let portSelectors;\n\n        var portContainerElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(this.portContainerMarkup).addClass('joint-port');\n\n        var portMarkup = this._getPortMarkup(port);\n        if (Array.isArray(portMarkup)) {\n            var portDoc = this.parseDOMJSON(portMarkup, portContainerElement.node);\n            var portFragment = portDoc.fragment;\n            if (portFragment.childNodes.length > 1) {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(portFragment);\n            } else {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(portFragment.firstChild);\n            }\n            portSelectors = portDoc.selectors;\n        } else {\n            portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(portMarkup);\n            if (Array.isArray(portElement)) {\n                portElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(portElement);\n            }\n        }\n\n        if (!portElement) {\n            throw new Error('ElementView: Invalid port markup.');\n        }\n\n        portElement.attr({\n            'port': port.id,\n            'port-group': port.group\n        });\n\n        // If the port ID is a number, we need to add\n        // extra information to the port element to distinguish\n        // between ports with the same ID but different types.\n        if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber(port.id)) {\n            portElement.attr('port-id-type', 'number');\n        }\n\n        const labelMarkupDef = this._getPortLabelMarkup(port.label);\n        if (Array.isArray(labelMarkupDef)) {\n            // JSON Markup\n            const { fragment, selectors } = this.parseDOMJSON(labelMarkupDef, portContainerElement.node);\n            const childCount = fragment.childNodes.length;\n            if (childCount > 0) {\n                labelSelectors = selectors;\n                labelElement = (childCount === 1) ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fragment.firstChild) : (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(fragment);\n            }\n        } else {\n            // String Markup\n            labelElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(labelMarkupDef);\n            if (Array.isArray(labelElement)) {\n                labelElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])('g').append(labelElement);\n            }\n        }\n\n        var portContainerSelectors;\n        if (portSelectors && labelSelectors) {\n            for (var key in labelSelectors) {\n                if (portSelectors[key] && key !== this.selector) throw new Error('ElementView: selectors within port must be unique.');\n            }\n            portContainerSelectors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, portSelectors, labelSelectors);\n        } else {\n            portContainerSelectors = portSelectors || labelSelectors || {};\n        }\n\n        // The `portRootSelector` points to the root SVGNode of the port.\n        // Either the implicit wrapping group <g/> in case the port consist of multiple SVGNodes.\n        // Or the single SVGNode of the port.\n        const portRootSelector = 'portRoot';\n        // The `labelRootSelector` points to the root SVGNode of the label.\n        const labelRootSelector = 'labelRoot';\n        // The `labelTextSelector` points to all text SVGNodes of the label.\n        const labelTextSelector = 'labelText';\n\n        if (!(portRootSelector in portContainerSelectors)) {\n            portContainerSelectors[portRootSelector] = portElement.node;\n        }\n\n        if (labelElement) {\n            const labelNode = labelElement.node;\n            if (!(labelRootSelector in portContainerSelectors)) {\n                portContainerSelectors[labelRootSelector] = labelNode;\n            }\n            if (!(labelTextSelector in portContainerSelectors)) {\n                // If the label is a <text> element, we can use it directly.\n                // Otherwise, we need to find the <text> element within the label.\n                const labelTextNode = (labelElement.tagName() === 'TEXT')\n                    ? labelNode\n                    : Array.from(labelNode.querySelectorAll('text'));\n                portContainerSelectors[labelTextSelector] = labelTextNode;\n                if (!labelSelectors) labelSelectors = {};\n                labelSelectors[labelTextSelector] = labelTextNode;\n            }\n        }\n\n        portContainerElement.append(portElement.addClass('joint-port-body'));\n        if (labelElement) {\n            portContainerElement.append(labelElement.addClass('joint-port-label'));\n        }\n\n        this._portElementsCache[port.id] = {\n            portElement: portContainerElement,\n            portLabelElement: labelElement,\n            portSelectors: portContainerSelectors,\n            portLabelSelectors: labelSelectors,\n            portContentElement: portElement,\n            portContentSelectors: portSelectors\n        };\n\n        return portContainerElement;\n    },\n\n    /**\n     * @param {string=} groupName\n     * @private\n     */\n    _updatePortGroup: function(groupName) {\n\n        var elementBBox = (0,_g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect)(this.model.size());\n        var portsMetrics = this.model._portSettingsData.getGroupPortsMetrics(groupName, elementBBox);\n\n        for (var i = 0, n = portsMetrics.length; i < n; i++) {\n            var metrics = portsMetrics[i];\n            var portId = metrics.portId;\n            var cached = this._portElementsCache[portId] || {};\n            var portTransformation = metrics.portTransformation;\n            var labelTransformation = metrics.labelTransformation;\n            if (labelTransformation && cached.portLabelElement) {\n                this.updateDOMSubtreeAttributes(cached.portLabelElement.node, labelTransformation.attrs, {\n                    rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(metrics.labelSize),\n                    selectors: cached.portLabelSelectors\n                });\n                this.applyPortTransform(cached.portLabelElement, labelTransformation, (-portTransformation.angle || 0));\n            }\n            this.updateDOMSubtreeAttributes(cached.portElement.node, metrics.portAttrs, {\n                rootBBox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(metrics.portSize),\n                selectors: cached.portSelectors\n            });\n            this.applyPortTransform(cached.portElement, portTransformation);\n        }\n    },\n\n    /**\n     * @param {Vectorizer} element\n     * @param {{dx:number, dy:number, angle: number, attrs: Object, x:number: y:number}} transformData\n     * @param {number=} initialAngle\n     * @constructor\n     */\n    applyPortTransform: function(element, transformData, initialAngle) {\n\n        var matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"].createSVGMatrix()\n            .rotate(initialAngle || 0)\n            .translate(transformData.x || 0, transformData.y || 0)\n            .rotate(transformData.angle || 0);\n\n        element.transform(matrix, { absolute: true });\n    },\n\n    /**\n     * @param {Port} port\n     * @returns {string}\n     * @private\n     */\n    _getPortMarkup: function(port) {\n\n        return port.markup || this.model.get('portMarkup') || this.model.portMarkup || this.portMarkup;\n    },\n\n    /**\n     * @param {Object} label\n     * @returns {string}\n     * @private\n     */\n    _getPortLabelMarkup: function(label) {\n\n        return label.markup || this.model.get('portLabelMarkup') || this.model.portLabelMarkup || this.portLabelMarkup;\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZGlhL3BvcnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwQztBQUNYO0FBQ2M7QUFDSTtBQUNVOztBQUUzRDs7QUFFQSxxQkFBcUIsc0RBQWM7QUFDbkM7QUFDQTtBQUNBLCtCQUErQixtREFBSTtBQUNuQyxvQ0FBb0Msd0RBQVM7O0FBRTdDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLG9EQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1EQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLFlBQVkscURBQWE7QUFDekI7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvREFBWTtBQUNoQywwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxlQUFlLGtEQUFVO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQSx3QkFBd0IsbURBQVcsR0FBRzs7QUFFdEM7O0FBRUE7QUFDQSwwQkFBMEIsa0RBQVUsR0FBRztBQUN2QztBQUNBLDBCQUEwQixrREFBVSxHQUFHO0FBQ3ZDO0FBQ0EseUJBQXlCLG1EQUFXLEdBQUc7O0FBRXZDO0FBQ0EsS0FBSzs7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RCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUFJO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBSTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IseUVBQXlFO0FBQ3pGLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG9EQUFDO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELEtBQUs7O0FBRUw7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9kaWEvcG9ydHMubWpzPzZmZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBSZWN0LCBQb2ludCB9IGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIFBvcnQgZnJvbSAnLi4vbGF5b3V0L3BvcnRzL3BvcnQubWpzJztcbmltcG9ydCAqIGFzIFBvcnRMYWJlbCBmcm9tICcuLi9sYXlvdXQvcG9ydHMvcG9ydExhYmVsLm1qcyc7XG5cbnZhciBQb3J0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBjbG9uZWREYXRhID0gdXRpbC5jbG9uZURlZXAoZGF0YSkgfHwge307XG4gICAgdGhpcy5wb3J0cyA9IFtdO1xuICAgIHRoaXMuZ3JvdXBzID0ge307XG4gICAgdGhpcy5wb3J0TGF5b3V0TmFtZXNwYWNlID0gUG9ydDtcbiAgICB0aGlzLnBvcnRMYWJlbExheW91dE5hbWVzcGFjZSA9IFBvcnRMYWJlbDtcblxuICAgIHRoaXMuX2luaXQoY2xvbmVkRGF0YSk7XG59O1xuXG5Qb3J0RGF0YS5wcm90b3R5cGUgPSB7XG5cbiAgICBnZXRQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcnRzO1xuICAgIH0sXG5cbiAgICBnZXRHcm91cDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cHNbbmFtZV0gfHwge307XG4gICAgfSxcblxuICAgIGdldFBvcnRzQnlHcm91cDogZnVuY3Rpb24oZ3JvdXBOYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9ydHMuZmlsdGVyKGZ1bmN0aW9uKHBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3J0Lmdyb3VwID09PSBncm91cE5hbWU7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRHcm91cFBvcnRzTWV0cmljczogZnVuY3Rpb24oZ3JvdXBOYW1lLCBlbEJCb3gpIHtcblxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKGdyb3VwTmFtZSk7XG4gICAgICAgIHZhciBwb3J0cyA9IHRoaXMuZ2V0UG9ydHNCeUdyb3VwKGdyb3VwTmFtZSk7XG5cbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb24gPSBncm91cC5wb3NpdGlvbiB8fCB7fTtcbiAgICAgICAgdmFyIGdyb3VwUG9zaXRpb25OYW1lID0gZ3JvdXBQb3NpdGlvbi5uYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5wb3J0TGF5b3V0TmFtZXNwYWNlO1xuICAgICAgICBpZiAoIW5hbWVzcGFjZVtncm91cFBvc2l0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIGdyb3VwUG9zaXRpb25OYW1lID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwQXJncyA9IGdyb3VwUG9zaXRpb24uYXJncyB8fCB7fTtcbiAgICAgICAgdmFyIHBvcnRzQXJncyA9IHBvcnRzLm1hcChmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9ydCAmJiBwb3J0LnBvc2l0aW9uICYmIHBvcnQucG9zaXRpb24uYXJncztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBncm91cFBvcnRUcmFuc2Zvcm1hdGlvbnMgPSBuYW1lc3BhY2VbZ3JvdXBQb3NpdGlvbk5hbWVdKHBvcnRzQXJncywgZWxCQm94LCBncm91cEFyZ3MpO1xuXG4gICAgICAgIHZhciBhY2N1bXVsYXRvciA9IHtcbiAgICAgICAgICAgIHBvcnRzOiBwb3J0cyxcbiAgICAgICAgICAgIHJlc3VsdDogW11cbiAgICAgICAgfTtcblxuICAgICAgICB1dGlsLnRvQXJyYXkoZ3JvdXBQb3J0VHJhbnNmb3JtYXRpb25zKS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBwb3J0VHJhbnNmb3JtYXRpb24sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcG9ydCA9IHJlcy5wb3J0c1tpbmRleF07XG4gICAgICAgICAgICByZXMucmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgIHBvcnRJZDogcG9ydC5pZCxcbiAgICAgICAgICAgICAgICBwb3J0VHJhbnNmb3JtYXRpb246IHBvcnRUcmFuc2Zvcm1hdGlvbixcbiAgICAgICAgICAgICAgICBsYWJlbFRyYW5zZm9ybWF0aW9uOiB0aGlzLl9nZXRQb3J0TGFiZWxMYXlvdXQocG9ydCwgUG9pbnQocG9ydFRyYW5zZm9ybWF0aW9uKSwgZWxCQm94KSxcbiAgICAgICAgICAgICAgICBwb3J0QXR0cnM6IHBvcnQuYXR0cnMsXG4gICAgICAgICAgICAgICAgcG9ydFNpemU6IHBvcnQuc2l6ZSxcbiAgICAgICAgICAgICAgICBsYWJlbFNpemU6IHBvcnQubGFiZWwuc2l6ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LmJpbmQodGhpcyksIGFjY3VtdWxhdG9yKTtcblxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IucmVzdWx0O1xuICAgIH0sXG5cbiAgICBfZ2V0UG9ydExhYmVsTGF5b3V0OiBmdW5jdGlvbihwb3J0LCBwb3J0UG9zaXRpb24sIGVsQkJveCkge1xuXG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLnBvcnRMYWJlbExheW91dE5hbWVzcGFjZTtcbiAgICAgICAgdmFyIGxhYmVsUG9zaXRpb24gPSBwb3J0LmxhYmVsLnBvc2l0aW9uLm5hbWUgfHwgJ2xlZnQnO1xuXG4gICAgICAgIGlmIChuYW1lc3BhY2VbbGFiZWxQb3NpdGlvbl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VbbGFiZWxQb3NpdGlvbl0ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIHBvcnQubGFiZWwucG9zaXRpb24uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgX2luaXQ6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICAvLyBwcmVwYXJlIGdyb3Vwc1xuICAgICAgICBpZiAodXRpbC5pc09iamVjdChkYXRhLmdyb3VwcykpIHtcbiAgICAgICAgICAgIHZhciBncm91cHMgPSBPYmplY3Qua2V5cyhkYXRhLmdyb3Vwcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2tleV0gPSB0aGlzLl9ldmFsdWF0ZUdyb3VwKGRhdGEuZ3JvdXBzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGFyZSBwb3J0c1xuICAgICAgICB2YXIgcG9ydHMgPSB1dGlsLnRvQXJyYXkoZGF0YS5pdGVtcyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcG9ydHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICB0aGlzLnBvcnRzLnB1c2godGhpcy5fZXZhbHVhdGVQb3J0KHBvcnRzW2pdKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2V2YWx1YXRlR3JvdXA6IGZ1bmN0aW9uKGdyb3VwKSB7XG5cbiAgICAgICAgcmV0dXJuIHV0aWwubWVyZ2UoZ3JvdXAsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLl9nZXRQb3NpdGlvbihncm91cC5wb3NpdGlvbiwgdHJ1ZSksXG4gICAgICAgICAgICBsYWJlbDogdGhpcy5fZ2V0TGFiZWwoZ3JvdXAsIHRydWUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfZXZhbHVhdGVQb3J0OiBmdW5jdGlvbihwb3J0KSB7XG5cbiAgICAgICAgdmFyIGV2YWx1YXRlZCA9IHV0aWwuYXNzaWduKHt9LCBwb3J0KTtcblxuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdldEdyb3VwKHBvcnQuZ3JvdXApO1xuXG4gICAgICAgIGV2YWx1YXRlZC5tYXJrdXAgPSBldmFsdWF0ZWQubWFya3VwIHx8IGdyb3VwLm1hcmt1cDtcbiAgICAgICAgZXZhbHVhdGVkLmF0dHJzID0gdXRpbC5tZXJnZSh7fSwgZ3JvdXAuYXR0cnMsIGV2YWx1YXRlZC5hdHRycyk7XG4gICAgICAgIGV2YWx1YXRlZC5wb3NpdGlvbiA9IHRoaXMuX2NyZWF0ZVBvc2l0aW9uTm9kZShncm91cCwgZXZhbHVhdGVkKTtcbiAgICAgICAgZXZhbHVhdGVkLmxhYmVsID0gdXRpbC5tZXJnZSh7fSwgZ3JvdXAubGFiZWwsIHRoaXMuX2dldExhYmVsKGV2YWx1YXRlZCkpO1xuICAgICAgICBldmFsdWF0ZWQueiA9IHRoaXMuX2dldFpJbmRleChncm91cCwgZXZhbHVhdGVkKTtcbiAgICAgICAgZXZhbHVhdGVkLnNpemUgPSB1dGlsLmFzc2lnbih7fSwgZ3JvdXAuc2l6ZSwgZXZhbHVhdGVkLnNpemUpO1xuXG4gICAgICAgIHJldHVybiBldmFsdWF0ZWQ7XG4gICAgfSxcblxuICAgIF9nZXRaSW5kZXg6IGZ1bmN0aW9uKGdyb3VwLCBwb3J0KSB7XG5cbiAgICAgICAgaWYgKHV0aWwuaXNOdW1iZXIocG9ydC56KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcnQuejtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbC5pc051bWJlcihncm91cC56KSB8fCBncm91cC56ID09PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cC56O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnYXV0byc7XG4gICAgfSxcblxuICAgIF9jcmVhdGVQb3NpdGlvbk5vZGU6IGZ1bmN0aW9uKGdyb3VwLCBwb3J0KSB7XG5cbiAgICAgICAgcmV0dXJuIHV0aWwubWVyZ2Uoe1xuICAgICAgICAgICAgbmFtZTogJ2xlZnQnLFxuICAgICAgICAgICAgYXJnczoge31cbiAgICAgICAgfSwgZ3JvdXAucG9zaXRpb24sIHsgYXJnczogcG9ydC5hcmdzIH0pO1xuICAgIH0sXG5cbiAgICBfZ2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uLCBzZXREZWZhdWx0KSB7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSB7fTtcbiAgICAgICAgdmFyIHBvc2l0aW9uTmFtZTtcblxuICAgICAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gJ2ZuJztcbiAgICAgICAgICAgIGFyZ3MuZm4gPSBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlsLmlzU3RyaW5nKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9zaXRpb25OYW1lID0gc2V0RGVmYXVsdCA/ICdsZWZ0JyA6IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTmFtZSA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBhcmdzLnggPSBwb3NpdGlvblswXTtcbiAgICAgICAgICAgIGFyZ3MueSA9IHBvc2l0aW9uWzFdO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgICAgICBwb3NpdGlvbk5hbWUgPSBwb3NpdGlvbi5uYW1lO1xuICAgICAgICAgICAgdXRpbC5hc3NpZ24oYXJncywgcG9zaXRpb24uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0geyBhcmdzOiBhcmdzIH07XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBwb3NpdGlvbk5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dldExhYmVsOiBmdW5jdGlvbihpdGVtLCBzZXREZWZhdWx0cykge1xuXG4gICAgICAgIHZhciBsYWJlbCA9IGl0ZW0ubGFiZWwgfHwge307XG5cbiAgICAgICAgdmFyIHJldCA9IGxhYmVsO1xuICAgICAgICByZXQucG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihsYWJlbC5wb3NpdGlvbiwgc2V0RGVmYXVsdHMpO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVsZW1lbnRQb3J0UHJvdG90eXBlID0ge1xuXG4gICAgX2luaXRpYWxpemVQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlUG9ydERhdGEoKTtcbiAgICAgICAgdGhpcy5vbignY2hhbmdlOnBvcnRzJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NSZW1vdmVkUG9ydCgpO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUG9ydERhdGEoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBsaW5rcyB0aWVkIHdpaHQganVzdCByZW1vdmVkIGVsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzUmVtb3ZlZFBvcnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXQoJ3BvcnRzJykgfHwge307XG4gICAgICAgIHZhciBjdXJyZW50SXRlbXNNYXAgPSB7fTtcblxuICAgICAgICB1dGlsLnRvQXJyYXkoY3VycmVudC5pdGVtcykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBjdXJyZW50SXRlbXNNYXBbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzKCdwb3J0cycpIHx8IHt9O1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IHt9O1xuXG4gICAgICAgIHV0aWwudG9BcnJheShwcmV2aW91cy5pdGVtcykuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRJdGVtc01hcFtpdGVtLmlkXSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRbaXRlbS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgICBpZiAoZ3JhcGggJiYgIXV0aWwuaXNFbXB0eShyZW1vdmVkKSkge1xuXG4gICAgICAgICAgICB2YXIgaW5ib3VuZExpbmtzID0gZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3ModGhpcywgeyBpbmJvdW5kOiB0cnVlIH0pO1xuICAgICAgICAgICAgaW5ib3VuZExpbmtzLmZvckVhY2goZnVuY3Rpb24obGluaykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRbbGluay5nZXQoJ3RhcmdldCcpLnBvcnRdKSBsaW5rLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBvdXRib3VuZExpbmtzID0gZ3JhcGguZ2V0Q29ubmVjdGVkTGlua3ModGhpcywgeyBvdXRib3VuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIG91dGJvdW5kTGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFtsaW5rLmdldCgnc291cmNlJykucG9ydF0pIGxpbmsucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvcnRzID0gdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycpO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwb3J0cykgJiYgcG9ydHMubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUG9ydDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb3J0SW5kZXgoaWQpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0FycmF5PG9iamVjdD59XG4gICAgICovXG4gICAgZ2V0UG9ydHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB1dGlsLmNsb25lRGVlcCh0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpIHx8IFtdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8b2JqZWN0Pn1cbiAgICAgKi9cbiAgICBnZXRHcm91cFBvcnRzOiBmdW5jdGlvbihncm91cE5hbWUpIHtcbiAgICAgICAgY29uc3QgZ3JvdXBQb3J0cyA9IHV0aWwudG9BcnJheSh0aGlzLnByb3AoWydwb3J0cycsJ2l0ZW1zJ10pKS5maWx0ZXIocG9ydCA9PiBwb3J0Lmdyb3VwID09PSBncm91cE5hbWUpO1xuICAgICAgICByZXR1cm4gdXRpbC5jbG9uZURlZXAoZ3JvdXBQb3J0cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0UG9ydDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gdXRpbC5jbG9uZURlZXAodXRpbC50b0FycmF5KHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKSkuZmluZChmdW5jdGlvbihwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gcG9ydC5pZCAmJiBwb3J0LmlkID09PSBpZDtcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBnZXRQb3J0R3JvdXBOYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9wb3J0U2V0dGluZ3NEYXRhLmdyb3Vwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBncm91cE5hbWVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0PHBvcnRJZCwge3g6IG51bWJlciwgeTogbnVtYmVyLCBhbmdsZTogbnVtYmVyfT59XG4gICAgICovXG4gICAgZ2V0UG9ydHNQb3NpdGlvbnM6IGZ1bmN0aW9uKGdyb3VwTmFtZSkge1xuXG4gICAgICAgIHZhciBwb3J0c01ldHJpY3MgPSB0aGlzLl9wb3J0U2V0dGluZ3NEYXRhLmdldEdyb3VwUG9ydHNNZXRyaWNzKGdyb3VwTmFtZSwgUmVjdCh0aGlzLnNpemUoKSkpO1xuXG4gICAgICAgIHJldHVybiBwb3J0c01ldHJpY3MucmVkdWNlKGZ1bmN0aW9uKHBvc2l0aW9ucywgbWV0cmljcykge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWF0aW9uID0gbWV0cmljcy5wb3J0VHJhbnNmb3JtYXRpb247XG4gICAgICAgICAgICBwb3NpdGlvbnNbbWV0cmljcy5wb3J0SWRdID0ge1xuICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybWF0aW9uLngsXG4gICAgICAgICAgICAgICAgeTogdHJhbnNmb3JtYXRpb24ueSxcbiAgICAgICAgICAgICAgICBhbmdsZTogdHJhbnNmb3JtYXRpb24uYW5nbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgICAgICB9LCB7fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFBvcnR9IHBvcnQgcG9ydCBpZCBvciBwb3J0XG4gICAgICogQHJldHVybnMge251bWJlcn0gcG9ydCBpbmRleFxuICAgICAqL1xuICAgIGdldFBvcnRJbmRleDogZnVuY3Rpb24ocG9ydCkge1xuXG4gICAgICAgIHZhciBpZCA9IHV0aWwuaXNPYmplY3QocG9ydCkgPyBwb3J0LmlkIDogcG9ydDtcblxuICAgICAgICBpZiAoIXRoaXMuX2lzVmFsaWRQb3J0SWQoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbC50b0FycmF5KHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKSkuZmluZEluZGV4KGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmlkID09PSBpZDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3J0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRdXG4gICAgICogQHJldHVybnMge2pvaW50LmRpYS5FbGVtZW50fVxuICAgICAqL1xuICAgIGFkZFBvcnQ6IGZ1bmN0aW9uKHBvcnQsIG9wdCkge1xuXG4gICAgICAgIGlmICghdXRpbC5pc09iamVjdChwb3J0KSB8fCBBcnJheS5pc0FycmF5KHBvcnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQ6IGFkZFBvcnQgcmVxdWlyZXMgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcnRzID0gdXRpbC5hc3NpZ24oW10sIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnKSk7XG4gICAgICAgIHBvcnRzLnB1c2gocG9ydCk7XG4gICAgICAgIHRoaXMucHJvcCgncG9ydHMvaXRlbXMnLCBwb3J0cywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UG9ydHxudW1iZXJ9IGJlZm9yZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwb3J0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRdXG4gICAgICogQHJldHVybnMge2pvaW50LmRpYS5FbGVtZW50fVxuICAgICAqL1xuICAgIGluc2VydFBvcnQ6IGZ1bmN0aW9uKGJlZm9yZSwgcG9ydCwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gKHR5cGVvZiBiZWZvcmUgPT09ICdudW1iZXInKSA/IGJlZm9yZSA6IHRoaXMuZ2V0UG9ydEluZGV4KGJlZm9yZSk7XG5cbiAgICAgICAgaWYgKCF1dGlsLmlzT2JqZWN0KHBvcnQpIHx8IEFycmF5LmlzQXJyYXkocG9ydCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlhLkVsZW1lbnQ6IGluc2VydFBvcnQgcmVxdWlyZXMgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9ydHMgPSB1dGlsLmFzc2lnbihbXSwgdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycpKTtcbiAgICAgICAgcG9ydHMuc3BsaWNlKGluZGV4LCAwLCBwb3J0KTtcbiAgICAgICAgdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycsIHBvcnRzLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcG9ydElkXG4gICAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0PX0gcGF0aFxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRcbiAgICAgKiBAcmV0dXJucyB7am9pbnQuZGlhLkVsZW1lbnR9XG4gICAgICovXG4gICAgcG9ydFByb3A6IGZ1bmN0aW9uKHBvcnRJZCwgcGF0aCwgdmFsdWUsIG9wdCkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0UG9ydEluZGV4KHBvcnRJZCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50OiB1bmFibGUgdG8gZmluZCBwb3J0IHdpdGggaWQgJyArIHBvcnRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICBhcmdzWzBdID0gWydwb3J0cycsICdpdGVtcycsIGluZGV4XS5jb25jYXQocGF0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbC5pc1N0cmluZyhwYXRoKSkge1xuXG4gICAgICAgICAgICAvLyBHZXQvc2V0IGFuIGF0dHJpYnV0ZSBieSBhIHNwZWNpYWwgcGF0aCBzeW50YXggdGhhdCBkZWxpbWl0c1xuICAgICAgICAgICAgLy8gbmVzdGVkIG9iamVjdHMgYnkgdGhlIGNvbG9uIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGFyZ3NbMF0gPSBbJ3BvcnRzL2l0ZW1zLycsIGluZGV4LCAnLycsIHBhdGhdLmpvaW4oJycpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGFyZ3MgPSBbJ3BvcnRzL2l0ZW1zLycgKyBpbmRleF07XG4gICAgICAgICAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBfdmFsaWRhdGVQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvcnRzQXR0ciA9IHRoaXMuZ2V0KCdwb3J0cycpIHx8IHt9O1xuXG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgIHBvcnRzQXR0ciA9IHBvcnRzQXR0ciB8fCB7fTtcbiAgICAgICAgdmFyIHBvcnRzID0gdXRpbC50b0FycmF5KHBvcnRzQXR0ci5pdGVtcyk7XG5cbiAgICAgICAgcG9ydHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2VzLnB1c2goJ0VsZW1lbnQ6IGludmFsaWQgcG9ydCAnLCBwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkUG9ydElkKHAuaWQpKSB7XG4gICAgICAgICAgICAgICAgcC5pZCA9IHRoaXMuZ2VuZXJhdGVQb3J0SWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHV0aWwudW5pcShwb3J0cywgJ2lkJykubGVuZ3RoICE9PSBwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXMucHVzaCgnRWxlbWVudDogZm91bmQgaWQgZHVwbGljaXRpZXMgaW4gcG9ydHMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlcztcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGVQb3J0SWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUlkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBwb3J0IGlkXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNWYWxpZFBvcnRJZDogZnVuY3Rpb24oaWQpIHtcblxuICAgICAgICByZXR1cm4gaWQgIT09IG51bGwgJiYgaWQgIT09IHVuZGVmaW5lZCAmJiAhdXRpbC5pc09iamVjdChpZCk7XG4gICAgfSxcblxuICAgIGFkZFBvcnRzOiBmdW5jdGlvbihwb3J0cywgb3B0KSB7XG5cbiAgICAgICAgaWYgKHBvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wKCdwb3J0cy9pdGVtcycsIHV0aWwuYXNzaWduKFtdLCB0aGlzLnByb3AoJ3BvcnRzL2l0ZW1zJykpLmNvbmNhdChwb3J0cyksIG9wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlUG9ydDogZnVuY3Rpb24ocG9ydCwgb3B0KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvcHQgfHwge307XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRQb3J0SW5kZXgocG9ydCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcnRzID0gdXRpbC5hc3NpZ24oW10sIHRoaXMucHJvcChbJ3BvcnRzJywgJ2l0ZW1zJ10pKTtcbiAgICAgICAgICAgIHBvcnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBvcHRpb25zLnJld3JpdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdwb3J0LXJlbW92ZScpO1xuICAgICAgICAgICAgdGhpcy5wcm9wKFsncG9ydHMnLCAnaXRlbXMnXSwgcG9ydHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zdG9wQmF0Y2goJ3BvcnQtcmVtb3ZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVBvcnRzOiBmdW5jdGlvbihwb3J0c0ZvclJlbW92YWwsIG9wdCkge1xuICAgICAgICBsZXQgb3B0aW9ucywgbmV3UG9ydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvcnRzRm9yUmVtb3ZhbCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHQgfHwge307XG4gICAgICAgICAgICBpZiAocG9ydHNGb3JSZW1vdmFsLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMudGhpcztcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb3J0cyA9IHV0aWwuYXNzaWduKFtdLCB0aGlzLnByb3AoWydwb3J0cycsICdpdGVtcyddKSk7XG4gICAgICAgICAgICBuZXdQb3J0cyA9IGN1cnJlbnRQb3J0cy5maWx0ZXIoZnVuY3Rpb24oY3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXBvcnRzRm9yUmVtb3ZhbC5zb21lKGZ1bmN0aW9uKHJwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJwSWQgPSB1dGlsLmlzT2JqZWN0KHJwKSA/IHJwLmlkIDogcnA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcC5pZCA9PT0gcnBJZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHBvcnRzRm9yUmVtb3ZhbCB8fCB7fTtcbiAgICAgICAgICAgIG5ld1BvcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydEJhdGNoKCdwb3J0LXJlbW92ZScpO1xuICAgICAgICBvcHRpb25zLnJld3JpdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnByb3AoWydwb3J0cycsICdpdGVtcyddLCBuZXdQb3J0cywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc3RvcEJhdGNoKCdwb3J0LXJlbW92ZScpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlUG9ydERhdGE6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlcnIgPSB0aGlzLl92YWxpZGF0ZVBvcnRzKCk7XG5cbiAgICAgICAgaWYgKGVyci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldCgncG9ydHMnLCB0aGlzLnByZXZpb3VzKCdwb3J0cycpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIuam9pbignICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2UG9ydERhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BvcnRTZXR0aW5nc0RhdGEpIHtcblxuICAgICAgICAgICAgcHJldlBvcnREYXRhID0gdGhpcy5fcG9ydFNldHRpbmdzRGF0YS5nZXRQb3J0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9ydFNldHRpbmdzRGF0YSA9IG5ldyBQb3J0RGF0YSh0aGlzLmdldCgncG9ydHMnKSk7XG5cbiAgICAgICAgdmFyIGN1clBvcnREYXRhID0gdGhpcy5fcG9ydFNldHRpbmdzRGF0YS5nZXRQb3J0cygpO1xuXG4gICAgICAgIGlmIChwcmV2UG9ydERhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGFkZGVkID0gY3VyUG9ydERhdGEuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZQb3J0RGF0YS5maW5kKGZ1bmN0aW9uKHByZXZQb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2UG9ydC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBwcmV2UG9ydERhdGEuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1clBvcnREYXRhLmZpbmQoZnVuY3Rpb24oY3VyUG9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VyUG9ydC5pZCA9PT0gaXRlbS5pZDtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncG9ydHM6cmVtb3ZlJywgdGhpcywgcmVtb3ZlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwb3J0czphZGQnLCB0aGlzLCBhZGRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgZWxlbWVudFZpZXdQb3J0UHJvdG90eXBlID0ge1xuXG4gICAgcG9ydENvbnRhaW5lck1hcmt1cDogJ2cnLFxuICAgIHBvcnRNYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICBzZWxlY3RvcjogJ2NpcmNsZScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdyJzogMTAsXG4gICAgICAgICAgICAnZmlsbCc6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAnIzAwMDAwMCdcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIHBvcnRMYWJlbE1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ3RleHQnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICcjMDAwMDAwJ1xuICAgICAgICB9XG4gICAgfV0sXG4gICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCB7cG9ydEVsZW1lbnQ6IFZlY3Rvcml6ZXIsIHBvcnRMYWJlbEVsZW1lbnQ6IFZlY3Rvcml6ZXJ9Pn0gKi9cbiAgICBfcG9ydEVsZW1lbnRzQ2FjaGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhblBvcnRzQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUG9ydFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHBvc2l0aW9uXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGxhYmVsXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IGF0dHJzXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1hcmt1cFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBncm91cFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVmcmVzaFBvcnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLl9yZW1vdmVQb3J0cygpO1xuICAgICAgICB0aGlzLl9jbGVhblBvcnRzQ2FjaGUoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyUG9ydHMoKTtcbiAgICB9LFxuXG4gICAgX2NsZWFuUG9ydHNDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3BvcnRFbGVtZW50c0NhY2hlID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbmRlclBvcnRzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAvLyByZWZlcmVuY2VzIHRvIHJlbmRlcmVkIGVsZW1lbnRzIHdpdGhvdXQgei1pbmRleFxuICAgICAgICB2YXIgZWxlbWVudFJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzLl9nZXRDb250YWluZXJFbGVtZW50KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNvdW50ID0gZWxlbS5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgZWxlbWVudFJlZmVyZW5jZXMucHVzaChlbGVtLm5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9ydHNHcm9wc0J5WiA9IHV0aWwuZ3JvdXBCeSh0aGlzLm1vZGVsLl9wb3J0U2V0dGluZ3NEYXRhLmdldFBvcnRzKCksICd6Jyk7XG4gICAgICAgIHZhciB3aXRob3V0WktleSA9ICdhdXRvJztcblxuICAgICAgICAvLyByZW5kZXIgbm9uLXogZmlyc3RcbiAgICAgICAgdXRpbC50b0FycmF5KHBvcnRzR3JvcHNCeVpbd2l0aG91dFpLZXldKS5mb3JFYWNoKGZ1bmN0aW9uKHBvcnQpIHtcbiAgICAgICAgICAgIHZhciBwb3J0RWxlbWVudCA9IHRoaXMuX2dldFBvcnRFbGVtZW50KHBvcnQpO1xuICAgICAgICAgICAgZWxlbS5hcHBlbmQocG9ydEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxlbWVudFJlZmVyZW5jZXMucHVzaChwb3J0RWxlbWVudCk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHZhciBncm91cE5hbWVzID0gT2JqZWN0LmtleXMocG9ydHNHcm9wc0J5Wik7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ3JvdXBOYW1lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGdyb3VwTmFtZXNba107XG4gICAgICAgICAgICBpZiAoZ3JvdXBOYW1lICE9PSB3aXRob3V0WktleSkge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gcGFyc2VJbnQoZ3JvdXBOYW1lLCAxMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kUG9ydHMocG9ydHNHcm9wc0J5Wltncm91cE5hbWVdLCB6LCBlbGVtZW50UmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVQb3J0cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7Vn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRDb250YWluZXJFbGVtZW50OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGFibGVOb2RlIHx8IHRoaXMudmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5PFBvcnQ+fXBvcnRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHpcbiAgICAgKiBAcGFyYW0gcmVmc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FwcGVuZFBvcnRzOiBmdW5jdGlvbihwb3J0cywgeiwgcmVmcykge1xuXG4gICAgICAgIHZhciBjb250YWluZXJFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xuICAgICAgICB2YXIgcG9ydEVsZW1lbnRzID0gdXRpbC50b0FycmF5KHBvcnRzKS5tYXAodGhpcy5fZ2V0UG9ydEVsZW1lbnQsIHRoaXMpO1xuXG4gICAgICAgIGlmIChyZWZzW3pdIHx8IHogPCAwKSB7XG4gICAgICAgICAgICBWKHJlZnNbTWF0aC5tYXgoeiwgMCldKS5iZWZvcmUocG9ydEVsZW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kKHBvcnRFbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ5IHRvIGdldCBlbGVtZW50IGZyb20gY2FjaGUsXG4gICAgICogQHBhcmFtIHBvcnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9nZXRQb3J0RWxlbWVudDogZnVuY3Rpb24ocG9ydCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0LmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRFbGVtZW50c0NhY2hlW3BvcnQuaWRdLnBvcnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQb3J0RWxlbWVudChwb3J0KTtcbiAgICB9LFxuXG4gICAgZmluZFBvcnROb2RlczogZnVuY3Rpb24ocG9ydElkLCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBwb3J0Q2FjaGUgPSB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0SWRdO1xuICAgICAgICBpZiAoIXBvcnRDYWNoZSkgcmV0dXJuIFtdO1xuICAgICAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gW3BvcnRDYWNoZS5wb3J0Q29udGVudEVsZW1lbnQubm9kZV07XG4gICAgICAgIGNvbnN0IHBvcnRSb290ID0gcG9ydENhY2hlLnBvcnRFbGVtZW50Lm5vZGU7XG4gICAgICAgIGNvbnN0IHBvcnRTZWxlY3RvcnMgPSBwb3J0Q2FjaGUucG9ydFNlbGVjdG9ycztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEJ5U2VsZWN0b3Ioc2VsZWN0b3IsIHBvcnRSb290LCBwb3J0U2VsZWN0b3JzKTtcbiAgICB9LFxuXG4gICAgZmluZFBvcnROb2RlOiBmdW5jdGlvbihwb3J0SWQsIHNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IFtub2RlID0gbnVsbF0gPSB0aGlzLmZpbmRQb3J0Tm9kZXMocG9ydElkLCBzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVQb3J0czogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy8gbGF5b3V0IHBvcnRzIHdpdGhvdXQgZ3JvdXBcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9ydEdyb3VwKHVuZGVmaW5lZCk7XG4gICAgICAgIC8vIGxheW91dCBwb3J0cyB3aXRoIGV4cGxpY2l0IGdyb3VwXG4gICAgICAgIHZhciBncm91cHNOYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMubW9kZWwuX3BvcnRTZXR0aW5nc0RhdGEuZ3JvdXBzKTtcbiAgICAgICAgZ3JvdXBzTmFtZXMuZm9yRWFjaCh0aGlzLl91cGRhdGVQb3J0R3JvdXAsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmVQb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHV0aWwuaW52b2tlKHRoaXMuX3BvcnRFbGVtZW50c0NhY2hlLCAncG9ydEVsZW1lbnQucmVtb3ZlJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UG9ydH0gcG9ydFxuICAgICAqIEByZXR1cm5zIHtWfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVBvcnRFbGVtZW50OiBmdW5jdGlvbihwb3J0KSB7XG5cbiAgICAgICAgbGV0IHBvcnRFbGVtZW50O1xuICAgICAgICBsZXQgbGFiZWxFbGVtZW50O1xuICAgICAgICBsZXQgbGFiZWxTZWxlY3RvcnM7XG4gICAgICAgIGxldCBwb3J0U2VsZWN0b3JzO1xuXG4gICAgICAgIHZhciBwb3J0Q29udGFpbmVyRWxlbWVudCA9IFYodGhpcy5wb3J0Q29udGFpbmVyTWFya3VwKS5hZGRDbGFzcygnam9pbnQtcG9ydCcpO1xuXG4gICAgICAgIHZhciBwb3J0TWFya3VwID0gdGhpcy5fZ2V0UG9ydE1hcmt1cChwb3J0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9ydE1hcmt1cCkpIHtcbiAgICAgICAgICAgIHZhciBwb3J0RG9jID0gdGhpcy5wYXJzZURPTUpTT04ocG9ydE1hcmt1cCwgcG9ydENvbnRhaW5lckVsZW1lbnQubm9kZSk7XG4gICAgICAgICAgICB2YXIgcG9ydEZyYWdtZW50ID0gcG9ydERvYy5mcmFnbWVudDtcbiAgICAgICAgICAgIGlmIChwb3J0RnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcG9ydEVsZW1lbnQgPSBWKCdnJykuYXBwZW5kKHBvcnRGcmFnbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcnRFbGVtZW50ID0gVihwb3J0RnJhZ21lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3J0U2VsZWN0b3JzID0gcG9ydERvYy5zZWxlY3RvcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3J0RWxlbWVudCA9IFYocG9ydE1hcmt1cCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb3J0RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBwb3J0RWxlbWVudCA9IFYoJ2cnKS5hcHBlbmQocG9ydEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwb3J0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50VmlldzogSW52YWxpZCBwb3J0IG1hcmt1cC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcnRFbGVtZW50LmF0dHIoe1xuICAgICAgICAgICAgJ3BvcnQnOiBwb3J0LmlkLFxuICAgICAgICAgICAgJ3BvcnQtZ3JvdXAnOiBwb3J0Lmdyb3VwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHRoZSBwb3J0IElEIGlzIGEgbnVtYmVyLCB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAvLyBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgcG9ydCBlbGVtZW50IHRvIGRpc3Rpbmd1aXNoXG4gICAgICAgIC8vIGJldHdlZW4gcG9ydHMgd2l0aCB0aGUgc2FtZSBJRCBidXQgZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICBpZiAodXRpbC5pc051bWJlcihwb3J0LmlkKSkge1xuICAgICAgICAgICAgcG9ydEVsZW1lbnQuYXR0cigncG9ydC1pZC10eXBlJywgJ251bWJlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFiZWxNYXJrdXBEZWYgPSB0aGlzLl9nZXRQb3J0TGFiZWxNYXJrdXAocG9ydC5sYWJlbCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxhYmVsTWFya3VwRGVmKSkge1xuICAgICAgICAgICAgLy8gSlNPTiBNYXJrdXBcbiAgICAgICAgICAgIGNvbnN0IHsgZnJhZ21lbnQsIHNlbGVjdG9ycyB9ID0gdGhpcy5wYXJzZURPTUpTT04obGFiZWxNYXJrdXBEZWYsIHBvcnRDb250YWluZXJFbGVtZW50Lm5vZGUpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb3VudCA9IGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNoaWxkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxTZWxlY3RvcnMgPSBzZWxlY3RvcnM7XG4gICAgICAgICAgICAgICAgbGFiZWxFbGVtZW50ID0gKGNoaWxkQ291bnQgPT09IDEpID8gVihmcmFnbWVudC5maXJzdENoaWxkKSA6IFYoJ2cnKS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3RyaW5nIE1hcmt1cFxuICAgICAgICAgICAgbGFiZWxFbGVtZW50ID0gVihsYWJlbE1hcmt1cERlZik7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsYWJlbEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxFbGVtZW50ID0gVignZycpLmFwcGVuZChsYWJlbEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvcnRDb250YWluZXJTZWxlY3RvcnM7XG4gICAgICAgIGlmIChwb3J0U2VsZWN0b3JzICYmIGxhYmVsU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGFiZWxTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9ydFNlbGVjdG9yc1trZXldICYmIGtleSAhPT0gdGhpcy5zZWxlY3RvcikgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50Vmlldzogc2VsZWN0b3JzIHdpdGhpbiBwb3J0IG11c3QgYmUgdW5pcXVlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9ydENvbnRhaW5lclNlbGVjdG9ycyA9IHV0aWwuYXNzaWduKHt9LCBwb3J0U2VsZWN0b3JzLCBsYWJlbFNlbGVjdG9ycyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzID0gcG9ydFNlbGVjdG9ycyB8fCBsYWJlbFNlbGVjdG9ycyB8fCB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBgcG9ydFJvb3RTZWxlY3RvcmAgcG9pbnRzIHRvIHRoZSByb290IFNWR05vZGUgb2YgdGhlIHBvcnQuXG4gICAgICAgIC8vIEVpdGhlciB0aGUgaW1wbGljaXQgd3JhcHBpbmcgZ3JvdXAgPGcvPiBpbiBjYXNlIHRoZSBwb3J0IGNvbnNpc3Qgb2YgbXVsdGlwbGUgU1ZHTm9kZXMuXG4gICAgICAgIC8vIE9yIHRoZSBzaW5nbGUgU1ZHTm9kZSBvZiB0aGUgcG9ydC5cbiAgICAgICAgY29uc3QgcG9ydFJvb3RTZWxlY3RvciA9ICdwb3J0Um9vdCc7XG4gICAgICAgIC8vIFRoZSBgbGFiZWxSb290U2VsZWN0b3JgIHBvaW50cyB0byB0aGUgcm9vdCBTVkdOb2RlIG9mIHRoZSBsYWJlbC5cbiAgICAgICAgY29uc3QgbGFiZWxSb290U2VsZWN0b3IgPSAnbGFiZWxSb290JztcbiAgICAgICAgLy8gVGhlIGBsYWJlbFRleHRTZWxlY3RvcmAgcG9pbnRzIHRvIGFsbCB0ZXh0IFNWR05vZGVzIG9mIHRoZSBsYWJlbC5cbiAgICAgICAgY29uc3QgbGFiZWxUZXh0U2VsZWN0b3IgPSAnbGFiZWxUZXh0JztcblxuICAgICAgICBpZiAoIShwb3J0Um9vdFNlbGVjdG9yIGluIHBvcnRDb250YWluZXJTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzW3BvcnRSb290U2VsZWN0b3JdID0gcG9ydEVsZW1lbnQubm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsTm9kZSA9IGxhYmVsRWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKCEobGFiZWxSb290U2VsZWN0b3IgaW4gcG9ydENvbnRhaW5lclNlbGVjdG9ycykpIHtcbiAgICAgICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzW2xhYmVsUm9vdFNlbGVjdG9yXSA9IGxhYmVsTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGxhYmVsVGV4dFNlbGVjdG9yIGluIHBvcnRDb250YWluZXJTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhYmVsIGlzIGEgPHRleHQ+IGVsZW1lbnQsIHdlIGNhbiB1c2UgaXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIDx0ZXh0PiBlbGVtZW50IHdpdGhpbiB0aGUgbGFiZWwuXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxUZXh0Tm9kZSA9IChsYWJlbEVsZW1lbnQudGFnTmFtZSgpID09PSAnVEVYVCcpXG4gICAgICAgICAgICAgICAgICAgID8gbGFiZWxOb2RlXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbShsYWJlbE5vZGUucXVlcnlTZWxlY3RvckFsbCgndGV4dCcpKTtcbiAgICAgICAgICAgICAgICBwb3J0Q29udGFpbmVyU2VsZWN0b3JzW2xhYmVsVGV4dFNlbGVjdG9yXSA9IGxhYmVsVGV4dE5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFsYWJlbFNlbGVjdG9ycykgbGFiZWxTZWxlY3RvcnMgPSB7fTtcbiAgICAgICAgICAgICAgICBsYWJlbFNlbGVjdG9yc1tsYWJlbFRleHRTZWxlY3Rvcl0gPSBsYWJlbFRleHROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9ydENvbnRhaW5lckVsZW1lbnQuYXBwZW5kKHBvcnRFbGVtZW50LmFkZENsYXNzKCdqb2ludC1wb3J0LWJvZHknKSk7XG4gICAgICAgIGlmIChsYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHBvcnRDb250YWluZXJFbGVtZW50LmFwcGVuZChsYWJlbEVsZW1lbnQuYWRkQ2xhc3MoJ2pvaW50LXBvcnQtbGFiZWwnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3J0RWxlbWVudHNDYWNoZVtwb3J0LmlkXSA9IHtcbiAgICAgICAgICAgIHBvcnRFbGVtZW50OiBwb3J0Q29udGFpbmVyRWxlbWVudCxcbiAgICAgICAgICAgIHBvcnRMYWJlbEVsZW1lbnQ6IGxhYmVsRWxlbWVudCxcbiAgICAgICAgICAgIHBvcnRTZWxlY3RvcnM6IHBvcnRDb250YWluZXJTZWxlY3RvcnMsXG4gICAgICAgICAgICBwb3J0TGFiZWxTZWxlY3RvcnM6IGxhYmVsU2VsZWN0b3JzLFxuICAgICAgICAgICAgcG9ydENvbnRlbnRFbGVtZW50OiBwb3J0RWxlbWVudCxcbiAgICAgICAgICAgIHBvcnRDb250ZW50U2VsZWN0b3JzOiBwb3J0U2VsZWN0b3JzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHBvcnRDb250YWluZXJFbGVtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGdyb3VwTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VwZGF0ZVBvcnRHcm91cDogZnVuY3Rpb24oZ3JvdXBOYW1lKSB7XG5cbiAgICAgICAgdmFyIGVsZW1lbnRCQm94ID0gUmVjdCh0aGlzLm1vZGVsLnNpemUoKSk7XG4gICAgICAgIHZhciBwb3J0c01ldHJpY3MgPSB0aGlzLm1vZGVsLl9wb3J0U2V0dGluZ3NEYXRhLmdldEdyb3VwUG9ydHNNZXRyaWNzKGdyb3VwTmFtZSwgZWxlbWVudEJCb3gpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9ydHNNZXRyaWNzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldHJpY3MgPSBwb3J0c01ldHJpY3NbaV07XG4gICAgICAgICAgICB2YXIgcG9ydElkID0gbWV0cmljcy5wb3J0SWQ7XG4gICAgICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5fcG9ydEVsZW1lbnRzQ2FjaGVbcG9ydElkXSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBwb3J0VHJhbnNmb3JtYXRpb24gPSBtZXRyaWNzLnBvcnRUcmFuc2Zvcm1hdGlvbjtcbiAgICAgICAgICAgIHZhciBsYWJlbFRyYW5zZm9ybWF0aW9uID0gbWV0cmljcy5sYWJlbFRyYW5zZm9ybWF0aW9uO1xuICAgICAgICAgICAgaWYgKGxhYmVsVHJhbnNmb3JtYXRpb24gJiYgY2FjaGVkLnBvcnRMYWJlbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURPTVN1YnRyZWVBdHRyaWJ1dGVzKGNhY2hlZC5wb3J0TGFiZWxFbGVtZW50Lm5vZGUsIGxhYmVsVHJhbnNmb3JtYXRpb24uYXR0cnMsIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEJCb3g6IG5ldyBSZWN0KG1ldHJpY3MubGFiZWxTaXplKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBjYWNoZWQucG9ydExhYmVsU2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVBvcnRUcmFuc2Zvcm0oY2FjaGVkLnBvcnRMYWJlbEVsZW1lbnQsIGxhYmVsVHJhbnNmb3JtYXRpb24sICgtcG9ydFRyYW5zZm9ybWF0aW9uLmFuZ2xlIHx8IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRE9NU3VidHJlZUF0dHJpYnV0ZXMoY2FjaGVkLnBvcnRFbGVtZW50Lm5vZGUsIG1ldHJpY3MucG9ydEF0dHJzLCB7XG4gICAgICAgICAgICAgICAgcm9vdEJCb3g6IG5ldyBSZWN0KG1ldHJpY3MucG9ydFNpemUpLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczogY2FjaGVkLnBvcnRTZWxlY3RvcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hcHBseVBvcnRUcmFuc2Zvcm0oY2FjaGVkLnBvcnRFbGVtZW50LCBwb3J0VHJhbnNmb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VmVjdG9yaXplcn0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7e2R4Om51bWJlciwgZHk6bnVtYmVyLCBhbmdsZTogbnVtYmVyLCBhdHRyczogT2JqZWN0LCB4Om51bWJlcjogeTpudW1iZXJ9fSB0cmFuc2Zvcm1EYXRhXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBpbml0aWFsQW5nbGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBhcHBseVBvcnRUcmFuc2Zvcm06IGZ1bmN0aW9uKGVsZW1lbnQsIHRyYW5zZm9ybURhdGEsIGluaXRpYWxBbmdsZSkge1xuXG4gICAgICAgIHZhciBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpXG4gICAgICAgICAgICAucm90YXRlKGluaXRpYWxBbmdsZSB8fCAwKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZSh0cmFuc2Zvcm1EYXRhLnggfHwgMCwgdHJhbnNmb3JtRGF0YS55IHx8IDApXG4gICAgICAgICAgICAucm90YXRlKHRyYW5zZm9ybURhdGEuYW5nbGUgfHwgMCk7XG5cbiAgICAgICAgZWxlbWVudC50cmFuc2Zvcm0obWF0cml4LCB7IGFic29sdXRlOiB0cnVlIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1BvcnR9IHBvcnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBvcnRNYXJrdXA6IGZ1bmN0aW9uKHBvcnQpIHtcblxuICAgICAgICByZXR1cm4gcG9ydC5tYXJrdXAgfHwgdGhpcy5tb2RlbC5nZXQoJ3BvcnRNYXJrdXAnKSB8fCB0aGlzLm1vZGVsLnBvcnRNYXJrdXAgfHwgdGhpcy5wb3J0TWFya3VwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGFiZWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFBvcnRMYWJlbE1hcmt1cDogZnVuY3Rpb24obGFiZWwpIHtcblxuICAgICAgICByZXR1cm4gbGFiZWwubWFya3VwIHx8IHRoaXMubW9kZWwuZ2V0KCdwb3J0TGFiZWxNYXJrdXAnKSB8fCB0aGlzLm1vZGVsLnBvcnRMYWJlbE1hcmt1cCB8fCB0aGlzLnBvcnRMYWJlbE1hcmt1cDtcbiAgICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/dia/ports.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/elementTools/HoverConnect.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@joint/core/src/elementTools/HoverConnect.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HoverConnect: function() { return /* binding */ HoverConnect; }\n/* harmony export */ });\n/* harmony import */ var _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cellTools/HoverConnect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _util_calc_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/calc.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cellTools/helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\n\nconst HoverConnect = _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__.HoverConnect.extend({\n\n    getTrackPath() {\n        const { relatedView: view, options } = this;\n        let {\n            useModelGeometry,\n            trackPath =  'M 0 0 H calc(w) V calc(h) H 0 Z'\n        } = options;\n        if (typeof trackPath === 'function') {\n            trackPath = trackPath.call(this, view);\n        }\n        if ((0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_1__.isCalcExpression)(trackPath)) {\n            const bbox = (0,_cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getViewBBox)(view, useModelGeometry);\n            trackPath = (0,_util_calc_mjs__WEBPACK_IMPORTED_MODULE_1__.evalCalcExpression)(trackPath, bbox);\n        }\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Path(_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].normalizePathData(trackPath));\n    },\n\n    getTrackMatrix() {\n        const { relatedView: view, options } = this;\n        let { useModelGeometry, rotate } = options;\n        let bbox = (0,_cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_2__.getViewBBox)(view, useModelGeometry);\n        const angle = view.model.angle();\n        if (!rotate) bbox = bbox.bbox(angle);\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].createSVGMatrix().translate(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n        if (rotate) matrix = matrix.rotate(angle);\n        matrix = matrix.translate(- bbox.width / 2, - bbox.height / 2);\n        return matrix;\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZWxlbWVudFRvb2xzL0hvdmVyQ29ubmVjdC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlGO0FBQ2xEO0FBQ0s7QUFDb0M7QUFDakI7O0FBRWhELHFCQUFxQixxRUFBZ0I7O0FBRTVDO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnRUFBZ0I7QUFDNUIseUJBQXlCLG1FQUFXO0FBQ3BDLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQSxtQkFBbUIsOENBQU0sQ0FBQyxvREFBQztBQUMzQixLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QyxjQUFjLDJCQUEyQjtBQUN6QyxtQkFBbUIsbUVBQVc7QUFDOUI7QUFDQTtBQUNBLHFCQUFxQixvREFBQztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZWxlbWVudFRvb2xzL0hvdmVyQ29ubmVjdC5tanM/MjA0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIb3ZlckNvbm5lY3QgYXMgTGlua0hvdmVyQ29ubmVjdCB9IGZyb20gJy4uL2NlbGxUb29scy9Ib3ZlckNvbm5lY3QubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNDYWxjRXhwcmVzc2lvbiwgZXZhbENhbGNFeHByZXNzaW9uIH0gZnJvbSAnLi4vdXRpbC9jYWxjLm1qcyc7XG5pbXBvcnQgeyBnZXRWaWV3QkJveCB9IGZyb20gJy4uL2NlbGxUb29scy9oZWxwZXJzLm1qcyc7XG5cbmV4cG9ydCBjb25zdCBIb3ZlckNvbm5lY3QgPSBMaW5rSG92ZXJDb25uZWN0LmV4dGVuZCh7XG5cbiAgICBnZXRUcmFja1BhdGgoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXc6IHZpZXcsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgICB1c2VNb2RlbEdlb21ldHJ5LFxuICAgICAgICAgICAgdHJhY2tQYXRoID0gICdNIDAgMCBIIGNhbGModykgViBjYWxjKGgpIEggMCBaJ1xuICAgICAgICB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja1BhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyYWNrUGF0aCA9IHRyYWNrUGF0aC5jYWxsKHRoaXMsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGNFeHByZXNzaW9uKHRyYWNrUGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBnZXRWaWV3QkJveCh2aWV3LCB1c2VNb2RlbEdlb21ldHJ5KTtcbiAgICAgICAgICAgIHRyYWNrUGF0aCA9IGV2YWxDYWxjRXhwcmVzc2lvbih0cmFja1BhdGgsIGJib3gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgZy5QYXRoKFYubm9ybWFsaXplUGF0aERhdGEodHJhY2tQYXRoKSk7XG4gICAgfSxcblxuICAgIGdldFRyYWNrTWF0cml4KCkge1xuICAgICAgICBjb25zdCB7IHJlbGF0ZWRWaWV3OiB2aWV3LCBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB1c2VNb2RlbEdlb21ldHJ5LCByb3RhdGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBiYm94ID0gZ2V0Vmlld0JCb3godmlldywgdXNlTW9kZWxHZW9tZXRyeSk7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdmlldy5tb2RlbC5hbmdsZSgpO1xuICAgICAgICBpZiAoIXJvdGF0ZSkgYmJveCA9IGJib3guYmJveChhbmdsZSk7XG4gICAgICAgIGxldCBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZShiYm94LnggKyBiYm94LndpZHRoIC8gMiwgYmJveC55ICsgYmJveC5oZWlnaHQgLyAyKTtcbiAgICAgICAgaWYgKHJvdGF0ZSkgbWF0cml4ID0gbWF0cml4LnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC50cmFuc2xhdGUoLSBiYm94LndpZHRoIC8gMiwgLSBiYm94LmhlaWdodCAvIDIpO1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/elementTools/HoverConnect.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/elementTools/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/elementTools/index.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Boundary: function() { return /* reexport safe */ _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_3__.Boundary; },\n/* harmony export */   Button: function() { return /* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_1__.Button; },\n/* harmony export */   Connect: function() { return /* reexport safe */ _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_2__.Connect; },\n/* harmony export */   Control: function() { return /* reexport safe */ _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_4__.Control; },\n/* harmony export */   HoverConnect: function() { return /* reexport safe */ _HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__.HoverConnect; },\n/* harmony export */   Remove: function() { return /* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_1__.Remove; }\n/* harmony export */ });\n/* harmony import */ var _HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HoverConnect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/elementTools/HoverConnect.mjs\");\n/* harmony import */ var _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cellTools/Button.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Button.mjs\");\n/* harmony import */ var _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cellTools/Connect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Connect.mjs\");\n/* harmony import */ var _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cellTools/Boundary.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Boundary.mjs\");\n/* harmony import */ var _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cellTools/Control.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Control.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZWxlbWVudFRvb2xzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFrRDs7QUFFTztBQUNOO0FBQ0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2VsZW1lbnRUb29scy9pbmRleC5tanM/MTM2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBIb3ZlckNvbm5lY3QgfSBmcm9tICcuL0hvdmVyQ29ubmVjdC5tanMnO1xuXG5leHBvcnQgeyBCdXR0b24sIFJlbW92ZSB9IGZyb20gJy4uL2NlbGxUb29scy9CdXR0b24ubWpzJztcbmV4cG9ydCB7IENvbm5lY3QgfSBmcm9tICcuLi9jZWxsVG9vbHMvQ29ubmVjdC5tanMnO1xuZXhwb3J0IHsgQm91bmRhcnkgfSBmcm9tICcuLi9jZWxsVG9vbHMvQm91bmRhcnkubWpzJztcbmV4cG9ydCB7IENvbnRyb2wgfSBmcm9tICcuLi9jZWxsVG9vbHMvQ29udHJvbC5tanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/elementTools/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/env/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/env/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: function() { return /* binding */ env; }\n/* harmony export */ });\nconst env = {\n\n    _results: {},\n\n    _tests: {\n\n        svgforeignobject: function() {\n            return !!document.createElementNS &&\n                /SVGForeignObject/.test(({}).toString.call(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')));\n        },\n\n        // works for iOS browsers too\n        isSafari: function() {\n            return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);\n        }\n    },\n\n    addTest: function(name, fn) {\n\n        return this._tests[name] = fn;\n    },\n\n    test: function(name) {\n\n        var fn = this._tests[name];\n\n        if (!fn) {\n            throw new Error('Test not defined (\"' + name + '\"). Use `joint.env.addTest(name, fn) to add a new test.`');\n        }\n\n        var result = this._results[name];\n\n        if (typeof result !== 'undefined') {\n            return result;\n        }\n\n        try {\n            result = fn();\n        } catch (error) {\n            result = false;\n        }\n\n        // Cache the test result.\n        this._results[name] = result;\n\n        return result;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZW52L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87O0FBRVAsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2Vudi9pbmRleC5tanM/MTc3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZW52ID0ge1xuXG4gICAgX3Jlc3VsdHM6IHt9LFxuXG4gICAgX3Rlc3RzOiB7XG5cbiAgICAgICAgc3ZnZm9yZWlnbm9iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gISFkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcbiAgICAgICAgICAgICAgICAvU1ZHRm9yZWlnbk9iamVjdC8udGVzdCgoe30pLnRvU3RyaW5nLmNhbGwoZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdmb3JlaWduT2JqZWN0JykpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB3b3JrcyBmb3IgaU9TIGJyb3dzZXJzIHRvb1xuICAgICAgICBpc1NhZmFyaTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRkVGVzdDogZnVuY3Rpb24obmFtZSwgZm4pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdHNbbmFtZV0gPSBmbjtcbiAgICB9LFxuXG4gICAgdGVzdDogZnVuY3Rpb24obmFtZSkge1xuXG4gICAgICAgIHZhciBmbiA9IHRoaXMuX3Rlc3RzW25hbWVdO1xuXG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBub3QgZGVmaW5lZCAoXCInICsgbmFtZSArICdcIikuIFVzZSBgam9pbnQuZW52LmFkZFRlc3QobmFtZSwgZm4pIHRvIGFkZCBhIG5ldyB0ZXN0LmAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9yZXN1bHRzW25hbWVdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmbigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSB0aGUgdGVzdCByZXN1bHQuXG4gICAgICAgIHRoaXMuX3Jlc3VsdHNbbmFtZV0gPSByZXN1bHQ7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/env/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/bezier.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/g/bezier.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bezier: function() { return /* binding */ bezier; }\n/* harmony export */ });\n/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n\n\n\n\nconst bezier = {\n\n    // Cubic Bezier curve path through points.\n    // @deprecated\n    // @param {array} points Array of points through which the smooth line will go.\n    // @return {array} SVG Path commands as an array\n    curveThroughPoints: function(points) {\n\n        console.warn('deprecated');\n\n        return new _path_mjs__WEBPACK_IMPORTED_MODULE_0__.Path(_curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve.throughPoints(points)).serialize();\n    },\n\n    // Get open-ended Bezier Spline Control Points.\n    // @deprecated\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    getCurveControlPoints: function(knots) {\n\n        console.warn('deprecated');\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = this.getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = this.getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2)\n                );\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    },\n\n    // Divide a Bezier curve into two at point defined by value 't' <0,1>.\n    // Using deCasteljau algorithm. http://math.stackexchange.com/a/317867\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts t and returns 2 curves.\n    getCurveDivider: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(p0, p1, p2, p3);\n\n        return function divideCurve(t) {\n\n            var divided = curve.divide(t);\n\n            return [{\n                p0: divided[0].start,\n                p1: divided[0].controlPoint1,\n                p2: divided[0].controlPoint2,\n                p3: divided[0].end\n            }, {\n                p0: divided[1].start,\n                p1: divided[1].controlPoint1,\n                p2: divided[1].controlPoint2,\n                p3: divided[1].end\n            }];\n        };\n    },\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @deprecated\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    getFirstControlPoints: function(rhs) {\n\n        console.warn('deprecated');\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    },\n\n    // Solves an inversion problem -- Given the (x, y) coordinates of a point which lies on\n    // a parametric curve x = x(t)/w(t), y = y(t)/w(t), nd the parameter value t\n    // which corresponds to that point.\n    // @deprecated\n    // @param control points (start, control start, control end, end)\n    // @return a function that accepts a point and returns t.\n    getInversionSolver: function(p0, p1, p2, p3) {\n\n        console.warn('deprecated');\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(p0, p1, p2, p3);\n\n        return function solveInversion(p) {\n\n            return curve.closestPointT(p);\n        };\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9iZXppZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDRTtBQUNBOztBQUU3Qjs7QUFFUDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBOztBQUVBLG1CQUFtQiwyQ0FBSSxDQUFDLDZDQUFLO0FBQzdCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2Q0FBSztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsNkNBQUs7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esd0NBQXdDLDZDQUFLOztBQUU3QztBQUNBO0FBQ0EsNkNBQTZDLDZDQUFLO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsNkNBQTZDLDZDQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsNkNBQUs7O0FBRTdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLDZDQUFLOztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvYmV6aWVyLm1qcz9lNGI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhdGggfSBmcm9tICcuL3BhdGgubWpzJztcbmltcG9ydCB7IEN1cnZlIH0gZnJvbSAnLi9jdXJ2ZS5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCBiZXppZXIgPSB7XG5cbiAgICAvLyBDdWJpYyBCZXppZXIgY3VydmUgcGF0aCB0aHJvdWdoIHBvaW50cy5cbiAgICAvLyBAZGVwcmVjYXRlZFxuICAgIC8vIEBwYXJhbSB7YXJyYXl9IHBvaW50cyBBcnJheSBvZiBwb2ludHMgdGhyb3VnaCB3aGljaCB0aGUgc21vb3RoIGxpbmUgd2lsbCBnby5cbiAgICAvLyBAcmV0dXJuIHthcnJheX0gU1ZHIFBhdGggY29tbWFuZHMgYXMgYW4gYXJyYXlcbiAgICBjdXJ2ZVRocm91Z2hQb2ludHM6IGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUGF0aChDdXJ2ZS50aHJvdWdoUG9pbnRzKHBvaW50cykpLnNlcmlhbGl6ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgb3Blbi1lbmRlZCBCZXppZXIgU3BsaW5lIENvbnRyb2wgUG9pbnRzLlxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgLy8gQHBhcmFtIGtub3RzIElucHV0IEtub3QgQmV6aWVyIHNwbGluZSBwb2ludHMgKEF0IGxlYXN0IHR3byBwb2ludHMhKS5cbiAgICAvLyBAcGFyYW0gZmlyc3RDb250cm9sUG9pbnRzIE91dHB1dCBGaXJzdCBDb250cm9sIHBvaW50cy4gQXJyYXkgb2Yga25vdHMubGVuZ3RoIC0gMSBsZW5ndGguXG4gICAgLy8gQHBhcmFtIHNlY29uZENvbnRyb2xQb2ludHMgT3V0cHV0IFNlY29uZCBDb250cm9sIHBvaW50cy4gQXJyYXkgb2Yga25vdHMubGVuZ3RoIC0gMSBsZW5ndGguXG4gICAgZ2V0Q3VydmVDb250cm9sUG9pbnRzOiBmdW5jdGlvbihrbm90cykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHZhciBmaXJzdENvbnRyb2xQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHNlY29uZENvbnRyb2xQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBrbm90cy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IEJlemllciBjdXJ2ZSBzaG91bGQgYmUgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICBpZiAobiA9PSAxKSB7XG4gICAgICAgICAgICAvLyAzUDEgPSAyUDAgKyBQM1xuICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzBdID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICgyICoga25vdHNbMF0ueCArIGtub3RzWzFdLngpIC8gMyxcbiAgICAgICAgICAgICAgICAoMiAqIGtub3RzWzBdLnkgKyBrbm90c1sxXS55KSAvIDNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFAyID0gMlAxIOKAkyBQMFxuICAgICAgICAgICAgc2Vjb25kQ29udHJvbFBvaW50c1swXSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAyICogZmlyc3RDb250cm9sUG9pbnRzWzBdLnggLSBrbm90c1swXS54LFxuICAgICAgICAgICAgICAgIDIgKiBmaXJzdENvbnRyb2xQb2ludHNbMF0ueSAtIGtub3RzWzBdLnlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBbZmlyc3RDb250cm9sUG9pbnRzLCBzZWNvbmRDb250cm9sUG9pbnRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBmaXJzdCBCZXppZXIgY29udHJvbCBwb2ludHMuXG4gICAgICAgIC8vIFJpZ2h0IGhhbmQgc2lkZSB2ZWN0b3IuXG4gICAgICAgIHZhciByaHMgPSBbXTtcblxuICAgICAgICAvLyBTZXQgcmlnaHQgaGFuZCBzaWRlIFggdmFsdWVzLlxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgcmhzW2ldID0gNCAqIGtub3RzW2ldLnggKyAyICoga25vdHNbaSArIDFdLng7XG4gICAgICAgIH1cblxuICAgICAgICByaHNbMF0gPSBrbm90c1swXS54ICsgMiAqIGtub3RzWzFdLng7XG4gICAgICAgIHJoc1tuIC0gMV0gPSAoOCAqIGtub3RzW24gLSAxXS54ICsga25vdHNbbl0ueCkgLyAyLjA7XG5cbiAgICAgICAgLy8gR2V0IGZpcnN0IGNvbnRyb2wgcG9pbnRzIFgtdmFsdWVzLlxuICAgICAgICB2YXIgeCA9IHRoaXMuZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cbiAgICAgICAgLy8gU2V0IHJpZ2h0IGhhbmQgc2lkZSBZIHZhbHVlcy5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHJoc1tpXSA9IDQgKiBrbm90c1tpXS55ICsgMiAqIGtub3RzW2kgKyAxXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmhzWzBdID0ga25vdHNbMF0ueSArIDIgKiBrbm90c1sxXS55O1xuICAgICAgICByaHNbbiAtIDFdID0gKDggKiBrbm90c1tuIC0gMV0ueSArIGtub3RzW25dLnkpIC8gMi4wO1xuXG4gICAgICAgIC8vIEdldCBmaXJzdCBjb250cm9sIHBvaW50cyBZLXZhbHVlcy5cbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG4gICAgICAgIC8vIEZpbGwgb3V0cHV0IGFycmF5cy5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgY29udHJvbCBwb2ludC5cbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludCh4W2ldLCB5W2ldKSk7XG5cbiAgICAgICAgICAgIC8vIFNlY29uZCBjb250cm9sIHBvaW50LlxuICAgICAgICAgICAgaWYgKGkgPCBuIC0gMSkge1xuICAgICAgICAgICAgICAgIHNlY29uZENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIDIgKiBrbm90cyBbaSArIDFdLnggLSB4W2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgMiAqIGtub3RzW2kgKyAxXS55IC0geVtpICsgMV1cbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWNvbmRDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICAgICAoa25vdHNbbl0ueCArIHhbbiAtIDFdKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIChrbm90c1tuXS55ICsgeVtuIC0gMV0pIC8gMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtmaXJzdENvbnRyb2xQb2ludHMsIHNlY29uZENvbnRyb2xQb2ludHNdO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGUgYSBCZXppZXIgY3VydmUgaW50byB0d28gYXQgcG9pbnQgZGVmaW5lZCBieSB2YWx1ZSAndCcgPDAsMT4uXG4gICAgLy8gVXNpbmcgZGVDYXN0ZWxqYXUgYWxnb3JpdGhtLiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9hLzMxNzg2N1xuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgLy8gQHBhcmFtIGNvbnRyb2wgcG9pbnRzIChzdGFydCwgY29udHJvbCBzdGFydCwgY29udHJvbCBlbmQsIGVuZClcbiAgICAvLyBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHQgYW5kIHJldHVybnMgMiBjdXJ2ZXMuXG4gICAgZ2V0Q3VydmVEaXZpZGVyOiBmdW5jdGlvbihwMCwgcDEsIHAyLCBwMykge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZCcpO1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZShwMCwgcDEsIHAyLCBwMyk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRpdmlkZUN1cnZlKHQpIHtcblxuICAgICAgICAgICAgdmFyIGRpdmlkZWQgPSBjdXJ2ZS5kaXZpZGUodCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHAwOiBkaXZpZGVkWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICAgIHAxOiBkaXZpZGVkWzBdLmNvbnRyb2xQb2ludDEsXG4gICAgICAgICAgICAgICAgcDI6IGRpdmlkZWRbMF0uY29udHJvbFBvaW50MixcbiAgICAgICAgICAgICAgICBwMzogZGl2aWRlZFswXS5lbmRcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBwMDogZGl2aWRlZFsxXS5zdGFydCxcbiAgICAgICAgICAgICAgICBwMTogZGl2aWRlZFsxXS5jb250cm9sUG9pbnQxLFxuICAgICAgICAgICAgICAgIHAyOiBkaXZpZGVkWzFdLmNvbnRyb2xQb2ludDIsXG4gICAgICAgICAgICAgICAgcDM6IGRpdmlkZWRbMV0uZW5kXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gU29sdmVzIGEgdHJpZGlhZ29uYWwgc3lzdGVtIGZvciBvbmUgb2YgY29vcmRpbmF0ZXMgKHggb3IgeSkgb2YgZmlyc3QgQmV6aWVyIGNvbnRyb2wgcG9pbnRzLlxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgLy8gQHBhcmFtIHJocyBSaWdodCBoYW5kIHNpZGUgdmVjdG9yLlxuICAgIC8vIEByZXR1cm4gU29sdXRpb24gdmVjdG9yLlxuICAgIGdldEZpcnN0Q29udHJvbFBvaW50czogZnVuY3Rpb24ocmhzKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCdkZXByZWNhdGVkJyk7XG5cbiAgICAgICAgdmFyIG4gPSByaHMubGVuZ3RoO1xuICAgICAgICAvLyBgeGAgaXMgYSBzb2x1dGlvbiB2ZWN0b3IuXG4gICAgICAgIHZhciB4ID0gW107XG4gICAgICAgIHZhciB0bXAgPSBbXTtcbiAgICAgICAgdmFyIGIgPSAyLjA7XG5cbiAgICAgICAgeFswXSA9IHJoc1swXSAvIGI7XG5cbiAgICAgICAgLy8gRGVjb21wb3NpdGlvbiBhbmQgZm9yd2FyZCBzdWJzdGl0dXRpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSAxIC8gYjtcbiAgICAgICAgICAgIGIgPSAoaSA8IG4gLSAxID8gNC4wIDogMy41KSAtIHRtcFtpXTtcbiAgICAgICAgICAgIHhbaV0gPSAocmhzW2ldIC0geFtpIC0gMV0pIC8gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEJhY2tzdWJzdGl0dXRpb24uXG4gICAgICAgICAgICB4W24gLSBpIC0gMV0gLT0gdG1wW24gLSBpXSAqIHhbbiAtIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgIC8vIFNvbHZlcyBhbiBpbnZlcnNpb24gcHJvYmxlbSAtLSBHaXZlbiB0aGUgKHgsIHkpIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgd2hpY2ggbGllcyBvblxuICAgIC8vIGEgcGFyYW1ldHJpYyBjdXJ2ZSB4ID0geCh0KS93KHQpLCB5ID0geSh0KS93KHQpLCDvrIFuZCB0aGUgcGFyYW1ldGVyIHZhbHVlIHRcbiAgICAvLyB3aGljaCBjb3JyZXNwb25kcyB0byB0aGF0IHBvaW50LlxuICAgIC8vIEBkZXByZWNhdGVkXG4gICAgLy8gQHBhcmFtIGNvbnRyb2wgcG9pbnRzIChzdGFydCwgY29udHJvbCBzdGFydCwgY29udHJvbCBlbmQsIGVuZClcbiAgICAvLyBAcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgcG9pbnQgYW5kIHJldHVybnMgdC5cbiAgICBnZXRJbnZlcnNpb25Tb2x2ZXI6IGZ1bmN0aW9uKHAwLCBwMSwgcDIsIHAzKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCdkZXByZWNhdGVkJyk7XG5cbiAgICAgICAgdmFyIGN1cnZlID0gbmV3IEN1cnZlKHAwLCBwMSwgcDIsIHAzKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc29sdmVJbnZlcnNpb24ocCkge1xuXG4gICAgICAgICAgICByZXR1cm4gY3VydmUuY2xvc2VzdFBvaW50VChwKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/bezier.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/curve.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Curve: function() { return /* binding */ Curve; }\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./polyline.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\n\nconst {\n    abs,\n    sqrt,\n    min,\n    max,\n    pow\n} = Math;\n\nconst Curve = function(p1, p2, p3, p4) {\n\n    if (!(this instanceof Curve)) {\n        return new Curve(p1, p2, p3, p4);\n    }\n\n    if (p1 instanceof Curve) {\n        return new Curve(p1.start, p1.controlPoint1, p1.controlPoint2, p1.end);\n    }\n\n    this.start = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1);\n    this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2);\n    this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p3);\n    this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p4);\n};\n\n// Curve passing through points.\n// Ported from C# implementation by Oleg V. Polikarpotchkin and Peter Lee (http://www.codeproject.com/KB/graphics/BezierSpline.aspx).\n// @param {array} points Array of points through which the smooth line will go.\n// @return {array} curves.\nCurve.throughPoints = (function() {\n\n    // Get open-ended Bezier Spline Control Points.\n    // @param knots Input Knot Bezier spline points (At least two points!).\n    // @param firstControlPoints Output First Control points. Array of knots.length - 1 length.\n    // @param secondControlPoints Output Second Control points. Array of knots.length - 1 length.\n    function getCurveControlPoints(knots) {\n\n        var firstControlPoints = [];\n        var secondControlPoints = [];\n        var n = knots.length - 1;\n        var i;\n\n        // Special case: Bezier curve should be a straight line.\n        if (n == 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                (2 * knots[0].x + knots[1].x) / 3,\n                (2 * knots[0].y + knots[1].y) / 3\n            );\n\n            // P2 = 2P1  P0\n            secondControlPoints[0] = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                2 * firstControlPoints[0].x - knots[0].x,\n                2 * firstControlPoints[0].y - knots[0].y\n            );\n\n            return [firstControlPoints, secondControlPoints];\n        }\n\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        var rhs = [];\n\n        // Set right hand side X values.\n        for (i = 1; i < n - 1; i++) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n\n        // Get first control points X-values.\n        var x = getFirstControlPoints(rhs);\n\n        // Set right hand side Y values.\n        for (i = 1; i < n - 1; ++i) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n\n        // Get first control points Y-values.\n        var y = getFirstControlPoints(rhs);\n\n        // Fill output arrays.\n        for (i = 0; i < n; i++) {\n            // First control point.\n            firstControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x[i], y[i]));\n\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                    2 * knots [i + 1].x - x[i + 1],\n                    2 * knots[i + 1].y - y[i + 1]\n                ));\n\n            } else {\n                secondControlPoints.push(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n                    (knots[n].x + x[n - 1]) / 2,\n                    (knots[n].y + y[n - 1]) / 2\n                ));\n            }\n        }\n\n        return [firstControlPoints, secondControlPoints];\n    }\n\n    // Solves a tridiagonal system for one of coordinates (x or y) of first Bezier control points.\n    // @param rhs Right hand side vector.\n    // @return Solution vector.\n    function getFirstControlPoints(rhs) {\n\n        var n = rhs.length;\n        // `x` is a solution vector.\n        var x = [];\n        var tmp = [];\n        var b = 2.0;\n\n        x[0] = rhs[0] / b;\n\n        // Decomposition and forward substitution.\n        for (var i = 1; i < n; i++) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n\n        for (i = 1; i < n; i++) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n\n        return x;\n    }\n\n    return function(points) {\n\n        if (!points || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n\n        var controlPoints = getCurveControlPoints(points);\n\n        var curves = [];\n        var n = controlPoints[0].length;\n        for (var i = 0; i < n; i++) {\n\n            var controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            var controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(controlPoints[1][i].x, controlPoints[1][i].y);\n\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n\n        return curves;\n    };\n})();\n\nCurve.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Curve,\n\n    // Returns a bbox that tightly envelops the curve.\n    bbox: function() {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        var x0 = start.x;\n        var y0 = start.y;\n        var x1 = controlPoint1.x;\n        var y1 = controlPoint1.y;\n        var x2 = controlPoint2.x;\n        var y2 = controlPoint2.y;\n        var x3 = end.x;\n        var y3 = end.y;\n\n        var points = new Array(); // local extremes\n        var tvalues = new Array(); // t values of local extremes\n        var bounds = [new Array(), new Array()];\n\n        var a, b, c, t;\n        var t1, t2;\n        var b2ac, sqrtb2ac;\n\n        for (var i = 0; i < 2; ++i) {\n\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n\n            if (abs(a) < 1e-12) { // Numerical robustness\n                if (abs(b) < 1e-12) { // Numerical robustness\n                    continue;\n                }\n\n                t = -c / b;\n                if ((0 < t) && (t < 1)) tvalues.push(t);\n\n                continue;\n            }\n\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = sqrt(b2ac);\n\n            if (b2ac < 0) continue;\n\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if ((0 < t1) && (t1 < 1)) tvalues.push(t1);\n\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if ((0 < t2) && (t2 < 1)) tvalues.push(t2);\n        }\n\n        var j = tvalues.length;\n        var jlen = j;\n        var mt;\n        var x, y;\n\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n\n            x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);\n            bounds[0][j] = x;\n\n            y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);\n            bounds[1][j] = y;\n\n            points[j] = { X: x, Y: y };\n        }\n\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n\n        var left = min.apply(null, bounds[0]);\n        var top = min.apply(null, bounds[1]);\n        var right = max.apply(null, bounds[0]);\n        var bottom = max.apply(null, bounds[1]);\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(left, top, (right - left), (bottom - top));\n    },\n\n    clone: function() {\n\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    // Returns the point on the curve closest to point `p`\n    closestPoint: function(p, opt) {\n\n        return this.pointAtT(this.closestPointT(p, opt));\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        return this.lengthAtT(this.closestPointT(p, localOpt), localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (!cpLength) return 0;\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0;\n\n        return cpLength / length;\n    },\n\n    // Returns `t` of the point on the curve closest to point `p`\n    closestPointT: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // does not use localOpt\n\n        // identify the subdivision that contains the point:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        var distFromStart; // distance of point from start of baseline\n        var distFromEnd; // distance of point from end of baseline\n        var chordLength; // distance between start and end of the subdivision\n        var minSumDist; // lowest observed sum of the two distances\n        var n = subdivisions.length;\n        var subdivisionSize = (n ? (1 / n) : 0);\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n\n            var startDist = currentSubdivision.start.distance(p);\n            var endDist = currentSubdivision.end.distance(p);\n            var sumDist = startDist + endDist;\n\n            // check that the point is closest to current subdivision and not any other\n            if (!minSumDist || (sumDist < minSumDist)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = i * subdivisionSize;\n                investigatedSubdivisionEndT = (i + 1) * subdivisionSize;\n\n                distFromStart = startDist;\n                distFromEnd = endDist;\n\n                chordLength = currentSubdivision.start.distance(currentSubdivision.end);\n\n                minSumDist = sumDist;\n            }\n        }\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            var startPrecisionRatio = (distFromStart ? (abs(distFromStart - distFromEnd) / distFromStart) : 0);\n            var endPrecisionRatio = (distFromEnd ? (abs(distFromStart - distFromEnd) / distFromEnd) : 0);\n            var hasRequiredPrecision = ((startPrecisionRatio < precisionRatio) || (endPrecisionRatio < precisionRatio));\n\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            var hasMinimalStartDistance = (distFromStart ? (distFromStart < (chordLength * precisionRatio)) : true);\n            var hasMinimalEndDistance = (distFromEnd ? (distFromEnd < (chordLength * precisionRatio)) : true);\n            var hasMinimalDistance = (hasMinimalStartDistance || hasMinimalEndDistance);\n\n            // do we stop now?\n            if (hasRequiredPrecision || hasMinimalDistance) {\n                return ((distFromStart <= distFromEnd) ? investigatedSubdivisionStartT : investigatedSubdivisionEndT);\n            }\n\n            // otherwise, set up for next iteration\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var startDist1 = divided[0].start.distance(p);\n            var endDist1 = divided[0].end.distance(p);\n            var sumDist1 = startDist1 + endDist1;\n\n            var startDist2 = divided[1].start.distance(p);\n            var endDist2 = divided[1].end.distance(p);\n            var sumDist2 = startDist2 + endDist2;\n\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n\n            } else {\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        return this.tangentAtT(this.closestPointT(p, opt));\n    },\n\n    // Returns `true` if the area surrounded by the curve contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open curves (always imagines a closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polyline = this.toPolyline(opt);\n        return polyline.containsPoint(p);\n    },\n\n    // Divides the curve into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // For a function that uses `t`, use Curve.divideAtT().\n    divideAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.divideAtT(0);\n        if (ratio >= 1) return this.divideAtT(1);\n\n        var t = this.tAt(ratio, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.divideAtT(t);\n    },\n\n    // Divides the curve into two at point defined by `t` between 0 and 1.\n    // Using de Casteljau's algorithm (http://math.stackexchange.com/a/317867).\n    // Additional resource: https://pomax.github.io/bezierinfo/#decasteljau\n    divideAtT: function(t) {\n\n        var start = this.start;\n        var controlPoint1 = this.controlPoint1;\n        var controlPoint2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end)\n            ];\n        }\n\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end)\n            ];\n        }\n\n        var dividerPoints = this.getSkeletonPoints(t);\n\n        var startControl1 = dividerPoints.startControlPoint1;\n        var startControl2 = dividerPoints.startControlPoint2;\n        var divider = dividerPoints.divider;\n        var dividerControl1 = dividerPoints.dividerControlPoint1;\n        var dividerControl2 = dividerPoints.dividerControlPoint2;\n\n        // return array with two new curves\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end)\n        ];\n    },\n\n    // Returns the distance between the curve's start and end points.\n    endpointDistance: function() {\n\n        return this.start.distance(this.end);\n    },\n\n    // Checks whether two curves are exactly the same.\n    equals: function(c) {\n\n        return !!c &&\n            this.start.x === c.start.x &&\n            this.start.y === c.start.y &&\n            this.controlPoint1.x === c.controlPoint1.x &&\n            this.controlPoint1.y === c.controlPoint1.y &&\n            this.controlPoint2.x === c.controlPoint2.x &&\n            this.controlPoint2.y === c.controlPoint2.y &&\n            this.end.x === c.end.x &&\n            this.end.y === c.end.y;\n    },\n\n    // Returns five helper points necessary for curve division.\n    getSkeletonPoints: function(t) {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone()\n            };\n        }\n\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone()\n            };\n        }\n\n        var midpoint1 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(start, control1)).pointAt(t);\n        var midpoint2 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(control1, control2)).pointAt(t);\n        var midpoint3 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(control2, end)).pointAt(t);\n\n        var subControl1 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(midpoint1, midpoint2)).pointAt(t);\n        var subControl2 = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(midpoint2, midpoint3)).pointAt(t);\n\n        var divider = (new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(subControl1, subControl2)).pointAt(t);\n\n        var output = {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divider,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3\n        };\n\n        return output;\n    },\n\n    // Returns a list of curves whose flattened length is better than `opt.precision`.\n    // That is, observed difference in length between recursions is less than 10^(-3) = 0.001 = 0.1%\n    // (Observed difference is not real precision, but close enough as long as special cases are covered)\n    // As a rule of thumb, increasing `precision` by 1 requires 2 more iterations (= levels of division operations)\n    // - Precision 0 (endpointDistance) - 0 iterations => total of 2^0 - 1 = 0 operations (1 subdivision)\n    // - Precision 1 (<10% error) - 2 iterations => total of 2^2 - 1 = 3 operations (4 subdivisions)\n    // - Precision 2 (<1% error) - 4 iterations => total of 2^4 - 1 = 15 operations requires 4 division operations on all elements (15 operations total) (16 subdivisions)\n    // - Precision 3 (<0.1% error) - 6 iterations => total of 2^6 - 1 = 63 operations - acceptable when drawing (64 subdivisions)\n    // - Precision 4 (<0.01% error) - 8 iterations => total of 2^8 - 1 = 255 operations - high resolution, can be used to interpolate `t` (256 subdivisions)\n    // (Variation of 1 recursion worse or better is possible depending on the curve, doubling/halving the number of operations accordingly)\n    getSubdivisions: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        var subdivisions = [new Curve(start, control1, control2, end)];\n        if (precision === 0) return subdivisions;\n\n        // special case #1: point-like curves\n        // - no need to calculate subdivisions, they would all be identical\n        var isPoint = !this.isDifferentiable();\n        if (isPoint) return subdivisions;\n\n        var previousLength = this.endpointDistance();\n\n        var precisionRatio = pow(10, -precision);\n\n        // special case #2: sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // - not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // - (i.e. cubic curves cannot intersect the baseline more than once)\n        // - therefore starting from iteration = 2 ensures that subsequent iterations do not produce sampling with equal length\n        // - (unless it's a straight-line curve, see below)\n        var minIterations = 2; // = 2*1\n\n        // special case #3: straight-line curves have the same observed length in all iterations\n        // - this causes observed precision ratio to always be 0 (= lower than `precisionRatio`, which is our exit condition)\n        // - we enforce the expected number of iterations = 2 * precision\n        var isLine = ((control1.cross(start, end) === 0) && (control2.cross(start, end) === 0));\n        if (isLine) {\n            minIterations = (2 * precision);\n        }\n\n        // recursively divide curve at `t = 0.5`\n        // until we reach `minIterations`\n        // and until the difference between observed length at subsequent iterations is lower than `precision`\n        var iteration = 0;\n        while (true) {\n            iteration += 1;\n\n            // divide all subdivisions\n            var newSubdivisions = [];\n            var numSubdivisions = subdivisions.length;\n            for (var i = 0; i < numSubdivisions; i++) {\n\n                var currentSubdivision = subdivisions[i];\n                var divided = currentSubdivision.divide(0.5); // dividing at t = 0.5 (not at middle length!)\n                newSubdivisions.push(divided[0], divided[1]);\n            }\n\n            // measure new length\n            var length = 0;\n            var numNewSubdivisions = newSubdivisions.length;\n            for (var j = 0; j < numNewSubdivisions; j++) {\n\n                var currentNewSubdivision = newSubdivisions[j];\n                length += currentNewSubdivision.endpointDistance();\n            }\n\n            // check if we have reached minimum number of iterations\n            if (iteration >= minIterations) {\n\n                // check if we have reached required observed precision\n                var observedPrecisionRatio = ((length !== 0) ? ((length - previousLength) / length) : 0);\n                if (observedPrecisionRatio < precisionRatio) {\n                    return newSubdivisions;\n                }\n            }\n\n            // otherwise, set up for next iteration\n            subdivisions = newSubdivisions;\n            previousLength = length;\n        }\n    },\n\n    isDifferentiable: function() {\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    // Returns flattened length of the curve with precision better than `opt.precision`; or using `opt.subdivisions` provided.\n    length: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var length = 0;\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            length += currentSubdivision.endpointDistance();\n        }\n\n        return length;\n    },\n\n    // Returns distance along the curve up to `t` with precision better than requested `opt.precision`. (Not using `opt.subdivisions`.)\n    lengthAtT: function(t, opt) {\n\n        if (t <= 0) return 0;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.subdivisions\n        // not using localOpt\n\n        var subCurve = this.divide(t)[0];\n        var subCurveLength = subCurve.length({ precision: precision });\n\n        return subCurveLength;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Mirrors Line.pointAt() function.\n    // For a function that tracks `t`, use Curve.pointAtT().\n    pointAt: function(ratio, opt) {\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        var t = this.tAt(ratio, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns point at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    pointAtLength: function(length, opt) {\n\n        var t = this.tAtLength(length, opt);\n\n        return this.pointAtT(t);\n    },\n\n    // Returns the point at provided `t` between 0 and 1.\n    // `t` does not track distance along curve as it does in Line objects.\n    // Non-linear relationship, speeds up and slows down as curve warps!\n    // For linear length-based solution, use Curve.pointAt().\n    pointAtT: function(t) {\n\n        if (t <= 0) return this.start.clone();\n        if (t >= 1) return this.end.clone();\n\n        return this.getSkeletonPoints(t).divider;\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // Returns a tangent line at requested `ratio` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (ratio < 0) ratio = 0;\n        else if (ratio > 1) ratio = 1;\n\n        var t = this.tAt(ratio, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `length` with precision better than requested `opt.precision`; or using `opt.subdivisions` provided.\n    tangentAtLength: function(length, opt) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var t = this.tAtLength(length, opt);\n\n        return this.tangentAtT(t);\n    },\n\n    // Returns a tangent line at requested `t`.\n    tangentAtT: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        if (t < 0) t = 0;\n        else if (t > 1) t = 1;\n\n        var skeletonPoints = this.getSkeletonPoints(t);\n\n        var p1 = skeletonPoints.startControlPoint2;\n        var p2 = skeletonPoints.dividerControlPoint1;\n\n        var tangentStart = skeletonPoints.divider;\n\n        var tangentLine = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line(p1, p2);\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    // Returns `t` at requested `ratio` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    tAt: function(ratio, opt) {\n\n        if (ratio <= 0) return 0;\n        if (ratio >= 1) return 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        var curveLength = this.length(localOpt);\n        var length = curveLength * ratio;\n\n        return this.tAtLength(length, localOpt);\n    },\n\n    // Returns `t` at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    // Uses `precision` to approximate length within `precision` (always underestimates)\n    // Then uses a binary search to find the `t` of a subdivision endpoint that is close (within `precision`) to the `length`, if the curve was as long as approximated\n    // As a rule of thumb, increasing `precision` by 1 causes the algorithm to go 2^(precision - 1) deeper\n    // - Precision 0 (chooses one of the two endpoints) - 0 levels\n    // - Precision 1 (chooses one of 5 points, <10% error) - 1 level\n    // - Precision 2 (<1% error) - 3 levels\n    // - Precision 3 (<0.1% error) - 7 levels\n    // - Precision 4 (<0.01% error) - 15 levels\n    tAtLength: function(length, opt) {\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        var localOpt = { precision: precision, subdivisions: subdivisions };\n\n        // identify the subdivision that contains the point at requested `length`:\n        var investigatedSubdivision;\n        var investigatedSubdivisionStartT; // assume that subdivisions are evenly spaced\n        var investigatedSubdivisionEndT;\n        //var baseline; // straightened version of subdivision to investigate\n        //var baselinePoint; // point on the baseline that is the requested distance away from start\n        var baselinePointDistFromStart; // distance of baselinePoint from start of baseline\n        var baselinePointDistFromEnd; // distance of baselinePoint from end of baseline\n        var l = 0; // length so far\n        var n = subdivisions.length;\n        var subdivisionSize = 1 / n;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var currentSubdivision = subdivisions[i];\n            var d = currentSubdivision.endpointDistance(); // length of current subdivision\n\n            if (length <= (l + d)) {\n                investigatedSubdivision = currentSubdivision;\n\n                investigatedSubdivisionStartT = index * subdivisionSize;\n                investigatedSubdivisionEndT = (index + 1) * subdivisionSize;\n\n                baselinePointDistFromStart = (fromStart ? (length - l) : ((d + l) - length));\n                baselinePointDistFromEnd = (fromStart ? ((d + l) - length) : (length - l));\n\n                break;\n            }\n\n            l += d;\n        }\n\n        if (!investigatedSubdivision) return (fromStart ? 1 : 0); // length requested is out of range - return maximum t\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n        var curveLength = this.length(localOpt);\n\n        var precisionRatio = pow(10, -precision);\n\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        while (true) {\n\n            // check if we have reached required observed precision\n            var observedPrecisionRatio;\n\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromStart / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionStartT;\n            observedPrecisionRatio = ((curveLength !== 0) ? (baselinePointDistFromEnd / curveLength) : 0);\n            if (observedPrecisionRatio < precisionRatio) return investigatedSubdivisionEndT;\n\n            // otherwise, set up for next iteration\n            var newBaselinePointDistFromStart;\n            var newBaselinePointDistFromEnd;\n\n            var divided = investigatedSubdivision.divide(0.5);\n            subdivisionSize /= 2;\n\n            var baseline1Length = divided[0].endpointDistance();\n            var baseline2Length = divided[1].endpointDistance();\n\n            if (baselinePointDistFromStart <= baseline1Length) { // point at requested length is inside divided[0]\n                investigatedSubdivision = divided[0];\n\n                investigatedSubdivisionEndT -= subdivisionSize; // sudivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n\n            } else { // point at requested length is inside divided[1]\n                investigatedSubdivision = divided[1];\n\n                investigatedSubdivisionStartT += subdivisionSize; // subdivisionSize was already halved\n\n                newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n            }\n\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    },\n\n    // Returns an array of points that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPoints: function(opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSubdivisions() call\n        var subdivisions = (opt.subdivisions === undefined) ? this.getSubdivisions({ precision: precision }) : opt.subdivisions;\n        // not using localOpt\n\n        var points = [subdivisions[0].start.clone()];\n        var n = subdivisions.length;\n        for (var i = 0; i < n; i++) {\n\n            var currentSubdivision = subdivisions[i];\n            points.push(currentSubdivision.end.clone());\n        }\n\n        return points;\n    },\n\n    // Returns a polyline that represents the curve when flattened, up to `opt.precision`; or using `opt.subdivisions` provided.\n    // Flattened length is no more than 10^(-precision) away from real curve length.\n    toPolyline: function(opt) {\n\n        return new _polyline_mjs__WEBPACK_IMPORTED_MODULE_4__.Polyline(this.toPoints(opt));\n    },\n\n    toString: function() {\n\n        return this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nCurve.prototype.divide = Curve.prototype.divideAtT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9jdXJ2ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ0Y7QUFDQTtBQUNRO0FBQ047O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUs7O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsNkNBQUs7QUFDMUIsNkJBQTZCLDZDQUFLO0FBQ2xDLDZCQUE2Qiw2Q0FBSztBQUNsQyxtQkFBbUIsNkNBQUs7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkNBQUs7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLDZDQUFLO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHdDQUF3Qyw2Q0FBSzs7QUFFN0M7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBSztBQUNsRDtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLDZDQUE2Qyw2Q0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FB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QjtBQUNuQjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7O0FBRUE7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBaUU7QUFDakU7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjs7QUFFQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLG1HQUFtRztBQUNuRztBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGO0FBQ3hGLHFGQUFxRixzQkFBc0I7QUFDM0c7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixPQUFPOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMLDJGQUEyRjtBQUMzRjtBQUNBOztBQUVBLG1CQUFtQixtREFBUTtBQUMzQixLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvY3VydmUubWpzP2RlYjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi9yZWN0Lm1qcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi9saW5lLm1qcyc7XG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4vcG9seWxpbmUubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuXG5jb25zdCB7XG4gICAgYWJzLFxuICAgIHNxcnQsXG4gICAgbWluLFxuICAgIG1heCxcbiAgICBwb3dcbn0gPSBNYXRoO1xuXG5leHBvcnQgY29uc3QgQ3VydmUgPSBmdW5jdGlvbihwMSwgcDIsIHAzLCBwNCkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1cnZlKSkge1xuICAgICAgICByZXR1cm4gbmV3IEN1cnZlKHAxLCBwMiwgcDMsIHA0KTtcbiAgICB9XG5cbiAgICBpZiAocDEgaW5zdGFuY2VvZiBDdXJ2ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEN1cnZlKHAxLnN0YXJ0LCBwMS5jb250cm9sUG9pbnQxLCBwMS5jb250cm9sUG9pbnQyLCBwMS5lbmQpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9pbnQocDEpO1xuICAgIHRoaXMuY29udHJvbFBvaW50MSA9IG5ldyBQb2ludChwMik7XG4gICAgdGhpcy5jb250cm9sUG9pbnQyID0gbmV3IFBvaW50KHAzKTtcbiAgICB0aGlzLmVuZCA9IG5ldyBQb2ludChwNCk7XG59O1xuXG4vLyBDdXJ2ZSBwYXNzaW5nIHRocm91Z2ggcG9pbnRzLlxuLy8gUG9ydGVkIGZyb20gQyMgaW1wbGVtZW50YXRpb24gYnkgT2xlZyBWLiBQb2xpa2FycG90Y2hraW4gYW5kIFBldGVyIExlZSAoaHR0cDovL3d3dy5jb2RlcHJvamVjdC5jb20vS0IvZ3JhcGhpY3MvQmV6aWVyU3BsaW5lLmFzcHgpLlxuLy8gQHBhcmFtIHthcnJheX0gcG9pbnRzIEFycmF5IG9mIHBvaW50cyB0aHJvdWdoIHdoaWNoIHRoZSBzbW9vdGggbGluZSB3aWxsIGdvLlxuLy8gQHJldHVybiB7YXJyYXl9IGN1cnZlcy5cbkN1cnZlLnRocm91Z2hQb2ludHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBHZXQgb3Blbi1lbmRlZCBCZXppZXIgU3BsaW5lIENvbnRyb2wgUG9pbnRzLlxuICAgIC8vIEBwYXJhbSBrbm90cyBJbnB1dCBLbm90IEJlemllciBzcGxpbmUgcG9pbnRzIChBdCBsZWFzdCB0d28gcG9pbnRzISkuXG4gICAgLy8gQHBhcmFtIGZpcnN0Q29udHJvbFBvaW50cyBPdXRwdXQgRmlyc3QgQ29udHJvbCBwb2ludHMuIEFycmF5IG9mIGtub3RzLmxlbmd0aCAtIDEgbGVuZ3RoLlxuICAgIC8vIEBwYXJhbSBzZWNvbmRDb250cm9sUG9pbnRzIE91dHB1dCBTZWNvbmQgQ29udHJvbCBwb2ludHMuIEFycmF5IG9mIGtub3RzLmxlbmd0aCAtIDEgbGVuZ3RoLlxuICAgIGZ1bmN0aW9uIGdldEN1cnZlQ29udHJvbFBvaW50cyhrbm90cykge1xuXG4gICAgICAgIHZhciBmaXJzdENvbnRyb2xQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHNlY29uZENvbnRyb2xQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIG4gPSBrbm90cy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IEJlemllciBjdXJ2ZSBzaG91bGQgYmUgYSBzdHJhaWdodCBsaW5lLlxuICAgICAgICBpZiAobiA9PSAxKSB7XG4gICAgICAgICAgICAvLyAzUDEgPSAyUDAgKyBQM1xuICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzWzBdID0gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgICgyICoga25vdHNbMF0ueCArIGtub3RzWzFdLngpIC8gMyxcbiAgICAgICAgICAgICAgICAoMiAqIGtub3RzWzBdLnkgKyBrbm90c1sxXS55KSAvIDNcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIFAyID0gMlAxIOKAkyBQMFxuICAgICAgICAgICAgc2Vjb25kQ29udHJvbFBvaW50c1swXSA9IG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAyICogZmlyc3RDb250cm9sUG9pbnRzWzBdLnggLSBrbm90c1swXS54LFxuICAgICAgICAgICAgICAgIDIgKiBmaXJzdENvbnRyb2xQb2ludHNbMF0ueSAtIGtub3RzWzBdLnlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiBbZmlyc3RDb250cm9sUG9pbnRzLCBzZWNvbmRDb250cm9sUG9pbnRzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBmaXJzdCBCZXppZXIgY29udHJvbCBwb2ludHMuXG4gICAgICAgIC8vIFJpZ2h0IGhhbmQgc2lkZSB2ZWN0b3IuXG4gICAgICAgIHZhciByaHMgPSBbXTtcblxuICAgICAgICAvLyBTZXQgcmlnaHQgaGFuZCBzaWRlIFggdmFsdWVzLlxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICAgICAgcmhzW2ldID0gNCAqIGtub3RzW2ldLnggKyAyICoga25vdHNbaSArIDFdLng7XG4gICAgICAgIH1cblxuICAgICAgICByaHNbMF0gPSBrbm90c1swXS54ICsgMiAqIGtub3RzWzFdLng7XG4gICAgICAgIHJoc1tuIC0gMV0gPSAoOCAqIGtub3RzW24gLSAxXS54ICsga25vdHNbbl0ueCkgLyAyLjA7XG5cbiAgICAgICAgLy8gR2V0IGZpcnN0IGNvbnRyb2wgcG9pbnRzIFgtdmFsdWVzLlxuICAgICAgICB2YXIgeCA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG4gICAgICAgIC8vIFNldCByaWdodCBoYW5kIHNpZGUgWSB2YWx1ZXMuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSB7XG4gICAgICAgICAgICByaHNbaV0gPSA0ICoga25vdHNbaV0ueSArIDIgKiBrbm90c1tpICsgMV0ueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJoc1swXSA9IGtub3RzWzBdLnkgKyAyICoga25vdHNbMV0ueTtcbiAgICAgICAgcmhzW24gLSAxXSA9ICg4ICoga25vdHNbbiAtIDFdLnkgKyBrbm90c1tuXS55KSAvIDIuMDtcblxuICAgICAgICAvLyBHZXQgZmlyc3QgY29udHJvbCBwb2ludHMgWS12YWx1ZXMuXG4gICAgICAgIHZhciB5ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cbiAgICAgICAgLy8gRmlsbCBvdXRwdXQgYXJyYXlzLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBjb250cm9sIHBvaW50LlxuICAgICAgICAgICAgZmlyc3RDb250cm9sUG9pbnRzLnB1c2gobmV3IFBvaW50KHhbaV0sIHlbaV0pKTtcblxuICAgICAgICAgICAgLy8gU2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gICAgICAgICAgICBpZiAoaSA8IG4gLSAxKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kQ29udHJvbFBvaW50cy5wdXNoKG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICAgICAgMiAqIGtub3RzIFtpICsgMV0ueCAtIHhbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAyICoga25vdHNbaSArIDFdLnkgLSB5W2kgKyAxXVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlY29uZENvbnRyb2xQb2ludHMucHVzaChuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIChrbm90c1tuXS54ICsgeFtuIC0gMV0pIC8gMixcbiAgICAgICAgICAgICAgICAgICAgKGtub3RzW25dLnkgKyB5W24gLSAxXSkgLyAyXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2ZpcnN0Q29udHJvbFBvaW50cywgc2Vjb25kQ29udHJvbFBvaW50c107XG4gICAgfVxuXG4gICAgLy8gU29sdmVzIGEgdHJpZGlhZ29uYWwgc3lzdGVtIGZvciBvbmUgb2YgY29vcmRpbmF0ZXMgKHggb3IgeSkgb2YgZmlyc3QgQmV6aWVyIGNvbnRyb2wgcG9pbnRzLlxuICAgIC8vIEBwYXJhbSByaHMgUmlnaHQgaGFuZCBzaWRlIHZlY3Rvci5cbiAgICAvLyBAcmV0dXJuIFNvbHV0aW9uIHZlY3Rvci5cbiAgICBmdW5jdGlvbiBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKSB7XG5cbiAgICAgICAgdmFyIG4gPSByaHMubGVuZ3RoO1xuICAgICAgICAvLyBgeGAgaXMgYSBzb2x1dGlvbiB2ZWN0b3IuXG4gICAgICAgIHZhciB4ID0gW107XG4gICAgICAgIHZhciB0bXAgPSBbXTtcbiAgICAgICAgdmFyIGIgPSAyLjA7XG5cbiAgICAgICAgeFswXSA9IHJoc1swXSAvIGI7XG5cbiAgICAgICAgLy8gRGVjb21wb3NpdGlvbiBhbmQgZm9yd2FyZCBzdWJzdGl0dXRpb24uXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSAxIC8gYjtcbiAgICAgICAgICAgIGIgPSAoaSA8IG4gLSAxID8gNC4wIDogMy41KSAtIHRtcFtpXTtcbiAgICAgICAgICAgIHhbaV0gPSAocmhzW2ldIC0geFtpIC0gMV0pIC8gYjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIC8vIEJhY2tzdWJzdGl0dXRpb24uXG4gICAgICAgICAgICB4W24gLSBpIC0gMV0gLT0gdG1wW24gLSBpXSAqIHhbbiAtIGldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBvaW50cykge1xuXG4gICAgICAgIGlmICghcG9pbnRzIHx8IChBcnJheS5pc0FycmF5KHBvaW50cykgJiYgcG9pbnRzLmxlbmd0aCA8IDIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0IGxlYXN0IDIgcG9pbnRzIGFyZSByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBnZXRDdXJ2ZUNvbnRyb2xQb2ludHMocG9pbnRzKTtcblxuICAgICAgICB2YXIgY3VydmVzID0gW107XG4gICAgICAgIHZhciBuID0gY29udHJvbFBvaW50c1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnQxID0gbmV3IFBvaW50KGNvbnRyb2xQb2ludHNbMF1baV0ueCwgY29udHJvbFBvaW50c1swXVtpXS55KTtcbiAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnQyID0gbmV3IFBvaW50KGNvbnRyb2xQb2ludHNbMV1baV0ueCwgY29udHJvbFBvaW50c1sxXVtpXS55KTtcblxuICAgICAgICAgICAgY3VydmVzLnB1c2gobmV3IEN1cnZlKHBvaW50c1tpXSwgY29udHJvbFBvaW50MSwgY29udHJvbFBvaW50MiwgcG9pbnRzW2kgKyAxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnZlcztcbiAgICB9O1xufSkoKTtcblxuQ3VydmUucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuQ3VydmUsXG5cbiAgICAvLyBSZXR1cm5zIGEgYmJveCB0aGF0IHRpZ2h0bHkgZW52ZWxvcHMgdGhlIGN1cnZlLlxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sUG9pbnQxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgY29udHJvbFBvaW50MiA9IHRoaXMuY29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHZhciB4MCA9IHN0YXJ0Lng7XG4gICAgICAgIHZhciB5MCA9IHN0YXJ0Lnk7XG4gICAgICAgIHZhciB4MSA9IGNvbnRyb2xQb2ludDEueDtcbiAgICAgICAgdmFyIHkxID0gY29udHJvbFBvaW50MS55O1xuICAgICAgICB2YXIgeDIgPSBjb250cm9sUG9pbnQyLng7XG4gICAgICAgIHZhciB5MiA9IGNvbnRyb2xQb2ludDIueTtcbiAgICAgICAgdmFyIHgzID0gZW5kLng7XG4gICAgICAgIHZhciB5MyA9IGVuZC55O1xuXG4gICAgICAgIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoKTsgLy8gbG9jYWwgZXh0cmVtZXNcbiAgICAgICAgdmFyIHR2YWx1ZXMgPSBuZXcgQXJyYXkoKTsgLy8gdCB2YWx1ZXMgb2YgbG9jYWwgZXh0cmVtZXNcbiAgICAgICAgdmFyIGJvdW5kcyA9IFtuZXcgQXJyYXkoKSwgbmV3IEFycmF5KCldO1xuXG4gICAgICAgIHZhciBhLCBiLCBjLCB0O1xuICAgICAgICB2YXIgdDEsIHQyO1xuICAgICAgICB2YXIgYjJhYywgc3FydGIyYWM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcblxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgICAgICAgICAgICBhID0gLTMgKiB4MCArIDkgKiB4MSAtIDkgKiB4MiArIDMgKiB4MztcbiAgICAgICAgICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSA2ICogeTAgLSAxMiAqIHkxICsgNiAqIHkyO1xuICAgICAgICAgICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICAgICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhYnMoYSkgPCAxZS0xMikgeyAvLyBOdW1lcmljYWwgcm9idXN0bmVzc1xuICAgICAgICAgICAgICAgIGlmIChhYnMoYikgPCAxZS0xMikgeyAvLyBOdW1lcmljYWwgcm9idXN0bmVzc1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICAgICAgICAgIGlmICgoMCA8IHQpICYmICh0IDwgMSkpIHR2YWx1ZXMucHVzaCh0KTtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XG4gICAgICAgICAgICBzcXJ0YjJhYyA9IHNxcnQoYjJhYyk7XG5cbiAgICAgICAgICAgIGlmIChiMmFjIDwgMCkgY29udGludWU7XG5cbiAgICAgICAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIGlmICgoMCA8IHQxKSAmJiAodDEgPCAxKSkgdHZhbHVlcy5wdXNoKHQxKTtcblxuICAgICAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICAgICAgaWYgKCgwIDwgdDIpICYmICh0MiA8IDEpKSB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGogPSB0dmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGpsZW4gPSBqO1xuICAgICAgICB2YXIgbXQ7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIHQgPSB0dmFsdWVzW2pdO1xuICAgICAgICAgICAgbXQgPSAxIC0gdDtcblxuICAgICAgICAgICAgeCA9IChtdCAqIG10ICogbXQgKiB4MCkgKyAoMyAqIG10ICogbXQgKiB0ICogeDEpICsgKDMgKiBtdCAqIHQgKiB0ICogeDIpICsgKHQgKiB0ICogdCAqIHgzKTtcbiAgICAgICAgICAgIGJvdW5kc1swXVtqXSA9IHg7XG5cbiAgICAgICAgICAgIHkgPSAobXQgKiBtdCAqIG10ICogeTApICsgKDMgKiBtdCAqIG10ICogdCAqIHkxKSArICgzICogbXQgKiB0ICogdCAqIHkyKSArICh0ICogdCAqIHQgKiB5Myk7XG4gICAgICAgICAgICBib3VuZHNbMV1bal0gPSB5O1xuXG4gICAgICAgICAgICBwb2ludHNbal0gPSB7IFg6IHgsIFk6IHkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR2YWx1ZXNbamxlbl0gPSAwO1xuICAgICAgICB0dmFsdWVzW2psZW4gKyAxXSA9IDE7XG5cbiAgICAgICAgcG9pbnRzW2psZW5dID0geyBYOiB4MCwgWTogeTAgfTtcbiAgICAgICAgcG9pbnRzW2psZW4gKyAxXSA9IHsgWDogeDMsIFk6IHkzIH07XG5cbiAgICAgICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgICAgIGJvdW5kc1sxXVtqbGVuXSA9IHkwO1xuXG4gICAgICAgIGJvdW5kc1swXVtqbGVuICsgMV0gPSB4MztcbiAgICAgICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuXG4gICAgICAgIHR2YWx1ZXMubGVuZ3RoID0gamxlbiArIDI7XG4gICAgICAgIGJvdW5kc1swXS5sZW5ndGggPSBqbGVuICsgMjtcbiAgICAgICAgYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuICAgICAgICBwb2ludHMubGVuZ3RoID0gamxlbiArIDI7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBtaW4uYXBwbHkobnVsbCwgYm91bmRzWzBdKTtcbiAgICAgICAgdmFyIHRvcCA9IG1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pO1xuICAgICAgICB2YXIgcmlnaHQgPSBtYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKTtcbiAgICAgICAgdmFyIGJvdHRvbSA9IG1heC5hcHBseShudWxsLCBib3VuZHNbMV0pO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdChsZWZ0LCB0b3AsIChyaWdodCAtIGxlZnQpLCAoYm90dG9tIC0gdG9wKSk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IEN1cnZlKHRoaXMuc3RhcnQsIHRoaXMuY29udHJvbFBvaW50MSwgdGhpcy5jb250cm9sUG9pbnQyLCB0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBjdXJ2ZSBjbG9zZXN0IHRvIHBvaW50IGBwYFxuICAgIGNsb3Nlc3RQb2ludDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdFQodGhpcy5jbG9zZXN0UG9pbnRUKHAsIG9wdCkpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhBdFQodGhpcy5jbG9zZXN0UG9pbnRUKHAsIGxvY2FsT3B0KSwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCwgbG9jYWxPcHQpO1xuICAgICAgICBpZiAoIWNwTGVuZ3RoKSByZXR1cm4gMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMDtcblxuICAgICAgICByZXR1cm4gY3BMZW5ndGggLyBsZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRgIG9mIHRoZSBwb2ludCBvbiB0aGUgY3VydmUgY2xvc2VzdCB0byBwb2ludCBgcGBcbiAgICBjbG9zZXN0UG9pbnRUOiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIC8vIGRvZXMgbm90IHVzZSBsb2NhbE9wdFxuXG4gICAgICAgIC8vIGlkZW50aWZ5IHRoZSBzdWJkaXZpc2lvbiB0aGF0IGNvbnRhaW5zIHRoZSBwb2ludDpcbiAgICAgICAgdmFyIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uO1xuICAgICAgICB2YXIgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQ7IC8vIGFzc3VtZSB0aGF0IHN1YmRpdmlzaW9ucyBhcmUgZXZlbmx5IHNwYWNlZFxuICAgICAgICB2YXIgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUO1xuICAgICAgICB2YXIgZGlzdEZyb21TdGFydDsgLy8gZGlzdGFuY2Ugb2YgcG9pbnQgZnJvbSBzdGFydCBvZiBiYXNlbGluZVxuICAgICAgICB2YXIgZGlzdEZyb21FbmQ7IC8vIGRpc3RhbmNlIG9mIHBvaW50IGZyb20gZW5kIG9mIGJhc2VsaW5lXG4gICAgICAgIHZhciBjaG9yZExlbmd0aDsgLy8gZGlzdGFuY2UgYmV0d2VlbiBzdGFydCBhbmQgZW5kIG9mIHRoZSBzdWJkaXZpc2lvblxuICAgICAgICB2YXIgbWluU3VtRGlzdDsgLy8gbG93ZXN0IG9ic2VydmVkIHN1bSBvZiB0aGUgdHdvIGRpc3RhbmNlc1xuICAgICAgICB2YXIgbiA9IHN1YmRpdmlzaW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBzdWJkaXZpc2lvblNpemUgPSAobiA/ICgxIC8gbikgOiAwKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdWJkaXZpc2lvbiA9IHN1YmRpdmlzaW9uc1tpXTtcblxuICAgICAgICAgICAgdmFyIHN0YXJ0RGlzdCA9IGN1cnJlbnRTdWJkaXZpc2lvbi5zdGFydC5kaXN0YW5jZShwKTtcbiAgICAgICAgICAgIHZhciBlbmREaXN0ID0gY3VycmVudFN1YmRpdmlzaW9uLmVuZC5kaXN0YW5jZShwKTtcbiAgICAgICAgICAgIHZhciBzdW1EaXN0ID0gc3RhcnREaXN0ICsgZW5kRGlzdDtcblxuICAgICAgICAgICAgLy8gY2hlY2sgdGhhdCB0aGUgcG9pbnQgaXMgY2xvc2VzdCB0byBjdXJyZW50IHN1YmRpdmlzaW9uIGFuZCBub3QgYW55IG90aGVyXG4gICAgICAgICAgICBpZiAoIW1pblN1bURpc3QgfHwgKHN1bURpc3QgPCBtaW5TdW1EaXN0KSkge1xuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uID0gY3VycmVudFN1YmRpdmlzaW9uO1xuXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQgPSBpICogc3ViZGl2aXNpb25TaXplO1xuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uRW5kVCA9IChpICsgMSkgKiBzdWJkaXZpc2lvblNpemU7XG5cbiAgICAgICAgICAgICAgICBkaXN0RnJvbVN0YXJ0ID0gc3RhcnREaXN0O1xuICAgICAgICAgICAgICAgIGRpc3RGcm9tRW5kID0gZW5kRGlzdDtcblxuICAgICAgICAgICAgICAgIGNob3JkTGVuZ3RoID0gY3VycmVudFN1YmRpdmlzaW9uLnN0YXJ0LmRpc3RhbmNlKGN1cnJlbnRTdWJkaXZpc2lvbi5lbmQpO1xuXG4gICAgICAgICAgICAgICAgbWluU3VtRGlzdCA9IHN1bURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlY2lzaW9uUmF0aW8gPSBwb3coMTAsIC1wcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGRpdmlkZSBpbnZlc3RpZ2F0ZWQgc3ViZGl2aXNpb246XG4gICAgICAgIC8vIHVudGlsIGRpc3RhbmNlIGJldHdlZW4gYmFzZWxpbmVQb2ludCBhbmQgY2xvc2VzdCBwYXRoIGVuZHBvaW50IGlzIHdpdGhpbiAxMF4oLXByZWNpc2lvbilcbiAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIGNsb3Nlc3QgZW5kcG9pbnQgb2YgdGhhdCBmaW5hbCBzdWJkaXZpc2lvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHJlYWNoZWQgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG9ic2VydmVkIHByZWNpc2lvblxuICAgICAgICAgICAgLy8gLSBjYWxjdWxhdGVkIGFzOiB0aGUgZGlmZmVyZW5jZSBpbiBkaXN0YW5jZXMgZnJvbSBwb2ludCB0byBzdGFydCBhbmQgZW5kIGRpdmlkZWQgYnkgdGhlIGRpc3RhbmNlXG4gICAgICAgICAgICAvLyAtIG5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBtb25vdG9uaWMgPSBpdCBkb2Vzbid0IGNvbnZlcmdlIHN0YWJseSBidXQgaGFzIFwidGVldGhcIlxuICAgICAgICAgICAgLy8gLSB0aGUgZnVuY3Rpb24gZGVjcmVhc2VzIHdoaWxlIG9uZSBvZiB0aGUgZW5kcG9pbnRzIGlzIGZpeGVkIGJ1dCBcImp1bXBzXCIgd2hlbmV2ZXIgd2Ugc3dpdGNoXG4gICAgICAgICAgICAvLyAtIHRoaXMgY3JpdGVyaW9uIHdvcmtzIHdlbGwgZm9yIHBvaW50cyBseWluZyBmYXIgYXdheSBmcm9tIHRoZSBjdXJ2ZVxuICAgICAgICAgICAgdmFyIHN0YXJ0UHJlY2lzaW9uUmF0aW8gPSAoZGlzdEZyb21TdGFydCA/IChhYnMoZGlzdEZyb21TdGFydCAtIGRpc3RGcm9tRW5kKSAvIGRpc3RGcm9tU3RhcnQpIDogMCk7XG4gICAgICAgICAgICB2YXIgZW5kUHJlY2lzaW9uUmF0aW8gPSAoZGlzdEZyb21FbmQgPyAoYWJzKGRpc3RGcm9tU3RhcnQgLSBkaXN0RnJvbUVuZCkgLyBkaXN0RnJvbUVuZCkgOiAwKTtcbiAgICAgICAgICAgIHZhciBoYXNSZXF1aXJlZFByZWNpc2lvbiA9ICgoc3RhcnRQcmVjaXNpb25SYXRpbyA8IHByZWNpc2lvblJhdGlvKSB8fCAoZW5kUHJlY2lzaW9uUmF0aW8gPCBwcmVjaXNpb25SYXRpbykpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHJlYWNoZWQgYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1pbmltYWwgZGlzdGFuY2VcbiAgICAgICAgICAgIC8vIC0gY2FsY3VsYXRlZCBhczogdGhlIHN1YmRpdmlzaW9uIGNob3JkIGxlbmd0aCBtdWx0aXBsaWVkIGJ5IHByZWNpc2lvblJhdGlvXG4gICAgICAgICAgICAvLyAtIGNhbGN1bGF0aW9uIGlzIHJlbGF0aXZlIHNvIGl0IHdpbGwgd29yayBmb3IgYXJiaXRyYXJpbHkgbGFyZ2Uvc21hbGwgY3VydmVzIGFuZCB0aGVpciBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgIC8vIC0gdGhpcyBpcyBhIGJhY2t1cCBjcml0ZXJpb24gdGhhdCB3b3JrcyB3ZWxsIGZvciBwb2ludHMgbHlpbmcgXCJhbG1vc3QgYXRcIiB0aGUgY3VydmVcbiAgICAgICAgICAgIHZhciBoYXNNaW5pbWFsU3RhcnREaXN0YW5jZSA9IChkaXN0RnJvbVN0YXJ0ID8gKGRpc3RGcm9tU3RhcnQgPCAoY2hvcmRMZW5ndGggKiBwcmVjaXNpb25SYXRpbykpIDogdHJ1ZSk7XG4gICAgICAgICAgICB2YXIgaGFzTWluaW1hbEVuZERpc3RhbmNlID0gKGRpc3RGcm9tRW5kID8gKGRpc3RGcm9tRW5kIDwgKGNob3JkTGVuZ3RoICogcHJlY2lzaW9uUmF0aW8pKSA6IHRydWUpO1xuICAgICAgICAgICAgdmFyIGhhc01pbmltYWxEaXN0YW5jZSA9IChoYXNNaW5pbWFsU3RhcnREaXN0YW5jZSB8fCBoYXNNaW5pbWFsRW5kRGlzdGFuY2UpO1xuXG4gICAgICAgICAgICAvLyBkbyB3ZSBzdG9wIG5vdz9cbiAgICAgICAgICAgIGlmIChoYXNSZXF1aXJlZFByZWNpc2lvbiB8fCBoYXNNaW5pbWFsRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChkaXN0RnJvbVN0YXJ0IDw9IGRpc3RGcm9tRW5kKSA/IGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUIDogaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBzZXQgdXAgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YXIgZGl2aWRlZCA9IGludmVzdGlnYXRlZFN1YmRpdmlzaW9uLmRpdmlkZSgwLjUpO1xuICAgICAgICAgICAgc3ViZGl2aXNpb25TaXplIC89IDI7XG5cbiAgICAgICAgICAgIHZhciBzdGFydERpc3QxID0gZGl2aWRlZFswXS5zdGFydC5kaXN0YW5jZShwKTtcbiAgICAgICAgICAgIHZhciBlbmREaXN0MSA9IGRpdmlkZWRbMF0uZW5kLmRpc3RhbmNlKHApO1xuICAgICAgICAgICAgdmFyIHN1bURpc3QxID0gc3RhcnREaXN0MSArIGVuZERpc3QxO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnREaXN0MiA9IGRpdmlkZWRbMV0uc3RhcnQuZGlzdGFuY2UocCk7XG4gICAgICAgICAgICB2YXIgZW5kRGlzdDIgPSBkaXZpZGVkWzFdLmVuZC5kaXN0YW5jZShwKTtcbiAgICAgICAgICAgIHZhciBzdW1EaXN0MiA9IHN0YXJ0RGlzdDIgKyBlbmREaXN0MjtcblxuICAgICAgICAgICAgaWYgKHN1bURpc3QxIDw9IHN1bURpc3QyKSB7XG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24gPSBkaXZpZGVkWzBdO1xuXG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUIC09IHN1YmRpdmlzaW9uU2l6ZTsgLy8gc3ViZGl2aXNpb25TaXplIHdhcyBhbHJlYWR5IGhhbHZlZFxuXG4gICAgICAgICAgICAgICAgZGlzdEZyb21TdGFydCA9IHN0YXJ0RGlzdDE7XG4gICAgICAgICAgICAgICAgZGlzdEZyb21FbmQgPSBlbmREaXN0MTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbiA9IGRpdmlkZWRbMV07XG5cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VCArPSBzdWJkaXZpc2lvblNpemU7IC8vIHN1YmRpdmlzaW9uU2l6ZSB3YXMgYWxyZWFkeSBoYWx2ZWRcblxuICAgICAgICAgICAgICAgIGRpc3RGcm9tU3RhcnQgPSBzdGFydERpc3QyO1xuICAgICAgICAgICAgICAgIGRpc3RGcm9tRW5kID0gZW5kRGlzdDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0VCh0aGlzLmNsb3Nlc3RQb2ludFQocCwgb3B0KSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmVhIHN1cnJvdW5kZWQgYnkgdGhlIGN1cnZlIGNvbnRhaW5zIHRoZSBwb2ludCBgcGAuXG4gICAgLy8gSW1wbGVtZW50cyB0aGUgZXZlbi1vZGQgYWxnb3JpdGhtIChzZWxmLWludGVyc2VjdGlvbnMgYXJlIFwib3V0c2lkZVwiKS5cbiAgICAvLyBDbG9zZXMgb3BlbiBjdXJ2ZXMgKGFsd2F5cyBpbWFnaW5lcyBhIGNsb3Npbmcgc2VnbWVudCkuXG4gICAgLy8gUHJlY2lzaW9uIG1heSBiZSBhZGp1c3RlZCBieSBwYXNzaW5nIGFuIGBvcHRgIG9iamVjdC5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLnRvUG9seWxpbmUob3B0KTtcbiAgICAgICAgcmV0dXJuIHBvbHlsaW5lLmNvbnRhaW5zUG9pbnQocCk7XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIGN1cnZlIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgcmF0aW9gIGJldHdlZW4gMCBhbmQgMSB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIEZvciBhIGZ1bmN0aW9uIHRoYXQgdXNlcyBgdGAsIHVzZSBDdXJ2ZS5kaXZpZGVBdFQoKS5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gdGhpcy5kaXZpZGVBdFQoMCk7XG4gICAgICAgIGlmIChyYXRpbyA+PSAxKSByZXR1cm4gdGhpcy5kaXZpZGVBdFQoMSk7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRBdChyYXRpbywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVBdFQodCk7XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIGN1cnZlIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgdCA9IHRoaXMudEF0TGVuZ3RoKGxlbmd0aCwgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXZpZGVBdFQodCk7XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIGN1cnZlIGludG8gdHdvIGF0IHBvaW50IGRlZmluZWQgYnkgYHRgIGJldHdlZW4gMCBhbmQgMS5cbiAgICAvLyBVc2luZyBkZSBDYXN0ZWxqYXUncyBhbGdvcml0aG0gKGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvMzE3ODY3KS5cbiAgICAvLyBBZGRpdGlvbmFsIHJlc291cmNlOiBodHRwczovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNkZWNhc3RlbGphdVxuICAgIGRpdmlkZUF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sUG9pbnQxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgY29udHJvbFBvaW50MiA9IHRoaXMuY29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIC8vIHNob3J0Y3V0cyBmb3IgYHRgIHZhbHVlcyB0aGF0IGFyZSBvdXQgb2YgcmFuZ2VcbiAgICAgICAgaWYgKHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBuZXcgQ3VydmUoc3RhcnQsIHN0YXJ0LCBzdGFydCwgc3RhcnQpLFxuICAgICAgICAgICAgICAgIG5ldyBDdXJ2ZShzdGFydCwgY29udHJvbFBvaW50MSwgY29udHJvbFBvaW50MiwgZW5kKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmV3IEN1cnZlKHN0YXJ0LCBjb250cm9sUG9pbnQxLCBjb250cm9sUG9pbnQyLCBlbmQpLFxuICAgICAgICAgICAgICAgIG5ldyBDdXJ2ZShlbmQsIGVuZCwgZW5kLCBlbmQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpdmlkZXJQb2ludHMgPSB0aGlzLmdldFNrZWxldG9uUG9pbnRzKHQpO1xuXG4gICAgICAgIHZhciBzdGFydENvbnRyb2wxID0gZGl2aWRlclBvaW50cy5zdGFydENvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBzdGFydENvbnRyb2wyID0gZGl2aWRlclBvaW50cy5zdGFydENvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBkaXZpZGVyID0gZGl2aWRlclBvaW50cy5kaXZpZGVyO1xuICAgICAgICB2YXIgZGl2aWRlckNvbnRyb2wxID0gZGl2aWRlclBvaW50cy5kaXZpZGVyQ29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGRpdmlkZXJDb250cm9sMiA9IGRpdmlkZXJQb2ludHMuZGl2aWRlckNvbnRyb2xQb2ludDI7XG5cbiAgICAgICAgLy8gcmV0dXJuIGFycmF5IHdpdGggdHdvIG5ldyBjdXJ2ZXNcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBDdXJ2ZShzdGFydCwgc3RhcnRDb250cm9sMSwgc3RhcnRDb250cm9sMiwgZGl2aWRlciksXG4gICAgICAgICAgICBuZXcgQ3VydmUoZGl2aWRlciwgZGl2aWRlckNvbnRyb2wxLCBkaXZpZGVyQ29udHJvbDIsIGVuZClcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgY3VydmUncyBzdGFydCBhbmQgZW5kIHBvaW50cy5cbiAgICBlbmRwb2ludERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZSh0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIHR3byBjdXJ2ZXMgYXJlIGV4YWN0bHkgdGhlIHNhbWUuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihjKSB7XG5cbiAgICAgICAgcmV0dXJuICEhYyAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydC54ID09PSBjLnN0YXJ0LnggJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnQueSA9PT0gYy5zdGFydC55ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEueCA9PT0gYy5jb250cm9sUG9pbnQxLnggJiZcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MS55ID09PSBjLmNvbnRyb2xQb2ludDEueSAmJlxuICAgICAgICAgICAgdGhpcy5jb250cm9sUG9pbnQyLnggPT09IGMuY29udHJvbFBvaW50Mi54ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIueSA9PT0gYy5jb250cm9sUG9pbnQyLnkgJiZcbiAgICAgICAgICAgIHRoaXMuZW5kLnggPT09IGMuZW5kLnggJiZcbiAgICAgICAgICAgIHRoaXMuZW5kLnkgPT09IGMuZW5kLnk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZml2ZSBoZWxwZXIgcG9pbnRzIG5lY2Vzc2FyeSBmb3IgY3VydmUgZGl2aXNpb24uXG4gICAgZ2V0U2tlbGV0b25Qb2ludHM6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgY29udHJvbDEgPSB0aGlzLmNvbnRyb2xQb2ludDE7XG4gICAgICAgIHZhciBjb250cm9sMiA9IHRoaXMuY29udHJvbFBvaW50MjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIC8vIHNob3J0Y3V0cyBmb3IgYHRgIHZhbHVlcyB0aGF0IGFyZSBvdXQgb2YgcmFuZ2VcbiAgICAgICAgaWYgKHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydENvbnRyb2xQb2ludDE6IHN0YXJ0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgc3RhcnRDb250cm9sUG9pbnQyOiBzdGFydC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGRpdmlkZXI6IHN0YXJ0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgZGl2aWRlckNvbnRyb2xQb2ludDE6IGNvbnRyb2wxLmNsb25lKCksXG4gICAgICAgICAgICAgICAgZGl2aWRlckNvbnRyb2xQb2ludDI6IGNvbnRyb2wyLmNsb25lKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0Q29udHJvbFBvaW50MTogY29udHJvbDEuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICBzdGFydENvbnRyb2xQb2ludDI6IGNvbnRyb2wyLmNsb25lKCksXG4gICAgICAgICAgICAgICAgZGl2aWRlcjogZW5kLmNsb25lKCksXG4gICAgICAgICAgICAgICAgZGl2aWRlckNvbnRyb2xQb2ludDE6IGVuZC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIGRpdmlkZXJDb250cm9sUG9pbnQyOiBlbmQuY2xvbmUoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaWRwb2ludDEgPSAobmV3IExpbmUoc3RhcnQsIGNvbnRyb2wxKSkucG9pbnRBdCh0KTtcbiAgICAgICAgdmFyIG1pZHBvaW50MiA9IChuZXcgTGluZShjb250cm9sMSwgY29udHJvbDIpKS5wb2ludEF0KHQpO1xuICAgICAgICB2YXIgbWlkcG9pbnQzID0gKG5ldyBMaW5lKGNvbnRyb2wyLCBlbmQpKS5wb2ludEF0KHQpO1xuXG4gICAgICAgIHZhciBzdWJDb250cm9sMSA9IChuZXcgTGluZShtaWRwb2ludDEsIG1pZHBvaW50MikpLnBvaW50QXQodCk7XG4gICAgICAgIHZhciBzdWJDb250cm9sMiA9IChuZXcgTGluZShtaWRwb2ludDIsIG1pZHBvaW50MykpLnBvaW50QXQodCk7XG5cbiAgICAgICAgdmFyIGRpdmlkZXIgPSAobmV3IExpbmUoc3ViQ29udHJvbDEsIHN1YkNvbnRyb2wyKSkucG9pbnRBdCh0KTtcblxuICAgICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICAgICAgc3RhcnRDb250cm9sUG9pbnQxOiBtaWRwb2ludDEsXG4gICAgICAgICAgICBzdGFydENvbnRyb2xQb2ludDI6IHN1YkNvbnRyb2wxLFxuICAgICAgICAgICAgZGl2aWRlcjogZGl2aWRlcixcbiAgICAgICAgICAgIGRpdmlkZXJDb250cm9sUG9pbnQxOiBzdWJDb250cm9sMixcbiAgICAgICAgICAgIGRpdmlkZXJDb250cm9sUG9pbnQyOiBtaWRwb2ludDNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBjdXJ2ZXMgd2hvc2UgZmxhdHRlbmVkIGxlbmd0aCBpcyBiZXR0ZXIgdGhhbiBgb3B0LnByZWNpc2lvbmAuXG4gICAgLy8gVGhhdCBpcywgb2JzZXJ2ZWQgZGlmZmVyZW5jZSBpbiBsZW5ndGggYmV0d2VlbiByZWN1cnNpb25zIGlzIGxlc3MgdGhhbiAxMF4oLTMpID0gMC4wMDEgPSAwLjElXG4gICAgLy8gKE9ic2VydmVkIGRpZmZlcmVuY2UgaXMgbm90IHJlYWwgcHJlY2lzaW9uLCBidXQgY2xvc2UgZW5vdWdoIGFzIGxvbmcgYXMgc3BlY2lhbCBjYXNlcyBhcmUgY292ZXJlZClcbiAgICAvLyBBcyBhIHJ1bGUgb2YgdGh1bWIsIGluY3JlYXNpbmcgYHByZWNpc2lvbmAgYnkgMSByZXF1aXJlcyAyIG1vcmUgaXRlcmF0aW9ucyAoPSBsZXZlbHMgb2YgZGl2aXNpb24gb3BlcmF0aW9ucylcbiAgICAvLyAtIFByZWNpc2lvbiAwIChlbmRwb2ludERpc3RhbmNlKSAtIDAgaXRlcmF0aW9ucyA9PiB0b3RhbCBvZiAyXjAgLSAxID0gMCBvcGVyYXRpb25zICgxIHN1YmRpdmlzaW9uKVxuICAgIC8vIC0gUHJlY2lzaW9uIDEgKDwxMCUgZXJyb3IpIC0gMiBpdGVyYXRpb25zID0+IHRvdGFsIG9mIDJeMiAtIDEgPSAzIG9wZXJhdGlvbnMgKDQgc3ViZGl2aXNpb25zKVxuICAgIC8vIC0gUHJlY2lzaW9uIDIgKDwxJSBlcnJvcikgLSA0IGl0ZXJhdGlvbnMgPT4gdG90YWwgb2YgMl40IC0gMSA9IDE1IG9wZXJhdGlvbnMgcmVxdWlyZXMgNCBkaXZpc2lvbiBvcGVyYXRpb25zIG9uIGFsbCBlbGVtZW50cyAoMTUgb3BlcmF0aW9ucyB0b3RhbCkgKDE2IHN1YmRpdmlzaW9ucylcbiAgICAvLyAtIFByZWNpc2lvbiAzICg8MC4xJSBlcnJvcikgLSA2IGl0ZXJhdGlvbnMgPT4gdG90YWwgb2YgMl42IC0gMSA9IDYzIG9wZXJhdGlvbnMgLSBhY2NlcHRhYmxlIHdoZW4gZHJhd2luZyAoNjQgc3ViZGl2aXNpb25zKVxuICAgIC8vIC0gUHJlY2lzaW9uIDQgKDwwLjAxJSBlcnJvcikgLSA4IGl0ZXJhdGlvbnMgPT4gdG90YWwgb2YgMl44IC0gMSA9IDI1NSBvcGVyYXRpb25zIC0gaGlnaCByZXNvbHV0aW9uLCBjYW4gYmUgdXNlZCB0byBpbnRlcnBvbGF0ZSBgdGAgKDI1NiBzdWJkaXZpc2lvbnMpXG4gICAgLy8gKFZhcmlhdGlvbiBvZiAxIHJlY3Vyc2lvbiB3b3JzZSBvciBiZXR0ZXIgaXMgcG9zc2libGUgZGVwZW5kaW5nIG9uIHRoZSBjdXJ2ZSwgZG91YmxpbmcvaGFsdmluZyB0aGUgbnVtYmVyIG9mIG9wZXJhdGlvbnMgYWNjb3JkaW5nbHkpXG4gICAgZ2V0U3ViZGl2aXNpb25zOiBmdW5jdGlvbihvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgLy8gbm90IHVzaW5nIG9wdC5zdWJkaXZpc2lvbnNcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGNvbnRyb2wxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgY29udHJvbDIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gW25ldyBDdXJ2ZShzdGFydCwgY29udHJvbDEsIGNvbnRyb2wyLCBlbmQpXTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gMCkgcmV0dXJuIHN1YmRpdmlzaW9ucztcblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgIzE6IHBvaW50LWxpa2UgY3VydmVzXG4gICAgICAgIC8vIC0gbm8gbmVlZCB0byBjYWxjdWxhdGUgc3ViZGl2aXNpb25zLCB0aGV5IHdvdWxkIGFsbCBiZSBpZGVudGljYWxcbiAgICAgICAgdmFyIGlzUG9pbnQgPSAhdGhpcy5pc0RpZmZlcmVudGlhYmxlKCk7XG4gICAgICAgIGlmIChpc1BvaW50KSByZXR1cm4gc3ViZGl2aXNpb25zO1xuXG4gICAgICAgIHZhciBwcmV2aW91c0xlbmd0aCA9IHRoaXMuZW5kcG9pbnREaXN0YW5jZSgpO1xuXG4gICAgICAgIHZhciBwcmVjaXNpb25SYXRpbyA9IHBvdygxMCwgLXByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlICMyOiBzaW5lLWxpa2UgY3VydmVzIG1heSBoYXZlIHRoZSBzYW1lIG9ic2VydmVkIGxlbmd0aCBpbiBpdGVyYXRpb24gMCBhbmQgMSAtIHNraXAgaXRlcmF0aW9uIDFcbiAgICAgICAgLy8gLSBub3QgYSBwcm9ibGVtIGZvciBmdXJ0aGVyIGl0ZXJhdGlvbnMgYmVjYXVzZSBjdWJpYyBjdXJ2ZXMgY2Fubm90IGhhdmUgbW9yZSB0aGFuIHR3byBsb2NhbCBleHRyZW1hXG4gICAgICAgIC8vIC0gKGkuZS4gY3ViaWMgY3VydmVzIGNhbm5vdCBpbnRlcnNlY3QgdGhlIGJhc2VsaW5lIG1vcmUgdGhhbiBvbmNlKVxuICAgICAgICAvLyAtIHRoZXJlZm9yZSBzdGFydGluZyBmcm9tIGl0ZXJhdGlvbiA9IDIgZW5zdXJlcyB0aGF0IHN1YnNlcXVlbnQgaXRlcmF0aW9ucyBkbyBub3QgcHJvZHVjZSBzYW1wbGluZyB3aXRoIGVxdWFsIGxlbmd0aFxuICAgICAgICAvLyAtICh1bmxlc3MgaXQncyBhIHN0cmFpZ2h0LWxpbmUgY3VydmUsIHNlZSBiZWxvdylcbiAgICAgICAgdmFyIG1pbkl0ZXJhdGlvbnMgPSAyOyAvLyA9IDIqMVxuXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSAjMzogc3RyYWlnaHQtbGluZSBjdXJ2ZXMgaGF2ZSB0aGUgc2FtZSBvYnNlcnZlZCBsZW5ndGggaW4gYWxsIGl0ZXJhdGlvbnNcbiAgICAgICAgLy8gLSB0aGlzIGNhdXNlcyBvYnNlcnZlZCBwcmVjaXNpb24gcmF0aW8gdG8gYWx3YXlzIGJlIDAgKD0gbG93ZXIgdGhhbiBgcHJlY2lzaW9uUmF0aW9gLCB3aGljaCBpcyBvdXIgZXhpdCBjb25kaXRpb24pXG4gICAgICAgIC8vIC0gd2UgZW5mb3JjZSB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgPSAyICogcHJlY2lzaW9uXG4gICAgICAgIHZhciBpc0xpbmUgPSAoKGNvbnRyb2wxLmNyb3NzKHN0YXJ0LCBlbmQpID09PSAwKSAmJiAoY29udHJvbDIuY3Jvc3Moc3RhcnQsIGVuZCkgPT09IDApKTtcbiAgICAgICAgaWYgKGlzTGluZSkge1xuICAgICAgICAgICAgbWluSXRlcmF0aW9ucyA9ICgyICogcHJlY2lzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGRpdmlkZSBjdXJ2ZSBhdCBgdCA9IDAuNWBcbiAgICAgICAgLy8gdW50aWwgd2UgcmVhY2ggYG1pbkl0ZXJhdGlvbnNgXG4gICAgICAgIC8vIGFuZCB1bnRpbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9ic2VydmVkIGxlbmd0aCBhdCBzdWJzZXF1ZW50IGl0ZXJhdGlvbnMgaXMgbG93ZXIgdGhhbiBgcHJlY2lzaW9uYFxuICAgICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiArPSAxO1xuXG4gICAgICAgICAgICAvLyBkaXZpZGUgYWxsIHN1YmRpdmlzaW9uc1xuICAgICAgICAgICAgdmFyIG5ld1N1YmRpdmlzaW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIG51bVN1YmRpdmlzaW9ucyA9IHN1YmRpdmlzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVN1YmRpdmlzaW9uczsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN1YmRpdmlzaW9uID0gc3ViZGl2aXNpb25zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkaXZpZGVkID0gY3VycmVudFN1YmRpdmlzaW9uLmRpdmlkZSgwLjUpOyAvLyBkaXZpZGluZyBhdCB0ID0gMC41IChub3QgYXQgbWlkZGxlIGxlbmd0aCEpXG4gICAgICAgICAgICAgICAgbmV3U3ViZGl2aXNpb25zLnB1c2goZGl2aWRlZFswXSwgZGl2aWRlZFsxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG1lYXN1cmUgbmV3IGxlbmd0aFxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgbnVtTmV3U3ViZGl2aXNpb25zID0gbmV3U3ViZGl2aXNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTmV3U3ViZGl2aXNpb25zOyBqKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TmV3U3ViZGl2aXNpb24gPSBuZXdTdWJkaXZpc2lvbnNbal07XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IGN1cnJlbnROZXdTdWJkaXZpc2lvbi5lbmRwb2ludERpc3RhbmNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCBtaW5pbXVtIG51bWJlciBvZiBpdGVyYXRpb25zXG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9uID49IG1pbkl0ZXJhdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhhdmUgcmVhY2hlZCByZXF1aXJlZCBvYnNlcnZlZCBwcmVjaXNpb25cbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZWRQcmVjaXNpb25SYXRpbyA9ICgobGVuZ3RoICE9PSAwKSA/ICgobGVuZ3RoIC0gcHJldmlvdXNMZW5ndGgpIC8gbGVuZ3RoKSA6IDApO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlZFByZWNpc2lvblJhdGlvIDwgcHJlY2lzaW9uUmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1N1YmRpdmlzaW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgc2V0IHVwIGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgc3ViZGl2aXNpb25zID0gbmV3U3ViZGl2aXNpb25zO1xuICAgICAgICAgICAgcHJldmlvdXNMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGNvbnRyb2wxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgY29udHJvbDIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICByZXR1cm4gIShzdGFydC5lcXVhbHMoY29udHJvbDEpICYmIGNvbnRyb2wxLmVxdWFscyhjb250cm9sMikgJiYgY29udHJvbDIuZXF1YWxzKGVuZCkpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGZsYXR0ZW5lZCBsZW5ndGggb2YgdGhlIGN1cnZlIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIGBvcHQucHJlY2lzaW9uYDsgb3IgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIGxlbmd0aDogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247IC8vIG9wdC5wcmVjaXNpb24gb25seSB1c2VkIGluIGdldFN1YmRpdmlzaW9ucygpIGNhbGxcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB2YXIgbiA9IHN1YmRpdmlzaW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50U3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbnNbaV07XG4gICAgICAgICAgICBsZW5ndGggKz0gY3VycmVudFN1YmRpdmlzaW9uLmVuZHBvaW50RGlzdGFuY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZGlzdGFuY2UgYWxvbmcgdGhlIGN1cnZlIHVwIHRvIGB0YCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gLiAoTm90IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYC4pXG4gICAgbGVuZ3RoQXRUOiBmdW5jdGlvbih0LCBvcHQpIHtcblxuICAgICAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgLy8gbm90IHVzaW5nIG9wdC5zdWJkaXZpc2lvbnNcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIHN1YkN1cnZlID0gdGhpcy5kaXZpZGUodClbMF07XG4gICAgICAgIHZhciBzdWJDdXJ2ZUxlbmd0aCA9IHN1YkN1cnZlLmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pO1xuXG4gICAgICAgIHJldHVybiBzdWJDdXJ2ZUxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBwb2ludCBhdCByZXF1ZXN0ZWQgYHJhdGlvYCBiZXR3ZWVuIDAgYW5kIDEgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBNaXJyb3JzIExpbmUucG9pbnRBdCgpIGZ1bmN0aW9uLlxuICAgIC8vIEZvciBhIGZ1bmN0aW9uIHRoYXQgdHJhY2tzIGB0YCwgdXNlIEN1cnZlLnBvaW50QXRUKCkuXG4gICAgcG9pbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBpZiAocmF0aW8gPj0gMSkgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRBdChyYXRpbywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0VCh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBwb2ludCBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgcG9pbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgdCA9IHRoaXMudEF0TGVuZ3RoKGxlbmd0aCwgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0VCh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcG9pbnQgYXQgcHJvdmlkZWQgYHRgIGJldHdlZW4gMCBhbmQgMS5cbiAgICAvLyBgdGAgZG9lcyBub3QgdHJhY2sgZGlzdGFuY2UgYWxvbmcgY3VydmUgYXMgaXQgZG9lcyBpbiBMaW5lIG9iamVjdHMuXG4gICAgLy8gTm9uLWxpbmVhciByZWxhdGlvbnNoaXAsIHNwZWVkcyB1cCBhbmQgc2xvd3MgZG93biBhcyBjdXJ2ZSB3YXJwcyFcbiAgICAvLyBGb3IgbGluZWFyIGxlbmd0aC1iYXNlZCBzb2x1dGlvbiwgdXNlIEN1cnZlLnBvaW50QXQoKS5cbiAgICBwb2ludEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0IDw9IDApIHJldHVybiB0aGlzLnN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGlmICh0ID49IDEpIHJldHVybiB0aGlzLmVuZC5jbG9uZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNrZWxldG9uUG9pbnRzKHQpLmRpdmlkZXI7XG4gICAgfSxcblxuICAgIC8vIERlZmF1bHQgcHJlY2lzaW9uXG4gICAgUFJFQ0lTSU9OOiAzLFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuc3RhcnQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5jb250cm9sUG9pbnQxLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLmVuZC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgb3JpZ2luKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuZW5kLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSB0YW5nZW50IGxpbmUgYXQgcmVxdWVzdGVkIGByYXRpb2Agd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3IgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIHRhbmdlbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0RpZmZlcmVudGlhYmxlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmIChyYXRpbyA8IDApIHJhdGlvID0gMDtcbiAgICAgICAgZWxzZSBpZiAocmF0aW8gPiAxKSByYXRpbyA9IDE7XG5cbiAgICAgICAgdmFyIHQgPSB0aGlzLnRBdChyYXRpbywgb3B0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy50YW5nZW50QXRUKHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgdGFuZ2VudCBsaW5lIGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvciB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgdGFuZ2VudEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0RpZmZlcmVudGlhYmxlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy50QXRMZW5ndGgobGVuZ3RoLCBvcHQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdFQodCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSB0YW5nZW50IGxpbmUgYXQgcmVxdWVzdGVkIGB0YC5cbiAgICB0YW5nZW50QXRUOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKHQgPCAwKSB0ID0gMDtcbiAgICAgICAgZWxzZSBpZiAodCA+IDEpIHQgPSAxO1xuXG4gICAgICAgIHZhciBza2VsZXRvblBvaW50cyA9IHRoaXMuZ2V0U2tlbGV0b25Qb2ludHModCk7XG5cbiAgICAgICAgdmFyIHAxID0gc2tlbGV0b25Qb2ludHMuc3RhcnRDb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgcDIgPSBza2VsZXRvblBvaW50cy5kaXZpZGVyQ29udHJvbFBvaW50MTtcblxuICAgICAgICB2YXIgdGFuZ2VudFN0YXJ0ID0gc2tlbGV0b25Qb2ludHMuZGl2aWRlcjtcblxuICAgICAgICB2YXIgdGFuZ2VudExpbmUgPSBuZXcgTGluZShwMSwgcDIpO1xuICAgICAgICB0YW5nZW50TGluZS50cmFuc2xhdGUodGFuZ2VudFN0YXJ0LnggLSBwMS54LCB0YW5nZW50U3RhcnQueSAtIHAxLnkpOyAvLyBtb3ZlIHNvIHRoYXQgdGFuZ2VudCBsaW5lIHN0YXJ0cyBhdCB0aGUgcG9pbnQgcmVxdWVzdGVkXG5cbiAgICAgICAgcmV0dXJuIHRhbmdlbnRMaW5lO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0YCBhdCByZXF1ZXN0ZWQgYHJhdGlvYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICB0QXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICBpZiAocmF0aW8gPD0gMCkgcmV0dXJuIDA7XG4gICAgICAgIGlmIChyYXRpbyA+PSAxKSByZXR1cm4gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIHZhciBsb2NhbE9wdCA9IHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIGN1cnZlTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY3VydmVMZW5ndGggKiByYXRpbztcblxuICAgICAgICByZXR1cm4gdGhpcy50QXRMZW5ndGgobGVuZ3RoLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRgIGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBVc2VzIGBwcmVjaXNpb25gIHRvIGFwcHJveGltYXRlIGxlbmd0aCB3aXRoaW4gYHByZWNpc2lvbmAgKGFsd2F5cyB1bmRlcmVzdGltYXRlcylcbiAgICAvLyBUaGVuIHVzZXMgYSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGB0YCBvZiBhIHN1YmRpdmlzaW9uIGVuZHBvaW50IHRoYXQgaXMgY2xvc2UgKHdpdGhpbiBgcHJlY2lzaW9uYCkgdG8gdGhlIGBsZW5ndGhgLCBpZiB0aGUgY3VydmUgd2FzIGFzIGxvbmcgYXMgYXBwcm94aW1hdGVkXG4gICAgLy8gQXMgYSBydWxlIG9mIHRodW1iLCBpbmNyZWFzaW5nIGBwcmVjaXNpb25gIGJ5IDEgY2F1c2VzIHRoZSBhbGdvcml0aG0gdG8gZ28gMl4ocHJlY2lzaW9uIC0gMSkgZGVlcGVyXG4gICAgLy8gLSBQcmVjaXNpb24gMCAoY2hvb3NlcyBvbmUgb2YgdGhlIHR3byBlbmRwb2ludHMpIC0gMCBsZXZlbHNcbiAgICAvLyAtIFByZWNpc2lvbiAxIChjaG9vc2VzIG9uZSBvZiA1IHBvaW50cywgPDEwJSBlcnJvcikgLSAxIGxldmVsXG4gICAgLy8gLSBQcmVjaXNpb24gMiAoPDElIGVycm9yKSAtIDMgbGV2ZWxzXG4gICAgLy8gLSBQcmVjaXNpb24gMyAoPDAuMSUgZXJyb3IpIC0gNyBsZXZlbHNcbiAgICAvLyAtIFByZWNpc2lvbiA0ICg8MC4wMSUgZXJyb3IpIC0gMTUgbGV2ZWxzXG4gICAgdEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciBmcm9tU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0ID0gZmFsc2U7IC8vIG5lZ2F0aXZlIGxlbmd0aHMgbWVhbiBzdGFydCBjYWxjdWxhdGlvbiBmcm9tIGVuZCBwb2ludFxuICAgICAgICAgICAgbGVuZ3RoID0gLWxlbmd0aDsgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gKG9wdC5zdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfTtcblxuICAgICAgICAvLyBpZGVudGlmeSB0aGUgc3ViZGl2aXNpb24gdGhhdCBjb250YWlucyB0aGUgcG9pbnQgYXQgcmVxdWVzdGVkIGBsZW5ndGhgOlxuICAgICAgICB2YXIgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb247XG4gICAgICAgIHZhciBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VDsgLy8gYXNzdW1lIHRoYXQgc3ViZGl2aXNpb25zIGFyZSBldmVubHkgc3BhY2VkXG4gICAgICAgIHZhciBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQ7XG4gICAgICAgIC8vdmFyIGJhc2VsaW5lOyAvLyBzdHJhaWdodGVuZWQgdmVyc2lvbiBvZiBzdWJkaXZpc2lvbiB0byBpbnZlc3RpZ2F0ZVxuICAgICAgICAvL3ZhciBiYXNlbGluZVBvaW50OyAvLyBwb2ludCBvbiB0aGUgYmFzZWxpbmUgdGhhdCBpcyB0aGUgcmVxdWVzdGVkIGRpc3RhbmNlIGF3YXkgZnJvbSBzdGFydFxuICAgICAgICB2YXIgYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQ7IC8vIGRpc3RhbmNlIG9mIGJhc2VsaW5lUG9pbnQgZnJvbSBzdGFydCBvZiBiYXNlbGluZVxuICAgICAgICB2YXIgYmFzZWxpbmVQb2ludERpc3RGcm9tRW5kOyAvLyBkaXN0YW5jZSBvZiBiYXNlbGluZVBvaW50IGZyb20gZW5kIG9mIGJhc2VsaW5lXG4gICAgICAgIHZhciBsID0gMDsgLy8gbGVuZ3RoIHNvIGZhclxuICAgICAgICB2YXIgbiA9IHN1YmRpdmlzaW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBzdWJkaXZpc2lvblNpemUgPSAxIC8gbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG4gLSAxIC0gaSkpO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFN1YmRpdmlzaW9uID0gc3ViZGl2aXNpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGQgPSBjdXJyZW50U3ViZGl2aXNpb24uZW5kcG9pbnREaXN0YW5jZSgpOyAvLyBsZW5ndGggb2YgY3VycmVudCBzdWJkaXZpc2lvblxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbiA9IGN1cnJlbnRTdWJkaXZpc2lvbjtcblxuICAgICAgICAgICAgICAgIGludmVzdGlnYXRlZFN1YmRpdmlzaW9uU3RhcnRUID0gaW5kZXggKiBzdWJkaXZpc2lvblNpemU7XG4gICAgICAgICAgICAgICAgaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUID0gKGluZGV4ICsgMSkgKiBzdWJkaXZpc2lvblNpemU7XG5cbiAgICAgICAgICAgICAgICBiYXNlbGluZVBvaW50RGlzdEZyb21TdGFydCA9IChmcm9tU3RhcnQgPyAobGVuZ3RoIC0gbCkgOiAoKGQgKyBsKSAtIGxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGJhc2VsaW5lUG9pbnREaXN0RnJvbUVuZCA9IChmcm9tU3RhcnQgPyAoKGQgKyBsKSAtIGxlbmd0aCkgOiAobGVuZ3RoIC0gbCkpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24pIHJldHVybiAoZnJvbVN0YXJ0ID8gMSA6IDApOyAvLyBsZW5ndGggcmVxdWVzdGVkIGlzIG91dCBvZiByYW5nZSAtIHJldHVybiBtYXhpbXVtIHRcbiAgICAgICAgLy8gbm90ZSB0aGF0IHByZWNpc2lvbiBhZmZlY3RzIHdoYXQgbGVuZ3RoIGlzIHJlY29yZGVkXG4gICAgICAgIC8vIChpbXByZWNpc2UgbWVhc3VyZW1lbnRzIHVuZGVyZXN0aW1hdGUgbGVuZ3RoIGJ5IHVwIHRvIDEwXigtcHJlY2lzaW9uKSBvZiB0aGUgcHJlY2lzZSBsZW5ndGgpXG4gICAgICAgIC8vIGUuZy4gYXQgcHJlY2lzaW9uIDEsIHRoZSBsZW5ndGggbWF5IGJlIHVuZGVyZXN0aW1hdGVkIGJ5IHVwIHRvIDEwJSBhbmQgY2F1c2UgdGhpcyBmdW5jdGlvbiB0byByZXR1cm4gMVxuXG4gICAgICAgIHZhciBjdXJ2ZUxlbmd0aCA9IHRoaXMubGVuZ3RoKGxvY2FsT3B0KTtcblxuICAgICAgICB2YXIgcHJlY2lzaW9uUmF0aW8gPSBwb3coMTAsIC1wcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGRpdmlkZSBpbnZlc3RpZ2F0ZWQgc3ViZGl2aXNpb246XG4gICAgICAgIC8vIHVudGlsIGRpc3RhbmNlIGJldHdlZW4gYmFzZWxpbmVQb2ludCBhbmQgY2xvc2VzdCBwYXRoIGVuZHBvaW50IGlzIHdpdGhpbiAxMF4oLXByZWNpc2lvbilcbiAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIGNsb3Nlc3QgZW5kcG9pbnQgb2YgdGhhdCBmaW5hbCBzdWJkaXZpc2lvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHJlYWNoZWQgcmVxdWlyZWQgb2JzZXJ2ZWQgcHJlY2lzaW9uXG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZWRQcmVjaXNpb25SYXRpbztcblxuICAgICAgICAgICAgb2JzZXJ2ZWRQcmVjaXNpb25SYXRpbyA9ICgoY3VydmVMZW5ndGggIT09IDApID8gKGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0IC8gY3VydmVMZW5ndGgpIDogMCk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWRQcmVjaXNpb25SYXRpbyA8IHByZWNpc2lvblJhdGlvKSByZXR1cm4gaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25TdGFydFQ7XG4gICAgICAgICAgICBvYnNlcnZlZFByZWNpc2lvblJhdGlvID0gKChjdXJ2ZUxlbmd0aCAhPT0gMCkgPyAoYmFzZWxpbmVQb2ludERpc3RGcm9tRW5kIC8gY3VydmVMZW5ndGgpIDogMCk7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWRQcmVjaXNpb25SYXRpbyA8IHByZWNpc2lvblJhdGlvKSByZXR1cm4gaW52ZXN0aWdhdGVkU3ViZGl2aXNpb25FbmRUO1xuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHNldCB1cCBmb3IgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIHZhciBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21TdGFydDtcbiAgICAgICAgICAgIHZhciBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21FbmQ7XG5cbiAgICAgICAgICAgIHZhciBkaXZpZGVkID0gaW52ZXN0aWdhdGVkU3ViZGl2aXNpb24uZGl2aWRlKDAuNSk7XG4gICAgICAgICAgICBzdWJkaXZpc2lvblNpemUgLz0gMjtcblxuICAgICAgICAgICAgdmFyIGJhc2VsaW5lMUxlbmd0aCA9IGRpdmlkZWRbMF0uZW5kcG9pbnREaXN0YW5jZSgpO1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lMkxlbmd0aCA9IGRpdmlkZWRbMV0uZW5kcG9pbnREaXN0YW5jZSgpO1xuXG4gICAgICAgICAgICBpZiAoYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgPD0gYmFzZWxpbmUxTGVuZ3RoKSB7IC8vIHBvaW50IGF0IHJlcXVlc3RlZCBsZW5ndGggaXMgaW5zaWRlIGRpdmlkZWRbMF1cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbiA9IGRpdmlkZWRbMF07XG5cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbkVuZFQgLT0gc3ViZGl2aXNpb25TaXplOyAvLyBzdWRpdmlzaW9uU2l6ZSB3YXMgYWxyZWFkeSBoYWx2ZWRcblxuICAgICAgICAgICAgICAgIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0ID0gYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQ7XG4gICAgICAgICAgICAgICAgbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tRW5kID0gYmFzZWxpbmUxTGVuZ3RoIC0gbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQ7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIHBvaW50IGF0IHJlcXVlc3RlZCBsZW5ndGggaXMgaW5zaWRlIGRpdmlkZWRbMV1cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvbiA9IGRpdmlkZWRbMV07XG5cbiAgICAgICAgICAgICAgICBpbnZlc3RpZ2F0ZWRTdWJkaXZpc2lvblN0YXJ0VCArPSBzdWJkaXZpc2lvblNpemU7IC8vIHN1YmRpdmlzaW9uU2l6ZSB3YXMgYWxyZWFkeSBoYWx2ZWRcblxuICAgICAgICAgICAgICAgIG5ld0Jhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0ID0gYmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQgLSBiYXNlbGluZTFMZW5ndGg7XG4gICAgICAgICAgICAgICAgbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tRW5kID0gYmFzZWxpbmUyTGVuZ3RoIC0gbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhc2VsaW5lUG9pbnREaXN0RnJvbVN0YXJ0ID0gbmV3QmFzZWxpbmVQb2ludERpc3RGcm9tU3RhcnQ7XG4gICAgICAgICAgICBiYXNlbGluZVBvaW50RGlzdEZyb21FbmQgPSBuZXdCYXNlbGluZVBvaW50RGlzdEZyb21FbmQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBwb2ludHMgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJ2ZSB3aGVuIGZsYXR0ZW5lZCwgdXAgdG8gYG9wdC5wcmVjaXNpb25gOyBvciB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gRmxhdHRlbmVkIGxlbmd0aCBpcyBubyBtb3JlIHRoYW4gMTBeKC1wcmVjaXNpb24pIGF3YXkgZnJvbSByZWFsIGN1cnZlIGxlbmd0aC5cbiAgICB0b1BvaW50czogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247IC8vIG9wdC5wcmVjaXNpb24gb25seSB1c2VkIGluIGdldFN1YmRpdmlzaW9ucygpIGNhbGxcbiAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IChvcHQuc3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zdWJkaXZpc2lvbnM7XG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBwb2ludHMgPSBbc3ViZGl2aXNpb25zWzBdLnN0YXJ0LmNsb25lKCldO1xuICAgICAgICB2YXIgbiA9IHN1YmRpdmlzaW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50U3ViZGl2aXNpb24gPSBzdWJkaXZpc2lvbnNbaV07XG4gICAgICAgICAgICBwb2ludHMucHVzaChjdXJyZW50U3ViZGl2aXNpb24uZW5kLmNsb25lKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHBvbHlsaW5lIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VydmUgd2hlbiBmbGF0dGVuZWQsIHVwIHRvIGBvcHQucHJlY2lzaW9uYDsgb3IgdXNpbmcgYG9wdC5zdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIC8vIEZsYXR0ZW5lZCBsZW5ndGggaXMgbm8gbW9yZSB0aGFuIDEwXigtcHJlY2lzaW9uKSBhd2F5IGZyb20gcmVhbCBjdXJ2ZSBsZW5ndGguXG4gICAgdG9Qb2x5bGluZTogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZSh0aGlzLnRvUG9pbnRzKG9wdCkpO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyAnICcgKyB0aGlzLmNvbnRyb2xQb2ludDEgKyAnICcgKyB0aGlzLmNvbnRyb2xQb2ludDIgKyAnICcgKyB0aGlzLmVuZDtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5lbmQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbkN1cnZlLnByb3RvdHlwZS5kaXZpZGUgPSBDdXJ2ZS5wcm90b3R5cGUuZGl2aWRlQXRUO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/g/ellipse.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ellipse: function() { return /* binding */ Ellipse; },\n/* harmony export */   ellipse: function() { return /* binding */ ellipse; }\n/* harmony export */ });\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\nconst {\n    sqrt,\n    round,\n    pow\n} = Math;\n\nconst Ellipse = function(c, a, b) {\n\n    if (!(this instanceof Ellipse)) {\n        return new Ellipse(c, a, b);\n    }\n\n    if (c instanceof Ellipse) {\n        return new Ellipse(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(c.x, c.y), c.a, c.b);\n    }\n\n    c = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(c);\n    this.x = c.x;\n    this.y = c.y;\n    this.a = a;\n    this.b = b;\n};\n\nEllipse.fromRect = function(rect) {\n\n    rect = new _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(rect);\n    return new Ellipse(rect.center(), rect.width / 2, rect.height / 2);\n};\n\nEllipse.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Ellipse,\n\n    bbox: function() {\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(this.x - this.a, this.y - this.b, 2 * this.a, 2 * this.b);\n    },\n\n    /**\n     * @returns {g.Point}\n     */\n    center: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y);\n    },\n\n    clone: function() {\n\n        return new Ellipse(this);\n    },\n\n    /**\n     * @param {g.Point} p\n     * @returns {boolean}\n     */\n    containsPoint: function(p) {\n\n        return this.normalizedDistance(p) <= 1;\n    },\n\n    equals: function(ellipse) {\n\n        return !!ellipse &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b;\n    },\n\n    // inflate by dx and dy\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.a += 2 * dx;\n        this.b += 2 * dy;\n\n        return this;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var intersections = [];\n        var a1 = line.start;\n        var a2 = line.end;\n        var rx = this.a;\n        var ry = this.b;\n        var dir = line.vector();\n        var diff = a1.difference(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this));\n        var mDir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        var mDiff = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(diff.x / (rx * rx), diff.y / (ry * ry));\n\n        var a = dir.dot(mDir);\n        var b = dir.dot(mDiff);\n        var c = diff.dot(mDiff) - 1.0;\n        var d = b * b - a * c;\n\n        if (d < 0) {\n            return null;\n        } else if (d > 0) {\n            var root = sqrt(d);\n            var ta = (-b - root) / a;\n            var tb = (-b + root) / a;\n\n            if ((ta < 0 || 1 < ta) && (tb < 0 || 1 < tb)) {\n                // if ((ta < 0 && tb < 0) || (ta > 1 && tb > 1)) outside else inside\n                return null;\n            } else {\n                if (0 <= ta && ta <= 1) intersections.push(a1.lerp(a2, ta));\n                if (0 <= tb && tb <= 1) intersections.push(a1.lerp(a2, tb));\n            }\n        } else {\n            var t = -b / a;\n            if (0 <= t && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            } else {\n                // outside\n                return null;\n            }\n        }\n\n        return intersections;\n    },\n\n    // Find point on me where line from my center to\n    // point p intersects my boundary.\n    // @param {number} angle If angle is specified, intersection with rotated ellipse is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p);\n\n        if (angle) p.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), angle);\n\n        var dx = p.x - this.x;\n        var dy = p.y - this.y;\n        var result;\n\n        if (dx === 0) {\n            result = this.bbox().pointNearestToPoint(p);\n            if (angle) return result.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), -angle);\n            return result;\n        }\n\n        var m = dy / dx;\n        var mSquared = m * m;\n        var aSquared = this.a * this.a;\n        var bSquared = this.b * this.b;\n\n        var x = sqrt(1 / ((1 / aSquared) + (mSquared / bSquared)));\n        x = dx < 0 ? -x : x;\n\n        var y = m * x;\n        result = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x + x, this.y + y);\n\n        if (angle) return result.rotate(new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y), -angle);\n        return result;\n    },\n\n    /**\n     * @param {g.Point} point\n     * @returns {number} result < 1 - inside ellipse, result == 1 - on ellipse boundary, result > 1 - outside\n     */\n    normalizedDistance: function(point) {\n\n        var x0 = point.x;\n        var y0 = point.y;\n        var a = this.a;\n        var b = this.b;\n        var x = this.x;\n        var y = this.y;\n\n        return ((x0 - x) * (x0 - x)) / (a * a) + ((y0 - y) * (y0 - y)) / (b * b);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.a = round(this.a * f) / f;\n        this.b = round(this.b * f) / f;\n        return this;\n    },\n\n    /** Compute angle between tangent and x axis\n     * @param {g.Point} p Point of tangency, it has to be on ellipse boundaries.\n     * @returns {number} angle between tangent and x axis\n     */\n    tangentTheta: function(p) {\n\n        var refPointDelta = 30;\n        var x0 = p.x;\n        var y0 = p.y;\n        var a = this.a;\n        var b = this.b;\n        var center = this.bbox().center();\n        var m = center.x;\n        var n = center.y;\n\n        var q1 = x0 > center.x + a / 2;\n        var q3 = x0 < center.x - a / 2;\n\n        var y, x;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x = (a * a / (x0 - m)) - (a * a * (y0 - n) * (y - n)) / (b * b * (x0 - m)) + m;\n\n        } else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y = (b * b / (y0 - n)) - (b * b * (x0 - m) * (x - m)) / (a * a * (y0 - n)) + n;\n        }\n\n        return (new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(x, y)).theta(p);\n\n    },\n\n    toString: function() {\n\n        return (new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.x, this.y)).toString() + ' ' + this.a + ' ' + this.b;\n    }\n};\n\n// For backwards compatibility:\nconst ellipse = Ellipse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9lbGxpcHNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrQztBQUNFO0FBQ0E7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFSzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsNkNBQUs7QUFDcEM7O0FBRUEsWUFBWSw2Q0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsMkNBQUk7QUFDbkI7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDZDQUFLOztBQUVmOztBQUVBLG1CQUFtQiwyQ0FBSTtBQUN2QixLQUFLOztBQUVMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2Q0FBSztBQUMxQyx1QkFBdUIsNkNBQUs7QUFDNUIsd0JBQXdCLDZDQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQSxnQkFBZ0IsNkNBQUs7O0FBRXJCLGdDQUFnQyw2Q0FBSzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsNkNBQUs7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLDZDQUFLOztBQUUxQiw0Q0FBNEMsNkNBQUs7QUFDakQ7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDZDQUFLOztBQUV6QixLQUFLOztBQUVMOztBQUVBLG9CQUFvQiw2Q0FBSztBQUN6QjtBQUNBOztBQUVBO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL2VsbGlwc2UubWpzP2E4ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vcmVjdC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcblxuY29uc3Qge1xuICAgIHNxcnQsXG4gICAgcm91bmQsXG4gICAgcG93XG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IEVsbGlwc2UgPSBmdW5jdGlvbihjLCBhLCBiKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRWxsaXBzZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKGMsIGEsIGIpO1xuICAgIH1cblxuICAgIGlmIChjIGluc3RhbmNlb2YgRWxsaXBzZSkge1xuICAgICAgICByZXR1cm4gbmV3IEVsbGlwc2UobmV3IFBvaW50KGMueCwgYy55KSwgYy5hLCBjLmIpO1xuICAgIH1cblxuICAgIGMgPSBuZXcgUG9pbnQoYyk7XG4gICAgdGhpcy54ID0gYy54O1xuICAgIHRoaXMueSA9IGMueTtcbiAgICB0aGlzLmEgPSBhO1xuICAgIHRoaXMuYiA9IGI7XG59O1xuXG5FbGxpcHNlLmZyb21SZWN0ID0gZnVuY3Rpb24ocmVjdCkge1xuXG4gICAgcmVjdCA9IG5ldyBSZWN0KHJlY3QpO1xuICAgIHJldHVybiBuZXcgRWxsaXBzZShyZWN0LmNlbnRlcigpLCByZWN0LndpZHRoIC8gMiwgcmVjdC5oZWlnaHQgLyAyKTtcbn07XG5cbkVsbGlwc2UucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuRWxsaXBzZSxcblxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh0aGlzLnggLSB0aGlzLmEsIHRoaXMueSAtIHRoaXMuYiwgMiAqIHRoaXMuYSwgMiAqIHRoaXMuYik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtnLlBvaW50fVxuICAgICAqL1xuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IEVsbGlwc2UodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Zy5Qb2ludH0gcFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkRGlzdGFuY2UocCkgPD0gMTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihlbGxpcHNlKSB7XG5cbiAgICAgICAgcmV0dXJuICEhZWxsaXBzZSAmJlxuICAgICAgICAgICAgZWxsaXBzZS54ID09PSB0aGlzLnggJiZcbiAgICAgICAgICAgIGVsbGlwc2UueSA9PT0gdGhpcy55ICYmXG4gICAgICAgICAgICBlbGxpcHNlLmEgPT09IHRoaXMuYSAmJlxuICAgICAgICAgICAgZWxsaXBzZS5iID09PSB0aGlzLmI7XG4gICAgfSxcblxuICAgIC8vIGluZmxhdGUgYnkgZHggYW5kIGR5XG4gICAgLy8gQHBhcmFtIGR4IHtkZWx0YV94fSByZXByZXNlbnRpbmcgYWRkaXRpb25hbCBzaXplIHRvIHhcbiAgICAvLyBAcGFyYW0gZHkge2RlbHRhX3l9IHJlcHJlc2VudGluZyBhZGRpdGlvbmFsIHNpemUgdG8geSAtXG4gICAgLy8gZHkgcGFyYW0gaXMgbm90IHJlcXVpcmVkIC0+IGluIHRoYXQgY2FzZSB5IGlzIHNpemVkIGJ5IGR4XG4gICAgaW5mbGF0ZTogZnVuY3Rpb24oZHgsIGR5KSB7XG4gICAgICAgIGlmIChkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYSArPSAyICogZHg7XG4gICAgICAgIHRoaXMuYiArPSAyICogZHk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG5cbiAgICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIGExID0gbGluZS5zdGFydDtcbiAgICAgICAgdmFyIGEyID0gbGluZS5lbmQ7XG4gICAgICAgIHZhciByeCA9IHRoaXMuYTtcbiAgICAgICAgdmFyIHJ5ID0gdGhpcy5iO1xuICAgICAgICB2YXIgZGlyID0gbGluZS52ZWN0b3IoKTtcbiAgICAgICAgdmFyIGRpZmYgPSBhMS5kaWZmZXJlbmNlKG5ldyBQb2ludCh0aGlzKSk7XG4gICAgICAgIHZhciBtRGlyID0gbmV3IFBvaW50KGRpci54IC8gKHJ4ICogcngpLCBkaXIueSAvIChyeSAqIHJ5KSk7XG4gICAgICAgIHZhciBtRGlmZiA9IG5ldyBQb2ludChkaWZmLnggLyAocnggKiByeCksIGRpZmYueSAvIChyeSAqIHJ5KSk7XG5cbiAgICAgICAgdmFyIGEgPSBkaXIuZG90KG1EaXIpO1xuICAgICAgICB2YXIgYiA9IGRpci5kb3QobURpZmYpO1xuICAgICAgICB2YXIgYyA9IGRpZmYuZG90KG1EaWZmKSAtIDEuMDtcbiAgICAgICAgdmFyIGQgPSBiICogYiAtIGEgKiBjO1xuXG4gICAgICAgIGlmIChkIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgIHZhciByb290ID0gc3FydChkKTtcbiAgICAgICAgICAgIHZhciB0YSA9ICgtYiAtIHJvb3QpIC8gYTtcbiAgICAgICAgICAgIHZhciB0YiA9ICgtYiArIHJvb3QpIC8gYTtcblxuICAgICAgICAgICAgaWYgKCh0YSA8IDAgfHwgMSA8IHRhKSAmJiAodGIgPCAwIHx8IDEgPCB0YikpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoKHRhIDwgMCAmJiB0YiA8IDApIHx8ICh0YSA+IDEgJiYgdGIgPiAxKSkgb3V0c2lkZSBlbHNlIGluc2lkZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoMCA8PSB0YSAmJiB0YSA8PSAxKSBpbnRlcnNlY3Rpb25zLnB1c2goYTEubGVycChhMiwgdGEpKTtcbiAgICAgICAgICAgICAgICBpZiAoMCA8PSB0YiAmJiB0YiA8PSAxKSBpbnRlcnNlY3Rpb25zLnB1c2goYTEubGVycChhMiwgdGIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gLWIgLyBhO1xuICAgICAgICAgICAgaWYgKDAgPD0gdCAmJiB0IDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2goYTEubGVycChhMiwgdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdXRzaWRlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgICB9LFxuXG4gICAgLy8gRmluZCBwb2ludCBvbiBtZSB3aGVyZSBsaW5lIGZyb20gbXkgY2VudGVyIHRvXG4gICAgLy8gcG9pbnQgcCBpbnRlcnNlY3RzIG15IGJvdW5kYXJ5LlxuICAgIC8vIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSBJZiBhbmdsZSBpcyBzcGVjaWZpZWQsIGludGVyc2VjdGlvbiB3aXRoIHJvdGF0ZWQgZWxsaXBzZSBpcyBjb21wdXRlZC5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZUZyb21DZW50ZXJUb1BvaW50OiBmdW5jdGlvbihwLCBhbmdsZSkge1xuXG4gICAgICAgIHAgPSBuZXcgUG9pbnQocCk7XG5cbiAgICAgICAgaWYgKGFuZ2xlKSBwLnJvdGF0ZShuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpLCBhbmdsZSk7XG5cbiAgICAgICAgdmFyIGR4ID0gcC54IC0gdGhpcy54O1xuICAgICAgICB2YXIgZHkgPSBwLnkgLSB0aGlzLnk7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGR4ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmJib3goKS5wb2ludE5lYXJlc3RUb1BvaW50KHApO1xuICAgICAgICAgICAgaWYgKGFuZ2xlKSByZXR1cm4gcmVzdWx0LnJvdGF0ZShuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpLCAtYW5nbGUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtID0gZHkgLyBkeDtcbiAgICAgICAgdmFyIG1TcXVhcmVkID0gbSAqIG07XG4gICAgICAgIHZhciBhU3F1YXJlZCA9IHRoaXMuYSAqIHRoaXMuYTtcbiAgICAgICAgdmFyIGJTcXVhcmVkID0gdGhpcy5iICogdGhpcy5iO1xuXG4gICAgICAgIHZhciB4ID0gc3FydCgxIC8gKCgxIC8gYVNxdWFyZWQpICsgKG1TcXVhcmVkIC8gYlNxdWFyZWQpKSk7XG4gICAgICAgIHggPSBkeCA8IDAgPyAteCA6IHg7XG5cbiAgICAgICAgdmFyIHkgPSBtICogeDtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFBvaW50KHRoaXMueCArIHgsIHRoaXMueSArIHkpO1xuXG4gICAgICAgIGlmIChhbmdsZSkgcmV0dXJuIHJlc3VsdC5yb3RhdGUobmV3IFBvaW50KHRoaXMueCwgdGhpcy55KSwgLWFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtnLlBvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHJlc3VsdCA8IDEgLSBpbnNpZGUgZWxsaXBzZSwgcmVzdWx0ID09IDEgLSBvbiBlbGxpcHNlIGJvdW5kYXJ5LCByZXN1bHQgPiAxIC0gb3V0c2lkZVxuICAgICAqL1xuICAgIG5vcm1hbGl6ZWREaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgeDAgPSBwb2ludC54O1xuICAgICAgICB2YXIgeTAgPSBwb2ludC55O1xuICAgICAgICB2YXIgYSA9IHRoaXMuYTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmI7XG4gICAgICAgIHZhciB4ID0gdGhpcy54O1xuICAgICAgICB2YXIgeSA9IHRoaXMueTtcblxuICAgICAgICByZXR1cm4gKCh4MCAtIHgpICogKHgwIC0geCkpIC8gKGEgKiBhKSArICgoeTAgLSB5KSAqICh5MCAtIHkpKSAvIChiICogYik7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICBsZXQgZiA9IDE7IC8vIGNhc2UgMFxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogZiA9IDEwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IGYgPSAxMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogZiA9IDEwMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGYgPSBwb3coMTAsIHByZWNpc2lvbik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0gcm91bmQodGhpcy54ICogZikgLyBmO1xuICAgICAgICB0aGlzLnkgPSByb3VuZCh0aGlzLnkgKiBmKSAvIGY7XG4gICAgICAgIHRoaXMuYSA9IHJvdW5kKHRoaXMuYSAqIGYpIC8gZjtcbiAgICAgICAgdGhpcy5iID0gcm91bmQodGhpcy5iICogZikgLyBmO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqIENvbXB1dGUgYW5nbGUgYmV0d2VlbiB0YW5nZW50IGFuZCB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge2cuUG9pbnR9IHAgUG9pbnQgb2YgdGFuZ2VuY3ksIGl0IGhhcyB0byBiZSBvbiBlbGxpcHNlIGJvdW5kYXJpZXMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gYW5nbGUgYmV0d2VlbiB0YW5nZW50IGFuZCB4IGF4aXNcbiAgICAgKi9cbiAgICB0YW5nZW50VGhldGE6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgcmVmUG9pbnREZWx0YSA9IDMwO1xuICAgICAgICB2YXIgeDAgPSBwLng7XG4gICAgICAgIHZhciB5MCA9IHAueTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5iYm94KCkuY2VudGVyKCk7XG4gICAgICAgIHZhciBtID0gY2VudGVyLng7XG4gICAgICAgIHZhciBuID0gY2VudGVyLnk7XG5cbiAgICAgICAgdmFyIHExID0geDAgPiBjZW50ZXIueCArIGEgLyAyO1xuICAgICAgICB2YXIgcTMgPSB4MCA8IGNlbnRlci54IC0gYSAvIDI7XG5cbiAgICAgICAgdmFyIHksIHg7XG4gICAgICAgIGlmIChxMSB8fCBxMykge1xuICAgICAgICAgICAgeSA9IHgwID4gY2VudGVyLnggPyB5MCAtIHJlZlBvaW50RGVsdGEgOiB5MCArIHJlZlBvaW50RGVsdGE7XG4gICAgICAgICAgICB4ID0gKGEgKiBhIC8gKHgwIC0gbSkpIC0gKGEgKiBhICogKHkwIC0gbikgKiAoeSAtIG4pKSAvIChiICogYiAqICh4MCAtIG0pKSArIG07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSB5MCA+IGNlbnRlci55ID8geDAgKyByZWZQb2ludERlbHRhIDogeDAgLSByZWZQb2ludERlbHRhO1xuICAgICAgICAgICAgeSA9IChiICogYiAvICh5MCAtIG4pKSAtIChiICogYiAqICh4MCAtIG0pICogKHggLSBtKSkgLyAoYSAqIGEgKiAoeTAgLSBuKSkgKyBuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZXcgUG9pbnQoeCwgeSkpLnRoZXRhKHApO1xuXG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gKG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSkpLnRvU3RyaW5nKCkgKyAnICcgKyB0aGlzLmEgKyAnICcgKyB0aGlzLmI7XG4gICAgfVxufTtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuZXhwb3J0IGNvbnN0IGVsbGlwc2UgPSBFbGxpcHNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/extend.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/g/extend.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extend: function() { return /* binding */ extend; }\n/* harmony export */ });\n// Local helper function.\n// Add properties from arguments on top of properties from `obj`.\n// This allows for rudimentary inheritance.\n// - The `obj` argument acts as parent.\n// - This function creates a new object that inherits all `obj` properties and adds/replaces those that are present in arguments.\n// - A high-level example: calling `extend(Vehicle, Car)` would be akin to declaring `class Car extends Vehicle`.\nfunction extend(obj) {\n    // In JavaScript, the combination of a constructor function (e.g. `g.Line = function(...) {...}`) and prototype (e.g. `g.Line.prototype = {...}) is akin to a C++ class.\n    // - When inheritance is not necessary, we can leave it at that. (This would be akin to calling extend with only `obj`.)\n    // - But, what if we wanted the `g.Line` quasiclass to inherit from another quasiclass (let's call it `g.GeometryObject`) in JavaScript?\n    // - First, realize that both of those quasiclasses would still have their own separate constructor function.\n    // - So what we are actually saying is that we want the `g.Line` prototype to inherit from `g.GeometryObject` prototype.\n    // - This method provides a way to do exactly that.\n    // - It copies parent prototype's properties, then adds extra ones from child prototype/overrides parent prototype properties with child prototype properties.\n    // - Therefore, to continue with the example above:\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, linePrototype)`\n    //   - Where `linePrototype` is a properties object that looks just like `g.Line.prototype` does right now.\n    //   - Then, `g.Line` would allow the programmer to access to all methods currently in `g.Line.Prototype`, plus any non-overridden methods from `g.GeometryObject.prototype`.\n    //   - In that aspect, `g.GeometryObject` would then act like the parent of `g.Line`.\n    // - Multiple inheritance is also possible, if multiple arguments are provided.\n    // - What if we wanted to add another level of abstraction between `g.GeometryObject` and `g.Line` (let's call it `g.LinearObject`)?\n    //   - `g.Line.prototype = extend(g.GeometryObject.prototype, g.LinearObject.prototype, linePrototype)`\n    //   - The ancestors are applied in order of appearance.\n    //   - That means that `g.Line` would have inherited from `g.LinearObject` that would have inherited from `g.GeometryObject`.\n    //   - Any number of ancestors may be provided.\n    // - Note that neither `obj` nor any of the arguments need to actually be prototypes of any JavaScript quasiclass, that was just a simplified explanation.\n    // - We can create a new object composed from the properties of any number of other objects (since they do not have a constructor, we can think of those as interfaces).\n    //   - `extend({ a: 1, b: 2 }, { b: 10, c: 20 }, { c: 100, d: 200 })` gives `{ a: 1, b: 10, c: 100, d: 200 }`.\n    //   - Basically, with this function, we can emulate the `extends` keyword as well as the `implements` keyword.\n    // - Therefore, both of the following are valid:\n    //   - `Lineto.prototype = extend(Line.prototype, segmentPrototype, linetoPrototype)`\n    //   - `Moveto.prototype = extend(segmentPrototype, movetoPrototype)`\n\n    var i;\n    var n;\n\n    var args = [];\n    n = arguments.length;\n    for (i = 1; i < n; i++) { // skip over obj\n        args.push(arguments[i]);\n    }\n\n    if (!obj) throw new Error('Missing a parent object.');\n    var child = Object.create(obj);\n\n    n = args.length;\n    for (i = 0; i < n; i++) {\n\n        var src = args[i];\n\n        var inheritedProperty;\n        var key;\n        for (key in src) {\n\n            if (src.hasOwnProperty(key)) {\n                delete child[key]; // delete property inherited from parent\n                inheritedProperty = Object.getOwnPropertyDescriptor(src, key); // get new definition of property from src\n                Object.defineProperty(child, key, inheritedProperty); // re-add property with new definition (includes getter/setter methods)\n            }\n        }\n    }\n\n    return child;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9leHRlbmQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLCtGQUErRixJQUFJLDRDQUE0QyxJQUFJO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVksSUFBSSxjQUFjLElBQUksZ0JBQWdCLFlBQVksNkJBQTZCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixPQUFPLE9BQU87QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLE9BQU87O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQywrRUFBK0U7QUFDL0Usc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9leHRlbmQubWpzPzlkMDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTG9jYWwgaGVscGVyIGZ1bmN0aW9uLlxuLy8gQWRkIHByb3BlcnRpZXMgZnJvbSBhcmd1bWVudHMgb24gdG9wIG9mIHByb3BlcnRpZXMgZnJvbSBgb2JqYC5cbi8vIFRoaXMgYWxsb3dzIGZvciBydWRpbWVudGFyeSBpbmhlcml0YW5jZS5cbi8vIC0gVGhlIGBvYmpgIGFyZ3VtZW50IGFjdHMgYXMgcGFyZW50LlxuLy8gLSBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgYWxsIGBvYmpgIHByb3BlcnRpZXMgYW5kIGFkZHMvcmVwbGFjZXMgdGhvc2UgdGhhdCBhcmUgcHJlc2VudCBpbiBhcmd1bWVudHMuXG4vLyAtIEEgaGlnaC1sZXZlbCBleGFtcGxlOiBjYWxsaW5nIGBleHRlbmQoVmVoaWNsZSwgQ2FyKWAgd291bGQgYmUgYWtpbiB0byBkZWNsYXJpbmcgYGNsYXNzIENhciBleHRlbmRzIFZlaGljbGVgLlxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChvYmopIHtcbiAgICAvLyBJbiBKYXZhU2NyaXB0LCB0aGUgY29tYmluYXRpb24gb2YgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiAoZS5nLiBgZy5MaW5lID0gZnVuY3Rpb24oLi4uKSB7Li4ufWApIGFuZCBwcm90b3R5cGUgKGUuZy4gYGcuTGluZS5wcm90b3R5cGUgPSB7Li4ufSkgaXMgYWtpbiB0byBhIEMrKyBjbGFzcy5cbiAgICAvLyAtIFdoZW4gaW5oZXJpdGFuY2UgaXMgbm90IG5lY2Vzc2FyeSwgd2UgY2FuIGxlYXZlIGl0IGF0IHRoYXQuIChUaGlzIHdvdWxkIGJlIGFraW4gdG8gY2FsbGluZyBleHRlbmQgd2l0aCBvbmx5IGBvYmpgLilcbiAgICAvLyAtIEJ1dCwgd2hhdCBpZiB3ZSB3YW50ZWQgdGhlIGBnLkxpbmVgIHF1YXNpY2xhc3MgdG8gaW5oZXJpdCBmcm9tIGFub3RoZXIgcXVhc2ljbGFzcyAobGV0J3MgY2FsbCBpdCBgZy5HZW9tZXRyeU9iamVjdGApIGluIEphdmFTY3JpcHQ/XG4gICAgLy8gLSBGaXJzdCwgcmVhbGl6ZSB0aGF0IGJvdGggb2YgdGhvc2UgcXVhc2ljbGFzc2VzIHdvdWxkIHN0aWxsIGhhdmUgdGhlaXIgb3duIHNlcGFyYXRlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIC8vIC0gU28gd2hhdCB3ZSBhcmUgYWN0dWFsbHkgc2F5aW5nIGlzIHRoYXQgd2Ugd2FudCB0aGUgYGcuTGluZWAgcHJvdG90eXBlIHRvIGluaGVyaXQgZnJvbSBgZy5HZW9tZXRyeU9iamVjdGAgcHJvdG90eXBlLlxuICAgIC8vIC0gVGhpcyBtZXRob2QgcHJvdmlkZXMgYSB3YXkgdG8gZG8gZXhhY3RseSB0aGF0LlxuICAgIC8vIC0gSXQgY29waWVzIHBhcmVudCBwcm90b3R5cGUncyBwcm9wZXJ0aWVzLCB0aGVuIGFkZHMgZXh0cmEgb25lcyBmcm9tIGNoaWxkIHByb3RvdHlwZS9vdmVycmlkZXMgcGFyZW50IHByb3RvdHlwZSBwcm9wZXJ0aWVzIHdpdGggY2hpbGQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gICAgLy8gLSBUaGVyZWZvcmUsIHRvIGNvbnRpbnVlIHdpdGggdGhlIGV4YW1wbGUgYWJvdmU6XG4gICAgLy8gICAtIGBnLkxpbmUucHJvdG90eXBlID0gZXh0ZW5kKGcuR2VvbWV0cnlPYmplY3QucHJvdG90eXBlLCBsaW5lUHJvdG90eXBlKWBcbiAgICAvLyAgIC0gV2hlcmUgYGxpbmVQcm90b3R5cGVgIGlzIGEgcHJvcGVydGllcyBvYmplY3QgdGhhdCBsb29rcyBqdXN0IGxpa2UgYGcuTGluZS5wcm90b3R5cGVgIGRvZXMgcmlnaHQgbm93LlxuICAgIC8vICAgLSBUaGVuLCBgZy5MaW5lYCB3b3VsZCBhbGxvdyB0aGUgcHJvZ3JhbW1lciB0byBhY2Nlc3MgdG8gYWxsIG1ldGhvZHMgY3VycmVudGx5IGluIGBnLkxpbmUuUHJvdG90eXBlYCwgcGx1cyBhbnkgbm9uLW92ZXJyaWRkZW4gbWV0aG9kcyBmcm9tIGBnLkdlb21ldHJ5T2JqZWN0LnByb3RvdHlwZWAuXG4gICAgLy8gICAtIEluIHRoYXQgYXNwZWN0LCBgZy5HZW9tZXRyeU9iamVjdGAgd291bGQgdGhlbiBhY3QgbGlrZSB0aGUgcGFyZW50IG9mIGBnLkxpbmVgLlxuICAgIC8vIC0gTXVsdGlwbGUgaW5oZXJpdGFuY2UgaXMgYWxzbyBwb3NzaWJsZSwgaWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICAvLyAtIFdoYXQgaWYgd2Ugd2FudGVkIHRvIGFkZCBhbm90aGVyIGxldmVsIG9mIGFic3RyYWN0aW9uIGJldHdlZW4gYGcuR2VvbWV0cnlPYmplY3RgIGFuZCBgZy5MaW5lYCAobGV0J3MgY2FsbCBpdCBgZy5MaW5lYXJPYmplY3RgKT9cbiAgICAvLyAgIC0gYGcuTGluZS5wcm90b3R5cGUgPSBleHRlbmQoZy5HZW9tZXRyeU9iamVjdC5wcm90b3R5cGUsIGcuTGluZWFyT2JqZWN0LnByb3RvdHlwZSwgbGluZVByb3RvdHlwZSlgXG4gICAgLy8gICAtIFRoZSBhbmNlc3RvcnMgYXJlIGFwcGxpZWQgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICAvLyAgIC0gVGhhdCBtZWFucyB0aGF0IGBnLkxpbmVgIHdvdWxkIGhhdmUgaW5oZXJpdGVkIGZyb20gYGcuTGluZWFyT2JqZWN0YCB0aGF0IHdvdWxkIGhhdmUgaW5oZXJpdGVkIGZyb20gYGcuR2VvbWV0cnlPYmplY3RgLlxuICAgIC8vICAgLSBBbnkgbnVtYmVyIG9mIGFuY2VzdG9ycyBtYXkgYmUgcHJvdmlkZWQuXG4gICAgLy8gLSBOb3RlIHRoYXQgbmVpdGhlciBgb2JqYCBub3IgYW55IG9mIHRoZSBhcmd1bWVudHMgbmVlZCB0byBhY3R1YWxseSBiZSBwcm90b3R5cGVzIG9mIGFueSBKYXZhU2NyaXB0IHF1YXNpY2xhc3MsIHRoYXQgd2FzIGp1c3QgYSBzaW1wbGlmaWVkIGV4cGxhbmF0aW9uLlxuICAgIC8vIC0gV2UgY2FuIGNyZWF0ZSBhIG5ldyBvYmplY3QgY29tcG9zZWQgZnJvbSB0aGUgcHJvcGVydGllcyBvZiBhbnkgbnVtYmVyIG9mIG90aGVyIG9iamVjdHMgKHNpbmNlIHRoZXkgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3Rvciwgd2UgY2FuIHRoaW5rIG9mIHRob3NlIGFzIGludGVyZmFjZXMpLlxuICAgIC8vICAgLSBgZXh0ZW5kKHsgYTogMSwgYjogMiB9LCB7IGI6IDEwLCBjOiAyMCB9LCB7IGM6IDEwMCwgZDogMjAwIH0pYCBnaXZlcyBgeyBhOiAxLCBiOiAxMCwgYzogMTAwLCBkOiAyMDAgfWAuXG4gICAgLy8gICAtIEJhc2ljYWxseSwgd2l0aCB0aGlzIGZ1bmN0aW9uLCB3ZSBjYW4gZW11bGF0ZSB0aGUgYGV4dGVuZHNgIGtleXdvcmQgYXMgd2VsbCBhcyB0aGUgYGltcGxlbWVudHNgIGtleXdvcmQuXG4gICAgLy8gLSBUaGVyZWZvcmUsIGJvdGggb2YgdGhlIGZvbGxvd2luZyBhcmUgdmFsaWQ6XG4gICAgLy8gICAtIGBMaW5ldG8ucHJvdG90eXBlID0gZXh0ZW5kKExpbmUucHJvdG90eXBlLCBzZWdtZW50UHJvdG90eXBlLCBsaW5ldG9Qcm90b3R5cGUpYFxuICAgIC8vICAgLSBgTW92ZXRvLnByb3RvdHlwZSA9IGV4dGVuZChzZWdtZW50UHJvdG90eXBlLCBtb3ZldG9Qcm90b3R5cGUpYFxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG47XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHsgLy8gc2tpcCBvdmVyIG9ialxuICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoIW9iaikgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGEgcGFyZW50IG9iamVjdC4nKTtcbiAgICB2YXIgY2hpbGQgPSBPYmplY3QuY3JlYXRlKG9iaik7XG5cbiAgICBuID0gYXJncy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgIHZhciBzcmMgPSBhcmdzW2ldO1xuXG4gICAgICAgIHZhciBpbmhlcml0ZWRQcm9wZXJ0eTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gc3JjKSB7XG5cbiAgICAgICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZFtrZXldOyAvLyBkZWxldGUgcHJvcGVydHkgaW5oZXJpdGVkIGZyb20gcGFyZW50XG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkUHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywga2V5KTsgLy8gZ2V0IG5ldyBkZWZpbml0aW9uIG9mIHByb3BlcnR5IGZyb20gc3JjXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBrZXksIGluaGVyaXRlZFByb3BlcnR5KTsgLy8gcmUtYWRkIHByb3BlcnR5IHdpdGggbmV3IGRlZmluaXRpb24gKGluY2x1ZGVzIGdldHRlci9zZXR0ZXIgbWV0aG9kcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/extend.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/g/geometry.helpers.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalizeAngle: function() { return /* binding */ normalizeAngle; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   scale: function() { return /* binding */ scale; },\n/* harmony export */   snapToGrid: function() { return /* binding */ snapToGrid; },\n/* harmony export */   toDeg: function() { return /* binding */ toDeg; },\n/* harmony export */   toRad: function() { return /* binding */ toRad; }\n/* harmony export */ });\n// Declare shorthands to the most used math functions.\nconst {\n    round,\n    floor,\n    PI\n} = Math;\n\nconst scale = {\n\n    // Return the `value` from the `domain` interval scaled to the `range` interval.\n    linear: function(domain, range, value) {\n\n        var domainSpan = domain[1] - domain[0];\n        var rangeSpan = range[1] - range[0];\n        return (((value - domain[0]) / domainSpan) * rangeSpan + range[0]) || 0;\n    }\n};\n\nconst normalizeAngle = function(angle) {\n\n    return (angle % 360) + (angle < 0 ? 360 : 0);\n};\n\nconst snapToGrid = function(value, gridSize) {\n\n    return gridSize * round(value / gridSize);\n};\n\nconst toDeg = function(rad) {\n\n    return (180 * rad / PI) % 360;\n};\n\nconst toRad = function(deg, over360) {\n\n    over360 = over360 || false;\n    deg = over360 ? deg : (deg % 360);\n    return deg * PI / 180;\n};\n\n// Return a random integer from the interval [min,max], inclusive.\nconst random = function(min, max) {\n\n    if (max === undefined) {\n        // use first argument as max, min is 0\n        max = (min === undefined) ? 1 : min;\n        min = 0;\n\n    } else if (max < min) {\n        // switch max and min\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n\n    return floor((Math.random() * (max - min + 1)) + min);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9nZW9tZXRyeS5oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFSzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTs7QUFFTzs7QUFFUDtBQUNBOztBQUVPOztBQUVQO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9nZW9tZXRyeS5oZWxwZXJzLm1qcz8xZTViIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERlY2xhcmUgc2hvcnRoYW5kcyB0byB0aGUgbW9zdCB1c2VkIG1hdGggZnVuY3Rpb25zLlxuY29uc3Qge1xuICAgIHJvdW5kLFxuICAgIGZsb29yLFxuICAgIFBJXG59ID0gTWF0aDtcblxuZXhwb3J0IGNvbnN0IHNjYWxlID0ge1xuXG4gICAgLy8gUmV0dXJuIHRoZSBgdmFsdWVgIGZyb20gdGhlIGBkb21haW5gIGludGVydmFsIHNjYWxlZCB0byB0aGUgYHJhbmdlYCBpbnRlcnZhbC5cbiAgICBsaW5lYXI6IGZ1bmN0aW9uKGRvbWFpbiwgcmFuZ2UsIHZhbHVlKSB7XG5cbiAgICAgICAgdmFyIGRvbWFpblNwYW4gPSBkb21haW5bMV0gLSBkb21haW5bMF07XG4gICAgICAgIHZhciByYW5nZVNwYW4gPSByYW5nZVsxXSAtIHJhbmdlWzBdO1xuICAgICAgICByZXR1cm4gKCgodmFsdWUgLSBkb21haW5bMF0pIC8gZG9tYWluU3BhbikgKiByYW5nZVNwYW4gKyByYW5nZVswXSkgfHwgMDtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplQW5nbGUgPSBmdW5jdGlvbihhbmdsZSkge1xuXG4gICAgcmV0dXJuIChhbmdsZSAlIDM2MCkgKyAoYW5nbGUgPCAwID8gMzYwIDogMCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc25hcFRvR3JpZCA9IGZ1bmN0aW9uKHZhbHVlLCBncmlkU2l6ZSkge1xuXG4gICAgcmV0dXJuIGdyaWRTaXplICogcm91bmQodmFsdWUgLyBncmlkU2l6ZSk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9EZWcgPSBmdW5jdGlvbihyYWQpIHtcblxuICAgIHJldHVybiAoMTgwICogcmFkIC8gUEkpICUgMzYwO1xufTtcblxuZXhwb3J0IGNvbnN0IHRvUmFkID0gZnVuY3Rpb24oZGVnLCBvdmVyMzYwKSB7XG5cbiAgICBvdmVyMzYwID0gb3ZlcjM2MCB8fCBmYWxzZTtcbiAgICBkZWcgPSBvdmVyMzYwID8gZGVnIDogKGRlZyAlIDM2MCk7XG4gICAgcmV0dXJuIGRlZyAqIFBJIC8gMTgwO1xufTtcblxuLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgZnJvbSB0aGUgaW50ZXJ2YWwgW21pbixtYXhdLCBpbmNsdXNpdmUuXG5leHBvcnQgY29uc3QgcmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcblxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1c2UgZmlyc3QgYXJndW1lbnQgYXMgbWF4LCBtaW4gaXMgMFxuICAgICAgICBtYXggPSAobWluID09PSB1bmRlZmluZWQpID8gMSA6IG1pbjtcbiAgICAgICAgbWluID0gMDtcblxuICAgIH0gZWxzZSBpZiAobWF4IDwgbWluKSB7XG4gICAgICAgIC8vIHN3aXRjaCBtYXggYW5kIG1pblxuICAgICAgICBjb25zdCB0ZW1wID0gbWluO1xuICAgICAgICBtaW4gPSBtYXg7XG4gICAgICAgIG1heCA9IHRlbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsb29yKChNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbik7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/index.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Curve: function() { return /* reexport safe */ _curve_mjs__WEBPACK_IMPORTED_MODULE_2__.Curve; },\n/* harmony export */   Ellipse: function() { return /* reexport safe */ _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__.Ellipse; },\n/* harmony export */   Line: function() { return /* reexport safe */ _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line; },\n/* harmony export */   Path: function() { return /* reexport safe */ _path_mjs__WEBPACK_IMPORTED_MODULE_5__.Path; },\n/* harmony export */   Point: function() { return /* reexport safe */ _point_mjs__WEBPACK_IMPORTED_MODULE_6__.Point; },\n/* harmony export */   Polygon: function() { return /* reexport safe */ _polygon_mjs__WEBPACK_IMPORTED_MODULE_8__.Polygon; },\n/* harmony export */   Polyline: function() { return /* reexport safe */ _polyline_mjs__WEBPACK_IMPORTED_MODULE_7__.Polyline; },\n/* harmony export */   Rect: function() { return /* reexport safe */ _rect_mjs__WEBPACK_IMPORTED_MODULE_9__.Rect; },\n/* harmony export */   bezier: function() { return /* reexport safe */ _bezier_mjs__WEBPACK_IMPORTED_MODULE_1__.bezier; },\n/* harmony export */   ellipse: function() { return /* reexport safe */ _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__.ellipse; },\n/* harmony export */   intersection: function() { return /* binding */ intersection; },\n/* harmony export */   line: function() { return /* reexport safe */ _line_mjs__WEBPACK_IMPORTED_MODULE_4__.line; },\n/* harmony export */   normalizeAngle: function() { return /* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle; },\n/* harmony export */   point: function() { return /* reexport safe */ _point_mjs__WEBPACK_IMPORTED_MODULE_6__.point; },\n/* harmony export */   random: function() { return /* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random; },\n/* harmony export */   rect: function() { return /* reexport safe */ _rect_mjs__WEBPACK_IMPORTED_MODULE_9__.rect; },\n/* harmony export */   scale: function() { return /* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.scale; },\n/* harmony export */   snapToGrid: function() { return /* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid; },\n/* harmony export */   toDeg: function() { return /* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg; },\n/* harmony export */   toRad: function() { return /* reexport safe */ _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad; },\n/* harmony export */   types: function() { return /* reexport safe */ _types_mjs__WEBPACK_IMPORTED_MODULE_10__.types; }\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _bezier_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/bezier.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _ellipse_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ellipse.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _path_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./polyline.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./polygon.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polygon.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _intersection_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./intersection.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/intersection.mjs\");\n// Geometry library.\n// -----------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst intersection = _intersection_mjs__WEBPACK_IMPORTED_MODULE_11__;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFdUM7QUFDVjtBQUNEO0FBQ0U7QUFDSDtBQUNBO0FBQ0M7QUFDRztBQUNEO0FBQ0g7QUFDQzs7QUFFd0I7QUFDN0MscUJBQXFCLCtDQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9pbmRleC5tanM/MmU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHZW9tZXRyeSBsaWJyYXJ5LlxuLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0ICogZnJvbSAnLi9nZW9tZXRyeS5oZWxwZXJzLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Jlemllci5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9jdXJ2ZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGxpcHNlLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpbmUubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGF0aC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2x5bGluZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2x5Z29uLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL3JlY3QubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMubWpzJztcblxuaW1wb3J0ICogYXMgX2ludGVyc2VjdGlvbiBmcm9tICcuL2ludGVyc2VjdGlvbi5tanMnO1xuZXhwb3J0IGNvbnN0IGludGVyc2VjdGlvbiA9IF9pbnRlcnNlY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/intersection.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/g/intersection.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ellipseWithEllipse: function() { return /* binding */ ellipseWithEllipse; },\n/* harmony export */   ellipseWithLine: function() { return /* binding */ ellipseWithLine; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   lineWithLine: function() { return /* binding */ lineWithLine; },\n/* harmony export */   pathWithEllipse: function() { return /* binding */ pathWithEllipse; },\n/* harmony export */   pathWithLine: function() { return /* binding */ pathWithLine; },\n/* harmony export */   pathWithPath: function() { return /* binding */ pathWithPath; },\n/* harmony export */   pathWithPolygon: function() { return /* binding */ pathWithPolygon; },\n/* harmony export */   pathWithPolyline: function() { return /* binding */ pathWithPolyline; },\n/* harmony export */   pathWithRect: function() { return /* binding */ pathWithRect; },\n/* harmony export */   polygonWithEllipse: function() { return /* binding */ polygonWithEllipse; },\n/* harmony export */   polygonWithLine: function() { return /* binding */ polygonWithLine; },\n/* harmony export */   polygonWithPolygon: function() { return /* binding */ polygonWithPolygon; },\n/* harmony export */   polygonWithPolyline: function() { return /* binding */ polygonWithPolyline; },\n/* harmony export */   polygonWithRect: function() { return /* binding */ polygonWithRect; },\n/* harmony export */   polylineWithEllipse: function() { return /* binding */ polylineWithEllipse; },\n/* harmony export */   polylineWithLine: function() { return /* binding */ polylineWithLine; },\n/* harmony export */   polylineWithPolyline: function() { return /* binding */ polylineWithPolyline; },\n/* harmony export */   polylineWithRect: function() { return /* binding */ polylineWithRect; },\n/* harmony export */   rectWithEllipse: function() { return /* binding */ rectWithEllipse; },\n/* harmony export */   rectWithLine: function() { return /* binding */ rectWithLine; },\n/* harmony export */   rectWithRect: function() { return /* binding */ rectWithRect; }\n/* harmony export */ });\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polygon.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\nfunction exists(shape1, shape2, shape1opt, shape2opt) {\n    switch (shape1.type) {\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return lineWithLine(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return ellipseWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return ellipseWithEllipse(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return rectWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return rectWithEllipse(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return rectWithRect(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return polylineWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return polylineWithEllipse(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return polylineWithRect(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n                    return polylineWithPolyline(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return polygonWithLine(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return polygonWithEllipse(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return polygonWithRect(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n                    return polygonWithPolyline(shape1, shape2);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon: {\n                    return polygonWithPolygon(shape1, shape2);\n                }\n            }\n            break;\n        }\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path: {\n            switch (shape2.type) {\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Line: {\n                    return pathWithLine(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse: {\n                    return pathWithEllipse(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect: {\n                    return pathWithRect(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline: {\n                    return pathWithPolyline(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon: {\n                    return pathWithPolygon(shape1, shape2, shape1opt);\n                }\n                case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path: {\n                    return pathWithPath(shape1, shape2, shape1opt, shape2opt);\n                }\n            }\n            break;\n        }\n    }\n    // None of the cases above\n    switch (shape2.type) {\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Ellipse:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Rect:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polyline:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Polygon:\n        case _types_mjs__WEBPACK_IMPORTED_MODULE_0__.types.Path: {\n            return exists(shape2, shape1, shape2opt, shape1opt);\n        }\n        default: {\n            throw Error(`The intersection for ${shape1} and ${shape2} could not be found.`);\n        }\n    }\n}\n\n/* Line */\n\nfunction lineWithLine(line1, line2) {\n    const x1 = line1.start.x;\n    const y1 = line1.start.y;\n    const x2 = line1.end.x;\n    const y2 = line1.end.y;\n    const x3 = line2.start.x;\n    const y3 = line2.start.y;\n    const x4 = line2.end.x;\n    const y4 = line2.end.y;\n    const s1x = x2 - x1;\n    const s1y = y2 - y1;\n    const s2x = x4 - x3;\n    const s2y = y4 - y3;\n    const s3x = x1 - x3;\n    const s3y = y1 - y3;\n    const p = s1x * s2y - s2x * s1y;\n    const s = (s1x * s3y - s1y * s3x) / p;\n    const t = (s2x * s3y - s2y * s3x) / p;\n    return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/* Ellipse */\n\nfunction ellipseWithLine(ellipse, line) {\n    const rex = ellipse.a;\n    const rey = ellipse.b;\n    const xe = ellipse.x;\n    const ye = ellipse.y;\n    const x1 = line.start.x - xe;\n    const x2 = line.end.x - xe;\n    const y1 = line.start.y - ye;\n    const y2 = line.end.y - ye;\n    const rex_2 = rex * rex;\n    const rey_2 = rey * rey;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const A = dx * dx / rex_2 + dy * dy / rey_2;\n    const B = 2 * x1 * dx / rex_2 + 2 * y1 * dy / rey_2;\n    const C = x1 * x1 / rex_2 + y1 * y1 / rey_2 - 1;\n    const D = B * B - 4 * A * C;\n    if (D === 0) {\n        const t = -B / 2 / A;\n        return t >= 0 && t <= 1;\n    } else if (D > 0) {\n        const sqrt = Math.sqrt(D);\n        const t1 = (-B + sqrt) / 2 / A;\n        const t2 = (-B - sqrt) / 2 / A;\n        return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);\n    }\n    return false;\n}\n\nfunction ellipseWithEllipse(ellipse1, ellipse2) {\n    return _ellipsesIntersection(ellipse1, 0, ellipse2, 0);\n}\n\n/* Rect */\n\nfunction rectWithLine(rect, line) {\n    const { start, end } = line;\n    const { x, y, width, height } = rect;\n    if (\n        (start.x > x + width && end.x > x + width)\n        || (start.x < x && end.x < x)\n        || (start.y > y + height && end.y > y + height)\n        || (start.y < y && end.y < y)\n    ) {\n        return false;\n    }\n    if (rect.containsPoint(line.start) || rect.containsPoint(line.end)) {\n        return true;\n    }\n    return lineWithLine(rect.topLine(), line)\n        || lineWithLine(rect.rightLine(), line)\n        || lineWithLine(rect.bottomLine(), line)\n        || lineWithLine(rect.leftLine(), line);\n}\n\nfunction rectWithEllipse(rect, ellipse) {\n    if (!rectWithRect(rect, _rect_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect.fromEllipse(ellipse))) return false;\n    return polygonWithEllipse(_polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect), ellipse);\n}\n\nfunction rectWithRect(rect1, rect2) {\n    return rect1.x < rect2.x + rect2.width\n        && rect1.x + rect1.width > rect2.x\n        && rect1.y < rect2.y + rect2.height\n        && rect1.y + rect1.height > rect2.y;\n}\n\n/* Polyline */\n\nfunction polylineWithLine(polyline, line) {\n    return _polylineWithLine(polyline, line, { interior: false });\n}\n\nfunction polylineWithEllipse(polyline, ellipse) {\n    return _polylineWithEllipse(polyline, ellipse, { interior: false });\n}\n\nfunction polylineWithRect(polyline, rect) {\n    return _polylineWithRect(polyline, rect, { interior: false });\n}\n\nfunction polylineWithPolyline(polyline1, polyline2) {\n    return _polylineWithPolyline(polyline1, polyline2, { interior: false });\n}\n\n/* Polygon */\n\nfunction polygonWithLine(polygon, line) {\n    return _polylineWithLine(polygon, line, { interior: true });\n}\n\nfunction polygonWithEllipse(polygon, ellipse) {\n    return _polylineWithEllipse(polygon, ellipse, { interior: true });\n}\n\nfunction polygonWithRect(polygon, rect) {\n    return _polylineWithRect(polygon, rect, { interior: true });\n}\n\nfunction polygonWithPolyline(polygon, polyline) {\n    return _polylineWithPolyline(polygon, polyline, { interior: true });\n}\n\nfunction polygonWithPolygon(polygon1, polygon2) {\n    return _polylineWithPolygon(polygon1, polygon2, { interior: true });\n}\n\n/* Path */\n\nfunction pathWithLine(path, line, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithLine(polyline, line);\n        } else {\n            return polylineWithLine(polyline, line);\n        }\n    });\n}\n\nfunction pathWithEllipse(path, ellipse, pathOpt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return polygonWithEllipse(polyline, ellipse);\n        } else {\n            return polylineWithEllipse(polyline, ellipse);\n        }\n    });\n}\n\nfunction pathWithRect(path, rect, pathOpt) {\n    return pathWithPolygon(path, _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect), pathOpt);\n}\n\nfunction pathWithPolyline(path, polyline, pathOpt) {\n    return _pathWithPolyline(path, polyline, pathOpt, { interior: false });\n}\n\nfunction pathWithPolygon(path, polygon, pathOpt) {\n    return _pathWithPolyline(path, polygon, pathOpt, { interior: true });\n}\n\nfunction pathWithPath(path1, path2, pathOpt1, pathOpt2) {\n    return path1.getSubpaths().some(subpath => {\n        const [polyline1] = subpath.toPolylines(pathOpt1);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return pathWithPolygon(path2, polyline1, pathOpt2);\n        } else {\n            return pathWithPolyline(path2, polyline1, pathOpt2);\n        }\n    });\n}\n\nfunction _polylineWithLine(polyline, line, opt = {}) {\n    const { interior = false } = opt;\n    let thisPoints;\n    if (interior) {\n        if (polyline.containsPoint(line.start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        const { start, end, points } = polyline;\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = polyline.points;\n    }\n    const { length } = thisPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (lineWithLine(line, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithEllipse(polyline, ellipse, opt = {}) {\n    const { start, end, points } = polyline;\n    if (ellipse.containsPoint(start)) {\n        return true;\n    }\n    let thisPoints;\n    const { interior = false } = opt;\n    if (interior) {\n        if (polyline.containsPoint(ellipse.center())) {\n            // If any point of the ellipse lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the center point)\n            return true;\n        }\n        thisPoints = end.equals(start) ? points : [...points, start];\n    } else {\n        thisPoints = points;\n    }\n\n    const { length } = thisPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = thisPoints[i];\n        segment.end = thisPoints[i + 1];\n        if (ellipseWithLine(ellipse, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithRect(polyline, rect, opt) {\n    const polygon = _polygon_mjs__WEBPACK_IMPORTED_MODULE_2__.Polygon.fromRect(rect);\n    return _polylineWithPolygon(polyline, polygon, opt);\n}\n\nfunction _pathWithPolyline(path, polyline1, pathOpt, opt) {\n    return path.getSubpaths().some(subpath => {\n        const [polyline2] = subpath.toPolylines(pathOpt);\n        const { type } = subpath.getSegment(-1);\n        if (type === 'Z') {\n            return _polylineWithPolygon(polyline1, polyline2, opt);\n        } else {\n            return _polylineWithPolyline(polyline1, polyline2, opt);\n        }\n    });\n}\n\nfunction _polylineWithPolyline(polyline1, polyline2, opt = {}) {\n    const { interior = false } = opt;\n    let thisPolyline;\n    if (interior) {\n        const { start } = polyline2;\n        if (polyline1.containsPoint(start)) {\n            // If any point of the polyline lies inside this polygon (interior = true)\n            // there is an intersection (we've chosen the start point)\n            return true;\n        }\n        thisPolyline = polyline1.clone().close();\n    } else {\n        thisPolyline = polyline1;\n    }\n    const otherPoints = polyline2.points;\n    const { length } = otherPoints;\n    const segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_3__.Line();\n    for (let i = 0; i < length - 1; i++) {\n        segment.start = otherPoints[i];\n        segment.end = otherPoints[i + 1];\n        if (polylineWithLine(thisPolyline, segment)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction _polylineWithPolygon(polyline, polygon, opt) {\n    return polygon.containsPoint(polyline.start) || _polylineWithPolyline(polyline, polygon.clone().close(), opt);\n}\n\nfunction _ellipsesIntersection(e1, w1, e2, w2) {\n    const { cos, sin } = Math;\n    const sinW1 = sin(w1);\n    const cosW1 = cos(w1);\n    const sinW2 = sin(w2);\n    const cosW2 = cos(w2);\n    const sinW1s = sinW1 * sinW1;\n    const cosW1s = cosW1 * cosW1;\n    const sinCos1 = sinW1 * cosW1;\n    const sinW2s = sinW2 * sinW2;\n    const cosW2s = cosW2 * cosW2;\n    const sinCos2 = sinW2 * cosW2;\n    const a1s = e1.a * e1.a;\n    const b1s = e1.b * e1.b;\n    const a2s = e2.a * e2.a;\n    const b2s = e2.b * e2.b;\n    const A1 = a1s * sinW1s + b1s * cosW1s;\n    const A2 = a2s * sinW2s + b2s * cosW2s;\n    const B1 = a1s * cosW1s + b1s * sinW1s;\n    const B2 = a2s * cosW2s + b2s * sinW2s;\n    let C1 = 2 * (b1s - a1s) * sinCos1;\n    let C2 = 2 * (b2s - a2s) * sinCos2;\n    let D1 = (-2 * A1 * e1.x - C1 * e1.y);\n    let D2 = (-2 * A2 * e2.x - C2 * e2.y);\n    let E1 = (-C1 * e1.x - 2 * B1 * e1.y);\n    let E2 = (-C2 * e2.x - 2 * B2 * e2.y);\n    const F1 = A1 * e1.x * e1.x + B1 * e1.y * e1.y + C1 * e1.x * e1.y - a1s * b1s;\n    const F2 = A2 * e2.x * e2.x + B2 * e2.y * e2.y + C2 * e2.x * e2.y - a2s * b2s;\n\n    C1 = C1 / 2;\n    C2 = C2 / 2;\n    D1 = D1 / 2;\n    D2 = D2 / 2;\n    E1 = E1 / 2;\n    E2 = E2 / 2;\n\n    const l3 = det3([\n        [A1, C1, D1],\n        [C1, B1, E1],\n        [D1, E1, F1]\n    ]);\n    const l0 = det3([\n        [A2, C2, D2],\n        [C2, B2, E2],\n        [D2, E2, F2]\n    ]);\n    const l2 = 0.33333333 * (det3([\n        [A2, C1, D1],\n        [C2, B1, E1],\n        [D2, E1, F1]\n    ]) + det3([\n        [A1, C2, D1],\n        [C1, B2, E1],\n        [D1, E2, F1]\n    ]) + det3([\n        [A1, C1, D2],\n        [C1, B1, E2],\n        [D1, E1, F2]\n    ]));\n    const l1 = 0.33333333 * (det3([\n        [A1, C2, D2],\n        [C1, B2, E2],\n        [D1, E2, F2]\n    ]) + det3([\n        [A2, C1, D2],\n        [C2, B1, E2],\n        [D2, E1, F2]\n    ]) + det3([\n        [A2, C2, D1],\n        [C2, B2, E1],\n        [D2, E2, F1]\n    ]));\n\n    const delta1 = det2([\n        [l3, l2],\n        [l2, l1]\n    ]);\n    const delta2 = det2([\n        [l3, l1],\n        [l2, l0]\n    ]);\n    const delta3 = det2([\n        [l2, l1],\n        [l1, l0]\n    ]);\n\n    const dP = det2([\n        [2 * delta1, delta2],\n        [delta2, 2 * delta3]\n    ]);\n\n    if (dP > 0 && (l1 > 0 || l2 > 0)) {\n        return false;\n    }\n    return true;\n}\n\nfunction det2(m) {\n    return m[0][0] * m[1][1] - m[0][1] * m[1][0];\n}\n\nfunction det3(m) {\n    return m[0][0] * m[1][1] * m[2][2] -\n        m[0][0] * m[1][2] * m[2][1] -\n        m[0][1] * m[1][0] * m[2][2] +\n        m[0][1] * m[1][2] * m[2][0] +\n        m[0][2] * m[1][0] * m[2][1] -\n        m[0][2] * m[1][1] * m[2][0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9pbnRlcnNlY3Rpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ007QUFDTjtBQUNFOztBQUU3QjtBQUNQO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQjtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQjtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFLO0FBQ2xCO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQjtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQjtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZDQUFLO0FBQ2xCO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0EscUJBQXFCLDZDQUFLO0FBQzFCO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBSztBQUNsQixhQUFhLDZDQUFLO0FBQ2xCLGFBQWEsNkNBQUs7QUFDbEIsYUFBYSw2Q0FBSztBQUNsQixhQUFhLDZDQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRLE1BQU0sUUFBUTtBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFTztBQUNQLFlBQVksYUFBYTtBQUN6QixZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLDRCQUE0QiwyQ0FBSTtBQUNoQyw4QkFBOEIsaURBQU87QUFDckM7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1AsK0NBQStDLGlCQUFpQjtBQUNoRTs7QUFFTztBQUNQLHFEQUFxRCxpQkFBaUI7QUFDdEU7O0FBRU87QUFDUCwrQ0FBK0MsaUJBQWlCO0FBQ2hFOztBQUVPO0FBQ1AseURBQXlELGlCQUFpQjtBQUMxRTs7QUFFQTs7QUFFTztBQUNQLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7O0FBRU87QUFDUCxvREFBb0QsZ0JBQWdCO0FBQ3BFOztBQUVPO0FBQ1AsOENBQThDLGdCQUFnQjtBQUM5RDs7QUFFTztBQUNQLHNEQUFzRCxnQkFBZ0I7QUFDdEU7O0FBRU87QUFDUCxzREFBc0QsZ0JBQWdCO0FBQ3RFOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRU87QUFDUCxpQ0FBaUMsaURBQU87QUFDeEM7O0FBRU87QUFDUCx3REFBd0QsaUJBQWlCO0FBQ3pFOztBQUVPO0FBQ1AsdURBQXVELGdCQUFnQjtBQUN2RTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsbURBQW1EO0FBQ25ELFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLHdCQUF3QiwyQ0FBSTtBQUM1QixvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pELFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxZQUFZLFNBQVM7QUFDckIsd0JBQXdCLDJDQUFJO0FBQzVCLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpREFBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSw2REFBNkQ7QUFDN0QsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsd0JBQXdCLDJDQUFJO0FBQzVCLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9pbnRlcnNlY3Rpb24ubWpzP2FjNGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgUG9seWdvbiB9IGZyb20gJy4vcG9seWdvbi5tanMnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vcmVjdC5tanMnO1xuaW1wb3J0IHsgdHlwZXMgfSBmcm9tICcuL3R5cGVzLm1qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCwgc2hhcGUyb3B0KSB7XG4gICAgc3dpdGNoIChzaGFwZTEudHlwZSkge1xuICAgICAgICBjYXNlIHR5cGVzLkxpbmU6IHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2hhcGUyLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmVXaXRoTGluZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGxpcHNlV2l0aExpbmUoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkVsbGlwc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsbGlwc2VXaXRoRWxsaXBzZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlcy5SZWN0OiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aExpbmUoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLkVsbGlwc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3RXaXRoRWxsaXBzZShzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUmVjdDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdFdpdGhSZWN0KHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHR5cGVzLlBvbHlsaW5lOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5bGluZVdpdGhMaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5bGluZVdpdGhFbGxpcHNlKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5SZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5bGluZVdpdGhSZWN0KHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5Qb2x5bGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoUG9seWxpbmUoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXMuUG9seWdvbjoge1xuICAgICAgICAgICAgc3dpdGNoIChzaGFwZTIudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuTGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9seWdvbldpdGhMaW5lKHNoYXBlMSwgc2hhcGUyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5FbGxpcHNlOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aEVsbGlwc2Uoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25XaXRoUmVjdChzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUG9seWxpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25XaXRoUG9seWxpbmUoc2hhcGUxLCBzaGFwZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlBvbHlnb246IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25XaXRoUG9seWdvbihzaGFwZTEsIHNoYXBlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlcy5QYXRoOiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5MaW5lOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoV2l0aExpbmUoc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhFbGxpcHNlKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHR5cGVzLlJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUmVjdChzaGFwZTEsIHNoYXBlMiwgc2hhcGUxb3B0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5Qb2x5bGluZToge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhQb2x5bGluZShzaGFwZTEsIHNoYXBlMiwgc2hhcGUxb3B0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlcy5Qb2x5Z29uOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoV2l0aFBvbHlnb24oc2hhcGUxLCBzaGFwZTIsIHNoYXBlMW9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXMuUGF0aDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhQYXRoKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTFvcHQsIHNoYXBlMm9wdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm9uZSBvZiB0aGUgY2FzZXMgYWJvdmVcbiAgICBzd2l0Y2ggKHNoYXBlMi50eXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXMuRWxsaXBzZTpcbiAgICAgICAgY2FzZSB0eXBlcy5SZWN0OlxuICAgICAgICBjYXNlIHR5cGVzLlBvbHlsaW5lOlxuICAgICAgICBjYXNlIHR5cGVzLlBvbHlnb246XG4gICAgICAgIGNhc2UgdHlwZXMuUGF0aDoge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cyhzaGFwZTIsIHNoYXBlMSwgc2hhcGUyb3B0LCBzaGFwZTFvcHQpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBUaGUgaW50ZXJzZWN0aW9uIGZvciAke3NoYXBlMX0gYW5kICR7c2hhcGUyfSBjb3VsZCBub3QgYmUgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qIExpbmUgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVXaXRoTGluZShsaW5lMSwgbGluZTIpIHtcbiAgICBjb25zdCB4MSA9IGxpbmUxLnN0YXJ0Lng7XG4gICAgY29uc3QgeTEgPSBsaW5lMS5zdGFydC55O1xuICAgIGNvbnN0IHgyID0gbGluZTEuZW5kLng7XG4gICAgY29uc3QgeTIgPSBsaW5lMS5lbmQueTtcbiAgICBjb25zdCB4MyA9IGxpbmUyLnN0YXJ0Lng7XG4gICAgY29uc3QgeTMgPSBsaW5lMi5zdGFydC55O1xuICAgIGNvbnN0IHg0ID0gbGluZTIuZW5kLng7XG4gICAgY29uc3QgeTQgPSBsaW5lMi5lbmQueTtcbiAgICBjb25zdCBzMXggPSB4MiAtIHgxO1xuICAgIGNvbnN0IHMxeSA9IHkyIC0geTE7XG4gICAgY29uc3QgczJ4ID0geDQgLSB4MztcbiAgICBjb25zdCBzMnkgPSB5NCAtIHkzO1xuICAgIGNvbnN0IHMzeCA9IHgxIC0geDM7XG4gICAgY29uc3QgczN5ID0geTEgLSB5MztcbiAgICBjb25zdCBwID0gczF4ICogczJ5IC0gczJ4ICogczF5O1xuICAgIGNvbnN0IHMgPSAoczF4ICogczN5IC0gczF5ICogczN4KSAvIHA7XG4gICAgY29uc3QgdCA9IChzMnggKiBzM3kgLSBzMnkgKiBzM3gpIC8gcDtcbiAgICByZXR1cm4gcyA+PSAwICYmIHMgPD0gMSAmJiB0ID49IDAgJiYgdCA8PSAxO1xufVxuXG4vKiBFbGxpcHNlICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbGxpcHNlV2l0aExpbmUoZWxsaXBzZSwgbGluZSkge1xuICAgIGNvbnN0IHJleCA9IGVsbGlwc2UuYTtcbiAgICBjb25zdCByZXkgPSBlbGxpcHNlLmI7XG4gICAgY29uc3QgeGUgPSBlbGxpcHNlLng7XG4gICAgY29uc3QgeWUgPSBlbGxpcHNlLnk7XG4gICAgY29uc3QgeDEgPSBsaW5lLnN0YXJ0LnggLSB4ZTtcbiAgICBjb25zdCB4MiA9IGxpbmUuZW5kLnggLSB4ZTtcbiAgICBjb25zdCB5MSA9IGxpbmUuc3RhcnQueSAtIHllO1xuICAgIGNvbnN0IHkyID0gbGluZS5lbmQueSAtIHllO1xuICAgIGNvbnN0IHJleF8yID0gcmV4ICogcmV4O1xuICAgIGNvbnN0IHJleV8yID0gcmV5ICogcmV5O1xuICAgIGNvbnN0IGR4ID0geDIgLSB4MTtcbiAgICBjb25zdCBkeSA9IHkyIC0geTE7XG4gICAgY29uc3QgQSA9IGR4ICogZHggLyByZXhfMiArIGR5ICogZHkgLyByZXlfMjtcbiAgICBjb25zdCBCID0gMiAqIHgxICogZHggLyByZXhfMiArIDIgKiB5MSAqIGR5IC8gcmV5XzI7XG4gICAgY29uc3QgQyA9IHgxICogeDEgLyByZXhfMiArIHkxICogeTEgLyByZXlfMiAtIDE7XG4gICAgY29uc3QgRCA9IEIgKiBCIC0gNCAqIEEgKiBDO1xuICAgIGlmIChEID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHQgPSAtQiAvIDIgLyBBO1xuICAgICAgICByZXR1cm4gdCA+PSAwICYmIHQgPD0gMTtcbiAgICB9IGVsc2UgaWYgKEQgPiAwKSB7XG4gICAgICAgIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQoRCk7XG4gICAgICAgIGNvbnN0IHQxID0gKC1CICsgc3FydCkgLyAyIC8gQTtcbiAgICAgICAgY29uc3QgdDIgPSAoLUIgLSBzcXJ0KSAvIDIgLyBBO1xuICAgICAgICByZXR1cm4gKHQxID49IDAgJiYgdDEgPD0gMSkgfHwgKHQyID49IDAgJiYgdDIgPD0gMSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2VXaXRoRWxsaXBzZShlbGxpcHNlMSwgZWxsaXBzZTIpIHtcbiAgICByZXR1cm4gX2VsbGlwc2VzSW50ZXJzZWN0aW9uKGVsbGlwc2UxLCAwLCBlbGxpcHNlMiwgMCk7XG59XG5cbi8qIFJlY3QgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RXaXRoTGluZShyZWN0LCBsaW5lKSB7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBsaW5lO1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBpZiAoXG4gICAgICAgIChzdGFydC54ID4geCArIHdpZHRoICYmIGVuZC54ID4geCArIHdpZHRoKVxuICAgICAgICB8fCAoc3RhcnQueCA8IHggJiYgZW5kLnggPCB4KVxuICAgICAgICB8fCAoc3RhcnQueSA+IHkgKyBoZWlnaHQgJiYgZW5kLnkgPiB5ICsgaGVpZ2h0KVxuICAgICAgICB8fCAoc3RhcnQueSA8IHkgJiYgZW5kLnkgPCB5KVxuICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyZWN0LmNvbnRhaW5zUG9pbnQobGluZS5zdGFydCkgfHwgcmVjdC5jb250YWluc1BvaW50KGxpbmUuZW5kKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVXaXRoTGluZShyZWN0LnRvcExpbmUoKSwgbGluZSlcbiAgICAgICAgfHwgbGluZVdpdGhMaW5lKHJlY3QucmlnaHRMaW5lKCksIGxpbmUpXG4gICAgICAgIHx8IGxpbmVXaXRoTGluZShyZWN0LmJvdHRvbUxpbmUoKSwgbGluZSlcbiAgICAgICAgfHwgbGluZVdpdGhMaW5lKHJlY3QubGVmdExpbmUoKSwgbGluZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWN0V2l0aEVsbGlwc2UocmVjdCwgZWxsaXBzZSkge1xuICAgIGlmICghcmVjdFdpdGhSZWN0KHJlY3QsIFJlY3QuZnJvbUVsbGlwc2UoZWxsaXBzZSkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHBvbHlnb25XaXRoRWxsaXBzZShQb2x5Z29uLmZyb21SZWN0KHJlY3QpLCBlbGxpcHNlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY3RXaXRoUmVjdChyZWN0MSwgcmVjdDIpIHtcbiAgICByZXR1cm4gcmVjdDEueCA8IHJlY3QyLnggKyByZWN0Mi53aWR0aFxuICAgICAgICAmJiByZWN0MS54ICsgcmVjdDEud2lkdGggPiByZWN0Mi54XG4gICAgICAgICYmIHJlY3QxLnkgPCByZWN0Mi55ICsgcmVjdDIuaGVpZ2h0XG4gICAgICAgICYmIHJlY3QxLnkgKyByZWN0MS5oZWlnaHQgPiByZWN0Mi55O1xufVxuXG4vKiBQb2x5bGluZSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmVXaXRoTGluZShwb2x5bGluZSwgbGluZSkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoTGluZShwb2x5bGluZSwgbGluZSwgeyBpbnRlcmlvcjogZmFsc2UgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5bGluZVdpdGhFbGxpcHNlKHBvbHlsaW5lLCBlbGxpcHNlKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhFbGxpcHNlKHBvbHlsaW5lLCBlbGxpcHNlLCB7IGludGVyaW9yOiBmYWxzZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlsaW5lV2l0aFJlY3QocG9seWxpbmUsIHJlY3QpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFJlY3QocG9seWxpbmUsIHJlY3QsIHsgaW50ZXJpb3I6IGZhbHNlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWxpbmVXaXRoUG9seWxpbmUocG9seWxpbmUxLCBwb2x5bGluZTIpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlsaW5lMSwgcG9seWxpbmUyLCB7IGludGVyaW9yOiBmYWxzZSB9KTtcbn1cblxuLyogUG9seWdvbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbldpdGhMaW5lKHBvbHlnb24sIGxpbmUpIHtcbiAgICByZXR1cm4gX3BvbHlsaW5lV2l0aExpbmUocG9seWdvbiwgbGluZSwgeyBpbnRlcmlvcjogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25XaXRoRWxsaXBzZShwb2x5Z29uLCBlbGxpcHNlKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhFbGxpcHNlKHBvbHlnb24sIGVsbGlwc2UsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uV2l0aFJlY3QocG9seWdvbiwgcmVjdCkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoUmVjdChwb2x5Z29uLCByZWN0LCB7IGludGVyaW9yOiB0cnVlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbldpdGhQb2x5bGluZShwb2x5Z29uLCBwb2x5bGluZSkge1xuICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWxpbmUocG9seWdvbiwgcG9seWxpbmUsIHsgaW50ZXJpb3I6IHRydWUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uV2l0aFBvbHlnb24ocG9seWdvbjEsIHBvbHlnb24yKSB7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhQb2x5Z29uKHBvbHlnb24xLCBwb2x5Z29uMiwgeyBpbnRlcmlvcjogdHJ1ZSB9KTtcbn1cblxuLyogUGF0aCAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhMaW5lKHBhdGgsIGxpbmUsIHBhdGhPcHQpIHtcbiAgICByZXR1cm4gcGF0aC5nZXRTdWJwYXRocygpLnNvbWUoc3VicGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IFtwb2x5bGluZV0gPSBzdWJwYXRoLnRvUG9seWxpbmVzKHBhdGhPcHQpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN1YnBhdGguZ2V0U2VnbWVudCgtMSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uV2l0aExpbmUocG9seWxpbmUsIGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlsaW5lV2l0aExpbmUocG9seWxpbmUsIGxpbmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRoV2l0aEVsbGlwc2UocGF0aCwgZWxsaXBzZSwgcGF0aE9wdCkge1xuICAgIHJldHVybiBwYXRoLmdldFN1YnBhdGhzKCkuc29tZShzdWJwYXRoID0+IHtcbiAgICAgICAgY29uc3QgW3BvbHlsaW5lXSA9IHN1YnBhdGgudG9Qb2x5bGluZXMocGF0aE9wdCk7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3VicGF0aC5nZXRTZWdtZW50KC0xKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25XaXRoRWxsaXBzZShwb2x5bGluZSwgZWxsaXBzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcG9seWxpbmVXaXRoRWxsaXBzZShwb2x5bGluZSwgZWxsaXBzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoUmVjdChwYXRoLCByZWN0LCBwYXRoT3B0KSB7XG4gICAgcmV0dXJuIHBhdGhXaXRoUG9seWdvbihwYXRoLCBQb2x5Z29uLmZyb21SZWN0KHJlY3QpLCBwYXRoT3B0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoUG9seWxpbmUocGF0aCwgcG9seWxpbmUsIHBhdGhPcHQpIHtcbiAgICByZXR1cm4gX3BhdGhXaXRoUG9seWxpbmUocGF0aCwgcG9seWxpbmUsIHBhdGhPcHQsIHsgaW50ZXJpb3I6IGZhbHNlIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFdpdGhQb2x5Z29uKHBhdGgsIHBvbHlnb24sIHBhdGhPcHQpIHtcbiAgICByZXR1cm4gX3BhdGhXaXRoUG9seWxpbmUocGF0aCwgcG9seWdvbiwgcGF0aE9wdCwgeyBpbnRlcmlvcjogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhdGhXaXRoUGF0aChwYXRoMSwgcGF0aDIsIHBhdGhPcHQxLCBwYXRoT3B0Mikge1xuICAgIHJldHVybiBwYXRoMS5nZXRTdWJwYXRocygpLnNvbWUoc3VicGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IFtwb2x5bGluZTFdID0gc3VicGF0aC50b1BvbHlsaW5lcyhwYXRoT3B0MSk7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3VicGF0aC5nZXRTZWdtZW50KC0xKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGhXaXRoUG9seWdvbihwYXRoMiwgcG9seWxpbmUxLCBwYXRoT3B0Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aFdpdGhQb2x5bGluZShwYXRoMiwgcG9seWxpbmUxLCBwYXRoT3B0Mik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX3BvbHlsaW5lV2l0aExpbmUocG9seWxpbmUsIGxpbmUsIG9wdCA9IHt9KSB7XG4gICAgY29uc3QgeyBpbnRlcmlvciA9IGZhbHNlIH0gPSBvcHQ7XG4gICAgbGV0IHRoaXNQb2ludHM7XG4gICAgaWYgKGludGVyaW9yKSB7XG4gICAgICAgIGlmIChwb2x5bGluZS5jb250YWluc1BvaW50KGxpbmUuc3RhcnQpKSB7XG4gICAgICAgICAgICAvLyBJZiBhbnkgcG9pbnQgb2YgdGhlIHBvbHlsaW5lIGxpZXMgaW5zaWRlIHRoaXMgcG9seWdvbiAoaW50ZXJpb3IgPSB0cnVlKVxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYW4gaW50ZXJzZWN0aW9uICh3ZSd2ZSBjaG9zZW4gdGhlIHN0YXJ0IHBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCBwb2ludHMgfSA9IHBvbHlsaW5lO1xuICAgICAgICB0aGlzUG9pbnRzID0gZW5kLmVxdWFscyhzdGFydCkgPyBwb2ludHMgOiBbLi4ucG9pbnRzLCBzdGFydF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1BvaW50cyA9IHBvbHlsaW5lLnBvaW50cztcbiAgICB9XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHRoaXNQb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudCA9IG5ldyBMaW5lKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgc2VnbWVudC5zdGFydCA9IHRoaXNQb2ludHNbaV07XG4gICAgICAgIHNlZ21lbnQuZW5kID0gdGhpc1BvaW50c1tpICsgMV07XG4gICAgICAgIGlmIChsaW5lV2l0aExpbmUobGluZSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3BvbHlsaW5lV2l0aEVsbGlwc2UocG9seWxpbmUsIGVsbGlwc2UsIG9wdCA9IHt9KSB7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCBwb2ludHMgfSA9IHBvbHlsaW5lO1xuICAgIGlmIChlbGxpcHNlLmNvbnRhaW5zUG9pbnQoc3RhcnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgdGhpc1BvaW50cztcbiAgICBjb25zdCB7IGludGVyaW9yID0gZmFsc2UgfSA9IG9wdDtcbiAgICBpZiAoaW50ZXJpb3IpIHtcbiAgICAgICAgaWYgKHBvbHlsaW5lLmNvbnRhaW5zUG9pbnQoZWxsaXBzZS5jZW50ZXIoKSkpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBwb2ludCBvZiB0aGUgZWxsaXBzZSBsaWVzIGluc2lkZSB0aGlzIHBvbHlnb24gKGludGVyaW9yID0gdHJ1ZSlcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiAod2UndmUgY2hvc2VuIHRoZSBjZW50ZXIgcG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzUG9pbnRzID0gZW5kLmVxdWFscyhzdGFydCkgPyBwb2ludHMgOiBbLi4ucG9pbnRzLCBzdGFydF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1BvaW50cyA9IHBvaW50cztcbiAgICB9XG5cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gdGhpc1BvaW50cztcbiAgICBjb25zdCBzZWdtZW50ID0gbmV3IExpbmUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBzZWdtZW50LnN0YXJ0ID0gdGhpc1BvaW50c1tpXTtcbiAgICAgICAgc2VnbWVudC5lbmQgPSB0aGlzUG9pbnRzW2kgKyAxXTtcbiAgICAgICAgaWYgKGVsbGlwc2VXaXRoTGluZShlbGxpcHNlLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcG9seWxpbmVXaXRoUmVjdChwb2x5bGluZSwgcmVjdCwgb3B0KSB7XG4gICAgY29uc3QgcG9seWdvbiA9IFBvbHlnb24uZnJvbVJlY3QocmVjdCk7XG4gICAgcmV0dXJuIF9wb2x5bGluZVdpdGhQb2x5Z29uKHBvbHlsaW5lLCBwb2x5Z29uLCBvcHQpO1xufVxuXG5mdW5jdGlvbiBfcGF0aFdpdGhQb2x5bGluZShwYXRoLCBwb2x5bGluZTEsIHBhdGhPcHQsIG9wdCkge1xuICAgIHJldHVybiBwYXRoLmdldFN1YnBhdGhzKCkuc29tZShzdWJwYXRoID0+IHtcbiAgICAgICAgY29uc3QgW3BvbHlsaW5lMl0gPSBzdWJwYXRoLnRvUG9seWxpbmVzKHBhdGhPcHQpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHN1YnBhdGguZ2V0U2VnbWVudCgtMSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWdvbihwb2x5bGluZTEsIHBvbHlsaW5lMiwgb3B0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfcG9seWxpbmVXaXRoUG9seWxpbmUocG9seWxpbmUxLCBwb2x5bGluZTIsIG9wdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX3BvbHlsaW5lV2l0aFBvbHlsaW5lKHBvbHlsaW5lMSwgcG9seWxpbmUyLCBvcHQgPSB7fSkge1xuICAgIGNvbnN0IHsgaW50ZXJpb3IgPSBmYWxzZSB9ID0gb3B0O1xuICAgIGxldCB0aGlzUG9seWxpbmU7XG4gICAgaWYgKGludGVyaW9yKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQgfSA9IHBvbHlsaW5lMjtcbiAgICAgICAgaWYgKHBvbHlsaW5lMS5jb250YWluc1BvaW50KHN0YXJ0KSkge1xuICAgICAgICAgICAgLy8gSWYgYW55IHBvaW50IG9mIHRoZSBwb2x5bGluZSBsaWVzIGluc2lkZSB0aGlzIHBvbHlnb24gKGludGVyaW9yID0gdHJ1ZSlcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiAod2UndmUgY2hvc2VuIHRoZSBzdGFydCBwb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNQb2x5bGluZSA9IHBvbHlsaW5lMS5jbG9uZSgpLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1BvbHlsaW5lID0gcG9seWxpbmUxO1xuICAgIH1cbiAgICBjb25zdCBvdGhlclBvaW50cyA9IHBvbHlsaW5lMi5wb2ludHM7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG90aGVyUG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgTGluZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHNlZ21lbnQuc3RhcnQgPSBvdGhlclBvaW50c1tpXTtcbiAgICAgICAgc2VnbWVudC5lbmQgPSBvdGhlclBvaW50c1tpICsgMV07XG4gICAgICAgIGlmIChwb2x5bGluZVdpdGhMaW5lKHRoaXNQb2x5bGluZSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3BvbHlsaW5lV2l0aFBvbHlnb24ocG9seWxpbmUsIHBvbHlnb24sIG9wdCkge1xuICAgIHJldHVybiBwb2x5Z29uLmNvbnRhaW5zUG9pbnQocG9seWxpbmUuc3RhcnQpIHx8IF9wb2x5bGluZVdpdGhQb2x5bGluZShwb2x5bGluZSwgcG9seWdvbi5jbG9uZSgpLmNsb3NlKCksIG9wdCk7XG59XG5cbmZ1bmN0aW9uIF9lbGxpcHNlc0ludGVyc2VjdGlvbihlMSwgdzEsIGUyLCB3Mikge1xuICAgIGNvbnN0IHsgY29zLCBzaW4gfSA9IE1hdGg7XG4gICAgY29uc3Qgc2luVzEgPSBzaW4odzEpO1xuICAgIGNvbnN0IGNvc1cxID0gY29zKHcxKTtcbiAgICBjb25zdCBzaW5XMiA9IHNpbih3Mik7XG4gICAgY29uc3QgY29zVzIgPSBjb3ModzIpO1xuICAgIGNvbnN0IHNpblcxcyA9IHNpblcxICogc2luVzE7XG4gICAgY29uc3QgY29zVzFzID0gY29zVzEgKiBjb3NXMTtcbiAgICBjb25zdCBzaW5Db3MxID0gc2luVzEgKiBjb3NXMTtcbiAgICBjb25zdCBzaW5XMnMgPSBzaW5XMiAqIHNpblcyO1xuICAgIGNvbnN0IGNvc1cycyA9IGNvc1cyICogY29zVzI7XG4gICAgY29uc3Qgc2luQ29zMiA9IHNpblcyICogY29zVzI7XG4gICAgY29uc3QgYTFzID0gZTEuYSAqIGUxLmE7XG4gICAgY29uc3QgYjFzID0gZTEuYiAqIGUxLmI7XG4gICAgY29uc3QgYTJzID0gZTIuYSAqIGUyLmE7XG4gICAgY29uc3QgYjJzID0gZTIuYiAqIGUyLmI7XG4gICAgY29uc3QgQTEgPSBhMXMgKiBzaW5XMXMgKyBiMXMgKiBjb3NXMXM7XG4gICAgY29uc3QgQTIgPSBhMnMgKiBzaW5XMnMgKyBiMnMgKiBjb3NXMnM7XG4gICAgY29uc3QgQjEgPSBhMXMgKiBjb3NXMXMgKyBiMXMgKiBzaW5XMXM7XG4gICAgY29uc3QgQjIgPSBhMnMgKiBjb3NXMnMgKyBiMnMgKiBzaW5XMnM7XG4gICAgbGV0IEMxID0gMiAqIChiMXMgLSBhMXMpICogc2luQ29zMTtcbiAgICBsZXQgQzIgPSAyICogKGIycyAtIGEycykgKiBzaW5Db3MyO1xuICAgIGxldCBEMSA9ICgtMiAqIEExICogZTEueCAtIEMxICogZTEueSk7XG4gICAgbGV0IEQyID0gKC0yICogQTIgKiBlMi54IC0gQzIgKiBlMi55KTtcbiAgICBsZXQgRTEgPSAoLUMxICogZTEueCAtIDIgKiBCMSAqIGUxLnkpO1xuICAgIGxldCBFMiA9ICgtQzIgKiBlMi54IC0gMiAqIEIyICogZTIueSk7XG4gICAgY29uc3QgRjEgPSBBMSAqIGUxLnggKiBlMS54ICsgQjEgKiBlMS55ICogZTEueSArIEMxICogZTEueCAqIGUxLnkgLSBhMXMgKiBiMXM7XG4gICAgY29uc3QgRjIgPSBBMiAqIGUyLnggKiBlMi54ICsgQjIgKiBlMi55ICogZTIueSArIEMyICogZTIueCAqIGUyLnkgLSBhMnMgKiBiMnM7XG5cbiAgICBDMSA9IEMxIC8gMjtcbiAgICBDMiA9IEMyIC8gMjtcbiAgICBEMSA9IEQxIC8gMjtcbiAgICBEMiA9IEQyIC8gMjtcbiAgICBFMSA9IEUxIC8gMjtcbiAgICBFMiA9IEUyIC8gMjtcblxuICAgIGNvbnN0IGwzID0gZGV0MyhbXG4gICAgICAgIFtBMSwgQzEsIEQxXSxcbiAgICAgICAgW0MxLCBCMSwgRTFdLFxuICAgICAgICBbRDEsIEUxLCBGMV1cbiAgICBdKTtcbiAgICBjb25zdCBsMCA9IGRldDMoW1xuICAgICAgICBbQTIsIEMyLCBEMl0sXG4gICAgICAgIFtDMiwgQjIsIEUyXSxcbiAgICAgICAgW0QyLCBFMiwgRjJdXG4gICAgXSk7XG4gICAgY29uc3QgbDIgPSAwLjMzMzMzMzMzICogKGRldDMoW1xuICAgICAgICBbQTIsIEMxLCBEMV0sXG4gICAgICAgIFtDMiwgQjEsIEUxXSxcbiAgICAgICAgW0QyLCBFMSwgRjFdXG4gICAgXSkgKyBkZXQzKFtcbiAgICAgICAgW0ExLCBDMiwgRDFdLFxuICAgICAgICBbQzEsIEIyLCBFMV0sXG4gICAgICAgIFtEMSwgRTIsIEYxXVxuICAgIF0pICsgZGV0MyhbXG4gICAgICAgIFtBMSwgQzEsIEQyXSxcbiAgICAgICAgW0MxLCBCMSwgRTJdLFxuICAgICAgICBbRDEsIEUxLCBGMl1cbiAgICBdKSk7XG4gICAgY29uc3QgbDEgPSAwLjMzMzMzMzMzICogKGRldDMoW1xuICAgICAgICBbQTEsIEMyLCBEMl0sXG4gICAgICAgIFtDMSwgQjIsIEUyXSxcbiAgICAgICAgW0QxLCBFMiwgRjJdXG4gICAgXSkgKyBkZXQzKFtcbiAgICAgICAgW0EyLCBDMSwgRDJdLFxuICAgICAgICBbQzIsIEIxLCBFMl0sXG4gICAgICAgIFtEMiwgRTEsIEYyXVxuICAgIF0pICsgZGV0MyhbXG4gICAgICAgIFtBMiwgQzIsIEQxXSxcbiAgICAgICAgW0MyLCBCMiwgRTFdLFxuICAgICAgICBbRDIsIEUyLCBGMV1cbiAgICBdKSk7XG5cbiAgICBjb25zdCBkZWx0YTEgPSBkZXQyKFtcbiAgICAgICAgW2wzLCBsMl0sXG4gICAgICAgIFtsMiwgbDFdXG4gICAgXSk7XG4gICAgY29uc3QgZGVsdGEyID0gZGV0MihbXG4gICAgICAgIFtsMywgbDFdLFxuICAgICAgICBbbDIsIGwwXVxuICAgIF0pO1xuICAgIGNvbnN0IGRlbHRhMyA9IGRldDIoW1xuICAgICAgICBbbDIsIGwxXSxcbiAgICAgICAgW2wxLCBsMF1cbiAgICBdKTtcblxuICAgIGNvbnN0IGRQID0gZGV0MihbXG4gICAgICAgIFsyICogZGVsdGExLCBkZWx0YTJdLFxuICAgICAgICBbZGVsdGEyLCAyICogZGVsdGEzXVxuICAgIF0pO1xuXG4gICAgaWYgKGRQID4gMCAmJiAobDEgPiAwIHx8IGwyID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGV0MihtKSB7XG4gICAgcmV0dXJuIG1bMF1bMF0gKiBtWzFdWzFdIC0gbVswXVsxXSAqIG1bMV1bMF07XG59XG5cbmZ1bmN0aW9uIGRldDMobSkge1xuICAgIHJldHVybiBtWzBdWzBdICogbVsxXVsxXSAqIG1bMl1bMl0gLVxuICAgICAgICBtWzBdWzBdICogbVsxXVsyXSAqIG1bMl1bMV0gLVxuICAgICAgICBtWzBdWzFdICogbVsxXVswXSAqIG1bMl1bMl0gK1xuICAgICAgICBtWzBdWzFdICogbVsxXVsyXSAqIG1bMl1bMF0gK1xuICAgICAgICBtWzBdWzJdICogbVsxXVswXSAqIG1bMl1bMV0gLVxuICAgICAgICBtWzBdWzJdICogbVsxXVsxXSAqIG1bMl1bMF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/intersection.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/line.bearing.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.bearing.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bearing: function() { return /* binding */ bearing; }\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n// @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n// @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n\n\nconst {\n    cos,\n    sin,\n    atan2\n} = Math;\n\nconst bearing = function(p, q) {\n\n    var lat1 = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(p.y);\n    var lat2 = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(q.y);\n    var lon1 = p.x;\n    var lon2 = q.x;\n    var dLon = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(lon2 - lon1);\n    var y = sin(dLon) * cos(lat2);\n    var x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(dLon);\n    var brng = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg)(atan2(y, x));\n\n    var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n\n    var index = brng - 22.5;\n    if (index < 0)\n        index += 360;\n    index = parseInt(index / 45);\n\n    return bearings[index];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLmJlYXJpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQSxhQUFhLFFBQVE7QUFDaUM7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFSzs7QUFFUCxlQUFlLDREQUFLO0FBQ3BCLGVBQWUsNERBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsNERBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsNERBQUs7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL2xpbmUuYmVhcmluZy5tanM/MjAzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAcmV0dXJuIHRoZSBiZWFyaW5nIChjYXJkaW5hbCBkaXJlY3Rpb24pIG9mIHRoZSBsaW5lLiBGb3IgZXhhbXBsZSBOLCBXLCBvciBTRS5cbi8vIEByZXR1cm5zIHtTdHJpbmd9IE9uZSBvZiB0aGUgZm9sbG93aW5nIGJlYXJpbmdzIDogTkUsIEUsIFNFLCBTLCBTVywgVywgTlcsIE4uXG5pbXBvcnQgeyB0b0RlZywgdG9SYWQgfSBmcm9tICcuL2dlb21ldHJ5LmhlbHBlcnMubWpzJztcblxuY29uc3Qge1xuICAgIGNvcyxcbiAgICBzaW4sXG4gICAgYXRhbjJcbn0gPSBNYXRoO1xuXG5leHBvcnQgY29uc3QgYmVhcmluZyA9IGZ1bmN0aW9uKHAsIHEpIHtcblxuICAgIHZhciBsYXQxID0gdG9SYWQocC55KTtcbiAgICB2YXIgbGF0MiA9IHRvUmFkKHEueSk7XG4gICAgdmFyIGxvbjEgPSBwLng7XG4gICAgdmFyIGxvbjIgPSBxLng7XG4gICAgdmFyIGRMb24gPSB0b1JhZChsb24yIC0gbG9uMSk7XG4gICAgdmFyIHkgPSBzaW4oZExvbikgKiBjb3MobGF0Mik7XG4gICAgdmFyIHggPSBjb3MobGF0MSkgKiBzaW4obGF0MikgLSBzaW4obGF0MSkgKiBjb3MobGF0MikgKiBjb3MoZExvbik7XG4gICAgdmFyIGJybmcgPSB0b0RlZyhhdGFuMih5LCB4KSk7XG5cbiAgICB2YXIgYmVhcmluZ3MgPSBbJ05FJywgJ0UnLCAnU0UnLCAnUycsICdTVycsICdXJywgJ05XJywgJ04nXTtcblxuICAgIHZhciBpbmRleCA9IGJybmcgLSAyMi41O1xuICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgIGluZGV4ICs9IDM2MDtcbiAgICBpbmRleCA9IHBhcnNlSW50KGluZGV4IC8gNDUpO1xuXG4gICAgcmV0dXJuIGJlYXJpbmdzW2luZGV4XTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/line.bearing.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/line.length.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.length.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   length: function() { return /* binding */ length; }\n/* harmony export */ });\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\");\n\n\nconst length = function(start, end) {\n    return Math.sqrt((0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_0__.squaredLength)(start, end));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLmxlbmd0aC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUQ7O0FBRWxEO0FBQ1AscUJBQXFCLHNFQUFhO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLmxlbmd0aC5tanM/ZTI5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzcXVhcmVkTGVuZ3RoIH0gZnJvbSAnLi9saW5lLnNxdWFyZWRMZW5ndGgubWpzJztcblxuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNxdWFyZWRMZW5ndGgoc3RhcnQsIGVuZCkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/line.length.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Line: function() { return /* binding */ Line; },\n/* harmony export */   line: function() { return /* binding */ line; }\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _line_bearing_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.bearing.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.bearing.mjs\");\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\");\n/* harmony import */ var _line_length_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.length.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.length.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\n\n\nconst {\n    max,\n    min\n} = Math;\n\nconst Line = function(p1, p2) {\n\n    if (!(this instanceof Line)) {\n        return new Line(p1, p2);\n    }\n\n    if (p1 instanceof Line) {\n        return new Line(p1.start, p1.end);\n    }\n\n    this.start = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1);\n    this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2);\n};\n\nLine.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Line,\n\n    // @returns the angle of incline of the line.\n    angle: function() {\n\n        var horizontalPoint = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontalPoint);\n    },\n\n    bbox: function() {\n\n        var left = min(this.start.x, this.end.x);\n        var top = min(this.start.y, this.end.y);\n        var right = max(this.start.x, this.end.x);\n        var bottom = max(this.start.y, this.end.y);\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_2__.Rect(left, top, (right - left), (bottom - top));\n    },\n\n    // @return the bearing (cardinal direction) of the line. For example N, W, or SE.\n    // @returns {String} One of the following bearings : NE, E, SE, S, SW, W, NW, N.\n    bearing: function() {\n        return (0,_line_bearing_mjs__WEBPACK_IMPORTED_MODULE_3__.bearing)(this.start, this.end);\n    },\n\n    clone: function() {\n\n        return new Line(this.start, this.end);\n    },\n\n    // @return {point} the closest point on the line to point `p`\n    closestPoint: function(p) {\n\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    },\n\n    closestPointLength: function(p) {\n\n        return this.closestPointNormalizedLength(p) * this.length();\n    },\n\n    // @return {number} the normalized length of the closest point on the line to point `p`\n    closestPointNormalizedLength: function(p) {\n\n        var product = this.vector().dot((new Line(this.start, p)).vector());\n        var cpNormalizedLength = min(1, max(0, product / this.squaredLength()));\n\n        // cpNormalizedLength returns `NaN` if this line has zero length\n        // we can work with that - if `NaN`, return 0\n        if (cpNormalizedLength !== cpNormalizedLength) return 0; // condition evaluates to `true` if and only if cpNormalizedLength is `NaN`\n        // (`NaN` is the only value that is not equal to itself)\n\n        return cpNormalizedLength;\n    },\n\n    closestPointTangent: function(p) {\n\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    },\n\n    // Returns `true` if the point lies on the line.\n    containsPoint: function(p) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (start.cross(p, end) !== 0) return false;\n        // else: cross product of 0 indicates that this line and the vector to `p` are collinear\n\n        var length = this.length();\n        if ((new Line(start, p)).length() > length) return false;\n        if ((new Line(p, end)).length() > length) return false;\n        // else: `p` lies between start and end of the line\n\n        return true;\n    },\n\n    // Divides the line into two at requested `ratio` between 0 and 1.\n    divideAt: function(ratio) {\n\n        var dividerPoint = this.pointAt(ratio);\n\n        // return array with two lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    // Divides the line into two at requested `length`.\n    divideAtLength: function(length) {\n\n        var dividerPoint = this.pointAtLength(length);\n\n        // return array with two new lines\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end)\n        ];\n    },\n\n    equals: function(l) {\n\n        return !!l &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y;\n    },\n\n    // @return {point} Point where I'm intersecting a line.\n    // @return [point] Points where I'm intersecting a rectangle.\n    // @see Squeak Smalltalk, LineSegment>>intersectionWith:\n    intersect: function(shape, opt) {\n\n        if (shape && shape.intersectionWithLine) {\n            var intersection = shape.intersectionWithLine(this, opt);\n\n            // Backwards compatibility\n            if (intersection && (shape instanceof Line)) {\n                intersection = intersection[0];\n            }\n\n            return intersection;\n        }\n\n        return null;\n    },\n\n    intersectionWithLine: function(line) {\n\n        var pt1Dir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        var pt2Dir = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        var det = (pt1Dir.x * pt2Dir.y) - (pt1Dir.y * pt2Dir.x);\n        var deltaPt = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        var alpha = (deltaPt.x * pt2Dir.y) - (deltaPt.y * pt2Dir.x);\n        var beta = (deltaPt.x * pt1Dir.y) - (deltaPt.y * pt1Dir.x);\n\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            // No intersection found.\n            return null;\n        }\n\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n\n        } else {\n            if (alpha < det || beta < det) {\n                return null;\n            }\n        }\n\n        return [new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n            this.start.x + (alpha * pt1Dir.x / det),\n            this.start.y + (alpha * pt1Dir.y / det)\n        )];\n    },\n\n    isDifferentiable: function() {\n\n        return !this.start.equals(this.end);\n    },\n\n    // @return {double} length of the line\n    length: function() {\n        return (0,_line_length_mjs__WEBPACK_IMPORTED_MODULE_4__.length)(this.start, this.end);\n    },\n\n    // @return {point} my midpoint\n    midpoint: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(\n            (this.start.x + this.end.x) / 2,\n            (this.start.y + this.end.y) / 2\n        );\n    },\n\n    parallel: function(distance) {\n        const l = this.clone();\n        if (!this.isDifferentiable()) return l;\n        const { start, end } = l;\n        const eRef = start.clone().rotate(end, 270);\n        const sRef = end.clone().rotate(start, 90);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return l;\n    },\n\n    // @return {point} my point at 't' <0,1>\n    pointAt: function(t) {\n\n        var start = this.start;\n        var end = this.end;\n\n        if (t <= 0) return start.clone();\n        if (t >= 1) return end.clone();\n\n        return start.lerp(end, t);\n    },\n\n    pointAtLength: function(length) {\n\n        var start = this.start;\n        var end = this.end;\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lineLength = this.length();\n        if (length >= lineLength) return (fromStart ? end.clone() : start.clone());\n\n        return this.pointAt((fromStart ? (length) : (lineLength - length)) / lineLength);\n    },\n\n    // @return {number} the offset of the point `p` from the line. + if the point `p` is on the right side of the line, - if on the left and 0 if on the line.\n    pointOffset: function(p) {\n\n        // Find the sign of the determinant of vectors (start,end), where p is the query point.\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p);\n        var start = this.start;\n        var end = this.end;\n        var determinant = ((end.x - start.x) * (p.y - start.y) - (end.y - start.y) * (p.x - start.x));\n\n        return determinant / this.length();\n    },\n\n    rotate: function(origin, angle) {\n\n        this.start.rotate(origin, angle);\n        this.end.rotate(origin, angle);\n        return this;\n    },\n\n    round: function(precision) {\n\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    // @return {number} scale the line so that it has the requested length\n    setLength: function(length) {\n\n        var currentLength = this.length();\n        if (!currentLength) return this;\n\n        var scaleFactor = length / currentLength;\n        return this.scale(scaleFactor, scaleFactor, this.start);\n    },\n\n    // @return {integer} length without sqrt\n    // @note for applications where the exact length is not necessary (e.g. compare only)\n    squaredLength: function() {\n        return (0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_5__.squaredLength)(this.start, this.end);\n    },\n\n    tangentAt: function(t) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAt(t); // constrains `t` between 0 and 1\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    tangentAtLength: function(length) {\n\n        if (!this.isDifferentiable()) return null;\n\n        var start = this.start;\n        var end = this.end;\n\n        var tangentStart = this.pointAtLength(length);\n\n        var tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y); // move so that tangent line starts at the point requested\n\n        return tangentLine;\n    },\n\n    toString: function() {\n\n        return this.start.toString() + ' ' + this.end.toString();\n    },\n\n    serialize: function() {\n\n        return this.start.serialize() + ' ' + this.end.serialize();\n    },\n\n    translate: function(tx, ty) {\n\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    },\n\n    // @return vector {point} of the line\n    vector: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n};\n\n// For backwards compatibility:\nLine.prototype.intersection = Line.prototype.intersect;\n\n\n// For backwards compatibility:\nconst line = Line;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvQztBQUNGO0FBQ1c7QUFDWTtBQUNkO0FBQ1A7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUs7O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsNkNBQUs7QUFDMUIsbUJBQW1CLDZDQUFLO0FBQ3hCOztBQUVBOztBQUVBLFVBQVUsNkNBQUs7O0FBRWY7QUFDQTs7QUFFQSxrQ0FBa0MsNkNBQUs7QUFDdkM7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwyQ0FBSTtBQUN2QixLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxlQUFlLDBEQUFPO0FBQ3RCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixPQUFPO0FBQ3ZCOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSx5QkFBeUIsNkNBQUs7QUFDOUIseUJBQXlCLDZDQUFLO0FBQzlCO0FBQ0EsMEJBQTBCLDZDQUFLO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw2Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGVBQWUsd0RBQU07QUFDckIsS0FBSzs7QUFFTCxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQSxtQkFBbUIsNkNBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLFFBQVE7QUFDeEI7O0FBRUE7QUFDQSxnQkFBZ0IsNkNBQUs7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsUUFBUTtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxlQUFlLHNFQUFhO0FBQzVCLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0EsbUZBQW1GOztBQUVuRjtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx1QkFBdUIsT0FBTztBQUM5Qjs7QUFFQSxtQkFBbUIsNkNBQUs7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLm1qcz81OWQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vcmVjdC5tanMnO1xuaW1wb3J0IHsgYmVhcmluZyB9IGZyb20gJy4vbGluZS5iZWFyaW5nLm1qcyc7XG5pbXBvcnQgeyBzcXVhcmVkTGVuZ3RoIH0gZnJvbSAnLi9saW5lLnNxdWFyZWRMZW5ndGgubWpzJztcbmltcG9ydCB7IGxlbmd0aCB9IGZyb20gJy4vbGluZS5sZW5ndGgubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuXG5jb25zdCB7XG4gICAgbWF4LFxuICAgIG1pblxufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBMaW5lID0gZnVuY3Rpb24ocDEsIHAyKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGluZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHAxLCBwMik7XG4gICAgfVxuXG4gICAgaWYgKHAxIGluc3RhbmNlb2YgTGluZSkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmUocDEuc3RhcnQsIHAxLmVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludChwMSk7XG4gICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQocDIpO1xufTtcblxuTGluZS5wcm90b3R5cGUgPSB7XG5cbiAgICB0eXBlOiB0eXBlcy5MaW5lLFxuXG4gICAgLy8gQHJldHVybnMgdGhlIGFuZ2xlIG9mIGluY2xpbmUgb2YgdGhlIGxpbmUuXG4gICAgYW5nbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBob3Jpem9udGFsUG9pbnQgPSBuZXcgUG9pbnQodGhpcy5zdGFydC54ICsgMSwgdGhpcy5zdGFydC55KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuYW5nbGVCZXR3ZWVuKHRoaXMuZW5kLCBob3Jpem9udGFsUG9pbnQpO1xuICAgIH0sXG5cbiAgICBiYm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgbGVmdCA9IG1pbih0aGlzLnN0YXJ0LngsIHRoaXMuZW5kLngpO1xuICAgICAgICB2YXIgdG9wID0gbWluKHRoaXMuc3RhcnQueSwgdGhpcy5lbmQueSk7XG4gICAgICAgIHZhciByaWdodCA9IG1heCh0aGlzLnN0YXJ0LngsIHRoaXMuZW5kLngpO1xuICAgICAgICB2YXIgYm90dG9tID0gbWF4KHRoaXMuc3RhcnQueSwgdGhpcy5lbmQueSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KGxlZnQsIHRvcCwgKHJpZ2h0IC0gbGVmdCksIChib3R0b20gLSB0b3ApKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB0aGUgYmVhcmluZyAoY2FyZGluYWwgZGlyZWN0aW9uKSBvZiB0aGUgbGluZS4gRm9yIGV4YW1wbGUgTiwgVywgb3IgU0UuXG4gICAgLy8gQHJldHVybnMge1N0cmluZ30gT25lIG9mIHRoZSBmb2xsb3dpbmcgYmVhcmluZ3MgOiBORSwgRSwgU0UsIFMsIFNXLCBXLCBOVywgTi5cbiAgICBiZWFyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJlYXJpbmcodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7cG9pbnR9IHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIHRvIHBvaW50IGBwYFxuICAgIGNsb3Nlc3RQb2ludDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXQodGhpcy5jbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoKHApKTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50TGVuZ3RoOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aChwKSAqIHRoaXMubGVuZ3RoKCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge251bWJlcn0gdGhlIG5vcm1hbGl6ZWQgbGVuZ3RoIG9mIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBsaW5lIHRvIHBvaW50IGBwYFxuICAgIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGg6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgcHJvZHVjdCA9IHRoaXMudmVjdG9yKCkuZG90KChuZXcgTGluZSh0aGlzLnN0YXJ0LCBwKSkudmVjdG9yKCkpO1xuICAgICAgICB2YXIgY3BOb3JtYWxpemVkTGVuZ3RoID0gbWluKDEsIG1heCgwLCBwcm9kdWN0IC8gdGhpcy5zcXVhcmVkTGVuZ3RoKCkpKTtcblxuICAgICAgICAvLyBjcE5vcm1hbGl6ZWRMZW5ndGggcmV0dXJucyBgTmFOYCBpZiB0aGlzIGxpbmUgaGFzIHplcm8gbGVuZ3RoXG4gICAgICAgIC8vIHdlIGNhbiB3b3JrIHdpdGggdGhhdCAtIGlmIGBOYU5gLCByZXR1cm4gMFxuICAgICAgICBpZiAoY3BOb3JtYWxpemVkTGVuZ3RoICE9PSBjcE5vcm1hbGl6ZWRMZW5ndGgpIHJldHVybiAwOyAvLyBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGB0cnVlYCBpZiBhbmQgb25seSBpZiBjcE5vcm1hbGl6ZWRMZW5ndGggaXMgYE5hTmBcbiAgICAgICAgLy8gKGBOYU5gIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZilcblxuICAgICAgICByZXR1cm4gY3BOb3JtYWxpemVkTGVuZ3RoO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUYW5nZW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0KHRoaXMuY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aChwKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYHRydWVgIGlmIHRoZSBwb2ludCBsaWVzIG9uIHRoZSBsaW5lLlxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgaWYgKHN0YXJ0LmNyb3NzKHAsIGVuZCkgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gZWxzZTogY3Jvc3MgcHJvZHVjdCBvZiAwIGluZGljYXRlcyB0aGF0IHRoaXMgbGluZSBhbmQgdGhlIHZlY3RvciB0byBgcGAgYXJlIGNvbGxpbmVhclxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAoKG5ldyBMaW5lKHN0YXJ0LCBwKSkubGVuZ3RoKCkgPiBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKChuZXcgTGluZShwLCBlbmQpKS5sZW5ndGgoKSA+IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBlbHNlOiBgcGAgbGllcyBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGxpbmVcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlcyB0aGUgbGluZSBpbnRvIHR3byBhdCByZXF1ZXN0ZWQgYHJhdGlvYCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIGRpdmlkZXJQb2ludCA9IHRoaXMucG9pbnRBdChyYXRpbyk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGFycmF5IHdpdGggdHdvIGxpbmVzXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgTGluZSh0aGlzLnN0YXJ0LCBkaXZpZGVyUG9pbnQpLFxuICAgICAgICAgICAgbmV3IExpbmUoZGl2aWRlclBvaW50LCB0aGlzLmVuZClcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLy8gRGl2aWRlcyB0aGUgbGluZSBpbnRvIHR3byBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAuXG4gICAgZGl2aWRlQXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBkaXZpZGVyUG9pbnQgPSB0aGlzLnBvaW50QXRMZW5ndGgobGVuZ3RoKTtcblxuICAgICAgICAvLyByZXR1cm4gYXJyYXkgd2l0aCB0d28gbmV3IGxpbmVzXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgTGluZSh0aGlzLnN0YXJ0LCBkaXZpZGVyUG9pbnQpLFxuICAgICAgICAgICAgbmV3IExpbmUoZGl2aWRlclBvaW50LCB0aGlzLmVuZClcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihsKSB7XG5cbiAgICAgICAgcmV0dXJuICEhbCAmJlxuICAgICAgICAgICAgdGhpcy5zdGFydC54ID09PSBsLnN0YXJ0LnggJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnQueSA9PT0gbC5zdGFydC55ICYmXG4gICAgICAgICAgICB0aGlzLmVuZC54ID09PSBsLmVuZC54ICYmXG4gICAgICAgICAgICB0aGlzLmVuZC55ID09PSBsLmVuZC55O1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtwb2ludH0gUG9pbnQgd2hlcmUgSSdtIGludGVyc2VjdGluZyBhIGxpbmUuXG4gICAgLy8gQHJldHVybiBbcG9pbnRdIFBvaW50cyB3aGVyZSBJJ20gaW50ZXJzZWN0aW5nIGEgcmVjdGFuZ2xlLlxuICAgIC8vIEBzZWUgU3F1ZWFrIFNtYWxsdGFsaywgTGluZVNlZ21lbnQ+PmludGVyc2VjdGlvbldpdGg6XG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbihzaGFwZSwgb3B0KSB7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmludGVyc2VjdGlvbldpdGhMaW5lKSB7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gc2hhcGUuaW50ZXJzZWN0aW9uV2l0aExpbmUodGhpcywgb3B0KTtcblxuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24gJiYgKHNoYXBlIGluc3RhbmNlb2YgTGluZSkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmU6IGZ1bmN0aW9uKGxpbmUpIHtcblxuICAgICAgICB2YXIgcHQxRGlyID0gbmV3IFBvaW50KHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0LngsIHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0LnkpO1xuICAgICAgICB2YXIgcHQyRGlyID0gbmV3IFBvaW50KGxpbmUuZW5kLnggLSBsaW5lLnN0YXJ0LngsIGxpbmUuZW5kLnkgLSBsaW5lLnN0YXJ0LnkpO1xuICAgICAgICB2YXIgZGV0ID0gKHB0MURpci54ICogcHQyRGlyLnkpIC0gKHB0MURpci55ICogcHQyRGlyLngpO1xuICAgICAgICB2YXIgZGVsdGFQdCA9IG5ldyBQb2ludChsaW5lLnN0YXJ0LnggLSB0aGlzLnN0YXJ0LngsIGxpbmUuc3RhcnQueSAtIHRoaXMuc3RhcnQueSk7XG4gICAgICAgIHZhciBhbHBoYSA9IChkZWx0YVB0LnggKiBwdDJEaXIueSkgLSAoZGVsdGFQdC55ICogcHQyRGlyLngpO1xuICAgICAgICB2YXIgYmV0YSA9IChkZWx0YVB0LnggKiBwdDFEaXIueSkgLSAoZGVsdGFQdC55ICogcHQxRGlyLngpO1xuXG4gICAgICAgIGlmIChkZXQgPT09IDAgfHwgYWxwaGEgKiBkZXQgPCAwIHx8IGJldGEgKiBkZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb24gZm91bmQuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoYWxwaGEgPiBkZXQgfHwgYmV0YSA+IGRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWxwaGEgPCBkZXQgfHwgYmV0YSA8IGRldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtuZXcgUG9pbnQoXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnggKyAoYWxwaGEgKiBwdDFEaXIueCAvIGRldCksXG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnkgKyAoYWxwaGEgKiBwdDFEaXIueSAvIGRldClcbiAgICAgICAgKV07XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydC5lcXVhbHModGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtkb3VibGV9IGxlbmd0aCBvZiB0aGUgbGluZVxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGgodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtwb2ludH0gbXkgbWlkcG9pbnRcbiAgICBtaWRwb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICh0aGlzLnN0YXJ0LnggKyB0aGlzLmVuZC54KSAvIDIsXG4gICAgICAgICAgICAodGhpcy5zdGFydC55ICsgdGhpcy5lbmQueSkgLyAyXG4gICAgICAgICk7XG4gICAgfSxcblxuICAgIHBhcmFsbGVsOiBmdW5jdGlvbihkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gbDtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBsO1xuICAgICAgICBjb25zdCBlUmVmID0gc3RhcnQuY2xvbmUoKS5yb3RhdGUoZW5kLCAyNzApO1xuICAgICAgICBjb25zdCBzUmVmID0gZW5kLmNsb25lKCkucm90YXRlKHN0YXJ0LCA5MCk7XG4gICAgICAgIHN0YXJ0Lm1vdmUoc1JlZiwgZGlzdGFuY2UpO1xuICAgICAgICBlbmQubW92ZShlUmVmLCBkaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiBsO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtwb2ludH0gbXkgcG9pbnQgYXQgJ3QnIDwwLDE+XG4gICAgcG9pbnRBdDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICBpZiAodCA8PSAwKSByZXR1cm4gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgaWYgKHQgPj0gMSkgcmV0dXJuIGVuZC5jbG9uZSgpO1xuXG4gICAgICAgIHJldHVybiBzdGFydC5sZXJwKGVuZCwgdCk7XG4gICAgfSxcblxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGluZUxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW5ndGggPj0gbGluZUxlbmd0aCkgcmV0dXJuIChmcm9tU3RhcnQgPyBlbmQuY2xvbmUoKSA6IHN0YXJ0LmNsb25lKCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXQoKGZyb21TdGFydCA/IChsZW5ndGgpIDogKGxpbmVMZW5ndGggLSBsZW5ndGgpKSAvIGxpbmVMZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtudW1iZXJ9IHRoZSBvZmZzZXQgb2YgdGhlIHBvaW50IGBwYCBmcm9tIHRoZSBsaW5lLiArIGlmIHRoZSBwb2ludCBgcGAgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxpbmUsIC0gaWYgb24gdGhlIGxlZnQgYW5kIDAgaWYgb24gdGhlIGxpbmUuXG4gICAgcG9pbnRPZmZzZXQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICAvLyBGaW5kIHRoZSBzaWduIG9mIHRoZSBkZXRlcm1pbmFudCBvZiB2ZWN0b3JzIChzdGFydCxlbmQpLCB3aGVyZSBwIGlzIHRoZSBxdWVyeSBwb2ludC5cbiAgICAgICAgcCA9IG5ldyBQb2ludChwKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgICAgICB2YXIgZGV0ZXJtaW5hbnQgPSAoKGVuZC54IC0gc3RhcnQueCkgKiAocC55IC0gc3RhcnQueSkgLSAoZW5kLnkgLSBzdGFydC55KSAqIChwLnggLSBzdGFydC54KSk7XG5cbiAgICAgICAgcmV0dXJuIGRldGVybWluYW50IC8gdGhpcy5sZW5ndGgoKTtcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbihvcmlnaW4sIGFuZ2xlKSB7XG5cbiAgICAgICAgdGhpcy5zdGFydC5yb3RhdGUob3JpZ2luLCBhbmdsZSk7XG4gICAgICAgIHRoaXMuZW5kLnJvdGF0ZShvcmlnaW4sIGFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHRoaXMuZW5kLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB0aGlzLnN0YXJ0LnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgdGhpcy5lbmQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7bnVtYmVyfSBzY2FsZSB0aGUgbGluZSBzbyB0aGF0IGl0IGhhcyB0aGUgcmVxdWVzdGVkIGxlbmd0aFxuICAgIHNldExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICBpZiAoIWN1cnJlbnRMZW5ndGgpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBzY2FsZUZhY3RvciA9IGxlbmd0aCAvIGN1cnJlbnRMZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlKHNjYWxlRmFjdG9yLCBzY2FsZUZhY3RvciwgdGhpcy5zdGFydCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge2ludGVnZXJ9IGxlbmd0aCB3aXRob3V0IHNxcnRcbiAgICAvLyBAbm90ZSBmb3IgYXBwbGljYXRpb25zIHdoZXJlIHRoZSBleGFjdCBsZW5ndGggaXMgbm90IG5lY2Vzc2FyeSAoZS5nLiBjb21wYXJlIG9ubHkpXG4gICAgc3F1YXJlZExlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzcXVhcmVkTGVuZ3RoKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICB9LFxuXG4gICAgdGFuZ2VudEF0OiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRGlmZmVyZW50aWFibGUoKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuXG4gICAgICAgIHZhciB0YW5nZW50U3RhcnQgPSB0aGlzLnBvaW50QXQodCk7IC8vIGNvbnN0cmFpbnMgYHRgIGJldHdlZW4gMCBhbmQgMVxuXG4gICAgICAgIHZhciB0YW5nZW50TGluZSA9IG5ldyBMaW5lKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0YW5nZW50TGluZS50cmFuc2xhdGUodGFuZ2VudFN0YXJ0LnggLSBzdGFydC54LCB0YW5nZW50U3RhcnQueSAtIHN0YXJ0LnkpOyAvLyBtb3ZlIHNvIHRoYXQgdGFuZ2VudCBsaW5lIHN0YXJ0cyBhdCB0aGUgcG9pbnQgcmVxdWVzdGVkXG5cbiAgICAgICAgcmV0dXJuIHRhbmdlbnRMaW5lO1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0RpZmZlcmVudGlhYmxlKCkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcblxuICAgICAgICB2YXIgdGFuZ2VudFN0YXJ0ID0gdGhpcy5wb2ludEF0TGVuZ3RoKGxlbmd0aCk7XG5cbiAgICAgICAgdmFyIHRhbmdlbnRMaW5lID0gbmV3IExpbmUoc3RhcnQsIGVuZCk7XG4gICAgICAgIHRhbmdlbnRMaW5lLnRyYW5zbGF0ZSh0YW5nZW50U3RhcnQueCAtIHN0YXJ0LngsIHRhbmdlbnRTdGFydC55IC0gc3RhcnQueSk7IC8vIG1vdmUgc28gdGhhdCB0YW5nZW50IGxpbmUgc3RhcnRzIGF0IHRoZSBwb2ludCByZXF1ZXN0ZWRcblxuICAgICAgICByZXR1cm4gdGFuZ2VudExpbmU7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC50b1N0cmluZygpICsgJyAnICsgdGhpcy5lbmQudG9TdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydC5zZXJpYWxpemUoKSArICcgJyArIHRoaXMuZW5kLnNlcmlhbGl6ZSgpO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSkge1xuXG4gICAgICAgIHRoaXMuc3RhcnQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuZW5kLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB2ZWN0b3Ige3BvaW50fSBvZiB0aGUgbGluZVxuICAgIHZlY3RvcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmVuZC54IC0gdGhpcy5zdGFydC54LCB0aGlzLmVuZC55IC0gdGhpcy5zdGFydC55KTtcbiAgICB9XG59O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG5MaW5lLnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBMaW5lLnByb3RvdHlwZS5pbnRlcnNlY3Q7XG5cblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuZXhwb3J0IGNvbnN0IGxpbmUgPSBMaW5lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/line.squaredLength.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/g/line.squaredLength.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   squaredLength: function() { return /* binding */ squaredLength; }\n/* harmony export */ });\n// @return {integer} length without sqrt\n// @note for applications where the exact length is not necessary (e.g. compare only)\nconst squaredLength = function(start, end) {\n\n    var x0 = start.x;\n    var y0 = start.y;\n    var x1 = end.x;\n    var y1 = end.y;\n    return (x0 -= x1) * x0 + (y0 -= y1) * y0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9saW5lLnNxdWFyZWRMZW5ndGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxZQUFZLFNBQVM7QUFDckI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9nL2xpbmUuc3F1YXJlZExlbmd0aC5tanM/OGE2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAcmV0dXJuIHtpbnRlZ2VyfSBsZW5ndGggd2l0aG91dCBzcXJ0XG4vLyBAbm90ZSBmb3IgYXBwbGljYXRpb25zIHdoZXJlIHRoZSBleGFjdCBsZW5ndGggaXMgbm90IG5lY2Vzc2FyeSAoZS5nLiBjb21wYXJlIG9ubHkpXG5leHBvcnQgY29uc3Qgc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblxuICAgIHZhciB4MCA9IHN0YXJ0Lng7XG4gICAgdmFyIHkwID0gc3RhcnQueTtcbiAgICB2YXIgeDEgPSBlbmQueDtcbiAgICB2YXIgeTEgPSBlbmQueTtcbiAgICByZXR1cm4gKHgwIC09IHgxKSAqIHgwICsgKHkwIC09IHkxKSAqIHkwO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@joint/core/src/g/path.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Path: function() { return /* binding */ Path; }\n/* harmony export */ });\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyline.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _curve_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/curve.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _extend_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extend.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/extend.mjs\");\n// Accepts path data string, array of segments, array of Curves and/or Lines, or a Polyline.\n// Path created is not guaranteed to be a valid (serializable) path (might not start with an M).\n\n\n\n\n\n\n\nconst Path = function(arg) {\n\n    if (!(this instanceof Path)) {\n        return new Path(arg);\n    }\n\n    if (typeof arg === 'string') { // create from a path data string\n        return new Path.parse(arg);\n    }\n\n    this.segments = [];\n\n    var i;\n    var n;\n\n    if (!arg) {\n        // don't do anything\n\n    } else if (Array.isArray(arg) && arg.length !== 0) { // if arg is a non-empty array\n        // flatten one level deep\n        // so we can chain arbitrary Path.createSegment results\n        arg = arg.reduce(function(acc, val) {\n            return acc.concat(val);\n        }, []);\n\n        n = arg.length;\n        if (arg[0].isSegment) { // create from an array of segments\n            for (i = 0; i < n; i++) {\n\n                var segment = arg[i];\n\n                this.appendSegment(segment);\n            }\n\n        } else { // create from an array of Curves and/or Lines\n            var previousObj = null;\n            for (i = 0; i < n; i++) {\n\n                var obj = arg[i];\n\n                if (!((obj instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) || (obj instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve))) {\n                    throw new Error('Cannot construct a path segment from the provided object.');\n                }\n\n                if (i === 0) this.appendSegment(Path.createSegment('M', obj.start));\n\n                // if objects do not link up, moveto segments are inserted to cover the gaps\n                if (previousObj && !previousObj.end.equals(obj.start)) this.appendSegment(Path.createSegment('M', obj.start));\n\n                if (obj instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) {\n                    this.appendSegment(Path.createSegment('L', obj.end));\n\n                } else if (obj instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) {\n                    this.appendSegment(Path.createSegment('C', obj.controlPoint1, obj.controlPoint2, obj.end));\n                }\n\n                previousObj = obj;\n            }\n        }\n\n    } else if (arg.isSegment) { // create from a single segment\n        this.appendSegment(arg);\n\n    } else if (arg instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) { // create from a single Line\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('L', arg.end));\n\n    } else if (arg instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) { // create from a single Curve\n        this.appendSegment(Path.createSegment('M', arg.start));\n        this.appendSegment(Path.createSegment('C', arg.controlPoint1, arg.controlPoint2, arg.end));\n\n    } else if (arg instanceof _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__.Polyline) { // create from a Polyline\n        if (!(arg.points && (arg.points.length !== 0))) return; // if Polyline has no points, leave Path empty\n\n        n = arg.points.length;\n        for (i = 0; i < n; i++) {\n\n            var point = arg.points[i];\n\n            if (i === 0) this.appendSegment(Path.createSegment('M', point));\n            else this.appendSegment(Path.createSegment('L', point));\n        }\n\n    } else { // unknown object\n        throw new Error('Cannot construct a path from the provided object.');\n    }\n};\n\n// More permissive than V.normalizePathData and Path.prototype.serialize.\n// Allows path data strings that do not start with a Moveto command (unlike SVG specification).\n// Does not require spaces between elements; commas are allowed, separators may be omitted when unambiguous (e.g. 'ZM10,10', 'L1.6.8', 'M100-200').\n// Allows for command argument chaining.\n// Throws an error if wrong number of arguments is provided with a command.\n// Throws an error if an unrecognized path command is provided (according to Path.segmentTypes). Only a subset of SVG commands is currently supported (L, C, M, Z).\nPath.parse = function(pathData) {\n\n    if (!pathData) return new Path();\n\n    var path = new Path();\n\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = pathData.match(commandRe);\n\n    var numCommands = commands.length;\n    for (var i = 0; i < numCommands; i++) {\n\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n        var args = command.match(argRe);\n\n        var segment = Path.createSegment.apply(this, args); // args = [type, coordinate1, coordinate2...]\n        path.appendSegment(segment);\n    }\n\n    return path;\n};\n\n// Create a segment or an array of segments.\n// Accepts unlimited points/coords arguments after `type`.\nPath.createSegment = function(type) {\n\n    if (!type) throw new Error('Type must be provided.');\n\n    var segmentConstructor = Path.segmentTypes[type];\n    if (!segmentConstructor) throw new Error(type + ' is not a recognized path segment type.');\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 1; i < n; i++) { // do not add first element (`type`) to args array\n        args.push(arguments[i]);\n    }\n\n    return applyToNew(segmentConstructor, args);\n};\n\nPath.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_3__.types.Path,\n\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if argument is not a segment or an array of segments.\n    appendSegment: function(arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var currentSegment;\n\n        var previousSegment = ((numSegments !== 0) ? segments[numSegments - 1] : null); // if we are appending to an empty path, previousSegment is null\n        var nextSegment = null;\n\n        if (!Array.isArray(arg)) { // arg is a segment\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.push(currentSegment);\n\n        } else { // arg is an array of segments\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    // Returns the bbox of the path.\n    // If path has no segments, returns null.\n    // If path has only invisible segments, returns bbox of the end point of last segment.\n    bbox: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var bbox;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var segmentBBox = segment.bbox();\n                bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n            }\n        }\n\n        if (bbox) return bbox;\n\n        // if the path has only invisible elements, return end point of last segment\n        var lastSegment = segments[numSegments - 1];\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_4__.Rect(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    },\n\n    // Returns a new path that is a clone of this path.\n    clone: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        var path = new Path();\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i].clone();\n            path.appendSegment(segment);\n        }\n\n        return path;\n    },\n\n    closestPoint: function(p, opt) {\n\n        var t = this.closestPointT(p, opt);\n        if (!t) return null;\n\n        return this.pointAtT(t);\n    },\n\n    closestPointLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var t = this.closestPointT(p, localOpt);\n        if (!t) return 0;\n\n        return this.lengthAtT(t, localOpt);\n    },\n\n    closestPointNormalizedLength: function(p, opt) {\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var cpLength = this.closestPointLength(p, localOpt);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length(localOpt);\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    // Private function.\n    closestPointT: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointT;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isVisible) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointT) return closestPointT;\n\n        // if no visible segment, return end of last segment\n        return { segmentIndex: numSegments - 1, value: 1 };\n    },\n\n    closestPointTangent: function(p, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var closestPointTangent;\n        var minSquaredDistance = Infinity;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n\n            if (segment.isDifferentiable()) {\n                var segmentClosestPointT = segment.closestPointT(p, {\n                    precision: precision,\n                    subdivisions: subdivisions\n                });\n                var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                var squaredDistance = (new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(segmentClosestPoint, p)).squaredLength();\n\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n\n        if (closestPointTangent) return closestPointTangent;\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Returns `true` if the area surrounded by the path contains the point `p`.\n    // Implements the even-odd algorithm (self-intersections are \"outside\").\n    // Closes open paths (always imagines a final closing segment).\n    // Precision may be adjusted by passing an `opt` object.\n    containsPoint: function(p, opt) {\n\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return false; // shortcut (this path has no polylines)\n\n        var numPolylines = polylines.length;\n\n        // how many component polylines does `p` lie within?\n        var numIntersections = 0;\n        for (var i = 0; i < numPolylines; i++) {\n            var polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                // `p` lies within this polyline\n                numIntersections++;\n            }\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    // Divides the path into two at requested `ratio` between 0 and 1 with precision better than `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.divideAtLength(length, localOpt);\n    },\n\n    // Divides the path into two at requested `length` with precision better than requested `opt.precision`; optionally using `opt.subdivisions` provided.\n    divideAtLength: function(length, opt) {\n\n        var numSegments = this.segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var i;\n        var segment;\n\n        // identify the segment to divide:\n\n        var l = 0; // length so far\n        var divided;\n        var dividedSegmentIndex;\n        var lastValidSegment; // visible AND differentiable\n        var lastValidSegmentIndex;\n        var t;\n        for (i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            segment = this.getSegment(index);\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) { // segment is not just a point\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n\n                if (length <= (l + d)) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                    break;\n                }\n            }\n\n            l += d;\n        }\n\n        if (!lastValidSegment) { // no valid segment found\n            return null;\n        }\n\n        // else: the path contains at least one valid segment\n\n        if (!divided) { // the desired length is greater than the length of the path\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = (fromStart ? 1 : 0);\n            divided = lastValidSegment.divideAtT(t);\n        }\n\n        // create a copy of this path and replace the identified segment with its two divided parts:\n\n        var pathCopy = this.clone();\n        pathCopy.replaceSegment(dividedSegmentIndex, divided);\n\n        var divisionStartIndex = dividedSegmentIndex;\n        var divisionMidIndex = dividedSegmentIndex + 1;\n        var divisionEndIndex = dividedSegmentIndex + 2;\n\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n\n        // insert a Moveto segment to ensure secondPath will be valid:\n        var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n        var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (i = divisionEndIndex; i < pathCopy.segments.length; i++) {\n\n            var originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            segment = pathCopy.getSegment(i);\n\n            if ((segment.type === 'Z') && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                var convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n\n        // distribute pathCopy segments into two paths and return those:\n\n        var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n\n        return [firstPath, secondPath];\n    },\n\n    // Checks whether two paths are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var segments = this.segments;\n        var otherSegments = p.segments;\n\n        var numSegments = segments.length;\n        if (otherSegments.length !== numSegments) return false; // if the two paths have different number of segments, they cannot be equal\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var otherSegment = otherSegments[i];\n\n            // as soon as an inequality is found in segments, return false\n            if ((segment.type !== otherSegment.type) || (!segment.equals(otherSegment))) return false;\n        }\n\n        // if no inequality found in segments, return true\n        return true;\n    },\n\n    // Accepts negative indices.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    getSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        return segments[index];\n    },\n\n    // Returns an array of segment subdivisions, with precision better than requested `opt.precision`.\n    getSegmentSubdivisions: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        // not using opt.segmentSubdivisions\n        // not using localOpt\n\n        var segmentSubdivisions = [];\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segment.getSubdivisions({ precision: precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n\n        return segmentSubdivisions;\n    },\n\n    // Returns an array of subpaths of this path.\n    // Invalid paths are validated first.\n    // Returns `[]` if path has no segments.\n    getSubpaths: function() {\n\n        const validatedPath = this.clone().validate();\n\n        const segments = validatedPath.segments;\n        const numSegments = segments.length;\n\n        const subpaths = [];\n        for (let i = 0; i < numSegments; i++) {\n\n            const segment = segments[i];\n            if (segment.isSubpathStart) {\n                // we encountered a subpath start segment\n                // create a new path for segment, and push it to list of subpaths\n                subpaths.push(new Path(segment));\n\n            } else {\n                // append current segment to the last subpath\n                subpaths[subpaths.length - 1].appendSegment(segment);\n            }\n        }\n\n        return subpaths;\n    },\n\n    // Insert `arg` at given `index`.\n    // `index = 0` means insert at the beginning.\n    // `index = segments.length` means insert at the end.\n    // Accepts negative indices, from `-1` to `-(segments.length + 1)`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    insertSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        // works even if path has no segments\n\n        // note that these are incremented compared to getSegments()\n        // we can insert after last element (note that this changes the meaning of index -1)\n        if (index < 0) index = numSegments + index + 1; // convert negative indices to positive\n        if (index > numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var previousSegment = null;\n        var nextSegment = null;\n\n        if (numSegments !== 0) {\n            if (index >= 1) {\n                previousSegment = segments[index - 1];\n                nextSegment = previousSegment.nextSegment; // if we are inserting at end, nextSegment is null\n\n            } else { // if index === 0\n                // previousSegment is null\n                nextSegment = segments[0];\n            }\n        }\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 0, currentSegment);\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n            }\n        }\n    },\n\n    intersectionWithLine: function(line, opt) {\n\n        var intersection = null;\n        var polylines = this.toPolylines(opt);\n        if (!polylines) return null;\n        for (var i = 0, n = polylines.length; i < n; i++) {\n            var polyline = polylines[i];\n            var polylineIntersection = line.intersect(polyline);\n            if (polylineIntersection) {\n                intersection || (intersection = []);\n                if (Array.isArray(polylineIntersection)) {\n                    Array.prototype.push.apply(intersection, polylineIntersection);\n                } else {\n                    intersection.push(polylineIntersection);\n                }\n            }\n        }\n\n        return intersection;\n    },\n\n    isDifferentiable: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            // as soon as a differentiable segment is found in segments, return true\n            if (segment.isDifferentiable()) return true;\n        }\n\n        // if no differentiable segment is found in segments, return false\n        return false;\n    },\n\n    // Checks whether current path segments are valid.\n    // Note that d is allowed to be empty - should disable rendering of the path.\n    isValid: function() {\n\n        var segments = this.segments;\n        var isValid = (segments.length === 0) || (segments[0].type === 'M'); // either empty or first segment is a Moveto\n        return isValid;\n    },\n\n    // Returns length of the path, with precision better than requested `opt.precision`; or using `opt.segmentSubdivisions` provided.\n    // If path has no segments, returns 0.\n    length: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision; // opt.precision only used in getSegmentSubdivisions() call\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var length = 0;\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            var subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions: subdivisions });\n        }\n\n        return length;\n    },\n\n    // Private function.\n    lengthAtT: function(t, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return 0; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return 0; // regardless of t.value\n\n        var tValue = t.value;\n        if (segmentIndex >= numSegments) {\n            segmentIndex = numSegments - 1;\n            tValue = 1;\n        } else if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var subdivisions;\n        var length = 0;\n        for (var i = 0; i < segmentIndex; i++) {\n\n            var segment = segments[i];\n            subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precisison: precision, subdivisions: subdivisions });\n        }\n\n        segment = segments[segmentIndex];\n        subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precisison: precision, subdivisions: subdivisions });\n\n        return length;\n    },\n\n    // Returns point at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    pointAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio <= 0) return this.start.clone();\n        if (ratio >= 1) return this.end.clone();\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.pointAtLength(length, localOpt);\n    },\n\n    // Returns point at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    pointAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (length === 0) return this.start.clone();\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegment;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) {\n                    return segment.pointAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastVisibleSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment endpoint\n        if (lastVisibleSegment) return (fromStart ? lastVisibleSegment.end : lastVisibleSegment.start);\n\n        // if no visible segment, return last segment end point (no matter if fromStart or no)\n        var lastSegment = segments[numSegments - 1];\n        return lastSegment.end.clone();\n    },\n\n    // Private function.\n    pointAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].pointAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].pointAtT(tValue);\n    },\n\n    // Default precision\n    PRECISION: 3,\n\n    // Helper method for adding segments.\n    prepareSegment: function(segment, previousSegment, nextSegment) {\n\n        // insert after previous segment and before previous segment's next segment\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment) previousSegment.nextSegment = segment;\n        if (nextSegment) nextSegment.previousSegment = segment;\n\n        var updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            segment.subpathStartSegment = segment; // assign self as subpath start segment\n            updateSubpathStart = nextSegment; // start updating from next segment\n        }\n\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart) this.updateSubpathStartSegment(updateSubpathStart);\n\n        return segment;\n    },\n\n    // Remove the segment at `index`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    removeSegment: function(index) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var removedSegment = segments.splice(index, 1)[0];\n        var previousSegment = removedSegment.previousSegment;\n        var nextSegment = removedSegment.nextSegment;\n\n        // link the previous and next segments together (if present)\n        if (previousSegment) previousSegment.nextSegment = nextSegment; // may be null\n        if (nextSegment) nextSegment.previousSegment = previousSegment; // may be null\n\n        // if removed segment used to start a subpath, update all subsequent segments until another subpath start segment is reached\n        if (removedSegment.isSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    // Replace the segment at `index` with `arg`.\n    // Accepts negative indices, from `-1` to `-segments.length`.\n    // Accepts one segment or an array of segments as argument.\n    // Throws an error if path has no segments.\n    // Throws an error if index is out of range.\n    // Throws an error if argument is not a segment or an array of segments.\n    replaceSegment: function(index, arg) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) throw new Error('Path has no segments.');\n\n        if (index < 0) index = numSegments + index; // convert negative indices to positive\n        if (index >= numSegments || index < 0) throw new Error('Index out of range.');\n\n        var currentSegment;\n\n        var replacedSegment = segments[index];\n        var previousSegment = replacedSegment.previousSegment;\n        var nextSegment = replacedSegment.nextSegment;\n\n        var updateSubpathStart = replacedSegment.isSubpathStart; // boolean: is an update of subpath starts necessary?\n\n        if (!Array.isArray(arg)) {\n            if (!arg || !arg.isSegment) throw new Error('Segment required.');\n\n            currentSegment = this.prepareSegment(arg, previousSegment, nextSegment);\n            segments.splice(index, 1, currentSegment); // directly replace\n\n            if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n\n        } else {\n            // flatten one level deep\n            // so we can chain arbitrary Path.createSegment results\n            arg = arg.reduce(function(acc, val) {\n                return acc.concat(val);\n            }, []);\n\n            if (!arg[0].isSegment) throw new Error('Segments required.');\n\n            segments.splice(index, 1);\n\n            var n = arg.length;\n            for (var i = 0; i < n; i++) {\n\n                var currentArg = arg[i];\n                currentSegment = this.prepareSegment(currentArg, previousSegment, nextSegment);\n                segments.splice((index + i), 0, currentSegment); // incrementing index to insert subsequent segments after inserted segments\n                previousSegment = currentSegment;\n\n                if (updateSubpathStart && currentSegment.isSubpathStart) updateSubpathStart = false; // already updated by `prepareSegment`\n            }\n        }\n\n        // if replaced segment used to start a subpath and no new subpath start was added, update all subsequent segments until another subpath start segment is reached\n        if (updateSubpathStart && nextSegment) this.updateSubpathStartSegment(nextSegment);\n    },\n\n    round: function(precision) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    segmentAt: function(ratio, opt) {\n\n        var index = this.segmentIndexAt(ratio, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    // Accepts negative length.\n    segmentAtLength: function(length, opt) {\n\n        var index = this.segmentIndexAtLength(length, opt);\n        if (!index) return null;\n\n        return this.getSegment(index);\n    },\n\n    segmentIndexAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.segmentIndexAtLength(length, localOpt);\n    },\n\n    // Accepts negative length.\n    segmentIndexAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastVisibleSegmentIndex = null;\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isVisible) {\n                if (length <= (l + d)) return index;\n                lastVisibleSegmentIndex = index;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return last visible segment index\n        // if no visible segment, return null\n        return lastVisibleSegmentIndex;\n    },\n\n    // Returns a string that can be used to reconstruct the path.\n    // Additional error checking compared to toString (must start with M segment).\n    serialize: function() {\n\n        if (!this.isValid()) throw new Error('Invalid path segments.');\n\n        return this.toString();\n    },\n\n    // Returns tangent line at requested `ratio` between 0 and 1, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    tangentAt: function(ratio, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        var localOpt = { precision: precision, segmentSubdivisions: segmentSubdivisions };\n\n        var pathLength = this.length(localOpt);\n        var length = pathLength * ratio;\n\n        return this.tangentAtLength(length, localOpt);\n    },\n\n    // Returns tangent line at requested `length`, with precision better than requested `opt.precision`; optionally using `opt.segmentSubdivisions` provided.\n    // Accepts negative length.\n    tangentAtLength: function(length, opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n        // not using localOpt\n\n        var lastValidSegment; // visible AND differentiable (with a tangent)\n        var l = 0; // length so far\n        for (var i = 0; i < numSegments; i++) {\n            var index = (fromStart ? i : (numSegments - 1 - i));\n\n            var segment = segments[index];\n            var subdivisions = segmentSubdivisions[index];\n            var d = segment.length({ precision: precision, subdivisions: subdivisions });\n\n            if (segment.isDifferentiable()) {\n                if (length <= (l + d)) {\n                    return segment.tangentAtLength(((fromStart ? 1 : -1) * (length - l)), {\n                        precision: precision,\n                        subdivisions: subdivisions\n                    });\n                }\n\n                lastValidSegment = segment;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            var t = (fromStart ? 1 : 0);\n            return lastValidSegment.tangentAtT(t);\n        }\n\n        // if no valid segment, return null\n        return null;\n    },\n\n    // Private function.\n    tangentAtT: function(t) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        var segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) return segments[0].tangentAtT(0);\n        if (segmentIndex >= numSegments) return segments[numSegments - 1].tangentAtT(1);\n\n        var tValue = t.value;\n        if (tValue < 0) tValue = 0;\n        else if (tValue > 1) tValue = 1;\n\n        return segments[segmentIndex].tangentAtT(tValue);\n    },\n\n    toPoints: function(opt) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null; // if segments is an empty array\n\n        opt = opt || {};\n        var precision = (opt.precision === undefined) ? this.PRECISION : opt.precision;\n        var segmentSubdivisions = (opt.segmentSubdivisions === undefined) ? this.getSegmentSubdivisions({ precision: precision }) : opt.segmentSubdivisions;\n\n        var points = [];\n        var partialPoints = [];\n        for (var i = 0; i < numSegments; i++) {\n            var segment = segments[i];\n            if (segment.isVisible) {\n                var currentSegmentSubdivisions = segmentSubdivisions[i];\n                if (currentSegmentSubdivisions.length > 0) {\n                    var subdivisionPoints = currentSegmentSubdivisions.map(function(curve) {\n                        return curve.start;\n                    });\n                    Array.prototype.push.apply(partialPoints, subdivisionPoints);\n                } else {\n                    partialPoints.push(segment.start);\n                }\n            } else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    },\n\n    toPolylines: function(opt) {\n\n        var polylines = [];\n        var points = this.toPoints(opt);\n        if (!points) return null;\n        for (var i = 0, n = points.length; i < n; i++) {\n            polylines.push(new _polyline_mjs__WEBPACK_IMPORTED_MODULE_2__.Polyline(points[i]));\n        }\n\n        return polylines;\n    },\n\n    toString: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        var pathData = '';\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            pathData += segment.serialize() + ' ';\n        }\n\n        return pathData.trim();\n    },\n\n    translate: function(tx, ty) {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            segment.translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Helper method for updating subpath start of segments, starting with the one provided.\n    updateSubpathStartSegment: function(segment) {\n\n        var previousSegment = segment.previousSegment; // may be null\n        while (segment && !segment.isSubpathStart) {\n\n            // assign previous segment's subpath start segment to this segment\n            if (previousSegment) segment.subpathStartSegment = previousSegment.subpathStartSegment; // may be null\n            else segment.subpathStartSegment = null; // if segment had no previous segment, assign null - creates an invalid path!\n\n            previousSegment = segment;\n            segment = segment.nextSegment; // move on to the segment after etc.\n        }\n    },\n\n    // If the path is not valid, insert M 0 0 at the beginning.\n    // Path with no segments is considered valid, so nothing is inserted.\n    validate: function() {\n\n        if (!this.isValid()) this.insertSegment(0, Path.createSegment('M', 0, 0));\n        return this;\n    }\n};\n\nObject.defineProperty(Path.prototype, 'start', {\n    // Getter for the first visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = 0; i < numSegments; i++) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.start;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\nObject.defineProperty(Path.prototype, 'end', {\n    // Getter for the last visible endpoint of the path.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var segments = this.segments;\n        var numSegments = segments.length;\n        if (numSegments === 0) return null;\n\n        for (var i = numSegments - 1; i >= 0; i--) {\n\n            var segment = segments[i];\n            if (segment.isVisible) return segment.end;\n        }\n\n        // if no visible segment, return last segment end point\n        return segments[numSegments - 1].end;\n    }\n});\n\n\n// Local helper function.\n// Use an array of arguments to call a constructor (function called with `new`).\n// Adapted from https://stackoverflow.com/a/8843181/2263595\n// It is not necessary to use this function if the arguments can be passed separately (i.e. if the number of arguments is limited).\n// - If that is the case, use `new constructor(arg1, arg2)`, for example.\n// It is not necessary to use this function if the function that needs an array of arguments is not supposed to be used as a constructor.\n// - If that is the case, use `f.apply(thisArg, [arg1, arg2...])`, for example.\nfunction applyToNew(constructor, argsArray) {\n    // The `new` keyword can only be applied to functions that take a limited number of arguments.\n    // - We can fake that with .bind().\n    // - It calls a function (`constructor`, here) with the arguments that were provided to it - effectively transforming an unlimited number of arguments into limited.\n    // - So `new (constructor.bind(thisArg, arg1, arg2...))`\n    // - `thisArg` can be anything (e.g. null) because `new` keyword resets context to the constructor object.\n    // We need to pass in a variable number of arguments to the bind() call.\n    // - We can use .apply().\n    // - So `new (constructor.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n    // - `thisArg` can still be anything because `new` overwrites it.\n    // Finally, to make sure that constructor.bind overwriting is not a problem, we switch to `Function.prototype.bind`.\n    // - So, the final version is `new (Function.prototype.bind.apply(constructor, [thisArg, arg1, arg2...]))`\n\n    // The function expects `argsArray[0]` to be `thisArg`.\n    // - This means that whatever is sent as the first element will be ignored.\n    // - The constructor will only see arguments starting from argsArray[1].\n    // - So, a new dummy element is inserted at the start of the array.\n    argsArray.unshift(null);\n\n    return new (Function.prototype.bind.apply(constructor, argsArray));\n}\n\n// Path segment interface:\nvar segmentPrototype = {\n\n    // virtual\n    bbox: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    clone: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPoint: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    closestPointNormalizedLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to closestPointNormalizedLength() function if closestPointT() is not defined for segment.\n    closestPointT: function(p) {\n\n        if (this.closestPointNormalizedLength) return this.closestPointNormalizedLength(p);\n\n        throw new Error('Neither closestPointT() nor closestPointNormalizedLength() function is implemented.');\n    },\n\n    // virtual\n    closestPointTangent: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    divideAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to divideAt() function if divideAtT() is not defined for segment.\n    divideAtT: function(t) {\n\n        if (this.divideAt) return this.divideAt(t);\n\n        throw new Error('Neither divideAtT() nor divideAt() function is implemented.');\n    },\n\n    // virtual\n    equals: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    getSubdivisions: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    isDifferentiable: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    isSegment: true,\n\n    isSubpathStart: false, // true for Moveto segments\n\n    isVisible: true, // false for Moveto segments\n\n    // virtual\n    length: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Return a fraction of result of length() function if lengthAtT() is not defined for segment.\n    lengthAtT: function(t) {\n\n        if (t <= 0) return 0;\n\n        var length = this.length();\n\n        if (t >= 1) return length;\n\n        return length * t;\n    },\n\n    nextSegment: null, // needed for subpath start segment updating\n\n    // virtual\n    pointAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    pointAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to pointAt() function if pointAtT() is not defined for segment.\n    pointAtT: function(t) {\n\n        if (this.pointAt) return this.pointAt(t);\n\n        throw new Error('Neither pointAtT() nor pointAt() function is implemented.');\n    },\n\n    previousSegment: null, // needed to get segment start property\n\n    // virtual\n    round: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    subpathStartSegment: null, // needed to get Closepath segment end property\n\n    // virtual\n    scale: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    serialize: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAt: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    tangentAtLength: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // Redirect calls to tangentAt() function if tangentAtT() is not defined for segment.\n    tangentAtT: function(t) {\n\n        if (this.tangentAt) return this.tangentAt(t);\n\n        throw new Error('Neither tangentAtT() nor tangentAt() function is implemented.');\n    },\n\n    // virtual\n    toString: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    },\n\n    // virtual\n    translate: function() {\n\n        throw new Error('Declaration missing for virtual function.');\n    }\n};\n\n// usually directly assigned\n// getter for Closepath\nObject.defineProperty(segmentPrototype, 'end', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    writable: true\n});\n\n// always a getter\n// always throws error for Moveto\nObject.defineProperty(segmentPrototype, 'start', {\n    // get a reference to the end point of previous segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.previousSegment) throw new Error('Missing previous segment. (This segment cannot be the first segment of a path; OR segment has not yet been added to a path.)');\n\n        return this.previousSegment.end;\n    }\n});\n\n// virtual\nObject.defineProperty(segmentPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Bad segment declaration. No type specified.');\n    }\n});\n\n// Path segment implementations:\nvar Lineto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Lineto)) { // switching context of `this` to Lineto when called without `new`\n        return applyToNew(Lineto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Lineto constructor expects a line, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            return this;\n\n        } else { // this is a poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) {\n\n                segmentPoint = args[i];\n                outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar linetoPrototype = {\n\n    clone: function() {\n\n        return new Lineto(this.end);\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            new Lineto(divided[0]),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(linetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'L'\n});\n\nLineto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line.prototype, linetoPrototype);\n\nvar Curveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Curveto)) { // switching context of `this` to Curveto when called without `new`\n        return applyToNew(Curveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) { // curves provided\n        if (n === 1) {\n            this.controlPoint1 = args[0].controlPoint1.clone();\n            this.controlPoint2 = args[0].controlPoint2.clone();\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 6) {\n            this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[2], +args[3]);\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[4], +args[5]);\n            return this;\n\n        } else if (n < 6) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 6) { // coords come in groups of six\n\n                segmentCoords = args.slice(i, i + 6); // will send fewer than six coords if args.length not divisible by 6\n                outputArray.push(applyToNew(Curveto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 3) {\n            this.controlPoint1 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            this.controlPoint2 = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[1]);\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[2]);\n            return this;\n\n        } else if (n < 3) {\n            throw new Error('Curveto constructor expects a curve, 3 points, or 6 coordinates (' + n + ' points provided).');\n\n        } else { // this is a poly-bezier segment\n            var segmentPoints;\n            outputArray = [];\n            for (i = 0; i < n; i += 3) { // points come in groups of three\n\n                segmentPoints = args.slice(i, i + 3); // will send fewer than three points if args.length is not divisible by 3\n                outputArray.push(applyToNew(Curveto, segmentPoints));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar curvetoPrototype = {\n\n    clone: function() {\n\n        return new Curveto(this.controlPoint1, this.controlPoint2, this.end);\n    },\n\n    divideAt: function(ratio, opt) {\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAt(ratio, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length, opt) {\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtLength(length, opt);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    divideAtT: function(t) {\n\n        var curve = new _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n        var divided = curve.divideAtT(t);\n        return [\n            new Curveto(divided[0]),\n            new Curveto(divided[1])\n        ];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment) return false;\n\n        var start = this.start;\n        var control1 = this.controlPoint1;\n        var control2 = this.controlPoint2;\n        var end = this.end;\n\n        return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    },\n\n    round: function(precision) {\n\n        this.controlPoint1.round(precision);\n        this.controlPoint2.round(precision);\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var c1 = this.controlPoint1;\n        var c2 = this.controlPoint2;\n        var end = this.end;\n        return this.type + ' ' + c1.x + ' ' + c1.y + ' ' + c2.x + ' ' + c2.y + ' ' + end.x + ' ' + end.y;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.controlPoint1 + ' ' + this.controlPoint2 + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(curvetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'C'\n});\n\nCurveto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve.prototype, curvetoPrototype);\n\nvar Moveto = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Moveto)) { // switching context of `this` to Moveto when called without `new`\n        return applyToNew(Moveto, args);\n    }\n\n    if (n === 0) {\n        throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (none provided).');\n    }\n\n    var outputArray;\n\n    if (args[0] instanceof _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line) { // lines provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' lines provided).');\n        }\n\n    } else if (args[0] instanceof _curve_mjs__WEBPACK_IMPORTED_MODULE_1__.Curve) { // curves provided\n        if (n === 1) {\n            this.end = args[0].end.clone();\n            return this;\n\n        } else {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' curves provided).');\n        }\n\n    } else if (typeof args[0] === 'string' || typeof args[0] === 'number') { // coordinates provided\n        if (n === 2) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(+args[0], +args[1]);\n            return this;\n\n        } else if (n < 2) {\n            throw new Error('Moveto constructor expects a line, a curve, 1 point, or 2 coordinates (' + n + ' coordinates provided).');\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentCoords;\n            outputArray = [];\n            for (i = 0; i < n; i += 2) { // coords come in groups of two\n\n                segmentCoords = args.slice(i, i + 2); // will send one coord if args.length not divisible by 2\n                if (i === 0) outputArray.push(applyToNew(Moveto, segmentCoords));\n                else outputArray.push(applyToNew(Lineto, segmentCoords));\n            }\n            return outputArray;\n        }\n\n    } else { // points provided (needs to be last to also cover plain objects with x and y)\n        if (n === 1) {\n            this.end = new _point_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(args[0]);\n            return this;\n\n        } else { // this is a moveto-with-subsequent-poly-line segment\n            var segmentPoint;\n            outputArray = [];\n            for (i = 0; i < n; i += 1) { // points come one by one\n\n                segmentPoint = args[i];\n                if (i === 0) outputArray.push(new Moveto(segmentPoint));\n                else outputArray.push(new Lineto(segmentPoint));\n            }\n            return outputArray;\n        }\n    }\n};\n\nvar movetoPrototype = {\n\n    bbox: function() {\n\n        return null;\n    },\n\n    clone: function() {\n\n        return new Moveto(this.end);\n    },\n\n    closestPoint: function() {\n\n        return this.end.clone();\n    },\n\n    closestPointNormalizedLength: function() {\n\n        return 0;\n    },\n\n    closestPointLength: function() {\n\n        return 0;\n    },\n\n    closestPointT: function() {\n\n        return 1;\n    },\n\n    closestPointTangent: function() {\n\n        return null;\n    },\n\n    divideAt: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    divideAtLength: function() {\n\n        return [\n            this.clone(),\n            this.clone()\n        ];\n    },\n\n    equals: function(m) {\n\n        return this.end.equals(m.end);\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        return false;\n    },\n\n    isSubpathStart: true,\n\n    isVisible: false,\n\n    length: function() {\n\n        return 0;\n    },\n\n    lengthAtT: function() {\n\n        return 0;\n    },\n\n    pointAt: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtLength: function() {\n\n        return this.end.clone();\n    },\n\n    pointAtT: function() {\n\n        return this.end.clone();\n    },\n\n    round: function(precision) {\n\n        this.end.round(precision);\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        this.end.scale(sx, sy, origin);\n        return this;\n    },\n\n    serialize: function() {\n\n        var end = this.end;\n        return this.type + ' ' + end.x + ' ' + end.y;\n    },\n\n    tangentAt: function() {\n\n        return null;\n    },\n\n    tangentAtLength: function() {\n\n        return null;\n    },\n\n    tangentAtT: function() {\n\n        return null;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.end;\n    },\n\n    translate: function(tx, ty) {\n\n        this.end.translate(tx, ty);\n        return this;\n    }\n};\n\nObject.defineProperty(movetoPrototype, 'start', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n});\n\nObject.defineProperty(movetoPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'M'\n});\n\nMoveto.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, movetoPrototype); // does not inherit from any other geometry object\n\nvar Closepath = function() {\n\n    var args = [];\n    var n = arguments.length;\n    for (var i = 0; i < n; i++) {\n        args.push(arguments[i]);\n    }\n\n    if (!(this instanceof Closepath)) { // switching context of `this` to Closepath when called without `new`\n        return applyToNew(Closepath, args);\n    }\n\n    if (n > 0) {\n        throw new Error('Closepath constructor expects no arguments.');\n    }\n\n    return this;\n};\n\nvar closepathPrototype = {\n\n    clone: function() {\n\n        return new Closepath();\n    },\n\n    divideAt: function(ratio) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAt(ratio);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    divideAtLength: function(length) {\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(this.start, this.end);\n        var divided = line.divideAtLength(length);\n        return [\n            // if we didn't actually cut into the segment, first divided part can stay as Z\n            (divided[1].isDifferentiable() ? new Lineto(divided[0]) : this.clone()),\n            new Lineto(divided[1])\n        ];\n    },\n\n    getSubdivisions: function() {\n\n        return [];\n    },\n\n    isDifferentiable: function() {\n\n        if (!this.previousSegment || !this.subpathStartSegment) return false;\n\n        return !this.start.equals(this.end);\n    },\n\n    round: function() {\n\n        return this;\n    },\n\n    scale: function() {\n\n        return this;\n    },\n\n    serialize: function() {\n\n        return this.type;\n    },\n\n    toString: function() {\n\n        return this.type + ' ' + this.start + ' ' + this.end;\n    },\n\n    translate: function() {\n\n        return this;\n    }\n};\n\nObject.defineProperty(closepathPrototype, 'end', {\n    // get a reference to the end point of subpath start segment\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        if (!this.subpathStartSegment) throw new Error('Missing subpath start segment. (This segment needs a subpath start segment (e.g. Moveto); OR segment has not yet been added to a path.)');\n\n        return this.subpathStartSegment.end;\n    }\n});\n\nObject.defineProperty(closepathPrototype, 'type', {\n\n    configurable: true,\n\n    enumerable: true,\n\n    value: 'Z'\n});\n\nClosepath.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_6__.extend)(segmentPrototype, _line_mjs__WEBPACK_IMPORTED_MODULE_0__.Line.prototype, closepathPrototype);\n\nvar segmentTypes = Path.segmentTypes = {\n    L: Lineto,\n    C: Curveto,\n    M: Moveto,\n    Z: Closepath,\n    z: Closepath\n};\n\nPath.regexSupportedData = new RegExp('^[\\\\s\\\\d' + Object.keys(segmentTypes).join('') + ',.]*$');\n\nPath.isDataSupported = function(data) {\n\n    if (typeof data !== 'string') return false;\n    return this.regexSupportedData.test(data);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9wYXRoLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDMEM7QUFDUjtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDL0I7O0FBRVA7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNLG1EQUFtRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxnQ0FBZ0M7QUFDaEMsd0JBQXdCLE9BQU87O0FBRS9COztBQUVBO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0Esd0JBQXdCLE9BQU87O0FBRS9COztBQUVBLHNDQUFzQywyQ0FBSSxxQkFBcUIsNkNBQUs7QUFDcEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQywyQ0FBSTtBQUN2Qzs7QUFFQSxrQkFBa0Isd0JBQXdCLDZDQUFLO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0sMEJBQTBCO0FBQ2hDOztBQUVBLE1BQU0sd0JBQXdCLDJDQUFJLElBQUk7QUFDdEM7QUFDQTs7QUFFQSxNQUFNLHdCQUF3Qiw2Q0FBSyxJQUFJO0FBQ3ZDO0FBQ0E7O0FBRUEsTUFBTSx3QkFBd0IsbURBQVEsSUFBSTtBQUMxQyxnRUFBZ0U7O0FBRWhFO0FBQ0Esb0JBQW9CLE9BQU87O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLE9BQU87QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlCQUFpQjs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVB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O0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBLHVCQUF1QiwyQ0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBLHVCQUF1QiwyQ0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGtKQUFrSjs7QUFFbEo7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVELHNCQUFzQixtREFBTSxtQkFBbUIsMkNBQUk7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcGF0aC5tanM/ZmI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBY2NlcHRzIHBhdGggZGF0YSBzdHJpbmcsIGFycmF5IG9mIHNlZ21lbnRzLCBhcnJheSBvZiBDdXJ2ZXMgYW5kL29yIExpbmVzLCBvciBhIFBvbHlsaW5lLlxuLy8gUGF0aCBjcmVhdGVkIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgdmFsaWQgKHNlcmlhbGl6YWJsZSkgcGF0aCAobWlnaHQgbm90IHN0YXJ0IHdpdGggYW4gTSkuXG5pbXBvcnQgeyBQb2x5bGluZSB9IGZyb20gJy4vcG9seWxpbmUubWpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuL3JlY3QubWpzJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi9wb2ludC5tanMnO1xuaW1wb3J0IHsgTGluZSB9IGZyb20gJy4vbGluZS5tanMnO1xuaW1wb3J0IHsgQ3VydmUgfSBmcm9tICcuL2N1cnZlLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcbmltcG9ydCB7IGV4dGVuZCB9IGZyb20gJy4vZXh0ZW5kLm1qcyc7XG5leHBvcnQgY29uc3QgUGF0aCA9IGZ1bmN0aW9uKGFyZykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChhcmcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykgeyAvLyBjcmVhdGUgZnJvbSBhIHBhdGggZGF0YSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoLnBhcnNlKGFyZyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIG47XG5cbiAgICBpZiAoIWFyZykge1xuICAgICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCAhPT0gMCkgeyAvLyBpZiBhcmcgaXMgYSBub24tZW1wdHkgYXJyYXlcbiAgICAgICAgLy8gZmxhdHRlbiBvbmUgbGV2ZWwgZGVlcFxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgIGFyZyA9IGFyZy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHZhbCk7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBuID0gYXJnLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1swXS5pc1NlZ21lbnQpIHsgLy8gY3JlYXRlIGZyb20gYW4gYXJyYXkgb2Ygc2VnbWVudHNcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gYXJnW2ldO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIGNyZWF0ZSBmcm9tIGFuIGFycmF5IG9mIEN1cnZlcyBhbmQvb3IgTGluZXNcbiAgICAgICAgICAgIHZhciBwcmV2aW91c09iaiA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gYXJnW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoKG9iaiBpbnN0YW5jZW9mIExpbmUpIHx8IChvYmogaW5zdGFuY2VvZiBDdXJ2ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIHBhdGggc2VnbWVudCBmcm9tIHRoZSBwcm92aWRlZCBvYmplY3QuJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBvYmouc3RhcnQpKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIG9iamVjdHMgZG8gbm90IGxpbmsgdXAsIG1vdmV0byBzZWdtZW50cyBhcmUgaW5zZXJ0ZWQgdG8gY292ZXIgdGhlIGdhcHNcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNPYmogJiYgIXByZXZpb3VzT2JqLmVuZC5lcXVhbHMob2JqLnN0YXJ0KSkgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTScsIG9iai5zdGFydCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIG9iai5lbmQpKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnQycsIG9iai5jb250cm9sUG9pbnQxLCBvYmouY29udHJvbFBvaW50Miwgb2JqLmVuZCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHByZXZpb3VzT2JqID0gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGFyZy5pc1NlZ21lbnQpIHsgLy8gY3JlYXRlIGZyb20gYSBzaW5nbGUgc2VnbWVudFxuICAgICAgICB0aGlzLmFwcGVuZFNlZ21lbnQoYXJnKTtcblxuICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTGluZSkgeyAvLyBjcmVhdGUgZnJvbSBhIHNpbmdsZSBMaW5lXG4gICAgICAgIHRoaXMuYXBwZW5kU2VnbWVudChQYXRoLmNyZWF0ZVNlZ21lbnQoJ00nLCBhcmcuc3RhcnQpKTtcbiAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIGFyZy5lbmQpKTtcblxuICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQ3VydmUpIHsgLy8gY3JlYXRlIGZyb20gYSBzaW5nbGUgQ3VydmVcbiAgICAgICAgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTScsIGFyZy5zdGFydCkpO1xuICAgICAgICB0aGlzLmFwcGVuZFNlZ21lbnQoUGF0aC5jcmVhdGVTZWdtZW50KCdDJywgYXJnLmNvbnRyb2xQb2ludDEsIGFyZy5jb250cm9sUG9pbnQyLCBhcmcuZW5kKSk7XG5cbiAgICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIFBvbHlsaW5lKSB7IC8vIGNyZWF0ZSBmcm9tIGEgUG9seWxpbmVcbiAgICAgICAgaWYgKCEoYXJnLnBvaW50cyAmJiAoYXJnLnBvaW50cy5sZW5ndGggIT09IDApKSkgcmV0dXJuOyAvLyBpZiBQb2x5bGluZSBoYXMgbm8gcG9pbnRzLCBsZWF2ZSBQYXRoIGVtcHR5XG5cbiAgICAgICAgbiA9IGFyZy5wb2ludHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IGFyZy5wb2ludHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB0aGlzLmFwcGVuZFNlZ21lbnQoUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgcG9pbnQpKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5hcHBlbmRTZWdtZW50KFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIHBvaW50KSk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7IC8vIHVua25vd24gb2JqZWN0XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIHBhdGggZnJvbSB0aGUgcHJvdmlkZWQgb2JqZWN0LicpO1xuICAgIH1cbn07XG5cbi8vIE1vcmUgcGVybWlzc2l2ZSB0aGFuIFYubm9ybWFsaXplUGF0aERhdGEgYW5kIFBhdGgucHJvdG90eXBlLnNlcmlhbGl6ZS5cbi8vIEFsbG93cyBwYXRoIGRhdGEgc3RyaW5ncyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGEgTW92ZXRvIGNvbW1hbmQgKHVubGlrZSBTVkcgc3BlY2lmaWNhdGlvbikuXG4vLyBEb2VzIG5vdCByZXF1aXJlIHNwYWNlcyBiZXR3ZWVuIGVsZW1lbnRzOyBjb21tYXMgYXJlIGFsbG93ZWQsIHNlcGFyYXRvcnMgbWF5IGJlIG9taXR0ZWQgd2hlbiB1bmFtYmlndW91cyAoZS5nLiAnWk0xMCwxMCcsICdMMS42LjgnLCAnTTEwMC0yMDAnKS5cbi8vIEFsbG93cyBmb3IgY29tbWFuZCBhcmd1bWVudCBjaGFpbmluZy5cbi8vIFRocm93cyBhbiBlcnJvciBpZiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGlzIHByb3ZpZGVkIHdpdGggYSBjb21tYW5kLlxuLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFuIHVucmVjb2duaXplZCBwYXRoIGNvbW1hbmQgaXMgcHJvdmlkZWQgKGFjY29yZGluZyB0byBQYXRoLnNlZ21lbnRUeXBlcykuIE9ubHkgYSBzdWJzZXQgb2YgU1ZHIGNvbW1hbmRzIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQgKEwsIEMsIE0sIFopLlxuUGF0aC5wYXJzZSA9IGZ1bmN0aW9uKHBhdGhEYXRhKSB7XG5cbiAgICBpZiAoIXBhdGhEYXRhKSByZXR1cm4gbmV3IFBhdGgoKTtcblxuICAgIHZhciBwYXRoID0gbmV3IFBhdGgoKTtcblxuICAgIHZhciBjb21tYW5kUmUgPSAvKD86W2EtekEtWl0gKikoPzooPzotP1xcZCsoPzpcXC5cXGQrKT8oPzplWy0rXT9cXGQrKT8gKiw/ICopfCg/Oi0/XFwuXFxkKyAqLD8gKikpK3woPzpbYS16QS1aXSAqKSg/ISB8XFxkfC18XFwuKS9nO1xuICAgIHZhciBjb21tYW5kcyA9IHBhdGhEYXRhLm1hdGNoKGNvbW1hbmRSZSk7XG5cbiAgICB2YXIgbnVtQ29tbWFuZHMgPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db21tYW5kczsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgdmFyIGFyZ1JlID0gLyg/OlthLXpBLVpdKXwoPzooPzotP1xcZCsoPzpcXC5cXGQrKT8oPzplWy0rXT9cXGQrKT8pKXwoPzooPzotP1xcLlxcZCspKS9nO1xuICAgICAgICB2YXIgYXJncyA9IGNvbW1hbmQubWF0Y2goYXJnUmUpO1xuXG4gICAgICAgIHZhciBzZWdtZW50ID0gUGF0aC5jcmVhdGVTZWdtZW50LmFwcGx5KHRoaXMsIGFyZ3MpOyAvLyBhcmdzID0gW3R5cGUsIGNvb3JkaW5hdGUxLCBjb29yZGluYXRlMi4uLl1cbiAgICAgICAgcGF0aC5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLy8gQ3JlYXRlIGEgc2VnbWVudCBvciBhbiBhcnJheSBvZiBzZWdtZW50cy5cbi8vIEFjY2VwdHMgdW5saW1pdGVkIHBvaW50cy9jb29yZHMgYXJndW1lbnRzIGFmdGVyIGB0eXBlYC5cblBhdGguY3JlYXRlU2VnbWVudCA9IGZ1bmN0aW9uKHR5cGUpIHtcblxuICAgIGlmICghdHlwZSkgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG11c3QgYmUgcHJvdmlkZWQuJyk7XG5cbiAgICB2YXIgc2VnbWVudENvbnN0cnVjdG9yID0gUGF0aC5zZWdtZW50VHlwZXNbdHlwZV07XG4gICAgaWYgKCFzZWdtZW50Q29uc3RydWN0b3IpIHRocm93IG5ldyBFcnJvcih0eXBlICsgJyBpcyBub3QgYSByZWNvZ25pemVkIHBhdGggc2VnbWVudCB0eXBlLicpO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHsgLy8gZG8gbm90IGFkZCBmaXJzdCBlbGVtZW50IChgdHlwZWApIHRvIGFyZ3MgYXJyYXlcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcGx5VG9OZXcoc2VnbWVudENvbnN0cnVjdG9yLCBhcmdzKTtcbn07XG5cblBhdGgucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuUGF0aCxcblxuICAgIC8vIEFjY2VwdHMgb25lIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYXMgYXJndW1lbnQuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGlzIG5vdCBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgYXBwZW5kU2VnbWVudDogZnVuY3Rpb24oYXJnKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAvLyB3b3JrcyBldmVuIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzXG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50O1xuXG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSAoKG51bVNlZ21lbnRzICE9PSAwKSA/IHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0gOiBudWxsKTsgLy8gaWYgd2UgYXJlIGFwcGVuZGluZyB0byBhbiBlbXB0eSBwYXRoLCBwcmV2aW91c1NlZ21lbnQgaXMgbnVsbFxuICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7IC8vIGFyZyBpcyBhIHNlZ21lbnRcbiAgICAgICAgICAgIGlmICghYXJnIHx8ICFhcmcuaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnQgcmVxdWlyZWQuJyk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRTZWdtZW50ID0gdGhpcy5wcmVwYXJlU2VnbWVudChhcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaChjdXJyZW50U2VnbWVudCk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gYXJnIGlzIGFuIGFycmF5IG9mIHNlZ21lbnRzXG4gICAgICAgICAgICAvLyBmbGF0dGVuIG9uZSBsZXZlbCBkZWVwXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdbMF0uaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICB2YXIgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGN1cnJlbnRBcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goY3VycmVudFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2VnbWVudCA9IGN1cnJlbnRTZWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGJib3ggb2YgdGhlIHBhdGguXG4gICAgLy8gSWYgcGF0aCBoYXMgbm8gc2VnbWVudHMsIHJldHVybnMgbnVsbC5cbiAgICAvLyBJZiBwYXRoIGhhcyBvbmx5IGludmlzaWJsZSBzZWdtZW50cywgcmV0dXJucyBiYm94IG9mIHRoZSBlbmQgcG9pbnQgb2YgbGFzdCBzZWdtZW50LlxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudEJCb3ggPSBzZWdtZW50LmJib3goKTtcbiAgICAgICAgICAgICAgICBiYm94ID0gYmJveCA/IGJib3gudW5pb24oc2VnbWVudEJCb3gpIDogc2VnbWVudEJCb3g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmJveCkgcmV0dXJuIGJib3g7XG5cbiAgICAgICAgLy8gaWYgdGhlIHBhdGggaGFzIG9ubHkgaW52aXNpYmxlIGVsZW1lbnRzLCByZXR1cm4gZW5kIHBvaW50IG9mIGxhc3Qgc2VnbWVudFxuICAgICAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdO1xuICAgICAgICByZXR1cm4gbmV3IFJlY3QobGFzdFNlZ21lbnQuZW5kLngsIGxhc3RTZWdtZW50LmVuZC55LCAwLCAwKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIG5ldyBwYXRoIHRoYXQgaXMgYSBjbG9uZSBvZiB0aGlzIHBhdGguXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV0uY2xvbmUoKTtcbiAgICAgICAgICAgIHBhdGguYXBwZW5kU2VnbWVudChzZWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUKHAsIG9wdCk7XG4gICAgICAgIGlmICghdCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucG9pbnRBdFQodCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludExlbmd0aDogZnVuY3Rpb24ocCwgb3B0KSB7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciB0ID0gdGhpcy5jbG9zZXN0UG9pbnRUKHAsIGxvY2FsT3B0KTtcbiAgICAgICAgaWYgKCF0KSByZXR1cm4gMDtcblxuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGhBdFQodCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCwgbG9jYWxPcHQpO1xuICAgICAgICBpZiAoY3BMZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBzaG9ydGN1dFxuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBwcmV2ZW50cyBkaXZpc2lvbiBieSB6ZXJvXG5cbiAgICAgICAgcmV0dXJuIGNwTGVuZ3RoIC8gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBQcml2YXRlIGZ1bmN0aW9uLlxuICAgIGNsb3Nlc3RQb2ludFQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgY2xvc2VzdFBvaW50VDtcbiAgICAgICAgdmFyIG1pblNxdWFyZWREaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvbnMgPSBzZWdtZW50U3ViZGl2aXNpb25zW2ldO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudENsb3Nlc3RQb2ludFQgPSBzZWdtZW50LmNsb3Nlc3RQb2ludFQocCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudENsb3Nlc3RQb2ludCA9IHNlZ21lbnQucG9pbnRBdFQoc2VnbWVudENsb3Nlc3RQb2ludFQpO1xuICAgICAgICAgICAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSAobmV3IExpbmUoc2VnbWVudENsb3Nlc3RQb2ludCwgcCkpLnNxdWFyZWRMZW5ndGgoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPCBtaW5TcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50VCA9IHsgc2VnbWVudEluZGV4OiBpLCB2YWx1ZTogc2VnbWVudENsb3Nlc3RQb2ludFQgfTtcbiAgICAgICAgICAgICAgICAgICAgbWluU3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbG9zZXN0UG9pbnRUKSByZXR1cm4gY2xvc2VzdFBvaW50VDtcblxuICAgICAgICAvLyBpZiBubyB2aXNpYmxlIHNlZ21lbnQsIHJldHVybiBlbmQgb2YgbGFzdCBzZWdtZW50XG4gICAgICAgIHJldHVybiB7IHNlZ21lbnRJbmRleDogbnVtU2VnbWVudHMgLSAxLCB2YWx1ZTogMSB9O1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUYW5nZW50OiBmdW5jdGlvbihwLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludFRhbmdlbnQ7XG4gICAgICAgIHZhciBtaW5TcXVhcmVkRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNEaWZmZXJlbnRpYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRDbG9zZXN0UG9pbnRUID0gc2VnbWVudC5jbG9zZXN0UG9pbnRUKHAsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRDbG9zZXN0UG9pbnQgPSBzZWdtZW50LnBvaW50QXRUKHNlZ21lbnRDbG9zZXN0UG9pbnRUKTtcbiAgICAgICAgICAgICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gKG5ldyBMaW5lKHNlZ21lbnRDbG9zZXN0UG9pbnQsIHApKS5zcXVhcmVkTGVuZ3RoKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDwgbWluU3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RQb2ludFRhbmdlbnQgPSBzZWdtZW50LnRhbmdlbnRBdFQoc2VnbWVudENsb3Nlc3RQb2ludFQpO1xuICAgICAgICAgICAgICAgICAgICBtaW5TcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb3Nlc3RQb2ludFRhbmdlbnQpIHJldHVybiBjbG9zZXN0UG9pbnRUYW5nZW50O1xuXG4gICAgICAgIC8vIGlmIG5vIHZhbGlkIHNlZ21lbnQsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJlYSBzdXJyb3VuZGVkIGJ5IHRoZSBwYXRoIGNvbnRhaW5zIHRoZSBwb2ludCBgcGAuXG4gICAgLy8gSW1wbGVtZW50cyB0aGUgZXZlbi1vZGQgYWxnb3JpdGhtIChzZWxmLWludGVyc2VjdGlvbnMgYXJlIFwib3V0c2lkZVwiKS5cbiAgICAvLyBDbG9zZXMgb3BlbiBwYXRocyAoYWx3YXlzIGltYWdpbmVzIGEgZmluYWwgY2xvc2luZyBzZWdtZW50KS5cbiAgICAvLyBQcmVjaXNpb24gbWF5IGJlIGFkanVzdGVkIGJ5IHBhc3NpbmcgYW4gYG9wdGAgb2JqZWN0LlxuICAgIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHAsIG9wdCkge1xuXG4gICAgICAgIHZhciBwb2x5bGluZXMgPSB0aGlzLnRvUG9seWxpbmVzKG9wdCk7XG4gICAgICAgIGlmICghcG9seWxpbmVzKSByZXR1cm4gZmFsc2U7IC8vIHNob3J0Y3V0ICh0aGlzIHBhdGggaGFzIG5vIHBvbHlsaW5lcylcblxuICAgICAgICB2YXIgbnVtUG9seWxpbmVzID0gcG9seWxpbmVzLmxlbmd0aDtcblxuICAgICAgICAvLyBob3cgbWFueSBjb21wb25lbnQgcG9seWxpbmVzIGRvZXMgYHBgIGxpZSB3aXRoaW4/XG4gICAgICAgIHZhciBudW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2x5bGluZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvbHlsaW5lID0gcG9seWxpbmVzW2ldO1xuICAgICAgICAgICAgaWYgKHBvbHlsaW5lLmNvbnRhaW5zUG9pbnQocCkpIHtcbiAgICAgICAgICAgICAgICAvLyBgcGAgbGllcyB3aXRoaW4gdGhpcyBwb2x5bGluZVxuICAgICAgICAgICAgICAgIG51bUludGVyc2VjdGlvbnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybnMgYHRydWVgIGZvciBvZGQgbnVtYmVycyBvZiBpbnRlcnNlY3Rpb25zIChldmVuLW9kZCBhbGdvcml0aG0pXG4gICAgICAgIHJldHVybiAoKG51bUludGVyc2VjdGlvbnMgJSAyKSA9PT0gMSk7XG4gICAgfSxcblxuICAgIC8vIERpdmlkZXMgdGhlIHBhdGggaW50byB0d28gYXQgcmVxdWVzdGVkIGByYXRpb2AgYmV0d2VlbiAwIGFuZCAxIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgMCkgcmF0aW8gPSAwO1xuICAgICAgICBpZiAocmF0aW8gPiAxKSByYXRpbyA9IDE7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aExlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZUF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBEaXZpZGVzIHRoZSBwYXRoIGludG8gdHdvIGF0IHJlcXVlc3RlZCBgbGVuZ3RoYCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgICAgLy8gaWRlbnRpZnkgdGhlIHNlZ21lbnQgdG8gZGl2aWRlOlxuXG4gICAgICAgIHZhciBsID0gMDsgLy8gbGVuZ3RoIHNvIGZhclxuICAgICAgICB2YXIgZGl2aWRlZDtcbiAgICAgICAgdmFyIGRpdmlkZWRTZWdtZW50SW5kZXg7XG4gICAgICAgIHZhciBsYXN0VmFsaWRTZWdtZW50OyAvLyB2aXNpYmxlIEFORCBkaWZmZXJlbnRpYWJsZVxuICAgICAgICB2YXIgbGFzdFZhbGlkU2VnbWVudEluZGV4O1xuICAgICAgICB2YXIgdDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG51bVNlZ21lbnRzIC0gMSAtIGkpKTtcblxuICAgICAgICAgICAgc2VnbWVudCA9IHRoaXMuZ2V0U2VnbWVudChpbmRleCk7XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQubGVuZ3RoKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc0RpZmZlcmVudGlhYmxlKCkpIHsgLy8gc2VnbWVudCBpcyBub3QganVzdCBhIHBvaW50XG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkU2VnbWVudEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlZFNlZ21lbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBkaXZpZGVkID0gc2VnbWVudC5kaXZpZGVBdExlbmd0aCgoKGZyb21TdGFydCA/IDEgOiAtMSkgKiAobGVuZ3RoIC0gbCkpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbGFzdFZhbGlkU2VnbWVudCkgeyAvLyBubyB2YWxpZCBzZWdtZW50IGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2U6IHRoZSBwYXRoIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSB2YWxpZCBzZWdtZW50XG5cbiAgICAgICAgaWYgKCFkaXZpZGVkKSB7IC8vIHRoZSBkZXNpcmVkIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcGF0aFxuICAgICAgICAgICAgZGl2aWRlZFNlZ21lbnRJbmRleCA9IGxhc3RWYWxpZFNlZ21lbnRJbmRleDtcbiAgICAgICAgICAgIHQgPSAoZnJvbVN0YXJ0ID8gMSA6IDApO1xuICAgICAgICAgICAgZGl2aWRlZCA9IGxhc3RWYWxpZFNlZ21lbnQuZGl2aWRlQXRUKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgY29weSBvZiB0aGlzIHBhdGggYW5kIHJlcGxhY2UgdGhlIGlkZW50aWZpZWQgc2VnbWVudCB3aXRoIGl0cyB0d28gZGl2aWRlZCBwYXJ0czpcblxuICAgICAgICB2YXIgcGF0aENvcHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHBhdGhDb3B5LnJlcGxhY2VTZWdtZW50KGRpdmlkZWRTZWdtZW50SW5kZXgsIGRpdmlkZWQpO1xuXG4gICAgICAgIHZhciBkaXZpc2lvblN0YXJ0SW5kZXggPSBkaXZpZGVkU2VnbWVudEluZGV4O1xuICAgICAgICB2YXIgZGl2aXNpb25NaWRJbmRleCA9IGRpdmlkZWRTZWdtZW50SW5kZXggKyAxO1xuICAgICAgICB2YXIgZGl2aXNpb25FbmRJbmRleCA9IGRpdmlkZWRTZWdtZW50SW5kZXggKyAyO1xuXG4gICAgICAgIC8vIGRvIG5vdCBpbnNlcnQgdGhlIHBhcnQgaWYgaXQgbG9va3MgbGlrZSBhIHBvaW50XG4gICAgICAgIGlmICghZGl2aWRlZFswXS5pc0RpZmZlcmVudGlhYmxlKCkpIHtcbiAgICAgICAgICAgIHBhdGhDb3B5LnJlbW92ZVNlZ21lbnQoZGl2aXNpb25TdGFydEluZGV4KTtcbiAgICAgICAgICAgIGRpdmlzaW9uTWlkSW5kZXggLT0gMTtcbiAgICAgICAgICAgIGRpdmlzaW9uRW5kSW5kZXggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc2VydCBhIE1vdmV0byBzZWdtZW50IHRvIGVuc3VyZSBzZWNvbmRQYXRoIHdpbGwgYmUgdmFsaWQ6XG4gICAgICAgIHZhciBtb3ZldG9FbmQgPSBwYXRoQ29weS5nZXRTZWdtZW50KGRpdmlzaW9uTWlkSW5kZXgpLnN0YXJ0O1xuICAgICAgICBwYXRoQ29weS5pbnNlcnRTZWdtZW50KGRpdmlzaW9uTWlkSW5kZXgsIFBhdGguY3JlYXRlU2VnbWVudCgnTScsIG1vdmV0b0VuZCkpO1xuICAgICAgICBkaXZpc2lvbkVuZEluZGV4ICs9IDE7XG5cbiAgICAgICAgLy8gZG8gbm90IGluc2VydCB0aGUgcGFydCBpZiBpdCBsb29rcyBsaWtlIGEgcG9pbnRcbiAgICAgICAgaWYgKCFkaXZpZGVkWzFdLmlzRGlmZmVyZW50aWFibGUoKSkge1xuICAgICAgICAgICAgcGF0aENvcHkucmVtb3ZlU2VnbWVudChkaXZpc2lvbkVuZEluZGV4IC0gMSk7XG4gICAgICAgICAgICBkaXZpc2lvbkVuZEluZGV4IC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCBDbG9zZXBhdGggc2VnbWVudHMgaW4gc2Vjb25kUGF0aCB3aWxsIGJlIGFzc2lnbmVkIGNvcnJlY3Qgc3VicGF0aFN0YXJ0U2VnbWVudDpcblxuICAgICAgICB2YXIgc2Vjb25kUGF0aFNlZ21lbnRJbmRleENvbnZlcnNpb24gPSBkaXZpc2lvbkVuZEluZGV4IC0gZGl2aXNpb25TdGFydEluZGV4IC0gMTtcbiAgICAgICAgZm9yIChpID0gZGl2aXNpb25FbmRJbmRleDsgaSA8IHBhdGhDb3B5LnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFNlZ21lbnQgPSB0aGlzLmdldFNlZ21lbnQoaSAtIHNlY29uZFBhdGhTZWdtZW50SW5kZXhDb252ZXJzaW9uKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBwYXRoQ29weS5nZXRTZWdtZW50KGkpO1xuXG4gICAgICAgICAgICBpZiAoKHNlZ21lbnQudHlwZSA9PT0gJ1onKSAmJiAhb3JpZ2luYWxTZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQuZW5kLmVxdWFscyhzZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQuZW5kKSkge1xuICAgICAgICAgICAgICAgIC8vIHBhdGhDb3B5IHNlZ21lbnQncyBzdWJwYXRoU3RhcnRTZWdtZW50IGlzIGRpZmZlcmVudCBmcm9tIG9yaWdpbmFsIHNlZ21lbnQncyBvbmVcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoaXMgQ2xvc2VwYXRoIHNlZ21lbnQgdG8gYSBMaW5ldG8gYW5kIHJlcGxhY2UgaXQgaW4gcGF0aENvcHlcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydGVkU2VnbWVudCA9IFBhdGguY3JlYXRlU2VnbWVudCgnTCcsIG9yaWdpbmFsU2VnbWVudC5lbmQpO1xuICAgICAgICAgICAgICAgIHBhdGhDb3B5LnJlcGxhY2VTZWdtZW50KGksIGNvbnZlcnRlZFNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlzdHJpYnV0ZSBwYXRoQ29weSBzZWdtZW50cyBpbnRvIHR3byBwYXRocyBhbmQgcmV0dXJuIHRob3NlOlxuXG4gICAgICAgIHZhciBmaXJzdFBhdGggPSBuZXcgUGF0aChwYXRoQ29weS5zZWdtZW50cy5zbGljZSgwLCBkaXZpc2lvbk1pZEluZGV4KSk7XG4gICAgICAgIHZhciBzZWNvbmRQYXRoID0gbmV3IFBhdGgocGF0aENvcHkuc2VnbWVudHMuc2xpY2UoZGl2aXNpb25NaWRJbmRleCkpO1xuXG4gICAgICAgIHJldHVybiBbZmlyc3RQYXRoLCBzZWNvbmRQYXRoXTtcbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIHdoZXRoZXIgdHdvIHBhdGhzIGFyZSBleGFjdGx5IHRoZSBzYW1lLlxuICAgIC8vIElmIGBwYCBpcyB1bmRlZmluZWQgb3IgbnVsbCwgcmV0dXJucyBmYWxzZS5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgb3RoZXJTZWdtZW50cyA9IHAuc2VnbWVudHM7XG5cbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAob3RoZXJTZWdtZW50cy5sZW5ndGggIT09IG51bVNlZ21lbnRzKSByZXR1cm4gZmFsc2U7IC8vIGlmIHRoZSB0d28gcGF0aHMgaGF2ZSBkaWZmZXJlbnQgbnVtYmVyIG9mIHNlZ21lbnRzLCB0aGV5IGNhbm5vdCBiZSBlcXVhbFxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG90aGVyU2VnbWVudCA9IG90aGVyU2VnbWVudHNbaV07XG5cbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYW4gaW5lcXVhbGl0eSBpcyBmb3VuZCBpbiBzZWdtZW50cywgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBpZiAoKHNlZ21lbnQudHlwZSAhPT0gb3RoZXJTZWdtZW50LnR5cGUpIHx8ICghc2VnbWVudC5lcXVhbHMob3RoZXJTZWdtZW50KSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGluZXF1YWxpdHkgZm91bmQgaW4gc2VnbWVudHMsIHJldHVybiB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGluZGljZXMuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgZ2V0U2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGhhcyBubyBzZWdtZW50cy4nKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IG51bVNlZ21lbnRzICsgaW5kZXg7IC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlcyB0byBwb3NpdGl2ZVxuICAgICAgICBpZiAoaW5kZXggPj0gbnVtU2VnbWVudHMgfHwgaW5kZXggPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZS4nKTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHNlZ21lbnQgc3ViZGl2aXNpb25zLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gLlxuICAgIGdldFNlZ21lbnRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICAvLyBub3QgdXNpbmcgb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnNcbiAgICAgICAgLy8gbm90IHVzaW5nIGxvY2FsT3B0XG5cbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudC5nZXRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KTtcbiAgICAgICAgICAgIHNlZ21lbnRTdWJkaXZpc2lvbnMucHVzaChzdWJkaXZpc2lvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2Ygc3VicGF0aHMgb2YgdGhpcyBwYXRoLlxuICAgIC8vIEludmFsaWQgcGF0aHMgYXJlIHZhbGlkYXRlZCBmaXJzdC5cbiAgICAvLyBSZXR1cm5zIGBbXWAgaWYgcGF0aCBoYXMgbm8gc2VnbWVudHMuXG4gICAgZ2V0U3VicGF0aHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZFBhdGggPSB0aGlzLmNsb25lKCkudmFsaWRhdGUoKTtcblxuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHZhbGlkYXRlZFBhdGguc2VnbWVudHM7XG4gICAgICAgIGNvbnN0IG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IHN1YnBhdGhzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1N1YnBhdGhTdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGVuY291bnRlcmVkIGEgc3VicGF0aCBzdGFydCBzZWdtZW50XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHBhdGggZm9yIHNlZ21lbnQsIGFuZCBwdXNoIGl0IHRvIGxpc3Qgb2Ygc3VicGF0aHNcbiAgICAgICAgICAgICAgICBzdWJwYXRocy5wdXNoKG5ldyBQYXRoKHNlZ21lbnQpKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgY3VycmVudCBzZWdtZW50IHRvIHRoZSBsYXN0IHN1YnBhdGhcbiAgICAgICAgICAgICAgICBzdWJwYXRoc1tzdWJwYXRocy5sZW5ndGggLSAxXS5hcHBlbmRTZWdtZW50KHNlZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnBhdGhzO1xuICAgIH0sXG5cbiAgICAvLyBJbnNlcnQgYGFyZ2AgYXQgZ2l2ZW4gYGluZGV4YC5cbiAgICAvLyBgaW5kZXggPSAwYCBtZWFucyBpbnNlcnQgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAvLyBgaW5kZXggPSBzZWdtZW50cy5sZW5ndGhgIG1lYW5zIGluc2VydCBhdCB0aGUgZW5kLlxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgaW5kaWNlcywgZnJvbSBgLTFgIHRvIGAtKHNlZ21lbnRzLmxlbmd0aCArIDEpYC5cbiAgICAvLyBBY2NlcHRzIG9uZSBzZWdtZW50IG9yIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFzIGFyZ3VtZW50LlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGlzIG5vdCBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgaW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXgsIGFyZykge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gd29ya3MgZXZlbiBpZiBwYXRoIGhhcyBubyBzZWdtZW50c1xuXG4gICAgICAgIC8vIG5vdGUgdGhhdCB0aGVzZSBhcmUgaW5jcmVtZW50ZWQgY29tcGFyZWQgdG8gZ2V0U2VnbWVudHMoKVxuICAgICAgICAvLyB3ZSBjYW4gaW5zZXJ0IGFmdGVyIGxhc3QgZWxlbWVudCAobm90ZSB0aGF0IHRoaXMgY2hhbmdlcyB0aGUgbWVhbmluZyBvZiBpbmRleCAtMSlcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBudW1TZWdtZW50cyArIGluZGV4ICsgMTsgLy8gY29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIHRvIHBvc2l0aXZlXG4gICAgICAgIGlmIChpbmRleCA+IG51bVNlZ21lbnRzIHx8IGluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UuJyk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50O1xuXG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSBudWxsO1xuICAgICAgICB2YXIgbmV4dFNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChudW1TZWdtZW50cyAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDEpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBzZWdtZW50c1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIG5leHRTZWdtZW50ID0gcHJldmlvdXNTZWdtZW50Lm5leHRTZWdtZW50OyAvLyBpZiB3ZSBhcmUgaW5zZXJ0aW5nIGF0IGVuZCwgbmV4dFNlZ21lbnQgaXMgbnVsbFxuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpZiBpbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzU2VnbWVudCBpcyBudWxsXG4gICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSBzZWdtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoIWFyZyB8fCAhYXJnLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50IHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHRoaXMucHJlcGFyZVNlZ21lbnQoYXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZShpbmRleCwgMCwgY3VycmVudFNlZ21lbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbGF0dGVuIG9uZSBsZXZlbCBkZWVwXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdbMF0uaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICB2YXIgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGN1cnJlbnRBcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZSgoaW5kZXggKyBpKSwgMCwgY3VycmVudFNlZ21lbnQpOyAvLyBpbmNyZW1lbnRpbmcgaW5kZXggdG8gaW5zZXJ0IHN1YnNlcXVlbnQgc2VnbWVudHMgYWZ0ZXIgaW5zZXJ0ZWQgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBjdXJyZW50U2VnbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Rpb25XaXRoTGluZTogZnVuY3Rpb24obGluZSwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBwb2x5bGluZXMgPSB0aGlzLnRvUG9seWxpbmVzKG9wdCk7XG4gICAgICAgIGlmICghcG9seWxpbmVzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5bGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9seWxpbmUgPSBwb2x5bGluZXNbaV07XG4gICAgICAgICAgICB2YXIgcG9seWxpbmVJbnRlcnNlY3Rpb24gPSBsaW5lLmludGVyc2VjdChwb2x5bGluZSk7XG4gICAgICAgICAgICBpZiAocG9seWxpbmVJbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24gfHwgKGludGVyc2VjdGlvbiA9IFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2x5bGluZUludGVyc2VjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9uLCBwb2x5bGluZUludGVyc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnB1c2gocG9seWxpbmVJbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfSxcblxuICAgIGlzRGlmZmVyZW50aWFibGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYSBkaWZmZXJlbnRpYWJsZSBzZWdtZW50IGlzIGZvdW5kIGluIHNlZ21lbnRzLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGRpZmZlcmVudGlhYmxlIHNlZ21lbnQgaXMgZm91bmQgaW4gc2VnbWVudHMsIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB3aGV0aGVyIGN1cnJlbnQgcGF0aCBzZWdtZW50cyBhcmUgdmFsaWQuXG4gICAgLy8gTm90ZSB0aGF0IGQgaXMgYWxsb3dlZCB0byBiZSBlbXB0eSAtIHNob3VsZCBkaXNhYmxlIHJlbmRlcmluZyBvZiB0aGUgcGF0aC5cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgaXNWYWxpZCA9IChzZWdtZW50cy5sZW5ndGggPT09IDApIHx8IChzZWdtZW50c1swXS50eXBlID09PSAnTScpOyAvLyBlaXRoZXIgZW1wdHkgb3IgZmlyc3Qgc2VnbWVudCBpcyBhIE1vdmV0b1xuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBsZW5ndGggb2YgdGhlIHBhdGgsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9yIHVzaW5nIGBvcHQuc2VnbWVudFN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gSWYgcGF0aCBoYXMgbm8gc2VnbWVudHMsIHJldHVybnMgMC5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gMDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjsgLy8gb3B0LnByZWNpc2lvbiBvbmx5IHVzZWQgaW4gZ2V0U2VnbWVudFN1YmRpdmlzaW9ucygpIGNhbGxcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzZWdtZW50Lmxlbmd0aCh7IHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbi5cbiAgICBsZW5ndGhBdFQ6IGZ1bmN0aW9uKHQsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gMDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdC5zZWdtZW50SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSByZXR1cm4gMDsgLy8gcmVnYXJkbGVzcyBvZiB0LnZhbHVlXG5cbiAgICAgICAgdmFyIHRWYWx1ZSA9IHQudmFsdWU7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPj0gbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IG51bVNlZ21lbnRzIC0gMTtcbiAgICAgICAgICAgIHRWYWx1ZSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodFZhbHVlIDwgMCkgdFZhbHVlID0gMDtcbiAgICAgICAgZWxzZSBpZiAodFZhbHVlID4gMSkgdFZhbHVlID0gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgc3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50SW5kZXg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpXTtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lzb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudEluZGV4XTtcbiAgICAgICAgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tzZWdtZW50SW5kZXhdO1xuICAgICAgICBsZW5ndGggKz0gc2VnbWVudC5sZW5ndGhBdFQodFZhbHVlLCB7IHByZWNpc2lzb246IHByZWNpc2lvbiwgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnMgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBwb2ludCBhdCByZXF1ZXN0ZWQgYHJhdGlvYCBiZXR3ZWVuIDAgYW5kIDEsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zZWdtZW50U3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICBwb2ludEF0OiBmdW5jdGlvbihyYXRpbywgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIGlmIChyYXRpbyA8PSAwKSByZXR1cm4gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBpZiAocmF0aW8gPj0gMSkgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG5cbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgcHJlY2lzaW9uID0gKG9wdC5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCkgPyB0aGlzLlBSRUNJU0lPTiA6IG9wdC5wcmVjaXNpb247XG4gICAgICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gKG9wdC5zZWdtZW50U3ViZGl2aXNpb25zID09PSB1bmRlZmluZWQpID8gdGhpcy5nZXRTZWdtZW50U3ViZGl2aXNpb25zKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSkgOiBvcHQuc2VnbWVudFN1YmRpdmlzaW9ucztcbiAgICAgICAgdmFyIGxvY2FsT3B0ID0geyBwcmVjaXNpb246IHByZWNpc2lvbiwgc2VnbWVudFN1YmRpdmlzaW9uczogc2VnbWVudFN1YmRpdmlzaW9ucyB9O1xuXG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gdGhpcy5sZW5ndGgobG9jYWxPcHQpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aExlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50QXRMZW5ndGgobGVuZ3RoLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcG9pbnQgYXQgcmVxdWVzdGVkIGBsZW5ndGhgLCB3aXRoIHByZWNpc2lvbiBiZXR0ZXIgdGhhbiByZXF1ZXN0ZWQgYG9wdC5wcmVjaXNpb25gOyBvcHRpb25hbGx5IHVzaW5nIGBvcHQuc2VnbWVudFN1YmRpdmlzaW9uc2AgcHJvdmlkZWQuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBsZW5ndGguXG4gICAgcG9pbnRBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHNlZ21lbnRzIGlzIGFuIGVtcHR5IGFycmF5XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuc3RhcnQuY2xvbmUoKTtcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGFzdFZpc2libGVTZWdtZW50O1xuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChudW1TZWdtZW50cyAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWdtZW50LnBvaW50QXRMZW5ndGgoKChmcm9tU3RhcnQgPyAxIDogLTEpICogKGxlbmd0aCAtIGwpKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBwcmVjaXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9uc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZVNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsICs9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZW5ndGggcmVxdWVzdGVkIGlzIGhpZ2hlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIHBhdGgsIHJldHVybiBsYXN0IHZpc2libGUgc2VnbWVudCBlbmRwb2ludFxuICAgICAgICBpZiAobGFzdFZpc2libGVTZWdtZW50KSByZXR1cm4gKGZyb21TdGFydCA/IGxhc3RWaXNpYmxlU2VnbWVudC5lbmQgOiBsYXN0VmlzaWJsZVNlZ21lbnQuc3RhcnQpO1xuXG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIGxhc3Qgc2VnbWVudCBlbmQgcG9pbnQgKG5vIG1hdHRlciBpZiBmcm9tU3RhcnQgb3Igbm8pXG4gICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV07XG4gICAgICAgIHJldHVybiBsYXN0U2VnbWVudC5lbmQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbi5cbiAgICBwb2ludEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdC5zZWdtZW50SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSByZXR1cm4gc2VnbWVudHNbMF0ucG9pbnRBdFQoMCk7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPj0gbnVtU2VnbWVudHMpIHJldHVybiBzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLnBvaW50QXRUKDEpO1xuXG4gICAgICAgIHZhciB0VmFsdWUgPSB0LnZhbHVlO1xuICAgICAgICBpZiAodFZhbHVlIDwgMCkgdFZhbHVlID0gMDtcbiAgICAgICAgZWxzZSBpZiAodFZhbHVlID4gMSkgdFZhbHVlID0gMTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudHNbc2VnbWVudEluZGV4XS5wb2ludEF0VCh0VmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgIFBSRUNJU0lPTjogMyxcblxuICAgIC8vIEhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBzZWdtZW50cy5cbiAgICBwcmVwYXJlU2VnbWVudDogZnVuY3Rpb24oc2VnbWVudCwgcHJldmlvdXNTZWdtZW50LCBuZXh0U2VnbWVudCkge1xuXG4gICAgICAgIC8vIGluc2VydCBhZnRlciBwcmV2aW91cyBzZWdtZW50IGFuZCBiZWZvcmUgcHJldmlvdXMgc2VnbWVudCdzIG5leHQgc2VnbWVudFxuICAgICAgICBzZWdtZW50LnByZXZpb3VzU2VnbWVudCA9IHByZXZpb3VzU2VnbWVudDtcbiAgICAgICAgc2VnbWVudC5uZXh0U2VnbWVudCA9IG5leHRTZWdtZW50O1xuICAgICAgICBpZiAocHJldmlvdXNTZWdtZW50KSBwcmV2aW91c1NlZ21lbnQubmV4dFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICBpZiAobmV4dFNlZ21lbnQpIG5leHRTZWdtZW50LnByZXZpb3VzU2VnbWVudCA9IHNlZ21lbnQ7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVN1YnBhdGhTdGFydCA9IHNlZ21lbnQ7XG4gICAgICAgIGlmIChzZWdtZW50LmlzU3VicGF0aFN0YXJ0KSB7XG4gICAgICAgICAgICBzZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQgPSBzZWdtZW50OyAvLyBhc3NpZ24gc2VsZiBhcyBzdWJwYXRoIHN0YXJ0IHNlZ21lbnRcbiAgICAgICAgICAgIHVwZGF0ZVN1YnBhdGhTdGFydCA9IG5leHRTZWdtZW50OyAvLyBzdGFydCB1cGRhdGluZyBmcm9tIG5leHQgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXNzaWduIHByZXZpb3VzIHNlZ21lbnQncyBzdWJwYXRoIHN0YXJ0IChvciBzZWxmIGlmIGl0IGlzIGEgc3VicGF0aCBzdGFydCkgdG8gc3Vic2VxdWVudCBzZWdtZW50c1xuICAgICAgICBpZiAodXBkYXRlU3VicGF0aFN0YXJ0KSB0aGlzLnVwZGF0ZVN1YnBhdGhTdGFydFNlZ21lbnQodXBkYXRlU3VicGF0aFN0YXJ0KTtcblxuICAgICAgICByZXR1cm4gc2VnbWVudDtcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBzZWdtZW50IGF0IGBpbmRleGAuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBpbmRpY2VzLCBmcm9tIGAtMWAgdG8gYC1zZWdtZW50cy5sZW5ndGhgLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBwYXRoIGhhcyBubyBzZWdtZW50cy5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgIHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHRocm93IG5ldyBFcnJvcignUGF0aCBoYXMgbm8gc2VnbWVudHMuJyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBudW1TZWdtZW50cyArIGluZGV4OyAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXMgdG8gcG9zaXRpdmVcbiAgICAgICAgaWYgKGluZGV4ID49IG51bVNlZ21lbnRzIHx8IGluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UuJyk7XG5cbiAgICAgICAgdmFyIHJlbW92ZWRTZWdtZW50ID0gc2VnbWVudHMuc3BsaWNlKGluZGV4LCAxKVswXTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2VnbWVudCA9IHJlbW92ZWRTZWdtZW50LnByZXZpb3VzU2VnbWVudDtcbiAgICAgICAgdmFyIG5leHRTZWdtZW50ID0gcmVtb3ZlZFNlZ21lbnQubmV4dFNlZ21lbnQ7XG5cbiAgICAgICAgLy8gbGluayB0aGUgcHJldmlvdXMgYW5kIG5leHQgc2VnbWVudHMgdG9nZXRoZXIgKGlmIHByZXNlbnQpXG4gICAgICAgIGlmIChwcmV2aW91c1NlZ21lbnQpIHByZXZpb3VzU2VnbWVudC5uZXh0U2VnbWVudCA9IG5leHRTZWdtZW50OyAvLyBtYXkgYmUgbnVsbFxuICAgICAgICBpZiAobmV4dFNlZ21lbnQpIG5leHRTZWdtZW50LnByZXZpb3VzU2VnbWVudCA9IHByZXZpb3VzU2VnbWVudDsgLy8gbWF5IGJlIG51bGxcblxuICAgICAgICAvLyBpZiByZW1vdmVkIHNlZ21lbnQgdXNlZCB0byBzdGFydCBhIHN1YnBhdGgsIHVwZGF0ZSBhbGwgc3Vic2VxdWVudCBzZWdtZW50cyB1bnRpbCBhbm90aGVyIHN1YnBhdGggc3RhcnQgc2VnbWVudCBpcyByZWFjaGVkXG4gICAgICAgIGlmIChyZW1vdmVkU2VnbWVudC5pc1N1YnBhdGhTdGFydCAmJiBuZXh0U2VnbWVudCkgdGhpcy51cGRhdGVTdWJwYXRoU3RhcnRTZWdtZW50KG5leHRTZWdtZW50KTtcbiAgICB9LFxuXG4gICAgLy8gUmVwbGFjZSB0aGUgc2VnbWVudCBhdCBgaW5kZXhgIHdpdGggYGFyZ2AuXG4gICAgLy8gQWNjZXB0cyBuZWdhdGl2ZSBpbmRpY2VzLCBmcm9tIGAtMWAgdG8gYC1zZWdtZW50cy5sZW5ndGhgLlxuICAgIC8vIEFjY2VwdHMgb25lIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMgYXMgYXJndW1lbnQuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHBhdGggaGFzIG5vIHNlZ21lbnRzLlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFyZ3VtZW50IGlzIG5vdCBhIHNlZ21lbnQgb3IgYW4gYXJyYXkgb2Ygc2VnbWVudHMuXG4gICAgcmVwbGFjZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4LCBhcmcpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1TZWdtZW50cyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGhhcyBubyBzZWdtZW50cy4nKTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSBpbmRleCA9IG51bVNlZ21lbnRzICsgaW5kZXg7IC8vIGNvbnZlcnQgbmVnYXRpdmUgaW5kaWNlcyB0byBwb3NpdGl2ZVxuICAgICAgICBpZiAoaW5kZXggPj0gbnVtU2VnbWVudHMgfHwgaW5kZXggPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZS4nKTtcblxuICAgICAgICB2YXIgY3VycmVudFNlZ21lbnQ7XG5cbiAgICAgICAgdmFyIHJlcGxhY2VkU2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgdmFyIHByZXZpb3VzU2VnbWVudCA9IHJlcGxhY2VkU2VnbWVudC5wcmV2aW91c1NlZ21lbnQ7XG4gICAgICAgIHZhciBuZXh0U2VnbWVudCA9IHJlcGxhY2VkU2VnbWVudC5uZXh0U2VnbWVudDtcblxuICAgICAgICB2YXIgdXBkYXRlU3VicGF0aFN0YXJ0ID0gcmVwbGFjZWRTZWdtZW50LmlzU3VicGF0aFN0YXJ0OyAvLyBib29sZWFuOiBpcyBhbiB1cGRhdGUgb2Ygc3VicGF0aCBzdGFydHMgbmVjZXNzYXJ5P1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoIWFyZyB8fCAhYXJnLmlzU2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdTZWdtZW50IHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBjdXJyZW50U2VnbWVudCA9IHRoaXMucHJlcGFyZVNlZ21lbnQoYXJnLCBwcmV2aW91c1NlZ21lbnQsIG5leHRTZWdtZW50KTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZShpbmRleCwgMSwgY3VycmVudFNlZ21lbnQpOyAvLyBkaXJlY3RseSByZXBsYWNlXG5cbiAgICAgICAgICAgIGlmICh1cGRhdGVTdWJwYXRoU3RhcnQgJiYgY3VycmVudFNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHVwZGF0ZVN1YnBhdGhTdGFydCA9IGZhbHNlOyAvLyBhbHJlYWR5IHVwZGF0ZWQgYnkgYHByZXBhcmVTZWdtZW50YFxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmbGF0dGVuIG9uZSBsZXZlbCBkZWVwXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhaW4gYXJiaXRyYXJ5IFBhdGguY3JlYXRlU2VnbWVudCByZXN1bHRzXG4gICAgICAgICAgICBhcmcgPSBhcmcucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYy5jb25jYXQodmFsKTtcbiAgICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICAgICAgaWYgKCFhcmdbMF0uaXNTZWdtZW50KSB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzIHJlcXVpcmVkLicpO1xuXG4gICAgICAgICAgICBzZWdtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICB2YXIgbiA9IGFyZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBcmcgPSBhcmdbaV07XG4gICAgICAgICAgICAgICAgY3VycmVudFNlZ21lbnQgPSB0aGlzLnByZXBhcmVTZWdtZW50KGN1cnJlbnRBcmcsIHByZXZpb3VzU2VnbWVudCwgbmV4dFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnNwbGljZSgoaW5kZXggKyBpKSwgMCwgY3VycmVudFNlZ21lbnQpOyAvLyBpbmNyZW1lbnRpbmcgaW5kZXggdG8gaW5zZXJ0IHN1YnNlcXVlbnQgc2VnbWVudHMgYWZ0ZXIgaW5zZXJ0ZWQgc2VnbWVudHNcbiAgICAgICAgICAgICAgICBwcmV2aW91c1NlZ21lbnQgPSBjdXJyZW50U2VnbWVudDtcblxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdWJwYXRoU3RhcnQgJiYgY3VycmVudFNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHVwZGF0ZVN1YnBhdGhTdGFydCA9IGZhbHNlOyAvLyBhbHJlYWR5IHVwZGF0ZWQgYnkgYHByZXBhcmVTZWdtZW50YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcmVwbGFjZWQgc2VnbWVudCB1c2VkIHRvIHN0YXJ0IGEgc3VicGF0aCBhbmQgbm8gbmV3IHN1YnBhdGggc3RhcnQgd2FzIGFkZGVkLCB1cGRhdGUgYWxsIHN1YnNlcXVlbnQgc2VnbWVudHMgdW50aWwgYW5vdGhlciBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgaXMgcmVhY2hlZFxuICAgICAgICBpZiAodXBkYXRlU3VicGF0aFN0YXJ0ICYmIG5leHRTZWdtZW50KSB0aGlzLnVwZGF0ZVN1YnBhdGhTdGFydFNlZ21lbnQobmV4dFNlZ21lbnQpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc2VnbWVudC5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIHNlZ21lbnQuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlZ21lbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4QXQocmF0aW8sIG9wdCk7XG4gICAgICAgIGlmICghaW5kZXgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlZ21lbnQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGxlbmd0aC5cbiAgICBzZWdtZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXhBdExlbmd0aChsZW5ndGgsIG9wdCk7XG4gICAgICAgIGlmICghaW5kZXgpIHJldHVybiBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlZ21lbnQoaW5kZXgpO1xuICAgIH0sXG5cbiAgICBzZWdtZW50SW5kZXhBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VnbWVudEluZGV4QXRMZW5ndGgobGVuZ3RoLCBsb2NhbE9wdCk7XG4gICAgfSxcblxuICAgIC8vIEFjY2VwdHMgbmVnYXRpdmUgbGVuZ3RoLlxuICAgIHNlZ21lbnRJbmRleEF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgsIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICAvLyBub3QgdXNpbmcgbG9jYWxPcHRcblxuICAgICAgICB2YXIgbGFzdFZpc2libGVTZWdtZW50SW5kZXggPSBudWxsO1xuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChudW1TZWdtZW50cyAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIHN1YmRpdmlzaW9ucyA9IHNlZ21lbnRTdWJkaXZpc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGQgPSBzZWdtZW50Lmxlbmd0aCh7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzdWJkaXZpc2lvbnM6IHN1YmRpdmlzaW9ucyB9KTtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAobCArIGQpKSByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICAgICAgbGFzdFZpc2libGVTZWdtZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVuZ3RoIHJlcXVlc3RlZCBpcyBoaWdoZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBwYXRoLCByZXR1cm4gbGFzdCB2aXNpYmxlIHNlZ21lbnQgaW5kZXhcbiAgICAgICAgLy8gaWYgbm8gdmlzaWJsZSBzZWdtZW50LCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbGFzdFZpc2libGVTZWdtZW50SW5kZXg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWNvbnN0cnVjdCB0aGUgcGF0aC5cbiAgICAvLyBBZGRpdGlvbmFsIGVycm9yIGNoZWNraW5nIGNvbXBhcmVkIHRvIHRvU3RyaW5nIChtdXN0IHN0YXJ0IHdpdGggTSBzZWdtZW50KS5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRoIHNlZ21lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGFuZ2VudCBsaW5lIGF0IHJlcXVlc3RlZCBgcmF0aW9gIGJldHdlZW4gMCBhbmQgMSwgd2l0aCBwcmVjaXNpb24gYmV0dGVyIHRoYW4gcmVxdWVzdGVkIGBvcHQucHJlY2lzaW9uYDsgb3B0aW9uYWxseSB1c2luZyBgb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnNgIHByb3ZpZGVkLlxuICAgIHRhbmdlbnRBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICBpZiAocmF0aW8gPCAwKSByYXRpbyA9IDA7XG4gICAgICAgIGlmIChyYXRpbyA+IDEpIHJhdGlvID0gMTtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSAob3B0LnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuUFJFQ0lTSU9OIDogb3B0LnByZWNpc2lvbjtcbiAgICAgICAgdmFyIHNlZ21lbnRTdWJkaXZpc2lvbnMgPSAob3B0LnNlZ21lbnRTdWJkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCkgPyB0aGlzLmdldFNlZ21lbnRTdWJkaXZpc2lvbnMoeyBwcmVjaXNpb246IHByZWNpc2lvbiB9KSA6IG9wdC5zZWdtZW50U3ViZGl2aXNpb25zO1xuICAgICAgICB2YXIgbG9jYWxPcHQgPSB7IHByZWNpc2lvbjogcHJlY2lzaW9uLCBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH07XG5cbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSB0aGlzLmxlbmd0aChsb2NhbE9wdCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoTGVuZ3RoICogcmF0aW87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0TGVuZ3RoKGxlbmd0aCwgbG9jYWxPcHQpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRhbmdlbnQgbGluZSBhdCByZXF1ZXN0ZWQgYGxlbmd0aGAsIHdpdGggcHJlY2lzaW9uIGJldHRlciB0aGFuIHJlcXVlc3RlZCBgb3B0LnByZWNpc2lvbmA7IG9wdGlvbmFsbHkgdXNpbmcgYG9wdC5zZWdtZW50U3ViZGl2aXNpb25zYCBwcm92aWRlZC5cbiAgICAvLyBBY2NlcHRzIG5lZ2F0aXZlIGxlbmd0aC5cbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCwgb3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIHZhciBmcm9tU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0ID0gZmFsc2U7IC8vIG5lZ2F0aXZlIGxlbmd0aHMgbWVhbiBzdGFydCBjYWxjdWxhdGlvbiBmcm9tIGVuZCBwb2ludFxuICAgICAgICAgICAgbGVuZ3RoID0gLWxlbmd0aDsgLy8gYWJzb2x1dGUgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG4gICAgICAgIC8vIG5vdCB1c2luZyBsb2NhbE9wdFxuXG4gICAgICAgIHZhciBsYXN0VmFsaWRTZWdtZW50OyAvLyB2aXNpYmxlIEFORCBkaWZmZXJlbnRpYWJsZSAod2l0aCBhIHRhbmdlbnQpXG4gICAgICAgIHZhciBsID0gMDsgLy8gbGVuZ3RoIHNvIGZhclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChmcm9tU3RhcnQgPyBpIDogKG51bVNlZ21lbnRzIC0gMSAtIGkpKTtcblxuICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgICAgICAgICB2YXIgc3ViZGl2aXNpb25zID0gc2VnbWVudFN1YmRpdmlzaW9uc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZCA9IHNlZ21lbnQubGVuZ3RoKHsgcHJlY2lzaW9uOiBwcmVjaXNpb24sIHN1YmRpdmlzaW9uczogc3ViZGl2aXNpb25zIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc0RpZmZlcmVudGlhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZ21lbnQudGFuZ2VudEF0TGVuZ3RoKCgoZnJvbVN0YXJ0ID8gMSA6IC0xKSAqIChsZW5ndGggLSBsKSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZGl2aXNpb25zOiBzdWJkaXZpc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGFzdFZhbGlkU2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGwgKz0gZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlbmd0aCByZXF1ZXN0ZWQgaXMgaGlnaGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgcGF0aCwgcmV0dXJuIHRhbmdlbnQgb2YgZW5kcG9pbnQgb2YgbGFzdCB2YWxpZCBzZWdtZW50XG4gICAgICAgIGlmIChsYXN0VmFsaWRTZWdtZW50KSB7XG4gICAgICAgICAgICB2YXIgdCA9IChmcm9tU3RhcnQgPyAxIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZhbGlkU2VnbWVudC50YW5nZW50QXRUKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gdmFsaWQgc2VnbWVudCwgcmV0dXJuIG51bGxcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8vIFByaXZhdGUgZnVuY3Rpb24uXG4gICAgdGFuZ2VudEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIHZhciBudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVNlZ21lbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgc2VnbWVudHMgaXMgYW4gZW1wdHkgYXJyYXlcblxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdC5zZWdtZW50SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSByZXR1cm4gc2VnbWVudHNbMF0udGFuZ2VudEF0VCgwKTtcbiAgICAgICAgaWYgKHNlZ21lbnRJbmRleCA+PSBudW1TZWdtZW50cykgcmV0dXJuIHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0udGFuZ2VudEF0VCgxKTtcblxuICAgICAgICB2YXIgdFZhbHVlID0gdC52YWx1ZTtcbiAgICAgICAgaWYgKHRWYWx1ZSA8IDApIHRWYWx1ZSA9IDA7XG4gICAgICAgIGVsc2UgaWYgKHRWYWx1ZSA+IDEpIHRWYWx1ZSA9IDE7XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRJbmRleF0udGFuZ2VudEF0VCh0VmFsdWUpO1xuICAgIH0sXG5cbiAgICB0b1BvaW50czogZnVuY3Rpb24ob3B0KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBzZWdtZW50cyBpcyBhbiBlbXB0eSBhcnJheVxuXG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHByZWNpc2lvbiA9IChvcHQucHJlY2lzaW9uID09PSB1bmRlZmluZWQpID8gdGhpcy5QUkVDSVNJT04gOiBvcHQucHJlY2lzaW9uO1xuICAgICAgICB2YXIgc2VnbWVudFN1YmRpdmlzaW9ucyA9IChvcHQuc2VnbWVudFN1YmRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkKSA/IHRoaXMuZ2V0U2VnbWVudFN1YmRpdmlzaW9ucyh7IHByZWNpc2lvbjogcHJlY2lzaW9uIH0pIDogb3B0LnNlZ21lbnRTdWJkaXZpc2lvbnM7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgcGFydGlhbFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNlZ21lbnRTdWJkaXZpc2lvbnMgPSBzZWdtZW50U3ViZGl2aXNpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VnbWVudFN1YmRpdmlzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJkaXZpc2lvblBvaW50cyA9IGN1cnJlbnRTZWdtZW50U3ViZGl2aXNpb25zLm1hcChmdW5jdGlvbihjdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnZlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocGFydGlhbFBvaW50cywgc3ViZGl2aXNpb25Qb2ludHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxQb2ludHMucHVzaChzZWdtZW50LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRpYWxQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxQb2ludHMucHVzaChzZWdtZW50c1tpIC0gMV0uZW5kKTtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwYXJ0aWFsUG9pbnRzKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsUG9pbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0aWFsUG9pbnRzLnB1c2godGhpcy5lbmQpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocGFydGlhbFBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9LFxuXG4gICAgdG9Qb2x5bGluZXM6IGZ1bmN0aW9uKG9wdCkge1xuXG4gICAgICAgIHZhciBwb2x5bGluZXMgPSBbXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMudG9Qb2ludHMob3B0KTtcbiAgICAgICAgaWYgKCFwb2ludHMpIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHBvbHlsaW5lcy5wdXNoKG5ldyBQb2x5bGluZShwb2ludHNbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2x5bGluZXM7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICB2YXIgbnVtU2VnbWVudHMgPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHBhdGhEYXRhID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgcGF0aERhdGEgKz0gc2VnbWVudC5zZXJpYWxpemUoKSArICcgJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoRGF0YS50cmltKCk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgc2VnbWVudC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBIZWxwZXIgbWV0aG9kIGZvciB1cGRhdGluZyBzdWJwYXRoIHN0YXJ0IG9mIHNlZ21lbnRzLCBzdGFydGluZyB3aXRoIHRoZSBvbmUgcHJvdmlkZWQuXG4gICAgdXBkYXRlU3VicGF0aFN0YXJ0U2VnbWVudDogZnVuY3Rpb24oc2VnbWVudCkge1xuXG4gICAgICAgIHZhciBwcmV2aW91c1NlZ21lbnQgPSBzZWdtZW50LnByZXZpb3VzU2VnbWVudDsgLy8gbWF5IGJlIG51bGxcbiAgICAgICAgd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuaXNTdWJwYXRoU3RhcnQpIHtcblxuICAgICAgICAgICAgLy8gYXNzaWduIHByZXZpb3VzIHNlZ21lbnQncyBzdWJwYXRoIHN0YXJ0IHNlZ21lbnQgdG8gdGhpcyBzZWdtZW50XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTZWdtZW50KSBzZWdtZW50LnN1YnBhdGhTdGFydFNlZ21lbnQgPSBwcmV2aW91c1NlZ21lbnQuc3VicGF0aFN0YXJ0U2VnbWVudDsgLy8gbWF5IGJlIG51bGxcbiAgICAgICAgICAgIGVsc2Ugc2VnbWVudC5zdWJwYXRoU3RhcnRTZWdtZW50ID0gbnVsbDsgLy8gaWYgc2VnbWVudCBoYWQgbm8gcHJldmlvdXMgc2VnbWVudCwgYXNzaWduIG51bGwgLSBjcmVhdGVzIGFuIGludmFsaWQgcGF0aCFcblxuICAgICAgICAgICAgcHJldmlvdXNTZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50Lm5leHRTZWdtZW50OyAvLyBtb3ZlIG9uIHRvIHRoZSBzZWdtZW50IGFmdGVyIGV0Yy5cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJZiB0aGUgcGF0aCBpcyBub3QgdmFsaWQsIGluc2VydCBNIDAgMCBhdCB0aGUgYmVnaW5uaW5nLlxuICAgIC8vIFBhdGggd2l0aCBubyBzZWdtZW50cyBpcyBjb25zaWRlcmVkIHZhbGlkLCBzbyBub3RoaW5nIGlzIGluc2VydGVkLlxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB0aGlzLmluc2VydFNlZ21lbnQoMCwgUGF0aC5jcmVhdGVTZWdtZW50KCdNJywgMCwgMCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0aC5wcm90b3R5cGUsICdzdGFydCcsIHtcbiAgICAvLyBHZXR0ZXIgZm9yIHRoZSBmaXJzdCB2aXNpYmxlIGVuZHBvaW50IG9mIHRoZSBwYXRoLlxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaXNWaXNpYmxlKSByZXR1cm4gc2VnbWVudC5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIGxhc3Qgc2VnbWVudCBlbmQgcG9pbnRcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0uZW5kO1xuICAgIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGF0aC5wcm90b3R5cGUsICdlbmQnLCB7XG4gICAgLy8gR2V0dGVyIGZvciB0aGUgbGFzdCB2aXNpYmxlIGVuZHBvaW50IG9mIHRoZSBwYXRoLlxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICAgICAgdmFyIG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtU2VnbWVudHMgPT09IDApIHJldHVybiBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBudW1TZWdtZW50cyAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5pc1Zpc2libGUpIHJldHVybiBzZWdtZW50LmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIHZpc2libGUgc2VnbWVudCwgcmV0dXJuIGxhc3Qgc2VnbWVudCBlbmQgcG9pbnRcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0uZW5kO1xuICAgIH1cbn0pO1xuXG5cbi8vIExvY2FsIGhlbHBlciBmdW5jdGlvbi5cbi8vIFVzZSBhbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gY2FsbCBhIGNvbnN0cnVjdG9yIChmdW5jdGlvbiBjYWxsZWQgd2l0aCBgbmV3YCkuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg4NDMxODEvMjI2MzU5NVxuLy8gSXQgaXMgbm90IG5lY2Vzc2FyeSB0byB1c2UgdGhpcyBmdW5jdGlvbiBpZiB0aGUgYXJndW1lbnRzIGNhbiBiZSBwYXNzZWQgc2VwYXJhdGVseSAoaS5lLiBpZiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBpcyBsaW1pdGVkKS5cbi8vIC0gSWYgdGhhdCBpcyB0aGUgY2FzZSwgdXNlIGBuZXcgY29uc3RydWN0b3IoYXJnMSwgYXJnMilgLCBmb3IgZXhhbXBsZS5cbi8vIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gdXNlIHRoaXMgZnVuY3Rpb24gaWYgdGhlIGZ1bmN0aW9uIHRoYXQgbmVlZHMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGlzIG5vdCBzdXBwb3NlZCB0byBiZSB1c2VkIGFzIGEgY29uc3RydWN0b3IuXG4vLyAtIElmIHRoYXQgaXMgdGhlIGNhc2UsIHVzZSBgZi5hcHBseSh0aGlzQXJnLCBbYXJnMSwgYXJnMi4uLl0pYCwgZm9yIGV4YW1wbGUuXG5mdW5jdGlvbiBhcHBseVRvTmV3KGNvbnN0cnVjdG9yLCBhcmdzQXJyYXkpIHtcbiAgICAvLyBUaGUgYG5ld2Aga2V5d29yZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBsaW1pdGVkIG51bWJlciBvZiBhcmd1bWVudHMuXG4gICAgLy8gLSBXZSBjYW4gZmFrZSB0aGF0IHdpdGggLmJpbmQoKS5cbiAgICAvLyAtIEl0IGNhbGxzIGEgZnVuY3Rpb24gKGBjb25zdHJ1Y3RvcmAsIGhlcmUpIHdpdGggdGhlIGFyZ3VtZW50cyB0aGF0IHdlcmUgcHJvdmlkZWQgdG8gaXQgLSBlZmZlY3RpdmVseSB0cmFuc2Zvcm1pbmcgYW4gdW5saW1pdGVkIG51bWJlciBvZiBhcmd1bWVudHMgaW50byBsaW1pdGVkLlxuICAgIC8vIC0gU28gYG5ldyAoY29uc3RydWN0b3IuYmluZCh0aGlzQXJnLCBhcmcxLCBhcmcyLi4uKSlgXG4gICAgLy8gLSBgdGhpc0FyZ2AgY2FuIGJlIGFueXRoaW5nIChlLmcuIG51bGwpIGJlY2F1c2UgYG5ld2Aga2V5d29yZCByZXNldHMgY29udGV4dCB0byB0aGUgY29uc3RydWN0b3Igb2JqZWN0LlxuICAgIC8vIFdlIG5lZWQgdG8gcGFzcyBpbiBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gdGhlIGJpbmQoKSBjYWxsLlxuICAgIC8vIC0gV2UgY2FuIHVzZSAuYXBwbHkoKS5cbiAgICAvLyAtIFNvIGBuZXcgKGNvbnN0cnVjdG9yLmJpbmQuYXBwbHkoY29uc3RydWN0b3IsIFt0aGlzQXJnLCBhcmcxLCBhcmcyLi4uXSkpYFxuICAgIC8vIC0gYHRoaXNBcmdgIGNhbiBzdGlsbCBiZSBhbnl0aGluZyBiZWNhdXNlIGBuZXdgIG92ZXJ3cml0ZXMgaXQuXG4gICAgLy8gRmluYWxseSwgdG8gbWFrZSBzdXJlIHRoYXQgY29uc3RydWN0b3IuYmluZCBvdmVyd3JpdGluZyBpcyBub3QgYSBwcm9ibGVtLCB3ZSBzd2l0Y2ggdG8gYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYC5cbiAgICAvLyAtIFNvLCB0aGUgZmluYWwgdmVyc2lvbiBpcyBgbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShjb25zdHJ1Y3RvciwgW3RoaXNBcmcsIGFyZzEsIGFyZzIuLi5dKSlgXG5cbiAgICAvLyBUaGUgZnVuY3Rpb24gZXhwZWN0cyBgYXJnc0FycmF5WzBdYCB0byBiZSBgdGhpc0FyZ2AuXG4gICAgLy8gLSBUaGlzIG1lYW5zIHRoYXQgd2hhdGV2ZXIgaXMgc2VudCBhcyB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXG4gICAgLy8gLSBUaGUgY29uc3RydWN0b3Igd2lsbCBvbmx5IHNlZSBhcmd1bWVudHMgc3RhcnRpbmcgZnJvbSBhcmdzQXJyYXlbMV0uXG4gICAgLy8gLSBTbywgYSBuZXcgZHVtbXkgZWxlbWVudCBpcyBpbnNlcnRlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIGFycmF5LlxuICAgIGFyZ3NBcnJheS51bnNoaWZ0KG51bGwpO1xuXG4gICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoY29uc3RydWN0b3IsIGFyZ3NBcnJheSkpO1xufVxuXG4vLyBQYXRoIHNlZ21lbnQgaW50ZXJmYWNlOlxudmFyIHNlZ21lbnRQcm90b3R5cGUgPSB7XG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGNsb3Nlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvc2VzdFBvaW50TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIFJlZGlyZWN0IGNhbGxzIHRvIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgoKSBmdW5jdGlvbiBpZiBjbG9zZXN0UG9pbnRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgY2xvc2VzdFBvaW50VDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIGlmICh0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgpIHJldHVybiB0aGlzLmNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGgocCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIGNsb3Nlc3RQb2ludFQoKSBub3IgY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aCgpIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIFJlZGlyZWN0IGNhbGxzIHRvIGRpdmlkZUF0KCkgZnVuY3Rpb24gaWYgZGl2aWRlQXRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgZGl2aWRlQXRUOiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGl2aWRlQXQpIHJldHVybiB0aGlzLmRpdmlkZUF0KHQpO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBkaXZpZGVBdFQoKSBub3IgZGl2aWRlQXQoKSBmdW5jdGlvbiBpcyBpbXBsZW1lbnRlZC4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIGVxdWFsczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgZ2V0U3ViZGl2aXNpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICBpc0RpZmZlcmVudGlhYmxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIGlzU2VnbWVudDogdHJ1ZSxcblxuICAgIGlzU3VicGF0aFN0YXJ0OiBmYWxzZSwgLy8gdHJ1ZSBmb3IgTW92ZXRvIHNlZ21lbnRzXG5cbiAgICBpc1Zpc2libGU6IHRydWUsIC8vIGZhbHNlIGZvciBNb3ZldG8gc2VnbWVudHNcblxuICAgIC8vIHZpcnR1YWxcbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIGEgZnJhY3Rpb24gb2YgcmVzdWx0IG9mIGxlbmd0aCgpIGZ1bmN0aW9uIGlmIGxlbmd0aEF0VCgpIGlzIG5vdCBkZWZpbmVkIGZvciBzZWdtZW50LlxuICAgIGxlbmd0aEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgICAgIGlmICh0ID49IDEpIHJldHVybiBsZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aCAqIHQ7XG4gICAgfSxcblxuICAgIG5leHRTZWdtZW50OiBudWxsLCAvLyBuZWVkZWQgZm9yIHN1YnBhdGggc3RhcnQgc2VnbWVudCB1cGRhdGluZ1xuXG4gICAgLy8gdmlydHVhbFxuICAgIHBvaW50QXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gUmVkaXJlY3QgY2FsbHMgdG8gcG9pbnRBdCgpIGZ1bmN0aW9uIGlmIHBvaW50QXRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgcG9pbnRBdFQ6IGZ1bmN0aW9uKHQpIHtcblxuICAgICAgICBpZiAodGhpcy5wb2ludEF0KSByZXR1cm4gdGhpcy5wb2ludEF0KHQpO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBwb2ludEF0VCgpIG5vciBwb2ludEF0KCkgZnVuY3Rpb24gaXMgaW1wbGVtZW50ZWQuJyk7XG4gICAgfSxcblxuICAgIHByZXZpb3VzU2VnbWVudDogbnVsbCwgLy8gbmVlZGVkIHRvIGdldCBzZWdtZW50IHN0YXJ0IHByb3BlcnR5XG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgc3VicGF0aFN0YXJ0U2VnbWVudDogbnVsbCwgLy8gbmVlZGVkIHRvIGdldCBDbG9zZXBhdGggc2VnbWVudCBlbmQgcHJvcGVydHlcblxuICAgIC8vIHZpcnR1YWxcbiAgICBzY2FsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY2xhcmF0aW9uIG1pc3NpbmcgZm9yIHZpcnR1YWwgZnVuY3Rpb24uJyk7XG4gICAgfSxcblxuICAgIC8vIHZpcnR1YWxcbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH0sXG5cbiAgICAvLyBSZWRpcmVjdCBjYWxscyB0byB0YW5nZW50QXQoKSBmdW5jdGlvbiBpZiB0YW5nZW50QXRUKCkgaXMgbm90IGRlZmluZWQgZm9yIHNlZ21lbnQuXG4gICAgdGFuZ2VudEF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIGlmICh0aGlzLnRhbmdlbnRBdCkgcmV0dXJuIHRoaXMudGFuZ2VudEF0KHQpO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciB0YW5nZW50QXRUKCkgbm9yIHRhbmdlbnRBdCgpIGZ1bmN0aW9uIGlzIGltcGxlbWVudGVkLicpO1xuICAgIH0sXG5cbiAgICAvLyB2aXJ0dWFsXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjbGFyYXRpb24gbWlzc2luZyBmb3IgdmlydHVhbCBmdW5jdGlvbi4nKTtcbiAgICB9LFxuXG4gICAgLy8gdmlydHVhbFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNsYXJhdGlvbiBtaXNzaW5nIGZvciB2aXJ0dWFsIGZ1bmN0aW9uLicpO1xuICAgIH1cbn07XG5cbi8vIHVzdWFsbHkgZGlyZWN0bHkgYXNzaWduZWRcbi8vIGdldHRlciBmb3IgQ2xvc2VwYXRoXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2VnbWVudFByb3RvdHlwZSwgJ2VuZCcsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8vIGFsd2F5cyBhIGdldHRlclxuLy8gYWx3YXlzIHRocm93cyBlcnJvciBmb3IgTW92ZXRvXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2VnbWVudFByb3RvdHlwZSwgJ3N0YXJ0Jywge1xuICAgIC8vIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgZW5kIHBvaW50IG9mIHByZXZpb3VzIHNlZ21lbnRcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c1NlZ21lbnQpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcmV2aW91cyBzZWdtZW50LiAoVGhpcyBzZWdtZW50IGNhbm5vdCBiZSB0aGUgZmlyc3Qgc2VnbWVudCBvZiBhIHBhdGg7IE9SIHNlZ21lbnQgaGFzIG5vdCB5ZXQgYmVlbiBhZGRlZCB0byBhIHBhdGguKScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzU2VnbWVudC5lbmQ7XG4gICAgfVxufSk7XG5cbi8vIHZpcnR1YWxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWdtZW50UHJvdG90eXBlLCAndHlwZScsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQmFkIHNlZ21lbnQgZGVjbGFyYXRpb24uIE5vIHR5cGUgc3BlY2lmaWVkLicpO1xuICAgIH1cbn0pO1xuXG4vLyBQYXRoIHNlZ21lbnQgaW1wbGVtZW50YXRpb25zOlxudmFyIExpbmV0byA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmV0bykpIHsgLy8gc3dpdGNoaW5nIGNvbnRleHQgb2YgYHRoaXNgIHRvIExpbmV0byB3aGVuIGNhbGxlZCB3aXRob3V0IGBuZXdgXG4gICAgICAgIHJldHVybiBhcHBseVRvTmV3KExpbmV0bywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5ldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGxpbmUsIDEgcG9pbnQsIG9yIDIgY29vcmRpbmF0ZXMgKG5vbmUgcHJvdmlkZWQpLicpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRBcnJheTtcblxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgTGluZSkgeyAvLyBsaW5lcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBhcmdzWzBdLmVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGluZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzICgnICsgbiArICcgbGluZXMgcHJvdmlkZWQpLicpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicpIHsgLy8gY29vcmRpbmF0ZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KCthcmdzWzBdLCArYXJnc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICB9IGVsc2UgaWYgKG4gPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGNvb3JkaW5hdGVzIHByb3ZpZGVkKS4nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGlzIGlzIGEgcG9seS1saW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBzZWdtZW50Q29vcmRzO1xuICAgICAgICAgICAgb3V0cHV0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpICs9IDIpIHsgLy8gY29vcmRzIGNvbWUgaW4gZ3JvdXBzIG9mIHR3b1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudENvb3JkcyA9IGFyZ3Muc2xpY2UoaSwgaSArIDIpOyAvLyB3aWxsIHNlbmQgb25lIGNvb3JkIGlmIGFyZ3MubGVuZ3RoIG5vdCBkaXZpc2libGUgYnkgMlxuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goYXBwbHlUb05ldyhMaW5ldG8sIHNlZ21lbnRDb29yZHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHsgLy8gcG9pbnRzIHByb3ZpZGVkIChuZWVkcyB0byBiZSBsYXN0IHRvIGFsc28gY292ZXIgcGxhaW4gb2JqZWN0cyB3aXRoIHggYW5kIHkpXG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBQb2ludChhcmdzWzBdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBwb2x5LWxpbmUgc2VnbWVudFxuICAgICAgICAgICAgdmFyIHNlZ21lbnRQb2ludDtcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAxKSB7XG5cbiAgICAgICAgICAgICAgICBzZWdtZW50UG9pbnQgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gobmV3IExpbmV0byhzZWdtZW50UG9pbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBsaW5ldG9Qcm90b3R5cGUgPSB7XG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5ldG8odGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24ocmF0aW8pIHtcblxuICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBsaW5lLmRpdmlkZUF0KHJhdGlvKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBMaW5ldG8oZGl2aWRlZFswXSksXG4gICAgICAgICAgICBuZXcgTGluZXRvKGRpdmlkZWRbMV0pXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblxuICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBsaW5lLmRpdmlkZUF0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgTGluZXRvKGRpdmlkZWRbMF0pLFxuICAgICAgICAgICAgbmV3IExpbmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzU2VnbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5zdGFydC5lcXVhbHModGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICByb3VuZDogZnVuY3Rpb24ocHJlY2lzaW9uKSB7XG5cbiAgICAgICAgdGhpcy5lbmQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHRoaXMuZW5kLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZW5kO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyAnICsgZW5kLnggKyAnICcgKyBlbmQueTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnICcgKyB0aGlzLnN0YXJ0ICsgJyAnICsgdGhpcy5lbmQ7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24odHgsIHR5KSB7XG5cbiAgICAgICAgdGhpcy5lbmQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaW5ldG9Qcm90b3R5cGUsICd0eXBlJywge1xuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIHZhbHVlOiAnTCdcbn0pO1xuXG5MaW5ldG8ucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIExpbmUucHJvdG90eXBlLCBsaW5ldG9Qcm90b3R5cGUpO1xuXG52YXIgQ3VydmV0byA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1cnZldG8pKSB7IC8vIHN3aXRjaGluZyBjb250ZXh0IG9mIGB0aGlzYCB0byBDdXJ2ZXRvIHdoZW4gY2FsbGVkIHdpdGhvdXQgYG5ld2BcbiAgICAgICAgcmV0dXJuIGFwcGx5VG9OZXcoQ3VydmV0bywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJ2ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBjdXJ2ZSwgMyBwb2ludHMsIG9yIDYgY29vcmRpbmF0ZXMgKG5vbmUgcHJvdmlkZWQpLicpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRBcnJheTtcblxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgQ3VydmUpIHsgLy8gY3VydmVzIHByb3ZpZGVkXG4gICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEgPSBhcmdzWzBdLmNvbnRyb2xQb2ludDEuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MiA9IGFyZ3NbMF0uY29udHJvbFBvaW50Mi5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBhcmdzWzBdLmVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VydmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgY3VydmUsIDMgcG9pbnRzLCBvciA2IGNvb3JkaW5hdGVzICgnICsgbiArICcgY3VydmVzIHByb3ZpZGVkKS4nKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInKSB7IC8vIGNvb3JkaW5hdGVzIHByb3ZpZGVkXG4gICAgICAgIGlmIChuID09PSA2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEgPSBuZXcgUG9pbnQoK2FyZ3NbMF0sICthcmdzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MiA9IG5ldyBQb2ludCgrYXJnc1syXSwgK2FyZ3NbM10pO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQoK2FyZ3NbNF0sICthcmdzWzVdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VydmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgY3VydmUsIDMgcG9pbnRzLCBvciA2IGNvb3JkaW5hdGVzICgnICsgbiArICcgY29vcmRpbmF0ZXMgcHJvdmlkZWQpLicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBwb2x5LWJlemllciBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudENvb3JkcztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSA2KSB7IC8vIGNvb3JkcyBjb21lIGluIGdyb3VwcyBvZiBzaXhcblxuICAgICAgICAgICAgICAgIHNlZ21lbnRDb29yZHMgPSBhcmdzLnNsaWNlKGksIGkgKyA2KTsgLy8gd2lsbCBzZW5kIGZld2VyIHRoYW4gc2l4IGNvb3JkcyBpZiBhcmdzLmxlbmd0aCBub3QgZGl2aXNpYmxlIGJ5IDZcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKGFwcGx5VG9OZXcoQ3VydmV0bywgc2VnbWVudENvb3JkcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBwb2ludHMgcHJvdmlkZWQgKG5lZWRzIHRvIGJlIGxhc3QgdG8gYWxzbyBjb3ZlciBwbGFpbiBvYmplY3RzIHdpdGggeCBhbmQgeSlcbiAgICAgICAgaWYgKG4gPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MSA9IG5ldyBQb2ludChhcmdzWzBdKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFBvaW50MiA9IG5ldyBQb2ludChhcmdzWzFdKTtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuIDwgMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJ2ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBjdXJ2ZSwgMyBwb2ludHMsIG9yIDYgY29vcmRpbmF0ZXMgKCcgKyBuICsgJyBwb2ludHMgcHJvdmlkZWQpLicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBwb2x5LWJlemllciBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudFBvaW50cztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAzKSB7IC8vIHBvaW50cyBjb21lIGluIGdyb3VwcyBvZiB0aHJlZVxuXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvaW50cyA9IGFyZ3Muc2xpY2UoaSwgaSArIDMpOyAvLyB3aWxsIHNlbmQgZmV3ZXIgdGhhbiB0aHJlZSBwb2ludHMgaWYgYXJncy5sZW5ndGggaXMgbm90IGRpdmlzaWJsZSBieSAzXG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KEN1cnZldG8sIHNlZ21lbnRQb2ludHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBjdXJ2ZXRvUHJvdG90eXBlID0ge1xuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgQ3VydmV0byh0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdDogZnVuY3Rpb24ocmF0aW8sIG9wdCkge1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZSh0aGlzLnN0YXJ0LCB0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGN1cnZlLmRpdmlkZUF0KHJhdGlvLCBvcHQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IEN1cnZldG8oZGl2aWRlZFswXSksXG4gICAgICAgICAgICBuZXcgQ3VydmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBkaXZpZGVBdExlbmd0aDogZnVuY3Rpb24obGVuZ3RoLCBvcHQpIHtcblxuICAgICAgICB2YXIgY3VydmUgPSBuZXcgQ3VydmUodGhpcy5zdGFydCwgdGhpcy5jb250cm9sUG9pbnQxLCB0aGlzLmNvbnRyb2xQb2ludDIsIHRoaXMuZW5kKTtcbiAgICAgICAgdmFyIGRpdmlkZWQgPSBjdXJ2ZS5kaXZpZGVBdExlbmd0aChsZW5ndGgsIG9wdCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgQ3VydmV0byhkaXZpZGVkWzBdKSxcbiAgICAgICAgICAgIG5ldyBDdXJ2ZXRvKGRpdmlkZWRbMV0pXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0VDogZnVuY3Rpb24odCkge1xuXG4gICAgICAgIHZhciBjdXJ2ZSA9IG5ldyBDdXJ2ZSh0aGlzLnN0YXJ0LCB0aGlzLmNvbnRyb2xQb2ludDEsIHRoaXMuY29udHJvbFBvaW50MiwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGN1cnZlLmRpdmlkZUF0VCh0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBDdXJ2ZXRvKGRpdmlkZWRbMF0pLFxuICAgICAgICAgICAgbmV3IEN1cnZldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzU2VnbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIHZhciBjb250cm9sMSA9IHRoaXMuY29udHJvbFBvaW50MTtcbiAgICAgICAgdmFyIGNvbnRyb2wyID0gdGhpcy5jb250cm9sUG9pbnQyO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5lbmQ7XG5cbiAgICAgICAgcmV0dXJuICEoc3RhcnQuZXF1YWxzKGNvbnRyb2wxKSAmJiBjb250cm9sMS5lcXVhbHMoY29udHJvbDIpICYmIGNvbnRyb2wyLmVxdWFscyhlbmQpKTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS5yb3VuZChwcmVjaXNpb24pO1xuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDIucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5lbmQucm91bmQocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50MS5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHRoaXMuZW5kLnNjYWxlKHN4LCBzeSwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGMxID0gdGhpcy5jb250cm9sUG9pbnQxO1xuICAgICAgICB2YXIgYzIgPSB0aGlzLmNvbnRyb2xQb2ludDI7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIGMxLnggKyAnICcgKyBjMS55ICsgJyAnICsgYzIueCArICcgJyArIGMyLnkgKyAnICcgKyBlbmQueCArICcgJyArIGVuZC55O1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIHRoaXMuc3RhcnQgKyAnICcgKyB0aGlzLmNvbnRyb2xQb2ludDEgKyAnICcgKyB0aGlzLmNvbnRyb2xQb2ludDIgKyAnICcgKyB0aGlzLmVuZDtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICB0aGlzLmNvbnRyb2xQb2ludDEudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHRoaXMuY29udHJvbFBvaW50Mi50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgdGhpcy5lbmQudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXRvUHJvdG90eXBlLCAndHlwZScsIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICB2YWx1ZTogJ0MnXG59KTtcblxuQ3VydmV0by5wcm90b3R5cGUgPSBleHRlbmQoc2VnbWVudFByb3RvdHlwZSwgQ3VydmUucHJvdG90eXBlLCBjdXJ2ZXRvUHJvdG90eXBlKTtcblxudmFyIE1vdmV0byA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vdmV0bykpIHsgLy8gc3dpdGNoaW5nIGNvbnRleHQgb2YgYHRoaXNgIHRvIE1vdmV0byB3aGVuIGNhbGxlZCB3aXRob3V0IGBuZXdgXG4gICAgICAgIHJldHVybiBhcHBseVRvTmV3KE1vdmV0bywgYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb3ZldG8gY29uc3RydWN0b3IgZXhwZWN0cyBhIGxpbmUsIGEgY3VydmUsIDEgcG9pbnQsIG9yIDIgY29vcmRpbmF0ZXMgKG5vbmUgcHJvdmlkZWQpLicpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRBcnJheTtcblxuICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgTGluZSkgeyAvLyBsaW5lcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBhcmdzWzBdLmVuZC5jbG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW92ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCBhIGN1cnZlLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzICgnICsgbiArICcgbGluZXMgcHJvdmlkZWQpLicpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBDdXJ2ZSkgeyAvLyBjdXJ2ZXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gYXJnc1swXS5lbmQuY2xvbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vdmV0byBjb25zdHJ1Y3RvciBleHBlY3RzIGEgbGluZSwgYSBjdXJ2ZSwgMSBwb2ludCwgb3IgMiBjb29yZGluYXRlcyAoJyArIG4gKyAnIGN1cnZlcyBwcm92aWRlZCkuJyk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmdzWzBdID09PSAnbnVtYmVyJykgeyAvLyBjb29yZGluYXRlcyBwcm92aWRlZFxuICAgICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBuZXcgUG9pbnQoK2FyZ3NbMF0sICthcmdzWzFdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAobiA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW92ZXRvIGNvbnN0cnVjdG9yIGV4cGVjdHMgYSBsaW5lLCBhIGN1cnZlLCAxIHBvaW50LCBvciAyIGNvb3JkaW5hdGVzICgnICsgbiArICcgY29vcmRpbmF0ZXMgcHJvdmlkZWQpLicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoaXMgaXMgYSBtb3ZldG8td2l0aC1zdWJzZXF1ZW50LXBvbHktbGluZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgc2VnbWVudENvb3JkcztcbiAgICAgICAgICAgIG91dHB1dEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSArPSAyKSB7IC8vIGNvb3JkcyBjb21lIGluIGdyb3VwcyBvZiB0d29cblxuICAgICAgICAgICAgICAgIHNlZ21lbnRDb29yZHMgPSBhcmdzLnNsaWNlKGksIGkgKyAyKTsgLy8gd2lsbCBzZW5kIG9uZSBjb29yZCBpZiBhcmdzLmxlbmd0aCBub3QgZGl2aXNpYmxlIGJ5IDJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KE1vdmV0bywgc2VnbWVudENvb3JkcykpO1xuICAgICAgICAgICAgICAgIGVsc2Ugb3V0cHV0QXJyYXkucHVzaChhcHBseVRvTmV3KExpbmV0bywgc2VnbWVudENvb3JkcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyBwb2ludHMgcHJvdmlkZWQgKG5lZWRzIHRvIGJlIGxhc3QgdG8gYWxzbyBjb3ZlciBwbGFpbiBvYmplY3RzIHdpdGggeCBhbmQgeSlcbiAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gbmV3IFBvaW50KGFyZ3NbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhpcyBpcyBhIG1vdmV0by13aXRoLXN1YnNlcXVlbnQtcG9seS1saW5lIHNlZ21lbnRcbiAgICAgICAgICAgIHZhciBzZWdtZW50UG9pbnQ7XG4gICAgICAgICAgICBvdXRwdXRBcnJheSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gMSkgeyAvLyBwb2ludHMgY29tZSBvbmUgYnkgb25lXG5cbiAgICAgICAgICAgICAgICBzZWdtZW50UG9pbnQgPSBhcmdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSBvdXRwdXRBcnJheS5wdXNoKG5ldyBNb3ZldG8oc2VnbWVudFBvaW50KSk7XG4gICAgICAgICAgICAgICAgZWxzZSBvdXRwdXRBcnJheS5wdXNoKG5ldyBMaW5ldG8oc2VnbWVudFBvaW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbW92ZXRvUHJvdG90eXBlID0ge1xuXG4gICAgYmJveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IE1vdmV0byh0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIGNsb3Nlc3RQb2ludE5vcm1hbGl6ZWRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50VGFuZ2VudDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGRpdmlkZUF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5jbG9uZSgpLFxuICAgICAgICAgICAgdGhpcy5jbG9uZSgpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGRpdmlkZUF0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5jbG9uZSgpLFxuICAgICAgICAgICAgdGhpcy5jbG9uZSgpXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGVxdWFsczogZnVuY3Rpb24obSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5lcXVhbHMobS5lbmQpO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBpc1N1YnBhdGhTdGFydDogdHJ1ZSxcblxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG5cbiAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBsZW5ndGhBdFQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBwb2ludEF0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbmQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgcG9pbnRBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLmNsb25lKCk7XG4gICAgfSxcblxuICAgIHBvaW50QXRUOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5lbmQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHRoaXMuZW5kLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICB0aGlzLmVuZC5zY2FsZShzeCwgc3ksIG9yaWdpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmVuZDtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIGVuZC54ICsgJyAnICsgZW5kLnk7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdExlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHRhbmdlbnRBdFQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcgJyArIHRoaXMuZW5kO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHR4LCB0eSkge1xuXG4gICAgICAgIHRoaXMuZW5kLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW92ZXRvUHJvdG90eXBlLCAnc3RhcnQnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYWNjZXNzLiBNb3ZldG8gc2VnbWVudHMgc2hvdWxkIG5vdCBuZWVkIGEgc3RhcnQgcHJvcGVydHkuJyk7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb3ZldG9Qcm90b3R5cGUsICd0eXBlJywge1xuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIHZhbHVlOiAnTSdcbn0pO1xuXG5Nb3ZldG8ucHJvdG90eXBlID0gZXh0ZW5kKHNlZ21lbnRQcm90b3R5cGUsIG1vdmV0b1Byb3RvdHlwZSk7IC8vIGRvZXMgbm90IGluaGVyaXQgZnJvbSBhbnkgb3RoZXIgZ2VvbWV0cnkgb2JqZWN0XG5cbnZhciBDbG9zZXBhdGggPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbG9zZXBhdGgpKSB7IC8vIHN3aXRjaGluZyBjb250ZXh0IG9mIGB0aGlzYCB0byBDbG9zZXBhdGggd2hlbiBjYWxsZWQgd2l0aG91dCBgbmV3YFxuICAgICAgICByZXR1cm4gYXBwbHlUb05ldyhDbG9zZXBhdGgsIGFyZ3MpO1xuICAgIH1cblxuICAgIGlmIChuID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nsb3NlcGF0aCBjb25zdHJ1Y3RvciBleHBlY3RzIG5vIGFyZ3VtZW50cy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBjbG9zZXBhdGhQcm90b3R5cGUgPSB7XG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDbG9zZXBhdGgoKTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gICAgICAgIHZhciBkaXZpZGVkID0gbGluZS5kaXZpZGVBdChyYXRpbyk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgYWN0dWFsbHkgY3V0IGludG8gdGhlIHNlZ21lbnQsIGZpcnN0IGRpdmlkZWQgcGFydCBjYW4gc3RheSBhcyBaXG4gICAgICAgICAgICAoZGl2aWRlZFsxXS5pc0RpZmZlcmVudGlhYmxlKCkgPyBuZXcgTGluZXRvKGRpdmlkZWRbMF0pIDogdGhpcy5jbG9uZSgpKSxcbiAgICAgICAgICAgIG5ldyBMaW5ldG8oZGl2aWRlZFsxXSlcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgZGl2aWRlQXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICAgICAgICB2YXIgZGl2aWRlZCA9IGxpbmUuZGl2aWRlQXRMZW5ndGgobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBhY3R1YWxseSBjdXQgaW50byB0aGUgc2VnbWVudCwgZmlyc3QgZGl2aWRlZCBwYXJ0IGNhbiBzdGF5IGFzIFpcbiAgICAgICAgICAgIChkaXZpZGVkWzFdLmlzRGlmZmVyZW50aWFibGUoKSA/IG5ldyBMaW5ldG8oZGl2aWRlZFswXSkgOiB0aGlzLmNsb25lKCkpLFxuICAgICAgICAgICAgbmV3IExpbmV0byhkaXZpZGVkWzFdKVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBnZXRTdWJkaXZpc2lvbnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgaXNEaWZmZXJlbnRpYWJsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzU2VnbWVudCB8fCAhdGhpcy5zdWJwYXRoU3RhcnRTZWdtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YXJ0LmVxdWFscyh0aGlzLmVuZCk7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJyAnICsgdGhpcy5zdGFydCArICcgJyArIHRoaXMuZW5kO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9zZXBhdGhQcm90b3R5cGUsICdlbmQnLCB7XG4gICAgLy8gZ2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBlbmQgcG9pbnQgb2Ygc3VicGF0aCBzdGFydCBzZWdtZW50XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuc3VicGF0aFN0YXJ0U2VnbWVudCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHN1YnBhdGggc3RhcnQgc2VnbWVudC4gKFRoaXMgc2VnbWVudCBuZWVkcyBhIHN1YnBhdGggc3RhcnQgc2VnbWVudCAoZS5nLiBNb3ZldG8pOyBPUiBzZWdtZW50IGhhcyBub3QgeWV0IGJlZW4gYWRkZWQgdG8gYSBwYXRoLiknKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5zdWJwYXRoU3RhcnRTZWdtZW50LmVuZDtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb3NlcGF0aFByb3RvdHlwZSwgJ3R5cGUnLCB7XG5cbiAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgdmFsdWU6ICdaJ1xufSk7XG5cbkNsb3NlcGF0aC5wcm90b3R5cGUgPSBleHRlbmQoc2VnbWVudFByb3RvdHlwZSwgTGluZS5wcm90b3R5cGUsIGNsb3NlcGF0aFByb3RvdHlwZSk7XG5cbnZhciBzZWdtZW50VHlwZXMgPSBQYXRoLnNlZ21lbnRUeXBlcyA9IHtcbiAgICBMOiBMaW5ldG8sXG4gICAgQzogQ3VydmV0byxcbiAgICBNOiBNb3ZldG8sXG4gICAgWjogQ2xvc2VwYXRoLFxuICAgIHo6IENsb3NlcGF0aFxufTtcblxuUGF0aC5yZWdleFN1cHBvcnRlZERhdGEgPSBuZXcgUmVnRXhwKCdeW1xcXFxzXFxcXGQnICsgT2JqZWN0LmtleXMoc2VnbWVudFR5cGVzKS5qb2luKCcnKSArICcsLl0qJCcpO1xuXG5QYXRoLmlzRGF0YVN1cHBvcnRlZCA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5yZWdleFN1cHBvcnRlZERhdGEudGVzdChkYXRhKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/path.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/point.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: function() { return /* binding */ Point; },\n/* harmony export */   point: function() { return /* binding */ point; }\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _line_bearing_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.bearing.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.bearing.mjs\");\n/* harmony import */ var _line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.squaredLength.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.squaredLength.mjs\");\n/* harmony import */ var _line_length_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line.length.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.length.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n/*\n    Point is the most basic object consisting of x/y coordinate.\n\n    Possible instantiations are:\n    * `Point(10, 20)`\n    * `new Point(10, 20)`\n    * `Point('10 20')`\n    * `Point(Point(10, 20))`\n*/\n\n\n\n\n\n\nconst {\n    abs,\n    cos,\n    sin,\n    sqrt,\n    min,\n    max,\n    atan2,\n    round,\n    pow,\n    PI\n} = Math;\n\nconst Point = function(x, y) {\n\n    if (!(this instanceof Point)) {\n        return new Point(x, y);\n    }\n\n    if (typeof x === 'string') {\n        var xy = x.split(x.indexOf('@') === -1 ? ' ' : '@');\n        x = parseFloat(xy[0]);\n        y = parseFloat(xy[1]);\n\n    } else if (Object(x) === x) {\n        y = x.y;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n};\n\n// Alternative constructor, from polar coordinates.\n// @param {number} Distance.\n// @param {number} Angle in radians.\n// @param {point} [optional] Origin.\nPoint.fromPolar = function(distance, angle, origin) {\n\n    origin = new Point(origin);\n    var x = abs(distance * cos(angle));\n    var y = abs(distance * sin(angle));\n    var deg = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle)((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDeg)(angle));\n\n    if (deg < 90) {\n        y = -y;\n\n    } else if (deg < 180) {\n        x = -x;\n        y = -y;\n\n    } else if (deg < 270) {\n        x = -x;\n    }\n\n    return new Point(origin.x + x, origin.y + y);\n};\n\n// Create a point with random coordinates that fall into the range `[x1, x2]` and `[y1, y2]`.\nPoint.random = function(x1, x2, y1, y2) {\n\n    return new Point((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random)(x1, x2), (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.random)(y1, y2));\n};\n\nPoint.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_1__.types.Point,\n\n    chooseClosest: function(points) {\n\n        var n = points.length;\n        if (n === 1) return new Point(points[0]);\n        var closest = null;\n        var minSqrDistance = Infinity;\n        for (var i = 0; i < n; i++) {\n            var p = new Point(points[i]);\n            var sqrDistance = this.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                closest = p;\n                minSqrDistance = sqrDistance;\n            }\n        }\n        return closest;\n    },\n\n    // If point lies outside rectangle `r`, return the nearest point on the boundary of rect `r`,\n    // otherwise return point itself.\n    // (see Squeak Smalltalk, Point>>adhereTo:)\n    adhereToRect: function(r) {\n\n        if (r.containsPoint(this)) {\n            return this;\n        }\n\n        this.x = min(max(this.x, r.x), r.x + r.width);\n        this.y = min(max(this.y, r.y), r.y + r.height);\n        return this;\n    },\n\n    // Compute the angle between vector from me to p1 and the vector from me to p2.\n    // ordering of points p1 and p2 is important!\n    // theta function's angle convention:\n    // returns angles between 0 and 180 when the angle is counterclockwise\n    // returns angles between 180 and 360 to convert clockwise angles into counterclockwise ones\n    // returns NaN if any of the points p1, p2 is coincident with this point\n    angleBetween: function(p1, p2) {\n\n        var angleBetween = (this.equals(p1) || this.equals(p2)) ? NaN : (this.theta(p2) - this.theta(p1));\n\n        if (angleBetween < 0) {\n            angleBetween += 360; // correction to keep angleBetween between 0 and 360\n        }\n\n        return angleBetween;\n    },\n\n    // Return the bearing between me and the given point.\n    bearing: function(point) {\n        return (0,_line_bearing_mjs__WEBPACK_IMPORTED_MODULE_2__.bearing)(this, point);\n    },\n\n    // Returns change in angle from my previous position (-dx, -dy) to my new position\n    // relative to ref point.\n    changeInAngle: function(dx, dy, ref) {\n\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().offset(-dx, -dy).theta(ref) - this.theta(ref);\n    },\n\n    clone: function() {\n\n        return new Point(this);\n    },\n\n    // Returns the cross product of this point relative to two other points\n    // this point is the common point\n    // point p1 lies on the first vector, point p2 lies on the second vector\n    // watch out for the ordering of points p1 and p2!\n    // positive result indicates a clockwise (\"right\") turn from first to second vector\n    // negative result indicates a counterclockwise (\"left\") turn from first to second vector\n    // zero indicates that the first and second vector are collinear\n    // note that the above directions are reversed from the usual answer on the Internet\n    // that is because we are in a left-handed coord system (because the y-axis points downward)\n    cross: function(p1, p2) {\n\n        return (p1 && p2) ? (((p2.x - this.x) * (p1.y - this.y)) - ((p2.y - this.y) * (p1.x - this.x))) : NaN;\n    },\n\n    difference: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        return new Point(this.x - (dx || 0), this.y - (dy || 0));\n    },\n\n    // Returns distance between me and point `p`.\n    distance: function(p) {\n        return (0,_line_length_mjs__WEBPACK_IMPORTED_MODULE_3__.length)(this, p);\n    },\n\n    // Returns the dot product of this point with given other point\n    dot: function(p) {\n\n        return p ? (this.x * p.x + this.y * p.y) : NaN;\n    },\n\n    equals: function(p) {\n\n        return !!p &&\n            this.x === p.x &&\n            this.y === p.y;\n    },\n\n    // Linear interpolation\n    lerp: function(p, t) {\n\n        var x = this.x;\n        var y = this.y;\n        return new Point((1 - t) * x + t * p.x, (1 - t) * y + t * p.y);\n    },\n\n    magnitude: function() {\n\n        return sqrt((this.x * this.x) + (this.y * this.y)) || 0.01;\n    },\n\n    // Returns a manhattan (taxi-cab) distance between me and point `p`.\n    manhattanDistance: function(p) {\n\n        return abs(p.x - this.x) + abs(p.y - this.y);\n    },\n\n    // Move point on line starting from ref ending at me by\n    // distance distance.\n    move: function(ref, distance) {\n\n        var theta = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)((new Point(ref)).theta(this));\n        var offset = this.offset(cos(theta) * distance, -sin(theta) * distance);\n        return offset;\n    },\n\n    // Scales x and y such that the distance between the point and the origin (0,0) is equal to the given length.\n    normalize: function(length) {\n\n        var scale = (length || 1) / this.magnitude();\n        return this.scale(scale, scale);\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        if ((Object(dx) === dx)) {\n            dy = dx.y;\n            dx = dx.x;\n        }\n\n        this.x += dx || 0;\n        this.y += dy || 0;\n        return this;\n    },\n\n    // Returns a point that is the reflection of me with\n    // the center of inversion in ref point.\n    reflection: function(ref) {\n\n        return (new Point(ref)).move(this, this.distance(ref));\n    },\n\n    // Rotate point by angle around origin.\n    // Angle is flipped because this is a left-handed coord system (y-axis points downward).\n    rotate: function(origin, angle) {\n\n        if (angle === 0) return this;\n\n        origin = origin || new Point(0, 0);\n\n        angle = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)((0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeAngle)(-angle));\n        var cosAngle = cos(angle);\n        var sinAngle = sin(angle);\n\n        var x = (cosAngle * (this.x - origin.x)) - (sinAngle * (this.y - origin.y)) + origin.x;\n        var y = (sinAngle * (this.x - origin.x)) + (cosAngle * (this.y - origin.y)) + origin.y;\n\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        return this;\n    },\n\n    // Scale point with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = (origin && new Point(origin)) || new Point(0, 0);\n        this.x = origin.x + sx * (this.x - origin.x);\n        this.y = origin.y + sy * (this.y - origin.y);\n        return this;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        this.x = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid)(this.x, gx);\n        this.y = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.snapToGrid)(this.y, gy || gx);\n        return this;\n    },\n\n    squaredDistance: function(p) {\n        return (0,_line_squaredLength_mjs__WEBPACK_IMPORTED_MODULE_4__.squaredLength)(this, p);\n    },\n\n    // Compute the angle between me and `p` and the x axis.\n    // (cartesian-to-polar coordinates conversion)\n    // Return theta angle in degrees.\n    theta: function(p) {\n\n        p = new Point(p);\n\n        // Invert the y-axis.\n        var y = -(p.y - this.y);\n        var x = p.x - this.x;\n        var rad = atan2(y, x); // defined for all 0 corner cases\n\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * PI + rad;\n        }\n\n        return 180 * rad / PI;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y };\n    },\n\n    // Converts rectangular to polar coordinates.\n    // An origin can be specified, otherwise it's 0@0.\n    toPolar: function(o) {\n\n        o = (o && new Point(o)) || new Point(0, 0);\n        var x = this.x;\n        var y = this.y;\n        this.x = sqrt((x - o.x) * (x - o.x) + (y - o.y) * (y - o.y)); // r\n        this.y = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRad)(o.theta(new Point(x, y)));\n        return this;\n    },\n\n    toString: function() {\n\n        return this.x + '@' + this.y;\n    },\n\n    serialize: function() {\n\n        return this.x + ',' + this.y;\n    },\n\n    update: function(x, y) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        return this;\n    },\n\n    // Compute the angle between the vector from 0,0 to me and the vector from 0,0 to p.\n    // Returns NaN if p is at 0,0.\n    vectorAngle: function(p) {\n\n        var zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n};\n\nPoint.prototype.translate = Point.prototype.offset;\n\n// For backwards compatibility:\nconst point = Point;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9wb2ludC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBGO0FBQzdDO0FBQ1k7QUFDZDtBQUNQOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFSzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFFQUFjLENBQUMsNERBQUs7O0FBRWxDO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiw2REFBTSxVQUFVLDZEQUFNO0FBQzNDOztBQUVBOztBQUVBLFVBQVUsNkNBQUs7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsMERBQU87QUFDdEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsd0RBQU07QUFDckIsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0REFBSztBQUN6QjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQkFBZ0IsNERBQUssQ0FBQyxxRUFBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsaUJBQWlCLGlFQUFVO0FBQzNCLGlCQUFpQixpRUFBVTtBQUMzQjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLHNFQUFhO0FBQzVCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsaUJBQWlCO0FBQ2pCLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSxpQkFBaUIsNERBQUs7QUFDdEI7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9pbnQubWpzPzgwZDciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBQb2ludCBpcyB0aGUgbW9zdCBiYXNpYyBvYmplY3QgY29uc2lzdGluZyBvZiB4L3kgY29vcmRpbmF0ZS5cblxuICAgIFBvc3NpYmxlIGluc3RhbnRpYXRpb25zIGFyZTpcbiAgICAqIGBQb2ludCgxMCwgMjApYFxuICAgICogYG5ldyBQb2ludCgxMCwgMjApYFxuICAgICogYFBvaW50KCcxMCAyMCcpYFxuICAgICogYFBvaW50KFBvaW50KDEwLCAyMCkpYFxuKi9cbmltcG9ydCB7IG5vcm1hbGl6ZUFuZ2xlLCByYW5kb20sIHNuYXBUb0dyaWQsIHRvRGVnLCB0b1JhZCB9IGZyb20gJy4vZ2VvbWV0cnkuaGVscGVycy5tanMnO1xuaW1wb3J0IHsgYmVhcmluZyB9IGZyb20gJy4vbGluZS5iZWFyaW5nLm1qcyc7XG5pbXBvcnQgeyBzcXVhcmVkTGVuZ3RoIH0gZnJvbSAnLi9saW5lLnNxdWFyZWRMZW5ndGgubWpzJztcbmltcG9ydCB7IGxlbmd0aCB9IGZyb20gJy4vbGluZS5sZW5ndGgubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuXG5jb25zdCB7XG4gICAgYWJzLFxuICAgIGNvcyxcbiAgICBzaW4sXG4gICAgc3FydCxcbiAgICBtaW4sXG4gICAgbWF4LFxuICAgIGF0YW4yLFxuICAgIHJvdW5kLFxuICAgIHBvdyxcbiAgICBQSVxufSA9IE1hdGg7XG5cbmV4cG9ydCBjb25zdCBQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB4eSA9IHguc3BsaXQoeC5pbmRleE9mKCdAJykgPT09IC0xID8gJyAnIDogJ0AnKTtcbiAgICAgICAgeCA9IHBhcnNlRmxvYXQoeHlbMF0pO1xuICAgICAgICB5ID0gcGFyc2VGbG9hdCh4eVsxXSk7XG5cbiAgICB9IGVsc2UgaWYgKE9iamVjdCh4KSA9PT0geCkge1xuICAgICAgICB5ID0geC55O1xuICAgICAgICB4ID0geC54O1xuICAgIH1cblxuICAgIHRoaXMueCA9IHggPT09IHVuZGVmaW5lZCA/IDAgOiB4O1xuICAgIHRoaXMueSA9IHkgPT09IHVuZGVmaW5lZCA/IDAgOiB5O1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IsIGZyb20gcG9sYXIgY29vcmRpbmF0ZXMuXG4vLyBAcGFyYW0ge251bWJlcn0gRGlzdGFuY2UuXG4vLyBAcGFyYW0ge251bWJlcn0gQW5nbGUgaW4gcmFkaWFucy5cbi8vIEBwYXJhbSB7cG9pbnR9IFtvcHRpb25hbF0gT3JpZ2luLlxuUG9pbnQuZnJvbVBvbGFyID0gZnVuY3Rpb24oZGlzdGFuY2UsIGFuZ2xlLCBvcmlnaW4pIHtcblxuICAgIG9yaWdpbiA9IG5ldyBQb2ludChvcmlnaW4pO1xuICAgIHZhciB4ID0gYWJzKGRpc3RhbmNlICogY29zKGFuZ2xlKSk7XG4gICAgdmFyIHkgPSBhYnMoZGlzdGFuY2UgKiBzaW4oYW5nbGUpKTtcbiAgICB2YXIgZGVnID0gbm9ybWFsaXplQW5nbGUodG9EZWcoYW5nbGUpKTtcblxuICAgIGlmIChkZWcgPCA5MCkge1xuICAgICAgICB5ID0gLXk7XG5cbiAgICB9IGVsc2UgaWYgKGRlZyA8IDE4MCkge1xuICAgICAgICB4ID0gLXg7XG4gICAgICAgIHkgPSAteTtcblxuICAgIH0gZWxzZSBpZiAoZGVnIDwgMjcwKSB7XG4gICAgICAgIHggPSAteDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBvaW50KG9yaWdpbi54ICsgeCwgb3JpZ2luLnkgKyB5KTtcbn07XG5cbi8vIENyZWF0ZSBhIHBvaW50IHdpdGggcmFuZG9tIGNvb3JkaW5hdGVzIHRoYXQgZmFsbCBpbnRvIHRoZSByYW5nZSBgW3gxLCB4Ml1gIGFuZCBgW3kxLCB5Ml1gLlxuUG9pbnQucmFuZG9tID0gZnVuY3Rpb24oeDEsIHgyLCB5MSwgeTIpIHtcblxuICAgIHJldHVybiBuZXcgUG9pbnQocmFuZG9tKHgxLCB4MiksIHJhbmRvbSh5MSwgeTIpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLlBvaW50LFxuXG4gICAgY2hvb3NlQ2xvc2VzdDogZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICAgICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobiA9PT0gMSkgcmV0dXJuIG5ldyBQb2ludChwb2ludHNbMF0pO1xuICAgICAgICB2YXIgY2xvc2VzdCA9IG51bGw7XG4gICAgICAgIHZhciBtaW5TcXJEaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUG9pbnQocG9pbnRzW2ldKTtcbiAgICAgICAgICAgIHZhciBzcXJEaXN0YW5jZSA9IHRoaXMuc3F1YXJlZERpc3RhbmNlKHApO1xuICAgICAgICAgICAgaWYgKHNxckRpc3RhbmNlIDwgbWluU3FyRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0ID0gcDtcbiAgICAgICAgICAgICAgICBtaW5TcXJEaXN0YW5jZSA9IHNxckRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH0sXG5cbiAgICAvLyBJZiBwb2ludCBsaWVzIG91dHNpZGUgcmVjdGFuZ2xlIGByYCwgcmV0dXJuIHRoZSBuZWFyZXN0IHBvaW50IG9uIHRoZSBib3VuZGFyeSBvZiByZWN0IGByYCxcbiAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHBvaW50IGl0c2VsZi5cbiAgICAvLyAoc2VlIFNxdWVhayBTbWFsbHRhbGssIFBvaW50Pj5hZGhlcmVUbzopXG4gICAgYWRoZXJlVG9SZWN0OiBmdW5jdGlvbihyKSB7XG5cbiAgICAgICAgaWYgKHIuY29udGFpbnNQb2ludCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggPSBtaW4obWF4KHRoaXMueCwgci54KSwgci54ICsgci53aWR0aCk7XG4gICAgICAgIHRoaXMueSA9IG1pbihtYXgodGhpcy55LCByLnkpLCByLnkgKyByLmhlaWdodCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDb21wdXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHZlY3RvciBmcm9tIG1lIHRvIHAxIGFuZCB0aGUgdmVjdG9yIGZyb20gbWUgdG8gcDIuXG4gICAgLy8gb3JkZXJpbmcgb2YgcG9pbnRzIHAxIGFuZCBwMiBpcyBpbXBvcnRhbnQhXG4gICAgLy8gdGhldGEgZnVuY3Rpb24ncyBhbmdsZSBjb252ZW50aW9uOlxuICAgIC8vIHJldHVybnMgYW5nbGVzIGJldHdlZW4gMCBhbmQgMTgwIHdoZW4gdGhlIGFuZ2xlIGlzIGNvdW50ZXJjbG9ja3dpc2VcbiAgICAvLyByZXR1cm5zIGFuZ2xlcyBiZXR3ZWVuIDE4MCBhbmQgMzYwIHRvIGNvbnZlcnQgY2xvY2t3aXNlIGFuZ2xlcyBpbnRvIGNvdW50ZXJjbG9ja3dpc2Ugb25lc1xuICAgIC8vIHJldHVybnMgTmFOIGlmIGFueSBvZiB0aGUgcG9pbnRzIHAxLCBwMiBpcyBjb2luY2lkZW50IHdpdGggdGhpcyBwb2ludFxuICAgIGFuZ2xlQmV0d2VlbjogZnVuY3Rpb24ocDEsIHAyKSB7XG5cbiAgICAgICAgdmFyIGFuZ2xlQmV0d2VlbiA9ICh0aGlzLmVxdWFscyhwMSkgfHwgdGhpcy5lcXVhbHMocDIpKSA/IE5hTiA6ICh0aGlzLnRoZXRhKHAyKSAtIHRoaXMudGhldGEocDEpKTtcblxuICAgICAgICBpZiAoYW5nbGVCZXR3ZWVuIDwgMCkge1xuICAgICAgICAgICAgYW5nbGVCZXR3ZWVuICs9IDM2MDsgLy8gY29ycmVjdGlvbiB0byBrZWVwIGFuZ2xlQmV0d2VlbiBiZXR3ZWVuIDAgYW5kIDM2MFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFuZ2xlQmV0d2VlbjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBiZWFyaW5nIGJldHdlZW4gbWUgYW5kIHRoZSBnaXZlbiBwb2ludC5cbiAgICBiZWFyaW5nOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gYmVhcmluZyh0aGlzLCBwb2ludCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgY2hhbmdlIGluIGFuZ2xlIGZyb20gbXkgcHJldmlvdXMgcG9zaXRpb24gKC1keCwgLWR5KSB0byBteSBuZXcgcG9zaXRpb25cbiAgICAvLyByZWxhdGl2ZSB0byByZWYgcG9pbnQuXG4gICAgY2hhbmdlSW5BbmdsZTogZnVuY3Rpb24oZHgsIGR5LCByZWYpIHtcblxuICAgICAgICAvLyBSZXZlcnQgdGhlIHRyYW5zbGF0aW9uIGFuZCBtZWFzdXJlIHRoZSBjaGFuZ2UgaW4gYW5nbGUgYXJvdW5kIHgtYXhpcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5vZmZzZXQoLWR4LCAtZHkpLnRoZXRhKHJlZikgLSB0aGlzLnRoZXRhKHJlZik7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHRoaXMgcG9pbnQgcmVsYXRpdmUgdG8gdHdvIG90aGVyIHBvaW50c1xuICAgIC8vIHRoaXMgcG9pbnQgaXMgdGhlIGNvbW1vbiBwb2ludFxuICAgIC8vIHBvaW50IHAxIGxpZXMgb24gdGhlIGZpcnN0IHZlY3RvciwgcG9pbnQgcDIgbGllcyBvbiB0aGUgc2Vjb25kIHZlY3RvclxuICAgIC8vIHdhdGNoIG91dCBmb3IgdGhlIG9yZGVyaW5nIG9mIHBvaW50cyBwMSBhbmQgcDIhXG4gICAgLy8gcG9zaXRpdmUgcmVzdWx0IGluZGljYXRlcyBhIGNsb2Nrd2lzZSAoXCJyaWdodFwiKSB0dXJuIGZyb20gZmlyc3QgdG8gc2Vjb25kIHZlY3RvclxuICAgIC8vIG5lZ2F0aXZlIHJlc3VsdCBpbmRpY2F0ZXMgYSBjb3VudGVyY2xvY2t3aXNlIChcImxlZnRcIikgdHVybiBmcm9tIGZpcnN0IHRvIHNlY29uZCB2ZWN0b3JcbiAgICAvLyB6ZXJvIGluZGljYXRlcyB0aGF0IHRoZSBmaXJzdCBhbmQgc2Vjb25kIHZlY3RvciBhcmUgY29sbGluZWFyXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBhYm92ZSBkaXJlY3Rpb25zIGFyZSByZXZlcnNlZCBmcm9tIHRoZSB1c3VhbCBhbnN3ZXIgb24gdGhlIEludGVybmV0XG4gICAgLy8gdGhhdCBpcyBiZWNhdXNlIHdlIGFyZSBpbiBhIGxlZnQtaGFuZGVkIGNvb3JkIHN5c3RlbSAoYmVjYXVzZSB0aGUgeS1heGlzIHBvaW50cyBkb3dud2FyZClcbiAgICBjcm9zczogZnVuY3Rpb24ocDEsIHAyKSB7XG5cbiAgICAgICAgcmV0dXJuIChwMSAmJiBwMikgPyAoKChwMi54IC0gdGhpcy54KSAqIChwMS55IC0gdGhpcy55KSkgLSAoKHAyLnkgLSB0aGlzLnkpICogKHAxLnggLSB0aGlzLngpKSkgOiBOYU47XG4gICAgfSxcblxuICAgIGRpZmZlcmVuY2U6IGZ1bmN0aW9uKGR4LCBkeSkge1xuXG4gICAgICAgIGlmICgoT2JqZWN0KGR4KSA9PT0gZHgpKSB7XG4gICAgICAgICAgICBkeSA9IGR4Lnk7XG4gICAgICAgICAgICBkeCA9IGR4Lng7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIChkeCB8fCAwKSwgdGhpcy55IC0gKGR5IHx8IDApKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIG1lIGFuZCBwb2ludCBgcGAuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCh0aGlzLCBwKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyBwb2ludCB3aXRoIGdpdmVuIG90aGVyIHBvaW50XG4gICAgZG90OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuIHAgPyAodGhpcy54ICogcC54ICsgdGhpcy55ICogcC55KSA6IE5hTjtcbiAgICB9LFxuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgcmV0dXJuICEhcCAmJlxuICAgICAgICAgICAgdGhpcy54ID09PSBwLnggJiZcbiAgICAgICAgICAgIHRoaXMueSA9PT0gcC55O1xuICAgIH0sXG5cbiAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgIGxlcnA6IGZ1bmN0aW9uKHAsIHQpIHtcblxuICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoKDEgLSB0KSAqIHggKyB0ICogcC54LCAoMSAtIHQpICogeSArIHQgKiBwLnkpO1xuICAgIH0sXG5cbiAgICBtYWduaXR1ZGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBzcXJ0KCh0aGlzLnggKiB0aGlzLngpICsgKHRoaXMueSAqIHRoaXMueSkpIHx8IDAuMDE7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBtYW5oYXR0YW4gKHRheGktY2FiKSBkaXN0YW5jZSBiZXR3ZWVuIG1lIGFuZCBwb2ludCBgcGAuXG4gICAgbWFuaGF0dGFuRGlzdGFuY2U6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICByZXR1cm4gYWJzKHAueCAtIHRoaXMueCkgKyBhYnMocC55IC0gdGhpcy55KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZSBwb2ludCBvbiBsaW5lIHN0YXJ0aW5nIGZyb20gcmVmIGVuZGluZyBhdCBtZSBieVxuICAgIC8vIGRpc3RhbmNlIGRpc3RhbmNlLlxuICAgIG1vdmU6IGZ1bmN0aW9uKHJlZiwgZGlzdGFuY2UpIHtcblxuICAgICAgICB2YXIgdGhldGEgPSB0b1JhZCgobmV3IFBvaW50KHJlZikpLnRoZXRhKHRoaXMpKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0KGNvcyh0aGV0YSkgKiBkaXN0YW5jZSwgLXNpbih0aGV0YSkgKiBkaXN0YW5jZSk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfSxcblxuICAgIC8vIFNjYWxlcyB4IGFuZCB5IHN1Y2ggdGhhdCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnQgYW5kIHRoZSBvcmlnaW4gKDAsMCkgaXMgZXF1YWwgdG8gdGhlIGdpdmVuIGxlbmd0aC5cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBzY2FsZSA9IChsZW5ndGggfHwgMSkgLyB0aGlzLm1hZ25pdHVkZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIH0sXG5cbiAgICAvLyBPZmZzZXQgbWUgYnkgdGhlIHNwZWNpZmllZCBhbW91bnQuXG4gICAgb2Zmc2V0OiBmdW5jdGlvbihkeCwgZHkpIHtcblxuICAgICAgICBpZiAoKE9iamVjdChkeCkgPT09IGR4KSkge1xuICAgICAgICAgICAgZHkgPSBkeC55O1xuICAgICAgICAgICAgZHggPSBkeC54O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ICs9IGR4IHx8IDA7XG4gICAgICAgIHRoaXMueSArPSBkeSB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIHJlZmxlY3Rpb24gb2YgbWUgd2l0aFxuICAgIC8vIHRoZSBjZW50ZXIgb2YgaW52ZXJzaW9uIGluIHJlZiBwb2ludC5cbiAgICByZWZsZWN0aW9uOiBmdW5jdGlvbihyZWYpIHtcblxuICAgICAgICByZXR1cm4gKG5ldyBQb2ludChyZWYpKS5tb3ZlKHRoaXMsIHRoaXMuZGlzdGFuY2UocmVmKSk7XG4gICAgfSxcblxuICAgIC8vIFJvdGF0ZSBwb2ludCBieSBhbmdsZSBhcm91bmQgb3JpZ2luLlxuICAgIC8vIEFuZ2xlIGlzIGZsaXBwZWQgYmVjYXVzZSB0aGlzIGlzIGEgbGVmdC1oYW5kZWQgY29vcmQgc3lzdGVtICh5LWF4aXMgcG9pbnRzIGRvd253YXJkKS5cbiAgICByb3RhdGU6IGZ1bmN0aW9uKG9yaWdpbiwgYW5nbGUpIHtcblxuICAgICAgICBpZiAoYW5nbGUgPT09IDApIHJldHVybiB0aGlzO1xuXG4gICAgICAgIG9yaWdpbiA9IG9yaWdpbiB8fCBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICAgICAgYW5nbGUgPSB0b1JhZChub3JtYWxpemVBbmdsZSgtYW5nbGUpKTtcbiAgICAgICAgdmFyIGNvc0FuZ2xlID0gY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHNpbkFuZ2xlID0gc2luKGFuZ2xlKTtcblxuICAgICAgICB2YXIgeCA9IChjb3NBbmdsZSAqICh0aGlzLnggLSBvcmlnaW4ueCkpIC0gKHNpbkFuZ2xlICogKHRoaXMueSAtIG9yaWdpbi55KSkgKyBvcmlnaW4ueDtcbiAgICAgICAgdmFyIHkgPSAoc2luQW5nbGUgKiAodGhpcy54IC0gb3JpZ2luLngpKSArIChjb3NBbmdsZSAqICh0aGlzLnkgLSBvcmlnaW4ueSkpICsgb3JpZ2luLnk7XG5cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICBsZXQgZiA9IDE7IC8vIGNhc2UgMFxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogZiA9IDEwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IGYgPSAxMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogZiA9IDEwMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGYgPSBwb3coMTAsIHByZWNpc2lvbik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0gcm91bmQodGhpcy54ICogZikgLyBmO1xuICAgICAgICB0aGlzLnkgPSByb3VuZCh0aGlzLnkgKiBmKSAvIGY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTY2FsZSBwb2ludCB3aXRoIG9yaWdpbi5cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5LCBvcmlnaW4pIHtcblxuICAgICAgICBvcmlnaW4gPSAob3JpZ2luICYmIG5ldyBQb2ludChvcmlnaW4pKSB8fCBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHRoaXMueCA9IG9yaWdpbi54ICsgc3ggKiAodGhpcy54IC0gb3JpZ2luLngpO1xuICAgICAgICB0aGlzLnkgPSBvcmlnaW4ueSArIHN5ICogKHRoaXMueSAtIG9yaWdpbi55KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNuYXBUb0dyaWQ6IGZ1bmN0aW9uKGd4LCBneSkge1xuXG4gICAgICAgIHRoaXMueCA9IHNuYXBUb0dyaWQodGhpcy54LCBneCk7XG4gICAgICAgIHRoaXMueSA9IHNuYXBUb0dyaWQodGhpcy55LCBneSB8fCBneCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzcXVhcmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHNxdWFyZWRMZW5ndGgodGhpcywgcCk7XG4gICAgfSxcblxuICAgIC8vIENvbXB1dGUgdGhlIGFuZ2xlIGJldHdlZW4gbWUgYW5kIGBwYCBhbmQgdGhlIHggYXhpcy5cbiAgICAvLyAoY2FydGVzaWFuLXRvLXBvbGFyIGNvb3JkaW5hdGVzIGNvbnZlcnNpb24pXG4gICAgLy8gUmV0dXJuIHRoZXRhIGFuZ2xlIGluIGRlZ3JlZXMuXG4gICAgdGhldGE6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuXG4gICAgICAgIC8vIEludmVydCB0aGUgeS1heGlzLlxuICAgICAgICB2YXIgeSA9IC0ocC55IC0gdGhpcy55KTtcbiAgICAgICAgdmFyIHggPSBwLnggLSB0aGlzLng7XG4gICAgICAgIHZhciByYWQgPSBhdGFuMih5LCB4KTsgLy8gZGVmaW5lZCBmb3IgYWxsIDAgY29ybmVyIGNhc2VzXG5cbiAgICAgICAgLy8gQ29ycmVjdGlvbiBmb3IgSUlJLiBhbmQgSVYuIHF1YWRyYW50LlxuICAgICAgICBpZiAocmFkIDwgMCkge1xuICAgICAgICAgICAgcmFkID0gMiAqIFBJICsgcmFkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDE4MCAqIHJhZCAvIFBJO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55IH07XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnRzIHJlY3Rhbmd1bGFyIHRvIHBvbGFyIGNvb3JkaW5hdGVzLlxuICAgIC8vIEFuIG9yaWdpbiBjYW4gYmUgc3BlY2lmaWVkLCBvdGhlcndpc2UgaXQncyAwQDAuXG4gICAgdG9Qb2xhcjogZnVuY3Rpb24obykge1xuXG4gICAgICAgIG8gPSAobyAmJiBuZXcgUG9pbnQobykpIHx8IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICB0aGlzLnggPSBzcXJ0KCh4IC0gby54KSAqICh4IC0gby54KSArICh5IC0gby55KSAqICh5IC0gby55KSk7IC8vIHJcbiAgICAgICAgdGhpcy55ID0gdG9SYWQoby50aGV0YShuZXcgUG9pbnQoeCwgeSkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy54ICsgJ0AnICsgdGhpcy55O1xuICAgIH0sXG5cbiAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnggKyAnLCcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICAgIGlmICgoT2JqZWN0KHgpID09PSB4KSkge1xuICAgICAgICAgICAgeSA9IHgueTtcbiAgICAgICAgICAgIHggPSB4Lng7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIENvbXB1dGUgdGhlIGFuZ2xlIGJldHdlZW4gdGhlIHZlY3RvciBmcm9tIDAsMCB0byBtZSBhbmQgdGhlIHZlY3RvciBmcm9tIDAsMCB0byBwLlxuICAgIC8vIFJldHVybnMgTmFOIGlmIHAgaXMgYXQgMCwwLlxuICAgIHZlY3RvckFuZ2xlOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIHplcm8gPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgICAgIHJldHVybiB6ZXJvLmFuZ2xlQmV0d2Vlbih0aGlzLCBwKTtcbiAgICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudHJhbnNsYXRlID0gUG9pbnQucHJvdG90eXBlLm9mZnNldDtcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxuZXhwb3J0IGNvbnN0IHBvaW50ID0gUG9pbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/points.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/g/points.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clonePoints: function() { return /* binding */ clonePoints; },\n/* harmony export */   convexHull: function() { return /* binding */ convexHull; },\n/* harmony export */   parsePoints: function() { return /* binding */ parsePoints; }\n/* harmony export */ });\nfunction parsePoints(svgString) {\n\n    // Step 1: Discard surrounding spaces\n    const trimmedString = svgString.trim();\n    if (trimmedString === '') return [];\n\n    const points = [];\n\n    // Step 2: Split at commas (+ their surrounding spaces) or at multiple spaces\n    // ReDoS mitigation: Have an anchor at the beginning of each alternation\n    // Note: This doesn't simplify double (or more) commas - causes empty coords\n    // This regex is used by `split()`, so it doesn't need to use /g\n    const coords = trimmedString.split(/\\b\\s*,\\s*|,\\s*|\\s+/);\n\n    const numCoords = coords.length;\n    for (let i = 0; i < numCoords; i += 2) {\n        // Step 3: Convert each coord to number\n        // Note: If the coord cannot be converted to a number, it will be `NaN`\n        // Note: If the coord is empty (\"\", e.g. from \",,\" input), it will be `0`\n        // Note: If we end up with an odd number of coords, the last point's second coord will be `NaN`\n        points.push({ x: +coords[i], y: +coords[i + 1] });\n    }\n    return points;\n}\n\nfunction clonePoints(points) {\n    const numPoints = points.length;\n    if (numPoints === 0) return [];\n    const newPoints = [];\n    for (let i = 0; i < numPoints; i++) {\n        const point = points[i].clone();\n        newPoints.push(point);\n    }\n    return newPoints;\n}\n\n// Returns a convex-hull polyline from this polyline.\n// Implements the Graham scan (https://en.wikipedia.org/wiki/Graham_scan).\n// Output polyline starts at the first element of the original polyline that is on the hull, then continues clockwise.\n// Minimal polyline is found (only vertices of the hull are reported, no collinear points).\nfunction convexHull(points) {\n\n    const { abs } = Math;\n\n    var i;\n    var n;\n\n    var numPoints = points.length;\n    if (numPoints === 0) return []; // if points array is empty\n\n    // step 1: find the starting point - point with the lowest y (if equality, highest x)\n    var startPoint;\n    for (i = 0; i < numPoints; i++) {\n        if (startPoint === undefined) {\n            // if this is the first point we see, set it as start point\n            startPoint = points[i];\n\n        } else if (points[i].y < startPoint.y) {\n            // start point should have lowest y from all points\n            startPoint = points[i];\n\n        } else if ((points[i].y === startPoint.y) && (points[i].x > startPoint.x)) {\n            // if two points have the lowest y, choose the one that has highest x\n            // there are no points to the right of startPoint - no ambiguity about theta 0\n            // if there are several coincident start point candidates, first one is reported\n            startPoint = points[i];\n        }\n    }\n\n    // step 2: sort the list of points\n    // sorting by angle between line from startPoint to point and the x-axis (theta)\n\n    // step 2a: create the point records = [point, originalIndex, angle]\n    var sortedPointRecords = [];\n    for (i = 0; i < numPoints; i++) {\n\n        var angle = startPoint.theta(points[i]);\n        if (angle === 0) {\n            angle = 360; // give highest angle to start point\n            // the start point will end up at end of sorted list\n            // the start point will end up at beginning of hull points list\n        }\n\n        var entry = [points[i], i, angle];\n        sortedPointRecords.push(entry);\n    }\n\n    // step 2b: sort the list in place\n    sortedPointRecords.sort(function(record1, record2) {\n        // returning a negative number here sorts record1 before record2\n        // if first angle is smaller than second, first angle should come before second\n\n        var sortOutput = record1[2] - record2[2];  // negative if first angle smaller\n        if (sortOutput === 0) {\n            // if the two angles are equal, sort by originalIndex\n            sortOutput = record2[1] - record1[1]; // negative if first index larger\n            // coincident points will be sorted in reverse-numerical order\n            // so the coincident points with lower original index will be considered first\n        }\n\n        return sortOutput;\n    });\n\n    // step 2c: duplicate start record from the top of the stack to the bottom of the stack\n    if (sortedPointRecords.length > 2) {\n        var startPointRecord = sortedPointRecords[sortedPointRecords.length - 1];\n        sortedPointRecords.unshift(startPointRecord);\n    }\n\n    // step 3a: go through sorted points in order and find those with right turns\n    // we want to get our results in clockwise order\n    var insidePoints = {}; // dictionary of points with left turns - cannot be on the hull\n    var hullPointRecords = []; // stack of records with right turns - hull point candidates\n\n    var currentPointRecord;\n    var currentPoint;\n    var lastHullPointRecord;\n    var lastHullPoint;\n    var secondLastHullPointRecord;\n    var secondLastHullPoint;\n    while (sortedPointRecords.length !== 0) {\n\n        currentPointRecord = sortedPointRecords.pop();\n        currentPoint = currentPointRecord[0];\n\n        // check if point has already been discarded\n        // keys for insidePoints are stored in the form 'point.x@point.y@@originalIndex'\n        if (insidePoints.hasOwnProperty(currentPointRecord[0] + '@@' + currentPointRecord[1])) {\n            // this point had an incorrect turn at some previous iteration of this loop\n            // this disqualifies it from possibly being on the hull\n            continue;\n        }\n\n        var correctTurnFound = false;\n        while (!correctTurnFound) {\n\n            if (hullPointRecords.length < 2) {\n                // not enough points for comparison, just add current point\n                hullPointRecords.push(currentPointRecord);\n                correctTurnFound = true;\n\n            } else {\n                lastHullPointRecord = hullPointRecords.pop();\n                lastHullPoint = lastHullPointRecord[0];\n                secondLastHullPointRecord = hullPointRecords.pop();\n                secondLastHullPoint = secondLastHullPointRecord[0];\n\n                var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n                if (crossProduct < 0) {\n                    // found a right turn\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    hullPointRecords.push(lastHullPointRecord);\n                    hullPointRecords.push(currentPointRecord);\n                    correctTurnFound = true;\n\n                } else if (crossProduct === 0) {\n                    // the three points are collinear\n                    // three options:\n                    // there may be a 180 or 0 degree angle at lastHullPoint\n                    // or two of the three points are coincident\n                    var THRESHOLD = 1e-10; // we have to take rounding errors into account\n                    var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                    if (abs(angleBetween - 180) < THRESHOLD) { // rounding around 180 to 180\n                        // if the cross product is 0 because the angle is 180 degrees\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                        // if the cross product is 0 because two points are the same\n                        // discard last hull point (add to insidePoints)\n                        //insidePoints.unshift(lastHullPoint);\n                        insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n\n                    } else if (abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) { // rounding around 0 and 360 to 0\n                        // if the cross product is 0 because the angle is 0 degrees\n                        // remove last hull point from hull BUT do not discard it\n                        // reenter second-to-last hull point (will be last at next iter)\n                        hullPointRecords.push(secondLastHullPointRecord);\n                        // put last hull point back into the sorted point records list\n                        sortedPointRecords.push(lastHullPointRecord);\n                        // we are switching the order of the 0deg and 180deg points\n                        // correct turn not found\n                    }\n\n                } else {\n                    // found a left turn\n                    // discard last hull point (add to insidePoints)\n                    //insidePoints.unshift(lastHullPoint);\n                    insidePoints[lastHullPointRecord[0] + '@@' + lastHullPointRecord[1]] = lastHullPoint;\n                    // reenter second-to-last hull point (will be last at next iter of loop)\n                    hullPointRecords.push(secondLastHullPointRecord);\n                    // do not do anything with current point\n                    // correct turn not found\n                }\n            }\n        }\n    }\n    // at this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n\n    // step 3b: remove duplicated startPointRecord from the end of the array\n    if (hullPointRecords.length > 2) {\n        hullPointRecords.pop();\n    }\n\n    // step 4: find the lowest originalIndex record and put it at the beginning of hull\n    var lowestHullIndex; // the lowest originalIndex on the hull\n    var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n    n = hullPointRecords.length;\n    for (i = 0; i < n; i++) {\n\n        var currentHullIndex = hullPointRecords[i][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n            lowestHullIndex = currentHullIndex;\n            indexOfLowestHullIndexRecord = i;\n        }\n    }\n\n    var hullPointRecordsReordered = [];\n    if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullPointRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullPointRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n\n    } else {\n        hullPointRecordsReordered = hullPointRecords;\n    }\n\n    var hullPoints = [];\n    n = hullPointRecordsReordered.length;\n    for (i = 0; i < n; i++) {\n        hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return hullPoints;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9wb2ludHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0NBQWtDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTzs7QUFFUCxZQUFZLE1BQU07O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTs7QUFFL0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDREQUE0RDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsMkNBQTJDO0FBQzNDO0FBQ0EsZ0JBQWdCLE9BQU87O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9wb2ludHMubWpzPzE2OGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUG9pbnRzKHN2Z1N0cmluZykge1xuXG4gICAgLy8gU3RlcCAxOiBEaXNjYXJkIHN1cnJvdW5kaW5nIHNwYWNlc1xuICAgIGNvbnN0IHRyaW1tZWRTdHJpbmcgPSBzdmdTdHJpbmcudHJpbSgpO1xuICAgIGlmICh0cmltbWVkU3RyaW5nID09PSAnJykgcmV0dXJuIFtdO1xuXG4gICAgY29uc3QgcG9pbnRzID0gW107XG5cbiAgICAvLyBTdGVwIDI6IFNwbGl0IGF0IGNvbW1hcyAoKyB0aGVpciBzdXJyb3VuZGluZyBzcGFjZXMpIG9yIGF0IG11bHRpcGxlIHNwYWNlc1xuICAgIC8vIFJlRG9TIG1pdGlnYXRpb246IEhhdmUgYW4gYW5jaG9yIGF0IHRoZSBiZWdpbm5pbmcgb2YgZWFjaCBhbHRlcm5hdGlvblxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBzaW1wbGlmeSBkb3VibGUgKG9yIG1vcmUpIGNvbW1hcyAtIGNhdXNlcyBlbXB0eSBjb29yZHNcbiAgICAvLyBUaGlzIHJlZ2V4IGlzIHVzZWQgYnkgYHNwbGl0KClgLCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gdXNlIC9nXG4gICAgY29uc3QgY29vcmRzID0gdHJpbW1lZFN0cmluZy5zcGxpdCgvXFxiXFxzKixcXHMqfCxcXHMqfFxccysvKTtcblxuICAgIGNvbnN0IG51bUNvb3JkcyA9IGNvb3Jkcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db29yZHM7IGkgKz0gMikge1xuICAgICAgICAvLyBTdGVwIDM6IENvbnZlcnQgZWFjaCBjb29yZCB0byBudW1iZXJcbiAgICAgICAgLy8gTm90ZTogSWYgdGhlIGNvb3JkIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBudW1iZXIsIGl0IHdpbGwgYmUgYE5hTmBcbiAgICAgICAgLy8gTm90ZTogSWYgdGhlIGNvb3JkIGlzIGVtcHR5IChcIlwiLCBlLmcuIGZyb20gXCIsLFwiIGlucHV0KSwgaXQgd2lsbCBiZSBgMGBcbiAgICAgICAgLy8gTm90ZTogSWYgd2UgZW5kIHVwIHdpdGggYW4gb2RkIG51bWJlciBvZiBjb29yZHMsIHRoZSBsYXN0IHBvaW50J3Mgc2Vjb25kIGNvb3JkIHdpbGwgYmUgYE5hTmBcbiAgICAgICAgcG9pbnRzLnB1c2goeyB4OiArY29vcmRzW2ldLCB5OiArY29vcmRzW2kgKyAxXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lUG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IG5ld1BvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV0uY2xvbmUoKTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG4vLyBSZXR1cm5zIGEgY29udmV4LWh1bGwgcG9seWxpbmUgZnJvbSB0aGlzIHBvbHlsaW5lLlxuLy8gSW1wbGVtZW50cyB0aGUgR3JhaGFtIHNjYW4gKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYWhhbV9zY2FuKS5cbi8vIE91dHB1dCBwb2x5bGluZSBzdGFydHMgYXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIG9yaWdpbmFsIHBvbHlsaW5lIHRoYXQgaXMgb24gdGhlIGh1bGwsIHRoZW4gY29udGludWVzIGNsb2Nrd2lzZS5cbi8vIE1pbmltYWwgcG9seWxpbmUgaXMgZm91bmQgKG9ubHkgdmVydGljZXMgb2YgdGhlIGh1bGwgYXJlIHJlcG9ydGVkLCBubyBjb2xsaW5lYXIgcG9pbnRzKS5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXhIdWxsKHBvaW50cykge1xuXG4gICAgY29uc3QgeyBhYnMgfSA9IE1hdGg7XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbjtcblxuICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBbXTsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAvLyBzdGVwIDE6IGZpbmQgdGhlIHN0YXJ0aW5nIHBvaW50IC0gcG9pbnQgd2l0aCB0aGUgbG93ZXN0IHkgKGlmIGVxdWFsaXR5LCBoaWdoZXN0IHgpXG4gICAgdmFyIHN0YXJ0UG9pbnQ7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIGlmIChzdGFydFBvaW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IHdlIHNlZSwgc2V0IGl0IGFzIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICBzdGFydFBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzW2ldLnkgPCBzdGFydFBvaW50LnkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHBvaW50IHNob3VsZCBoYXZlIGxvd2VzdCB5IGZyb20gYWxsIHBvaW50c1xuICAgICAgICAgICAgc3RhcnRQb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICB9IGVsc2UgaWYgKChwb2ludHNbaV0ueSA9PT0gc3RhcnRQb2ludC55KSAmJiAocG9pbnRzW2ldLnggPiBzdGFydFBvaW50LngpKSB7XG4gICAgICAgICAgICAvLyBpZiB0d28gcG9pbnRzIGhhdmUgdGhlIGxvd2VzdCB5LCBjaG9vc2UgdGhlIG9uZSB0aGF0IGhhcyBoaWdoZXN0IHhcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBwb2ludHMgdG8gdGhlIHJpZ2h0IG9mIHN0YXJ0UG9pbnQgLSBubyBhbWJpZ3VpdHkgYWJvdXQgdGhldGEgMFxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHNldmVyYWwgY29pbmNpZGVudCBzdGFydCBwb2ludCBjYW5kaWRhdGVzLCBmaXJzdCBvbmUgaXMgcmVwb3J0ZWRcbiAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdGVwIDI6IHNvcnQgdGhlIGxpc3Qgb2YgcG9pbnRzXG4gICAgLy8gc29ydGluZyBieSBhbmdsZSBiZXR3ZWVuIGxpbmUgZnJvbSBzdGFydFBvaW50IHRvIHBvaW50IGFuZCB0aGUgeC1heGlzICh0aGV0YSlcblxuICAgIC8vIHN0ZXAgMmE6IGNyZWF0ZSB0aGUgcG9pbnQgcmVjb3JkcyA9IFtwb2ludCwgb3JpZ2luYWxJbmRleCwgYW5nbGVdXG4gICAgdmFyIHNvcnRlZFBvaW50UmVjb3JkcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuXG4gICAgICAgIHZhciBhbmdsZSA9IHN0YXJ0UG9pbnQudGhldGEocG9pbnRzW2ldKTtcbiAgICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgICAgICBhbmdsZSA9IDM2MDsgLy8gZ2l2ZSBoaWdoZXN0IGFuZ2xlIHRvIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgcG9pbnQgd2lsbCBlbmQgdXAgYXQgZW5kIG9mIHNvcnRlZCBsaXN0XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgcG9pbnQgd2lsbCBlbmQgdXAgYXQgYmVnaW5uaW5nIG9mIGh1bGwgcG9pbnRzIGxpc3RcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnRyeSA9IFtwb2ludHNbaV0sIGksIGFuZ2xlXTtcbiAgICAgICAgc29ydGVkUG9pbnRSZWNvcmRzLnB1c2goZW50cnkpO1xuICAgIH1cblxuICAgIC8vIHN0ZXAgMmI6IHNvcnQgdGhlIGxpc3QgaW4gcGxhY2VcbiAgICBzb3J0ZWRQb2ludFJlY29yZHMuc29ydChmdW5jdGlvbihyZWNvcmQxLCByZWNvcmQyKSB7XG4gICAgICAgIC8vIHJldHVybmluZyBhIG5lZ2F0aXZlIG51bWJlciBoZXJlIHNvcnRzIHJlY29yZDEgYmVmb3JlIHJlY29yZDJcbiAgICAgICAgLy8gaWYgZmlyc3QgYW5nbGUgaXMgc21hbGxlciB0aGFuIHNlY29uZCwgZmlyc3QgYW5nbGUgc2hvdWxkIGNvbWUgYmVmb3JlIHNlY29uZFxuXG4gICAgICAgIHZhciBzb3J0T3V0cHV0ID0gcmVjb3JkMVsyXSAtIHJlY29yZDJbMl07ICAvLyBuZWdhdGl2ZSBpZiBmaXJzdCBhbmdsZSBzbWFsbGVyXG4gICAgICAgIGlmIChzb3J0T3V0cHV0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgdHdvIGFuZ2xlcyBhcmUgZXF1YWwsIHNvcnQgYnkgb3JpZ2luYWxJbmRleFxuICAgICAgICAgICAgc29ydE91dHB1dCA9IHJlY29yZDJbMV0gLSByZWNvcmQxWzFdOyAvLyBuZWdhdGl2ZSBpZiBmaXJzdCBpbmRleCBsYXJnZXJcbiAgICAgICAgICAgIC8vIGNvaW5jaWRlbnQgcG9pbnRzIHdpbGwgYmUgc29ydGVkIGluIHJldmVyc2UtbnVtZXJpY2FsIG9yZGVyXG4gICAgICAgICAgICAvLyBzbyB0aGUgY29pbmNpZGVudCBwb2ludHMgd2l0aCBsb3dlciBvcmlnaW5hbCBpbmRleCB3aWxsIGJlIGNvbnNpZGVyZWQgZmlyc3RcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3J0T3V0cHV0O1xuICAgIH0pO1xuXG4gICAgLy8gc3RlcCAyYzogZHVwbGljYXRlIHN0YXJ0IHJlY29yZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHRvIHRoZSBib3R0b20gb2YgdGhlIHN0YWNrXG4gICAgaWYgKHNvcnRlZFBvaW50UmVjb3Jkcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHZhciBzdGFydFBvaW50UmVjb3JkID0gc29ydGVkUG9pbnRSZWNvcmRzW3NvcnRlZFBvaW50UmVjb3Jkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgc29ydGVkUG9pbnRSZWNvcmRzLnVuc2hpZnQoc3RhcnRQb2ludFJlY29yZCk7XG4gICAgfVxuXG4gICAgLy8gc3RlcCAzYTogZ28gdGhyb3VnaCBzb3J0ZWQgcG9pbnRzIGluIG9yZGVyIGFuZCBmaW5kIHRob3NlIHdpdGggcmlnaHQgdHVybnNcbiAgICAvLyB3ZSB3YW50IHRvIGdldCBvdXIgcmVzdWx0cyBpbiBjbG9ja3dpc2Ugb3JkZXJcbiAgICB2YXIgaW5zaWRlUG9pbnRzID0ge307IC8vIGRpY3Rpb25hcnkgb2YgcG9pbnRzIHdpdGggbGVmdCB0dXJucyAtIGNhbm5vdCBiZSBvbiB0aGUgaHVsbFxuICAgIHZhciBodWxsUG9pbnRSZWNvcmRzID0gW107IC8vIHN0YWNrIG9mIHJlY29yZHMgd2l0aCByaWdodCB0dXJucyAtIGh1bGwgcG9pbnQgY2FuZGlkYXRlc1xuXG4gICAgdmFyIGN1cnJlbnRQb2ludFJlY29yZDtcbiAgICB2YXIgY3VycmVudFBvaW50O1xuICAgIHZhciBsYXN0SHVsbFBvaW50UmVjb3JkO1xuICAgIHZhciBsYXN0SHVsbFBvaW50O1xuICAgIHZhciBzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkO1xuICAgIHZhciBzZWNvbmRMYXN0SHVsbFBvaW50O1xuICAgIHdoaWxlIChzb3J0ZWRQb2ludFJlY29yZHMubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAgICAgY3VycmVudFBvaW50UmVjb3JkID0gc29ydGVkUG9pbnRSZWNvcmRzLnBvcCgpO1xuICAgICAgICBjdXJyZW50UG9pbnQgPSBjdXJyZW50UG9pbnRSZWNvcmRbMF07XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgcG9pbnQgaGFzIGFscmVhZHkgYmVlbiBkaXNjYXJkZWRcbiAgICAgICAgLy8ga2V5cyBmb3IgaW5zaWRlUG9pbnRzIGFyZSBzdG9yZWQgaW4gdGhlIGZvcm0gJ3BvaW50LnhAcG9pbnQueUBAb3JpZ2luYWxJbmRleCdcbiAgICAgICAgaWYgKGluc2lkZVBvaW50cy5oYXNPd25Qcm9wZXJ0eShjdXJyZW50UG9pbnRSZWNvcmRbMF0gKyAnQEAnICsgY3VycmVudFBvaW50UmVjb3JkWzFdKSkge1xuICAgICAgICAgICAgLy8gdGhpcyBwb2ludCBoYWQgYW4gaW5jb3JyZWN0IHR1cm4gYXQgc29tZSBwcmV2aW91cyBpdGVyYXRpb24gb2YgdGhpcyBsb29wXG4gICAgICAgICAgICAvLyB0aGlzIGRpc3F1YWxpZmllcyBpdCBmcm9tIHBvc3NpYmx5IGJlaW5nIG9uIHRoZSBodWxsXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb3JyZWN0VHVybkZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghY29ycmVjdFR1cm5Gb3VuZCkge1xuXG4gICAgICAgICAgICBpZiAoaHVsbFBvaW50UmVjb3Jkcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBwb2ludHMgZm9yIGNvbXBhcmlzb24sIGp1c3QgYWRkIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2goY3VycmVudFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICBjb3JyZWN0VHVybkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXN0SHVsbFBvaW50UmVjb3JkID0gaHVsbFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0SHVsbFBvaW50ID0gbGFzdEh1bGxQb2ludFJlY29yZFswXTtcbiAgICAgICAgICAgICAgICBzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkID0gaHVsbFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBzZWNvbmRMYXN0SHVsbFBvaW50ID0gc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZFswXTtcblxuICAgICAgICAgICAgICAgIHZhciBjcm9zc1Byb2R1Y3QgPSBzZWNvbmRMYXN0SHVsbFBvaW50LmNyb3NzKGxhc3RIdWxsUG9pbnQsIGN1cnJlbnRQb2ludCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NQcm9kdWN0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIHJpZ2h0IHR1cm5cbiAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2gobGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChjdXJyZW50UG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0VHVybkZvdW5kID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NQcm9kdWN0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0aHJlZSBwb2ludHMgYXJlIGNvbGxpbmVhclxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJlZSBvcHRpb25zOlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtYXkgYmUgYSAxODAgb3IgMCBkZWdyZWUgYW5nbGUgYXQgbGFzdEh1bGxQb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyBvciB0d28gb2YgdGhlIHRocmVlIHBvaW50cyBhcmUgY29pbmNpZGVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgVEhSRVNIT0xEID0gMWUtMTA7IC8vIHdlIGhhdmUgdG8gdGFrZSByb3VuZGluZyBlcnJvcnMgaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmdsZUJldHdlZW4gPSBsYXN0SHVsbFBvaW50LmFuZ2xlQmV0d2VlbihzZWNvbmRMYXN0SHVsbFBvaW50LCBjdXJyZW50UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzKGFuZ2xlQmV0d2VlbiAtIDE4MCkgPCBUSFJFU0hPTEQpIHsgLy8gcm91bmRpbmcgYXJvdW5kIDE4MCB0byAxODBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjcm9zcyBwcm9kdWN0IGlzIDAgYmVjYXVzZSB0aGUgYW5nbGUgaXMgMTgwIGRlZ3JlZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc2NhcmQgbGFzdCBodWxsIHBvaW50IChhZGQgdG8gaW5zaWRlUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pbnNpZGVQb2ludHMudW5zaGlmdChsYXN0SHVsbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZVBvaW50c1tsYXN0SHVsbFBvaW50UmVjb3JkWzBdICsgJ0BAJyArIGxhc3RIdWxsUG9pbnRSZWNvcmRbMV1dID0gbGFzdEh1bGxQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlZW50ZXIgc2Vjb25kLXRvLWxhc3QgaHVsbCBwb2ludCAod2lsbCBiZSBsYXN0IGF0IG5leHQgaXRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bGxQb2ludFJlY29yZHMucHVzaChzZWNvbmRMYXN0SHVsbFBvaW50UmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkbyBhbnl0aGluZyB3aXRoIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdHVybiBub3QgZm91bmRcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RIdWxsUG9pbnQuZXF1YWxzKGN1cnJlbnRQb2ludCkgfHwgc2Vjb25kTGFzdEh1bGxQb2ludC5lcXVhbHMobGFzdEh1bGxQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjcm9zcyBwcm9kdWN0IGlzIDAgYmVjYXVzZSB0d28gcG9pbnRzIGFyZSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzY2FyZCBsYXN0IGh1bGwgcG9pbnQgKGFkZCB0byBpbnNpZGVQb2ludHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2luc2lkZVBvaW50cy51bnNoaWZ0KGxhc3RIdWxsUG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zaWRlUG9pbnRzW2xhc3RIdWxsUG9pbnRSZWNvcmRbMF0gKyAnQEAnICsgbGFzdEh1bGxQb2ludFJlY29yZFsxXV0gPSBsYXN0SHVsbFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVlbnRlciBzZWNvbmQtdG8tbGFzdCBodWxsIHBvaW50ICh3aWxsIGJlIGxhc3QgYXQgbmV4dCBpdGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGRvIGFueXRoaW5nIHdpdGggY3VycmVudCBwb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCB0dXJuIG5vdCBmb3VuZFxuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWJzKCgoYW5nbGVCZXR3ZWVuICsgMSkgJSAzNjApIC0gMSkgPCBUSFJFU0hPTEQpIHsgLy8gcm91bmRpbmcgYXJvdW5kIDAgYW5kIDM2MCB0byAwXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3Jvc3MgcHJvZHVjdCBpcyAwIGJlY2F1c2UgdGhlIGFuZ2xlIGlzIDAgZGVncmVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxhc3QgaHVsbCBwb2ludCBmcm9tIGh1bGwgQlVUIGRvIG5vdCBkaXNjYXJkIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWVudGVyIHNlY29uZC10by1sYXN0IGh1bGwgcG9pbnQgKHdpbGwgYmUgbGFzdCBhdCBuZXh0IGl0ZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBodWxsUG9pbnRSZWNvcmRzLnB1c2goc2Vjb25kTGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXQgbGFzdCBodWxsIHBvaW50IGJhY2sgaW50byB0aGUgc29ydGVkIHBvaW50IHJlY29yZHMgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkUG9pbnRSZWNvcmRzLnB1c2gobGFzdEh1bGxQb2ludFJlY29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgc3dpdGNoaW5nIHRoZSBvcmRlciBvZiB0aGUgMGRlZyBhbmQgMTgwZGVnIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVjdCB0dXJuIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGxlZnQgdHVyblxuICAgICAgICAgICAgICAgICAgICAvLyBkaXNjYXJkIGxhc3QgaHVsbCBwb2ludCAoYWRkIHRvIGluc2lkZVBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgLy9pbnNpZGVQb2ludHMudW5zaGlmdChsYXN0SHVsbFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlUG9pbnRzW2xhc3RIdWxsUG9pbnRSZWNvcmRbMF0gKyAnQEAnICsgbGFzdEh1bGxQb2ludFJlY29yZFsxXV0gPSBsYXN0SHVsbFBvaW50O1xuICAgICAgICAgICAgICAgICAgICAvLyByZWVudGVyIHNlY29uZC10by1sYXN0IGh1bGwgcG9pbnQgKHdpbGwgYmUgbGFzdCBhdCBuZXh0IGl0ZXIgb2YgbG9vcClcbiAgICAgICAgICAgICAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wdXNoKHNlY29uZExhc3RIdWxsUG9pbnRSZWNvcmQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgZG8gYW55dGhpbmcgd2l0aCBjdXJyZW50IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgdHVybiBub3QgZm91bmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYXQgdGhpcyBwb2ludCwgaHVsbFBvaW50UmVjb3JkcyBjb250YWlucyB0aGUgb3V0cHV0IHBvaW50cyBpbiBjbG9ja3dpc2Ugb3JkZXJcbiAgICAvLyB0aGUgcG9pbnRzIHN0YXJ0IHdpdGggbG93ZXN0LXksaGlnaGVzdC14IHN0YXJ0UG9pbnQsIGFuZCBlbmQgYXQgdGhlIHNhbWUgcG9pbnRcblxuICAgIC8vIHN0ZXAgM2I6IHJlbW92ZSBkdXBsaWNhdGVkIHN0YXJ0UG9pbnRSZWNvcmQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgIGlmIChodWxsUG9pbnRSZWNvcmRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgaHVsbFBvaW50UmVjb3Jkcy5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyBzdGVwIDQ6IGZpbmQgdGhlIGxvd2VzdCBvcmlnaW5hbEluZGV4IHJlY29yZCBhbmQgcHV0IGl0IGF0IHRoZSBiZWdpbm5pbmcgb2YgaHVsbFxuICAgIHZhciBsb3dlc3RIdWxsSW5kZXg7IC8vIHRoZSBsb3dlc3Qgb3JpZ2luYWxJbmRleCBvbiB0aGUgaHVsbFxuICAgIHZhciBpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkID0gLTE7IC8vIHRoZSBpbmRleCBvZiB0aGUgcmVjb3JkIHdpdGggbG93ZXN0SHVsbEluZGV4XG4gICAgbiA9IGh1bGxQb2ludFJlY29yZHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICB2YXIgY3VycmVudEh1bGxJbmRleCA9IGh1bGxQb2ludFJlY29yZHNbaV1bMV07XG5cbiAgICAgICAgaWYgKGxvd2VzdEh1bGxJbmRleCA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRIdWxsSW5kZXggPCBsb3dlc3RIdWxsSW5kZXgpIHtcbiAgICAgICAgICAgIGxvd2VzdEh1bGxJbmRleCA9IGN1cnJlbnRIdWxsSW5kZXg7XG4gICAgICAgICAgICBpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkID0gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBodWxsUG9pbnRSZWNvcmRzUmVvcmRlcmVkID0gW107XG4gICAgaWYgKGluZGV4T2ZMb3dlc3RIdWxsSW5kZXhSZWNvcmQgPiAwKSB7XG4gICAgICAgIHZhciBuZXdGaXJzdENodW5rID0gaHVsbFBvaW50UmVjb3Jkcy5zbGljZShpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkKTtcbiAgICAgICAgdmFyIG5ld1NlY29uZENodW5rID0gaHVsbFBvaW50UmVjb3Jkcy5zbGljZSgwLCBpbmRleE9mTG93ZXN0SHVsbEluZGV4UmVjb3JkKTtcbiAgICAgICAgaHVsbFBvaW50UmVjb3Jkc1Jlb3JkZXJlZCA9IG5ld0ZpcnN0Q2h1bmsuY29uY2F0KG5ld1NlY29uZENodW5rKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWQgPSBodWxsUG9pbnRSZWNvcmRzO1xuICAgIH1cblxuICAgIHZhciBodWxsUG9pbnRzID0gW107XG4gICAgbiA9IGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWQubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaHVsbFBvaW50cy5wdXNoKGh1bGxQb2ludFJlY29yZHNSZW9yZGVyZWRbaV1bMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBodWxsUG9pbnRzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/points.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/polygon.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/g/polygon.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polygon: function() { return /* binding */ Polygon; }\n/* harmony export */ });\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _polyline_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polyline.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _extend_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extend.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/extend.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _points_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./points.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/points.mjs\");\n\n\n\n\n\n\nconst Polygon = function(points) {\n\n    if (!(this instanceof Polygon)) {\n        return new Polygon(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polygon.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(_point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point) : []);\n};\n\nPolygon.parse = function(svgString) {\n    return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePoints)(svgString));\n};\n\nPolygon.fromRect = function(rect) {\n    return new Polygon([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft()\n    ]);\n};\n\nPolygon.prototype = (0,_extend_mjs__WEBPACK_IMPORTED_MODULE_2__.extend)(_polyline_mjs__WEBPACK_IMPORTED_MODULE_3__.Polyline.prototype, {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_4__.types.Polygon,\n\n    clone: function() {\n        return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.clonePoints)(this.points));\n    },\n\n    convexHull: function() {\n        return new Polygon((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.convexHull)(this.points));\n    },\n\n    lengthPoints: function() {\n        const { start, end, points } = this;\n        if (points.length <= 1 || start.equals(end)) return points;\n        return [...points, start.clone()];\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9wb2x5Z29uLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDTTtBQUNKO0FBQ0Y7QUFDZ0M7O0FBRTdEOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELDZDQUFLO0FBQzNEOztBQUVBO0FBQ0EsdUJBQXVCLHdEQUFXO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG1EQUFNLENBQUMsbURBQVE7O0FBRW5DLFVBQVUsNkNBQUs7O0FBRWY7QUFDQSwyQkFBMkIsd0RBQVc7QUFDdEMsS0FBSzs7QUFFTDtBQUNBLDJCQUEyQix1REFBVTtBQUNyQyxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9seWdvbi5tanM/OGU4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcG9pbnQubWpzJztcbmltcG9ydCB7IFBvbHlsaW5lIH0gZnJvbSAnLi9wb2x5bGluZS5tanMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi9leHRlbmQubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuaW1wb3J0IHsgY2xvbmVQb2ludHMsIHBhcnNlUG9pbnRzLCBjb252ZXhIdWxsIH0gZnJvbSAnLi9wb2ludHMubWpzJztcblxuZXhwb3J0IGNvbnN0IFBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb2x5Z29uKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb24ocG9pbnRzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBvaW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uLnBhcnNlKHBvaW50cyk7XG4gICAgfVxuXG4gICAgdGhpcy5wb2ludHMgPSAoQXJyYXkuaXNBcnJheShwb2ludHMpID8gcG9pbnRzLm1hcChQb2ludCkgOiBbXSk7XG59O1xuXG5Qb2x5Z29uLnBhcnNlID0gZnVuY3Rpb24oc3ZnU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHBhcnNlUG9pbnRzKHN2Z1N0cmluZykpO1xufTtcblxuUG9seWdvbi5mcm9tUmVjdCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oW1xuICAgICAgICByZWN0LnRvcExlZnQoKSxcbiAgICAgICAgcmVjdC50b3BSaWdodCgpLFxuICAgICAgICByZWN0LmJvdHRvbVJpZ2h0KCksXG4gICAgICAgIHJlY3QuYm90dG9tTGVmdCgpXG4gICAgXSk7XG59O1xuXG5Qb2x5Z29uLnByb3RvdHlwZSA9IGV4dGVuZChQb2x5bGluZS5wcm90b3R5cGUsIHtcblxuICAgIHR5cGU6IHR5cGVzLlBvbHlnb24sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbihjbG9uZVBvaW50cyh0aGlzLnBvaW50cykpO1xuICAgIH0sXG5cbiAgICBjb252ZXhIdWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uKGNvbnZleEh1bGwodGhpcy5wb2ludHMpKTtcbiAgICB9LFxuXG4gICAgbGVuZ3RoUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCBwb2ludHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDEgfHwgc3RhcnQuZXF1YWxzKGVuZCkpIHJldHVybiBwb2ludHM7XG4gICAgICAgIHJldHVybiBbLi4ucG9pbnRzLCBzdGFydC5jbG9uZSgpXTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/polygon.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@joint/core/src/g/polyline.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polyline: function() { return /* binding */ Polyline; }\n/* harmony export */ });\n/* harmony import */ var _rect_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n/* harmony import */ var _points_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./points.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/points.mjs\");\n\n\n\n\n\n\n\nconst Polyline = function(points) {\n\n    if (!(this instanceof Polyline)) {\n        return new Polyline(points);\n    }\n\n    if (typeof points === 'string') {\n        return new Polyline.parse(points);\n    }\n\n    this.points = (Array.isArray(points) ? points.map(_point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point) : []);\n};\n\nPolyline.parse = function(svgString) {\n    return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.parsePoints)(svgString));\n};\n\nPolyline.fromRect = function(rect) {\n    return new Polyline([\n        rect.topLeft(),\n        rect.topRight(),\n        rect.bottomRight(),\n        rect.bottomLeft(),\n        rect.topLeft(),\n    ]);\n};\n\nPolyline.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Polyline,\n\n    bbox: function() {\n\n        var x1 = Infinity;\n        var x2 = -Infinity;\n        var y1 = Infinity;\n        var y2 = -Infinity;\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var x = point.x;\n            var y = point.y;\n\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n        }\n\n        return new _rect_mjs__WEBPACK_IMPORTED_MODULE_3__.Rect(x1, y1, x2 - x1, y2 - y1);\n    },\n\n    clone: function() {\n        return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.clonePoints)(this.points));\n    },\n\n    closestPoint: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.pointAtLength(cpLength);\n    },\n\n    closestPointLength: function(p) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n        if (numPoints === 1) return 0; // if there is only one point\n\n        var cpLength;\n        var minSqrDistance = Infinity;\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(points[i], points[i + 1]);\n            var lineLength = line.length();\n\n            var cpNormalizedLength = line.closestPointNormalizedLength(p);\n            var cp = line.pointAt(cpNormalizedLength);\n\n            var sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + (cpNormalizedLength * lineLength);\n            }\n\n            length += lineLength;\n        }\n\n        return cpLength;\n    },\n\n    closestPointNormalizedLength: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n        if (cpLength === 0) return 0; // shortcut\n\n        var length = this.length();\n        if (length === 0) return 0; // prevents division by zero\n\n        return cpLength / length;\n    },\n\n    closestPointTangent: function(p) {\n\n        var cpLength = this.closestPointLength(p);\n\n        return this.tangentAtLength(cpLength);\n    },\n\n    // Returns `true` if the area surrounded by the polyline contains the point `p`.\n    // Implements the even-odd SVG algorithm (self-intersections are \"outside\").\n    // (Uses horizontal rays to the right of `p` to look for intersections.)\n    // Closes open polylines (always imagines a final closing segment).\n    containsPoint: function(p) {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false; // shortcut (this polyline has no points)\n\n        var x = p.x;\n        var y = p.y;\n\n        // initialize a final closing segment by creating one from last-first points on polyline\n        var startIndex = numPoints - 1; // start of current polyline segment\n        var endIndex = 0; // end of current polyline segment\n        var numIntersections = 0;\n        var segment = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var ray = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var rayEnd = new _point_mjs__WEBPACK_IMPORTED_MODULE_0__.Point();\n        for (; endIndex < numPoints; endIndex++) {\n            var start = points[startIndex];\n            var end = points[endIndex];\n            if (p.equals(start)) return true; // shortcut (`p` is a point on polyline)\n            // current polyline segment\n            segment.start = start;\n            segment.end = end;\n            if (segment.containsPoint(p)) return true; // shortcut (`p` lies on a polyline segment)\n\n            // do we have an intersection?\n            if (((y <= start.y) && (y > end.y)) || ((y > start.y) && (y <= end.y))) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n\n                var xDifference = (((start.x - x) > (end.x - x)) ? (start.x - x) : (end.x - x));\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    rayEnd.x = x + xDifference;\n                    rayEnd.y = y; // right\n                    ray.start = p;\n                    ray.end = rayEnd;\n                    if (segment.intersect(ray)) {\n                        // an intersection was detected to the right of `p`\n                        numIntersections++;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return ((numIntersections % 2) === 1);\n    },\n\n    close: function() {\n        const { start, end, points } = this;\n        if (start && end && !start.equals(end)) {\n            points.push(start.clone());\n        }\n        return this;\n    },\n\n    lengthPoints: function() {\n        return this.points;\n    },\n\n    convexHull: function() {\n        return new Polyline((0,_points_mjs__WEBPACK_IMPORTED_MODULE_1__.convexHull)(this.points));\n    },\n\n    // Checks whether two polylines are exactly the same.\n    // If `p` is undefined or null, returns false.\n    equals: function(p) {\n\n        if (!p) return false;\n\n        var points = this.points;\n        var otherPoints = p.points;\n\n        var numPoints = points.length;\n        if (otherPoints.length !== numPoints) return false; // if the two polylines have different number of points, they cannot be equal\n\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            var otherPoint = p.points[i];\n\n            // as soon as an inequality is found in points, return false\n            if (!point.equals(otherPoint)) return false;\n        }\n\n        // if no inequality found in points, return true\n        return true;\n    },\n\n    intersectionWithLine: function(l) {\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(l);\n        var intersections = [];\n        var points = this.lengthPoints();\n        var l2 = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        for (var i = 0, n = points.length - 1; i < n; i++) {\n            l2.start = points[i];\n            l2.end = points[i + 1];\n            var int = line.intersectionWithLine(l2);\n            if (int) intersections.push(int[0]);\n        }\n        return (intersections.length > 0) ? intersections : null;\n    },\n\n    isDifferentiable: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return false;\n\n        var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line();\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            line.start = points[i];\n            line.end = points[i + 1];\n            // as soon as a differentiable line is found between two points, return true\n            if (line.isDifferentiable()) return true;\n        }\n\n        // if no differentiable line is found between pairs of points, return false\n        return false;\n    },\n\n    length: function() {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return 0; // if points array is empty\n\n        var length = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            length += points[i].distance(points[i + 1]);\n        }\n\n        return length;\n    },\n\n    pointAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        if (ratio <= 0) return points[0].clone();\n        if (ratio >= 1) return points[numPoints - 1].clone();\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.pointAtLength(length);\n    },\n\n    pointAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return points[0].clone(); // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var l = 0;\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(a, b);\n            var d = a.distance(b);\n\n            if (length <= (l + d)) {\n                return line.pointAtLength((fromStart ? 1 : -1) * (length - l));\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last endpoint\n        var lastPoint = (fromStart ? points[numPoints - 1] : points[0]);\n        return lastPoint.clone();\n    },\n\n    round: function(precision) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].round(precision);\n        }\n\n        return this;\n    },\n\n    scale: function(sx, sy, origin) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].scale(sx, sy, origin);\n        }\n\n        return this;\n    },\n\n    simplify: function(opt = {}) {\n\n        const points = this.points;\n        if (points.length < 3) return this; // we need at least 3 points\n\n        // TODO: we may also accept startIndex and endIndex to specify where to start and end simplification\n\n        // Due to the nature of the algorithm, we do not use 0 as the default value for `threshold`\n        // because of the rounding errors that can occur when comparing distances.\n        const threshold = opt.threshold || 1e-10; // = max distance of middle point from chord to be simplified\n\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = (currentIndex + 1);\n            const lastIndex = (currentIndex + 2);\n\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n\n            const chord = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            } else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n\n        // `points` array was modified in-place\n        return this;\n    },\n\n    tangentAt: function(ratio) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        if (ratio < 0) ratio = 0;\n        if (ratio > 1) ratio = 1;\n\n        var polylineLength = this.length();\n        var length = polylineLength * ratio;\n\n        return this.tangentAtLength(length);\n    },\n\n    tangentAtLength: function(length) {\n\n        var points = this.lengthPoints();\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n        if (numPoints === 1) return null; // if there is only one point\n\n        var fromStart = true;\n        if (length < 0) {\n            fromStart = false; // negative lengths mean start calculation from end point\n            length = -length; // absolute value\n        }\n\n        var lastValidLine; // differentiable (with a tangent)\n        var l = 0; // length so far\n        var n = numPoints - 1;\n        for (var i = 0; i < n; i++) {\n            var index = (fromStart ? i : (n - 1 - i));\n\n            var a = points[index];\n            var b = points[index + 1];\n            var line = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(a, b);\n            var d = a.distance(b);\n\n            if (line.isDifferentiable()) { // has a tangent line (line length is not 0)\n                if (length <= (l + d)) {\n                    return line.tangentAtLength((fromStart ? 1 : -1) * (length - l));\n                }\n\n                lastValidLine = line;\n            }\n\n            l += d;\n        }\n\n        // if length requested is higher than the length of the polyline, return last valid endpoint\n        if (lastValidLine) {\n            var ratio = (fromStart ? 1 : 0);\n            return lastValidLine.tangentAt(ratio);\n        }\n\n        // if no valid line, return null\n        return null;\n    },\n\n    toString: function() {\n\n        return this.points + '';\n    },\n\n    translate: function(tx, ty) {\n\n        var points = this.points;\n        var numPoints = points.length;\n\n        for (var i = 0; i < numPoints; i++) {\n            points[i].translate(tx, ty);\n        }\n\n        return this;\n    },\n\n    // Return svgString that can be used to recreate this line.\n    serialize: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return ''; // if points array is empty\n\n        var output = '';\n        for (var i = 0; i < numPoints; i++) {\n\n            var point = points[i];\n            output += point.x + ',' + point.y + ' ';\n        }\n\n        return output.trim();\n    }\n};\n\nObject.defineProperty(Polyline.prototype, 'start', {\n    // Getter for the first point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[0];\n    },\n});\n\nObject.defineProperty(Polyline.prototype, 'end', {\n    // Getter for the last point of the polyline.\n\n    configurable: true,\n\n    enumerable: true,\n\n    get: function() {\n\n        var points = this.points;\n        var numPoints = points.length;\n        if (numPoints === 0) return null; // if points array is empty\n\n        return this.points[numPoints - 1];\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9wb2x5bGluZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ0U7QUFDRjtBQUNFO0FBQ2dDOzs7QUFHN0Q7O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsNkNBQUs7QUFDM0Q7O0FBRUE7QUFDQSx3QkFBd0Isd0RBQVc7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsNkNBQUs7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUMsd0JBQXdCLGVBQWU7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwyQ0FBSTtBQUN2QixLQUFLOztBQUVMO0FBQ0EsNEJBQTRCLHdEQUFXO0FBQ3ZDLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPOztBQUUvQiwyQkFBMkIsMkNBQUk7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEMsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCLDJDQUFJO0FBQzlCLHNCQUFzQiwyQ0FBSTtB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QUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0Esd0JBQXdCLGVBQWU7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSxLQUFLO0FBQ0wsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2cvcG9seWxpbmUubWpzPzgxMTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4vcmVjdC5tanMnO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuL3BvaW50Lm1qcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi9saW5lLm1qcyc7XG5pbXBvcnQgeyB0eXBlcyB9IGZyb20gJy4vdHlwZXMubWpzJztcbmltcG9ydCB7IGNsb25lUG9pbnRzLCBwYXJzZVBvaW50cywgY29udmV4SHVsbCB9IGZyb20gJy4vcG9pbnRzLm1qcyc7XG5cblxuZXhwb3J0IGNvbnN0IFBvbHlsaW5lID0gZnVuY3Rpb24ocG9pbnRzKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9seWxpbmUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUocG9pbnRzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBvaW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZS5wYXJzZShwb2ludHMpO1xuICAgIH1cblxuICAgIHRoaXMucG9pbnRzID0gKEFycmF5LmlzQXJyYXkocG9pbnRzKSA/IHBvaW50cy5tYXAoUG9pbnQpIDogW10pO1xufTtcblxuUG9seWxpbmUucGFyc2UgPSBmdW5jdGlvbihzdmdTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFBvbHlsaW5lKHBhcnNlUG9pbnRzKHN2Z1N0cmluZykpO1xufTtcblxuUG9seWxpbmUuZnJvbVJlY3QgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bGluZShbXG4gICAgICAgIHJlY3QudG9wTGVmdCgpLFxuICAgICAgICByZWN0LnRvcFJpZ2h0KCksXG4gICAgICAgIHJlY3QuYm90dG9tUmlnaHQoKSxcbiAgICAgICAgcmVjdC5ib3R0b21MZWZ0KCksXG4gICAgICAgIHJlY3QudG9wTGVmdCgpLFxuICAgIF0pO1xufTtcblxuUG9seWxpbmUucHJvdG90eXBlID0ge1xuXG4gICAgdHlwZTogdHlwZXMuUG9seWxpbmUsXG5cbiAgICBiYm94OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgeDEgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHgyID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgeTEgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHkyID0gLUluZmluaXR5O1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgIHZhciB5ID0gcG9pbnQueTtcblxuICAgICAgICAgICAgaWYgKHggPCB4MSkgeDEgPSB4O1xuICAgICAgICAgICAgaWYgKHggPiB4MikgeDIgPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCB5MSkgeTEgPSB5O1xuICAgICAgICAgICAgaWYgKHkgPiB5MikgeTIgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0KHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZShjbG9uZVBvaW50cyh0aGlzLnBvaW50cykpO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnQ6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICB2YXIgY3BMZW5ndGggPSB0aGlzLmNsb3Nlc3RQb2ludExlbmd0aChwKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0TGVuZ3RoKGNwTGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgY2xvc2VzdFBvaW50TGVuZ3RoOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGVuZ3RoUG9pbnRzKCk7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gMDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDEpIHJldHVybiAwOyAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludFxuXG4gICAgICAgIHZhciBjcExlbmd0aDtcbiAgICAgICAgdmFyIG1pblNxckRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgICB2YXIgbiA9IG51bVBvaW50cyAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZS5sZW5ndGgoKTtcblxuICAgICAgICAgICAgdmFyIGNwTm9ybWFsaXplZExlbmd0aCA9IGxpbmUuY2xvc2VzdFBvaW50Tm9ybWFsaXplZExlbmd0aChwKTtcbiAgICAgICAgICAgIHZhciBjcCA9IGxpbmUucG9pbnRBdChjcE5vcm1hbGl6ZWRMZW5ndGgpO1xuXG4gICAgICAgICAgICB2YXIgc3FyRGlzdGFuY2UgPSBjcC5zcXVhcmVkRGlzdGFuY2UocCk7XG4gICAgICAgICAgICBpZiAoc3FyRGlzdGFuY2UgPCBtaW5TcXJEaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIG1pblNxckRpc3RhbmNlID0gc3FyRGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgY3BMZW5ndGggPSBsZW5ndGggKyAoY3BOb3JtYWxpemVkTGVuZ3RoICogbGluZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbmd0aCArPSBsaW5lTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNwTGVuZ3RoO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnROb3JtYWxpemVkTGVuZ3RoOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCk7XG4gICAgICAgIGlmIChjcExlbmd0aCA9PT0gMCkgcmV0dXJuIDA7IC8vIHNob3J0Y3V0XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBwcmV2ZW50cyBkaXZpc2lvbiBieSB6ZXJvXG5cbiAgICAgICAgcmV0dXJuIGNwTGVuZ3RoIC8gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICBjbG9zZXN0UG9pbnRUYW5nZW50OiBmdW5jdGlvbihwKSB7XG5cbiAgICAgICAgdmFyIGNwTGVuZ3RoID0gdGhpcy5jbG9zZXN0UG9pbnRMZW5ndGgocCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudGFuZ2VudEF0TGVuZ3RoKGNwTGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZWEgc3Vycm91bmRlZCBieSB0aGUgcG9seWxpbmUgY29udGFpbnMgdGhlIHBvaW50IGBwYC5cbiAgICAvLyBJbXBsZW1lbnRzIHRoZSBldmVuLW9kZCBTVkcgYWxnb3JpdGhtIChzZWxmLWludGVyc2VjdGlvbnMgYXJlIFwib3V0c2lkZVwiKS5cbiAgICAvLyAoVXNlcyBob3Jpem9udGFsIHJheXMgdG8gdGhlIHJpZ2h0IG9mIGBwYCB0byBsb29rIGZvciBpbnRlcnNlY3Rpb25zLilcbiAgICAvLyBDbG9zZXMgb3BlbiBwb2x5bGluZXMgKGFsd2F5cyBpbWFnaW5lcyBhIGZpbmFsIGNsb3Npbmcgc2VnbWVudCkuXG4gICAgY29udGFpbnNQb2ludDogZnVuY3Rpb24ocCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBmYWxzZTsgLy8gc2hvcnRjdXQgKHRoaXMgcG9seWxpbmUgaGFzIG5vIHBvaW50cylcblxuICAgICAgICB2YXIgeCA9IHAueDtcbiAgICAgICAgdmFyIHkgPSBwLnk7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBhIGZpbmFsIGNsb3Npbmcgc2VnbWVudCBieSBjcmVhdGluZyBvbmUgZnJvbSBsYXN0LWZpcnN0IHBvaW50cyBvbiBwb2x5bGluZVxuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IG51bVBvaW50cyAtIDE7IC8vIHN0YXJ0IG9mIGN1cnJlbnQgcG9seWxpbmUgc2VnbWVudFxuICAgICAgICB2YXIgZW5kSW5kZXggPSAwOyAvLyBlbmQgb2YgY3VycmVudCBwb2x5bGluZSBzZWdtZW50XG4gICAgICAgIHZhciBudW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBuZXcgTGluZSgpO1xuICAgICAgICB2YXIgcmF5ID0gbmV3IExpbmUoKTtcbiAgICAgICAgdmFyIHJheUVuZCA9IG5ldyBQb2ludCgpO1xuICAgICAgICBmb3IgKDsgZW5kSW5kZXggPCBudW1Qb2ludHM7IGVuZEluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBvaW50c1tzdGFydEluZGV4XTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwb2ludHNbZW5kSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHAuZXF1YWxzKHN0YXJ0KSkgcmV0dXJuIHRydWU7IC8vIHNob3J0Y3V0IChgcGAgaXMgYSBwb2ludCBvbiBwb2x5bGluZSlcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9seWxpbmUgc2VnbWVudFxuICAgICAgICAgICAgc2VnbWVudC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgc2VnbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICBpZiAoc2VnbWVudC5jb250YWluc1BvaW50KHApKSByZXR1cm4gdHJ1ZTsgLy8gc2hvcnRjdXQgKGBwYCBsaWVzIG9uIGEgcG9seWxpbmUgc2VnbWVudClcblxuICAgICAgICAgICAgLy8gZG8gd2UgaGF2ZSBhbiBpbnRlcnNlY3Rpb24/XG4gICAgICAgICAgICBpZiAoKCh5IDw9IHN0YXJ0LnkpICYmICh5ID4gZW5kLnkpKSB8fCAoKHkgPiBzdGFydC55KSAmJiAoeSA8PSBlbmQueSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb25kaXRpb25hbCBicmFuY2ggSVMgTk9UIGVudGVyZWQgd2hlbiBgc2VnbWVudGAgaXMgY29sbGluZWFyL2NvaW5jaWRlbnQgd2l0aCBgcmF5YFxuICAgICAgICAgICAgICAgIC8vICh3aGVuIGB5ID09PSBzdGFydC55ID09PSBlbmQueWApXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb25kaXRpb25hbCBicmFuY2ggSVMgZW50ZXJlZCB3aGVuIGBzZWdtZW50YCB0b3VjaGVzIGByYXlgIGF0IG9ubHkgb25lIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gd2hlbiBgeSA9PT0gc3RhcnQueSAhPT0gZW5kLnlgKVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoaXMgYnJhbmNoIGlzIGVudGVyZWQgYWdhaW4gZm9yIHRoZSBmb2xsb3dpbmcgc2VnbWVudCwgdGhlIHR3byB0b3VjaGVzIGNhbmNlbCBvdXRcblxuICAgICAgICAgICAgICAgIHZhciB4RGlmZmVyZW5jZSA9ICgoKHN0YXJ0LnggLSB4KSA+IChlbmQueCAtIHgpKSA/IChzdGFydC54IC0geCkgOiAoZW5kLnggLSB4KSk7XG4gICAgICAgICAgICAgICAgaWYgKHhEaWZmZXJlbmNlID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VnbWVudCBsaWVzIGF0IGxlYXN0IHBhcnRpYWxseSB0byB0aGUgcmlnaHQgb2YgYHBgXG4gICAgICAgICAgICAgICAgICAgIHJheUVuZC54ID0geCArIHhEaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICByYXlFbmQueSA9IHk7IC8vIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIHJheS5zdGFydCA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHJheS5lbmQgPSByYXlFbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LmludGVyc2VjdChyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBpbnRlcnNlY3Rpb24gd2FzIGRldGVjdGVkIHRvIHRoZSByaWdodCBvZiBgcGBcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bUludGVyc2VjdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZTogYHNlZ21lbnRgIGxpZXMgY29tcGxldGVseSB0byB0aGUgbGVmdCBvZiBgcGAgKGkuZS4gbm8gaW50ZXJzZWN0aW9uIHRvIHRoZSByaWdodClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbW92ZSB0byBjaGVjayB0aGUgbmV4dCBwb2x5bGluZSBzZWdtZW50XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gZW5kSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm5zIGB0cnVlYCBmb3Igb2RkIG51bWJlcnMgb2YgaW50ZXJzZWN0aW9ucyAoZXZlbi1vZGQgYWxnb3JpdGhtKVxuICAgICAgICByZXR1cm4gKChudW1JbnRlcnNlY3Rpb25zICUgMikgPT09IDEpO1xuICAgIH0sXG5cbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgcG9pbnRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc3RhcnQgJiYgZW5kICYmICFzdGFydC5lcXVhbHMoZW5kKSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnQuY2xvbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGxlbmd0aFBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICB9LFxuXG4gICAgY29udmV4SHVsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmUoY29udmV4SHVsbCh0aGlzLnBvaW50cykpO1xuICAgIH0sXG5cbiAgICAvLyBDaGVja3Mgd2hldGhlciB0d28gcG9seWxpbmVzIGFyZSBleGFjdGx5IHRoZSBzYW1lLlxuICAgIC8vIElmIGBwYCBpcyB1bmRlZmluZWQgb3IgbnVsbCwgcmV0dXJucyBmYWxzZS5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgICBpZiAoIXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBvdGhlclBvaW50cyA9IHAucG9pbnRzO1xuXG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAob3RoZXJQb2ludHMubGVuZ3RoICE9PSBudW1Qb2ludHMpIHJldHVybiBmYWxzZTsgLy8gaWYgdGhlIHR3byBwb2x5bGluZXMgaGF2ZSBkaWZmZXJlbnQgbnVtYmVyIG9mIHBvaW50cywgdGhleSBjYW5ub3QgYmUgZXF1YWxcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciBvdGhlclBvaW50ID0gcC5wb2ludHNbaV07XG5cbiAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgYW4gaW5lcXVhbGl0eSBpcyBmb3VuZCBpbiBwb2ludHMsIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgaWYgKCFwb2ludC5lcXVhbHMob3RoZXJQb2ludCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGluZXF1YWxpdHkgZm91bmQgaW4gcG9pbnRzLCByZXR1cm4gdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmU6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZShsKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGVuZ3RoUG9pbnRzKCk7XG4gICAgICAgIHZhciBsMiA9IG5ldyBMaW5lKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGwyLnN0YXJ0ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbDIuZW5kID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBpbnQgPSBsaW5lLmludGVyc2VjdGlvbldpdGhMaW5lKGwyKTtcbiAgICAgICAgICAgIGlmIChpbnQpIGludGVyc2VjdGlvbnMucHVzaChpbnRbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSA/IGludGVyc2VjdGlvbnMgOiBudWxsO1xuICAgIH0sXG5cbiAgICBpc0RpZmZlcmVudGlhYmxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSgpO1xuICAgICAgICB2YXIgbiA9IG51bVBvaW50cyAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsaW5lLnN0YXJ0ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgbGluZS5lbmQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgICAgLy8gYXMgc29vbiBhcyBhIGRpZmZlcmVudGlhYmxlIGxpbmUgaXMgZm91bmQgYmV0d2VlbiB0d28gcG9pbnRzLCByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgaWYgKGxpbmUuaXNEaWZmZXJlbnRpYWJsZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGRpZmZlcmVudGlhYmxlIGxpbmUgaXMgZm91bmQgYmV0d2VlbiBwYWlycyBvZiBwb2ludHMsIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGVuZ3RoUG9pbnRzKCk7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gMDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgIHZhciBuID0gbnVtUG9pbnRzIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBwb2ludHNbaV0uZGlzdGFuY2UocG9pbnRzW2kgKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0sXG5cbiAgICBwb2ludEF0OiBmdW5jdGlvbihyYXRpbykge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gcG9pbnRzWzBdLmNsb25lKCk7IC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIHBvaW50XG5cbiAgICAgICAgaWYgKHJhdGlvIDw9IDApIHJldHVybiBwb2ludHNbMF0uY2xvbmUoKTtcbiAgICAgICAgaWYgKHJhdGlvID49IDEpIHJldHVybiBwb2ludHNbbnVtUG9pbnRzIC0gMV0uY2xvbmUoKTtcblxuICAgICAgICB2YXIgcG9seWxpbmVMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcG9seWxpbmVMZW5ndGggKiByYXRpbztcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludEF0TGVuZ3RoKGxlbmd0aCk7XG4gICAgfSxcblxuICAgIHBvaW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gcG9pbnRzWzBdLmNsb25lKCk7IC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIHBvaW50XG5cbiAgICAgICAgdmFyIGZyb21TdGFydCA9IHRydWU7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgICBmcm9tU3RhcnQgPSBmYWxzZTsgLy8gbmVnYXRpdmUgbGVuZ3RocyBtZWFuIHN0YXJ0IGNhbGN1bGF0aW9uIGZyb20gZW5kIHBvaW50XG4gICAgICAgICAgICBsZW5ndGggPSAtbGVuZ3RoOyAvLyBhYnNvbHV0ZSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICB2YXIgbiA9IG51bVBvaW50cyAtIDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAoZnJvbVN0YXJ0ID8gaSA6IChuIC0gMSAtIGkpKTtcblxuICAgICAgICAgICAgdmFyIGEgPSBwb2ludHNbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGIgPSBwb2ludHNbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbmV3IExpbmUoYSwgYik7XG4gICAgICAgICAgICB2YXIgZCA9IGEuZGlzdGFuY2UoYik7XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gKGwgKyBkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnBvaW50QXRMZW5ndGgoKGZyb21TdGFydCA/IDEgOiAtMSkgKiAobGVuZ3RoIC0gbCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsICs9IGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZW5ndGggcmVxdWVzdGVkIGlzIGhpZ2hlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIHBvbHlsaW5lLCByZXR1cm4gbGFzdCBlbmRwb2ludFxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gKGZyb21TdGFydCA/IHBvaW50c1tudW1Qb2ludHMgLSAxXSA6IHBvaW50c1swXSk7XG4gICAgICAgIHJldHVybiBsYXN0UG9pbnQuY2xvbmUoKTtcbiAgICB9LFxuXG4gICAgcm91bmQ6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzW2ldLnJvdW5kKHByZWNpc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSwgb3JpZ2luKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHNbaV0uc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNpbXBsaWZ5OiBmdW5jdGlvbihvcHQgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDMpIHJldHVybiB0aGlzOyAvLyB3ZSBuZWVkIGF0IGxlYXN0IDMgcG9pbnRzXG5cbiAgICAgICAgLy8gVE9ETzogd2UgbWF5IGFsc28gYWNjZXB0IHN0YXJ0SW5kZXggYW5kIGVuZEluZGV4IHRvIHNwZWNpZnkgd2hlcmUgdG8gc3RhcnQgYW5kIGVuZCBzaW1wbGlmaWNhdGlvblxuXG4gICAgICAgIC8vIER1ZSB0byB0aGUgbmF0dXJlIG9mIHRoZSBhbGdvcml0aG0sIHdlIGRvIG5vdCB1c2UgMCBhcyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgYHRocmVzaG9sZGBcbiAgICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgcm91bmRpbmcgZXJyb3JzIHRoYXQgY2FuIG9jY3VyIHdoZW4gY29tcGFyaW5nIGRpc3RhbmNlcy5cbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0LnRocmVzaG9sZCB8fCAxZS0xMDsgLy8gPSBtYXggZGlzdGFuY2Ugb2YgbWlkZGxlIHBvaW50IGZyb20gY2hvcmQgdG8gYmUgc2ltcGxpZmllZFxuXG4gICAgICAgIC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBvbHlsaW5lIGFuZCBnbyBmb3J3YXJkXG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAvLyB3ZSBuZWVkIGF0IGxlYXN0IG9uZSBpbnRlcm1lZGlhdGUgcG9pbnQgKDMgcG9pbnRzKSBpbiBldmVyeSBpdGVyYXRpb25cbiAgICAgICAgLy8gYXMgc29vbiBhcyB0aGF0IHN0b3BzIGJlaW5nIHRydWUsIHdlIGtub3cgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBwb2x5bGluZVxuICAgICAgICB3aGlsZSAocG9pbnRzW2N1cnJlbnRJbmRleCArIDJdKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEluZGV4ID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlSW5kZXggPSAoY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMik7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbZmlyc3RJbmRleF07XG4gICAgICAgICAgICBjb25zdCBtaWRkbGVQb2ludCA9IHBvaW50c1ttaWRkbGVJbmRleF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBwb2ludHNbbGFzdEluZGV4XTtcblxuICAgICAgICAgICAgY29uc3QgY2hvcmQgPSBuZXcgTGluZShmaXJzdFBvaW50LCBsYXN0UG9pbnQpOyAvLyA9IGNvbm5lY3Rpb24gYmV0d2VlbiBmaXJzdCBhbmQgbGFzdCBwb2ludFxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50ID0gY2hvcmQuY2xvc2VzdFBvaW50KG1pZGRsZVBvaW50KTsgLy8gPSBjbG9zZXN0IHBvaW50IG9uIGNob3JkIGZyb20gbWlkZGxlIHBvaW50XG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0UG9pbnREaXN0YW5jZSA9IGNsb3Nlc3RQb2ludC5kaXN0YW5jZShtaWRkbGVQb2ludCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdFBvaW50RGlzdGFuY2UgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgLy8gbWlkZGxlIHBvaW50IGlzIGNsb3NlIGVub3VnaCB0byB0aGUgY2hvcmQgPSBzaW1wbGlmeVxuICAgICAgICAgICAgICAgIC8vIDEpIHJlbW92ZSBtaWRkbGUgcG9pbnQ6XG4gICAgICAgICAgICAgICAgcG9pbnRzLnNwbGljZShtaWRkbGVJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgLy8gMikgaW4gbmV4dCBpdGVyYXRpb24sIGludmVzdGlnYXRlIHRoZSBuZXdseS1jcmVhdGVkIHRyaXBsZXQgb2YgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gICAgLSBkbyBub3QgY2hhbmdlIGBjdXJyZW50SW5kZXhgXG4gICAgICAgICAgICAgICAgLy8gICAgPSAoZmlyc3QgcG9pbnQgc3RheXMsIHBvaW50IGFmdGVyIHJlbW92ZWQgcG9pbnQgYmVjb21lcyBtaWRkbGUgcG9pbnQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1pZGRsZSBwb2ludCBpcyBmYXIgZnJvbSB0aGUgY2hvcmRcbiAgICAgICAgICAgICAgICAvLyAxKSBwcmVzZXJ2ZSBtaWRkbGUgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyAyKSBpbiBuZXh0IGl0ZXJhdGlvbiwgbW92ZSBgY3VycmVudEluZGV4YCBieSBvbmUgc3RlcDpcbiAgICAgICAgICAgICAgICBjdXJyZW50SW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAvLyAgICA9IChwb2ludCBhZnRlciBmaXJzdCBwb2ludCBiZWNvbWVzIGZpcnN0IHBvaW50KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYHBvaW50c2AgYXJyYXkgd2FzIG1vZGlmaWVkIGluLXBsYWNlXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXQ6IGZ1bmN0aW9uKHJhdGlvKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMubGVuZ3RoUG9pbnRzKCk7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAwKSByZXR1cm4gbnVsbDsgLy8gaWYgcG9pbnRzIGFycmF5IGlzIGVtcHR5XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDEpIHJldHVybiBudWxsOyAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBwb2ludFxuXG4gICAgICAgIGlmIChyYXRpbyA8IDApIHJhdGlvID0gMDtcbiAgICAgICAgaWYgKHJhdGlvID4gMSkgcmF0aW8gPSAxO1xuXG4gICAgICAgIHZhciBwb2x5bGluZUxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwb2x5bGluZUxlbmd0aCAqIHJhdGlvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnRhbmdlbnRBdExlbmd0aChsZW5ndGgpO1xuICAgIH0sXG5cbiAgICB0YW5nZW50QXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmxlbmd0aFBvaW50cygpO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuICAgICAgICBpZiAobnVtUG9pbnRzID09PSAxKSByZXR1cm4gbnVsbDsgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnRcblxuICAgICAgICB2YXIgZnJvbVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIGZyb21TdGFydCA9IGZhbHNlOyAvLyBuZWdhdGl2ZSBsZW5ndGhzIG1lYW4gc3RhcnQgY2FsY3VsYXRpb24gZnJvbSBlbmQgcG9pbnRcbiAgICAgICAgICAgIGxlbmd0aCA9IC1sZW5ndGg7IC8vIGFic29sdXRlIHZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdFZhbGlkTGluZTsgLy8gZGlmZmVyZW50aWFibGUgKHdpdGggYSB0YW5nZW50KVxuICAgICAgICB2YXIgbCA9IDA7IC8vIGxlbmd0aCBzbyBmYXJcbiAgICAgICAgdmFyIG4gPSBudW1Qb2ludHMgLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gKGZyb21TdGFydCA/IGkgOiAobiAtIDEgLSBpKSk7XG5cbiAgICAgICAgICAgIHZhciBhID0gcG9pbnRzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBiID0gcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKGEsIGIpO1xuICAgICAgICAgICAgdmFyIGQgPSBhLmRpc3RhbmNlKGIpO1xuXG4gICAgICAgICAgICBpZiAobGluZS5pc0RpZmZlcmVudGlhYmxlKCkpIHsgLy8gaGFzIGEgdGFuZ2VudCBsaW5lIChsaW5lIGxlbmd0aCBpcyBub3QgMClcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDw9IChsICsgZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUudGFuZ2VudEF0TGVuZ3RoKChmcm9tU3RhcnQgPyAxIDogLTEpICogKGxlbmd0aCAtIGwpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0VmFsaWRMaW5lID0gbGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbCArPSBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbGVuZ3RoIHJlcXVlc3RlZCBpcyBoaWdoZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBwb2x5bGluZSwgcmV0dXJuIGxhc3QgdmFsaWQgZW5kcG9pbnRcbiAgICAgICAgaWYgKGxhc3RWYWxpZExpbmUpIHtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IChmcm9tU3RhcnQgPyAxIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gbGFzdFZhbGlkTGluZS50YW5nZW50QXQocmF0aW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm8gdmFsaWQgbGluZSwgcmV0dXJuIG51bGxcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHMgKyAnJztcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih0eCwgdHkpIHtcblxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIHZhciBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50c1tpXS50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gc3ZnU3RyaW5nIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVjcmVhdGUgdGhpcyBsaW5lLlxuICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuICcnOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcblxuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgb3V0cHV0ICs9IHBvaW50LnggKyAnLCcgKyBwb2ludC55ICsgJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dC50cmltKCk7XG4gICAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvbHlsaW5lLnByb3RvdHlwZSwgJ3N0YXJ0Jywge1xuICAgIC8vIEdldHRlciBmb3IgdGhlIGZpcnN0IHBvaW50IG9mIHRoZSBwb2x5bGluZS5cblxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgdmFyIG51bVBvaW50cyA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1Qb2ludHMgPT09IDApIHJldHVybiBudWxsOyAvLyBpZiBwb2ludHMgYXJyYXkgaXMgZW1wdHlcblxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHNbMF07XG4gICAgfSxcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUG9seWxpbmUucHJvdG90eXBlLCAnZW5kJywge1xuICAgIC8vIEdldHRlciBmb3IgdGhlIGxhc3QgcG9pbnQgb2YgdGhlIHBvbHlsaW5lLlxuXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICB2YXIgbnVtUG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG51bVBvaW50cyA9PT0gMCkgcmV0dXJuIG51bGw7IC8vIGlmIHBvaW50cyBhcnJheSBpcyBlbXB0eVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50c1tudW1Qb2ludHMgLSAxXTtcbiAgICB9LFxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs":
/*!*************************************************!*\
  !*** ./node_modules/@joint/core/src/g/rect.mjs ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rect: function() { return /* binding */ Rect; },\n/* harmony export */   rect: function() { return /* binding */ rect; }\n/* harmony export */ });\n/* harmony import */ var _geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry.helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _point_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _ellipse_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ellipse.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _types_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\");\n\n\n\n\n\n\nconst {\n    abs,\n    cos,\n    sin,\n    min,\n    max,\n    round,\n    pow\n} = Math;\n\nconst Rect = function(x, y, w, h) {\n\n    if (!(this instanceof Rect)) {\n        return new Rect(x, y, w, h);\n    }\n\n    if ((Object(x) === x)) {\n        y = x.y;\n        w = x.width;\n        h = x.height;\n        x = x.x;\n    }\n\n    this.x = x === undefined ? 0 : x;\n    this.y = y === undefined ? 0 : y;\n    this.width = w === undefined ? 0 : w;\n    this.height = h === undefined ? 0 : h;\n};\n\nRect.fromEllipse = function(e) {\n\n    e = new _ellipse_mjs__WEBPACK_IMPORTED_MODULE_0__.Ellipse(e);\n    return new Rect(e.x - e.a, e.y - e.b, 2 * e.a, 2 * e.b);\n};\n\nRect.fromPointUnion = function(...points) {\n\n    if (points.length === 0) return null;\n\n    const p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < points.length; i++) {\n        p.update(points[i]);\n        const x = p.x;\n        const y = p.y;\n\n        if (x < minX) minX = x;\n        if (x > maxX) maxX = x;\n        if (y < minY) minY = y;\n        if (y > maxY) maxY = y;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.fromRectUnion = function(...rects) {\n\n    if (rects.length === 0) return null;\n\n    const r = new Rect();\n    let minX, minY, maxX, maxY;\n    minX = minY = Infinity;\n    maxX = maxY = -Infinity;\n\n    for (let i = 0; i < rects.length; i++) {\n        r.update(rects[i]);\n        const x = r.x;\n        const y = r.y;\n        const mX = x + r.width;\n        const mY = y + r.height;\n\n        if (x < minX) minX = x;\n        if (mX > maxX) maxX = mX;\n        if (y < minY) minY = y;\n        if (mY > maxY) maxY = mY;\n    }\n\n    return new Rect(minX, minY, maxX - minX, maxY - minY);\n};\n\nRect.prototype = {\n\n    type: _types_mjs__WEBPACK_IMPORTED_MODULE_2__.types.Rect,\n\n    // Find my bounding box when I'm rotated with the center of rotation in the center of me.\n    // @return r {rectangle} representing a bounding box\n    bbox: function(angle) {\n        return this.clone().rotateAroundCenter(angle);\n    },\n\n    rotateAroundCenter: function(angle) {\n        if (!angle) return this;\n        const { width, height } = this;\n        const theta = (0,_geometry_helpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toRad)(angle);\n        const st = abs(sin(theta));\n        const ct = abs(cos(theta));\n        const w = width * ct + height * st;\n        const h = width * st + height * ct;\n        this.x += (width - w) / 2;\n        this.y += (height - h) / 2;\n        this.width = w;\n        this.height = h;\n        return this;\n    },\n\n    bottomLeft: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y + this.height);\n    },\n\n    bottomLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.bottomLeft(), this.bottomRight());\n    },\n\n    bottomMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height);\n    },\n\n    center: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height / 2);\n    },\n\n    clone: function() {\n\n        return new Rect(this);\n    },\n\n    // @return {bool} true if point p is inside me.\n    // @param {bool} strict If true, the point has to be strictly inside (not on the border).\n    containsPoint: function(p, opt) {\n        let x, y;\n        if (!p || (typeof p === 'string')) {\n            // Backwards compatibility: if the point is not provided,\n            // the point is considered to be the origin [0, 0].\n            ({ x, y } = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(p));\n        } else {\n            // Do not create a new Point object if the point is already a Point-like object.\n            ({ x = 0, y = 0 } = p);\n        }\n        return opt && opt.strict\n            ? (x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height)\n            : x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n    },\n\n    // @return {bool} true if rectangle `r` is inside me.\n    containsRect: function(r) {\n\n        var r0 = new Rect(this).normalize();\n        var r1 = new Rect(r).normalize();\n        var w0 = r0.width;\n        var h0 = r0.height;\n        var w1 = r1.width;\n        var h1 = r1.height;\n\n        if (!w0 || !h0 || !w1 || !h1) {\n            // At least one of the dimensions is 0\n            return false;\n        }\n\n        var x0 = r0.x;\n        var y0 = r0.y;\n        var x1 = r1.x;\n        var y1 = r1.y;\n\n        w1 += x1;\n        w0 += x0;\n        h1 += y1;\n        h0 += y0;\n\n        return x0 <= x1 && w1 <= w0 && y0 <= y1 && h1 <= h0;\n    },\n\n    corner: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y + this.height);\n    },\n\n    // @return {boolean} true if rectangles are equal.\n    equals: function(r) {\n\n        var mr = (new Rect(this)).normalize();\n        var nr = (new Rect(r)).normalize();\n        return mr.x === nr.x && mr.y === nr.y && mr.width === nr.width && mr.height === nr.height;\n    },\n\n    // inflate by dx and dy, recompute origin [x, y]\n    // @param dx {delta_x} representing additional size to x\n    // @param dy {delta_y} representing additional size to y -\n    // dy param is not required -> in that case y is sized by dx\n    inflate: function(dx, dy) {\n\n        if (dx === undefined) {\n            dx = 0;\n        }\n\n        if (dy === undefined) {\n            dy = dx;\n        }\n\n        this.x -= dx;\n        this.y -= dy;\n        this.width += 2 * dx;\n        this.height += 2 * dy;\n\n        return this;\n    },\n\n    // @return {rect} if rectangles intersect, {null} if not.\n    intersect: function(r) {\n\n        var myOrigin = this.origin();\n        var myCorner = this.corner();\n        var rOrigin = r.origin();\n        var rCorner = r.corner();\n\n        // No intersection found\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) return null;\n\n        var x = max(myOrigin.x, rOrigin.x);\n        var y = max(myOrigin.y, rOrigin.y);\n\n        return new Rect(x, y, min(myCorner.x, rCorner.x) - x, min(myCorner.y, rCorner.y) - y);\n    },\n\n    intersectionWithLine: function(line) {\n\n        var r = this;\n        var rectLines = [r.topLine(), r.rightLine(), r.bottomLine(), r.leftLine()];\n        var points = [];\n        var dedupeArr = [];\n        var pt, i;\n\n        var n = rectLines.length;\n        for (i = 0; i < n; i++) {\n\n            pt = line.intersect(rectLines[i]);\n            if (pt !== null && dedupeArr.indexOf(pt.toString()) < 0) {\n                points.push(pt);\n                dedupeArr.push(pt.toString());\n            }\n        }\n\n        return points.length > 0 ? points : null;\n    },\n\n    // Find point on my boundary where line starting\n    // from my center ending in point p intersects me.\n    // @param {number} angle If angle is specified, intersection with rotated rectangle is computed.\n    intersectionWithLineFromCenterToPoint: function(p, angle) {\n\n        p = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(p);\n        var center = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y + this.height / 2);\n        var result;\n\n        if (angle) p.rotate(center, angle);\n\n        // (clockwise, starting from the top side)\n        var sides = [\n            this.topLine(),\n            this.rightLine(),\n            this.bottomLine(),\n            this.leftLine()\n        ];\n        var connector = new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(center, p);\n\n        for (var i = sides.length - 1; i >= 0; --i) {\n            var intersection = sides[i].intersection(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle) result.rotate(center, -angle);\n        return result;\n    },\n\n    leftLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topLeft(), this.bottomLeft());\n    },\n\n    leftMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y + this.height / 2);\n    },\n\n    maxRectScaleToFit: function(rect, origin) {\n\n        rect = new Rect(rect);\n        origin || (origin = rect.center());\n\n        var sx1, sx2, sx3, sx4, sy1, sy2, sy3, sy4;\n        var ox = origin.x;\n        var oy = origin.y;\n\n        // Here we find the maximal possible scale for all corner points (for x and y axis) of the rectangle,\n        // so when the scale is applied the point is still inside the rectangle.\n\n        sx1 = sx2 = sx3 = sx4 = sy1 = sy2 = sy3 = sy4 = Infinity;\n\n        // Top Left\n        var p1 = rect.topLeft();\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        var p2 = rect.bottomRight();\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        var p3 = rect.topRight();\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        var p4 = rect.bottomLeft();\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n\n        return {\n            sx: min(sx1, sx2, sx3, sx4),\n            sy: min(sy1, sy2, sy3, sy4)\n        };\n    },\n\n    maxRectUniformScaleToFit: function(rect, origin) {\n\n        var scale = this.maxRectScaleToFit(rect, origin);\n        return min(scale.sx, scale.sy);\n    },\n\n    // Move and expand me.\n    // @param r {rectangle} representing deltas\n    moveAndExpand: function(r) {\n\n        this.x += r.x || 0;\n        this.y += r.y || 0;\n        this.width += r.width || 0;\n        this.height += r.height || 0;\n        return this;\n    },\n\n    // Normalize the rectangle; i.e., make it so that it has a non-negative width and height.\n    // If width < 0 the function swaps the left and right corners,\n    // and it swaps the top and bottom corners if height < 0\n    // like in http://qt-project.org/doc/qt-4.8/qrectf.html#normalized\n    normalize: function() {\n\n        var newx = this.x;\n        var newy = this.y;\n        var newwidth = this.width;\n        var newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    },\n\n    // Offset me by the specified amount.\n    offset: function(dx, dy) {\n\n        // pretend that this is a point and call offset()\n        // rewrites x and y according to dx and dy\n        return _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.prototype.offset.call(this, dx, dy);\n    },\n\n    origin: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, this.y);\n    },\n\n    // @return {point} a point on my boundary nearest to the given point.\n    // @see Squeak Smalltalk, Rectangle>>pointNearestTo:\n    pointNearestToPoint: function(point) {\n\n        point = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point);\n        if (this.containsPoint(point)) {\n            var side = this.sideNearestToPoint(point);\n            switch (side) {\n                case 'right':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, point.y);\n                case 'left':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x, point.y);\n                case 'bottom':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, this.y + this.height);\n                case 'top':\n                    return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point.x, this.y);\n            }\n        }\n        return point.adhereToRect(this);\n    },\n\n    rightLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topRight(), this.bottomRight());\n    },\n\n    rightMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y + this.height / 2);\n    },\n\n    round: function(precision) {\n\n        let f = 1; // case 0\n        if (precision) {\n            switch (precision) {\n                case 1: f = 10; break;\n                case 2: f = 100; break;\n                case 3: f = 1000; break;\n                default: f = pow(10, precision); break;\n            }\n        }\n\n        this.x = round(this.x * f) / f;\n        this.y = round(this.y * f) / f;\n        this.width = round(this.width * f) / f;\n        this.height = round(this.height * f) / f;\n        return this;\n    },\n\n    // Scale rectangle with origin.\n    scale: function(sx, sy, origin) {\n\n        origin = this.origin().scale(sx, sy, origin);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    },\n\n    // @return {string} (left|right|top|bottom) side which is nearest to point\n    // @see Squeak Smalltalk, Rectangle>>sideNearestTo:\n    sideNearestToPoint: function(point) {\n\n        point = new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(point);\n        var distToLeft = point.x - this.x;\n        var distToRight = (this.x + this.width) - point.x;\n        var distToTop = point.y - this.y;\n        var distToBottom = (this.y + this.height) - point.y;\n        var closest = distToLeft;\n        var side = 'left';\n\n        if (distToRight < closest) {\n            closest = distToRight;\n            side = 'right';\n        }\n        if (distToTop < closest) {\n            closest = distToTop;\n            side = 'top';\n        }\n        if (distToBottom < closest) {\n            // closest = distToBottom;\n            side = 'bottom';\n        }\n        return side;\n    },\n\n    snapToGrid: function(gx, gy) {\n\n        var origin = this.origin().snapToGrid(gx, gy);\n        var corner = this.corner().snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    },\n\n    toJSON: function() {\n\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    },\n\n    topLine: function() {\n\n        return new _line_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(this.topLeft(), this.topRight());\n    },\n\n    topMiddle: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width / 2, this.y);\n    },\n\n    topRight: function() {\n\n        return new _point_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(this.x + this.width, this.y);\n    },\n\n    toString: function() {\n\n        return this.origin().toString() + ' ' + this.corner().toString();\n    },\n\n    // @return {rect} representing the union of both rectangles.\n    union: function(rect) {\n\n        return Rect.fromRectUnion(this, rect);\n    },\n\n    update: function(x, y, w, h) {\n\n        if ((Object(x) === x)) {\n            y = x.y;\n            w = x.width;\n            h = x.height;\n            x = x.x;\n        }\n\n        this.x = x || 0;\n        this.y = y || 0;\n        this.width = w || 0;\n        this.height = h || 0;\n        return this;\n    }\n};\n\nRect.prototype.bottomRight = Rect.prototype.corner;\n\nRect.prototype.topLeft = Rect.prototype.origin;\n\nRect.prototype.translate = Rect.prototype.offset;\n\n// For backwards compatibility:\nconst rect = Rect;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9yZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStDO0FBQ2I7QUFDRTtBQUNJO0FBQ0o7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVLOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLGlEQUFPO0FBQ25CO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCLDZDQUFLO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLDZDQUFLOztBQUVmO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsc0JBQXNCLDREQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDJDQUFJO0FBQ3ZCLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCLEtBQUs7O0FBRUw7O0FBRUEsbUJBQW1CLDZDQUFLO0FBQ3hCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxLQUFLOztBQUVMLGdCQUFnQixNQUFNO0FBQ3RCLGVBQWUs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QUNoQyxpQ0FBaUM7QUFDakMsa0NBQWtDO0FBQ2xDLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBLG9CQUFvQiw2Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxpQkFBaUI7QUFDakIsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUIsMkNBQUk7QUFDdkIsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUIsNkNBQUs7QUFDeEIsS0FBSzs7QUFFTDs7QUFFQSxtQkFBbUIsNkNBQUs7QUFDeEIsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEtBQUs7O0FBRUwsZ0JBQWdCLE1BQU07QUFDdEI7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy9yZWN0Lm1qcz85Y2Q4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvUmFkIH0gZnJvbSAnLi9nZW9tZXRyeS5oZWxwZXJzLm1qcyc7XG5pbXBvcnQgeyBMaW5lIH0gZnJvbSAnLi9saW5lLm1qcyc7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4vcG9pbnQubWpzJztcbmltcG9ydCB7IEVsbGlwc2UgfSBmcm9tICcuL2VsbGlwc2UubWpzJztcbmltcG9ydCB7IHR5cGVzIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuXG5jb25zdCB7XG4gICAgYWJzLFxuICAgIGNvcyxcbiAgICBzaW4sXG4gICAgbWluLFxuICAgIG1heCxcbiAgICByb3VuZCxcbiAgICBwb3dcbn0gPSBNYXRoO1xuXG5leHBvcnQgY29uc3QgUmVjdCA9IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWN0KSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYgKChPYmplY3QoeCkgPT09IHgpKSB7XG4gICAgICAgIHkgPSB4Lnk7XG4gICAgICAgIHcgPSB4LndpZHRoO1xuICAgICAgICBoID0geC5oZWlnaHQ7XG4gICAgICAgIHggPSB4Lng7XG4gICAgfVxuXG4gICAgdGhpcy54ID0geCA9PT0gdW5kZWZpbmVkID8gMCA6IHg7XG4gICAgdGhpcy55ID0geSA9PT0gdW5kZWZpbmVkID8gMCA6IHk7XG4gICAgdGhpcy53aWR0aCA9IHcgPT09IHVuZGVmaW5lZCA/IDAgOiB3O1xuICAgIHRoaXMuaGVpZ2h0ID0gaCA9PT0gdW5kZWZpbmVkID8gMCA6IGg7XG59O1xuXG5SZWN0LmZyb21FbGxpcHNlID0gZnVuY3Rpb24oZSkge1xuXG4gICAgZSA9IG5ldyBFbGxpcHNlKGUpO1xuICAgIHJldHVybiBuZXcgUmVjdChlLnggLSBlLmEsIGUueSAtIGUuYiwgMiAqIGUuYSwgMiAqIGUuYik7XG59O1xuXG5SZWN0LmZyb21Qb2ludFVuaW9uID0gZnVuY3Rpb24oLi4ucG9pbnRzKSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBwID0gbmV3IFBvaW50KCk7XG4gICAgbGV0IG1pblgsIG1pblksIG1heFgsIG1heFk7XG4gICAgbWluWCA9IG1pblkgPSBJbmZpbml0eTtcbiAgICBtYXhYID0gbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHAudXBkYXRlKHBvaW50c1tpXSk7XG4gICAgICAgIGNvbnN0IHggPSBwLng7XG4gICAgICAgIGNvbnN0IHkgPSBwLnk7XG5cbiAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlY3QobWluWCwgbWluWSwgbWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbn07XG5cblJlY3QuZnJvbVJlY3RVbmlvbiA9IGZ1bmN0aW9uKC4uLnJlY3RzKSB7XG5cbiAgICBpZiAocmVjdHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHIgPSBuZXcgUmVjdCgpO1xuICAgIGxldCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgIG1pblggPSBtaW5ZID0gSW5maW5pdHk7XG4gICAgbWF4WCA9IG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHIudXBkYXRlKHJlY3RzW2ldKTtcbiAgICAgICAgY29uc3QgeCA9IHIueDtcbiAgICAgICAgY29uc3QgeSA9IHIueTtcbiAgICAgICAgY29uc3QgbVggPSB4ICsgci53aWR0aDtcbiAgICAgICAgY29uc3QgbVkgPSB5ICsgci5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgaWYgKG1YID4gbWF4WCkgbWF4WCA9IG1YO1xuICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICBpZiAobVkgPiBtYXhZKSBtYXhZID0gbVk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWN0KG1pblgsIG1pblksIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG59O1xuXG5SZWN0LnByb3RvdHlwZSA9IHtcblxuICAgIHR5cGU6IHR5cGVzLlJlY3QsXG5cbiAgICAvLyBGaW5kIG15IGJvdW5kaW5nIGJveCB3aGVuIEknbSByb3RhdGVkIHdpdGggdGhlIGNlbnRlciBvZiByb3RhdGlvbiBpbiB0aGUgY2VudGVyIG9mIG1lLlxuICAgIC8vIEByZXR1cm4gciB7cmVjdGFuZ2xlfSByZXByZXNlbnRpbmcgYSBib3VuZGluZyBib3hcbiAgICBiYm94OiBmdW5jdGlvbihhbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnJvdGF0ZUFyb3VuZENlbnRlcihhbmdsZSk7XG4gICAgfSxcblxuICAgIHJvdGF0ZUFyb3VuZENlbnRlcjogZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgaWYgKCFhbmdsZSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgdGhldGEgPSB0b1JhZChhbmdsZSk7XG4gICAgICAgIGNvbnN0IHN0ID0gYWJzKHNpbih0aGV0YSkpO1xuICAgICAgICBjb25zdCBjdCA9IGFicyhjb3ModGhldGEpKTtcbiAgICAgICAgY29uc3QgdyA9IHdpZHRoICogY3QgKyBoZWlnaHQgKiBzdDtcbiAgICAgICAgY29uc3QgaCA9IHdpZHRoICogc3QgKyBoZWlnaHQgKiBjdDtcbiAgICAgICAgdGhpcy54ICs9ICh3aWR0aCAtIHcpIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IChoZWlnaHQgLSBoKSAvIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBib3R0b21MZWZ0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBib3R0b21MaW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy5ib3R0b21MZWZ0KCksIHRoaXMuYm90dG9tUmlnaHQoKSk7XG4gICAgfSxcblxuICAgIGJvdHRvbU1pZGRsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgIH0sXG5cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgfSxcblxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFJlY3QodGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge2Jvb2x9IHRydWUgaWYgcG9pbnQgcCBpcyBpbnNpZGUgbWUuXG4gICAgLy8gQHBhcmFtIHtib29sfSBzdHJpY3QgSWYgdHJ1ZSwgdGhlIHBvaW50IGhhcyB0byBiZSBzdHJpY3RseSBpbnNpZGUgKG5vdCBvbiB0aGUgYm9yZGVyKS5cbiAgICBjb250YWluc1BvaW50OiBmdW5jdGlvbihwLCBvcHQpIHtcbiAgICAgICAgbGV0IHgsIHk7XG4gICAgICAgIGlmICghcCB8fCAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IGlmIHRoZSBwb2ludCBpcyBub3QgcHJvdmlkZWQsXG4gICAgICAgICAgICAvLyB0aGUgcG9pbnQgaXMgY29uc2lkZXJlZCB0byBiZSB0aGUgb3JpZ2luIFswLCAwXS5cbiAgICAgICAgICAgICh7IHgsIHkgfSA9IG5ldyBQb2ludChwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgY3JlYXRlIGEgbmV3IFBvaW50IG9iamVjdCBpZiB0aGUgcG9pbnQgaXMgYWxyZWFkeSBhIFBvaW50LWxpa2Ugb2JqZWN0LlxuICAgICAgICAgICAgKHsgeCA9IDAsIHkgPSAwIH0gPSBwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0ICYmIG9wdC5zdHJpY3RcbiAgICAgICAgICAgID8gKHggPiB0aGlzLnggJiYgeCA8IHRoaXMueCArIHRoaXMud2lkdGggJiYgeSA+IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICA6IHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtib29sfSB0cnVlIGlmIHJlY3RhbmdsZSBgcmAgaXMgaW5zaWRlIG1lLlxuICAgIGNvbnRhaW5zUmVjdDogZnVuY3Rpb24ocikge1xuXG4gICAgICAgIHZhciByMCA9IG5ldyBSZWN0KHRoaXMpLm5vcm1hbGl6ZSgpO1xuICAgICAgICB2YXIgcjEgPSBuZXcgUmVjdChyKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIHcwID0gcjAud2lkdGg7XG4gICAgICAgIHZhciBoMCA9IHIwLmhlaWdodDtcbiAgICAgICAgdmFyIHcxID0gcjEud2lkdGg7XG4gICAgICAgIHZhciBoMSA9IHIxLmhlaWdodDtcblxuICAgICAgICBpZiAoIXcwIHx8ICFoMCB8fCAhdzEgfHwgIWgxKSB7XG4gICAgICAgICAgICAvLyBBdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnMgaXMgMFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgwID0gcjAueDtcbiAgICAgICAgdmFyIHkwID0gcjAueTtcbiAgICAgICAgdmFyIHgxID0gcjEueDtcbiAgICAgICAgdmFyIHkxID0gcjEueTtcblxuICAgICAgICB3MSArPSB4MTtcbiAgICAgICAgdzAgKz0geDA7XG4gICAgICAgIGgxICs9IHkxO1xuICAgICAgICBoMCArPSB5MDtcblxuICAgICAgICByZXR1cm4geDAgPD0geDEgJiYgdzEgPD0gdzAgJiYgeTAgPD0geTEgJiYgaDEgPD0gaDA7XG4gICAgfSxcblxuICAgIGNvcm5lcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcmVjdGFuZ2xlcyBhcmUgZXF1YWwuXG4gICAgZXF1YWxzOiBmdW5jdGlvbihyKSB7XG5cbiAgICAgICAgdmFyIG1yID0gKG5ldyBSZWN0KHRoaXMpKS5ub3JtYWxpemUoKTtcbiAgICAgICAgdmFyIG5yID0gKG5ldyBSZWN0KHIpKS5ub3JtYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1yLnggPT09IG5yLnggJiYgbXIueSA9PT0gbnIueSAmJiBtci53aWR0aCA9PT0gbnIud2lkdGggJiYgbXIuaGVpZ2h0ID09PSBuci5oZWlnaHQ7XG4gICAgfSxcblxuICAgIC8vIGluZmxhdGUgYnkgZHggYW5kIGR5LCByZWNvbXB1dGUgb3JpZ2luIFt4LCB5XVxuICAgIC8vIEBwYXJhbSBkeCB7ZGVsdGFfeH0gcmVwcmVzZW50aW5nIGFkZGl0aW9uYWwgc2l6ZSB0byB4XG4gICAgLy8gQHBhcmFtIGR5IHtkZWx0YV95fSByZXByZXNlbnRpbmcgYWRkaXRpb25hbCBzaXplIHRvIHkgLVxuICAgIC8vIGR5IHBhcmFtIGlzIG5vdCByZXF1aXJlZCAtPiBpbiB0aGF0IGNhc2UgeSBpcyBzaXplZCBieSBkeFxuICAgIGluZmxhdGU6IGZ1bmN0aW9uKGR4LCBkeSkge1xuXG4gICAgICAgIGlmIChkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHkgPSBkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMueCAtPSBkeDtcbiAgICAgICAgdGhpcy55IC09IGR5O1xuICAgICAgICB0aGlzLndpZHRoICs9IDIgKiBkeDtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gMiAqIGR5O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtyZWN0fSBpZiByZWN0YW5nbGVzIGludGVyc2VjdCwge251bGx9IGlmIG5vdC5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKHIpIHtcblxuICAgICAgICB2YXIgbXlPcmlnaW4gPSB0aGlzLm9yaWdpbigpO1xuICAgICAgICB2YXIgbXlDb3JuZXIgPSB0aGlzLmNvcm5lcigpO1xuICAgICAgICB2YXIgck9yaWdpbiA9IHIub3JpZ2luKCk7XG4gICAgICAgIHZhciByQ29ybmVyID0gci5jb3JuZXIoKTtcblxuICAgICAgICAvLyBObyBpbnRlcnNlY3Rpb24gZm91bmRcbiAgICAgICAgaWYgKHJDb3JuZXIueCA8PSBteU9yaWdpbi54IHx8XG4gICAgICAgICAgICByQ29ybmVyLnkgPD0gbXlPcmlnaW4ueSB8fFxuICAgICAgICAgICAgck9yaWdpbi54ID49IG15Q29ybmVyLnggfHxcbiAgICAgICAgICAgIHJPcmlnaW4ueSA+PSBteUNvcm5lci55KSByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgeCA9IG1heChteU9yaWdpbi54LCByT3JpZ2luLngpO1xuICAgICAgICB2YXIgeSA9IG1heChteU9yaWdpbi55LCByT3JpZ2luLnkpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVjdCh4LCB5LCBtaW4obXlDb3JuZXIueCwgckNvcm5lci54KSAtIHgsIG1pbihteUNvcm5lci55LCByQ29ybmVyLnkpIC0geSk7XG4gICAgfSxcblxuICAgIGludGVyc2VjdGlvbldpdGhMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG5cbiAgICAgICAgdmFyIHIgPSB0aGlzO1xuICAgICAgICB2YXIgcmVjdExpbmVzID0gW3IudG9wTGluZSgpLCByLnJpZ2h0TGluZSgpLCByLmJvdHRvbUxpbmUoKSwgci5sZWZ0TGluZSgpXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICB2YXIgZGVkdXBlQXJyID0gW107XG4gICAgICAgIHZhciBwdCwgaTtcblxuICAgICAgICB2YXIgbiA9IHJlY3RMaW5lcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblxuICAgICAgICAgICAgcHQgPSBsaW5lLmludGVyc2VjdChyZWN0TGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKHB0ICE9PSBudWxsICYmIGRlZHVwZUFyci5pbmRleE9mKHB0LnRvU3RyaW5nKCkpIDwgMCkge1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHB0KTtcbiAgICAgICAgICAgICAgICBkZWR1cGVBcnIucHVzaChwdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb2ludHMubGVuZ3RoID4gMCA/IHBvaW50cyA6IG51bGw7XG4gICAgfSxcblxuICAgIC8vIEZpbmQgcG9pbnQgb24gbXkgYm91bmRhcnkgd2hlcmUgbGluZSBzdGFydGluZ1xuICAgIC8vIGZyb20gbXkgY2VudGVyIGVuZGluZyBpbiBwb2ludCBwIGludGVyc2VjdHMgbWUuXG4gICAgLy8gQHBhcmFtIHtudW1iZXJ9IGFuZ2xlIElmIGFuZ2xlIGlzIHNwZWNpZmllZCwgaW50ZXJzZWN0aW9uIHdpdGggcm90YXRlZCByZWN0YW5nbGUgaXMgY29tcHV0ZWQuXG4gICAgaW50ZXJzZWN0aW9uV2l0aExpbmVGcm9tQ2VudGVyVG9Qb2ludDogZnVuY3Rpb24ocCwgYW5nbGUpIHtcblxuICAgICAgICBwID0gbmV3IFBvaW50KHApO1xuICAgICAgICB2YXIgY2VudGVyID0gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmIChhbmdsZSkgcC5yb3RhdGUoY2VudGVyLCBhbmdsZSk7XG5cbiAgICAgICAgLy8gKGNsb2Nrd2lzZSwgc3RhcnRpbmcgZnJvbSB0aGUgdG9wIHNpZGUpXG4gICAgICAgIHZhciBzaWRlcyA9IFtcbiAgICAgICAgICAgIHRoaXMudG9wTGluZSgpLFxuICAgICAgICAgICAgdGhpcy5yaWdodExpbmUoKSxcbiAgICAgICAgICAgIHRoaXMuYm90dG9tTGluZSgpLFxuICAgICAgICAgICAgdGhpcy5sZWZ0TGluZSgpXG4gICAgICAgIF07XG4gICAgICAgIHZhciBjb25uZWN0b3IgPSBuZXcgTGluZShjZW50ZXIsIHApO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzaWRlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHNpZGVzW2ldLmludGVyc2VjdGlvbihjb25uZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGludGVyc2VjdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGFuZ2xlKSByZXN1bHQucm90YXRlKGNlbnRlciwgLWFuZ2xlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgbGVmdExpbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLnRvcExlZnQoKSwgdGhpcy5ib3R0b21MZWZ0KCkpO1xuICAgIH0sXG5cbiAgICBsZWZ0TWlkZGxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyKTtcbiAgICB9LFxuXG4gICAgbWF4UmVjdFNjYWxlVG9GaXQ6IGZ1bmN0aW9uKHJlY3QsIG9yaWdpbikge1xuXG4gICAgICAgIHJlY3QgPSBuZXcgUmVjdChyZWN0KTtcbiAgICAgICAgb3JpZ2luIHx8IChvcmlnaW4gPSByZWN0LmNlbnRlcigpKTtcblxuICAgICAgICB2YXIgc3gxLCBzeDIsIHN4Mywgc3g0LCBzeTEsIHN5Miwgc3kzLCBzeTQ7XG4gICAgICAgIHZhciBveCA9IG9yaWdpbi54O1xuICAgICAgICB2YXIgb3kgPSBvcmlnaW4ueTtcblxuICAgICAgICAvLyBIZXJlIHdlIGZpbmQgdGhlIG1heGltYWwgcG9zc2libGUgc2NhbGUgZm9yIGFsbCBjb3JuZXIgcG9pbnRzIChmb3IgeCBhbmQgeSBheGlzKSBvZiB0aGUgcmVjdGFuZ2xlLFxuICAgICAgICAvLyBzbyB3aGVuIHRoZSBzY2FsZSBpcyBhcHBsaWVkIHRoZSBwb2ludCBpcyBzdGlsbCBpbnNpZGUgdGhlIHJlY3RhbmdsZS5cblxuICAgICAgICBzeDEgPSBzeDIgPSBzeDMgPSBzeDQgPSBzeTEgPSBzeTIgPSBzeTMgPSBzeTQgPSBJbmZpbml0eTtcblxuICAgICAgICAvLyBUb3AgTGVmdFxuICAgICAgICB2YXIgcDEgPSByZWN0LnRvcExlZnQoKTtcbiAgICAgICAgaWYgKHAxLnggPCBveCkge1xuICAgICAgICAgICAgc3gxID0gKHRoaXMueCAtIG94KSAvIChwMS54IC0gb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwMS55IDwgb3kpIHtcbiAgICAgICAgICAgIHN5MSA9ICh0aGlzLnkgLSBveSkgLyAocDEueSAtIG95KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCb3R0b20gUmlnaHRcbiAgICAgICAgdmFyIHAyID0gcmVjdC5ib3R0b21SaWdodCgpO1xuICAgICAgICBpZiAocDIueCA+IG94KSB7XG4gICAgICAgICAgICBzeDIgPSAodGhpcy54ICsgdGhpcy53aWR0aCAtIG94KSAvIChwMi54IC0gb3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwMi55ID4gb3kpIHtcbiAgICAgICAgICAgIHN5MiA9ICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIG95KSAvIChwMi55IC0gb3kpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvcCBSaWdodFxuICAgICAgICB2YXIgcDMgPSByZWN0LnRvcFJpZ2h0KCk7XG4gICAgICAgIGlmIChwMy54ID4gb3gpIHtcbiAgICAgICAgICAgIHN4MyA9ICh0aGlzLnggKyB0aGlzLndpZHRoIC0gb3gpIC8gKHAzLnggLSBveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAzLnkgPCBveSkge1xuICAgICAgICAgICAgc3kzID0gKHRoaXMueSAtIG95KSAvIChwMy55IC0gb3kpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdHRvbSBMZWZ0XG4gICAgICAgIHZhciBwNCA9IHJlY3QuYm90dG9tTGVmdCgpO1xuICAgICAgICBpZiAocDQueCA8IG94KSB7XG4gICAgICAgICAgICBzeDQgPSAodGhpcy54IC0gb3gpIC8gKHA0LnggLSBveCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHA0LnkgPiBveSkge1xuICAgICAgICAgICAgc3k0ID0gKHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gb3kpIC8gKHA0LnkgLSBveSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3g6IG1pbihzeDEsIHN4Miwgc3gzLCBzeDQpLFxuICAgICAgICAgICAgc3k6IG1pbihzeTEsIHN5Miwgc3kzLCBzeTQpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG1heFJlY3RVbmlmb3JtU2NhbGVUb0ZpdDogZnVuY3Rpb24ocmVjdCwgb3JpZ2luKSB7XG5cbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5tYXhSZWN0U2NhbGVUb0ZpdChyZWN0LCBvcmlnaW4pO1xuICAgICAgICByZXR1cm4gbWluKHNjYWxlLnN4LCBzY2FsZS5zeSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmUgYW5kIGV4cGFuZCBtZS5cbiAgICAvLyBAcGFyYW0gciB7cmVjdGFuZ2xlfSByZXByZXNlbnRpbmcgZGVsdGFzXG4gICAgbW92ZUFuZEV4cGFuZDogZnVuY3Rpb24ocikge1xuXG4gICAgICAgIHRoaXMueCArPSByLnggfHwgMDtcbiAgICAgICAgdGhpcy55ICs9IHIueSB8fCAwO1xuICAgICAgICB0aGlzLndpZHRoICs9IHIud2lkdGggfHwgMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gci5oZWlnaHQgfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcmVjdGFuZ2xlOyBpLmUuLCBtYWtlIGl0IHNvIHRoYXQgaXQgaGFzIGEgbm9uLW5lZ2F0aXZlIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgLy8gSWYgd2lkdGggPCAwIHRoZSBmdW5jdGlvbiBzd2FwcyB0aGUgbGVmdCBhbmQgcmlnaHQgY29ybmVycyxcbiAgICAvLyBhbmQgaXQgc3dhcHMgdGhlIHRvcCBhbmQgYm90dG9tIGNvcm5lcnMgaWYgaGVpZ2h0IDwgMFxuICAgIC8vIGxpa2UgaW4gaHR0cDovL3F0LXByb2plY3Qub3JnL2RvYy9xdC00LjgvcXJlY3RmLmh0bWwjbm9ybWFsaXplZFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIG5ld3ggPSB0aGlzLng7XG4gICAgICAgIHZhciBuZXd5ID0gdGhpcy55O1xuICAgICAgICB2YXIgbmV3d2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICB2YXIgbmV3aGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIDwgMCkge1xuICAgICAgICAgICAgbmV3eCA9IHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgICAgICAgICBuZXd3aWR0aCA9IC10aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG5ld3kgPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIG5ld2hlaWdodCA9IC10aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnggPSBuZXd4O1xuICAgICAgICB0aGlzLnkgPSBuZXd5O1xuICAgICAgICB0aGlzLndpZHRoID0gbmV3d2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3aGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gT2Zmc2V0IG1lIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LlxuICAgIG9mZnNldDogZnVuY3Rpb24oZHgsIGR5KSB7XG5cbiAgICAgICAgLy8gcHJldGVuZCB0aGF0IHRoaXMgaXMgYSBwb2ludCBhbmQgY2FsbCBvZmZzZXQoKVxuICAgICAgICAvLyByZXdyaXRlcyB4IGFuZCB5IGFjY29yZGluZyB0byBkeCBhbmQgZHlcbiAgICAgICAgcmV0dXJuIFBvaW50LnByb3RvdHlwZS5vZmZzZXQuY2FsbCh0aGlzLCBkeCwgZHkpO1xuICAgIH0sXG5cbiAgICBvcmlnaW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICAvLyBAcmV0dXJuIHtwb2ludH0gYSBwb2ludCBvbiBteSBib3VuZGFyeSBuZWFyZXN0IHRvIHRoZSBnaXZlbiBwb2ludC5cbiAgICAvLyBAc2VlIFNxdWVhayBTbWFsbHRhbGssIFJlY3RhbmdsZT4+cG9pbnROZWFyZXN0VG86XG4gICAgcG9pbnROZWFyZXN0VG9Qb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICBwb2ludCA9IG5ldyBQb2ludChwb2ludCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gICAgICAgICAgICB2YXIgc2lkZSA9IHRoaXMuc2lkZU5lYXJlc3RUb1BvaW50KHBvaW50KTtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoLCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHBvaW50LnkpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocG9pbnQueCwgdGhpcy55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQuYWRoZXJlVG9SZWN0KHRoaXMpO1xuICAgIH0sXG5cbiAgICByaWdodExpbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLnRvcFJpZ2h0KCksIHRoaXMuYm90dG9tUmlnaHQoKSk7XG4gICAgfSxcblxuICAgIHJpZ2h0TWlkZGxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblxuICAgICAgICBsZXQgZiA9IDE7IC8vIGNhc2UgMFxuICAgICAgICBpZiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogZiA9IDEwOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IGYgPSAxMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogZiA9IDEwMDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGYgPSBwb3coMTAsIHByZWNpc2lvbik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0gcm91bmQodGhpcy54ICogZikgLyBmO1xuICAgICAgICB0aGlzLnkgPSByb3VuZCh0aGlzLnkgKiBmKSAvIGY7XG4gICAgICAgIHRoaXMud2lkdGggPSByb3VuZCh0aGlzLndpZHRoICogZikgLyBmO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHJvdW5kKHRoaXMuaGVpZ2h0ICogZikgLyBmO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2NhbGUgcmVjdGFuZ2xlIHdpdGggb3JpZ2luLlxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3ksIG9yaWdpbikge1xuXG4gICAgICAgIG9yaWdpbiA9IHRoaXMub3JpZ2luKCkuc2NhbGUoc3gsIHN5LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLnggPSBvcmlnaW4ueDtcbiAgICAgICAgdGhpcy55ID0gb3JpZ2luLnk7XG4gICAgICAgIHRoaXMud2lkdGggKj0gc3g7XG4gICAgICAgIHRoaXMuaGVpZ2h0ICo9IHN5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQHJldHVybiB7c3RyaW5nfSAobGVmdHxyaWdodHx0b3B8Ym90dG9tKSBzaWRlIHdoaWNoIGlzIG5lYXJlc3QgdG8gcG9pbnRcbiAgICAvLyBAc2VlIFNxdWVhayBTbWFsbHRhbGssIFJlY3RhbmdsZT4+c2lkZU5lYXJlc3RUbzpcbiAgICBzaWRlTmVhcmVzdFRvUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQocG9pbnQpO1xuICAgICAgICB2YXIgZGlzdFRvTGVmdCA9IHBvaW50LnggLSB0aGlzLng7XG4gICAgICAgIHZhciBkaXN0VG9SaWdodCA9ICh0aGlzLnggKyB0aGlzLndpZHRoKSAtIHBvaW50Lng7XG4gICAgICAgIHZhciBkaXN0VG9Ub3AgPSBwb2ludC55IC0gdGhpcy55O1xuICAgICAgICB2YXIgZGlzdFRvQm90dG9tID0gKHRoaXMueSArIHRoaXMuaGVpZ2h0KSAtIHBvaW50Lnk7XG4gICAgICAgIHZhciBjbG9zZXN0ID0gZGlzdFRvTGVmdDtcbiAgICAgICAgdmFyIHNpZGUgPSAnbGVmdCc7XG5cbiAgICAgICAgaWYgKGRpc3RUb1JpZ2h0IDwgY2xvc2VzdCkge1xuICAgICAgICAgICAgY2xvc2VzdCA9IGRpc3RUb1JpZ2h0O1xuICAgICAgICAgICAgc2lkZSA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3RUb1RvcCA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBkaXN0VG9Ub3A7XG4gICAgICAgICAgICBzaWRlID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3RUb0JvdHRvbSA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIC8vIGNsb3Nlc3QgPSBkaXN0VG9Cb3R0b207XG4gICAgICAgICAgICBzaWRlID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZGU7XG4gICAgfSxcblxuICAgIHNuYXBUb0dyaWQ6IGZ1bmN0aW9uKGd4LCBneSkge1xuXG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbigpLnNuYXBUb0dyaWQoZ3gsIGd5KTtcbiAgICAgICAgdmFyIGNvcm5lciA9IHRoaXMuY29ybmVyKCkuc25hcFRvR3JpZChneCwgZ3kpO1xuICAgICAgICB0aGlzLnggPSBvcmlnaW4ueDtcbiAgICAgICAgdGhpcy55ID0gb3JpZ2luLnk7XG4gICAgICAgIHRoaXMud2lkdGggPSBjb3JuZXIueCAtIG9yaWdpbi54O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGNvcm5lci55IC0gb3JpZ2luLnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55LCB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9O1xuICAgIH0sXG5cbiAgICB0b3BMaW5lOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy50b3BMZWZ0KCksIHRoaXMudG9wUmlnaHQoKSk7XG4gICAgfSxcblxuICAgIHRvcE1pZGRsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgdG9wUmlnaHQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgdGhpcy53aWR0aCwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbigpLnRvU3RyaW5nKCkgKyAnICcgKyB0aGlzLmNvcm5lcigpLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8vIEByZXR1cm4ge3JlY3R9IHJlcHJlc2VudGluZyB0aGUgdW5pb24gb2YgYm90aCByZWN0YW5nbGVzLlxuICAgIHVuaW9uOiBmdW5jdGlvbihyZWN0KSB7XG5cbiAgICAgICAgcmV0dXJuIFJlY3QuZnJvbVJlY3RVbmlvbih0aGlzLCByZWN0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG5cbiAgICAgICAgaWYgKChPYmplY3QoeCkgPT09IHgpKSB7XG4gICAgICAgICAgICB5ID0geC55O1xuICAgICAgICAgICAgdyA9IHgud2lkdGg7XG4gICAgICAgICAgICBoID0geC5oZWlnaHQ7XG4gICAgICAgICAgICB4ID0geC54O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSB3IHx8IDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaCB8fCAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5SZWN0LnByb3RvdHlwZS5ib3R0b21SaWdodCA9IFJlY3QucHJvdG90eXBlLmNvcm5lcjtcblxuUmVjdC5wcm90b3R5cGUudG9wTGVmdCA9IFJlY3QucHJvdG90eXBlLm9yaWdpbjtcblxuUmVjdC5wcm90b3R5cGUudHJhbnNsYXRlID0gUmVjdC5wcm90b3R5cGUub2Zmc2V0O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6XG5leHBvcnQgY29uc3QgcmVjdCA9IFJlY3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@joint/core/src/g/types.mjs ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   types: function() { return /* binding */ types; }\n/* harmony export */ });\nconst types = {\n    Point: 1,\n    Line: 2,\n    Ellipse: 3,\n    Rect: 4,\n    Polyline: 5,\n    Polygon: 6,\n    Curve: 7,\n    Path: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy90eXBlcy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvZy90eXBlcy5tanM/NDQ5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gICAgUG9pbnQ6IDEsXG4gICAgTGluZTogMixcbiAgICBFbGxpcHNlOiAzLFxuICAgIFJlY3Q6IDQsXG4gICAgUG9seWxpbmU6IDUsXG4gICAgUG9seWdvbjogNixcbiAgICBDdXJ2ZTogNyxcbiAgICBQYXRoOiA4XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/g/types.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/highlighters/addClass.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/addClass.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: function() { return /* binding */ addClass; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\n\nconst className = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.addClassNamePrefix('highlighted');\n\nconst addClass = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_1__.HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    options: {\n        className\n    },\n\n    highlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).addClass(this.options.className);\n    },\n\n    unhighlight: function(_cellView, node) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).removeClass(this.options.className);\n    }\n\n}, {\n    // Backwards Compatibility\n    className\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL2FkZENsYXNzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBDO0FBQ1g7QUFDOEI7O0FBRTdELGtCQUFrQiwrREFBdUI7O0FBRWxDLGlCQUFpQixxRUFBZTs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFFBQVEsd0RBQUM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsUUFBUSx3REFBQztBQUNUOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9hZGRDbGFzcy5tanM/Mzg0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4uL2RpYS9IaWdobGlnaHRlclZpZXcubWpzJztcblxuY29uc3QgY2xhc3NOYW1lID0gdXRpbC5hZGRDbGFzc05hbWVQcmVmaXgoJ2hpZ2hsaWdodGVkJyk7XG5cbmV4cG9ydCBjb25zdCBhZGRDbGFzcyA9IEhpZ2hsaWdodGVyVmlldy5leHRlbmQoe1xuXG4gICAgVVBEQVRBQkxFOiBmYWxzZSxcbiAgICBNT1VOVEFCTEU6IGZhbHNlLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBjbGFzc05hbWVcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihfY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgVihub2RlKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lKTtcbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQ6IGZ1bmN0aW9uKF9jZWxsVmlldywgbm9kZSkge1xuICAgICAgICBWKG5vZGUpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpO1xuICAgIH1cblxufSwge1xuICAgIC8vIEJhY2t3YXJkcyBDb21wYXRpYmlsaXR5XG4gICAgY2xhc3NOYW1lXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/highlighters/addClass.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/highlighters/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/index.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: function() { return /* reexport safe */ _addClass_mjs__WEBPACK_IMPORTED_MODULE_3__.addClass; },\n/* harmony export */   list: function() { return /* reexport safe */ _list_mjs__WEBPACK_IMPORTED_MODULE_4__.list; },\n/* harmony export */   mask: function() { return /* reexport safe */ _mask_mjs__WEBPACK_IMPORTED_MODULE_1__.mask; },\n/* harmony export */   opacity: function() { return /* reexport safe */ _opacity_mjs__WEBPACK_IMPORTED_MODULE_2__.opacity; },\n/* harmony export */   stroke: function() { return /* reexport safe */ _stroke_mjs__WEBPACK_IMPORTED_MODULE_0__.stroke; }\n/* harmony export */ });\n/* harmony import */ var _stroke_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stroke.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/stroke.mjs\");\n/* harmony import */ var _mask_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mask.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/mask.mjs\");\n/* harmony import */ var _opacity_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./opacity.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/opacity.mjs\");\n/* harmony import */ var _addClass_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./addClass.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/addClass.mjs\");\n/* harmony import */ var _list_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./list.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/highlighters/list.mjs\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0Y7QUFDRztBQUNDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9oaWdobGlnaHRlcnMvaW5kZXgubWpzP2IyNzMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9zdHJva2UubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vbWFzay5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vcGFjaXR5Lm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2FkZENsYXNzLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpc3QubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/highlighters/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/highlighters/list.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/list.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   list: function() { return /* binding */ list; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/getRectPoint.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/getRectPoint.mjs\");\n\n\n\n\n\nconst Directions = {\n    ROW: 'row',\n    COLUMN: 'column'\n};\n\nconst list = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    tagName: 'g',\n    MOUNTABLE: true,\n    UPDATE_ATTRIBUTES: function() {\n        return [this.options.attribute];\n    },\n\n    _prevItems: null,\n\n    highlight(elementView, node) {\n        const element = elementView.model;\n        const { attribute, size = 20, gap = 5, direction = Directions.ROW } = this.options;\n        if (!attribute) throw new Error('List: attribute is required');\n        const normalizedSize = (typeof size === 'number') ? { width: size, height: size } : size;\n        const isRowDirection = (direction === Directions.ROW);\n        const itemWidth = isRowDirection ? normalizedSize.width : normalizedSize.height;\n        let items = element.get(attribute);\n        if (!Array.isArray(items)) items = [];\n        const prevItems = this._prevItems || [];\n        const comparison = items.map((item, index) => (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual)(prevItems[index], items[index]));\n        if (prevItems.length !== items.length || comparison.some(unchanged => !unchanged)) {\n            const prevEls = this.vel.children();\n            const itemsEls = items.map((item, index) => {\n                const prevEl = (index in prevEls) ? prevEls[index].node : null;\n                if (comparison[index]) return prevEl;\n                const itemEl = this.createListItem(item, normalizedSize, prevEl);\n                if (!itemEl) return null;\n                if (!(itemEl instanceof SVGElement)) throw new Error('List: item must be an SVGElement');\n                itemEl.dataset.index = index;\n                itemEl.dataset.attribute = attribute;\n                const offset = index * (itemWidth + gap);\n                itemEl.setAttribute('transform', (isRowDirection)\n                    ? `translate(${offset}, 0)`\n                    : `translate(0, ${offset})`\n                );\n                return itemEl;\n            });\n            this.vel.empty().append(itemsEls);\n            this._prevItems = items;\n        }\n        const itemsCount = items.length;\n        const length = (itemsCount === 0)\n            ? 0\n            : (itemsCount * itemWidth + (itemsCount - 1) * gap);\n        const listSize = (isRowDirection)\n            ? { width: length, height: normalizedSize.height }\n            : { width: normalizedSize.width, height: length };\n\n        this.position(element, listSize);\n    },\n\n    position(element, listSize) {\n        const { vel, options } = this;\n        const { margin = 5, position = 'top-left' } = options;\n        const { width, height } = element.size();\n        const { left, right, top, bottom } = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeSides)(margin);\n        const bbox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Rect(left, top, width - (left + right), height - (top + bottom));\n        let { x, y } = (0,_util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.getRectPoint)(bbox, position);\n        // x\n        switch (position) {\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.CENTER:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.TOP:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM: {\n                x -= listSize.width / 2;\n                break;\n            }\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.TOP_RIGHT: {\n                x -= listSize.width;\n                break;\n            }\n        }\n        // y\n        switch (position) {\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.CENTER:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.LEFT: {\n                y -= listSize.height / 2;\n                break;\n            }\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_RIGHT:\n            case _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions.BOTTOM_LEFT: {\n                y -= listSize.height;\n                break;\n            }\n        }\n        vel.attr('transform', `translate(${x}, ${y})`);\n    }\n}, {\n    Directions,\n    Positions: _util_getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_4__.Positions\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL2xpc3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFzQztBQUN1QjtBQUlsQztBQUlPOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFTyxhQUFhLHFFQUFlOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQSw4REFBOEQsNEJBQTRCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsd0RBQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUMsc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjs7QUFFaEI7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLG9DQUFvQztBQUNwRCxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGdCQUFnQiwyQkFBMkIsRUFBRSwrREFBYztBQUMzRCx5QkFBeUIsOENBQUk7QUFDN0IsY0FBYyxPQUFPLEVBQUUsb0VBQVk7QUFDbkM7QUFDQTtBQUNBLGlCQUFpQiw2REFBUztBQUMxQixpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBUztBQUMxQixpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBUztBQUMxQixpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2REFBUztBQUMxQixpQkFBaUIsNkRBQVM7QUFDMUIsaUJBQWlCLDZEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUUsSUFBSSxFQUFFO0FBQ25EO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsYUFBYTtBQUNiLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9oaWdobGlnaHRlcnMvbGlzdC5tanM/YWFjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgSGlnaGxpZ2h0ZXJWaWV3IH0gZnJvbSAnLi4vZGlhL0hpZ2hsaWdodGVyVmlldy5tanMnO1xuaW1wb3J0IHtcbiAgICBub3JtYWxpemVTaWRlcyxcbiAgICBpc0VxdWFsLFxufSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQge1xuICAgIFBvc2l0aW9ucyxcbiAgICBnZXRSZWN0UG9pbnQsXG59IGZyb20gJy4uL3V0aWwvZ2V0UmVjdFBvaW50Lm1qcyc7XG5cbmNvbnN0IERpcmVjdGlvbnMgPSB7XG4gICAgUk9XOiAncm93JyxcbiAgICBDT0xVTU46ICdjb2x1bW4nXG59O1xuXG5leHBvcnQgY29uc3QgbGlzdCA9IEhpZ2hsaWdodGVyVmlldy5leHRlbmQoe1xuXG4gICAgdGFnTmFtZTogJ2cnLFxuICAgIE1PVU5UQUJMRTogdHJ1ZSxcbiAgICBVUERBVEVfQVRUUklCVVRFUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5vcHRpb25zLmF0dHJpYnV0ZV07XG4gICAgfSxcblxuICAgIF9wcmV2SXRlbXM6IG51bGwsXG5cbiAgICBoaWdobGlnaHQoZWxlbWVudFZpZXcsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRWaWV3Lm1vZGVsO1xuICAgICAgICBjb25zdCB7IGF0dHJpYnV0ZSwgc2l6ZSA9IDIwLCBnYXAgPSA1LCBkaXJlY3Rpb24gPSBEaXJlY3Rpb25zLlJPVyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZSkgdGhyb3cgbmV3IEVycm9yKCdMaXN0OiBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFNpemUgPSAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSA/IHsgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSB9IDogc2l6ZTtcbiAgICAgICAgY29uc3QgaXNSb3dEaXJlY3Rpb24gPSAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlJPVyk7XG4gICAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGlzUm93RGlyZWN0aW9uID8gbm9ybWFsaXplZFNpemUud2lkdGggOiBub3JtYWxpemVkU2l6ZS5oZWlnaHQ7XG4gICAgICAgIGxldCBpdGVtcyA9IGVsZW1lbnQuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIGl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IHByZXZJdGVtcyA9IHRoaXMuX3ByZXZJdGVtcyB8fCBbXTtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvbiA9IGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IGlzRXF1YWwocHJldkl0ZW1zW2luZGV4XSwgaXRlbXNbaW5kZXhdKSk7XG4gICAgICAgIGlmIChwcmV2SXRlbXMubGVuZ3RoICE9PSBpdGVtcy5sZW5ndGggfHwgY29tcGFyaXNvbi5zb21lKHVuY2hhbmdlZCA9PiAhdW5jaGFuZ2VkKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldkVscyA9IHRoaXMudmVsLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICBjb25zdCBpdGVtc0VscyA9IGl0ZW1zLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RWwgPSAoaW5kZXggaW4gcHJldkVscykgPyBwcmV2RWxzW2luZGV4XS5ub2RlIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyaXNvbltpbmRleF0pIHJldHVybiBwcmV2RWw7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUVsID0gdGhpcy5jcmVhdGVMaXN0SXRlbShpdGVtLCBub3JtYWxpemVkU2l6ZSwgcHJldkVsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1FbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCEoaXRlbUVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkpIHRocm93IG5ldyBFcnJvcignTGlzdDogaXRlbSBtdXN0IGJlIGFuIFNWR0VsZW1lbnQnKTtcbiAgICAgICAgICAgICAgICBpdGVtRWwuZGF0YXNldC5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGl0ZW1FbC5kYXRhc2V0LmF0dHJpYnV0ZSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIChpdGVtV2lkdGggKyBnYXApO1xuICAgICAgICAgICAgICAgIGl0ZW1FbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIChpc1Jvd0RpcmVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBgdHJhbnNsYXRlKCR7b2Zmc2V0fSwgMClgXG4gICAgICAgICAgICAgICAgICAgIDogYHRyYW5zbGF0ZSgwLCAke29mZnNldH0pYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52ZWwuZW1wdHkoKS5hcHBlbmQoaXRlbXNFbHMpO1xuICAgICAgICAgICAgdGhpcy5fcHJldkl0ZW1zID0gaXRlbXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXNDb3VudCA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKGl0ZW1zQ291bnQgPT09IDApXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogKGl0ZW1zQ291bnQgKiBpdGVtV2lkdGggKyAoaXRlbXNDb3VudCAtIDEpICogZ2FwKTtcbiAgICAgICAgY29uc3QgbGlzdFNpemUgPSAoaXNSb3dEaXJlY3Rpb24pXG4gICAgICAgICAgICA/IHsgd2lkdGg6IGxlbmd0aCwgaGVpZ2h0OiBub3JtYWxpemVkU2l6ZS5oZWlnaHQgfVxuICAgICAgICAgICAgOiB7IHdpZHRoOiBub3JtYWxpemVkU2l6ZS53aWR0aCwgaGVpZ2h0OiBsZW5ndGggfTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uKGVsZW1lbnQsIGxpc3RTaXplKTtcbiAgICB9LFxuXG4gICAgcG9zaXRpb24oZWxlbWVudCwgbGlzdFNpemUpIHtcbiAgICAgICAgY29uc3QgeyB2ZWwsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbWFyZ2luID0gNSwgcG9zaXRpb24gPSAndG9wLWxlZnQnIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGVsZW1lbnQuc2l6ZSgpO1xuICAgICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSB9ID0gbm9ybWFsaXplU2lkZXMobWFyZ2luKTtcbiAgICAgICAgY29uc3QgYmJveCA9IG5ldyBSZWN0KGxlZnQsIHRvcCwgd2lkdGggLSAobGVmdCArIHJpZ2h0KSwgaGVpZ2h0IC0gKHRvcCArIGJvdHRvbSkpO1xuICAgICAgICBsZXQgeyB4LCB5IH0gPSBnZXRSZWN0UG9pbnQoYmJveCwgcG9zaXRpb24pO1xuICAgICAgICAvLyB4XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkNFTlRFUjpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLlRPUDpcbiAgICAgICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTToge1xuICAgICAgICAgICAgICAgIHggLT0gbGlzdFNpemUud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuUklHSFQ6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT01fUklHSFQ6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5UT1BfUklHSFQ6IHtcbiAgICAgICAgICAgICAgICB4IC09IGxpc3RTaXplLndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHlcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQ0VOVEVSOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuUklHSFQ6XG4gICAgICAgICAgICBjYXNlIFBvc2l0aW9ucy5MRUZUOiB7XG4gICAgICAgICAgICAgICAgeSAtPSBsaXN0U2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NX1JJR0hUOlxuICAgICAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NX0xFRlQ6IHtcbiAgICAgICAgICAgICAgICB5IC09IGxpc3RTaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2ZWwuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3h9LCAke3l9KWApO1xuICAgIH1cbn0sIHtcbiAgICBEaXJlY3Rpb25zLFxuICAgIFBvc2l0aW9uc1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/highlighters/list.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/highlighters/mask.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/mask.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mask: function() { return /* binding */ mask; }\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\nconst MASK_CLIP = 20;\n\nfunction forEachDescendant(vel, fn) {\n    const descendants = vel.children();\n    while (descendants.length > 0) {\n        const descendant = descendants.shift();\n        if (fn(descendant)) {\n            descendants.push(...descendant.children());\n        }\n    }\n}\n\nconst mask = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    tagName: 'rect',\n    className: 'highlight-mask',\n    attributes: {\n        'pointer-events': 'none'\n    },\n\n    options: {\n        padding: 3,\n        maskClip: MASK_CLIP,\n        deep: false,\n        attrs: {\n            'stroke': '#FEB663',\n            'stroke-width': 3,\n            'stroke-linecap': 'butt',\n            'stroke-linejoin': 'miter',\n        }\n    },\n\n    VISIBLE: 'white',\n    INVISIBLE: 'black',\n\n    MASK_ROOT_ATTRIBUTE_BLACKLIST: [\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'transform',\n        'stroke-dasharray',\n        'class',\n    ],\n\n    MASK_CHILD_ATTRIBUTE_BLACKLIST: [\n        'stroke',\n        'fill',\n        'stroke-width',\n        'stroke-opacity',\n        'stroke-dasharray',\n        'fill-opacity',\n        'marker-start',\n        'marker-end',\n        'marker-mid',\n        'class',\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REPLACE_TAGS: [\n        'FOREIGNOBJECT',\n        'IMAGE',\n        'USE',\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    // TODO: change the list to a function callback\n    MASK_REMOVE_TAGS: [\n        'TEXT',\n        'TSPAN',\n        'TEXTPATH'\n    ],\n\n    transformMaskChild(cellView, childEl) {\n        const {\n            MASK_CHILD_ATTRIBUTE_BLACKLIST,\n            MASK_REPLACE_TAGS,\n            MASK_REMOVE_TAGS\n        } = this;\n        const childTagName = childEl.tagName();\n        // Do not include the element in the mask's image\n        if (!_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSVGGraphicsElement(childEl) || MASK_REMOVE_TAGS.includes(childTagName)) {\n            childEl.remove();\n            return false;\n        }\n        // Replace the element with a rectangle\n        if (MASK_REPLACE_TAGS.includes(childTagName)) {\n            // Note: clone() method does not change the children ids\n            const originalChild = cellView.vel.findOne(`#${childEl.id}`);\n            if (originalChild) {\n                const { node: originalNode } = originalChild;\n                let childBBox = cellView.getNodeBoundingRect(originalNode);\n                if (cellView.model.isElement()) {\n                    childBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformRect(childBBox, cellView.getNodeMatrix(originalNode));\n                }\n                const replacement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('rect', childBBox.toJSON());\n                const { x: ox, y: oy } = childBBox.center();\n                const { angle, cx = ox, cy = oy } = originalChild.rotate();\n                if (angle) replacement.rotate(angle, cx, cy);\n                // Note: it's not important to keep the same sibling index since all subnodes are filled\n                childEl.parent().append(replacement);\n            }\n            childEl.remove();\n            return false;\n        }\n        // Keep the element, but clean it from certain attributes\n        MASK_CHILD_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            if (attrName === 'fill' && childEl.attr('fill') === 'none') return;\n            childEl.removeAttr(attrName);\n        });\n        return true;\n    },\n\n    transformMaskRoot(_cellView, rootEl) {\n        const { MASK_ROOT_ATTRIBUTE_BLACKLIST } = this;\n        MASK_ROOT_ATTRIBUTE_BLACKLIST.forEach(attrName => {\n            rootEl.removeAttr(attrName);\n        });\n    },\n\n    getMaskShape(cellView, vel) {\n        const { options, MASK_REPLACE_TAGS } = this;\n        const { deep } = options;\n        const tagName = vel.tagName();\n        let maskRoot;\n        if (tagName === 'G') {\n            if (!deep) return null;\n            maskRoot = vel.clone();\n            forEachDescendant(maskRoot, maskChild => this.transformMaskChild(cellView, maskChild));\n        } else {\n            if (MASK_REPLACE_TAGS.includes(tagName)) return null;\n            maskRoot = vel.clone();\n        }\n        this.transformMaskRoot(cellView, maskRoot);\n        return maskRoot;\n    },\n\n    getMaskId() {\n        return `highlight-mask-${this.cid}`;\n    },\n\n    getMask(cellView, vNode) {\n\n        const { VISIBLE, INVISIBLE, options } = this;\n        const { padding, attrs } = options;\n        // support both `strokeWidth` and `stroke-width` attribute names\n        const strokeWidth = parseFloat((0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('g').attr(attrs).attr('stroke-width'));\n        const hasNodeFill = vNode.attr('fill') !== 'none';\n        let magnetStrokeWidth = parseFloat(vNode.attr('stroke-width'));\n        if (isNaN(magnetStrokeWidth)) magnetStrokeWidth = 1;\n        // stroke of the invisible shape\n        const minStrokeWidth = magnetStrokeWidth + padding * 2;\n        // stroke of the visible shape\n        const maxStrokeWidth = minStrokeWidth + strokeWidth * 2;\n        let maskEl = this.getMaskShape(cellView, vNode);\n        if (!maskEl) {\n            const nodeBBox = cellView.getNodeBoundingRect(vNode.node);\n            // Make sure the rect is visible\n            nodeBBox.inflate(nodeBBox.width ? 0 : 0.5, nodeBBox.height ? 0 : 0.5);\n            maskEl =  (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('rect', nodeBBox.toJSON());\n        }\n        maskEl.attr(attrs);\n        return (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('mask', {\n            'id': this.getMaskId()\n        }).append([\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? VISIBLE : 'none',\n                'stroke': VISIBLE,\n                'stroke-width': maxStrokeWidth\n            }),\n            maskEl.clone().attr({\n                'fill': hasNodeFill ? INVISIBLE : 'none',\n                'stroke': INVISIBLE,\n                'stroke-width': minStrokeWidth\n            })\n        ]);\n    },\n\n    removeMask(paper) {\n        const maskNode = paper.svg.getElementById(this.getMaskId());\n        if (maskNode) {\n            paper.defs.removeChild(maskNode);\n        }\n    },\n\n    addMask(paper, maskEl) {\n        paper.defs.appendChild(maskEl.node);\n    },\n\n    highlight(cellView, node) {\n        const { options, vel } = this;\n        const { padding, attrs, maskClip = MASK_CLIP, layer } = options;\n        const color = ('stroke' in attrs) ? attrs['stroke'] : '#000000';\n        if (!layer && node === cellView.el) {\n            // If the highlighter is appended to the cellView\n            // and we measure the size of the cellView wrapping group\n            // it's necessary to remove the highlighter first\n            vel.remove();\n        }\n        const highlighterBBox = cellView.getNodeBoundingRect(node).inflate(padding + maskClip);\n        const highlightMatrix = this.getNodeMatrix(cellView, node);\n        const maskEl = this.getMask(cellView, (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node));\n        this.addMask(cellView.paper, maskEl);\n        vel.attr(highlighterBBox.toJSON());\n        vel.attr({\n            'transform': _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(highlightMatrix),\n            'mask': `url(#${maskEl.id})`,\n            'fill': color\n        });\n    },\n\n    unhighlight(cellView) {\n        this.removeMask(cellView.paper);\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL21hc2subWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUM4Qjs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLGFBQWEscUVBQWU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWEsb0RBQUM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsV0FBVztBQUN0RTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBLGdDQUFnQyxvREFBQztBQUNqQztBQUNBLG9DQUFvQyx3REFBQztBQUNyQyx3QkFBd0IsZUFBZTtBQUN2Qyx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDLEtBQUs7O0FBRUw7O0FBRUEsZ0JBQWdCLDhCQUE4QjtBQUM5QyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsdUNBQXVDLHdEQUFDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBQztBQUN2QjtBQUNBO0FBQ0EsZUFBZSx3REFBQztBQUNoQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3REFBQztBQUMvQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQUM7QUFDMUIsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9tYXNrLm1qcz9lZmY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4uL2RpYS9IaWdobGlnaHRlclZpZXcubWpzJztcblxuY29uc3QgTUFTS19DTElQID0gMjA7XG5cbmZ1bmN0aW9uIGZvckVhY2hEZXNjZW5kYW50KHZlbCwgZm4pIHtcbiAgICBjb25zdCBkZXNjZW5kYW50cyA9IHZlbC5jaGlsZHJlbigpO1xuICAgIHdoaWxlIChkZXNjZW5kYW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRlc2NlbmRhbnQgPSBkZXNjZW5kYW50cy5zaGlmdCgpO1xuICAgICAgICBpZiAoZm4oZGVzY2VuZGFudCkpIHtcbiAgICAgICAgICAgIGRlc2NlbmRhbnRzLnB1c2goLi4uZGVzY2VuZGFudC5jaGlsZHJlbigpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1hc2sgPSBIaWdobGlnaHRlclZpZXcuZXh0ZW5kKHtcblxuICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICBjbGFzc05hbWU6ICdoaWdobGlnaHQtbWFzaycsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICB9LFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiAzLFxuICAgICAgICBtYXNrQ2xpcDogTUFTS19DTElQLFxuICAgICAgICBkZWVwOiBmYWxzZSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICdzdHJva2UnOiAnI0ZFQjY2MycsXG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMyxcbiAgICAgICAgICAgICdzdHJva2UtbGluZWNhcCc6ICdidXR0JyxcbiAgICAgICAgICAgICdzdHJva2UtbGluZWpvaW4nOiAnbWl0ZXInLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIFZJU0lCTEU6ICd3aGl0ZScsXG4gICAgSU5WSVNJQkxFOiAnYmxhY2snLFxuXG4gICAgTUFTS19ST09UX0FUVFJJQlVURV9CTEFDS0xJU1Q6IFtcbiAgICAgICAgJ21hcmtlci1zdGFydCcsXG4gICAgICAgICdtYXJrZXItZW5kJyxcbiAgICAgICAgJ21hcmtlci1taWQnLFxuICAgICAgICAndHJhbnNmb3JtJyxcbiAgICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgICAgICAnY2xhc3MnLFxuICAgIF0sXG5cbiAgICBNQVNLX0NISUxEX0FUVFJJQlVURV9CTEFDS0xJU1Q6IFtcbiAgICAgICAgJ3N0cm9rZScsXG4gICAgICAgICdmaWxsJyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCcsXG4gICAgICAgICdzdHJva2Utb3BhY2l0eScsXG4gICAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgICAgJ2ZpbGwtb3BhY2l0eScsXG4gICAgICAgICdtYXJrZXItc3RhcnQnLFxuICAgICAgICAnbWFya2VyLWVuZCcsXG4gICAgICAgICdtYXJrZXItbWlkJyxcbiAgICAgICAgJ2NsYXNzJyxcbiAgICBdLFxuXG4gICAgLy8gVE9ETzogY2hhbmdlIHRoZSBsaXN0IHRvIGEgZnVuY3Rpb24gY2FsbGJhY2tcbiAgICBNQVNLX1JFUExBQ0VfVEFHUzogW1xuICAgICAgICAnRk9SRUlHTk9CSkVDVCcsXG4gICAgICAgICdJTUFHRScsXG4gICAgICAgICdVU0UnLFxuICAgICAgICAnVEVYVCcsXG4gICAgICAgICdUU1BBTicsXG4gICAgICAgICdURVhUUEFUSCdcbiAgICBdLFxuXG4gICAgLy8gVE9ETzogY2hhbmdlIHRoZSBsaXN0IHRvIGEgZnVuY3Rpb24gY2FsbGJhY2tcbiAgICBNQVNLX1JFTU9WRV9UQUdTOiBbXG4gICAgICAgICdURVhUJyxcbiAgICAgICAgJ1RTUEFOJyxcbiAgICAgICAgJ1RFWFRQQVRIJ1xuICAgIF0sXG5cbiAgICB0cmFuc2Zvcm1NYXNrQ2hpbGQoY2VsbFZpZXcsIGNoaWxkRWwpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgTUFTS19DSElMRF9BVFRSSUJVVEVfQkxBQ0tMSVNULFxuICAgICAgICAgICAgTUFTS19SRVBMQUNFX1RBR1MsXG4gICAgICAgICAgICBNQVNLX1JFTU9WRV9UQUdTXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjaGlsZFRhZ05hbWUgPSBjaGlsZEVsLnRhZ05hbWUoKTtcbiAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgdGhlIGVsZW1lbnQgaW4gdGhlIG1hc2sncyBpbWFnZVxuICAgICAgICBpZiAoIVYuaXNTVkdHcmFwaGljc0VsZW1lbnQoY2hpbGRFbCkgfHwgTUFTS19SRU1PVkVfVEFHUy5pbmNsdWRlcyhjaGlsZFRhZ05hbWUpKSB7XG4gICAgICAgICAgICBjaGlsZEVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGVsZW1lbnQgd2l0aCBhIHJlY3RhbmdsZVxuICAgICAgICBpZiAoTUFTS19SRVBMQUNFX1RBR1MuaW5jbHVkZXMoY2hpbGRUYWdOYW1lKSkge1xuICAgICAgICAgICAgLy8gTm90ZTogY2xvbmUoKSBtZXRob2QgZG9lcyBub3QgY2hhbmdlIHRoZSBjaGlsZHJlbiBpZHNcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hpbGQgPSBjZWxsVmlldy52ZWwuZmluZE9uZShgIyR7Y2hpbGRFbC5pZH1gKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlOiBvcmlnaW5hbE5vZGUgfSA9IG9yaWdpbmFsQ2hpbGQ7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qob3JpZ2luYWxOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbFZpZXcubW9kZWwuaXNFbGVtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gVi50cmFuc2Zvcm1SZWN0KGNoaWxkQkJveCwgY2VsbFZpZXcuZ2V0Tm9kZU1hdHJpeChvcmlnaW5hbE5vZGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBWKCdyZWN0JywgY2hpbGRCQm94LnRvSlNPTigpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IG94LCB5OiBveSB9ID0gY2hpbGRCQm94LmNlbnRlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYW5nbGUsIGN4ID0gb3gsIGN5ID0gb3kgfSA9IG9yaWdpbmFsQ2hpbGQucm90YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlKSByZXBsYWNlbWVudC5yb3RhdGUoYW5nbGUsIGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogaXQncyBub3QgaW1wb3J0YW50IHRvIGtlZXAgdGhlIHNhbWUgc2libGluZyBpbmRleCBzaW5jZSBhbGwgc3Vibm9kZXMgYXJlIGZpbGxlZFxuICAgICAgICAgICAgICAgIGNoaWxkRWwucGFyZW50KCkuYXBwZW5kKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCB0aGUgZWxlbWVudCwgYnV0IGNsZWFuIGl0IGZyb20gY2VydGFpbiBhdHRyaWJ1dGVzXG4gICAgICAgIE1BU0tfQ0hJTERfQVRUUklCVVRFX0JMQUNLTElTVC5mb3JFYWNoKGF0dHJOYW1lID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyTmFtZSA9PT0gJ2ZpbGwnICYmIGNoaWxkRWwuYXR0cignZmlsbCcpID09PSAnbm9uZScpIHJldHVybjtcbiAgICAgICAgICAgIGNoaWxkRWwucmVtb3ZlQXR0cihhdHRyTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtTWFza1Jvb3QoX2NlbGxWaWV3LCByb290RWwpIHtcbiAgICAgICAgY29uc3QgeyBNQVNLX1JPT1RfQVRUUklCVVRFX0JMQUNLTElTVCB9ID0gdGhpcztcbiAgICAgICAgTUFTS19ST09UX0FUVFJJQlVURV9CTEFDS0xJU1QuZm9yRWFjaChhdHRyTmFtZSA9PiB7XG4gICAgICAgICAgICByb290RWwucmVtb3ZlQXR0cihhdHRyTmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBnZXRNYXNrU2hhcGUoY2VsbFZpZXcsIHZlbCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIE1BU0tfUkVQTEFDRV9UQUdTIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGRlZXAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB2ZWwudGFnTmFtZSgpO1xuICAgICAgICBsZXQgbWFza1Jvb3Q7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnRycpIHtcbiAgICAgICAgICAgIGlmICghZGVlcCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBtYXNrUm9vdCA9IHZlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZm9yRWFjaERlc2NlbmRhbnQobWFza1Jvb3QsIG1hc2tDaGlsZCA9PiB0aGlzLnRyYW5zZm9ybU1hc2tDaGlsZChjZWxsVmlldywgbWFza0NoaWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTUFTS19SRVBMQUNFX1RBR1MuaW5jbHVkZXModGFnTmFtZSkpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbWFza1Jvb3QgPSB2ZWwuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hc2tSb290KGNlbGxWaWV3LCBtYXNrUm9vdCk7XG4gICAgICAgIHJldHVybiBtYXNrUm9vdDtcbiAgICB9LFxuXG4gICAgZ2V0TWFza0lkKCkge1xuICAgICAgICByZXR1cm4gYGhpZ2hsaWdodC1tYXNrLSR7dGhpcy5jaWR9YDtcbiAgICB9LFxuXG4gICAgZ2V0TWFzayhjZWxsVmlldywgdk5vZGUpIHtcblxuICAgICAgICBjb25zdCB7IFZJU0lCTEUsIElOVklTSUJMRSwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nLCBhdHRycyB9ID0gb3B0aW9ucztcbiAgICAgICAgLy8gc3VwcG9ydCBib3RoIGBzdHJva2VXaWR0aGAgYW5kIGBzdHJva2Utd2lkdGhgIGF0dHJpYnV0ZSBuYW1lc1xuICAgICAgICBjb25zdCBzdHJva2VXaWR0aCA9IHBhcnNlRmxvYXQoVignZycpLmF0dHIoYXR0cnMpLmF0dHIoJ3N0cm9rZS13aWR0aCcpKTtcbiAgICAgICAgY29uc3QgaGFzTm9kZUZpbGwgPSB2Tm9kZS5hdHRyKCdmaWxsJykgIT09ICdub25lJztcbiAgICAgICAgbGV0IG1hZ25ldFN0cm9rZVdpZHRoID0gcGFyc2VGbG9hdCh2Tm9kZS5hdHRyKCdzdHJva2Utd2lkdGgnKSk7XG4gICAgICAgIGlmIChpc05hTihtYWduZXRTdHJva2VXaWR0aCkpIG1hZ25ldFN0cm9rZVdpZHRoID0gMTtcbiAgICAgICAgLy8gc3Ryb2tlIG9mIHRoZSBpbnZpc2libGUgc2hhcGVcbiAgICAgICAgY29uc3QgbWluU3Ryb2tlV2lkdGggPSBtYWduZXRTdHJva2VXaWR0aCArIHBhZGRpbmcgKiAyO1xuICAgICAgICAvLyBzdHJva2Ugb2YgdGhlIHZpc2libGUgc2hhcGVcbiAgICAgICAgY29uc3QgbWF4U3Ryb2tlV2lkdGggPSBtaW5TdHJva2VXaWR0aCArIHN0cm9rZVdpZHRoICogMjtcbiAgICAgICAgbGV0IG1hc2tFbCA9IHRoaXMuZ2V0TWFza1NoYXBlKGNlbGxWaWV3LCB2Tm9kZSk7XG4gICAgICAgIGlmICghbWFza0VsKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qodk5vZGUubm9kZSk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlY3QgaXMgdmlzaWJsZVxuICAgICAgICAgICAgbm9kZUJCb3guaW5mbGF0ZShub2RlQkJveC53aWR0aCA/IDAgOiAwLjUsIG5vZGVCQm94LmhlaWdodCA/IDAgOiAwLjUpO1xuICAgICAgICAgICAgbWFza0VsID0gIFYoJ3JlY3QnLCBub2RlQkJveC50b0pTT04oKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFza0VsLmF0dHIoYXR0cnMpO1xuICAgICAgICByZXR1cm4gVignbWFzaycsIHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMuZ2V0TWFza0lkKClcbiAgICAgICAgfSkuYXBwZW5kKFtcbiAgICAgICAgICAgIG1hc2tFbC5jbG9uZSgpLmF0dHIoe1xuICAgICAgICAgICAgICAgICdmaWxsJzogaGFzTm9kZUZpbGwgPyBWSVNJQkxFIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiBWSVNJQkxFLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiBtYXhTdHJva2VXaWR0aFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXNrRWwuY2xvbmUoKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAnZmlsbCc6IGhhc05vZGVGaWxsID8gSU5WSVNJQkxFIDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiBJTlZJU0lCTEUsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IG1pblN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlTWFzayhwYXBlcikge1xuICAgICAgICBjb25zdCBtYXNrTm9kZSA9IHBhcGVyLnN2Zy5nZXRFbGVtZW50QnlJZCh0aGlzLmdldE1hc2tJZCgpKTtcbiAgICAgICAgaWYgKG1hc2tOb2RlKSB7XG4gICAgICAgICAgICBwYXBlci5kZWZzLnJlbW92ZUNoaWxkKG1hc2tOb2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRNYXNrKHBhcGVyLCBtYXNrRWwpIHtcbiAgICAgICAgcGFwZXIuZGVmcy5hcHBlbmRDaGlsZChtYXNrRWwubm9kZSk7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodChjZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nLCBhdHRycywgbWFza0NsaXAgPSBNQVNLX0NMSVAsIGxheWVyIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjb2xvciA9ICgnc3Ryb2tlJyBpbiBhdHRycykgPyBhdHRyc1snc3Ryb2tlJ10gOiAnIzAwMDAwMCc7XG4gICAgICAgIGlmICghbGF5ZXIgJiYgbm9kZSA9PT0gY2VsbFZpZXcuZWwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBoaWdobGlnaHRlciBpcyBhcHBlbmRlZCB0byB0aGUgY2VsbFZpZXdcbiAgICAgICAgICAgIC8vIGFuZCB3ZSBtZWFzdXJlIHRoZSBzaXplIG9mIHRoZSBjZWxsVmlldyB3cmFwcGluZyBncm91cFxuICAgICAgICAgICAgLy8gaXQncyBuZWNlc3NhcnkgdG8gcmVtb3ZlIHRoZSBoaWdobGlnaHRlciBmaXJzdFxuICAgICAgICAgICAgdmVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodGVyQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qobm9kZSkuaW5mbGF0ZShwYWRkaW5nICsgbWFza0NsaXApO1xuICAgICAgICBjb25zdCBoaWdobGlnaHRNYXRyaXggPSB0aGlzLmdldE5vZGVNYXRyaXgoY2VsbFZpZXcsIG5vZGUpO1xuICAgICAgICBjb25zdCBtYXNrRWwgPSB0aGlzLmdldE1hc2soY2VsbFZpZXcsIFYobm9kZSkpO1xuICAgICAgICB0aGlzLmFkZE1hc2soY2VsbFZpZXcucGFwZXIsIG1hc2tFbCk7XG4gICAgICAgIHZlbC5hdHRyKGhpZ2hsaWdodGVyQkJveC50b0pTT04oKSk7XG4gICAgICAgIHZlbC5hdHRyKHtcbiAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKGhpZ2hsaWdodE1hdHJpeCksXG4gICAgICAgICAgICAnbWFzayc6IGB1cmwoIyR7bWFza0VsLmlkfSlgLFxuICAgICAgICAgICAgJ2ZpbGwnOiBjb2xvclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgdW5oaWdobGlnaHQoY2VsbFZpZXcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVNYXNrKGNlbGxWaWV3LnBhcGVyKTtcbiAgICB9XG5cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/highlighters/mask.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/highlighters/opacity.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/opacity.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   opacity: function() { return /* binding */ opacity; }\n/* harmony export */ });\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\nconst opacity = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    UPDATABLE: false,\n    MOUNTABLE: false,\n\n    highlight: function(_cellView, node) {\n        const { alphaValue = 0.3 } = this.options;\n        node.style.opacity = alphaValue;\n    },\n\n    unhighlight: function(_cellView, node) {\n        node.style.opacity = '';\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL29wYWNpdHkubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZEOztBQUV0RCxnQkFBZ0IscUVBQWU7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL2hpZ2hsaWdodGVycy9vcGFjaXR5Lm1qcz9iYmM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4uL2RpYS9IaWdobGlnaHRlclZpZXcubWpzJztcblxuZXhwb3J0IGNvbnN0IG9wYWNpdHkgPSBIaWdobGlnaHRlclZpZXcuZXh0ZW5kKHtcblxuICAgIFVQREFUQUJMRTogZmFsc2UsXG4gICAgTU9VTlRBQkxFOiBmYWxzZSxcblxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oX2NlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgYWxwaGFWYWx1ZSA9IDAuMyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSBhbHBoYVZhbHVlO1xuICAgIH0sXG5cbiAgICB1bmhpZ2hsaWdodDogZnVuY3Rpb24oX2NlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIG5vZGUuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/highlighters/opacity.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/highlighters/stroke.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/highlighters/stroke.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stroke: function() { return /* binding */ stroke; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/HighlighterView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/HighlighterView.mjs\");\n\n\n\n\nconst stroke = _dia_HighlighterView_mjs__WEBPACK_IMPORTED_MODULE_0__.HighlighterView.extend({\n\n    tagName: 'path',\n    className: 'highlight-stroke',\n    attributes: {\n        'pointer-events': 'none',\n        'fill': 'none'\n    },\n\n    options: {\n        padding: 3,\n        rx: 0,\n        ry: 0,\n        useFirstSubpath: false,\n        attrs: {\n            'stroke-width': 3,\n            'stroke': '#FEB663'\n        }\n    },\n\n    getPathData(cellView, node) {\n        const { options } = this;\n        const { useFirstSubpath } = options;\n        let d;\n        try {\n            const vNode = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node);\n            d = vNode.convertToPathData().trim();\n            if (vNode.tagName() === 'PATH' && useFirstSubpath) {\n                const secondSubpathIndex = d.search(/.M/i) + 1;\n                if (secondSubpathIndex > 0) {\n                    d = d.substr(0, secondSubpathIndex);\n                }\n            }\n        } catch (error) {\n            // Failed to get path data from magnet element.\n            // Draw a rectangle around the node instead.\n            const nodeBBox = cellView.getNodeBoundingRect(node);\n            d = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rectToPath((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.assign)({}, options, nodeBBox.toJSON()));\n        }\n        return d;\n    },\n\n    highlightConnection(cellView) {\n        this.vel.attr('d', cellView.getSerializedConnection());\n    },\n\n    highlightNode(cellView, node) {\n        const { vel, options } = this;\n        const { padding, layer } = options;\n        let highlightMatrix = this.getNodeMatrix(cellView, node);\n        // Add padding to the highlight element.\n        if (padding) {\n            if (!layer && node === cellView.el) {\n                // If the highlighter is appended to the cellView\n                // and we measure the size of the cellView wrapping group\n                // it's necessary to remove the highlighter first\n                vel.remove();\n            }\n            let nodeBBox = cellView.getNodeBoundingRect(node);\n            const cx = nodeBBox.x + (nodeBBox.width / 2);\n            const cy = nodeBBox.y + (nodeBBox.height / 2);\n            nodeBBox = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformRect(nodeBBox, highlightMatrix);\n            const width = Math.max(nodeBBox.width, 1);\n            const height = Math.max(nodeBBox.height, 1);\n            const sx = (width + padding) / width;\n            const sy = (height + padding) / height;\n            const paddingMatrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix({\n                a: sx,\n                b: 0,\n                c: 0,\n                d: sy,\n                e: cx - sx * cx,\n                f: cy - sy * cy\n            });\n            highlightMatrix = highlightMatrix.multiply(paddingMatrix);\n        }\n        vel.attr({\n            'd': this.getPathData(cellView, node),\n            'transform': _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(highlightMatrix)\n        });\n    },\n\n    highlight(cellView, node) {\n        const { vel, options } = this;\n        vel.attr(options.attrs);\n        if (options.nonScalingStroke) {\n            vel.attr('vector-effect', 'non-scaling-stroke');\n        }\n        if (cellView.isNodeConnection(node)) {\n            this.highlightConnection(cellView);\n        } else {\n            this.highlightNode(cellView, node);\n        }\n    }\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvaGlnaGxpZ2h0ZXJzL3N0cm9rZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyQztBQUNaO0FBQzhCOztBQUV0RCxlQUFlLHFFQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0EsMEJBQTBCLHdEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBQyxZQUFZLHVEQUFNLEdBQUc7QUFDdEM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvREFBQztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQUM7QUFDMUIsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9oaWdobGlnaHRlcnMvc3Ryb2tlLm1qcz9jMTdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IEhpZ2hsaWdodGVyVmlldyB9IGZyb20gJy4uL2RpYS9IaWdobGlnaHRlclZpZXcubWpzJztcblxuZXhwb3J0IGNvbnN0IHN0cm9rZSA9IEhpZ2hsaWdodGVyVmlldy5leHRlbmQoe1xuXG4gICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgIGNsYXNzTmFtZTogJ2hpZ2hsaWdodC1zdHJva2UnLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAnZmlsbCc6ICdub25lJ1xuICAgIH0sXG5cbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBhZGRpbmc6IDMsXG4gICAgICAgIHJ4OiAwLFxuICAgICAgICByeTogMCxcbiAgICAgICAgdXNlRmlyc3RTdWJwYXRoOiBmYWxzZSxcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAzLFxuICAgICAgICAgICAgJ3N0cm9rZSc6ICcjRkVCNjYzJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFBhdGhEYXRhKGNlbGxWaWV3LCBub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB1c2VGaXJzdFN1YnBhdGggfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgdk5vZGUgPSBWKG5vZGUpO1xuICAgICAgICAgICAgZCA9IHZOb2RlLmNvbnZlcnRUb1BhdGhEYXRhKCkudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHZOb2RlLnRhZ05hbWUoKSA9PT0gJ1BBVEgnICYmIHVzZUZpcnN0U3VicGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZFN1YnBhdGhJbmRleCA9IGQuc2VhcmNoKC8uTS9pKSArIDE7XG4gICAgICAgICAgICAgICAgaWYgKHNlY29uZFN1YnBhdGhJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQuc3Vic3RyKDAsIHNlY29uZFN1YnBhdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gRmFpbGVkIHRvIGdldCBwYXRoIGRhdGEgZnJvbSBtYWduZXQgZWxlbWVudC5cbiAgICAgICAgICAgIC8vIERyYXcgYSByZWN0YW5nbGUgYXJvdW5kIHRoZSBub2RlIGluc3RlYWQuXG4gICAgICAgICAgICBjb25zdCBub2RlQkJveCA9IGNlbGxWaWV3LmdldE5vZGVCb3VuZGluZ1JlY3Qobm9kZSk7XG4gICAgICAgICAgICBkID0gVi5yZWN0VG9QYXRoKGFzc2lnbih7fSwgb3B0aW9ucywgbm9kZUJCb3gudG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0Q29ubmVjdGlvbihjZWxsVmlldykge1xuICAgICAgICB0aGlzLnZlbC5hdHRyKCdkJywgY2VsbFZpZXcuZ2V0U2VyaWFsaXplZENvbm5lY3Rpb24oKSk7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodE5vZGUoY2VsbFZpZXcsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgeyB2ZWwsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGFkZGluZywgbGF5ZXIgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBoaWdobGlnaHRNYXRyaXggPSB0aGlzLmdldE5vZGVNYXRyaXgoY2VsbFZpZXcsIG5vZGUpO1xuICAgICAgICAvLyBBZGQgcGFkZGluZyB0byB0aGUgaGlnaGxpZ2h0IGVsZW1lbnQuXG4gICAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgICAgICBpZiAoIWxheWVyICYmIG5vZGUgPT09IGNlbGxWaWV3LmVsKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhpZ2hsaWdodGVyIGlzIGFwcGVuZGVkIHRvIHRoZSBjZWxsVmlld1xuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBtZWFzdXJlIHRoZSBzaXplIG9mIHRoZSBjZWxsVmlldyB3cmFwcGluZyBncm91cFxuICAgICAgICAgICAgICAgIC8vIGl0J3MgbmVjZXNzYXJ5IHRvIHJlbW92ZSB0aGUgaGlnaGxpZ2h0ZXIgZmlyc3RcbiAgICAgICAgICAgICAgICB2ZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbm9kZUJCb3ggPSBjZWxsVmlldy5nZXROb2RlQm91bmRpbmdSZWN0KG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgY3ggPSBub2RlQkJveC54ICsgKG5vZGVCQm94LndpZHRoIC8gMik7XG4gICAgICAgICAgICBjb25zdCBjeSA9IG5vZGVCQm94LnkgKyAobm9kZUJCb3guaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBub2RlQkJveCA9IFYudHJhbnNmb3JtUmVjdChub2RlQkJveCwgaGlnaGxpZ2h0TWF0cml4KTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgobm9kZUJCb3gud2lkdGgsIDEpO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgobm9kZUJCb3guaGVpZ2h0LCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHN4ID0gKHdpZHRoICsgcGFkZGluZykgLyB3aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IHN5ID0gKGhlaWdodCArIHBhZGRpbmcpIC8gaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZ01hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KHtcbiAgICAgICAgICAgICAgICBhOiBzeCxcbiAgICAgICAgICAgICAgICBiOiAwLFxuICAgICAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICAgICAgZDogc3ksXG4gICAgICAgICAgICAgICAgZTogY3ggLSBzeCAqIGN4LFxuICAgICAgICAgICAgICAgIGY6IGN5IC0gc3kgKiBjeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoaWdobGlnaHRNYXRyaXggPSBoaWdobGlnaHRNYXRyaXgubXVsdGlwbHkocGFkZGluZ01hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgdmVsLmF0dHIoe1xuICAgICAgICAgICAgJ2QnOiB0aGlzLmdldFBhdGhEYXRhKGNlbGxWaWV3LCBub2RlKSxcbiAgICAgICAgICAgICd0cmFuc2Zvcm0nOiBWLm1hdHJpeFRvVHJhbnNmb3JtU3RyaW5nKGhpZ2hsaWdodE1hdHJpeClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGhpZ2hsaWdodChjZWxsVmlldywgbm9kZSkge1xuICAgICAgICBjb25zdCB7IHZlbCwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgdmVsLmF0dHIob3B0aW9ucy5hdHRycyk7XG4gICAgICAgIGlmIChvcHRpb25zLm5vblNjYWxpbmdTdHJva2UpIHtcbiAgICAgICAgICAgIHZlbC5hdHRyKCd2ZWN0b3ItZWZmZWN0JywgJ25vbi1zY2FsaW5nLXN0cm9rZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsVmlldy5pc05vZGVDb25uZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodENvbm5lY3Rpb24oY2VsbFZpZXcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHROb2RlKGNlbGxWaWV3LCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/highlighters/stroke.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/port.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/layout/ports/port.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolute: function() { return /* binding */ absolute; },\n/* harmony export */   bottom: function() { return /* binding */ bottom; },\n/* harmony export */   ellipse: function() { return /* binding */ ellipse; },\n/* harmony export */   ellipseSpread: function() { return /* binding */ ellipseSpread; },\n/* harmony export */   fn: function() { return /* binding */ fn; },\n/* harmony export */   left: function() { return /* binding */ left; },\n/* harmony export */   line: function() { return /* binding */ line; },\n/* harmony export */   right: function() { return /* binding */ right; },\n/* harmony export */   top: function() { return /* binding */ top; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/ellipse.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\");\n\n\n\nfunction portTransformAttrs(point, angle, opt) {\n\n    var trans = point.toJSON();\n\n    trans.angle = angle || 0;\n\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, trans);\n}\n\nfunction lineLayout(ports, p1, p2, elBBox) {\n    return ports.map(function(port, index, ports) {\n        var p = this.pointAt(((index + 0.5) / ports.length));\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p.offset(port.dx || 0, port.dy || 0);\n        }\n        return portTransformAttrs(p.round(), 0, argTransform(elBBox, port));\n    }, _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.line(p1, p2));\n}\n\nfunction ellipseLayout(ports, elBBox, startAngle, stepFn) {\n\n    var center = elBBox.center();\n    var ratio = elBBox.width / elBBox.height;\n    var p1 = elBBox.topMiddle();\n\n    var ellipse = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Ellipse.fromRect(elBBox);\n\n    return ports.map(function(port, index, ports) {\n\n        var angle = startAngle + stepFn(index, ports.length);\n        var p2 = p1.clone()\n            .rotate(center, -angle)\n            .scale(ratio, 1, center);\n\n        var theta = port.compensateRotation ? -ellipse.tangentTheta(p2) : 0;\n\n        // `dx`,`dy` per port offset option\n        if (port.dx || port.dy) {\n            p2.offset(port.dx || 0, port.dy || 0);\n        }\n\n        // `dr` delta radius option\n        if (port.dr) {\n            p2.move(center, port.dr);\n        }\n\n        return portTransformAttrs(p2.round(), theta, argTransform(elBBox, port));\n    });\n}\n\n\nfunction argTransform(bbox, args) {\n    let { x, y, angle } = args;\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage(x)) {\n        x = parseFloat(x) / 100 * bbox.width;\n    } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression(x)) {\n        x = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression(x, bbox));\n    }\n    if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isPercentage(y)) {\n        y = parseFloat(y) / 100 * bbox.height;\n    } else if (_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression(y)) {\n        y = Number(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression(y, bbox));\n    }\n    return { x, y, angle };\n}\n\n// Creates a point stored in arguments\nfunction argPoint(bbox, args) {\n    const { x, y } = argTransform(bbox, args);\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Point(x || 0, y || 0);\n}\n\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst absolute = function(ports, elBBox) {\n    return ports.map(port => {\n        const transformation = argPoint(elBBox, port).round().toJSON();\n        transformation.angle = port.angle || 0;\n        return transformation;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst fn = function(ports, elBBox, opt) {\n    return opt.fn(ports, elBBox, opt);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst line = function(ports, elBBox, opt) {\n\n    var start = argPoint(elBBox, opt.start || elBBox.origin());\n    var end = argPoint(elBBox, opt.end || elBBox.corner());\n\n    return lineLayout(ports, start, end, elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst left = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.bottomLeft(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst right = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.topRight(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst top = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.origin(), elBBox.topRight(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt opt Group options\n * @returns {Array<g.Point>}\n */\nconst bottom = function(ports, elBBox, opt) {\n    return lineLayout(ports, elBBox.bottomLeft(), elBBox.corner(), elBBox);\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nconst ellipseSpread = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 360 / ports.length;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index) {\n        return index * stepAngle;\n    });\n};\n\n/**\n * @param {Array<Object>} ports\n * @param {g.Rect} elBBox\n * @param {Object=} opt Group options\n * @returns {Array<g.Point>}\n */\nconst ellipse = function(ports, elBBox, opt) {\n\n    var startAngle = opt.startAngle || 0;\n    var stepAngle = opt.step || 20;\n\n    return ellipseLayout(ports, elBBox, startAngle, function(index, count) {\n        return (index + 0.5 - count / 2) * stepAngle;\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGF5b3V0L3BvcnRzL3BvcnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNNOztBQUU3Qzs7QUFFQTs7QUFFQTs7QUFFQSxXQUFXLHFEQUFhLEdBQUc7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSw4Q0FBTTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaURBQVM7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLFVBQVUsY0FBYztBQUN4QixRQUFRLHlEQUFpQjtBQUN6QjtBQUNBLE1BQU0sU0FBUyw2REFBcUI7QUFDcEMsbUJBQW1CLCtEQUF1QjtBQUMxQztBQUNBLFFBQVEseURBQWlCO0FBQ3pCO0FBQ0EsTUFBTSxTQUFTLDZEQUFxQjtBQUNwQyxtQkFBbUIsK0RBQXVCO0FBQzFDO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsZUFBZSwrQ0FBTztBQUN0Qjs7O0FBR0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ087O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGF5b3V0L3BvcnRzL3BvcnQubWpzPzNmNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi8uLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uLy4uL3V0aWwvaW5kZXgubWpzJztcblxuZnVuY3Rpb24gcG9ydFRyYW5zZm9ybUF0dHJzKHBvaW50LCBhbmdsZSwgb3B0KSB7XG5cbiAgICB2YXIgdHJhbnMgPSBwb2ludC50b0pTT04oKTtcblxuICAgIHRyYW5zLmFuZ2xlID0gYW5nbGUgfHwgMDtcblxuICAgIHJldHVybiB1dGlsLmRlZmF1bHRzKHt9LCBvcHQsIHRyYW5zKTtcbn1cblxuZnVuY3Rpb24gbGluZUxheW91dChwb3J0cywgcDEsIHAyLCBlbEJCb3gpIHtcbiAgICByZXR1cm4gcG9ydHMubWFwKGZ1bmN0aW9uKHBvcnQsIGluZGV4LCBwb3J0cykge1xuICAgICAgICB2YXIgcCA9IHRoaXMucG9pbnRBdCgoKGluZGV4ICsgMC41KSAvIHBvcnRzLmxlbmd0aCkpO1xuICAgICAgICAvLyBgZHhgLGBkeWAgcGVyIHBvcnQgb2Zmc2V0IG9wdGlvblxuICAgICAgICBpZiAocG9ydC5keCB8fCBwb3J0LmR5KSB7XG4gICAgICAgICAgICBwLm9mZnNldChwb3J0LmR4IHx8IDAsIHBvcnQuZHkgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcnRUcmFuc2Zvcm1BdHRycyhwLnJvdW5kKCksIDAsIGFyZ1RyYW5zZm9ybShlbEJCb3gsIHBvcnQpKTtcbiAgICB9LCBnLmxpbmUocDEsIHAyKSk7XG59XG5cbmZ1bmN0aW9uIGVsbGlwc2VMYXlvdXQocG9ydHMsIGVsQkJveCwgc3RhcnRBbmdsZSwgc3RlcEZuKSB7XG5cbiAgICB2YXIgY2VudGVyID0gZWxCQm94LmNlbnRlcigpO1xuICAgIHZhciByYXRpbyA9IGVsQkJveC53aWR0aCAvIGVsQkJveC5oZWlnaHQ7XG4gICAgdmFyIHAxID0gZWxCQm94LnRvcE1pZGRsZSgpO1xuXG4gICAgdmFyIGVsbGlwc2UgPSBnLkVsbGlwc2UuZnJvbVJlY3QoZWxCQm94KTtcblxuICAgIHJldHVybiBwb3J0cy5tYXAoZnVuY3Rpb24ocG9ydCwgaW5kZXgsIHBvcnRzKSB7XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gc3RhcnRBbmdsZSArIHN0ZXBGbihpbmRleCwgcG9ydHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHAyID0gcDEuY2xvbmUoKVxuICAgICAgICAgICAgLnJvdGF0ZShjZW50ZXIsIC1hbmdsZSlcbiAgICAgICAgICAgIC5zY2FsZShyYXRpbywgMSwgY2VudGVyKTtcblxuICAgICAgICB2YXIgdGhldGEgPSBwb3J0LmNvbXBlbnNhdGVSb3RhdGlvbiA/IC1lbGxpcHNlLnRhbmdlbnRUaGV0YShwMikgOiAwO1xuXG4gICAgICAgIC8vIGBkeGAsYGR5YCBwZXIgcG9ydCBvZmZzZXQgb3B0aW9uXG4gICAgICAgIGlmIChwb3J0LmR4IHx8IHBvcnQuZHkpIHtcbiAgICAgICAgICAgIHAyLm9mZnNldChwb3J0LmR4IHx8IDAsIHBvcnQuZHkgfHwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBgZHJgIGRlbHRhIHJhZGl1cyBvcHRpb25cbiAgICAgICAgaWYgKHBvcnQuZHIpIHtcbiAgICAgICAgICAgIHAyLm1vdmUoY2VudGVyLCBwb3J0LmRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3J0VHJhbnNmb3JtQXR0cnMocDIucm91bmQoKSwgdGhldGEsIGFyZ1RyYW5zZm9ybShlbEJCb3gsIHBvcnQpKTtcbiAgICB9KTtcbn1cblxuXG5mdW5jdGlvbiBhcmdUcmFuc2Zvcm0oYmJveCwgYXJncykge1xuICAgIGxldCB7IHgsIHksIGFuZ2xlIH0gPSBhcmdzO1xuICAgIGlmICh1dGlsLmlzUGVyY2VudGFnZSh4KSkge1xuICAgICAgICB4ID0gcGFyc2VGbG9hdCh4KSAvIDEwMCAqIGJib3gud2lkdGg7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzQ2FsY0V4cHJlc3Npb24oeCkpIHtcbiAgICAgICAgeCA9IE51bWJlcih1dGlsLmV2YWxDYWxjRXhwcmVzc2lvbih4LCBiYm94KSk7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzUGVyY2VudGFnZSh5KSkge1xuICAgICAgICB5ID0gcGFyc2VGbG9hdCh5KSAvIDEwMCAqIGJib3guaGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc0NhbGNFeHByZXNzaW9uKHkpKSB7XG4gICAgICAgIHkgPSBOdW1iZXIodXRpbC5ldmFsQ2FsY0V4cHJlc3Npb24oeSwgYmJveCkpO1xuICAgIH1cbiAgICByZXR1cm4geyB4LCB5LCBhbmdsZSB9O1xufVxuXG4vLyBDcmVhdGVzIGEgcG9pbnQgc3RvcmVkIGluIGFyZ3VtZW50c1xuZnVuY3Rpb24gYXJnUG9pbnQoYmJveCwgYXJncykge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYXJnVHJhbnNmb3JtKGJib3gsIGFyZ3MpO1xuICAgIHJldHVybiBuZXcgZy5Qb2ludCh4IHx8IDAsIHkgfHwgMCk7XG59XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBvcHQgR3JvdXAgb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5PGcuUG9pbnQ+fVxuICovXG5leHBvcnQgY29uc3QgYWJzb2x1dGUgPSBmdW5jdGlvbihwb3J0cywgZWxCQm94KSB7XG4gICAgcmV0dXJuIHBvcnRzLm1hcChwb3J0ID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb24gPSBhcmdQb2ludChlbEJCb3gsIHBvcnQpLnJvdW5kKCkudG9KU09OKCk7XG4gICAgICAgIHRyYW5zZm9ybWF0aW9uLmFuZ2xlID0gcG9ydC5hbmdsZSB8fCAwO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtYXRpb247XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBmbiA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBvcHQuZm4ocG9ydHMsIGVsQkJveCwgb3B0KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgb3B0IEdyb3VwIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheTxnLlBvaW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxpbmUgPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcblxuICAgIHZhciBzdGFydCA9IGFyZ1BvaW50KGVsQkJveCwgb3B0LnN0YXJ0IHx8IGVsQkJveC5vcmlnaW4oKSk7XG4gICAgdmFyIGVuZCA9IGFyZ1BvaW50KGVsQkJveCwgb3B0LmVuZCB8fCBlbEJCb3guY29ybmVyKCkpO1xuXG4gICAgcmV0dXJuIGxpbmVMYXlvdXQocG9ydHMsIHN0YXJ0LCBlbmQsIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBsZWZ0ID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxpbmVMYXlvdXQocG9ydHMsIGVsQkJveC5vcmlnaW4oKSwgZWxCQm94LmJvdHRvbUxlZnQoKSwgZWxCQm94KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgb3B0IEdyb3VwIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheTxnLlBvaW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJpZ2h0ID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxpbmVMYXlvdXQocG9ydHMsIGVsQkJveC50b3BSaWdodCgpLCBlbEJCb3guY29ybmVyKCksIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCB0b3AgPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gbGluZUxheW91dChwb3J0cywgZWxCQm94Lm9yaWdpbigpLCBlbEJCb3gudG9wUmlnaHQoKSwgZWxCQm94KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb3J0c1xuICogQHBhcmFtIHtnLlJlY3R9IGVsQkJveFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHQgb3B0IEdyb3VwIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheTxnLlBvaW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJvdHRvbSA9IGZ1bmN0aW9uKHBvcnRzLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsaW5lTGF5b3V0KHBvcnRzLCBlbEJCb3guYm90dG9tTGVmdCgpLCBlbEJCb3guY29ybmVyKCksIGVsQkJveCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9ydHNcbiAqIEBwYXJhbSB7Zy5SZWN0fSBlbEJCb3hcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0IEdyb3VwIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheTxnLlBvaW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVsbGlwc2VTcHJlYWQgPSBmdW5jdGlvbihwb3J0cywgZWxCQm94LCBvcHQpIHtcblxuICAgIHZhciBzdGFydEFuZ2xlID0gb3B0LnN0YXJ0QW5nbGUgfHwgMDtcbiAgICB2YXIgc3RlcEFuZ2xlID0gb3B0LnN0ZXAgfHwgMzYwIC8gcG9ydHMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGVsbGlwc2VMYXlvdXQocG9ydHMsIGVsQkJveCwgc3RhcnRBbmdsZSwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICogc3RlcEFuZ2xlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IHBvcnRzXG4gKiBAcGFyYW0ge2cuUmVjdH0gZWxCQm94XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBHcm91cCBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXk8Zy5Qb2ludD59XG4gKi9cbmV4cG9ydCBjb25zdCBlbGxpcHNlID0gZnVuY3Rpb24ocG9ydHMsIGVsQkJveCwgb3B0KSB7XG5cbiAgICB2YXIgc3RhcnRBbmdsZSA9IG9wdC5zdGFydEFuZ2xlIHx8IDA7XG4gICAgdmFyIHN0ZXBBbmdsZSA9IG9wdC5zdGVwIHx8IDIwO1xuXG4gICAgcmV0dXJuIGVsbGlwc2VMYXlvdXQocG9ydHMsIGVsQkJveCwgc3RhcnRBbmdsZSwgZnVuY3Rpb24oaW5kZXgsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiAoaW5kZXggKyAwLjUgLSBjb3VudCAvIDIpICogc3RlcEFuZ2xlO1xuICAgIH0pO1xufTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/port.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@joint/core/src/layout/ports/portLabel.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bottom: function() { return /* binding */ bottom; },\n/* harmony export */   inside: function() { return /* binding */ inside; },\n/* harmony export */   insideOriented: function() { return /* binding */ insideOriented; },\n/* harmony export */   left: function() { return /* binding */ left; },\n/* harmony export */   manual: function() { return /* binding */ manual; },\n/* harmony export */   outside: function() { return /* binding */ outside; },\n/* harmony export */   outsideOriented: function() { return /* binding */ outsideOriented; },\n/* harmony export */   radial: function() { return /* binding */ radial; },\n/* harmony export */   radialOriented: function() { return /* binding */ radialOriented; },\n/* harmony export */   right: function() { return /* binding */ right; },\n/* harmony export */   top: function() { return /* binding */ top; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\nfunction labelAttributes(opt1, opt2) {\n\n    // use value from `opt2` if it is missing in `opt1`\n    // use value from this object if it is missing in `opt2` as well\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaultsDeep({}, opt1, opt2, {\n        x: 0,\n        y: 0,\n        angle: 0,\n        attrs: {}\n    });\n}\n\nfunction getBBoxAngles(elBBox) {\n\n    var center = elBBox.center();\n\n    var tl = center.theta(elBBox.origin());\n    var bl = center.theta(elBBox.bottomLeft());\n    var br = center.theta(elBBox.corner());\n    var tr = center.theta(elBBox.topRight());\n\n    return [tl, tr, br, bl];\n}\n\nfunction outsideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction insideLayout(portPosition, elBBox, autoOrient, opt) {\n\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, { offset: 15 });\n    var angle = elBBox.center().theta(portPosition);\n\n    var tx, ty, y, textAnchor;\n    var offset = opt.offset;\n    var orientAngle = 0;\n\n    const [topLeftAngle, bottomLeftAngle, bottomRightAngle, topRightAngle] = getBBoxAngles(elBBox);\n    if ((angle < bottomLeftAngle) || (angle > bottomRightAngle)) {\n        y = '.3em';\n        tx = -offset;\n        ty = 0;\n        textAnchor = 'end';\n    } else if (angle < topLeftAngle) {\n        tx = 0;\n        ty = offset;\n        if (autoOrient) {\n            orientAngle = 90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '.6em';\n        }\n    } else if (angle < topRightAngle) {\n        y = '.3em';\n        tx = offset;\n        ty = 0;\n        textAnchor = 'start';\n    } else {\n        tx = 0;\n        ty = -offset;\n        if (autoOrient) {\n            orientAngle = -90;\n            textAnchor = 'start';\n            y = '.3em';\n        } else {\n            textAnchor = 'middle';\n            y = '0';\n        }\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(tx),\n        y: round(ty),\n        angle: orientAngle,\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nfunction radialLayout(portCenterOffset, autoOrient, opt) {\n\n    opt = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults({}, opt, { offset: 20 });\n\n    var origin = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.point(0, 0);\n    var angle = -portCenterOffset.theta(origin);\n    var orientAngle = angle;\n    var offset = portCenterOffset.clone()\n        .move(origin, opt.offset)\n        .difference(portCenterOffset)\n        .round();\n\n    var y = '.3em';\n    var textAnchor;\n\n    if ((angle + 90) % 180 === 0) {\n        textAnchor = autoOrient ? 'end' : 'middle';\n        if (!autoOrient && angle === -270) {\n            y = '0em';\n        }\n    } else if (angle > -270 && angle < -90) {\n        textAnchor = 'start';\n        orientAngle = angle - 180;\n    } else {\n        textAnchor = 'end';\n    }\n\n    var round = Math.round;\n    return labelAttributes(opt, {\n        x: round(offset.x),\n        y: round(offset.y),\n        angle: ((autoOrient) ? orientAngle : 0),\n        attrs: { labelText: { y, textAnchor }}\n    });\n}\n\nconst manual = function(_portPosition, _elBBox, opt) {\n    return labelAttributes(opt);\n};\n\nconst left = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: -15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'end' }},\n    });\n};\n\nconst right = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        x: 15,\n        attrs: { labelText: { y: '.3em', textAnchor: 'start' }},\n    });\n};\n\nconst top = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: -15,\n        attrs: { labelText: { y: '0', textAnchor: 'middle' }},\n    });\n};\n\nconst bottom = function(portPosition, elBBox, opt) {\n    return labelAttributes(opt, {\n        y: 15,\n        attrs: { labelText: { y: '.6em', textAnchor: 'middle' }},\n    });\n};\n\nconst outsideOriented = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, true, opt);\n};\n\nconst outside = function(portPosition, elBBox, opt) {\n    return outsideLayout(portPosition, elBBox, false, opt);\n};\n\nconst insideOriented = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, true, opt);\n};\n\nconst inside = function(portPosition, elBBox, opt) {\n    return insideLayout(portPosition, elBBox, false, opt);\n};\n\nconst radial = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), false, opt);\n};\n\nconst radialOriented = function(portPosition, elBBox, opt) {\n    return radialLayout(portPosition.difference(elBBox.center()), true, opt);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGF5b3V0L3BvcnRzL3BvcnRMYWJlbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNNOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyx5REFBaUIsR0FBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUscURBQWEsR0FBRyxTQUFTLFlBQVk7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIsS0FBSztBQUNMOztBQUVBOztBQUVBLFVBQVUscURBQWEsR0FBRyxTQUFTLFlBQVk7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIsS0FBSztBQUNMOztBQUVBOztBQUVBLFVBQVUscURBQWEsR0FBRyxTQUFTLFlBQVk7O0FBRS9DLGlCQUFpQiwrQ0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUIsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYSwrQkFBK0I7QUFDN0QsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixhQUFhLGlDQUFpQztBQUMvRCxLQUFLO0FBQ0w7O0FBRU87QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLGFBQWEsK0JBQStCO0FBQzdELEtBQUs7QUFDTDs7QUFFTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYSxrQ0FBa0M7QUFDaEUsS0FBSztBQUNMOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGF5b3V0L3BvcnRzL3BvcnRMYWJlbC5tanM/MDRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uLy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vdXRpbC9pbmRleC5tanMnO1xuXG5mdW5jdGlvbiBsYWJlbEF0dHJpYnV0ZXMob3B0MSwgb3B0Mikge1xuXG4gICAgLy8gdXNlIHZhbHVlIGZyb20gYG9wdDJgIGlmIGl0IGlzIG1pc3NpbmcgaW4gYG9wdDFgXG4gICAgLy8gdXNlIHZhbHVlIGZyb20gdGhpcyBvYmplY3QgaWYgaXQgaXMgbWlzc2luZyBpbiBgb3B0MmAgYXMgd2VsbFxuICAgIHJldHVybiB1dGlsLmRlZmF1bHRzRGVlcCh7fSwgb3B0MSwgb3B0Miwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICBhbmdsZTogMCxcbiAgICAgICAgYXR0cnM6IHt9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEJCb3hBbmdsZXMoZWxCQm94KSB7XG5cbiAgICB2YXIgY2VudGVyID0gZWxCQm94LmNlbnRlcigpO1xuXG4gICAgdmFyIHRsID0gY2VudGVyLnRoZXRhKGVsQkJveC5vcmlnaW4oKSk7XG4gICAgdmFyIGJsID0gY2VudGVyLnRoZXRhKGVsQkJveC5ib3R0b21MZWZ0KCkpO1xuICAgIHZhciBiciA9IGNlbnRlci50aGV0YShlbEJCb3guY29ybmVyKCkpO1xuICAgIHZhciB0ciA9IGNlbnRlci50aGV0YShlbEJCb3gudG9wUmlnaHQoKSk7XG5cbiAgICByZXR1cm4gW3RsLCB0ciwgYnIsIGJsXTtcbn1cblxuZnVuY3Rpb24gb3V0c2lkZUxheW91dChwb3J0UG9zaXRpb24sIGVsQkJveCwgYXV0b09yaWVudCwgb3B0KSB7XG5cbiAgICBvcHQgPSB1dGlsLmRlZmF1bHRzKHt9LCBvcHQsIHsgb2Zmc2V0OiAxNSB9KTtcbiAgICB2YXIgYW5nbGUgPSBlbEJCb3guY2VudGVyKCkudGhldGEocG9ydFBvc2l0aW9uKTtcblxuICAgIHZhciB0eCwgdHksIHksIHRleHRBbmNob3I7XG4gICAgdmFyIG9mZnNldCA9IG9wdC5vZmZzZXQ7XG4gICAgdmFyIG9yaWVudEFuZ2xlID0gMDtcblxuICAgIGNvbnN0IFt0b3BMZWZ0QW5nbGUsIGJvdHRvbUxlZnRBbmdsZSwgYm90dG9tUmlnaHRBbmdsZSwgdG9wUmlnaHRBbmdsZV0gPSBnZXRCQm94QW5nbGVzKGVsQkJveCk7XG4gICAgaWYgKChhbmdsZSA8IGJvdHRvbUxlZnRBbmdsZSkgfHwgKGFuZ2xlID4gYm90dG9tUmlnaHRBbmdsZSkpIHtcbiAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgdHggPSBvZmZzZXQ7XG4gICAgICAgIHR5ID0gMDtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA8IHRvcExlZnRBbmdsZSkge1xuICAgICAgICB0eCA9IDA7XG4gICAgICAgIHR5ID0gLW9mZnNldDtcbiAgICAgICAgaWYgKGF1dG9PcmllbnQpIHtcbiAgICAgICAgICAgIG9yaWVudEFuZ2xlID0gLTkwO1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgeSA9ICcwJztcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYW5nbGUgPCB0b3BSaWdodEFuZ2xlKSB7XG4gICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIHR4ID0gLW9mZnNldDtcbiAgICAgICAgdHkgPSAwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHggPSAwO1xuICAgICAgICB0eSA9IG9mZnNldDtcbiAgICAgICAgaWYgKGF1dG9PcmllbnQpIHtcbiAgICAgICAgICAgIG9yaWVudEFuZ2xlID0gOTA7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICAgICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0QW5jaG9yID0gJ21pZGRsZSc7XG4gICAgICAgICAgICB5ID0gJy42ZW0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICByZXR1cm4gbGFiZWxBdHRyaWJ1dGVzKG9wdCwge1xuICAgICAgICB4OiByb3VuZCh0eCksXG4gICAgICAgIHk6IHJvdW5kKHR5KSxcbiAgICAgICAgYW5nbGU6IG9yaWVudEFuZ2xlLFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeSwgdGV4dEFuY2hvciB9fVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbnNpZGVMYXlvdXQocG9ydFBvc2l0aW9uLCBlbEJCb3gsIGF1dG9PcmllbnQsIG9wdCkge1xuXG4gICAgb3B0ID0gdXRpbC5kZWZhdWx0cyh7fSwgb3B0LCB7IG9mZnNldDogMTUgfSk7XG4gICAgdmFyIGFuZ2xlID0gZWxCQm94LmNlbnRlcigpLnRoZXRhKHBvcnRQb3NpdGlvbik7XG5cbiAgICB2YXIgdHgsIHR5LCB5LCB0ZXh0QW5jaG9yO1xuICAgIHZhciBvZmZzZXQgPSBvcHQub2Zmc2V0O1xuICAgIHZhciBvcmllbnRBbmdsZSA9IDA7XG5cbiAgICBjb25zdCBbdG9wTGVmdEFuZ2xlLCBib3R0b21MZWZ0QW5nbGUsIGJvdHRvbVJpZ2h0QW5nbGUsIHRvcFJpZ2h0QW5nbGVdID0gZ2V0QkJveEFuZ2xlcyhlbEJCb3gpO1xuICAgIGlmICgoYW5nbGUgPCBib3R0b21MZWZ0QW5nbGUpIHx8IChhbmdsZSA+IGJvdHRvbVJpZ2h0QW5nbGUpKSB7XG4gICAgICAgIHkgPSAnLjNlbSc7XG4gICAgICAgIHR4ID0gLW9mZnNldDtcbiAgICAgICAgdHkgPSAwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChhbmdsZSA8IHRvcExlZnRBbmdsZSkge1xuICAgICAgICB0eCA9IDA7XG4gICAgICAgIHR5ID0gb2Zmc2V0O1xuICAgICAgICBpZiAoYXV0b09yaWVudCkge1xuICAgICAgICAgICAgb3JpZW50QW5nbGUgPSA5MDtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnc3RhcnQnO1xuICAgICAgICAgICAgeSA9ICcuM2VtJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIHkgPSAnLjZlbSc7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFuZ2xlIDwgdG9wUmlnaHRBbmdsZSkge1xuICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB0eCA9IG9mZnNldDtcbiAgICAgICAgdHkgPSAwO1xuICAgICAgICB0ZXh0QW5jaG9yID0gJ3N0YXJ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0eCA9IDA7XG4gICAgICAgIHR5ID0gLW9mZnNldDtcbiAgICAgICAgaWYgKGF1dG9PcmllbnQpIHtcbiAgICAgICAgICAgIG9yaWVudEFuZ2xlID0gLTkwO1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgICAgICB5ID0gJy4zZW0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dEFuY2hvciA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgeSA9ICcwJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeDogcm91bmQodHgpLFxuICAgICAgICB5OiByb3VuZCh0eSksXG4gICAgICAgIGFuZ2xlOiBvcmllbnRBbmdsZSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHksIHRleHRBbmNob3IgfX1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmFkaWFsTGF5b3V0KHBvcnRDZW50ZXJPZmZzZXQsIGF1dG9PcmllbnQsIG9wdCkge1xuXG4gICAgb3B0ID0gdXRpbC5kZWZhdWx0cyh7fSwgb3B0LCB7IG9mZnNldDogMjAgfSk7XG5cbiAgICB2YXIgb3JpZ2luID0gZy5wb2ludCgwLCAwKTtcbiAgICB2YXIgYW5nbGUgPSAtcG9ydENlbnRlck9mZnNldC50aGV0YShvcmlnaW4pO1xuICAgIHZhciBvcmllbnRBbmdsZSA9IGFuZ2xlO1xuICAgIHZhciBvZmZzZXQgPSBwb3J0Q2VudGVyT2Zmc2V0LmNsb25lKClcbiAgICAgICAgLm1vdmUob3JpZ2luLCBvcHQub2Zmc2V0KVxuICAgICAgICAuZGlmZmVyZW5jZShwb3J0Q2VudGVyT2Zmc2V0KVxuICAgICAgICAucm91bmQoKTtcblxuICAgIHZhciB5ID0gJy4zZW0nO1xuICAgIHZhciB0ZXh0QW5jaG9yO1xuXG4gICAgaWYgKChhbmdsZSArIDkwKSAlIDE4MCA9PT0gMCkge1xuICAgICAgICB0ZXh0QW5jaG9yID0gYXV0b09yaWVudCA/ICdlbmQnIDogJ21pZGRsZSc7XG4gICAgICAgIGlmICghYXV0b09yaWVudCAmJiBhbmdsZSA9PT0gLTI3MCkge1xuICAgICAgICAgICAgeSA9ICcwZW0nO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChhbmdsZSA+IC0yNzAgJiYgYW5nbGUgPCAtOTApIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdzdGFydCc7XG4gICAgICAgIG9yaWVudEFuZ2xlID0gYW5nbGUgLSAxODA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEFuY2hvciA9ICdlbmQnO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeDogcm91bmQob2Zmc2V0LngpLFxuICAgICAgICB5OiByb3VuZChvZmZzZXQueSksXG4gICAgICAgIGFuZ2xlOiAoKGF1dG9PcmllbnQpID8gb3JpZW50QW5nbGUgOiAwKSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHksIHRleHRBbmNob3IgfX1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IG1hbnVhbCA9IGZ1bmN0aW9uKF9wb3J0UG9zaXRpb24sIF9lbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBsZWZ0ID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHg6IC0xNSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHk6ICcuM2VtJywgdGV4dEFuY2hvcjogJ2VuZCcgfX0sXG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmlnaHQgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGxhYmVsQXR0cmlidXRlcyhvcHQsIHtcbiAgICAgICAgeDogMTUsXG4gICAgICAgIGF0dHJzOiB7IGxhYmVsVGV4dDogeyB5OiAnLjNlbScsIHRleHRBbmNob3I6ICdzdGFydCcgfX0sXG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgdG9wID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHk6IC0xNSxcbiAgICAgICAgYXR0cnM6IHsgbGFiZWxUZXh0OiB7IHk6ICcwJywgdGV4dEFuY2hvcjogJ21pZGRsZScgfX0sXG4gICAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgYm90dG9tID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiBsYWJlbEF0dHJpYnV0ZXMob3B0LCB7XG4gICAgICAgIHk6IDE1LFxuICAgICAgICBhdHRyczogeyBsYWJlbFRleHQ6IHsgeTogJy42ZW0nLCB0ZXh0QW5jaG9yOiAnbWlkZGxlJyB9fSxcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBvdXRzaWRlT3JpZW50ZWQgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIG91dHNpZGVMYXlvdXQocG9ydFBvc2l0aW9uLCBlbEJCb3gsIHRydWUsIG9wdCk7XG59O1xuXG5leHBvcnQgY29uc3Qgb3V0c2lkZSA9IGZ1bmN0aW9uKHBvcnRQb3NpdGlvbiwgZWxCQm94LCBvcHQpIHtcbiAgICByZXR1cm4gb3V0c2lkZUxheW91dChwb3J0UG9zaXRpb24sIGVsQkJveCwgZmFsc2UsIG9wdCk7XG59O1xuXG5leHBvcnQgY29uc3QgaW5zaWRlT3JpZW50ZWQgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGluc2lkZUxheW91dChwb3J0UG9zaXRpb24sIGVsQkJveCwgdHJ1ZSwgb3B0KTtcbn07XG5cbmV4cG9ydCBjb25zdCBpbnNpZGUgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIGluc2lkZUxheW91dChwb3J0UG9zaXRpb24sIGVsQkJveCwgZmFsc2UsIG9wdCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmFkaWFsID0gZnVuY3Rpb24ocG9ydFBvc2l0aW9uLCBlbEJCb3gsIG9wdCkge1xuICAgIHJldHVybiByYWRpYWxMYXlvdXQocG9ydFBvc2l0aW9uLmRpZmZlcmVuY2UoZWxCQm94LmNlbnRlcigpKSwgZmFsc2UsIG9wdCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmFkaWFsT3JpZW50ZWQgPSBmdW5jdGlvbihwb3J0UG9zaXRpb24sIGVsQkJveCwgb3B0KSB7XG4gICAgcmV0dXJuIHJhZGlhbExheW91dChwb3J0UG9zaXRpb24uZGlmZmVyZW5jZShlbEJCb3guY2VudGVyKCkpLCB0cnVlLCBvcHQpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/layout/ports/portLabel.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkAnchors/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkAnchors/index.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   connectionClosest: function() { return /* binding */ connectionClosest; },\n/* harmony export */   connectionLength: function() { return /* binding */ connectionLength; },\n/* harmony export */   connectionPerpendicular: function() { return /* binding */ connectionPerpendicular; },\n/* harmony export */   connectionRatio: function() { return /* binding */ connectionRatio; },\n/* harmony export */   resolveRef: function() { return /* binding */ resolveRef; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n\nfunction connectionRatio(view, _magnet, _refPoint, opt) {\n\n    var ratio = ('ratio' in opt) ? opt.ratio : 0.5;\n    return view.getPointAtRatio(ratio);\n}\n\nfunction connectionLength(view, _magnet, _refPoint, opt) {\n\n    var length = ('length' in opt) ? opt.length : 20;\n    return view.getPointAtLength(length);\n}\n\nfunction _connectionPerpendicular(view, _magnet, refPoint, opt) {\n\n    var OFFSET = 1e6;\n    var path = view.getConnection();\n    var segmentSubdivisions = view.getConnectionSubdivisions();\n    var verticalLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().offset(0, OFFSET), refPoint.clone().offset(0, -OFFSET));\n    var horizontalLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(refPoint.clone().offset(OFFSET, 0), refPoint.clone().offset(-OFFSET, 0));\n    var verticalIntersections = verticalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var horizontalIntersections = horizontalLine.intersect(path, { segmentSubdivisions: segmentSubdivisions });\n    var intersections = [];\n    if (verticalIntersections) Array.prototype.push.apply(intersections, verticalIntersections);\n    if (horizontalIntersections) Array.prototype.push.apply(intersections, horizontalIntersections);\n    if (intersections.length > 0) return refPoint.chooseClosest(intersections);\n    if ('fallbackAt' in opt) {\n        return getPointAtLink(view, opt.fallbackAt);\n    }\n    return connectionClosest(view, _magnet, refPoint, opt);\n}\n\nfunction _connectionClosest(view, _magnet, refPoint, _opt) {\n\n    var closestPoint = view.getClosestPoint(refPoint);\n    if (!closestPoint) return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n    return closestPoint;\n}\n\nfunction resolveRef(fn) {\n    return function(view, magnet, ref, opt) {\n        if (ref instanceof Element) {\n            var refView = this.paper.findView(ref);\n            var refPoint;\n            if (refView) {\n                if (refView.isNodeConnection(ref)) {\n                    var distance = ('fixedAt' in opt) ? opt.fixedAt : '50%';\n                    refPoint = getPointAtLink(refView, distance);\n                } else {\n                    refPoint = refView.getNodeBBox(ref).center();\n                }\n            } else {\n                // Something went wrong\n                refPoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point();\n            }\n            return fn.call(this, view, magnet, refPoint, opt);\n        }\n        return fn.apply(this, arguments);\n    };\n}\n\nfunction getPointAtLink(view, value) {\n    var parsedValue = parseFloat(value);\n    if ((0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.isPercentage)(value)) {\n        return view.getPointAtRatio(parsedValue / 100);\n    } else {\n        return view.getPointAtLength(parsedValue);\n    }\n}\n\n// joint.linkAnchors\n\nconst connectionPerpendicular = resolveRef(_connectionPerpendicular);\nconst connectionClosest = resolveRef(_connectionClosest);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua0FuY2hvcnMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0k7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhDQUFJO0FBQy9CLDZCQUE2Qiw4Q0FBSTtBQUNqQywrREFBK0QsMENBQTBDO0FBQ3pHLG1FQUFtRSwwQ0FBMEM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLCtDQUFLO0FBQ3ZDO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwrQkFBK0IsK0NBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDZEQUFZO0FBQ3BCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUM2QztBQUN0QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua0FuY2hvcnMvaW5kZXgubWpzPzBlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTGluZSwgUG9pbnQgfSBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc1BlcmNlbnRhZ2UgfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIGNvbm5lY3Rpb25SYXRpbyh2aWV3LCBfbWFnbmV0LCBfcmVmUG9pbnQsIG9wdCkge1xuXG4gICAgdmFyIHJhdGlvID0gKCdyYXRpbycgaW4gb3B0KSA/IG9wdC5yYXRpbyA6IDAuNTtcbiAgICByZXR1cm4gdmlldy5nZXRQb2ludEF0UmF0aW8ocmF0aW8pO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0aW9uTGVuZ3RoKHZpZXcsIF9tYWduZXQsIF9yZWZQb2ludCwgb3B0KSB7XG5cbiAgICB2YXIgbGVuZ3RoID0gKCdsZW5ndGgnIGluIG9wdCkgPyBvcHQubGVuZ3RoIDogMjA7XG4gICAgcmV0dXJuIHZpZXcuZ2V0UG9pbnRBdExlbmd0aChsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBfY29ubmVjdGlvblBlcnBlbmRpY3VsYXIodmlldywgX21hZ25ldCwgcmVmUG9pbnQsIG9wdCkge1xuXG4gICAgdmFyIE9GRlNFVCA9IDFlNjtcbiAgICB2YXIgcGF0aCA9IHZpZXcuZ2V0Q29ubmVjdGlvbigpO1xuICAgIHZhciBzZWdtZW50U3ViZGl2aXNpb25zID0gdmlldy5nZXRDb25uZWN0aW9uU3ViZGl2aXNpb25zKCk7XG4gICAgdmFyIHZlcnRpY2FsTGluZSA9IG5ldyBMaW5lKHJlZlBvaW50LmNsb25lKCkub2Zmc2V0KDAsIE9GRlNFVCksIHJlZlBvaW50LmNsb25lKCkub2Zmc2V0KDAsIC1PRkZTRVQpKTtcbiAgICB2YXIgaG9yaXpvbnRhbExpbmUgPSBuZXcgTGluZShyZWZQb2ludC5jbG9uZSgpLm9mZnNldChPRkZTRVQsIDApLCByZWZQb2ludC5jbG9uZSgpLm9mZnNldCgtT0ZGU0VULCAwKSk7XG4gICAgdmFyIHZlcnRpY2FsSW50ZXJzZWN0aW9ucyA9IHZlcnRpY2FsTGluZS5pbnRlcnNlY3QocGF0aCwgeyBzZWdtZW50U3ViZGl2aXNpb25zOiBzZWdtZW50U3ViZGl2aXNpb25zIH0pO1xuICAgIHZhciBob3Jpem9udGFsSW50ZXJzZWN0aW9ucyA9IGhvcml6b250YWxMaW5lLmludGVyc2VjdChwYXRoLCB7IHNlZ21lbnRTdWJkaXZpc2lvbnM6IHNlZ21lbnRTdWJkaXZpc2lvbnMgfSk7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICBpZiAodmVydGljYWxJbnRlcnNlY3Rpb25zKSBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbnRlcnNlY3Rpb25zLCB2ZXJ0aWNhbEludGVyc2VjdGlvbnMpO1xuICAgIGlmIChob3Jpem9udGFsSW50ZXJzZWN0aW9ucykgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaW50ZXJzZWN0aW9ucywgaG9yaXpvbnRhbEludGVyc2VjdGlvbnMpO1xuICAgIGlmIChpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHJldHVybiByZWZQb2ludC5jaG9vc2VDbG9zZXN0KGludGVyc2VjdGlvbnMpO1xuICAgIGlmICgnZmFsbGJhY2tBdCcgaW4gb3B0KSB7XG4gICAgICAgIHJldHVybiBnZXRQb2ludEF0TGluayh2aWV3LCBvcHQuZmFsbGJhY2tBdCk7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uQ2xvc2VzdCh2aWV3LCBfbWFnbmV0LCByZWZQb2ludCwgb3B0KTtcbn1cblxuZnVuY3Rpb24gX2Nvbm5lY3Rpb25DbG9zZXN0KHZpZXcsIF9tYWduZXQsIHJlZlBvaW50LCBfb3B0KSB7XG5cbiAgICB2YXIgY2xvc2VzdFBvaW50ID0gdmlldy5nZXRDbG9zZXN0UG9pbnQocmVmUG9pbnQpO1xuICAgIGlmICghY2xvc2VzdFBvaW50KSByZXR1cm4gbmV3IFBvaW50KCk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVSZWYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmlldywgbWFnbmV0LCByZWYsIG9wdCkge1xuICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHJlZlZpZXcgPSB0aGlzLnBhcGVyLmZpbmRWaWV3KHJlZik7XG4gICAgICAgICAgICB2YXIgcmVmUG9pbnQ7XG4gICAgICAgICAgICBpZiAocmVmVmlldykge1xuICAgICAgICAgICAgICAgIGlmIChyZWZWaWV3LmlzTm9kZUNvbm5lY3Rpb24ocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAoJ2ZpeGVkQXQnIGluIG9wdCkgPyBvcHQuZml4ZWRBdCA6ICc1MCUnO1xuICAgICAgICAgICAgICAgICAgICByZWZQb2ludCA9IGdldFBvaW50QXRMaW5rKHJlZlZpZXcsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZQb2ludCA9IHJlZlZpZXcuZ2V0Tm9kZUJCb3gocmVmKS5jZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICAgICAgICAgICAgcmVmUG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHZpZXcsIG1hZ25ldCwgcmVmUG9pbnQsIG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9pbnRBdExpbmsodmlldywgdmFsdWUpIHtcbiAgICB2YXIgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoaXNQZXJjZW50YWdlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmlldy5nZXRQb2ludEF0UmF0aW8ocGFyc2VkVmFsdWUgLyAxMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2aWV3LmdldFBvaW50QXRMZW5ndGgocGFyc2VkVmFsdWUpO1xuICAgIH1cbn1cblxuLy8gam9pbnQubGlua0FuY2hvcnNcbmV4cG9ydCB7IGNvbm5lY3Rpb25SYXRpbywgY29ubmVjdGlvbkxlbmd0aCB9O1xuZXhwb3J0IGNvbnN0IGNvbm5lY3Rpb25QZXJwZW5kaWN1bGFyID0gcmVzb2x2ZVJlZihfY29ubmVjdGlvblBlcnBlbmRpY3VsYXIpO1xuZXhwb3J0IGNvbnN0IGNvbm5lY3Rpb25DbG9zZXN0ID0gcmVzb2x2ZVJlZihfY29ubmVjdGlvbkNsb3Nlc3QpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkAnchors/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Anchor.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Anchor.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SourceAnchor: function() { return /* binding */ SourceAnchor; },\n/* harmony export */   TargetAnchor: function() { return /* binding */ TargetAnchor; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cellTools/helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\nconst Anchor = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    tagName: 'g',\n    type: null,\n    children: [{\n        tagName: 'circle',\n        selector: 'anchor',\n        attributes: {\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'area',\n        attributes: {\n            'pointer-events': 'none',\n            'fill': 'none',\n            'stroke': '#33334F',\n            'stroke-dasharray': '2,4',\n            'rx': 5,\n            'ry': 5\n        }\n    }],\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onPointerDblClick',\n        dbltap: 'onPointerDblClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        snap: _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.snapAnchor,\n        anchor: _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_1__.getAnchor,\n        scale: null,\n        resetAnchor: true,\n        customAnchorAttributes: {\n            'stroke-width': 4,\n            'stroke': '#33334F',\n            'fill': '#FFFFFF',\n            'r': 5\n        },\n        defaultAnchorAttributes: {\n            'stroke-width': 2,\n            'stroke': '#FFFFFF',\n            'fill': '#33334F',\n            'r': 6\n        },\n        areaPadding: 6,\n        snapRadius: 10,\n        restrictArea: true,\n        redundancyRemoval: true\n    },\n    onRender: function() {\n        this.renderChildren();\n        this.toggleArea(false);\n        this.update();\n    },\n    update: function() {\n        var type = this.type;\n        var relatedView = this.relatedView;\n        var view = relatedView.getEndView(type);\n        if (view) {\n            this.updateAnchor();\n            this.updateArea();\n            this.el.style.display = '';\n        } else {\n            this.el.style.display = 'none';\n        }\n        return this;\n    },\n    updateAnchor: function() {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var anchorNode = childNodes.anchor;\n        if (!anchorNode) return;\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var position = relatedView.getEndAnchor(type);\n        var options = this.options;\n        var customAnchor = relatedView.model.prop([type, 'anchor']);\n        let transformString =  `translate(${position.x},${position.y})`;\n        if (options.scale) {\n            transformString += ` scale(${options.scale})`;\n        }\n        anchorNode.setAttribute('transform', transformString);\n        var anchorAttributes = (customAnchor) ? options.customAnchorAttributes : options.defaultAnchorAttributes;\n        for (var attrName in anchorAttributes) {\n            anchorNode.setAttribute(attrName, anchorAttributes[attrName]);\n        }\n    },\n    updateArea: function() {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var areaNode = childNodes.area;\n        if (!areaNode) return;\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var view = relatedView.getEndView(type);\n        var model = view.model;\n        var magnet = relatedView.getEndMagnet(type);\n        var padding = this.options.areaPadding;\n        if (!isFinite(padding)) padding = 0;\n        var bbox, angle, center;\n        if (view.isNodeConnection(magnet)) {\n            bbox = view.getNodeBBox(magnet);\n            angle = 0;\n            center = bbox.center();\n        } else {\n            bbox = view.getNodeUnrotatedBBox(magnet);\n            angle = model.angle();\n            center = bbox.center();\n            if (angle) center.rotate(model.getBBox().center(), -angle);\n            // TODO: get the link's magnet rotation into account\n        }\n        bbox.inflate(padding);\n        areaNode.setAttribute('x', -bbox.width / 2);\n        areaNode.setAttribute('y', -bbox.height / 2);\n        areaNode.setAttribute('width', bbox.width);\n        areaNode.setAttribute('height', bbox.height);\n        areaNode.setAttribute('transform', 'translate(' + center.x + ',' + center.y + ') rotate(' + angle + ')');\n    },\n    toggleArea: function(visible) {\n        var childNodes = this.childNodes;\n        if (!childNodes) return;\n        var areaNode = childNodes.area;\n        if (!areaNode) return;\n        areaNode.style.display = (visible) ? '' : 'none';\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.paper.undelegateEvents();\n        this.delegateDocumentEvents();\n        this.focus();\n        this.toggleArea(this.options.restrictArea);\n        this.relatedView.model.startBatch('anchor-move', { ui: true, tool: this.cid });\n    },\n    resetAnchor: function(anchor) {\n        var type = this.type;\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    onPointerMove: function(evt) {\n\n        var relatedView = this.relatedView;\n        var type = this.type;\n        var view = relatedView.getEndView(type);\n        var model = view.model;\n        var magnet = relatedView.getEndMagnet(type);\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeEvent(evt);\n        var coords = this.paper.clientToLocalPoint(normalizedEvent.clientX, normalizedEvent.clientY);\n        var snapFn = this.options.snap;\n        if (typeof snapFn === 'function') {\n            coords = snapFn.call(relatedView, coords, view, magnet, type, relatedView, this);\n            coords = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(coords);\n        }\n\n        if (this.options.restrictArea) {\n            if (view.isNodeConnection(magnet)) {\n                // snap coords to the link's connection\n                var pointAtConnection = view.getClosestPoint(coords);\n                if (pointAtConnection) coords = pointAtConnection;\n            } else {\n                // snap coords within node bbox\n                var bbox = view.getNodeUnrotatedBBox(magnet);\n                var angle = model.angle();\n                var origin = model.getBBox().center();\n                var rotatedCoords = coords.clone().rotate(origin, angle);\n                if (!bbox.containsPoint(rotatedCoords)) {\n                    coords = bbox.pointNearestToPoint(rotatedCoords).rotate(origin, -angle);\n                }\n            }\n        }\n\n        var anchor;\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn === 'function') {\n            anchor = anchorFn.call(relatedView, coords, view, magnet, type, relatedView);\n        }\n\n        this.resetAnchor(anchor);\n        this.update();\n    },\n\n    onPointerUp: function(evt) {\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeEvent(evt);\n        this.paper.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleArea(false);\n        var linkView = this.relatedView;\n        if (this.options.redundancyRemoval) linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        linkView.checkMouseleave(normalizedEvent);\n        linkView.model.stopBatch('anchor-move', { ui: true, tool: this.cid });\n    },\n\n    onPointerDblClick: function() {\n        var anchor = this.options.resetAnchor;\n        if (anchor === false) return; // reset anchor disabled\n        if (anchor === true) anchor = null; // remove the current anchor\n        this.resetAnchor(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.cloneDeep(anchor));\n        this.update();\n    }\n});\n\nconst SourceAnchor = Anchor.extend({\n    name: 'source-anchor',\n    type: 'source'\n});\n\nconst TargetAnchor = Anchor.extend({\n    name: 'target-anchor',\n    type: 'target'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL0FuY2hvci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvQztBQUNNO0FBQ0s7QUFDa0I7O0FBRWpFLGVBQWUsdURBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsOERBQVU7QUFDeEIsZ0JBQWdCLDZEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVyxHQUFHLFdBQVc7QUFDckU7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMEJBQTBCO0FBQ3JGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQU87QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0NBQWdDLDJEQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLDBCQUEwQjtBQUMvRztBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUUsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDRDQUE0QztBQUM1Qyx5QkFBeUIsc0RBQWM7QUFDdkM7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL0FuY2hvci5tanM/MDg2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0IHsgVG9vbFZpZXcgfSBmcm9tICcuLi9kaWEvVG9vbFZpZXcubWpzJztcbmltcG9ydCB7IGdldEFuY2hvciwgc25hcEFuY2hvciB9IGZyb20gJy4uL2NlbGxUb29scy9oZWxwZXJzLm1qcyc7XG5cbmNvbnN0IEFuY2hvciA9IFRvb2xWaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogJ2cnLFxuICAgIHR5cGU6IG51bGwsXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICBzZWxlY3RvcjogJ2FuY2hvcicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdjdXJzb3InOiAncG9pbnRlcidcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICBzZWxlY3RvcjogJ2FyZWEnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAnIzMzMzM0RicsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcyLDQnLFxuICAgICAgICAgICAgJ3J4JzogNSxcbiAgICAgICAgICAgICdyeSc6IDVcbiAgICAgICAgfVxuICAgIH1dLFxuICAgIGV2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgdG91Y2hzdGFydDogJ29uUG9pbnRlckRvd24nLFxuICAgICAgICBkYmxjbGljazogJ29uUG9pbnRlckRibENsaWNrJyxcbiAgICAgICAgZGJsdGFwOiAnb25Qb2ludGVyRGJsQ2xpY2snXG4gICAgfSxcbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICdvblBvaW50ZXJNb3ZlJyxcbiAgICAgICAgdG91Y2htb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIG1vdXNldXA6ICdvblBvaW50ZXJVcCcsXG4gICAgICAgIHRvdWNoZW5kOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGNhbmNlbDogJ29uUG9pbnRlclVwJ1xuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBzbmFwOiBzbmFwQW5jaG9yLFxuICAgICAgICBhbmNob3I6IGdldEFuY2hvcixcbiAgICAgICAgc2NhbGU6IG51bGwsXG4gICAgICAgIHJlc2V0QW5jaG9yOiB0cnVlLFxuICAgICAgICBjdXN0b21BbmNob3JBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJzogNCxcbiAgICAgICAgICAgICdzdHJva2UnOiAnIzMzMzM0RicsXG4gICAgICAgICAgICAnZmlsbCc6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICdyJzogNVxuICAgICAgICB9LFxuICAgICAgICBkZWZhdWx0QW5jaG9yQXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAnc3Ryb2tlJzogJyNGRkZGRkYnLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnIzMzMzM0RicsXG4gICAgICAgICAgICAncic6IDZcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYVBhZGRpbmc6IDYsXG4gICAgICAgIHNuYXBSYWRpdXM6IDEwLFxuICAgICAgICByZXN0cmljdEFyZWE6IHRydWUsXG4gICAgICAgIHJlZHVuZGFuY3lSZW1vdmFsOiB0cnVlXG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy50b2dnbGVBcmVhKGZhbHNlKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdmlldyA9IHJlbGF0ZWRWaWV3LmdldEVuZFZpZXcodHlwZSk7XG4gICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuY2hvcigpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBcmVhKCk7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHVwZGF0ZUFuY2hvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkTm9kZXMpIHJldHVybjtcbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSBjaGlsZE5vZGVzLmFuY2hvcjtcbiAgICAgICAgaWYgKCFhbmNob3JOb2RlKSByZXR1cm47XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSByZWxhdGVkVmlldy5nZXRFbmRBbmNob3IodHlwZSk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgY3VzdG9tQW5jaG9yID0gcmVsYXRlZFZpZXcubW9kZWwucHJvcChbdHlwZSwgJ2FuY2hvciddKTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybVN0cmluZyA9ICBgdHJhbnNsYXRlKCR7cG9zaXRpb24ueH0sJHtwb3NpdGlvbi55fSlgO1xuICAgICAgICBpZiAob3B0aW9ucy5zY2FsZSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nICs9IGAgc2NhbGUoJHtvcHRpb25zLnNjYWxlfSlgO1xuICAgICAgICB9XG4gICAgICAgIGFuY2hvck5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1TdHJpbmcpO1xuICAgICAgICB2YXIgYW5jaG9yQXR0cmlidXRlcyA9IChjdXN0b21BbmNob3IpID8gb3B0aW9ucy5jdXN0b21BbmNob3JBdHRyaWJ1dGVzIDogb3B0aW9ucy5kZWZhdWx0QW5jaG9yQXR0cmlidXRlcztcbiAgICAgICAgZm9yICh2YXIgYXR0ck5hbWUgaW4gYW5jaG9yQXR0cmlidXRlcykge1xuICAgICAgICAgICAgYW5jaG9yTm9kZS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGFuY2hvckF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlQXJlYTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkTm9kZXMpIHJldHVybjtcbiAgICAgICAgdmFyIGFyZWFOb2RlID0gY2hpbGROb2Rlcy5hcmVhO1xuICAgICAgICBpZiAoIWFyZWFOb2RlKSByZXR1cm47XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIgdmlldyA9IHJlbGF0ZWRWaWV3LmdldEVuZFZpZXcodHlwZSk7XG4gICAgICAgIHZhciBtb2RlbCA9IHZpZXcubW9kZWw7XG4gICAgICAgIHZhciBtYWduZXQgPSByZWxhdGVkVmlldy5nZXRFbmRNYWduZXQodHlwZSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5vcHRpb25zLmFyZWFQYWRkaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHBhZGRpbmcpKSBwYWRkaW5nID0gMDtcbiAgICAgICAgdmFyIGJib3gsIGFuZ2xlLCBjZW50ZXI7XG4gICAgICAgIGlmICh2aWV3LmlzTm9kZUNvbm5lY3Rpb24obWFnbmV0KSkge1xuICAgICAgICAgICAgYmJveCA9IHZpZXcuZ2V0Tm9kZUJCb3gobWFnbmV0KTtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgICAgIGNlbnRlciA9IGJib3guY2VudGVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYm94ID0gdmlldy5nZXROb2RlVW5yb3RhdGVkQkJveChtYWduZXQpO1xuICAgICAgICAgICAgYW5nbGUgPSBtb2RlbC5hbmdsZSgpO1xuICAgICAgICAgICAgY2VudGVyID0gYmJveC5jZW50ZXIoKTtcbiAgICAgICAgICAgIGlmIChhbmdsZSkgY2VudGVyLnJvdGF0ZShtb2RlbC5nZXRCQm94KCkuY2VudGVyKCksIC1hbmdsZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBnZXQgdGhlIGxpbmsncyBtYWduZXQgcm90YXRpb24gaW50byBhY2NvdW50XG4gICAgICAgIH1cbiAgICAgICAgYmJveC5pbmZsYXRlKHBhZGRpbmcpO1xuICAgICAgICBhcmVhTm9kZS5zZXRBdHRyaWJ1dGUoJ3gnLCAtYmJveC53aWR0aCAvIDIpO1xuICAgICAgICBhcmVhTm9kZS5zZXRBdHRyaWJ1dGUoJ3knLCAtYmJveC5oZWlnaHQgLyAyKTtcbiAgICAgICAgYXJlYU5vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJib3gud2lkdGgpO1xuICAgICAgICBhcmVhTm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJib3guaGVpZ2h0KTtcbiAgICAgICAgYXJlYU5vZGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjZW50ZXIueCArICcsJyArIGNlbnRlci55ICsgJykgcm90YXRlKCcgKyBhbmdsZSArICcpJyk7XG4gICAgfSxcbiAgICB0b2dnbGVBcmVhOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoIWNoaWxkTm9kZXMpIHJldHVybjtcbiAgICAgICAgdmFyIGFyZWFOb2RlID0gY2hpbGROb2Rlcy5hcmVhO1xuICAgICAgICBpZiAoIWFyZWFOb2RlKSByZXR1cm47XG4gICAgICAgIGFyZWFOb2RlLnN0eWxlLmRpc3BsYXkgPSAodmlzaWJsZSkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuICAgIG9uUG9pbnRlckRvd246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQpKSByZXR1cm47XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMucGFwZXIudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFyZWEodGhpcy5vcHRpb25zLnJlc3RyaWN0QXJlYSk7XG4gICAgICAgIHRoaXMucmVsYXRlZFZpZXcubW9kZWwuc3RhcnRCYXRjaCgnYW5jaG9yLW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICB9LFxuICAgIHJlc2V0QW5jaG9yOiBmdW5jdGlvbihhbmNob3IpIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHZhciByZWxhdGVkTW9kZWwgPSB0aGlzLnJlbGF0ZWRWaWV3Lm1vZGVsO1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICByZWxhdGVkTW9kZWwucHJvcChbdHlwZSwgJ2FuY2hvciddLCBhbmNob3IsIHtcbiAgICAgICAgICAgICAgICByZXdyaXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvb2w6IHRoaXMuY2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbGF0ZWRNb2RlbC5yZW1vdmVQcm9wKFt0eXBlLCAnYW5jaG9yJ10sIHtcbiAgICAgICAgICAgICAgICB1aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b29sOiB0aGlzLmNpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB2YXIgdmlldyA9IHJlbGF0ZWRWaWV3LmdldEVuZFZpZXcodHlwZSk7XG4gICAgICAgIHZhciBtb2RlbCA9IHZpZXcubW9kZWw7XG4gICAgICAgIHZhciBtYWduZXQgPSByZWxhdGVkVmlldy5nZXRFbmRNYWduZXQodHlwZSk7XG4gICAgICAgIHZhciBub3JtYWxpemVkRXZlbnQgPSB1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLnBhcGVyLmNsaWVudFRvTG9jYWxQb2ludChub3JtYWxpemVkRXZlbnQuY2xpZW50WCwgbm9ybWFsaXplZEV2ZW50LmNsaWVudFkpO1xuICAgICAgICB2YXIgc25hcEZuID0gdGhpcy5vcHRpb25zLnNuYXA7XG4gICAgICAgIGlmICh0eXBlb2Ygc25hcEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb29yZHMgPSBzbmFwRm4uY2FsbChyZWxhdGVkVmlldywgY29vcmRzLCB2aWV3LCBtYWduZXQsIHR5cGUsIHJlbGF0ZWRWaWV3LCB0aGlzKTtcbiAgICAgICAgICAgIGNvb3JkcyA9IG5ldyBnLlBvaW50KGNvb3Jkcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc3RyaWN0QXJlYSkge1xuICAgICAgICAgICAgaWYgKHZpZXcuaXNOb2RlQ29ubmVjdGlvbihtYWduZXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gc25hcCBjb29yZHMgdG8gdGhlIGxpbmsncyBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50QXRDb25uZWN0aW9uID0gdmlldy5nZXRDbG9zZXN0UG9pbnQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRBdENvbm5lY3Rpb24pIGNvb3JkcyA9IHBvaW50QXRDb25uZWN0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzbmFwIGNvb3JkcyB3aXRoaW4gbm9kZSBiYm94XG4gICAgICAgICAgICAgICAgdmFyIGJib3ggPSB2aWV3LmdldE5vZGVVbnJvdGF0ZWRCQm94KG1hZ25ldCk7XG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gbW9kZWwuYW5nbGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gbW9kZWwuZ2V0QkJveCgpLmNlbnRlcigpO1xuICAgICAgICAgICAgICAgIHZhciByb3RhdGVkQ29vcmRzID0gY29vcmRzLmNsb25lKCkucm90YXRlKG9yaWdpbiwgYW5nbGUpO1xuICAgICAgICAgICAgICAgIGlmICghYmJveC5jb250YWluc1BvaW50KHJvdGF0ZWRDb29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkcyA9IGJib3gucG9pbnROZWFyZXN0VG9Qb2ludChyb3RhdGVkQ29vcmRzKS5yb3RhdGUob3JpZ2luLCAtYW5nbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3I7XG4gICAgICAgIHZhciBhbmNob3JGbiA9IHRoaXMub3B0aW9ucy5hbmNob3I7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFuY2hvciA9IGFuY2hvckZuLmNhbGwocmVsYXRlZFZpZXcsIGNvb3JkcywgdmlldywgbWFnbmV0LCB0eXBlLCByZWxhdGVkVmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2V0QW5jaG9yKGFuY2hvcik7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICB0aGlzLnBhcGVyLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFyZWEoZmFsc2UpO1xuICAgICAgICB2YXIgbGlua1ZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlZHVuZGFuY3lSZW1vdmFsKSBsaW5rVmlldy5yZW1vdmVSZWR1bmRhbnRMaW5lYXJWZXJ0aWNlcyh7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgbGlua1ZpZXcuY2hlY2tNb3VzZWxlYXZlKG5vcm1hbGl6ZWRFdmVudCk7XG4gICAgICAgIGxpbmtWaWV3Lm1vZGVsLnN0b3BCYXRjaCgnYW5jaG9yLW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICB9LFxuXG4gICAgb25Qb2ludGVyRGJsQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5vcHRpb25zLnJlc2V0QW5jaG9yO1xuICAgICAgICBpZiAoYW5jaG9yID09PSBmYWxzZSkgcmV0dXJuOyAvLyByZXNldCBhbmNob3IgZGlzYWJsZWRcbiAgICAgICAgaWYgKGFuY2hvciA9PT0gdHJ1ZSkgYW5jaG9yID0gbnVsbDsgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGFuY2hvclxuICAgICAgICB0aGlzLnJlc2V0QW5jaG9yKHV0aWwuY2xvbmVEZWVwKGFuY2hvcikpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgU291cmNlQW5jaG9yID0gQW5jaG9yLmV4dGVuZCh7XG4gICAgbmFtZTogJ3NvdXJjZS1hbmNob3InLFxuICAgIHR5cGU6ICdzb3VyY2UnXG59KTtcblxuZXhwb3J0IGNvbnN0IFRhcmdldEFuY2hvciA9IEFuY2hvci5leHRlbmQoe1xuICAgIG5hbWU6ICd0YXJnZXQtYW5jaG9yJyxcbiAgICB0eXBlOiAndGFyZ2V0J1xufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Anchor.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Arrowhead.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Arrowhead.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SourceArrowhead: function() { return /* binding */ SourceArrowhead; },\n/* harmony export */   TargetArrowhead: function() { return /* binding */ TargetArrowhead; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n\n\n\n\n\n// End Markers\nconst Arrowhead = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_0__.ToolView.extend({\n    tagName: 'path',\n    xAxisVector: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0),\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    options: {\n        scale: null\n    },\n    onRender: function() {\n        this.update();\n    },\n    update: function() {\n        var ratio = this.ratio;\n        var view = this.relatedView;\n        var tangent = view.getTangentAtRatio(ratio);\n        var position, angle;\n        if (tangent) {\n            position = tangent.start;\n            angle = tangent.vector().vectorAngle(this.xAxisVector) || 0;\n        } else {\n            position = view.getPointAtRatio(ratio);\n            angle = 0;\n        }\n        if (!position) return this;\n        var matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createSVGMatrix().translate(position.x, position.y).rotate(angle);\n        const { scale } = this.options;\n        if (scale) matrix = matrix.scale(scale);\n        this.vel.transform(matrix, { absolute: true });\n        return this;\n    },\n    onPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        relatedView.model.startBatch('arrowhead-move', { ui: true, tool: this.cid });\n        relatedView.startArrowheadMove(this.arrowheadType);\n        const data = evt.data || (evt.data = {});\n        this.delegateDocumentEvents(null, data);\n        paper.undelegateEvents();\n        this.focus();\n        this.el.style.pointerEvents = 'none';\n        relatedView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onPointerMove: function(evt) {\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeEvent(evt);\n        var coords = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.relatedView.pointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        relatedView.pointerup(normalizedEvent, coords.x, coords.y);\n        paper.delegateEvents();\n        this.blur();\n        this.el.style.pointerEvents = '';\n        relatedView.model.stopBatch('arrowhead-move', { ui: true, tool: this.cid });\n    }\n});\n\nconst TargetArrowhead = Arrowhead.extend({\n    name: 'target-arrowhead',\n    ratio: 1,\n    arrowheadType: 'target',\n    attributes: {\n        'd': 'M -10 -8 10 0 -10 8 Z',\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move',\n        'class': 'target-arrowhead'\n    }\n});\n\nconst SourceArrowhead = Arrowhead.extend({\n    name: 'source-arrowhead',\n    ratio: 0,\n    arrowheadType: 'source',\n    attributes: {\n        'd': 'M 10 -8 -10 0 10 8 Z',\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move',\n        'class': 'source-arrowhead'\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL0Fycm93aGVhZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ0w7QUFDVztBQUNLOztBQUUvQztBQUNBLGtCQUFrQix1REFBUTtBQUMxQjtBQUNBLHFCQUFxQiwrQ0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9EQUFDO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMEJBQTBCO0FBQ25GO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEIsMkRBQW1CO0FBQ2pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMEJBQTBCO0FBQ2xGO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9saW5rVG9vbHMvQXJyb3doZWFkLm1qcz8yOTc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuaW1wb3J0IFYgZnJvbSAnLi4vVi9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBUb29sVmlldyB9IGZyb20gJy4uL2RpYS9Ub29sVmlldy5tanMnO1xuXG4vLyBFbmQgTWFya2Vyc1xuY29uc3QgQXJyb3doZWFkID0gVG9vbFZpZXcuZXh0ZW5kKHtcbiAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgeEF4aXNWZWN0b3I6IG5ldyBnLlBvaW50KDEsIDApLFxuICAgIGV2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgdG91Y2hzdGFydDogJ29uUG9pbnRlckRvd24nXG4gICAgfSxcbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICdvblBvaW50ZXJNb3ZlJyxcbiAgICAgICAgdG91Y2htb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIG1vdXNldXA6ICdvblBvaW50ZXJVcCcsXG4gICAgICAgIHRvdWNoZW5kOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGNhbmNlbDogJ29uUG9pbnRlclVwJ1xuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBzY2FsZTogbnVsbFxuICAgIH0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJhdGlvID0gdGhpcy5yYXRpbztcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdGFuZ2VudCA9IHZpZXcuZ2V0VGFuZ2VudEF0UmF0aW8ocmF0aW8pO1xuICAgICAgICB2YXIgcG9zaXRpb24sIGFuZ2xlO1xuICAgICAgICBpZiAodGFuZ2VudCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSB0YW5nZW50LnN0YXJ0O1xuICAgICAgICAgICAgYW5nbGUgPSB0YW5nZW50LnZlY3RvcigpLnZlY3RvckFuZ2xlKHRoaXMueEF4aXNWZWN0b3IpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IHZpZXcuZ2V0UG9pbnRBdFJhdGlvKHJhdGlvKTtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIG1hdHJpeCA9IFYuY3JlYXRlU1ZHTWF0cml4KCkudHJhbnNsYXRlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpLnJvdGF0ZShhbmdsZSk7XG4gICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNjYWxlKSBtYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICAgICAgICB0aGlzLnZlbC50cmFuc2Zvcm0obWF0cml4LCB7IGFic29sdXRlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9uUG9pbnRlckRvd246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQpKSByZXR1cm47XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciBwYXBlciA9IHJlbGF0ZWRWaWV3LnBhcGVyO1xuICAgICAgICByZWxhdGVkVmlldy5tb2RlbC5zdGFydEJhdGNoKCdhcnJvd2hlYWQtbW92ZScsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICByZWxhdGVkVmlldy5zdGFydEFycm93aGVhZE1vdmUodGhpcy5hcnJvd2hlYWRUeXBlKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2dC5kYXRhIHx8IChldnQuZGF0YSA9IHt9KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKG51bGwsIGRhdGEpO1xuICAgICAgICBwYXBlci51bmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICByZWxhdGVkVmlldy5ub3RpZnlQb2ludGVyZG93biguLi5wYXBlci5nZXRQb2ludGVyQXJncyhldnQpKTtcbiAgICB9LFxuICAgIG9uUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5wYXBlci5zbmFwVG9HcmlkKG5vcm1hbGl6ZWRFdmVudC5jbGllbnRYLCBub3JtYWxpemVkRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIHRoaXMucmVsYXRlZFZpZXcucG9pbnRlcm1vdmUobm9ybWFsaXplZEV2ZW50LCBjb29yZHMueCwgY29vcmRzLnkpO1xuICAgIH0sXG4gICAgb25Qb2ludGVyVXA6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVEb2N1bWVudEV2ZW50cygpO1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgcGFwZXIgPSByZWxhdGVkVmlldy5wYXBlcjtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHBhcGVyLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKTtcbiAgICAgICAgcmVsYXRlZFZpZXcucG9pbnRlcnVwKG5vcm1hbGl6ZWRFdmVudCwgY29vcmRzLngsIGNvb3Jkcy55KTtcbiAgICAgICAgcGFwZXIuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIHRoaXMuZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICByZWxhdGVkVmlldy5tb2RlbC5zdG9wQmF0Y2goJ2Fycm93aGVhZC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBUYXJnZXRBcnJvd2hlYWQgPSBBcnJvd2hlYWQuZXh0ZW5kKHtcbiAgICBuYW1lOiAndGFyZ2V0LWFycm93aGVhZCcsXG4gICAgcmF0aW86IDEsXG4gICAgYXJyb3doZWFkVHlwZTogJ3RhcmdldCcsXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAnZCc6ICdNIC0xMCAtOCAxMCAwIC0xMCA4IFonLFxuICAgICAgICAnZmlsbCc6ICcjMzMzMzRGJyxcbiAgICAgICAgJ3N0cm9rZSc6ICcjRkZGRkZGJyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICdjdXJzb3InOiAnbW92ZScsXG4gICAgICAgICdjbGFzcyc6ICd0YXJnZXQtYXJyb3doZWFkJ1xuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgU291cmNlQXJyb3doZWFkID0gQXJyb3doZWFkLmV4dGVuZCh7XG4gICAgbmFtZTogJ3NvdXJjZS1hcnJvd2hlYWQnLFxuICAgIHJhdGlvOiAwLFxuICAgIGFycm93aGVhZFR5cGU6ICdzb3VyY2UnLFxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ2QnOiAnTSAxMCAtOCAtMTAgMCAxMCA4IFonLFxuICAgICAgICAnZmlsbCc6ICcjMzMzMzRGJyxcbiAgICAgICAgJ3N0cm9rZSc6ICcjRkZGRkZGJyxcbiAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICdjdXJzb3InOiAnbW92ZScsXG4gICAgICAgICdjbGFzcyc6ICdzb3VyY2UtYXJyb3doZWFkJ1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Arrowhead.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkTools/RotateLabel.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/RotateLabel.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RotateLabel: function() { return /* binding */ RotateLabel; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cellTools/Control.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Control.mjs\");\n\n\n\nconst RotateLabel = _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_0__.Control.extend({\n\n    xAxisVector: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(1, 0),\n\n    children() {\n        const {\n            buttonColor = '#333',\n            iconColor = '#fff',\n            outlineColor = '#fff'\n        } = this.options;\n        return [{\n            selector: 'handle',\n            tagName: 'g',\n            attributes: {\n                cursor: 'grab',\n            },\n            children: [{\n                tagName: 'circle',\n                attributes: {\n                    r: 10,\n                    fill: buttonColor,\n                    stroke: outlineColor,\n                },\n            }, {\n                tagName: 'path',\n                attributes: {\n                    d: 'M -5 0 A 5 5 0 1 1 0 5',\n                    fill: 'transparent',\n                    stroke: iconColor,\n                    strokeWidth: 2,\n                    strokeLinecap: 'round',\n                },\n            }, {\n                tagName: 'path',\n                attributes: {\n                    d: 'M -3 5 L 0 2.5 0 7.5 Z',\n                    fill: iconColor,\n                    stroke: iconColor,\n                    strokeWidth: 1,\n                    transform: 'rotate(-5, -3, 5)',\n                }\n            }]\n        }];\n    },\n\n    getPosition(view) {\n        const { offset = 0 } = this.options;\n        const { x = 0, y = 0 } = typeof offset === 'number' ? { x: 0, y: offset } : offset;\n        const label = this.getLabel();\n        const labelPosition = this.getLabelPosition(label);\n        const coords = view.getLabelCoordinates(labelPosition);\n        let { angle = 0, args = {}} = labelPosition;\n        const keepGradient = args.keepGradient;\n        if (keepGradient) {\n            const tangent = view.getTangentAtRatio(\n                view.getClosestPointRatio(coords)\n            );\n            if (tangent) {\n                // link slope angle\n                angle += tangent.vector().vectorAngle(this.xAxisVector) || 0;\n            }\n        }\n        const matrix = new DOMMatrix()\n            .translate(coords.x, coords.y)\n            .rotate(angle)\n            .translate(x, y);\n        return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point(matrix.e, matrix.f);\n    },\n\n    // Override the default `computeVisibility` method to hide the tool if the label is not present.\n    computeVisibility() {\n        const visibility = _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_0__.Control.prototype.computeVisibility.apply(this, arguments);\n        return visibility && !!this.getLabel();\n    },\n\n    setPosition(view, coordinates) {\n        const model = view.model;\n        const label = this.getLabel();\n        if (!label) return;\n        const labelPosition = this.getLabelPosition(label);\n        const position = view.getLabelCoordinates(labelPosition);\n        const angle = 90 - position.theta(coordinates);\n        const index = this.getLabelIndex();\n        model.prop(['labels', index, 'position', 'angle'], angle);\n    },\n\n    resetPosition(view) {\n        const model = view.model;\n        const index = this.getLabelIndex();\n        model.prop(['labels', index, 'position', 'angle'], 0);\n    },\n\n    getLabelIndex() {\n        return this.options.labelIndex || 0;\n    },\n\n    getLabel() {\n        return this.relatedView.model.label(this.getLabelIndex()) || null;\n    },\n\n    getLabelPosition(label) {\n        const view = this.relatedView;\n        const labelPosition = view._normalizeLabelPosition(label.position);\n        return view._mergeLabelPositionProperty(labelPosition, view._getDefaultLabelPositionProperty());\n    },\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL1JvdGF0ZUxhYmVsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFDZTs7QUFFNUMsb0JBQW9CLDJEQUFPOztBQUVsQyxxQkFBcUIsK0NBQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLGVBQWUsaUNBQWlDLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUFPO0FBQzFCLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDJCQUEyQiwyREFBTztBQUNsQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9saW5rVG9vbHMvUm90YXRlTGFiZWwubWpzP2ZiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBDb250cm9sIH0gZnJvbSAnLi4vY2VsbFRvb2xzL0NvbnRyb2wubWpzJztcblxuZXhwb3J0IGNvbnN0IFJvdGF0ZUxhYmVsID0gQ29udHJvbC5leHRlbmQoe1xuXG4gICAgeEF4aXNWZWN0b3I6IG5ldyBnLlBvaW50KDEsIDApLFxuXG4gICAgY2hpbGRyZW4oKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGJ1dHRvbkNvbG9yID0gJyMzMzMnLFxuICAgICAgICAgICAgaWNvbkNvbG9yID0gJyNmZmYnLFxuICAgICAgICAgICAgb3V0bGluZUNvbG9yID0gJyNmZmYnXG4gICAgICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdoYW5kbGUnLFxuICAgICAgICAgICAgdGFnTmFtZTogJ2cnLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGN1cnNvcjogJ2dyYWInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcjogMTAsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IGJ1dHRvbkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG91dGxpbmVDb2xvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGQ6ICdNIC01IDAgQSA1IDUgMCAxIDEgMCA1JyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBpY29uQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZDogJ00gLTMgNSBMIDAgMi41IDAgNy41IFonLFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBpY29uQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogaWNvbkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKC01LCAtMywgNSknLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgIH1dO1xuICAgIH0sXG5cbiAgICBnZXRQb3NpdGlvbih2aWV3KSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0ID0gMCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB7IHggPSAwLCB5ID0gMCB9ID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyB7IHg6IDAsIHk6IG9mZnNldCB9IDogb2Zmc2V0O1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWwoKTtcbiAgICAgICAgY29uc3QgbGFiZWxQb3NpdGlvbiA9IHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihsYWJlbCk7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHZpZXcuZ2V0TGFiZWxDb29yZGluYXRlcyhsYWJlbFBvc2l0aW9uKTtcbiAgICAgICAgbGV0IHsgYW5nbGUgPSAwLCBhcmdzID0ge319ID0gbGFiZWxQb3NpdGlvbjtcbiAgICAgICAgY29uc3Qga2VlcEdyYWRpZW50ID0gYXJncy5rZWVwR3JhZGllbnQ7XG4gICAgICAgIGlmIChrZWVwR3JhZGllbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhbmdlbnQgPSB2aWV3LmdldFRhbmdlbnRBdFJhdGlvKFxuICAgICAgICAgICAgICAgIHZpZXcuZ2V0Q2xvc2VzdFBvaW50UmF0aW8oY29vcmRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh0YW5nZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gbGluayBzbG9wZSBhbmdsZVxuICAgICAgICAgICAgICAgIGFuZ2xlICs9IHRhbmdlbnQudmVjdG9yKCkudmVjdG9yQW5nbGUodGhpcy54QXhpc1ZlY3RvcikgfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRyaXggPSBuZXcgRE9NTWF0cml4KClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoY29vcmRzLngsIGNvb3Jkcy55KVxuICAgICAgICAgICAgLnJvdGF0ZShhbmdsZSlcbiAgICAgICAgICAgIC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIHJldHVybiBuZXcgZy5Qb2ludChtYXRyaXguZSwgbWF0cml4LmYpO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBgY29tcHV0ZVZpc2liaWxpdHlgIG1ldGhvZCB0byBoaWRlIHRoZSB0b29sIGlmIHRoZSBsYWJlbCBpcyBub3QgcHJlc2VudC5cbiAgICBjb21wdXRlVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IENvbnRyb2wucHJvdG90eXBlLmNvbXB1dGVWaXNpYmlsaXR5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB2aXNpYmlsaXR5ICYmICEhdGhpcy5nZXRMYWJlbCgpO1xuICAgIH0sXG5cbiAgICBzZXRQb3NpdGlvbih2aWV3LCBjb29yZGluYXRlcykge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHZpZXcubW9kZWw7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbCgpO1xuICAgICAgICBpZiAoIWxhYmVsKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGxhYmVsUG9zaXRpb24gPSB0aGlzLmdldExhYmVsUG9zaXRpb24obGFiZWwpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHZpZXcuZ2V0TGFiZWxDb29yZGluYXRlcyhsYWJlbFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSA5MCAtIHBvc2l0aW9uLnRoZXRhKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldExhYmVsSW5kZXgoKTtcbiAgICAgICAgbW9kZWwucHJvcChbJ2xhYmVscycsIGluZGV4LCAncG9zaXRpb24nLCAnYW5nbGUnXSwgYW5nbGUpO1xuICAgIH0sXG5cbiAgICByZXNldFBvc2l0aW9uKHZpZXcpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB2aWV3Lm1vZGVsO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0TGFiZWxJbmRleCgpO1xuICAgICAgICBtb2RlbC5wcm9wKFsnbGFiZWxzJywgaW5kZXgsICdwb3NpdGlvbicsICdhbmdsZSddLCAwKTtcbiAgICB9LFxuXG4gICAgZ2V0TGFiZWxJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbEluZGV4IHx8IDA7XG4gICAgfSxcblxuICAgIGdldExhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGVkVmlldy5tb2RlbC5sYWJlbCh0aGlzLmdldExhYmVsSW5kZXgoKSkgfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgZ2V0TGFiZWxQb3NpdGlvbihsYWJlbCkge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgY29uc3QgbGFiZWxQb3NpdGlvbiA9IHZpZXcuX25vcm1hbGl6ZUxhYmVsUG9zaXRpb24obGFiZWwucG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdmlldy5fbWVyZ2VMYWJlbFBvc2l0aW9uUHJvcGVydHkobGFiZWxQb3NpdGlvbiwgdmlldy5fZ2V0RGVmYXVsdExhYmVsUG9zaXRpb25Qcm9wZXJ0eSgpKTtcbiAgICB9LFxuXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkTools/RotateLabel.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Segments.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Segments.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Segments: function() { return /* binding */ Segments; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cellTools/helpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/helpers.mjs\");\n\n\n\n\n\n\n\nvar SegmentHandle = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: 'g',\n    svgElement: true,\n    className: 'marker-segment',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    children: [{\n        tagName: 'line',\n        selector: 'line',\n        attributes: {\n            'stroke': '#33334F',\n            'stroke-width': 2,\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'rect',\n        selector: 'handle',\n        attributes: {\n            'width': 20,\n            'height': 8,\n            'x': -10,\n            'y': -4,\n            'rx': 4,\n            'ry': 4,\n            'fill': '#33334F',\n            'stroke': '#FFFFFF',\n            'stroke-width': 2\n        }\n    }],\n    onRender: function() {\n        this.renderChildren();\n    },\n    position: function(x, y, angle, view) {\n        const { scale } = this.options;\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix().translate(x, y).rotate(angle);\n        if (scale) matrix = matrix.scale(scale);\n\n        var handle = this.childNodes.handle;\n        handle.setAttribute('transform', _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].matrixToTransformString(matrix));\n        handle.setAttribute('cursor', (angle % 180 === 0) ? 'row-resize' : 'col-resize');\n\n        var viewPoint = view.getClosestPoint(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x, y));\n        var line = this.childNodes.line;\n        line.setAttribute('x1', x);\n        line.setAttribute('y1', y);\n        line.setAttribute('x2', viewPoint.x);\n        line.setAttribute('y2', viewPoint.y);\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        this.trigger('change:start', this, evt);\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n        this.trigger('change:end', this, evt);\n    },\n    show: function() {\n        this.el.style.display = '';\n    },\n    hide: function() {\n        this.el.style.display = 'none';\n    }\n});\n\nconst Segments = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_3__.ToolView.extend({\n    name: 'segments',\n    precision: .5,\n    options: {\n        handleClass: SegmentHandle,\n        segmentLengthThreshold: 40,\n        redundancyRemoval: true,\n        anchor: _cellTools_helpers_mjs__WEBPACK_IMPORTED_MODULE_4__.getAnchor,\n        snapRadius: 10,\n        snapHandle: true,\n        stopPropagation: true\n    },\n    handles: null,\n    onRender: function() {\n        this.resetHandles();\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        vertices.unshift(relatedView.sourcePoint);\n        vertices.push(relatedView.targetPoint);\n        for (var i = 0, n = vertices.length; i < n - 1; i++) {\n            var vertex = vertices[i];\n            var nextVertex = vertices[i + 1];\n            var handle = this.renderHandle(vertex, nextVertex);\n            this.simulateRelatedView(handle.el);\n            this.handles.push(handle);\n            handle.options.index = i;\n        }\n        return this;\n    },\n    renderHandle: function(vertex, nextVertex) {\n        var handle = new (this.options.handleClass)({\n            paper: this.paper,\n            scale: this.options.scale,\n            guard: evt => this.guard(evt)\n        });\n        handle.render();\n        this.updateHandle(handle, vertex, nextVertex);\n        handle.vel.appendTo(this.el);\n        this.startHandleListening(handle);\n        return handle;\n    },\n    update: function() {\n        this.render();\n        return this;\n    },\n    startHandleListening: function(handle) {\n        this.listenTo(handle, 'change:start', this.onHandleChangeStart);\n        this.listenTo(handle, 'changing', this.onHandleChanging);\n        this.listenTo(handle, 'change:end', this.onHandleChangeEnd);\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    shiftHandleIndexes: function(value) {\n        var handles = this.handles;\n        for (var i = 0, n = handles.length; i < n; i++) handles[i].options.index += value;\n    },\n    resetAnchor: function(type, anchor) {\n        var relatedModel = this.relatedView.model;\n        if (anchor) {\n            relatedModel.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                tool: this.cid\n            });\n        } else {\n            relatedModel.removeProp([type, 'anchor'], {\n                ui: true,\n                tool: this.cid\n            });\n        }\n    },\n    snapHandle: function(handle, position, data) {\n\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        var link = linkView.model;\n        var vertices = link.vertices();\n        var axis = handle.options.axis;\n        var prev = vertices[index - 2] || data.sourceAnchor;\n        var next = vertices[index + 1] || data.targetAnchor;\n        var snapRadius = this.options.snapRadius;\n        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n            position[axis] = prev[axis];\n        } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n            position[axis] = next[axis];\n        }\n        return position;\n    },\n\n    onHandleChanging: function(handle, evt) {\n\n        const { options } = this;\n        var data = this.eventData(evt);\n        var relatedView = this.relatedView;\n        var paper = relatedView.paper;\n        var index = handle.options.index - 1;\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent(evt);\n        var coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        var position = this.snapHandle(handle, coords.clone(), data);\n        var axis = handle.options.axis;\n        var offset = (this.options.snapHandle) ? 0 : (coords[axis] - position[axis]);\n        var link = relatedView.model;\n        var vertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.cloneDeep(link.vertices());\n        var anchorFn = this.options.anchor;\n        if (typeof anchorFn !== 'function') anchorFn = null;\n\n        const handleIndex = handle.options.index;\n\n        const vertexPoints = [relatedView.sourcePoint.clone(), ...vertices, relatedView.targetPoint.clone()];\n        let indexOffset = 0;\n\n        // check if vertex before handle vertex exists\n        if (handleIndex - 1 >= 0) {\n            const v1 = vertexPoints[handleIndex - 1];\n            const v2 = vertexPoints[handleIndex];\n\n            const theta = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                vertices.splice(handleIndex - 1, 0, data.originalVertices[handleIndex - 1]);\n                indexOffset++;\n                this.shiftHandleIndexes(1);\n            }\n        }\n\n        var vertex = vertices[index + indexOffset];\n        var nextVertex = vertices[index + 1 + indexOffset];\n\n        // check if vertex after handle vertex exists\n        if (handleIndex + 2 < vertexPoints.length) {\n            const v1 = vertexPoints[handleIndex + 1];\n            const v2 = vertexPoints[handleIndex + 2];\n\n            const theta = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Line(v1, v2).vector().theta();\n\n            // check only non-orthogonal segments\n            if (theta % 90 !== 0) {\n                const isSingleVertex = data.originalVertices.length === 1;\n                const origVIndex = isSingleVertex ? 0 : handleIndex;\n                const additionalOffset = data.firstHandleShifted && !isSingleVertex ? 1 : 0;\n                let nextVIndex = 1 + indexOffset;\n                vertices.splice(handleIndex + nextVIndex, 0, data.originalVertices[origVIndex - additionalOffset]);\n            }\n        }\n\n        // First Segment\n        var sourceView = relatedView.sourceView;\n        var sourceBBox = relatedView.sourceBBox;\n        var changeSourceAnchor = false;\n        var deleteSourceAnchor = false;\n        if (!vertex) {\n            vertex = relatedView.sourceAnchor.toJSON();\n            vertex[axis] = position[axis];\n            if (sourceBBox.containsPoint(vertex)) {\n                vertex[axis] = position[axis];\n                changeSourceAnchor = true;\n            } else {\n                // we left the area of the source magnet for the first time\n                vertices.unshift(vertex);\n                this.shiftHandleIndexes(1);\n                data.firstHandleShifted = true;\n                deleteSourceAnchor = true;\n            }\n        } else if (index === 0) {\n            if (sourceBBox.containsPoint(vertex)) {\n                vertices.shift();\n                this.shiftHandleIndexes(-1);\n                changeSourceAnchor = true;\n            } else {\n                vertex[axis] = position[axis];\n                deleteSourceAnchor = true;\n            }\n        } else {\n            vertex[axis] = position[axis];\n        }\n\n        if (anchorFn && sourceView) {\n            if (changeSourceAnchor) {\n                var sourceAnchorPosition = data.sourceAnchor.clone();\n                sourceAnchorPosition[axis] = position[axis];\n                var sourceAnchor = anchorFn.call(relatedView, sourceAnchorPosition, sourceView, relatedView.sourceMagnet || sourceView.el, 'source', relatedView);\n                this.resetAnchor('source', sourceAnchor);\n            }\n            if (deleteSourceAnchor) {\n                this.resetAnchor('source', data.sourceAnchorDef);\n            }\n        }\n\n        // Last segment\n        var targetView = relatedView.targetView;\n        var targetBBox = relatedView.targetBBox;\n        var changeTargetAnchor = false;\n        var deleteTargetAnchor = false;\n        if (!nextVertex) {\n            nextVertex = relatedView.targetAnchor.toJSON();\n            nextVertex[axis] = position[axis];\n            if (targetBBox.containsPoint(nextVertex)) {\n                changeTargetAnchor = true;\n            } else {\n                // we left the area of the target magnet for the first time\n                vertices.push(nextVertex);\n                deleteTargetAnchor = true;\n            }\n        } else if (index === vertices.length - 2) {\n            if (targetBBox.containsPoint(nextVertex)) {\n                vertices.pop();\n                changeTargetAnchor = true;\n            } else {\n                nextVertex[axis] = position[axis];\n                deleteTargetAnchor = true;\n            }\n        } else {\n            nextVertex[axis] = position[axis];\n        }\n\n        if (anchorFn && targetView) {\n            if (changeTargetAnchor) {\n                var targetAnchorPosition = data.targetAnchor.clone();\n                targetAnchorPosition[axis] = position[axis];\n                var targetAnchor = anchorFn.call(relatedView, targetAnchorPosition, targetView, relatedView.targetMagnet || targetView.el, 'target', relatedView);\n                this.resetAnchor('target', targetAnchor);\n            }\n            if (deleteTargetAnchor) {\n                this.resetAnchor('target', data.targetAnchorDef);\n            }\n        }\n        if (vertices.some(v => !v)) {\n            // This can happen when the link is using a smart routing and the number of\n            // vertices is not the same as the number of route points.\n            throw new Error('Segments: incompatible router in use');\n        }\n        link.vertices(vertices, { ui: true, tool: this.cid });\n        this.updateHandle(handle, vertex, nextVertex, offset);\n        if (!options.stopPropagation) relatedView.notifyPointermove(normalizedEvent, coords.x, coords.y);\n    },\n    onHandleChangeStart: function(handle, evt) {\n        const { options, handles, relatedView: linkView } = this;\n        const { model, paper } = linkView;\n        var index = handle.options.index;\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            if (i !== index) handles[i].hide();\n        }\n        this.focus();\n        this.eventData(evt, {\n            sourceAnchor: linkView.sourceAnchor.clone(),\n            targetAnchor: linkView.targetAnchor.clone(),\n            sourceAnchorDef: _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.clone(model.prop(['source', 'anchor'])),\n            targetAnchorDef: _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.clone(model.prop(['target', 'anchor'])),\n            originalVertices: _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.cloneDeep(model.vertices()),\n            firstHandleShifted: false\n        });\n        model.startBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerdown(...paper.getPointerArgs(evt));\n    },\n    onHandleChangeEnd: function(_handle, evt) {\n        const { options, relatedView: linkView }= this;\n        const { paper, model } = linkView;\n        if (options.redundancyRemoval) {\n            linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        }\n        const normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_5__.normalizeEvent(evt);\n        const coords = paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.render();\n        this.blur();\n        model.stopBatch('segment-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvent, coords.x, coords.y);\n        linkView.checkMouseleave(normalizedEvent);\n    },\n    updateHandle: function(handle, vertex, nextVertex, offset) {\n        var vertical = Math.abs(vertex.x - nextVertex.x) < this.precision;\n        var horizontal = Math.abs(vertex.y - nextVertex.y) < this.precision;\n        if (vertical || horizontal) {\n            var segmentLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_7__.Line(vertex, nextVertex);\n            var length = segmentLine.length();\n            if (length < this.options.segmentLengthThreshold) {\n                handle.hide();\n            } else {\n                var position = segmentLine.midpoint();\n                var axis = (vertical) ? 'x' : 'y';\n                position[axis] += offset || 0;\n                var angle = segmentLine.vector().vectorAngle(new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(1, 0));\n                handle.position(position.x, position.y, angle, this.relatedView);\n                handle.show();\n                handle.options.axis = axis;\n            }\n        } else {\n            handle.hide();\n        }\n    },\n    onRemove: function() {\n        this.resetHandles();\n    }\n}, {\n    SegmentHandle: SegmentHandle // keep as class property\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL1NlZ21lbnRzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb0M7QUFDTDtBQUNXO0FBQ0Y7QUFDTztBQUNNOztBQUVyRCxvQkFBb0IsZ0RBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLHFCQUFxQixvREFBQztBQUN0Qjs7QUFFQTtBQUNBLHlDQUF5QyxvREFBQztBQUMxQzs7QUFFQSxpREFBaUQsK0NBQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTSxpQkFBaUIsdURBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VG9vbHMvU2VnbWVudHMubWpzP2I5YzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIG12YyBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCB7IFRvb2xWaWV3IH0gZnJvbSAnLi4vZGlhL1Rvb2xWaWV3Lm1qcyc7XG5pbXBvcnQgeyBnZXRBbmNob3IgfSBmcm9tICcuLi9jZWxsVG9vbHMvaGVscGVycy5tanMnO1xuXG52YXIgU2VnbWVudEhhbmRsZSA9IG12Yy5WaWV3LmV4dGVuZCh7XG4gICAgdGFnTmFtZTogJ2cnLFxuICAgIHN2Z0VsZW1lbnQ6IHRydWUsXG4gICAgY2xhc3NOYW1lOiAnbWFya2VyLXNlZ21lbnQnLFxuICAgIGV2ZW50czoge1xuICAgICAgICBtb3VzZWRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgICAgICAgdG91Y2hzdGFydDogJ29uUG9pbnRlckRvd24nXG4gICAgfSxcbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICdvblBvaW50ZXJNb3ZlJyxcbiAgICAgICAgdG91Y2htb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIG1vdXNldXA6ICdvblBvaW50ZXJVcCcsXG4gICAgICAgIHRvdWNoZW5kOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGNhbmNlbDogJ29uUG9pbnRlclVwJ1xuICAgIH0sXG4gICAgY2hpbGRyZW46IFt7XG4gICAgICAgIHRhZ05hbWU6ICdsaW5lJyxcbiAgICAgICAgc2VsZWN0b3I6ICdsaW5lJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3N0cm9rZSc6ICcjMzMzMzRGJyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICBzZWxlY3RvcjogJ2hhbmRsZScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICd3aWR0aCc6IDIwLFxuICAgICAgICAgICAgJ2hlaWdodCc6IDgsXG4gICAgICAgICAgICAneCc6IC0xMCxcbiAgICAgICAgICAgICd5JzogLTQsXG4gICAgICAgICAgICAncngnOiA0LFxuICAgICAgICAgICAgJ3J5JzogNCxcbiAgICAgICAgICAgICdmaWxsJzogJyMzMzMzNEYnLFxuICAgICAgICAgICAgJ3N0cm9rZSc6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgICdzdHJva2Utd2lkdGgnOiAyXG4gICAgICAgIH1cbiAgICB9XSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4oKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbih4LCB5LCBhbmdsZSwgdmlldykge1xuICAgICAgICBjb25zdCB7IHNjYWxlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGxldCBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZSh4LCB5KS5yb3RhdGUoYW5nbGUpO1xuICAgICAgICBpZiAoc2NhbGUpIG1hdHJpeCA9IG1hdHJpeC5zY2FsZShzY2FsZSk7XG5cbiAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuY2hpbGROb2Rlcy5oYW5kbGU7XG4gICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFYubWF0cml4VG9UcmFuc2Zvcm1TdHJpbmcobWF0cml4KSk7XG4gICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoJ2N1cnNvcicsIChhbmdsZSAlIDE4MCA9PT0gMCkgPyAncm93LXJlc2l6ZScgOiAnY29sLXJlc2l6ZScpO1xuXG4gICAgICAgIHZhciB2aWV3UG9pbnQgPSB2aWV3LmdldENsb3Nlc3RQb2ludChuZXcgZy5Qb2ludCh4LCB5KSk7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5jaGlsZE5vZGVzLmxpbmU7XG4gICAgICAgIGxpbmUuc2V0QXR0cmlidXRlKCd4MScsIHgpO1xuICAgICAgICBsaW5lLnNldEF0dHJpYnV0ZSgneTEnLCB5KTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3gyJywgdmlld1BvaW50LngpO1xuICAgICAgICBsaW5lLnNldEF0dHJpYnV0ZSgneTInLCB2aWV3UG9pbnQueSk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ndWFyZChldnQpKSByZXR1cm47XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnN0YXJ0JywgdGhpcywgZXZ0KTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhcGVyLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKG51bGwsIGV2dC5kYXRhKTtcbiAgICB9LFxuICAgIG9uUG9pbnRlck1vdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5naW5nJywgdGhpcywgZXZ0KTtcbiAgICB9LFxuICAgIG9uUG9pbnRlclVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhcGVyLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmVuZCcsIHRoaXMsIGV2dCk7XG4gICAgfSxcbiAgICBzaG93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgU2VnbWVudHMgPSBUb29sVmlldy5leHRlbmQoe1xuICAgIG5hbWU6ICdzZWdtZW50cycsXG4gICAgcHJlY2lzaW9uOiAuNSxcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGhhbmRsZUNsYXNzOiBTZWdtZW50SGFuZGxlLFxuICAgICAgICBzZWdtZW50TGVuZ3RoVGhyZXNob2xkOiA0MCxcbiAgICAgICAgcmVkdW5kYW5jeVJlbW92YWw6IHRydWUsXG4gICAgICAgIGFuY2hvcjogZ2V0QW5jaG9yLFxuICAgICAgICBzbmFwUmFkaXVzOiAxMCxcbiAgICAgICAgc25hcEhhbmRsZTogdHJ1ZSxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiB0cnVlXG4gICAgfSxcbiAgICBoYW5kbGVzOiBudWxsLFxuICAgIG9uUmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNldEhhbmRsZXMoKTtcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gcmVsYXRlZFZpZXcubW9kZWwudmVydGljZXMoKTtcbiAgICAgICAgdmVydGljZXMudW5zaGlmdChyZWxhdGVkVmlldy5zb3VyY2VQb2ludCk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2gocmVsYXRlZFZpZXcudGFyZ2V0UG9pbnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIHZhciBuZXh0VmVydGV4ID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMucmVuZGVySGFuZGxlKHZlcnRleCwgbmV4dFZlcnRleCk7XG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRlUmVsYXRlZFZpZXcoaGFuZGxlLmVsKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gICAgICAgICAgICBoYW5kbGUub3B0aW9ucy5pbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXJIYW5kbGU6IGZ1bmN0aW9uKHZlcnRleCwgbmV4dFZlcnRleCkge1xuICAgICAgICB2YXIgaGFuZGxlID0gbmV3ICh0aGlzLm9wdGlvbnMuaGFuZGxlQ2xhc3MpKHtcbiAgICAgICAgICAgIHBhcGVyOiB0aGlzLnBhcGVyLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9ucy5zY2FsZSxcbiAgICAgICAgICAgIGd1YXJkOiBldnQgPT4gdGhpcy5ndWFyZChldnQpXG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGUucmVuZGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlKGhhbmRsZSwgdmVydGV4LCBuZXh0VmVydGV4KTtcbiAgICAgICAgaGFuZGxlLnZlbC5hcHBlbmRUbyh0aGlzLmVsKTtcbiAgICAgICAgdGhpcy5zdGFydEhhbmRsZUxpc3RlbmluZyhoYW5kbGUpO1xuICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdGFydEhhbmRsZUxpc3RlbmluZzogZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oaGFuZGxlLCAnY2hhbmdlOnN0YXJ0JywgdGhpcy5vbkhhbmRsZUNoYW5nZVN0YXJ0KTtcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhoYW5kbGUsICdjaGFuZ2luZycsIHRoaXMub25IYW5kbGVDaGFuZ2luZyk7XG4gICAgICAgIHRoaXMubGlzdGVuVG8oaGFuZGxlLCAnY2hhbmdlOmVuZCcsIHRoaXMub25IYW5kbGVDaGFuZ2VFbmQpO1xuICAgIH0sXG4gICAgcmVzZXRIYW5kbGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhhbmRsZXMpKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaGFuZGxlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGhhbmRsZXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNoaWZ0SGFuZGxlSW5kZXhlczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gaGFuZGxlcy5sZW5ndGg7IGkgPCBuOyBpKyspIGhhbmRsZXNbaV0ub3B0aW9ucy5pbmRleCArPSB2YWx1ZTtcbiAgICB9LFxuICAgIHJlc2V0QW5jaG9yOiBmdW5jdGlvbih0eXBlLCBhbmNob3IpIHtcbiAgICAgICAgdmFyIHJlbGF0ZWRNb2RlbCA9IHRoaXMucmVsYXRlZFZpZXcubW9kZWw7XG4gICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgIHJlbGF0ZWRNb2RlbC5wcm9wKFt0eXBlLCAnYW5jaG9yJ10sIGFuY2hvciwge1xuICAgICAgICAgICAgICAgIHJld3JpdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdWk6IHRydWUsXG4gICAgICAgICAgICAgICAgdG9vbDogdGhpcy5jaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsYXRlZE1vZGVsLnJlbW92ZVByb3AoW3R5cGUsICdhbmNob3InXSwge1xuICAgICAgICAgICAgICAgIHVpOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRvb2w6IHRoaXMuY2lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc25hcEhhbmRsZTogZnVuY3Rpb24oaGFuZGxlLCBwb3NpdGlvbiwgZGF0YSkge1xuXG4gICAgICAgIHZhciBpbmRleCA9IGhhbmRsZS5vcHRpb25zLmluZGV4O1xuICAgICAgICB2YXIgbGlua1ZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgbGluayA9IGxpbmtWaWV3Lm1vZGVsO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBsaW5rLnZlcnRpY2VzKCk7XG4gICAgICAgIHZhciBheGlzID0gaGFuZGxlLm9wdGlvbnMuYXhpcztcbiAgICAgICAgdmFyIHByZXYgPSB2ZXJ0aWNlc1tpbmRleCAtIDJdIHx8IGRhdGEuc291cmNlQW5jaG9yO1xuICAgICAgICB2YXIgbmV4dCA9IHZlcnRpY2VzW2luZGV4ICsgMV0gfHwgZGF0YS50YXJnZXRBbmNob3I7XG4gICAgICAgIHZhciBzbmFwUmFkaXVzID0gdGhpcy5vcHRpb25zLnNuYXBSYWRpdXM7XG4gICAgICAgIGlmIChNYXRoLmFicyhwb3NpdGlvbltheGlzXSAtIHByZXZbYXhpc10pIDwgc25hcFJhZGl1cykge1xuICAgICAgICAgICAgcG9zaXRpb25bYXhpc10gPSBwcmV2W2F4aXNdO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHBvc2l0aW9uW2F4aXNdIC0gbmV4dFtheGlzXSkgPCBzbmFwUmFkaXVzKSB7XG4gICAgICAgICAgICBwb3NpdGlvbltheGlzXSA9IG5leHRbYXhpc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICBvbkhhbmRsZUNoYW5naW5nOiBmdW5jdGlvbihoYW5kbGUsIGV2dCkge1xuXG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmV2ZW50RGF0YShldnQpO1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgcGFwZXIgPSByZWxhdGVkVmlldy5wYXBlcjtcbiAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlLm9wdGlvbnMuaW5kZXggLSAxO1xuICAgICAgICB2YXIgbm9ybWFsaXplZEV2ZW50ID0gdXRpbC5ub3JtYWxpemVFdmVudChldnQpO1xuICAgICAgICB2YXIgY29vcmRzID0gcGFwZXIuc25hcFRvR3JpZChub3JtYWxpemVkRXZlbnQuY2xpZW50WCwgbm9ybWFsaXplZEV2ZW50LmNsaWVudFkpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnNuYXBIYW5kbGUoaGFuZGxlLCBjb29yZHMuY2xvbmUoKSwgZGF0YSk7XG4gICAgICAgIHZhciBheGlzID0gaGFuZGxlLm9wdGlvbnMuYXhpcztcbiAgICAgICAgdmFyIG9mZnNldCA9ICh0aGlzLm9wdGlvbnMuc25hcEhhbmRsZSkgPyAwIDogKGNvb3Jkc1theGlzXSAtIHBvc2l0aW9uW2F4aXNdKTtcbiAgICAgICAgdmFyIGxpbmsgPSByZWxhdGVkVmlldy5tb2RlbDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdXRpbC5jbG9uZURlZXAobGluay52ZXJ0aWNlcygpKTtcbiAgICAgICAgdmFyIGFuY2hvckZuID0gdGhpcy5vcHRpb25zLmFuY2hvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBhbmNob3JGbiAhPT0gJ2Z1bmN0aW9uJykgYW5jaG9yRm4gPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZUluZGV4ID0gaGFuZGxlLm9wdGlvbnMuaW5kZXg7XG5cbiAgICAgICAgY29uc3QgdmVydGV4UG9pbnRzID0gW3JlbGF0ZWRWaWV3LnNvdXJjZVBvaW50LmNsb25lKCksIC4uLnZlcnRpY2VzLCByZWxhdGVkVmlldy50YXJnZXRQb2ludC5jbG9uZSgpXTtcbiAgICAgICAgbGV0IGluZGV4T2Zmc2V0ID0gMDtcblxuICAgICAgICAvLyBjaGVjayBpZiB2ZXJ0ZXggYmVmb3JlIGhhbmRsZSB2ZXJ0ZXggZXhpc3RzXG4gICAgICAgIGlmIChoYW5kbGVJbmRleCAtIDEgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgdjEgPSB2ZXJ0ZXhQb2ludHNbaGFuZGxlSW5kZXggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gdmVydGV4UG9pbnRzW2hhbmRsZUluZGV4XTtcblxuICAgICAgICAgICAgY29uc3QgdGhldGEgPSBuZXcgZy5MaW5lKHYxLCB2MikudmVjdG9yKCkudGhldGEoKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgb25seSBub24tb3J0aG9nb25hbCBzZWdtZW50c1xuICAgICAgICAgICAgaWYgKHRoZXRhICUgOTAgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UoaGFuZGxlSW5kZXggLSAxLCAwLCBkYXRhLm9yaWdpbmFsVmVydGljZXNbaGFuZGxlSW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgaW5kZXhPZmZzZXQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0SGFuZGxlSW5kZXhlcygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1tpbmRleCArIGluZGV4T2Zmc2V0XTtcbiAgICAgICAgdmFyIG5leHRWZXJ0ZXggPSB2ZXJ0aWNlc1tpbmRleCArIDEgKyBpbmRleE9mZnNldF07XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdmVydGV4IGFmdGVyIGhhbmRsZSB2ZXJ0ZXggZXhpc3RzXG4gICAgICAgIGlmIChoYW5kbGVJbmRleCArIDIgPCB2ZXJ0ZXhQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB2MSA9IHZlcnRleFBvaW50c1toYW5kbGVJbmRleCArIDFdO1xuICAgICAgICAgICAgY29uc3QgdjIgPSB2ZXJ0ZXhQb2ludHNbaGFuZGxlSW5kZXggKyAyXTtcblxuICAgICAgICAgICAgY29uc3QgdGhldGEgPSBuZXcgZy5MaW5lKHYxLCB2MikudmVjdG9yKCkudGhldGEoKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgb25seSBub24tb3J0aG9nb25hbCBzZWdtZW50c1xuICAgICAgICAgICAgaWYgKHRoZXRhICUgOTAgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NpbmdsZVZlcnRleCA9IGRhdGEub3JpZ2luYWxWZXJ0aWNlcy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZJbmRleCA9IGlzU2luZ2xlVmVydGV4ID8gMCA6IGhhbmRsZUluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxPZmZzZXQgPSBkYXRhLmZpcnN0SGFuZGxlU2hpZnRlZCAmJiAhaXNTaW5nbGVWZXJ0ZXggPyAxIDogMDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZJbmRleCA9IDEgKyBpbmRleE9mZnNldDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5zcGxpY2UoaGFuZGxlSW5kZXggKyBuZXh0VkluZGV4LCAwLCBkYXRhLm9yaWdpbmFsVmVydGljZXNbb3JpZ1ZJbmRleCAtIGFkZGl0aW9uYWxPZmZzZXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpcnN0IFNlZ21lbnRcbiAgICAgICAgdmFyIHNvdXJjZVZpZXcgPSByZWxhdGVkVmlldy5zb3VyY2VWaWV3O1xuICAgICAgICB2YXIgc291cmNlQkJveCA9IHJlbGF0ZWRWaWV3LnNvdXJjZUJCb3g7XG4gICAgICAgIHZhciBjaGFuZ2VTb3VyY2VBbmNob3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRlbGV0ZVNvdXJjZUFuY2hvciA9IGZhbHNlO1xuICAgICAgICBpZiAoIXZlcnRleCkge1xuICAgICAgICAgICAgdmVydGV4ID0gcmVsYXRlZFZpZXcuc291cmNlQW5jaG9yLnRvSlNPTigpO1xuICAgICAgICAgICAgdmVydGV4W2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICBpZiAoc291cmNlQkJveC5jb250YWluc1BvaW50KHZlcnRleCkpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhbYXhpc10gPSBwb3NpdGlvbltheGlzXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VTb3VyY2VBbmNob3IgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBsZWZ0IHRoZSBhcmVhIG9mIHRoZSBzb3VyY2UgbWFnbmV0IGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnVuc2hpZnQodmVydGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0SGFuZGxlSW5kZXhlcygxKTtcbiAgICAgICAgICAgICAgICBkYXRhLmZpcnN0SGFuZGxlU2hpZnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlU291cmNlQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUJCb3guY29udGFpbnNQb2ludCh2ZXJ0ZXgpKSB7XG4gICAgICAgICAgICAgICAgdmVydGljZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0SGFuZGxlSW5kZXhlcygtMSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlU291cmNlQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVydGV4W2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICAgICAgZGVsZXRlU291cmNlQW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZlcnRleFtheGlzXSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuY2hvckZuICYmIHNvdXJjZVZpZXcpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VTb3VyY2VBbmNob3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQW5jaG9yUG9zaXRpb24gPSBkYXRhLnNvdXJjZUFuY2hvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUFuY2hvclBvc2l0aW9uW2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUFuY2hvciA9IGFuY2hvckZuLmNhbGwocmVsYXRlZFZpZXcsIHNvdXJjZUFuY2hvclBvc2l0aW9uLCBzb3VyY2VWaWV3LCByZWxhdGVkVmlldy5zb3VyY2VNYWduZXQgfHwgc291cmNlVmlldy5lbCwgJ3NvdXJjZScsIHJlbGF0ZWRWaWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QW5jaG9yKCdzb3VyY2UnLCBzb3VyY2VBbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbGV0ZVNvdXJjZUFuY2hvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbmNob3IoJ3NvdXJjZScsIGRhdGEuc291cmNlQW5jaG9yRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExhc3Qgc2VnbWVudFxuICAgICAgICB2YXIgdGFyZ2V0VmlldyA9IHJlbGF0ZWRWaWV3LnRhcmdldFZpZXc7XG4gICAgICAgIHZhciB0YXJnZXRCQm94ID0gcmVsYXRlZFZpZXcudGFyZ2V0QkJveDtcbiAgICAgICAgdmFyIGNoYW5nZVRhcmdldEFuY2hvciA9IGZhbHNlO1xuICAgICAgICB2YXIgZGVsZXRlVGFyZ2V0QW5jaG9yID0gZmFsc2U7XG4gICAgICAgIGlmICghbmV4dFZlcnRleCkge1xuICAgICAgICAgICAgbmV4dFZlcnRleCA9IHJlbGF0ZWRWaWV3LnRhcmdldEFuY2hvci50b0pTT04oKTtcbiAgICAgICAgICAgIG5leHRWZXJ0ZXhbYXhpc10gPSBwb3NpdGlvbltheGlzXTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRCQm94LmNvbnRhaW5zUG9pbnQobmV4dFZlcnRleCkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUYXJnZXRBbmNob3IgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBsZWZ0IHRoZSBhcmVhIG9mIHRoZSB0YXJnZXQgbWFnbmV0IGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2gobmV4dFZlcnRleCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlVGFyZ2V0QW5jaG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdmVydGljZXMubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgaWYgKHRhcmdldEJCb3guY29udGFpbnNQb2ludChuZXh0VmVydGV4KSkge1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNoYW5nZVRhcmdldEFuY2hvciA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRWZXJ0ZXhbYXhpc10gPSBwb3NpdGlvbltheGlzXTtcbiAgICAgICAgICAgICAgICBkZWxldGVUYXJnZXRBbmNob3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFZlcnRleFtheGlzXSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFuY2hvckZuICYmIHRhcmdldFZpZXcpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VUYXJnZXRBbmNob3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0QW5jaG9yUG9zaXRpb24gPSBkYXRhLnRhcmdldEFuY2hvci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvclBvc2l0aW9uW2F4aXNdID0gcG9zaXRpb25bYXhpc107XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEFuY2hvciA9IGFuY2hvckZuLmNhbGwocmVsYXRlZFZpZXcsIHRhcmdldEFuY2hvclBvc2l0aW9uLCB0YXJnZXRWaWV3LCByZWxhdGVkVmlldy50YXJnZXRNYWduZXQgfHwgdGFyZ2V0Vmlldy5lbCwgJ3RhcmdldCcsIHJlbGF0ZWRWaWV3KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QW5jaG9yKCd0YXJnZXQnLCB0YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbGV0ZVRhcmdldEFuY2hvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbmNob3IoJ3RhcmdldCcsIGRhdGEudGFyZ2V0QW5jaG9yRGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGljZXMuc29tZSh2ID0+ICF2KSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIGxpbmsgaXMgdXNpbmcgYSBzbWFydCByb3V0aW5nIGFuZCB0aGUgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyB2ZXJ0aWNlcyBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiByb3V0ZSBwb2ludHMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlZ21lbnRzOiBpbmNvbXBhdGlibGUgcm91dGVyIGluIHVzZScpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsudmVydGljZXModmVydGljZXMsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZShoYW5kbGUsIHZlcnRleCwgbmV4dFZlcnRleCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0b3BQcm9wYWdhdGlvbikgcmVsYXRlZFZpZXcubm90aWZ5UG9pbnRlcm1vdmUobm9ybWFsaXplZEV2ZW50LCBjb29yZHMueCwgY29vcmRzLnkpO1xuICAgIH0sXG4gICAgb25IYW5kbGVDaGFuZ2VTdGFydDogZnVuY3Rpb24oaGFuZGxlLCBldnQpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCBoYW5kbGVzLCByZWxhdGVkVmlldzogbGlua1ZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgbW9kZWwsIHBhcGVyIH0gPSBsaW5rVmlldztcbiAgICAgICAgdmFyIGluZGV4ID0gaGFuZGxlLm9wdGlvbnMuaW5kZXg7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShoYW5kbGVzKSkgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGhhbmRsZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXgpIGhhbmRsZXNbaV0uaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7XG4gICAgICAgICAgICBzb3VyY2VBbmNob3I6IGxpbmtWaWV3LnNvdXJjZUFuY2hvci5jbG9uZSgpLFxuICAgICAgICAgICAgdGFyZ2V0QW5jaG9yOiBsaW5rVmlldy50YXJnZXRBbmNob3IuY2xvbmUoKSxcbiAgICAgICAgICAgIHNvdXJjZUFuY2hvckRlZjogdXRpbC5jbG9uZShtb2RlbC5wcm9wKFsnc291cmNlJywgJ2FuY2hvciddKSksXG4gICAgICAgICAgICB0YXJnZXRBbmNob3JEZWY6IHV0aWwuY2xvbmUobW9kZWwucHJvcChbJ3RhcmdldCcsICdhbmNob3InXSkpLFxuICAgICAgICAgICAgb3JpZ2luYWxWZXJ0aWNlczogdXRpbC5jbG9uZURlZXAobW9kZWwudmVydGljZXMoKSksXG4gICAgICAgICAgICBmaXJzdEhhbmRsZVNoaWZ0ZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBtb2RlbC5zdGFydEJhdGNoKCdzZWdtZW50LW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0b3BQcm9wYWdhdGlvbikgbGlua1ZpZXcubm90aWZ5UG9pbnRlcmRvd24oLi4ucGFwZXIuZ2V0UG9pbnRlckFyZ3MoZXZ0KSk7XG4gICAgfSxcbiAgICBvbkhhbmRsZUNoYW5nZUVuZDogZnVuY3Rpb24oX2hhbmRsZSwgZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcmVsYXRlZFZpZXc6IGxpbmtWaWV3IH09IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgcGFwZXIsIG1vZGVsIH0gPSBsaW5rVmlldztcbiAgICAgICAgaWYgKG9wdGlvbnMucmVkdW5kYW5jeVJlbW92YWwpIHtcbiAgICAgICAgICAgIGxpbmtWaWV3LnJlbW92ZVJlZHVuZGFudExpbmVhclZlcnRpY2VzKHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFdmVudCA9IHV0aWwubm9ybWFsaXplRXZlbnQoZXZ0KTtcbiAgICAgICAgY29uc3QgY29vcmRzID0gcGFwZXIuc25hcFRvR3JpZChub3JtYWxpemVkRXZlbnQuY2xpZW50WCwgbm9ybWFsaXplZEV2ZW50LmNsaWVudFkpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgbW9kZWwuc3RvcEJhdGNoKCdzZWdtZW50LW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0b3BQcm9wYWdhdGlvbikgbGlua1ZpZXcubm90aWZ5UG9pbnRlcnVwKG5vcm1hbGl6ZWRFdmVudCwgY29vcmRzLngsIGNvb3Jkcy55KTtcbiAgICAgICAgbGlua1ZpZXcuY2hlY2tNb3VzZWxlYXZlKG5vcm1hbGl6ZWRFdmVudCk7XG4gICAgfSxcbiAgICB1cGRhdGVIYW5kbGU6IGZ1bmN0aW9uKGhhbmRsZSwgdmVydGV4LCBuZXh0VmVydGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsID0gTWF0aC5hYnModmVydGV4LnggLSBuZXh0VmVydGV4LngpIDwgdGhpcy5wcmVjaXNpb247XG4gICAgICAgIHZhciBob3Jpem9udGFsID0gTWF0aC5hYnModmVydGV4LnkgLSBuZXh0VmVydGV4LnkpIDwgdGhpcy5wcmVjaXNpb247XG4gICAgICAgIGlmICh2ZXJ0aWNhbCB8fCBob3Jpem9udGFsKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudExpbmUgPSBuZXcgZy5MaW5lKHZlcnRleCwgbmV4dFZlcnRleCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VnbWVudExpbmUubGVuZ3RoKCk7XG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgdGhpcy5vcHRpb25zLnNlZ21lbnRMZW5ndGhUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzZWdtZW50TGluZS5taWRwb2ludCgpO1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gKHZlcnRpY2FsKSA/ICd4JyA6ICd5JztcbiAgICAgICAgICAgICAgICBwb3NpdGlvbltheGlzXSArPSBvZmZzZXQgfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBzZWdtZW50TGluZS52ZWN0b3IoKS52ZWN0b3JBbmdsZShuZXcgZy5Qb2ludCgxLCAwKSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlLnBvc2l0aW9uKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGFuZ2xlLCB0aGlzLnJlbGF0ZWRWaWV3KTtcbiAgICAgICAgICAgICAgICBoYW5kbGUuc2hvdygpO1xuICAgICAgICAgICAgICAgIGhhbmRsZS5vcHRpb25zLmF4aXMgPSBheGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlc2V0SGFuZGxlcygpO1xuICAgIH1cbn0sIHtcbiAgICBTZWdtZW50SGFuZGxlOiBTZWdtZW50SGFuZGxlIC8vIGtlZXAgYXMgY2xhc3MgcHJvcGVydHlcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Segments.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Vertices.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/Vertices.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vertices: function() { return /* binding */ Vertices; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mvc/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dia/ToolView.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/ToolView.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\n\n\n\n\n\n// Vertex Handles\nvar VertexHandle = _mvc_index_mjs__WEBPACK_IMPORTED_MODULE_0__.View.extend({\n    tagName: 'circle',\n    svgElement: true,\n    className: 'marker-vertex',\n    events: {\n        mousedown: 'onPointerDown',\n        touchstart: 'onPointerDown',\n        dblclick: 'onDoubleClick',\n        dbltap: 'onDoubleClick'\n    },\n    documentEvents: {\n        mousemove: 'onPointerMove',\n        touchmove: 'onPointerMove',\n        mouseup: 'onPointerUp',\n        touchend: 'onPointerUp',\n        touchcancel: 'onPointerUp'\n    },\n    attributes: {\n        'r': 6,\n        'fill': '#33334F',\n        'stroke': '#FFFFFF',\n        'stroke-width': 2,\n        'cursor': 'move'\n    },\n    position: function(x, y) {\n        const { vel, options } = this;\n        const { scale } = options;\n        let matrix = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].createSVGMatrix().translate(x, y);\n        if (scale) matrix = matrix.scale(scale);\n        vel.transform(matrix, { absolute: true });\n    },\n    onPointerDown: function(evt) {\n        if (this.options.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.paper.undelegateEvents();\n        this.delegateDocumentEvents(null, evt.data);\n        this.trigger('will-change', this, evt);\n    },\n    onPointerMove: function(evt) {\n        this.trigger('changing', this, evt);\n    },\n    onDoubleClick: function(evt) {\n        this.trigger('remove', this, evt);\n    },\n    onPointerUp: function(evt) {\n        this.trigger('changed', this, evt);\n        this.undelegateDocumentEvents();\n        this.options.paper.delegateEvents();\n    }\n});\n\nconst Vertices = _dia_ToolView_mjs__WEBPACK_IMPORTED_MODULE_2__.ToolView.extend({\n    name: 'vertices',\n    options: {\n        handleClass: VertexHandle,\n        snapRadius: 20,\n        redundancyRemoval: true,\n        vertexAdding: true,\n        // vertexRemoving: true,\n        // vertexMoving: true,\n        stopPropagation: true,\n        scale: null\n    },\n    children: [{\n        tagName: 'path',\n        selector: 'connection',\n        className: 'joint-vertices-path',\n        attributes: {\n            'fill': 'none',\n            'stroke': 'transparent',\n            'stroke-width': 10,\n            'cursor': 'cell'\n        }\n    }],\n    handles: null,\n    interactiveLinkNode: null,\n    events: {\n        'mousedown .joint-vertices-path': 'onPathPointerDown',\n        'touchstart .joint-vertices-path': 'onPathPointerDown'\n    },\n    linkEvents: {\n        mousedown: 'onLinkPointerDown',\n        touchstart: 'onLinkPointerDown'\n    },\n    onRender: function() {\n        const { vertexAdding } = this.options;\n        if (vertexAdding) {\n            const { interactiveLinkNode = null } = vertexAdding;\n            if (interactiveLinkNode) {\n                this.delegateLinkEvents(interactiveLinkNode);\n            } else {\n                this.renderChildren();\n                this.updatePath();\n            }\n        }\n        this.resetHandles();\n        this.renderHandles();\n        return this;\n    },\n    delegateLinkEvents: function(selector) {\n        this.undelegateLinkEvents();\n        const el = this.relatedView.findNode(selector);\n        if (!el) {\n            console.warn(`Interactive link node \"${selector}\" not found.`);\n            return;\n        }\n        el.classList.add('joint-vertices-path');\n        this.interactiveLinkNode = el;\n        this.delegateElementEvents(el, this.linkEvents);\n    },\n    undelegateLinkEvents: function() {\n        const el = this.interactiveLinkNode;\n        if (!el) return;\n        this.undelegateElementEvents(el);\n        el.classList.remove('joint-vertices-path');\n        this.interactiveLinkNode = null;\n    },\n    update: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        if (vertices.length === this.handles.length) {\n            this.updateHandles();\n        } else {\n            this.resetHandles();\n            this.renderHandles();\n        }\n        if (this.options.vertexAdding) {\n            this.updatePath();\n        }\n        return this;\n    },\n    resetHandles: function() {\n        var handles = this.handles;\n        this.handles = [];\n        this.stopListening();\n        if (!Array.isArray(handles)) return;\n        for (var i = 0, n = handles.length; i < n; i++) {\n            handles[i].remove();\n        }\n    },\n    renderHandles: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        for (var i = 0, n = vertices.length; i < n; i++) {\n            var vertex = vertices[i];\n            var handle = new (this.options.handleClass)({\n                index: i,\n                paper: this.paper,\n                scale: this.options.scale,\n                guard: evt => this.guard(evt)\n            });\n            handle.render();\n            handle.position(vertex.x, vertex.y);\n            this.simulateRelatedView(handle.el);\n            handle.vel.appendTo(this.el);\n            this.handles.push(handle);\n            this.startHandleListening(handle);\n        }\n    },\n    updateHandles: function() {\n        var relatedView = this.relatedView;\n        var vertices = relatedView.model.vertices();\n        for (var i = 0, n = vertices.length; i < n; i++) {\n            var vertex = vertices[i];\n            var handle = this.handles[i];\n            if (!handle) return;\n            handle.position(vertex.x, vertex.y);\n        }\n    },\n    updatePath: function() {\n        if (this.interactiveLinkNode) return;\n        const connection = this.childNodes.connection;\n        if (connection) connection.setAttribute('d', this.relatedView.getSerializedConnection());\n    },\n    startHandleListening: function(handle) {\n        const { vertexRemoving = true, vertexMoving = true } = this.options;\n        if (vertexMoving) {\n            this.listenTo(handle, 'will-change', this.onHandleWillChange);\n            this.listenTo(handle, 'changing', this.onHandleChanging);\n            this.listenTo(handle, 'changed', this.onHandleChanged);\n        }\n        if (vertexRemoving) {\n            this.listenTo(handle, 'remove', this.onHandleRemove);\n        }\n    },\n    getNeighborPoints: function(index) {\n        var linkView = this.relatedView;\n        var vertices = linkView.model.vertices();\n        var prev = (index > 0) ? vertices[index - 1] : linkView.sourceAnchor;\n        var next = (index < vertices.length - 1) ? vertices[index + 1] : linkView.targetAnchor;\n        return {\n            prev: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(prev),\n            next: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(next)\n        };\n    },\n    onHandleWillChange: function(_handle, evt) {\n        this.focus();\n        const { relatedView, options } = this;\n        relatedView.model.startBatch('vertex-move', { ui: true, tool: this.cid });\n        if (!options.stopPropagation) relatedView.notifyPointerdown(...relatedView.paper.getPointerArgs(evt));\n    },\n    onHandleChanging: function(handle, evt) {\n        const { options, relatedView: linkView } = this;\n        var index = handle.options.index;\n        var [normalizedEvent, x, y] = linkView.paper.getPointerArgs(evt);\n        var vertex = { x, y };\n        this.snapVertex(vertex, index);\n        linkView.model.vertex(index, vertex, { ui: true, tool: this.cid });\n        handle.position(vertex.x, vertex.y);\n        if (!options.stopPropagation) linkView.notifyPointermove(normalizedEvent, x, y);\n    },\n    onHandleChanged: function(_handle, evt) {\n        const { options, relatedView: linkView } = this;\n        if (options.vertexAdding) this.updatePath();\n        if (!options.redundancyRemoval) {\n            linkView.checkMouseleave(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeEvent(evt));\n            return;\n        }\n        var verticesRemoved = linkView.removeRedundantLinearVertices({ ui: true, tool: this.cid });\n        if (verticesRemoved) this.render();\n        this.blur();\n        linkView.model.stopBatch('vertex-move', { ui: true, tool: this.cid });\n        if (this.eventData(evt).vertexAdded) {\n            linkView.model.stopBatch('vertex-add', { ui: true, tool: this.cid });\n        }\n        var [normalizedEvt, x, y] = linkView.paper.getPointerArgs(evt);\n        if (!options.stopPropagation) linkView.notifyPointerup(normalizedEvt, x, y);\n        linkView.checkMouseleave(normalizedEvt);\n    },\n    snapVertex: function(vertex, index) {\n        var snapRadius = this.options.snapRadius;\n        if (snapRadius > 0) {\n            var neighbors = this.getNeighborPoints(index);\n            var prev = neighbors.prev;\n            var next = neighbors.next;\n            if (Math.abs(vertex.x - prev.x) < snapRadius) {\n                vertex.x = prev.x;\n            } else if (Math.abs(vertex.x - next.x) < snapRadius) {\n                vertex.x = next.x;\n            }\n            if (Math.abs(vertex.y - prev.y) < snapRadius) {\n                vertex.y = neighbors.prev.y;\n            } else if (Math.abs(vertex.y - next.y) < snapRadius) {\n                vertex.y = next.y;\n            }\n        }\n    },\n    onHandleRemove: function(handle, evt) {\n        var index = handle.options.index;\n        var linkView = this.relatedView;\n        linkView.model.removeVertex(index, { ui: true });\n        if (this.options.vertexAdding) this.updatePath();\n        linkView.checkMouseleave(_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeEvent(evt));\n    },\n    onPathPointerDown: function(evt) {\n        if (this.guard(evt)) return;\n        evt.stopPropagation();\n        evt.preventDefault();\n        var normalizedEvent = _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.normalizeEvent(evt);\n        var vertex = this.paper.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY).toJSON();\n        var relatedView = this.relatedView;\n        relatedView.model.startBatch('vertex-add', { ui: true, tool: this.cid });\n        var index = relatedView.getVertexIndex(vertex.x, vertex.y);\n        this.snapVertex(vertex, index);\n        relatedView.model.insertVertex(index, vertex, { ui: true, tool: this.cid });\n        this.update();\n        var handle = this.handles[index];\n        this.eventData(normalizedEvent, { vertexAdded: true });\n        handle.onPointerDown(normalizedEvent);\n    },\n    onLinkPointerDown: function(evt) {\n        this.relatedView.preventDefaultInteraction(evt);\n        this.onPathPointerDown(evt);\n    },\n    onRemove: function() {\n        this.resetHandles();\n        this.undelegateLinkEvents();\n    }\n}, {\n    VertexHandle: VertexHandle // keep as class property\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL1ZlcnRpY2VzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0M7QUFDTTtBQUNGO0FBQ087QUFDaEI7OztBQUcvQjtBQUNBLG1CQUFtQixnREFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQixnQkFBZ0IsUUFBUTtBQUN4QixxQkFBcUIsb0RBQUM7QUFDdEI7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU0saUJBQWlCLHVEQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBTztBQUM3QixzQkFBc0IsK0NBQU87QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkMsc0RBQXNELDBCQUEwQjtBQUNoRjtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLCtDQUErQywwQkFBMEI7QUFDekU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBLHFDQUFxQywyREFBbUI7QUFDeEQ7QUFDQTtBQUNBLHVFQUF1RSwwQkFBMEI7QUFDakc7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEI7QUFDNUU7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0EsaUNBQWlDLDJEQUFtQjtBQUNwRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQW1CO0FBQ2pEO0FBQ0E7QUFDQSxxREFBcUQsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQSx3REFBd0QsMEJBQTBCO0FBQ2xGO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9saW5rVG9vbHMvVmVydGljZXMubWpzPzE0OWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIG12YyBmcm9tICcuLi9tdmMvaW5kZXgubWpzJztcbmltcG9ydCB7IFRvb2xWaWV3IH0gZnJvbSAnLi4vZGlhL1Rvb2xWaWV3Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5cblxuLy8gVmVydGV4IEhhbmRsZXNcbnZhciBWZXJ0ZXhIYW5kbGUgPSBtdmMuVmlldy5leHRlbmQoe1xuICAgIHRhZ05hbWU6ICdjaXJjbGUnLFxuICAgIHN2Z0VsZW1lbnQ6IHRydWUsXG4gICAgY2xhc3NOYW1lOiAnbWFya2VyLXZlcnRleCcsXG4gICAgZXZlbnRzOiB7XG4gICAgICAgIG1vdXNlZG93bjogJ29uUG9pbnRlckRvd24nLFxuICAgICAgICB0b3VjaHN0YXJ0OiAnb25Qb2ludGVyRG93bicsXG4gICAgICAgIGRibGNsaWNrOiAnb25Eb3VibGVDbGljaycsXG4gICAgICAgIGRibHRhcDogJ29uRG91YmxlQ2xpY2snXG4gICAgfSxcbiAgICBkb2N1bWVudEV2ZW50czoge1xuICAgICAgICBtb3VzZW1vdmU6ICdvblBvaW50ZXJNb3ZlJyxcbiAgICAgICAgdG91Y2htb3ZlOiAnb25Qb2ludGVyTW92ZScsXG4gICAgICAgIG1vdXNldXA6ICdvblBvaW50ZXJVcCcsXG4gICAgICAgIHRvdWNoZW5kOiAnb25Qb2ludGVyVXAnLFxuICAgICAgICB0b3VjaGNhbmNlbDogJ29uUG9pbnRlclVwJ1xuICAgIH0sXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICAncic6IDYsXG4gICAgICAgICdmaWxsJzogJyMzMzMzNEYnLFxuICAgICAgICAnc3Ryb2tlJzogJyNGRkZGRkYnLFxuICAgICAgICAnc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgJ2N1cnNvcic6ICdtb3ZlJ1xuICAgIH0sXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgY29uc3QgeyB2ZWwsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc2NhbGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBtYXRyaXggPSBWLmNyZWF0ZVNWR01hdHJpeCgpLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgaWYgKHNjYWxlKSBtYXRyaXggPSBtYXRyaXguc2NhbGUoc2NhbGUpO1xuICAgICAgICB2ZWwudHJhbnNmb3JtKG1hdHJpeCwgeyBhYnNvbHV0ZTogdHJ1ZSB9KTtcbiAgICB9LFxuICAgIG9uUG9pbnRlckRvd246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmd1YXJkKGV2dCkpIHJldHVybjtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhcGVyLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKG51bGwsIGV2dC5kYXRhKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd3aWxsLWNoYW5nZScsIHRoaXMsIGV2dCk7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2luZycsIHRoaXMsIGV2dCk7XG4gICAgfSxcbiAgICBvbkRvdWJsZUNsaWNrOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZW1vdmUnLCB0aGlzLCBldnQpO1xuICAgIH0sXG4gICAgb25Qb2ludGVyVXA6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB0aGlzLCBldnQpO1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVEb2N1bWVudEV2ZW50cygpO1xuICAgICAgICB0aGlzLm9wdGlvbnMucGFwZXIuZGVsZWdhdGVFdmVudHMoKTtcbiAgICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IFZlcnRpY2VzID0gVG9vbFZpZXcuZXh0ZW5kKHtcbiAgICBuYW1lOiAndmVydGljZXMnLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaGFuZGxlQ2xhc3M6IFZlcnRleEhhbmRsZSxcbiAgICAgICAgc25hcFJhZGl1czogMjAsXG4gICAgICAgIHJlZHVuZGFuY3lSZW1vdmFsOiB0cnVlLFxuICAgICAgICB2ZXJ0ZXhBZGRpbmc6IHRydWUsXG4gICAgICAgIC8vIHZlcnRleFJlbW92aW5nOiB0cnVlLFxuICAgICAgICAvLyB2ZXJ0ZXhNb3Zpbmc6IHRydWUsXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogdHJ1ZSxcbiAgICAgICAgc2NhbGU6IG51bGxcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbe1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnY29ubmVjdGlvbicsXG4gICAgICAgIGNsYXNzTmFtZTogJ2pvaW50LXZlcnRpY2VzLXBhdGgnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCc6IDEwLFxuICAgICAgICAgICAgJ2N1cnNvcic6ICdjZWxsJ1xuICAgICAgICB9XG4gICAgfV0sXG4gICAgaGFuZGxlczogbnVsbCxcbiAgICBpbnRlcmFjdGl2ZUxpbmtOb2RlOiBudWxsLFxuICAgIGV2ZW50czoge1xuICAgICAgICAnbW91c2Vkb3duIC5qb2ludC12ZXJ0aWNlcy1wYXRoJzogJ29uUGF0aFBvaW50ZXJEb3duJyxcbiAgICAgICAgJ3RvdWNoc3RhcnQgLmpvaW50LXZlcnRpY2VzLXBhdGgnOiAnb25QYXRoUG9pbnRlckRvd24nXG4gICAgfSxcbiAgICBsaW5rRXZlbnRzOiB7XG4gICAgICAgIG1vdXNlZG93bjogJ29uTGlua1BvaW50ZXJEb3duJyxcbiAgICAgICAgdG91Y2hzdGFydDogJ29uTGlua1BvaW50ZXJEb3duJ1xuICAgIH0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHZlcnRleEFkZGluZyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAodmVydGV4QWRkaW5nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGludGVyYWN0aXZlTGlua05vZGUgPSBudWxsIH0gPSB2ZXJ0ZXhBZGRpbmc7XG4gICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmVMaW5rTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGVMaW5rRXZlbnRzKGludGVyYWN0aXZlTGlua05vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEhhbmRsZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJIYW5kbGVzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVsZWdhdGVMaW5rRXZlbnRzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVMaW5rRXZlbnRzKCk7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5yZWxhdGVkVmlldy5maW5kTm9kZShzZWxlY3Rvcik7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW50ZXJhY3RpdmUgbGluayBub2RlIFwiJHtzZWxlY3Rvcn1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnam9pbnQtdmVydGljZXMtcGF0aCcpO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlTGlua05vZGUgPSBlbDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUVsZW1lbnRFdmVudHMoZWwsIHRoaXMubGlua0V2ZW50cyk7XG4gICAgfSxcbiAgICB1bmRlbGVnYXRlTGlua0V2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5pbnRlcmFjdGl2ZUxpbmtOb2RlO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZUVsZW1lbnRFdmVudHMoZWwpO1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdqb2ludC12ZXJ0aWNlcy1wYXRoJyk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVMaW5rTm9kZSA9IG51bGw7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVsYXRlZFZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdmVydGljZXMgPSByZWxhdGVkVmlldy5tb2RlbC52ZXJ0aWNlcygpO1xuICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoID09PSB0aGlzLmhhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRIYW5kbGVzKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckhhbmRsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRleEFkZGluZykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZXNldEhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGFuZGxlcyA9IHRoaXMuaGFuZGxlcztcbiAgICAgICAgdGhpcy5oYW5kbGVzID0gW107XG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGFuZGxlcykpIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoYW5kbGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaGFuZGxlc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVySGFuZGxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHJlbGF0ZWRWaWV3Lm1vZGVsLnZlcnRpY2VzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gbmV3ICh0aGlzLm9wdGlvbnMuaGFuZGxlQ2xhc3MpKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICBwYXBlcjogdGhpcy5wYXBlcixcbiAgICAgICAgICAgICAgICBzY2FsZTogdGhpcy5vcHRpb25zLnNjYWxlLFxuICAgICAgICAgICAgICAgIGd1YXJkOiBldnQgPT4gdGhpcy5ndWFyZChldnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZS5yZW5kZXIoKTtcbiAgICAgICAgICAgIGhhbmRsZS5wb3NpdGlvbih2ZXJ0ZXgueCwgdmVydGV4LnkpO1xuICAgICAgICAgICAgdGhpcy5zaW11bGF0ZVJlbGF0ZWRWaWV3KGhhbmRsZS5lbCk7XG4gICAgICAgICAgICBoYW5kbGUudmVsLmFwcGVuZFRvKHRoaXMuZWwpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVzLnB1c2goaGFuZGxlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIYW5kbGVMaXN0ZW5pbmcoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlSGFuZGxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWxhdGVkVmlldyA9IHRoaXMucmVsYXRlZFZpZXc7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHJlbGF0ZWRWaWV3Lm1vZGVsLnZlcnRpY2VzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gdGhpcy5oYW5kbGVzW2ldO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZS5wb3NpdGlvbih2ZXJ0ZXgueCwgdmVydGV4LnkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RpdmVMaW5rTm9kZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5jaGlsZE5vZGVzLmNvbm5lY3Rpb247XG4gICAgICAgIGlmIChjb25uZWN0aW9uKSBjb25uZWN0aW9uLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMucmVsYXRlZFZpZXcuZ2V0U2VyaWFsaXplZENvbm5lY3Rpb24oKSk7XG4gICAgfSxcbiAgICBzdGFydEhhbmRsZUxpc3RlbmluZzogZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgIGNvbnN0IHsgdmVydGV4UmVtb3ZpbmcgPSB0cnVlLCB2ZXJ0ZXhNb3ZpbmcgPSB0cnVlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICh2ZXJ0ZXhNb3ZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oaGFuZGxlLCAnd2lsbC1jaGFuZ2UnLCB0aGlzLm9uSGFuZGxlV2lsbENoYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGhhbmRsZSwgJ2NoYW5naW5nJywgdGhpcy5vbkhhbmRsZUNoYW5naW5nKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oaGFuZGxlLCAnY2hhbmdlZCcsIHRoaXMub25IYW5kbGVDaGFuZ2VkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGV4UmVtb3ZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oaGFuZGxlLCAncmVtb3ZlJywgdGhpcy5vbkhhbmRsZVJlbW92ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldE5laWdoYm9yUG9pbnRzOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB2YXIgbGlua1ZpZXcgPSB0aGlzLnJlbGF0ZWRWaWV3O1xuICAgICAgICB2YXIgdmVydGljZXMgPSBsaW5rVmlldy5tb2RlbC52ZXJ0aWNlcygpO1xuICAgICAgICB2YXIgcHJldiA9IChpbmRleCA+IDApID8gdmVydGljZXNbaW5kZXggLSAxXSA6IGxpbmtWaWV3LnNvdXJjZUFuY2hvcjtcbiAgICAgICAgdmFyIG5leHQgPSAoaW5kZXggPCB2ZXJ0aWNlcy5sZW5ndGggLSAxKSA/IHZlcnRpY2VzW2luZGV4ICsgMV0gOiBsaW5rVmlldy50YXJnZXRBbmNob3I7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmV2OiBuZXcgZy5Qb2ludChwcmV2KSxcbiAgICAgICAgICAgIG5leHQ6IG5ldyBnLlBvaW50KG5leHQpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvbkhhbmRsZVdpbGxDaGFuZ2U6IGZ1bmN0aW9uKF9oYW5kbGUsIGV2dCkge1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIGNvbnN0IHsgcmVsYXRlZFZpZXcsIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgIHJlbGF0ZWRWaWV3Lm1vZGVsLnN0YXJ0QmF0Y2goJ3ZlcnRleC1tb3ZlJywgeyB1aTogdHJ1ZSwgdG9vbDogdGhpcy5jaWQgfSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24pIHJlbGF0ZWRWaWV3Lm5vdGlmeVBvaW50ZXJkb3duKC4uLnJlbGF0ZWRWaWV3LnBhcGVyLmdldFBvaW50ZXJBcmdzKGV2dCkpO1xuICAgIH0sXG4gICAgb25IYW5kbGVDaGFuZ2luZzogZnVuY3Rpb24oaGFuZGxlLCBldnQpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zLCByZWxhdGVkVmlldzogbGlua1ZpZXcgfSA9IHRoaXM7XG4gICAgICAgIHZhciBpbmRleCA9IGhhbmRsZS5vcHRpb25zLmluZGV4O1xuICAgICAgICB2YXIgW25vcm1hbGl6ZWRFdmVudCwgeCwgeV0gPSBsaW5rVmlldy5wYXBlci5nZXRQb2ludGVyQXJncyhldnQpO1xuICAgICAgICB2YXIgdmVydGV4ID0geyB4LCB5IH07XG4gICAgICAgIHRoaXMuc25hcFZlcnRleCh2ZXJ0ZXgsIGluZGV4KTtcbiAgICAgICAgbGlua1ZpZXcubW9kZWwudmVydGV4KGluZGV4LCB2ZXJ0ZXgsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICBoYW5kbGUucG9zaXRpb24odmVydGV4LngsIHZlcnRleC55KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0b3BQcm9wYWdhdGlvbikgbGlua1ZpZXcubm90aWZ5UG9pbnRlcm1vdmUobm9ybWFsaXplZEV2ZW50LCB4LCB5KTtcbiAgICB9LFxuICAgIG9uSGFuZGxlQ2hhbmdlZDogZnVuY3Rpb24oX2hhbmRsZSwgZXZ0KSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcmVsYXRlZFZpZXc6IGxpbmtWaWV3IH0gPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0ZXhBZGRpbmcpIHRoaXMudXBkYXRlUGF0aCgpO1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVkdW5kYW5jeVJlbW92YWwpIHtcbiAgICAgICAgICAgIGxpbmtWaWV3LmNoZWNrTW91c2VsZWF2ZSh1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJ0aWNlc1JlbW92ZWQgPSBsaW5rVmlldy5yZW1vdmVSZWR1bmRhbnRMaW5lYXJWZXJ0aWNlcyh7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgaWYgKHZlcnRpY2VzUmVtb3ZlZCkgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICAgIGxpbmtWaWV3Lm1vZGVsLnN0b3BCYXRjaCgndmVydGV4LW1vdmUnLCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnREYXRhKGV2dCkudmVydGV4QWRkZWQpIHtcbiAgICAgICAgICAgIGxpbmtWaWV3Lm1vZGVsLnN0b3BCYXRjaCgndmVydGV4LWFkZCcsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBbbm9ybWFsaXplZEV2dCwgeCwgeV0gPSBsaW5rVmlldy5wYXBlci5nZXRQb2ludGVyQXJncyhldnQpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcFByb3BhZ2F0aW9uKSBsaW5rVmlldy5ub3RpZnlQb2ludGVydXAobm9ybWFsaXplZEV2dCwgeCwgeSk7XG4gICAgICAgIGxpbmtWaWV3LmNoZWNrTW91c2VsZWF2ZShub3JtYWxpemVkRXZ0KTtcbiAgICB9LFxuICAgIHNuYXBWZXJ0ZXg6IGZ1bmN0aW9uKHZlcnRleCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHNuYXBSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc25hcFJhZGl1cztcbiAgICAgICAgaWYgKHNuYXBSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5nZXROZWlnaGJvclBvaW50cyhpbmRleCk7XG4gICAgICAgICAgICB2YXIgcHJldiA9IG5laWdoYm9ycy5wcmV2O1xuICAgICAgICAgICAgdmFyIG5leHQgPSBuZWlnaGJvcnMubmV4dDtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0ZXgueCAtIHByZXYueCkgPCBzbmFwUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4LnggPSBwcmV2Lng7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHZlcnRleC54IC0gbmV4dC54KSA8IHNuYXBSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXgueCA9IG5leHQueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0ZXgueSAtIHByZXYueSkgPCBzbmFwUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4LnkgPSBuZWlnaGJvcnMucHJldi55O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyh2ZXJ0ZXgueSAtIG5leHQueSkgPCBzbmFwUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4LnkgPSBuZXh0Lnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uSGFuZGxlUmVtb3ZlOiBmdW5jdGlvbihoYW5kbGUsIGV2dCkge1xuICAgICAgICB2YXIgaW5kZXggPSBoYW5kbGUub3B0aW9ucy5pbmRleDtcbiAgICAgICAgdmFyIGxpbmtWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgbGlua1ZpZXcubW9kZWwucmVtb3ZlVmVydGV4KGluZGV4LCB7IHVpOiB0cnVlIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRleEFkZGluZykgdGhpcy51cGRhdGVQYXRoKCk7XG4gICAgICAgIGxpbmtWaWV3LmNoZWNrTW91c2VsZWF2ZSh1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCkpO1xuICAgIH0sXG4gICAgb25QYXRoUG9pbnRlckRvd246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAodGhpcy5ndWFyZChldnQpKSByZXR1cm47XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBub3JtYWxpemVkRXZlbnQgPSB1dGlsLm5vcm1hbGl6ZUV2ZW50KGV2dCk7XG4gICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLnBhcGVyLnNuYXBUb0dyaWQobm9ybWFsaXplZEV2ZW50LmNsaWVudFgsIG5vcm1hbGl6ZWRFdmVudC5jbGllbnRZKS50b0pTT04oKTtcbiAgICAgICAgdmFyIHJlbGF0ZWRWaWV3ID0gdGhpcy5yZWxhdGVkVmlldztcbiAgICAgICAgcmVsYXRlZFZpZXcubW9kZWwuc3RhcnRCYXRjaCgndmVydGV4LWFkZCcsIHsgdWk6IHRydWUsIHRvb2w6IHRoaXMuY2lkIH0pO1xuICAgICAgICB2YXIgaW5kZXggPSByZWxhdGVkVmlldy5nZXRWZXJ0ZXhJbmRleCh2ZXJ0ZXgueCwgdmVydGV4LnkpO1xuICAgICAgICB0aGlzLnNuYXBWZXJ0ZXgodmVydGV4LCBpbmRleCk7XG4gICAgICAgIHJlbGF0ZWRWaWV3Lm1vZGVsLmluc2VydFZlcnRleChpbmRleCwgdmVydGV4LCB7IHVpOiB0cnVlLCB0b29sOiB0aGlzLmNpZCB9KTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgdmFyIGhhbmRsZSA9IHRoaXMuaGFuZGxlc1tpbmRleF07XG4gICAgICAgIHRoaXMuZXZlbnREYXRhKG5vcm1hbGl6ZWRFdmVudCwgeyB2ZXJ0ZXhBZGRlZDogdHJ1ZSB9KTtcbiAgICAgICAgaGFuZGxlLm9uUG9pbnRlckRvd24obm9ybWFsaXplZEV2ZW50KTtcbiAgICB9LFxuICAgIG9uTGlua1BvaW50ZXJEb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy5yZWxhdGVkVmlldy5wcmV2ZW50RGVmYXVsdEludGVyYWN0aW9uKGV2dCk7XG4gICAgICAgIHRoaXMub25QYXRoUG9pbnRlckRvd24oZXZ0KTtcbiAgICB9LFxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZXNldEhhbmRsZXMoKTtcbiAgICAgICAgdGhpcy51bmRlbGVnYXRlTGlua0V2ZW50cygpO1xuICAgIH1cbn0sIHtcbiAgICBWZXJ0ZXhIYW5kbGU6IFZlcnRleEhhbmRsZSAvLyBrZWVwIGFzIGNsYXNzIHByb3BlcnR5XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Vertices.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/linkTools/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/linkTools/index.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Boundary: function() { return /* reexport safe */ _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_6__.Boundary; },\n/* harmony export */   Button: function() { return /* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_5__.Button; },\n/* harmony export */   Connect: function() { return /* reexport safe */ _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_7__.Connect; },\n/* harmony export */   Control: function() { return /* reexport safe */ _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_9__.Control; },\n/* harmony export */   HoverConnect: function() { return /* reexport safe */ _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_8__.HoverConnect; },\n/* harmony export */   Remove: function() { return /* reexport safe */ _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_5__.Remove; },\n/* harmony export */   RotateLabel: function() { return /* reexport safe */ _RotateLabel_mjs__WEBPACK_IMPORTED_MODULE_4__.RotateLabel; },\n/* harmony export */   Segments: function() { return /* reexport safe */ _Segments_mjs__WEBPACK_IMPORTED_MODULE_1__.Segments; },\n/* harmony export */   SourceAnchor: function() { return /* reexport safe */ _Anchor_mjs__WEBPACK_IMPORTED_MODULE_3__.SourceAnchor; },\n/* harmony export */   SourceArrowhead: function() { return /* reexport safe */ _Arrowhead_mjs__WEBPACK_IMPORTED_MODULE_2__.SourceArrowhead; },\n/* harmony export */   TargetAnchor: function() { return /* reexport safe */ _Anchor_mjs__WEBPACK_IMPORTED_MODULE_3__.TargetAnchor; },\n/* harmony export */   TargetArrowhead: function() { return /* reexport safe */ _Arrowhead_mjs__WEBPACK_IMPORTED_MODULE_2__.TargetArrowhead; },\n/* harmony export */   Vertices: function() { return /* reexport safe */ _Vertices_mjs__WEBPACK_IMPORTED_MODULE_0__.Vertices; }\n/* harmony export */ });\n/* harmony import */ var _Vertices_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vertices.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Vertices.mjs\");\n/* harmony import */ var _Segments_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Segments.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Segments.mjs\");\n/* harmony import */ var _Arrowhead_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Arrowhead.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Arrowhead.mjs\");\n/* harmony import */ var _Anchor_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Anchor.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/Anchor.mjs\");\n/* harmony import */ var _RotateLabel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RotateLabel.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/linkTools/RotateLabel.mjs\");\n/* harmony import */ var _cellTools_Button_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cellTools/Button.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Button.mjs\");\n/* harmony import */ var _cellTools_Boundary_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cellTools/Boundary.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Boundary.mjs\");\n/* harmony import */ var _cellTools_Connect_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cellTools/Connect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Connect.mjs\");\n/* harmony import */ var _cellTools_HoverConnect_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../cellTools/HoverConnect.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/HoverConnect.mjs\");\n/* harmony import */ var _cellTools_Control_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cellTools/Control.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/cellTools/Control.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbGlua1Rvb2xzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNBO0FBQ0M7QUFDSDtBQUNLOztBQUVNO0FBQ0U7QUFDRDtBQUNLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9saW5rVG9vbHMvaW5kZXgubWpzP2RjOTEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9WZXJ0aWNlcy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9TZWdtZW50cy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9BcnJvd2hlYWQubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vQW5jaG9yLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL1JvdGF0ZUxhYmVsLm1qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4uL2NlbGxUb29scy9CdXR0b24ubWpzJztcbmV4cG9ydCAqIGZyb20gJy4uL2NlbGxUb29scy9Cb3VuZGFyeS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi4vY2VsbFRvb2xzL0Nvbm5lY3QubWpzJztcbmV4cG9ydCAqIGZyb20gJy4uL2NlbGxUb29scy9Ib3ZlckNvbm5lY3QubWpzJztcbmV4cG9ydCAqIGZyb20gJy4uL2NlbGxUb29scy9Db250cm9sLm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/linkTools/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Collection.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Collection.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collection: function() { return /* binding */ Collection; }\n/* harmony export */ });\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Model.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mvcUtils.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n\n\n// Collection\n// -------------------\n\n// If models tend to represent a single row of data, a Collection is\n// more analogous to a table full of data ... or a small slice or page of that\n// table, or a collection of rows that belong together for a particular reason\n// -- all of the messages in this particular folder, all of the documents\n// belonging to this particular author, and so on. Collections maintain\n// indexes of their models, both in order, and for lookup by `id`.\n\n// Create a new **Collection**, perhaps to contain a specific type of `model`.\n// If a `comparator` is specified, the Collection will maintain\n// its models in sort order, as they're added and removed.\nvar Collection = function(models, options) {\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ silent: true }, options));\n};\n\n// Default options for `Collection#set`.\nvar setOptions = { add: true, remove: true, merge: true };\nvar addOptions = { add: true, remove: false };\n\n// Splices `insert` into `array` at index `at`.\nvar splice = function(array, insert, at) {\n    at = Math.min(Math.max(at, 0), array.length);\n    var tail = Array(array.length - at);\n    var length = insert.length;\n    var i;\n    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];\n    for (i = 0; i < length; i++) array[i + at] = insert[i];\n    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];\n};\n\n// Define the Collection's inheritable methods.\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(Collection.prototype, _Events_mjs__WEBPACK_IMPORTED_MODULE_1__.Events, {\n\n    // The default model for a collection is just a **Model**.\n    // This should be overridden in most cases.\n    model: _Model_mjs__WEBPACK_IMPORTED_MODULE_2__.Model,\n\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Collection.\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n        return this.map(function(model) { return model.toJSON(options); });\n    },\n\n    // Add a model, or list of models to the set. `models` may be\n    // Models or raw JavaScript objects to be converted to Models, or any\n    // combination of the two.\n    add: function(models, options) {\n        return this.set(models, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ merge: false }, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n        options = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options);\n        var singular = !Array.isArray(models);\n        models = singular ? [models] : models.slice();\n        var removed = this._removeModels(models, options);\n        if (!options.silent && removed.length) {\n            options.changes = { added: [], merged: [], removed: removed };\n            this.trigger('update', this, options);\n        }\n        return singular ? removed[0] : removed;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n        if (models == null) return;\n\n        options = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, setOptions, options);\n\n        var singular = !Array.isArray(models);\n        models = singular ? [models] : models.slice();\n\n        var at = options.at;\n        if (at != null) at = +at;\n        if (at > this.length) at = this.length;\n        if (at < 0) at += this.length + 1;\n\n        var set = [];\n        var toAdd = [];\n        var toMerge = [];\n        var toRemove = [];\n        var modelMap = {};\n\n        var add = options.add;\n        var merge = options.merge;\n        var remove = options.remove;\n\n        var sort = false;\n        var sortable = this.comparator && at == null && options.sort !== false;\n        var sortAttr = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(this.comparator) ? this.comparator : null;\n\n        // Turn bare objects into model references, and prevent invalid models\n        // from being added.\n        var model, i;\n        for (i = 0; i < models.length; i++) {\n            model = models[i];\n\n            // If a duplicate is found, prevent it from being added and\n            // optionally merge it into the existing model.\n            var existing = this.get(model);\n            if (existing) {\n                if (merge && model !== existing) {\n                    var attrs = this._isModel(model) ? model.attributes : model;\n                    existing.set(attrs, options);\n                    toMerge.push(existing);\n                    if (sortable && !sort) sort = existing.hasChanged(sortAttr);\n                }\n                if (!modelMap[existing.cid]) {\n                    modelMap[existing.cid] = true;\n                    set.push(existing);\n                }\n                models[i] = existing;\n\n                // If this is a new, valid model, push it to the `toAdd` list.\n            } else if (add) {\n                model = models[i] = this._prepareModel(model, options);\n                if (model) {\n                    toAdd.push(model);\n                    this._addReference(model, options);\n                    modelMap[model.cid] = true;\n                    set.push(model);\n                }\n            }\n        }\n\n        // Remove stale models.\n        if (remove) {\n            for (i = 0; i < this.length; i++) {\n                model = this.models[i];\n                if (!modelMap[model.cid]) toRemove.push(model);\n            }\n            if (toRemove.length) this._removeModels(toRemove, options);\n        }\n\n        // See if sorting is needed, update `length` and splice in new models.\n        var orderChanged = false;\n        var replace = !sortable && add && remove;\n        if (set.length && replace) {\n            orderChanged = this.length !== set.length || this.models.some(function(m, index) {\n                return m !== set[index];\n            });\n            this.models.length = 0;\n            splice(this.models, set, 0);\n            this.length = this.models.length;\n        } else if (toAdd.length) {\n            if (sortable) sort = true;\n            splice(this.models, toAdd, at == null ? this.length : at);\n            this.length = this.models.length;\n        }\n\n        // Silently sort the collection if appropriate.\n        if (sort) this.sort({ silent: true });\n\n        // Unless silenced, it's time to fire all appropriate add/sort/update events.\n        if (!options.silent) {\n            for (i = 0; i < toAdd.length; i++) {\n                if (at != null) options.index = at + i;\n                model = toAdd[i];\n                model.trigger('add', model, this, options);\n            }\n            if (sort || orderChanged) this.trigger('sort', this, options);\n            if (toAdd.length || toRemove.length || toMerge.length) {\n                options.changes = {\n                    added: toAdd,\n                    removed: toRemove,\n                    merged: toMerge\n                };\n                this.trigger('update', this, options);\n            }\n        }\n\n        // Return the added (or merged) model (or models).\n        return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n        options = options ? (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(options) : {};\n        for (var i = 0; i < this.models.length; i++) {\n            this._removeReference(this.models[i], options);\n        }\n        options.previousModels = this.models;\n        this._reset();\n        models = this.add(models, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ silent: true }, options));\n        if (!options.silent) this.trigger('reset', this, options);\n        return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n        return this.add(model, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ at: this.length }, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n        var model = this.at(this.length - 1);\n        return this.remove(model, options);\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n        return this.add(model, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({ at: 0 }, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n        var model = this.at(0);\n        return this.remove(model, options);\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n        return Array.prototype.slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id, cid, model object with id or cid\n    // properties, or an attributes object that is transformed through modelId.\n    get: function(obj) {\n        if (obj == null) return void 0;\n        return this._byId[obj] ||\n        this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] ||\n        obj.cid && this._byId[obj.cid];\n    },\n\n    // Returns `true` if the model is in the collection.\n    has: function(obj) {\n        return this.get(obj) != null;\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n        if (index < 0) index += this.length;\n        return this.models[index];\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n        var comparator = this.comparator;\n        if (!comparator) throw new Error('Cannot sort a set without a comparator');\n        options || (options = {});\n\n        var length = comparator.length;\n        if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(comparator)) comparator = comparator.bind(this);\n\n        // Run sort based on type of `comparator`.\n        if (length === 1 || (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(comparator)) {\n            this.models = this.sortBy(comparator);\n        } else {\n            this.models.sort(comparator);\n        }\n        if (!options.silent) this.trigger('sort', this, options);\n        return this;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n        return new this.constructor(this.models, {\n            model: this.model,\n            comparator: this.comparator\n        });\n    },\n\n    // Define how to uniquely identify models in the collection.\n    modelId: function(attrs, idAttribute) {\n        return attrs[idAttribute || this.model.prototype.idAttribute || 'id'];\n    },\n\n    // Get an iterator of all models in this collection.\n    values: function() {\n        return new CollectionIterator(this, ITERATOR_VALUES);\n    },\n\n    // Get an iterator of all model IDs in this collection.\n    keys: function() {\n        return new CollectionIterator(this, ITERATOR_KEYS);\n    },\n\n    // Get an iterator of all [ID, model] tuples in this collection.\n    entries: function() {\n        return new CollectionIterator(this, ITERATOR_KEYSVALUES);\n    },\n\n    // Iterate over elements of the collection, and invoke fn for each element\n    each: function(fn, context) {\n        this.models.forEach(fn, context);\n    },\n\n    // Iterate over elements of collection, and return an array of all elements fn returns truthy for\n    filter: function(fn, context) {\n        return this.models.filter(fn, context);\n    },\n\n    find: function(fn, context) {\n        return this.models.find(fn, context);\n    },\n\n    findIndex: function(fn, context) {\n        return this.models.findIndex(fn, context);\n    },\n\n    // Return the first model of the collection\n    first: function() {\n        return this.models[0];\n    },\n\n    // Return true if value is in the collection\n    includes: function(value) {\n        return this.models.includes(value);\n    },\n\n    // Return the last model of the collection\n    last: function() {\n        return this.models[this.models.length - 1];\n    },\n\n    // Return true if collection has no elements\n    isEmpty: function() {\n        return !this.models.length;\n    },\n\n    // Create an array of values by running each element in the collection through fn\n    map: function(fn, context) {\n        return this.models.map(fn, context);\n    },\n\n    // Runs \"reducer\" fn over all elements in the collection, in ascending-index order, and accumulates them into a single value\n    reduce: function(fn, initAcc = this.first()) {\n        return this.models.reduce(fn, initAcc);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n        this.length = 0;\n        this.models = [];\n        this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n        if (this._isModel(attrs)) {\n            if (!attrs.collection) attrs.collection = this;\n            return attrs;\n        }\n        options = options ? (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(options) : {};\n        options.collection = this;\n\n        var model;\n        if (this.model.prototype) {\n            model = new this.model(attrs, options);\n        } else {\n        // ES class methods didn't have prototype\n            model = this.model(attrs, options);\n        }\n\n        if (!model.validationError) return model;\n        this.trigger('invalid', this, model.validationError, options);\n        return false;\n    },\n\n    // Internal method called by both remove and set.\n    _removeModels: function(models, options) {\n        var removed = [];\n        for (var i = 0; i < models.length; i++) {\n            var model = this.get(models[i]);\n            if (!model) continue;\n\n            var index = this.models.indexOf(model);\n            this.models.splice(index, 1);\n            this.length--;\n\n            // Remove references before triggering 'remove' event to prevent an\n            // infinite loop. #3693\n            delete this._byId[model.cid];\n            var id = this.modelId(model.attributes, model.idAttribute);\n            if (id != null) delete this._byId[id];\n\n            if (!options.silent) {\n                options.index = index;\n                model.trigger('remove', model, this, options);\n            }\n\n            removed.push(model);\n            this._removeReference(model, options);\n        }\n        if (models.length > 0 && !options.silent) delete options.index;\n        return removed;\n    },\n\n    // Method for checking whether an object should be considered a model for\n    // the purposes of adding to the collection.\n    _isModel: function(model) {\n        return model instanceof _Model_mjs__WEBPACK_IMPORTED_MODULE_2__.Model;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n        this._byId[model.cid] = model;\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) this._byId[id] = model;\n        model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n        delete this._byId[model.cid];\n        var id = this.modelId(model.attributes, model.idAttribute);\n        if (id != null) delete this._byId[id];\n        if (this === model.collection) delete model.collection;\n        model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n        if (model) {\n            if ((event === 'add' || event === 'remove') && collection !== this) return;\n            if (event === 'changeId') {\n                var prevId = this.modelId(model.previousAttributes(), model.idAttribute);\n                var id = this.modelId(model.attributes, model.idAttribute);\n                if (prevId != null) delete this._byId[prevId];\n                if (id != null) this._byId[id] = model;\n            }\n        }\n        this.trigger.apply(this, arguments);\n    }\n\n});\n\n// Defining an @@iterator method implements JavaScript's Iterable protocol.\n// In modern ES2015 browsers, this value is found at Symbol.iterator.\nvar $$iterator = typeof Symbol === 'function' && Symbol.iterator;\nif ($$iterator) {\n    Collection.prototype[$$iterator] = Collection.prototype.values;\n}\n\n// CollectionIterator\n// ------------------\n\n// A CollectionIterator implements JavaScript's Iterator protocol, allowing the\n// use of `for of` loops in modern browsers and interoperation between\n// Collection and other JavaScript functions and third-party libraries\n// which can operate on Iterables.\nvar CollectionIterator = function(collection, kind) {\n    this._collection = collection;\n    this._kind = kind;\n    this._index = 0;\n};\n\n// This \"enum\" defines the three possible kinds of values which can be emitted\n// by a CollectionIterator that correspond to the values(), keys() and entries()\n// methods on Collection, respectively.\nvar ITERATOR_VALUES = 1;\nvar ITERATOR_KEYS = 2;\nvar ITERATOR_KEYSVALUES = 3;\n\n// All Iterators should themselves be Iterable.\nif ($$iterator) {\n    CollectionIterator.prototype[$$iterator] = function() {\n        return this;\n    };\n}\n\nCollectionIterator.prototype.next = function() {\n    if (this._collection) {\n\n        // Only continue iterating if the iterated collection is long enough.\n        if (this._index < this._collection.length) {\n            var model = this._collection.at(this._index);\n            this._index++;\n\n            // Construct a value depending on what kind of values should be iterated.\n            var value;\n            if (this._kind === ITERATOR_VALUES) {\n                value = model;\n            } else {\n                var id = this._collection.modelId(model.attributes, model.idAttribute);\n                if (this._kind === ITERATOR_KEYS) {\n                    value = id;\n                } else { // ITERATOR_KEYSVALUES\n                    value = [id, model];\n                }\n            }\n            return { value: value, done: false };\n        }\n\n        // Once exhausted, remove the reference to the collection so future\n        // calls to the next method always return done.\n        this._collection = void 0;\n    }\n\n    return { value: void 0, done: true };\n};\n\n//  Methods that we want to implement on the Collection.\nvar collectionMethods = { toArray: 1, sortBy: 3 };\n\n\n// Mix in each method as a proxy to `Collection#models`.\n\nvar config = [ Collection, collectionMethods, 'models' ];\n\nfunction addMethods(config) {\n    var Base = config[0],\n        methods = config[1],\n        attribute = config[2];\n\n    const methodsToAdd = {\n        sortBy: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.sortBy,\n        toArray: _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray\n    };\n\n    (0,_mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__.addMethodsUtil)(Base, methodsToAdd, methods, attribute);\n}\n\naddMethods(config);\n\n// Set up inheritance for the collection.\nCollection.extend = _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__.extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0NvbGxlY3Rpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNDO0FBQ0Y7QUFDb0I7QUFROUI7OztBQUcxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFNLEdBQUcsY0FBYztBQUMxRDs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLGlCQUFpQjtBQUNqQzs7QUFFQTtBQUNBLHNEQUFNLHVCQUF1QiwrQ0FBTTs7QUFFbkM7QUFDQTtBQUNBLFdBQVcsNkNBQUs7OztBQUdoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrQkFBK0I7QUFDekUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBTSxHQUFHLGNBQWM7QUFDdkQsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFNLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNEQUFNLEdBQUc7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qix3REFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixjQUFjOztBQUU1QztBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQUs7QUFDakMsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzREFBTSxHQUFHLGNBQWM7QUFDekQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLCtCQUErQixzREFBTSxHQUFHLGlCQUFpQjtBQUN6RCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsK0JBQStCLHNEQUFNLEdBQUcsT0FBTztBQUMvQyxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsWUFBWSwwREFBVTs7QUFFdEI7QUFDQSw0QkFBNEIsd0RBQVE7QUFDcEM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFEQUFLO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZDQUFLO0FBQ3JDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSwwQkFBMEI7OztBQUcxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxlQUFlO0FBQ2Y7O0FBRUEsSUFBSSw2REFBYztBQUNsQjs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixpREFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Db2xsZWN0aW9uLm1qcz9kMmQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4vRXZlbnRzLm1qcyc7XG5pbXBvcnQgeyBNb2RlbCB9IGZyb20gJy4vTW9kZWwubWpzJztcbmltcG9ydCB7IGV4dGVuZCwgYWRkTWV0aG9kc1V0aWwgfSBmcm9tICcuL212Y1V0aWxzLm1qcyc7XG5pbXBvcnQge1xuICAgIGFzc2lnbixcbiAgICBjbG9uZSxcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzU3RyaW5nLFxuICAgIHNvcnRCeSxcbiAgICB0b0FycmF5XG59IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuXG5cbi8vIENvbGxlY3Rpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIENvbGxlY3Rpb24gaXNcbi8vIG1vcmUgYW5hbG9nb3VzIHRvIGEgdGFibGUgZnVsbCBvZiBkYXRhIC4uLiBvciBhIHNtYWxsIHNsaWNlIG9yIHBhZ2Ugb2YgdGhhdFxuLy8gdGFibGUsIG9yIGEgY29sbGVjdGlvbiBvZiByb3dzIHRoYXQgYmVsb25nIHRvZ2V0aGVyIGZvciBhIHBhcnRpY3VsYXIgcmVhc29uXG4vLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXG4vLyBiZWxvbmdpbmcgdG8gdGhpcyBwYXJ0aWN1bGFyIGF1dGhvciwgYW5kIHNvIG9uLiBDb2xsZWN0aW9ucyBtYWludGFpblxuLy8gaW5kZXhlcyBvZiB0aGVpciBtb2RlbHMsIGJvdGggaW4gb3JkZXIsIGFuZCBmb3IgbG9va3VwIGJ5IGBpZGAuXG5cbi8vIENyZWF0ZSBhIG5ldyAqKkNvbGxlY3Rpb24qKiwgcGVyaGFwcyB0byBjb250YWluIGEgc3BlY2lmaWMgdHlwZSBvZiBgbW9kZWxgLlxuLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXG4vLyBpdHMgbW9kZWxzIGluIHNvcnQgb3JkZXIsIGFzIHRoZXkncmUgYWRkZWQgYW5kIHJlbW92ZWQuXG5leHBvcnQgdmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yICE9PSB2b2lkIDApIHRoaXMuY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHRoaXMucmVzZXQobW9kZWxzLCBhc3NpZ24oeyBzaWxlbnQ6IHRydWUgfSwgb3B0aW9ucykpO1xufTtcblxuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBgQ29sbGVjdGlvbiNzZXRgLlxudmFyIHNldE9wdGlvbnMgPSB7IGFkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZSB9O1xudmFyIGFkZE9wdGlvbnMgPSB7IGFkZDogdHJ1ZSwgcmVtb3ZlOiBmYWxzZSB9O1xuXG4vLyBTcGxpY2VzIGBpbnNlcnRgIGludG8gYGFycmF5YCBhdCBpbmRleCBgYXRgLlxudmFyIHNwbGljZSA9IGZ1bmN0aW9uKGFycmF5LCBpbnNlcnQsIGF0KSB7XG4gICAgYXQgPSBNYXRoLm1pbihNYXRoLm1heChhdCwgMCksIGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIHRhaWwgPSBBcnJheShhcnJheS5sZW5ndGggLSBhdCk7XG4gICAgdmFyIGxlbmd0aCA9IGluc2VydC5sZW5ndGg7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRhaWwubGVuZ3RoOyBpKyspIHRhaWxbaV0gPSBhcnJheVtpICsgYXRdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJyYXlbaSArIGF0XSA9IGluc2VydFtpXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykgYXJyYXlbaSArIGxlbmd0aCArIGF0XSA9IHRhaWxbaV07XG59O1xuXG4vLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuYXNzaWduKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIC8vIFRoZSBkZWZhdWx0IG1vZGVsIGZvciBhIGNvbGxlY3Rpb24gaXMganVzdCBhICoqTW9kZWwqKi5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIG1vc3QgY2FzZXMuXG4gICAgbW9kZWw6IE1vZGVsLFxuXG5cbiAgICAvLyBwcmVpbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIFlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCBhIGZ1bmN0aW9uXG4gICAgLy8gb3Igb2JqZWN0LiAgcHJlaW5pdGlhbGl6ZSB3aWxsIHJ1biBiZWZvcmUgYW55IGluc3RhbnRpYXRpb24gbG9naWMgaXMgcnVuIGluIHRoZSBDb2xsZWN0aW9uLlxuICAgIHByZWluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIE5vIGltcGxlbWVudGF0aW9uLlxuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBObyBpbXBsZW1lbnRhdGlvbi5cbiAgICB9LFxuXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxuICAgIC8vIG1vZGVscycgYXR0cmlidXRlcy5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG1vZGVsKSB7IHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7IH0pO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC4gYG1vZGVsc2AgbWF5IGJlXG4gICAgLy8gTW9kZWxzIG9yIHJhdyBKYXZhU2NyaXB0IG9iamVjdHMgdG8gYmUgY29udmVydGVkIHRvIE1vZGVscywgb3IgYW55XG4gICAgLy8gY29tYmluYXRpb24gb2YgdGhlIHR3by5cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQobW9kZWxzLCBhc3NpZ24oeyBtZXJnZTogZmFsc2UgfSwgb3B0aW9ucywgYWRkT3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCwgb3IgYSBsaXN0IG9mIG1vZGVscyBmcm9tIHRoZSBzZXQuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzaW5ndWxhciA9ICFBcnJheS5pc0FycmF5KG1vZGVscyk7XG4gICAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBtb2RlbHMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVNb2RlbHMobW9kZWxzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiByZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgb3B0aW9ucy5jaGFuZ2VzID0geyBhZGRlZDogW10sIG1lcmdlZDogW10sIHJlbW92ZWQ6IHJlbW92ZWQgfTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbmd1bGFyID8gcmVtb3ZlZFswXSA6IHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8vIFVwZGF0ZSBhIGNvbGxlY3Rpb24gYnkgYHNldGAtaW5nIGEgbmV3IGxpc3Qgb2YgbW9kZWxzLCBhZGRpbmcgbmV3IG9uZXMsXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxuICAgIC8vIGFscmVhZHkgZXhpc3QgaW4gdGhlIGNvbGxlY3Rpb24sIGFzIG5lY2Vzc2FyeS4gU2ltaWxhciB0byAqKk1vZGVsI3NldCoqLFxuICAgIC8vIHRoZSBjb3JlIG9wZXJhdGlvbiBmb3IgdXBkYXRpbmcgdGhlIGRhdGEgY29udGFpbmVkIGJ5IHRoZSBjb2xsZWN0aW9uLlxuICAgIHNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChtb2RlbHMgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICAgIG9wdGlvbnMgPSBhc3NpZ24oe30sIHNldE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciBzaW5ndWxhciA9ICFBcnJheS5pc0FycmF5KG1vZGVscyk7XG4gICAgICAgIG1vZGVscyA9IHNpbmd1bGFyID8gW21vZGVsc10gOiBtb2RlbHMuc2xpY2UoKTtcblxuICAgICAgICB2YXIgYXQgPSBvcHRpb25zLmF0O1xuICAgICAgICBpZiAoYXQgIT0gbnVsbCkgYXQgPSArYXQ7XG4gICAgICAgIGlmIChhdCA+IHRoaXMubGVuZ3RoKSBhdCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoYXQgPCAwKSBhdCArPSB0aGlzLmxlbmd0aCArIDE7XG5cbiAgICAgICAgdmFyIHNldCA9IFtdO1xuICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgdmFyIHRvTWVyZ2UgPSBbXTtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICAgIHZhciBtb2RlbE1hcCA9IHt9O1xuXG4gICAgICAgIHZhciBhZGQgPSBvcHRpb25zLmFkZDtcbiAgICAgICAgdmFyIG1lcmdlID0gb3B0aW9ucy5tZXJnZTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IG9wdGlvbnMucmVtb3ZlO1xuXG4gICAgICAgIHZhciBzb3J0ID0gZmFsc2U7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IHRoaXMuY29tcGFyYXRvciAmJiBhdCA9PSBudWxsICYmIG9wdGlvbnMuc29ydCAhPT0gZmFsc2U7XG4gICAgICAgIHZhciBzb3J0QXR0ciA9IGlzU3RyaW5nKHRoaXMuY29tcGFyYXRvcikgPyB0aGlzLmNvbXBhcmF0b3IgOiBudWxsO1xuXG4gICAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcbiAgICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cbiAgICAgICAgdmFyIG1vZGVsLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXTtcblxuICAgICAgICAgICAgLy8gSWYgYSBkdXBsaWNhdGUgaXMgZm91bmQsIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhZGRlZCBhbmRcbiAgICAgICAgICAgIC8vIG9wdGlvbmFsbHkgbWVyZ2UgaXQgaW50byB0aGUgZXhpc3RpbmcgbW9kZWwuXG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLmdldChtb2RlbCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2UgJiYgbW9kZWwgIT09IGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRycyA9IHRoaXMuX2lzTW9kZWwobW9kZWwpID8gbW9kZWwuYXR0cmlidXRlcyA6IG1vZGVsO1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5zZXQoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0b01lcmdlLnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgIXNvcnQpIHNvcnQgPSBleGlzdGluZy5oYXNDaGFuZ2VkKHNvcnRBdHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtb2RlbE1hcFtleGlzdGluZy5jaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChleGlzdGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGVsc1tpXSA9IGV4aXN0aW5nO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldywgdmFsaWQgbW9kZWwsIHB1c2ggaXQgdG8gdGhlIGB0b0FkZGAgbGlzdC5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUmVmZXJlbmNlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxNYXBbbW9kZWwuY2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgc3RhbGUgbW9kZWxzLlxuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vZGVsID0gdGhpcy5tb2RlbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFtb2RlbE1hcFttb2RlbC5jaWRdKSB0b1JlbW92ZS5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b1JlbW92ZS5sZW5ndGgpIHRoaXMuX3JlbW92ZU1vZGVscyh0b1JlbW92ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWUgaWYgc29ydGluZyBpcyBuZWVkZWQsIHVwZGF0ZSBgbGVuZ3RoYCBhbmQgc3BsaWNlIGluIG5ldyBtb2RlbHMuXG4gICAgICAgIHZhciBvcmRlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSAhc29ydGFibGUgJiYgYWRkICYmIHJlbW92ZTtcbiAgICAgICAgaWYgKHNldC5sZW5ndGggJiYgcmVwbGFjZSkge1xuICAgICAgICAgICAgb3JkZXJDaGFuZ2VkID0gdGhpcy5sZW5ndGggIT09IHNldC5sZW5ndGggfHwgdGhpcy5tb2RlbHMuc29tZShmdW5jdGlvbihtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtICE9PSBzZXRbaW5kZXhdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCBzZXQsIDApO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodG9BZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUpIHNvcnQgPSB0cnVlO1xuICAgICAgICAgICAgc3BsaWNlKHRoaXMubW9kZWxzLCB0b0FkZCwgYXQgPT0gbnVsbCA/IHRoaXMubGVuZ3RoIDogYXQpO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLm1vZGVscy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWxlbnRseSBzb3J0IHRoZSBjb2xsZWN0aW9uIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICBpZiAoc29ydCkgdGhpcy5zb3J0KHsgc2lsZW50OiB0cnVlIH0pO1xuXG4gICAgICAgIC8vIFVubGVzcyBzaWxlbmNlZCwgaXQncyB0aW1lIHRvIGZpcmUgYWxsIGFwcHJvcHJpYXRlIGFkZC9zb3J0L3VwZGF0ZSBldmVudHMuXG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhdCAhPSBudWxsKSBvcHRpb25zLmluZGV4ID0gYXQgKyBpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gdG9BZGRbaV07XG4gICAgICAgICAgICAgICAgbW9kZWwudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvcnQgfHwgb3JkZXJDaGFuZ2VkKSB0aGlzLnRyaWdnZXIoJ3NvcnQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICh0b0FkZC5sZW5ndGggfHwgdG9SZW1vdmUubGVuZ3RoIHx8IHRvTWVyZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jaGFuZ2VzID0ge1xuICAgICAgICAgICAgICAgICAgICBhZGRlZDogdG9BZGQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IHRvUmVtb3ZlLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZWQ6IHRvTWVyZ2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigndXBkYXRlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIGFkZGVkIChvciBtZXJnZWQpIG1vZGVsIChvciBtb2RlbHMpLlxuICAgICAgICByZXR1cm4gc2luZ3VsYXIgPyBtb2RlbHNbMF0gOiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8vIFdoZW4geW91IGhhdmUgbW9yZSBpdGVtcyB0aGFuIHlvdSB3YW50IHRvIGFkZCBvciByZW1vdmUgaW5kaXZpZHVhbGx5LFxuICAgIC8vIHlvdSBjYW4gcmVzZXQgdGhlIGVudGlyZSBzZXQgd2l0aCBhIG5ldyBsaXN0IG9mIG1vZGVscywgd2l0aG91dCBmaXJpbmdcbiAgICAvLyBhbnkgZ3JhbnVsYXIgYGFkZGAgb3IgYHJlbW92ZWAgZXZlbnRzLiBGaXJlcyBgcmVzZXRgIHdoZW4gZmluaXNoZWQuXG4gICAgLy8gVXNlZnVsIGZvciBidWxrIG9wZXJhdGlvbnMgYW5kIG9wdGltaXphdGlvbnMuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyA/IGNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZSh0aGlzLm1vZGVsc1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5wcmV2aW91c01vZGVscyA9IHRoaXMubW9kZWxzO1xuICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICBtb2RlbHMgPSB0aGlzLmFkZChtb2RlbHMsIGFzc2lnbih7IHNpbGVudDogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1vZGVscztcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgbW9kZWwgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwdXNoOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIGFzc2lnbih7IGF0OiB0aGlzLmxlbmd0aCB9LCBvcHRpb25zKSk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICBwb3A6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChtb2RlbCwgYXNzaWduKHsgYXQ6IDAgfSwgb3B0aW9ucykpO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYSBtb2RlbCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdCgwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gU2xpY2Ugb3V0IGEgc3ViLWFycmF5IG9mIG1vZGVscyBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgIHNsaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLm1vZGVscywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGEgbW9kZWwgZnJvbSB0aGUgc2V0IGJ5IGlkLCBjaWQsIG1vZGVsIG9iamVjdCB3aXRoIGlkIG9yIGNpZFxuICAgIC8vIHByb3BlcnRpZXMsIG9yIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRoYXQgaXMgdHJhbnNmb3JtZWQgdGhyb3VnaCBtb2RlbElkLlxuICAgIGdldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWRbb2JqXSB8fFxuICAgICAgICB0aGlzLl9ieUlkW3RoaXMubW9kZWxJZCh0aGlzLl9pc01vZGVsKG9iaikgPyBvYmouYXR0cmlidXRlcyA6IG9iaiwgb2JqLmlkQXR0cmlidXRlKV0gfHxcbiAgICAgICAgb2JqLmNpZCAmJiB0aGlzLl9ieUlkW29iai5jaWRdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgbW9kZWwgaXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgaGFzOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG9iaikgIT0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBtb2RlbCBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIGluZGV4ICs9IHRoaXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXG4gICAgLy8gbm9ybWFsIGNpcmN1bXN0YW5jZXMsIGFzIHRoZSBzZXQgd2lsbCBtYWludGFpbiBzb3J0IG9yZGVyIGFzIGVhY2ggaXRlbVxuICAgIC8vIGlzIGFkZGVkLlxuICAgIHNvcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLmNvbXBhcmF0b3I7XG4gICAgICAgIGlmICghY29tcGFyYXRvcikgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc29ydCBhIHNldCB3aXRob3V0IGEgY29tcGFyYXRvcicpO1xuICAgICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBjb21wYXJhdG9yLmxlbmd0aDtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29tcGFyYXRvcikpIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gUnVuIHNvcnQgYmFzZWQgb24gdHlwZSBvZiBgY29tcGFyYXRvcmAuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDEgfHwgaXNTdHJpbmcoY29tcGFyYXRvcikpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzID0gdGhpcy5zb3J0QnkoY29tcGFyYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVscy5zb3J0KGNvbXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNvbGxlY3Rpb24gd2l0aCBhbiBpZGVudGljYWwgbGlzdCBvZiBtb2RlbHMgYXMgdGhpcyBvbmUuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5tb2RlbHMsIHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICAgICAgY29tcGFyYXRvcjogdGhpcy5jb21wYXJhdG9yXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEZWZpbmUgaG93IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IG1vZGVscyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICBtb2RlbElkOiBmdW5jdGlvbihhdHRycywgaWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzW2lkQXR0cmlidXRlIHx8IHRoaXMubW9kZWwucHJvdG90eXBlLmlkQXR0cmlidXRlIHx8ICdpZCddO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW4gaXRlcmF0b3Igb2YgYWxsIG1vZGVscyBpbiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uSXRlcmF0b3IodGhpcywgSVRFUkFUT1JfVkFMVUVTKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG9mIGFsbCBtb2RlbCBJRHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JdGVyYXRvcih0aGlzLCBJVEVSQVRPUl9LRVlTKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuIGl0ZXJhdG9yIG9mIGFsbCBbSUQsIG1vZGVsXSB0dXBsZXMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb25JdGVyYXRvcih0aGlzLCBJVEVSQVRPUl9LRVlTVkFMVUVTKTtcbiAgICB9LFxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVsZW1lbnRzIG9mIHRoZSBjb2xsZWN0aW9uLCBhbmQgaW52b2tlIGZuIGZvciBlYWNoIGVsZW1lbnRcbiAgICBlYWNoOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1vZGVscy5mb3JFYWNoKGZuLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVsZW1lbnRzIG9mIGNvbGxlY3Rpb24sIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzIGZuIHJldHVybnMgdHJ1dGh5IGZvclxuICAgIGZpbHRlcjogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzLmZpbHRlcihmbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVscy5maW5kKGZuLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHMuZmluZEluZGV4KGZuLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJuIHRoZSBmaXJzdCBtb2RlbCBvZiB0aGUgY29sbGVjdGlvblxuICAgIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzWzBdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB2YWx1ZSBpcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHMuaW5jbHVkZXModmFsdWUpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIGxhc3QgbW9kZWwgb2YgdGhlIGNvbGxlY3Rpb25cbiAgICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW3RoaXMubW9kZWxzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBjb2xsZWN0aW9uIGhhcyBubyBlbGVtZW50c1xuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMubW9kZWxzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvbiB0aHJvdWdoIGZuXG4gICAgbWFwOiBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHMubWFwKGZuLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLy8gUnVucyBcInJlZHVjZXJcIiBmbiBvdmVyIGFsbCBlbGVtZW50cyBpbiB0aGUgY29sbGVjdGlvbiwgaW4gYXNjZW5kaW5nLWluZGV4IG9yZGVyLCBhbmQgYWNjdW11bGF0ZXMgdGhlbSBpbnRvIGEgc2luZ2xlIHZhbHVlXG4gICAgcmVkdWNlOiBmdW5jdGlvbihmbiwgaW5pdEFjYyA9IHRoaXMuZmlyc3QoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbHMucmVkdWNlKGZuLCBpbml0QWNjKTtcbiAgICB9LFxuXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGlzIGZpcnN0IGluaXRpYWxpemVkIG9yIHJlc2V0LlxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICB9LFxuXG4gICAgLy8gUHJlcGFyZSBhIGhhc2ggb2YgYXR0cmlidXRlcyAob3Igb3RoZXIgbW9kZWwpIHRvIGJlIGFkZGVkIHRvIHRoaXNcbiAgICAvLyBjb2xsZWN0aW9uLlxuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc01vZGVsKGF0dHJzKSkge1xuICAgICAgICAgICAgaWYgKCFhdHRycy5jb2xsZWN0aW9uKSBhdHRycy5jb2xsZWN0aW9uID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBhdHRycztcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyA/IGNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICAgIG9wdGlvbnMuY29sbGVjdGlvbiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIG1vZGVsO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFUyBjbGFzcyBtZXRob2RzIGRpZG4ndCBoYXZlIHByb3RvdHlwZVxuICAgICAgICAgICAgbW9kZWwgPSB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW9kZWwudmFsaWRhdGlvbkVycm9yKSByZXR1cm4gbW9kZWw7XG4gICAgICAgIHRoaXMudHJpZ2dlcignaW52YWxpZCcsIHRoaXMsIG1vZGVsLnZhbGlkYXRpb25FcnJvciwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBieSBib3RoIHJlbW92ZSBhbmQgc2V0LlxuICAgIF9yZW1vdmVNb2RlbHM6IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXQobW9kZWxzW2ldKTtcbiAgICAgICAgICAgIGlmICghbW9kZWwpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1vZGVscy5pbmRleE9mKG1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlcyBiZWZvcmUgdHJpZ2dlcmluZyAncmVtb3ZlJyBldmVudCB0byBwcmV2ZW50IGFuXG4gICAgICAgICAgICAvLyBpbmZpbml0ZSBsb29wLiAjMzY5M1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMubW9kZWxJZChtb2RlbC5hdHRyaWJ1dGVzLCBtb2RlbC5pZEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbaWRdO1xuXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGVscy5sZW5ndGggPiAwICYmICFvcHRpb25zLnNpbGVudCkgZGVsZXRlIG9wdGlvbnMuaW5kZXg7XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvLyBNZXRob2QgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgbW9kZWwgZm9yXG4gICAgLy8gdGhlIHB1cnBvc2VzIG9mIGFkZGluZyB0byB0aGUgY29sbGVjdGlvbi5cbiAgICBfaXNNb2RlbDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsIGluc3RhbmNlb2YgTW9kZWw7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcywgbW9kZWwuaWRBdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXG4gICAgX3JlbW92ZVJlZmVyZW5jZTogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuY2lkXTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5tb2RlbElkKG1vZGVsLmF0dHJpYnV0ZXMsIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIGRlbGV0ZSB0aGlzLl9ieUlkW2lkXTtcbiAgICAgICAgaWYgKHRoaXMgPT09IG1vZGVsLmNvbGxlY3Rpb24pIGRlbGV0ZSBtb2RlbC5jb2xsZWN0aW9uO1xuICAgICAgICBtb2RlbC5vZmYoJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgfSxcblxuICAgIC8vIEludGVybmFsIG1ldGhvZCBjYWxsZWQgZXZlcnkgdGltZSBhIG1vZGVsIGluIHRoZSBzZXQgZmlyZXMgYW4gZXZlbnQuXG4gICAgLy8gU2V0cyBuZWVkIHRvIHVwZGF0ZSB0aGVpciBpbmRleGVzIHdoZW4gbW9kZWxzIGNoYW5nZSBpZHMuIEFsbCBvdGhlclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcbiAgICAvLyBpbiBvdGhlciBjb2xsZWN0aW9ucyBhcmUgaWdub3JlZC5cbiAgICBfb25Nb2RlbEV2ZW50OiBmdW5jdGlvbihldmVudCwgbW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ3JlbW92ZScpICYmIGNvbGxlY3Rpb24gIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2NoYW5nZUlkJykge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2SWQgPSB0aGlzLm1vZGVsSWQobW9kZWwucHJldmlvdXNBdHRyaWJ1dGVzKCksIG1vZGVsLmlkQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcywgbW9kZWwuaWRBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2SWQgIT0gbnVsbCkgZGVsZXRlIHRoaXMuX2J5SWRbcHJldklkXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFtpZF0gPSBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbn0pO1xuXG4vLyBEZWZpbmluZyBhbiBAQGl0ZXJhdG9yIG1ldGhvZCBpbXBsZW1lbnRzIEphdmFTY3JpcHQncyBJdGVyYWJsZSBwcm90b2NvbC5cbi8vIEluIG1vZGVybiBFUzIwMTUgYnJvd3NlcnMsIHRoaXMgdmFsdWUgaXMgZm91bmQgYXQgU3ltYm9sLml0ZXJhdG9yLlxudmFyICQkaXRlcmF0b3IgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbmlmICgkJGl0ZXJhdG9yKSB7XG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbJCRpdGVyYXRvcl0gPSBDb2xsZWN0aW9uLnByb3RvdHlwZS52YWx1ZXM7XG59XG5cbi8vIENvbGxlY3Rpb25JdGVyYXRvclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEEgQ29sbGVjdGlvbkl0ZXJhdG9yIGltcGxlbWVudHMgSmF2YVNjcmlwdCdzIEl0ZXJhdG9yIHByb3RvY29sLCBhbGxvd2luZyB0aGVcbi8vIHVzZSBvZiBgZm9yIG9mYCBsb29wcyBpbiBtb2Rlcm4gYnJvd3NlcnMgYW5kIGludGVyb3BlcmF0aW9uIGJldHdlZW5cbi8vIENvbGxlY3Rpb24gYW5kIG90aGVyIEphdmFTY3JpcHQgZnVuY3Rpb25zIGFuZCB0aGlyZC1wYXJ0eSBsaWJyYXJpZXNcbi8vIHdoaWNoIGNhbiBvcGVyYXRlIG9uIEl0ZXJhYmxlcy5cbnZhciBDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBraW5kKSB7XG4gICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgdGhpcy5fa2luZCA9IGtpbmQ7XG4gICAgdGhpcy5faW5kZXggPSAwO1xufTtcblxuLy8gVGhpcyBcImVudW1cIiBkZWZpbmVzIHRoZSB0aHJlZSBwb3NzaWJsZSBraW5kcyBvZiB2YWx1ZXMgd2hpY2ggY2FuIGJlIGVtaXR0ZWRcbi8vIGJ5IGEgQ29sbGVjdGlvbkl0ZXJhdG9yIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgdmFsdWVzKCksIGtleXMoKSBhbmQgZW50cmllcygpXG4vLyBtZXRob2RzIG9uIENvbGxlY3Rpb24sIHJlc3BlY3RpdmVseS5cbnZhciBJVEVSQVRPUl9WQUxVRVMgPSAxO1xudmFyIElURVJBVE9SX0tFWVMgPSAyO1xudmFyIElURVJBVE9SX0tFWVNWQUxVRVMgPSAzO1xuXG4vLyBBbGwgSXRlcmF0b3JzIHNob3VsZCB0aGVtc2VsdmVzIGJlIEl0ZXJhYmxlLlxuaWYgKCQkaXRlcmF0b3IpIHtcbiAgICBDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlWyQkaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbkNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uKSB7XG5cbiAgICAgICAgLy8gT25seSBjb250aW51ZSBpdGVyYXRpbmcgaWYgdGhlIGl0ZXJhdGVkIGNvbGxlY3Rpb24gaXMgbG9uZyBlbm91Z2guXG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMuX2NvbGxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLl9jb2xsZWN0aW9uLmF0KHRoaXMuX2luZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG5cbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBhIHZhbHVlIGRlcGVuZGluZyBvbiB3aGF0IGtpbmQgb2YgdmFsdWVzIHNob3VsZCBiZSBpdGVyYXRlZC5cbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9raW5kID09PSBJVEVSQVRPUl9WQUxVRVMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGVsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzLl9jb2xsZWN0aW9uLm1vZGVsSWQobW9kZWwuYXR0cmlidXRlcywgbW9kZWwuaWRBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9raW5kID09PSBJVEVSQVRPUl9LRVlTKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gSVRFUkFUT1JfS0VZU1ZBTFVFU1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtpZCwgbW9kZWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9uY2UgZXhoYXVzdGVkLCByZW1vdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgY29sbGVjdGlvbiBzbyBmdXR1cmVcbiAgICAgICAgLy8gY2FsbHMgdG8gdGhlIG5leHQgbWV0aG9kIGFsd2F5cyByZXR1cm4gZG9uZS5cbiAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBkb25lOiB0cnVlIH07XG59O1xuXG4vLyAgTWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxudmFyIGNvbGxlY3Rpb25NZXRob2RzID0geyB0b0FycmF5OiAxLCBzb3J0Qnk6IDMgfTtcblxuXG4vLyBNaXggaW4gZWFjaCBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuXG52YXIgY29uZmlnID0gWyBDb2xsZWN0aW9uLCBjb2xsZWN0aW9uTWV0aG9kcywgJ21vZGVscycgXTtcblxuZnVuY3Rpb24gYWRkTWV0aG9kcyhjb25maWcpIHtcbiAgICB2YXIgQmFzZSA9IGNvbmZpZ1swXSxcbiAgICAgICAgbWV0aG9kcyA9IGNvbmZpZ1sxXSxcbiAgICAgICAgYXR0cmlidXRlID0gY29uZmlnWzJdO1xuXG4gICAgY29uc3QgbWV0aG9kc1RvQWRkID0ge1xuICAgICAgICBzb3J0QnksXG4gICAgICAgIHRvQXJyYXlcbiAgICB9O1xuXG4gICAgYWRkTWV0aG9kc1V0aWwoQmFzZSwgbWV0aG9kc1RvQWRkLCBtZXRob2RzLCBhdHRyaWJ1dGUpO1xufVxuXG5hZGRNZXRob2RzKGNvbmZpZyk7XG5cbi8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIGNvbGxlY3Rpb24uXG5Db2xsZWN0aW9uLmV4dGVuZCA9IGV4dGVuZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Collection.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Data.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Data.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nclass Data {\n\n    constructor() {\n        this.map = new WeakMap();\n    }\n\n    has(obj, key) {\n        if (key === undefined) return this.map.has(obj);\n        return key in this.map.get(obj);\n    }\n\n    create(obj) {\n        if (!this.has(obj)) this.map.set(obj, Object.create(null));\n        return this.get(obj);\n    }\n\n    get(obj, key) {\n        if (!this.has(obj)) return undefined;\n        const data = this.map.get(obj);\n        if (key === undefined) return data;\n        return data[key];\n    }\n\n    set(obj, key, value) {\n        if (key === undefined) return;\n        const data = this.create(obj);\n        if (typeof key === 'string') {\n            data[key] = value;\n        } else {\n            Object.assign(data, key);\n        }\n    }\n\n    remove(obj, key) {\n        if (!this.has(obj)) return;\n        if (key === undefined) {\n            this.map.delete(obj);\n        } else {\n            const data = this.map.get(obj);\n            delete data[key];\n        }\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Data);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RhdGEubWpzIiwibWFwcGluZ3MiOiI7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQWUsSUFBSSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RhdGEubWpzPzdmODciXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRGF0YSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cblxuICAgIGhhcyhvYmosIGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLm1hcC5oYXMob2JqKTtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLm1hcC5nZXQob2JqKTtcbiAgICB9XG5cbiAgICBjcmVhdGUob2JqKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXMob2JqKSkgdGhpcy5tYXAuc2V0KG9iaiwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChvYmopO1xuICAgIH1cblxuICAgIGdldChvYmosIGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKG9iaikpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1hcC5nZXQob2JqKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZGF0YTtcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcbiAgICB9XG5cbiAgICBzZXQob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5jcmVhdGUob2JqKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZShvYmosIGtleSkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzKG9iaikpIHJldHVybjtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1hcC5nZXQob2JqKTtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGE7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Data.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/Dom.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ $; }\n/* harmony export */ });\n/* harmony import */ var _util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/utilHelpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _vars_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vars.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\");\n/* harmony import */ var _Event_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Event.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs\");\n\n/*!\n * jQuery JavaScript Library v4.0.0-pre+c98597ea.dirty\n * https://jquery.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2023-11-24T14:04Z\n */\n\n\n\n\n\nconst document = (typeof window !== 'undefined') ? window.document : null;\nconst documentElement = document && document.documentElement;\n\nconst rTypeNamespace = /^([^.]*)(?:\\.(.+)|)/;\n\n// Only count HTML whitespace\n// Other whitespace should count in values\n// https://infra.spec.whatwg.org/#ascii-whitespace\nconst rNotHtmlWhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n// Define a local copy of $\nconst $ = function(selector) {\n    // The $ object is actually just the init constructor 'enhanced'\n    // Need init if $ is called (just allow error to be thrown if not included)\n    return new $.Dom(selector);\n};\n\n$.fn = $.prototype = {\n    constructor: $,\n    // The default length of a $ object is 0\n    length: 0,\n};\n\n// A global GUID counter for objects\n$.guid = 1;\n\n// User data storage\n$.data = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataUser;\n\n$.merge = function(first, second) {\n    let len = +second.length;\n    let i = first.length;\n    for (let j = 0; j < len; j++) {\n        first[i++] = second[j];\n    }\n    first.length = i;\n    return first;\n};\n\n$.parseHTML = function(string) {\n    // Inline events will not execute when the HTML is parsed; this includes, for example, sending GET requests for images.\n    const context = document.implementation.createHTMLDocument();\n    // Set the base href for the created document so any parsed elements with URLs\n    // are based on the document's URL\n    const base = context.createElement('base');\n    base.href = document.location.href;\n    context.head.appendChild(base);\n\n    context.body.innerHTML = string;\n    // remove scripts\n    const scripts = context.getElementsByTagName('script');\n    for (let i = 0; i < scripts.length; i++) {\n        scripts[i].remove();\n    }\n    return Array.from(context.body.childNodes);\n};\n\nif (typeof Symbol === 'function') {\n    $.fn[Symbol.iterator] = Array.prototype[Symbol.iterator];\n}\n\n$.fn.toArray = function() {\n    return Array.from(this);\n};\n\n// Take an array of elements and push it onto the stack\n// (returning the new matched element set)\n$.fn.pushStack = function(elements) {\n    // Build a new $ matched element set\n    const ret = $.merge(this.constructor(), elements);\n    // Add the old object onto the stack (as a reference)\n    ret.prevObject = this;\n    // Return the newly-formed element set\n    return ret;\n};\n\n$.fn.find = function(selector) {\n    const [el] = this;\n    const ret = this.pushStack([]);\n    if (!el) return ret;\n    // Early return if context is not an element, document or document fragment\n    const { nodeType } = el;\n    if (nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return ret;\n    }\n    if (typeof selector !== 'string') {\n        if (el !== selector && el.contains(selector)) {\n            $.merge(ret, [selector]);\n        }\n    } else {\n        $.merge(ret, el.querySelectorAll(selector));\n    }\n    return ret;\n};\n\n$.fn.add = function(selector) {\n    const newElements = $(selector).toArray();\n    const prevElements = this.toArray();\n    const ret = this.pushStack([]);\n    $.merge(ret, (0,_util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq)(prevElements.concat(newElements)));\n    return ret;\n};\n\n$.fn.addBack = function() {\n    return this.add(this.prevObject);\n};\n\n$.fn.filter = function(selector) {\n    const matches = [];\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (!node.matches(selector)) continue;\n        matches.push(node);\n    }\n    return this.pushStack(matches);\n};\n\n// A simple way to check for HTML strings\n// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)\n// Strict HTML recognition (trac-11290: must start with <)\n// Shortcut simple #id case for speed\nconst rQuickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/;\n\nfunction isObviousHtml(input) {\n    return (\n        input[0] === '<' && input[input.length - 1] === '>' && input.length >= 3\n    );\n}\n\nconst Dom = function(selector) {\n    if (!selector) {\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        return this;\n    }\n    if (typeof selector === 'function') {\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        throw new Error('function not supported');\n    }\n    if (arguments.length > 1) {\n        throw new Error('selector with context not supported');\n    }\n    if (selector.nodeType) {\n        // HANDLE: $(DOMElement)\n        this[0] = selector;\n        this.length = 1;\n        return this;\n    }\n    let match;\n    if (isObviousHtml(selector + '')) {\n        // Handle obvious HTML strings\n        // Assume that strings that start and end with <> are HTML and skip\n        // the regex check. This also handles browser-supported HTML wrappers\n        // like TrustedHTML.\n        match = [null, selector, null];\n    } else if (typeof selector === 'string') {\n        // Handle HTML strings or selectors\n        match = rQuickExpr.exec(selector);\n    } else {\n        // Array-like\n        return $.merge(this, selector);\n    }\n    if (!match || !match[1]) {\n        // HANDLE: $(expr)\n        return $root.find(selector);\n    }\n    // Match html or make sure no context is specified for #id\n    // Note: match[1] may be a string or a TrustedHTML wrapper\n    if (match[1]) {\n        // HANDLE: $(html) -> $(array)\n        $.merge(this, $.parseHTML(match[1]));\n        return this;\n    }\n    // HANDLE: $(#id)\n    const el = document.getElementById(match[2]);\n    if (el) {\n        // Inject the element directly into the $ object\n        this[0] = el;\n        this.length = 1;\n    }\n    return this;\n};\n\n$.Dom = Dom;\n\n// Give the init function the $ prototype for later instantiation\nDom.prototype = $.fn;\n\n// Events\n\n$.Event = _Event_mjs__WEBPACK_IMPORTED_MODULE_2__.Event;\n\n$.event = {\n    special: Object.create(null),\n};\n\n$.event.has = function(elem, eventType) {\n    const events = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.get(elem, 'events');\n    if (!events) return false;\n    if (!eventType) return true;\n    return Array.isArray(events[eventType]) && events[eventType].length > 0;\n};\n\n$.event.on = function(elem, types, selector, data, fn, one) {\n\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n        // ( types-Object, selector, data )\n        if (typeof selector !== 'string') {\n            // ( types-Object, data )\n            data = data || selector;\n            selector = undefined;\n        }\n        for (let type in types) {\n            $.event.on(elem, type, selector, data, types[type], one);\n        }\n        return elem;\n    }\n\n    if (data == null && fn == null) {\n        // ( types, fn )\n        fn = selector;\n        data = selector = undefined;\n    } else if (fn == null) {\n        if (typeof selector === 'string') {\n            // ( types, selector, fn )\n            fn = data;\n            data = undefined;\n        } else {\n            // ( types, data, fn )\n            fn = data;\n            data = selector;\n            selector = undefined;\n        }\n    }\n    if (!fn) {\n        return elem;\n    }\n    if (one === 1) {\n        const origFn = fn;\n        fn = function(event) {\n            // Can use an empty set, since event contains the info\n            $().off(event);\n            return origFn.apply(this, arguments);\n        };\n\n        // Use same guid so caller can remove using origFn\n        fn.guid = origFn.guid || (origFn.guid = $.guid++);\n    }\n    for (let i = 0; i < elem.length; i++) {\n        $.event.add(elem[i], types, fn, data, selector);\n    }\n};\n\n$.event.add = function(elem, types, handler, data, selector) {\n    // Only attach events to objects for which we can store data\n    if (typeof elem != 'object') {\n        return;\n    }\n\n    const elemData = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.create(elem);\n\n    // Caller can pass in an object of custom data in lieu of the handler\n    let handleObjIn;\n    if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n    }\n\n    // Ensure that invalid selectors throw exceptions at attach time\n    // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n    if (selector) {\n        documentElement.matches(selector);\n    }\n\n    // Make sure that the handler has a unique ID, used to find/remove it later\n    if (!handler.guid) {\n        handler.guid = $.guid++;\n    }\n\n    // Init the element's event structure and main handler, if this is the first\n    let events;\n    if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n    }\n    let eventHandle;\n    if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function(e) {\n            // Discard the second event of a $.event.trigger() and\n            // when an event is called after a page has unloaded\n            return (typeof $ !== 'undefined')\n                ? $.event.dispatch.apply(elem, arguments)\n                : undefined;\n        };\n    }\n\n    // Handle multiple events separated by a space\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!origType) {\n            continue;\n        }\n\n        const namespaces = ns.split('.').sort();\n        // If event changes its type, use the special event handlers for the changed type\n        let special = $.event.special[origType];\n        // If selector defined, determine special event api type, otherwise given type\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        // Update special based on newly reset type\n        special = $.event.special[type];\n        // handleObj is passed to all event handlers\n        const handleObj = Object.assign(\n            {\n                type: type,\n                origType: origType,\n                data: data,\n                handler: handler,\n                guid: handler.guid,\n                selector: selector,\n                namespace: namespaces.join('.'),\n            },\n            handleObjIn\n        );\n\n        let handlers;\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n            handlers = events[type] = [];\n            handlers.delegateCount = 0;\n\n            // Only use addEventListener if the special events handler returns false\n            if (\n                !special || !special.setup ||\n                    special.setup.call(elem, data, namespaces, eventHandle) === false\n            ) {\n                if (elem.addEventListener) {\n                    elem.addEventListener(type, eventHandle);\n                }\n            }\n        }\n\n        if (special && special.add) {\n            special.add.call(elem, handleObj);\n            if (!handleObj.handler.guid) {\n                handleObj.handler.guid = handler.guid;\n            }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n            handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n            handlers.push(handleObj);\n        }\n    }\n};\n\n// Detach an event or set of events from an element\n$.event.remove = function(elem, types, handler, selector, mappedTypes) {\n\n    const elemData = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.get(elem);\n    if (!elemData || !elemData.events) return;\n    const events = elemData.events;\n\n    // Once for each type.namespace in types; type may be omitted\n    const typesArr = (types || '').match(rNotHtmlWhite) || [''];\n    let i = typesArr.length;\n    while (i--) {\n        const [, origType, ns = ''] = rTypeNamespace.exec(typesArr[i]);\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!origType) {\n            for (const type in events) {\n                $.event.remove(\n                    elem,\n                    type + typesArr[i],\n                    handler,\n                    selector,\n                    true\n                );\n            }\n            continue;\n        }\n\n        const special = $.event.special[origType];\n        const type = (special && (selector ? special.delegateType : special.bindType)) || origType;\n        const handlers = events[type];\n        if (!handlers || handlers.length === 0) continue;\n\n        const namespaces = ns.split('.').sort();\n        const rNamespace = ns\n            ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\n            : null;\n\n        // Remove matching events\n        const origCount = handlers.length;\n        let j = origCount;\n        while (j--) {\n            const handleObj = handlers[j];\n\n            if (\n                (mappedTypes || origType === handleObj.origType) &&\n                    (!handler || handler.guid === handleObj.guid) &&\n                    (!rNamespace || rNamespace.test(handleObj.namespace)) &&\n                    (!selector ||\n                        selector === handleObj.selector ||\n                        (selector === '**' && handleObj.selector))\n            ) {\n                handlers.splice(j, 1);\n                if (handleObj.selector) {\n                    handlers.delegateCount--;\n                }\n                if (special && special.remove) {\n                    special.remove.call(elem, handleObj);\n                }\n            }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && handlers.length === 0) {\n            if (\n                !special || !special.teardown ||\n                    special.teardown.call(elem, namespaces, elemData.handle) === false\n            ) {\n                // This \"if\" is needed for plain objects\n                if (elem.removeEventListener) {\n                    elem.removeEventListener(type, elemData.handle);\n                }\n            }\n            delete events[type];\n        }\n    }\n\n    // Remove data if it's no longer used\n    if ((0,_util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty)(events)) {\n        _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.remove(elem, 'handle');\n        _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.remove(elem, 'events');\n    }\n};\n\n$.event.dispatch = function(nativeEvent) {\n\n    const elem = this;\n    // Make a writable $.Event from the native event object\n    const event = $.event.fix(nativeEvent);\n    event.delegateTarget = elem;\n    // Use the fix-ed $.Event rather than the (read-only) native event\n    const args = Array.from(arguments);\n    args[0] = event;\n\n    const eventsData = _vars_mjs__WEBPACK_IMPORTED_MODULE_0__.dataPriv.get(elem, 'events');\n    const handlers = (eventsData && eventsData[event.type]) || [];\n    const special = $.event.special[event.type];\n\n    // Call the preDispatch hook for the mapped type, and let it bail if desired\n    if (special && special.preDispatch) {\n        if (special.preDispatch.call(elem, event) === false) return;\n    }\n\n    // Determine handlers\n    const handlerQueue = $.event.handlers.call(elem, event, handlers);\n\n    // Run delegates first; they may want to stop propagation beneath us\n    let i = 0;\n    let matched;\n    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        let j = 0;\n        let handleObj;\n        while (\n            (handleObj = matched.handlers[j++]) &&\n                !event.isImmediatePropagationStopped()\n        ) {\n\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n\n            const origSpecial = $.event.special[handleObj.origType];\n            let handler;\n            if (origSpecial && origSpecial.handle) {\n                handler = origSpecial.handle;\n            } else {\n                handler = handleObj.handler;\n            }\n\n            const ret = handler.apply(matched.elem, args);\n            if (ret !== undefined) {\n                if ((event.result = ret) === false) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                }\n            }\n        }\n    }\n\n    // Call the postDispatch hook for the mapped type\n    if (special && special.postDispatch) {\n        special.postDispatch.call(elem, event);\n    }\n\n    return event.result;\n};\n\n$.event.handlers = function(event, handlers) {\n\n    const delegateCount = handlers.delegateCount;\n    const handlerQueue = [];\n\n    // Find delegate handlers\n    if (\n        delegateCount &&\n            // Support: Firefox <=42 - 66+\n            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n            // Support: IE 11+\n            // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n            !(event.type === 'click' && event.button >= 1)\n    ) {\n        for (let cur = event.target; cur !== this; cur = cur.parentNode || this) {\n            // Don't check non-elements (trac-13208)\n            // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)\n            if (\n                cur.nodeType === 1 &&\n                    !(event.type === 'click' && cur.disabled === true)\n            ) {\n                const matchedHandlers = [];\n                const matchedSelectors = {};\n                for (let i = 0; i < delegateCount; i++) {\n                    const handleObj = handlers[i];\n                    // Don't conflict with Object.prototype properties (trac-13203)\n                    const sel = handleObj.selector + ' ';\n                    if (matchedSelectors[sel] === undefined) {\n                        matchedSelectors[sel] = cur.matches(sel);\n                    }\n                    if (matchedSelectors[sel]) {\n                        matchedHandlers.push(handleObj);\n                    }\n                }\n                if (matchedHandlers.length) {\n                    handlerQueue.push({\n                        elem: cur,\n                        handlers: matchedHandlers,\n                    });\n                }\n            }\n        }\n    }\n\n    // Add the remaining (directly-bound) handlers\n    if (delegateCount < handlers.length) {\n        handlerQueue.push({\n            elem: this,\n            handlers: handlers.slice(delegateCount),\n        });\n    }\n\n    return handlerQueue;\n};\n\n$.event.fix = function(originalEvent) {\n    return originalEvent.envelope ? originalEvent : new _Event_mjs__WEBPACK_IMPORTED_MODULE_2__.Event(originalEvent);\n};\n\n// A central reference to the root $(document)\nconst $root = $(document);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9Eb20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJEO0FBQ1g7QUFDWjs7QUFFcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywrQ0FBUTs7QUFFakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkRBQUk7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsNkNBQUs7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLCtDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLCtDQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiwrQ0FBUTtBQUM3QjtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDhEQUFPO0FBQ2YsUUFBUSwrQ0FBUTtBQUNoQixRQUFRLCtDQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLCtDQUFRO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCw2Q0FBSztBQUM3RDs7QUFFQTtBQUNBOztBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Eb20vRG9tLm1qcz8xN2ViIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHY0LjAuMC1wcmUrYzk4NTk3ZWEuZGlydHlcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgT3BlbkpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjMtMTEtMjRUMTQ6MDRaXG4gKi9cblxuaW1wb3J0IHsgdW5pcSwgaXNFbXB0eSB9IGZyb20gJy4uLy4uL3V0aWwvdXRpbEhlbHBlcnMubWpzJztcbmltcG9ydCB7IGRhdGFQcml2LCBkYXRhVXNlciB9IGZyb20gJy4vdmFycy5tanMnO1xuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICcuL0V2ZW50Lm1qcyc7XG5cbmNvbnN0IGRvY3VtZW50ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdy5kb2N1bWVudCA6IG51bGw7XG5jb25zdCBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbmNvbnN0IHJUeXBlTmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuLy8gT25seSBjb3VudCBIVE1MIHdoaXRlc3BhY2Vcbi8vIE90aGVyIHdoaXRlc3BhY2Ugc2hvdWxkIGNvdW50IGluIHZhbHVlc1xuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbmNvbnN0IHJOb3RIdG1sV2hpdGUgPSAvW15cXHgyMFxcdFxcclxcblxcZl0rL2c7XG5cbi8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgJFxuY29uc3QgJCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgLy8gVGhlICQgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuICAgIC8vIE5lZWQgaW5pdCBpZiAkIGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuICAgIHJldHVybiBuZXcgJC5Eb20oc2VsZWN0b3IpO1xufTtcblxuJC5mbiA9ICQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiAkLFxuICAgIC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhICQgb2JqZWN0IGlzIDBcbiAgICBsZW5ndGg6IDAsXG59O1xuXG4vLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcbiQuZ3VpZCA9IDE7XG5cbi8vIFVzZXIgZGF0YSBzdG9yYWdlXG4kLmRhdGEgPSBkYXRhVXNlcjtcblxuJC5tZXJnZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBsZXQgbGVuID0gK3NlY29uZC5sZW5ndGg7XG4gICAgbGV0IGkgPSBmaXJzdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICBmaXJzdFtpKytdID0gc2Vjb25kW2pdO1xuICAgIH1cbiAgICBmaXJzdC5sZW5ndGggPSBpO1xuICAgIHJldHVybiBmaXJzdDtcbn07XG5cbiQucGFyc2VIVE1MID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgLy8gSW5saW5lIGV2ZW50cyB3aWxsIG5vdCBleGVjdXRlIHdoZW4gdGhlIEhUTUwgaXMgcGFyc2VkOyB0aGlzIGluY2x1ZGVzLCBmb3IgZXhhbXBsZSwgc2VuZGluZyBHRVQgcmVxdWVzdHMgZm9yIGltYWdlcy5cbiAgICBjb25zdCBjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gICAgLy8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50IHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG4gICAgLy8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTFxuICAgIGNvbnN0IGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICBiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgIGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZChiYXNlKTtcblxuICAgIGNvbnRleHQuYm9keS5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgLy8gcmVtb3ZlIHNjcmlwdHNcbiAgICBjb25zdCBzY3JpcHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjcmlwdHNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNvbnRleHQuYm9keS5jaGlsZE5vZGVzKTtcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgJC5mbltTeW1ib2wuaXRlcmF0b3JdID0gQXJyYXkucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl07XG59XG5cbiQuZm4udG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMpO1xufTtcblxuLy8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuLy8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG4kLmZuLnB1c2hTdGFjayA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgLy8gQnVpbGQgYSBuZXcgJCBtYXRjaGVkIGVsZW1lbnQgc2V0XG4gICAgY29uc3QgcmV0ID0gJC5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1lbnRzKTtcbiAgICAvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuICAgIHJldC5wcmV2T2JqZWN0ID0gdGhpcztcbiAgICAvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuICAgIHJldHVybiByZXQ7XG59O1xuXG4kLmZuLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgIGNvbnN0IHJldCA9IHRoaXMucHVzaFN0YWNrKFtdKTtcbiAgICBpZiAoIWVsKSByZXR1cm4gcmV0O1xuICAgIC8vIEVhcmx5IHJldHVybiBpZiBjb250ZXh0IGlzIG5vdCBhbiBlbGVtZW50LCBkb2N1bWVudCBvciBkb2N1bWVudCBmcmFnbWVudFxuICAgIGNvbnN0IHsgbm9kZVR5cGUgfSA9IGVsO1xuICAgIGlmIChub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGVsICE9PSBzZWxlY3RvciAmJiBlbC5jb250YWlucyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICQubWVyZ2UocmV0LCBbc2VsZWN0b3JdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgICQubWVyZ2UocmV0LCBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuXG4kLmZuLmFkZCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudHMgPSAkKHNlbGVjdG9yKS50b0FycmF5KCk7XG4gICAgY29uc3QgcHJldkVsZW1lbnRzID0gdGhpcy50b0FycmF5KCk7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5wdXNoU3RhY2soW10pO1xuICAgICQubWVyZ2UocmV0LCB1bmlxKHByZXZFbGVtZW50cy5jb25jYXQobmV3RWxlbWVudHMpKSk7XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbiQuZm4uYWRkQmFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFkZCh0aGlzLnByZXZPYmplY3QpO1xufTtcblxuJC5mbi5maWx0ZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbaV07XG4gICAgICAgIGlmICghbm9kZS5tYXRjaGVzKHNlbGVjdG9yKSkgY29udGludWU7XG4gICAgICAgIG1hdGNoZXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG1hdGNoZXMpO1xufTtcblxuLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncbi8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICh0cmFjLTk1MjEpXG4vLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAodHJhYy0xMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG4vLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5jb25zdCByUXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC87XG5cbmZ1bmN0aW9uIGlzT2J2aW91c0h0bWwoaW5wdXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBpbnB1dFswXSA9PT0gJzwnICYmIGlucHV0W2lucHV0Lmxlbmd0aCAtIDFdID09PSAnPicgJiYgaW5wdXQubGVuZ3RoID49IDNcbiAgICApO1xufVxuXG5jb25zdCBEb20gPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgLy8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEhBTkRMRTogJChmdW5jdGlvbilcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWxlY3RvciB3aXRoIGNvbnRleHQgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcbiAgICAgICAgLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXG4gICAgICAgIHRoaXNbMF0gPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGV0IG1hdGNoO1xuICAgIGlmIChpc09idmlvdXNIdG1sKHNlbGVjdG9yICsgJycpKSB7XG4gICAgICAgIC8vIEhhbmRsZSBvYnZpb3VzIEhUTUwgc3RyaW5nc1xuICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwXG4gICAgICAgIC8vIHRoZSByZWdleCBjaGVjay4gVGhpcyBhbHNvIGhhbmRsZXMgYnJvd3Nlci1zdXBwb3J0ZWQgSFRNTCB3cmFwcGVyc1xuICAgICAgICAvLyBsaWtlIFRydXN0ZWRIVE1MLlxuICAgICAgICBtYXRjaCA9IFtudWxsLCBzZWxlY3RvciwgbnVsbF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Mgb3Igc2VsZWN0b3JzXG4gICAgICAgIG1hdGNoID0gclF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheS1saWtlXG4gICAgICAgIHJldHVybiAkLm1lcmdlKHRoaXMsIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2hbMV0pIHtcbiAgICAgICAgLy8gSEFORExFOiAkKGV4cHIpXG4gICAgICAgIHJldHVybiAkcm9vdC5maW5kKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgLy8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuICAgIC8vIE5vdGU6IG1hdGNoWzFdIG1heSBiZSBhIHN0cmluZyBvciBhIFRydXN0ZWRIVE1MIHdyYXBwZXJcbiAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgLy8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG4gICAgICAgICQubWVyZ2UodGhpcywgJC5wYXJzZUhUTUwobWF0Y2hbMV0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEhBTkRMRTogJCgjaWQpXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRjaFsyXSk7XG4gICAgaWYgKGVsKSB7XG4gICAgICAgIC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSAkIG9iamVjdFxuICAgICAgICB0aGlzWzBdID0gZWw7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4kLkRvbSA9IERvbTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgJCBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbkRvbS5wcm90b3R5cGUgPSAkLmZuO1xuXG4vLyBFdmVudHNcblxuJC5FdmVudCA9IEV2ZW50O1xuXG4kLmV2ZW50ID0ge1xuICAgIHNwZWNpYWw6IE9iamVjdC5jcmVhdGUobnVsbCksXG59O1xuXG4kLmV2ZW50LmhhcyA9IGZ1bmN0aW9uKGVsZW0sIGV2ZW50VHlwZSkge1xuICAgIGNvbnN0IGV2ZW50cyA9IGRhdGFQcml2LmdldChlbGVtLCAnZXZlbnRzJyk7XG4gICAgaWYgKCFldmVudHMpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWV2ZW50VHlwZSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXZlbnRzW2V2ZW50VHlwZV0pICYmIGV2ZW50c1tldmVudFR5cGVdLmxlbmd0aCA+IDA7XG59O1xuXG4kLmV2ZW50Lm9uID0gZnVuY3Rpb24oZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKSB7XG5cbiAgICAvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcbiAgICBpZiAodHlwZW9mIHR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuICAgICAgICAgICAgZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHR5cGVzKSB7XG4gICAgICAgICAgICAkLmV2ZW50Lm9uKGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1t0eXBlXSwgb25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwpIHtcbiAgICAgICAgLy8gKCB0eXBlcywgZm4gKVxuICAgICAgICBmbiA9IHNlbGVjdG9yO1xuICAgICAgICBkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChmbiA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuICAgICAgICAgICAgZm4gPSBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICggdHlwZXMsIGRhdGEsIGZuIClcbiAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGlmIChvbmUgPT09IDEpIHtcbiAgICAgICAgY29uc3Qgb3JpZ0ZuID0gZm47XG4gICAgICAgIGZuID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuICAgICAgICAgICAgJCgpLm9mZihldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ0ZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cbiAgICAgICAgZm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8IChvcmlnRm4uZ3VpZCA9ICQuZ3VpZCsrKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICQuZXZlbnQuYWRkKGVsZW1baV0sIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IpO1xuICAgIH1cbn07XG5cbiQuZXZlbnQuYWRkID0gZnVuY3Rpb24oZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yKSB7XG4gICAgLy8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgZm9yIHdoaWNoIHdlIGNhbiBzdG9yZSBkYXRhXG4gICAgaWYgKHR5cGVvZiBlbGVtICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtRGF0YSA9IGRhdGFQcml2LmNyZWF0ZShlbGVtKTtcblxuICAgIC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuICAgIGxldCBoYW5kbGVPYmpJbjtcbiAgICBpZiAoaGFuZGxlci5oYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG4gICAgICAgIHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuICAgIC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG4gICAgaWYgKCFoYW5kbGVyLmd1aWQpIHtcbiAgICAgICAgaGFuZGxlci5ndWlkID0gJC5ndWlkKys7XG4gICAgfVxuXG4gICAgLy8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgIGxldCBldmVudHM7XG4gICAgaWYgKCEoZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzKSkge1xuICAgICAgICBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBsZXQgZXZlbnRIYW5kbGU7XG4gICAgaWYgKCEoZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUpKSB7XG4gICAgICAgIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgJC5ldmVudC50cmlnZ2VyKCkgYW5kXG4gICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiAkICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICA/ICQuZXZlbnQuZGlzcGF0Y2guYXBwbHkoZWxlbSwgYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcbiAgICBjb25zdCB0eXBlc0FyciA9ICh0eXBlcyB8fCAnJykubWF0Y2gock5vdEh0bWxXaGl0ZSkgfHwgWycnXTtcbiAgICBsZXQgaSA9IHR5cGVzQXJyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IFssIG9yaWdUeXBlLCBucyA9ICcnXSA9IHJUeXBlTmFtZXNwYWNlLmV4ZWModHlwZXNBcnJbaV0pO1xuICAgICAgICAvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcbiAgICAgICAgaWYgKCFvcmlnVHlwZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gbnMuc3BsaXQoJy4nKS5zb3J0KCk7XG4gICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuICAgICAgICBsZXQgc3BlY2lhbCA9ICQuZXZlbnQuc3BlY2lhbFtvcmlnVHlwZV07XG4gICAgICAgIC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuICAgICAgICBjb25zdCB0eXBlID0gKHNwZWNpYWwgJiYgKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSkgfHwgb3JpZ1R5cGU7XG4gICAgICAgIC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcbiAgICAgICAgc3BlY2lhbCA9ICQuZXZlbnQuc3BlY2lhbFt0eXBlXTtcbiAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgY29uc3QgaGFuZGxlT2JqID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG9yaWdUeXBlOiBvcmlnVHlwZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgZ3VpZDogaGFuZGxlci5ndWlkLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbignLicpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU9iakluXG4gICAgICAgICk7XG5cbiAgICAgICAgbGV0IGhhbmRsZXJzO1xuICAgICAgICAvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuICAgICAgICBpZiAoIShoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSkpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdID0gW107XG4gICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgLy8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNwZWNpYWwgfHwgIXNwZWNpYWwuc2V0dXAgfHxcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5zZXR1cC5jYWxsKGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlY2lhbCAmJiBzcGVjaWFsLmFkZCkge1xuICAgICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbChlbGVtLCBoYW5kbGVPYmopO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVPYmouaGFuZGxlci5ndWlkKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlT2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuJC5ldmVudC5yZW1vdmUgPSBmdW5jdGlvbihlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzKSB7XG5cbiAgICBjb25zdCBlbGVtRGF0YSA9IGRhdGFQcml2LmdldChlbGVtKTtcbiAgICBpZiAoIWVsZW1EYXRhIHx8ICFlbGVtRGF0YS5ldmVudHMpIHJldHVybjtcbiAgICBjb25zdCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHM7XG5cbiAgICAvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG4gICAgY29uc3QgdHlwZXNBcnIgPSAodHlwZXMgfHwgJycpLm1hdGNoKHJOb3RIdG1sV2hpdGUpIHx8IFsnJ107XG4gICAgbGV0IGkgPSB0eXBlc0Fyci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBbLCBvcmlnVHlwZSwgbnMgPSAnJ10gPSByVHlwZU5hbWVzcGFjZS5leGVjKHR5cGVzQXJyW2ldKTtcbiAgICAgICAgLy8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG4gICAgICAgIGlmICghb3JpZ1R5cGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICAkLmV2ZW50LnJlbW92ZShcbiAgICAgICAgICAgICAgICAgICAgZWxlbSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSArIHR5cGVzQXJyW2ldLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNwZWNpYWwgPSAkLmV2ZW50LnNwZWNpYWxbb3JpZ1R5cGVdO1xuICAgICAgICBjb25zdCB0eXBlID0gKHNwZWNpYWwgJiYgKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSkgfHwgb3JpZ1R5cGU7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoIWhhbmRsZXJzIHx8IGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbmFtZXNwYWNlcyA9IG5zLnNwbGl0KCcuJykuc29ydCgpO1xuICAgICAgICBjb25zdCByTmFtZXNwYWNlID0gbnNcbiAgICAgICAgICAgID8gbmV3IFJlZ0V4cCgnKF58XFxcXC4pJyArIG5hbWVzcGFjZXMuam9pbignXFxcXC4oPzouKlxcXFwufCknKSArICcoXFxcXC58JCknKVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcbiAgICAgICAgY29uc3Qgb3JpZ0NvdW50ID0gaGFuZGxlcnMubGVuZ3RoO1xuICAgICAgICBsZXQgaiA9IG9yaWdDb3VudDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlT2JqID0gaGFuZGxlcnNbal07XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQpICYmXG4gICAgICAgICAgICAgICAgICAgICghck5hbWVzcGFjZSB8fCByTmFtZXNwYWNlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICghc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3RvciA9PT0gJyoqJyAmJiBoYW5kbGVPYmouc2VsZWN0b3IpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVPYmouc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbCAmJiBzcGVjaWFsLnJlbW92ZSkge1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuICAgICAgICAvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcbiAgICAgICAgaWYgKG9yaWdDb3VudCAmJiBoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhc3BlY2lhbCB8fCAhc3BlY2lhbC50ZWFyZG93biB8fFxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnRlYXJkb3duLmNhbGwoZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlKSA9PT0gZmFsc2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGVsZW1EYXRhLmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBkYXRhIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcbiAgICBpZiAoaXNFbXB0eShldmVudHMpKSB7XG4gICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCAnaGFuZGxlJyk7XG4gICAgICAgIGRhdGFQcml2LnJlbW92ZShlbGVtLCAnZXZlbnRzJyk7XG4gICAgfVxufTtcblxuJC5ldmVudC5kaXNwYXRjaCA9IGZ1bmN0aW9uKG5hdGl2ZUV2ZW50KSB7XG5cbiAgICBjb25zdCBlbGVtID0gdGhpcztcbiAgICAvLyBNYWtlIGEgd3JpdGFibGUgJC5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG4gICAgY29uc3QgZXZlbnQgPSAkLmV2ZW50LmZpeChuYXRpdmVFdmVudCk7XG4gICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBlbGVtO1xuICAgIC8vIFVzZSB0aGUgZml4LWVkICQuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgYXJnc1swXSA9IGV2ZW50O1xuXG4gICAgY29uc3QgZXZlbnRzRGF0YSA9IGRhdGFQcml2LmdldChlbGVtLCAnZXZlbnRzJyk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSAoZXZlbnRzRGF0YSAmJiBldmVudHNEYXRhW2V2ZW50LnR5cGVdKSB8fCBbXTtcbiAgICBjb25zdCBzcGVjaWFsID0gJC5ldmVudC5zcGVjaWFsW2V2ZW50LnR5cGVdO1xuXG4gICAgLy8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuICAgIGlmIChzcGVjaWFsICYmIHNwZWNpYWwucHJlRGlzcGF0Y2gpIHtcbiAgICAgICAgaWYgKHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbChlbGVtLCBldmVudCkgPT09IGZhbHNlKSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIGhhbmRsZXJzXG4gICAgY29uc3QgaGFuZGxlclF1ZXVlID0gJC5ldmVudC5oYW5kbGVycy5jYWxsKGVsZW0sIGV2ZW50LCBoYW5kbGVycyk7XG5cbiAgICAvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbWF0Y2hlZDtcbiAgICB3aGlsZSAoKG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbaSsrXSkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBsZXQgaGFuZGxlT2JqO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1tqKytdKSAmJlxuICAgICAgICAgICAgICAgICFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpXG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG4gICAgICAgICAgICBldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cbiAgICAgICAgICAgIGNvbnN0IG9yaWdTcGVjaWFsID0gJC5ldmVudC5zcGVjaWFsW2hhbmRsZU9iai5vcmlnVHlwZV07XG4gICAgICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgICAgIGlmIChvcmlnU3BlY2lhbCAmJiBvcmlnU3BlY2lhbC5oYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gb3JpZ1NwZWNpYWwuaGFuZGxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlT2JqLmhhbmRsZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGhhbmRsZXIuYXBwbHkobWF0Y2hlZC5lbGVtLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgoZXZlbnQucmVzdWx0ID0gcmV0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuICAgIGlmIChzcGVjaWFsICYmIHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XG4gICAgICAgIHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoZWxlbSwgZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudC5yZXN1bHQ7XG59O1xuXG4kLmV2ZW50LmhhbmRsZXJzID0gZnVuY3Rpb24oZXZlbnQsIGhhbmRsZXJzKSB7XG5cbiAgICBjb25zdCBkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudDtcbiAgICBjb25zdCBoYW5kbGVyUXVldWUgPSBbXTtcblxuICAgIC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcbiAgICBpZiAoXG4gICAgICAgIGRlbGVnYXRlQ291bnQgJiZcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MiAtIDY2K1xuICAgICAgICAgICAgLy8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUgMTErXG4gICAgICAgICAgICAvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG4gICAgICAgICAgICAhKGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiYgZXZlbnQuYnV0dG9uID49IDEpXG4gICAgKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IGV2ZW50LnRhcmdldDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKHRyYWMtMTMyMDgpXG4gICAgICAgICAgICAvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAodHJhYy02OTExLCB0cmFjLTgxNjUsIHRyYWMtMTEzODIsIHRyYWMtMTE3NjQpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY3VyLm5vZGVUeXBlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICEoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkU2VsZWN0b3JzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlT2JqID0gaGFuZGxlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICh0cmFjLTEzMjAzKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyAnICc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkU2VsZWN0b3JzW3NlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNlbGVjdG9yc1tzZWxdID0gY3VyLm1hdGNoZXMoc2VsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFNlbGVjdG9yc1tzZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSGFuZGxlcnMucHVzaChoYW5kbGVPYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkSGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGN1cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcbiAgICBpZiAoZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICBoYW5kbGVyUXVldWUucHVzaCh7XG4gICAgICAgICAgICBlbGVtOiB0aGlzLFxuICAgICAgICAgICAgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKGRlbGVnYXRlQ291bnQpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlclF1ZXVlO1xufTtcblxuJC5ldmVudC5maXggPSBmdW5jdGlvbihvcmlnaW5hbEV2ZW50KSB7XG4gICAgcmV0dXJuIG9yaWdpbmFsRXZlbnQuZW52ZWxvcGUgPyBvcmlnaW5hbEV2ZW50IDogbmV3IEV2ZW50KG9yaWdpbmFsRXZlbnQpO1xufTtcblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCAkKGRvY3VtZW50KVxuY29uc3QgJHJvb3QgPSAkKGRvY3VtZW50KTtcblxuZXhwb3J0IHsgJCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/Event.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Event: function() { return /* binding */ Event; }\n/* harmony export */ });\nconst Event = function(src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof Event)) {\n        return new Event(src, props);\n    }\n\n    // Event object\n    if (src && src.type) {\n        this.originalEvent = src;\n        this.type = src.type;\n\n        // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n        this.isDefaultPrevented = src.defaultPrevented\n            ? returnTrue\n            : returnFalse;\n\n        // Create target properties\n        this.target = src.target;\n        this.currentTarget = src.currentTarget;\n        this.relatedTarget = src.relatedTarget;\n\n        // Event type\n    } else {\n        this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n        Object.assign(this, props);\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = (src && src.timeStamp) || Date.now();\n\n    // Mark it as fixed\n    this.envelope = true;\n};\n\n// $.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n    constructor: Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    preventDefault: function() {\n        const evt = this.originalEvent;\n        this.isDefaultPrevented = returnTrue;\n        if (evt) {\n            evt.preventDefault();\n        }\n    },\n    stopPropagation: function() {\n        const evt = this.originalEvent;\n        this.isPropagationStopped = returnTrue;\n        if (evt) {\n            evt.stopPropagation();\n        }\n    },\n    stopImmediatePropagation: function() {\n        const evt = this.originalEvent;\n        this.isImmediatePropagationStopped = returnTrue;\n        if (evt) {\n            evt.stopImmediatePropagation();\n        }\n        this.stopPropagation();\n    },\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\n[\n    'altKey',\n    'bubbles',\n    'cancelable',\n    'changedTouches',\n    'ctrlKey',\n    'detail',\n    'eventPhase',\n    'metaKey',\n    'pageX',\n    'pageY',\n    'shiftKey',\n    'view',\n    'char',\n    'code',\n    'charCode',\n    'key',\n    'keyCode',\n    'button',\n    'buttons',\n    'clientX',\n    'clientY',\n    'offsetX',\n    'offsetY',\n    'pointerId',\n    'pointerType',\n    'screenX',\n    'screenY',\n    'targetTouches',\n    'toElement',\n    'touches',\n    'which',\n].forEach((name) => addProp(name));\n\nfunction addProp(name) {\n    Object.defineProperty(Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: function() {\n            return this.originalEvent ? this.originalEvent[name] : undefined;\n        },\n        set: function(value) {\n            Object.defineProperty(this, name, {\n                enumerable: true,\n                configurable: true,\n                writable: true,\n                value: value,\n            });\n        },\n    });\n}\n\nfunction returnTrue() {\n    return true;\n}\n\nfunction returnFalse() {\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9FdmVudC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9FdmVudC5tanM/YjgyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRXZlbnQgPSBmdW5jdGlvbihzcmMsIHByb3BzKSB7XG4gICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEV2ZW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50KHNyYywgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIEV2ZW50IG9iamVjdFxuICAgIGlmIChzcmMgJiYgc3JjLnR5cGUpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICAgICAgPyByZXR1cm5UcnVlXG4gICAgICAgICAgICA6IHJldHVybkZhbHNlO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnRhcmdldCA9IHNyYy50YXJnZXQ7XG4gICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuICAgICAgICAvLyBFdmVudCB0eXBlXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH1cblxuICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgdGhpcy50aW1lU3RhbXAgPSAoc3JjICYmIHNyYy50aW1lU3RhbXApIHx8IERhdGUubm93KCk7XG5cbiAgICAvLyBNYXJrIGl0IGFzIGZpeGVkXG4gICAgdGhpcy5lbnZlbG9wZSA9IHRydWU7XG59O1xuXG4vLyAkLkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEV2ZW50LFxuICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGV2dCA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZXZ0ID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBldnQgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgICBldnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbltcbiAgICAnYWx0S2V5JyxcbiAgICAnYnViYmxlcycsXG4gICAgJ2NhbmNlbGFibGUnLFxuICAgICdjaGFuZ2VkVG91Y2hlcycsXG4gICAgJ2N0cmxLZXknLFxuICAgICdkZXRhaWwnLFxuICAgICdldmVudFBoYXNlJyxcbiAgICAnbWV0YUtleScsXG4gICAgJ3BhZ2VYJyxcbiAgICAncGFnZVknLFxuICAgICdzaGlmdEtleScsXG4gICAgJ3ZpZXcnLFxuICAgICdjaGFyJyxcbiAgICAnY29kZScsXG4gICAgJ2NoYXJDb2RlJyxcbiAgICAna2V5JyxcbiAgICAna2V5Q29kZScsXG4gICAgJ2J1dHRvbicsXG4gICAgJ2J1dHRvbnMnLFxuICAgICdjbGllbnRYJyxcbiAgICAnY2xpZW50WScsXG4gICAgJ29mZnNldFgnLFxuICAgICdvZmZzZXRZJyxcbiAgICAncG9pbnRlcklkJyxcbiAgICAncG9pbnRlclR5cGUnLFxuICAgICdzY3JlZW5YJyxcbiAgICAnc2NyZWVuWScsXG4gICAgJ3RhcmdldFRvdWNoZXMnLFxuICAgICd0b0VsZW1lbnQnLFxuICAgICd0b3VjaGVzJyxcbiAgICAnd2hpY2gnLFxuXS5mb3JFYWNoKChuYW1lKSA9PiBhZGRQcm9wKG5hbWUpKTtcblxuZnVuY3Rpb24gYWRkUHJvcChuYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50ID8gdGhpcy5vcmlnaW5hbEV2ZW50W25hbWVdIDogdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/animations.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/animations.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animate: function() { return /* binding */ animate; },\n/* harmony export */   stop: function() { return /* binding */ stop; }\n/* harmony export */ });\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dom.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n/* harmony import */ var _vars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vars.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\");\n\n\n\nconst animationKey = 'animationFrameId';\nconst cssReset = {};\n\ncssReset['transition-property'] =\ncssReset['transition-duration'] =\ncssReset['transition-delay'] =\ncssReset['transition-timing-function'] =\ncssReset['animation-name'] =\ncssReset['animation-duration'] =\ncssReset['animation-delay'] =\ncssReset['animation-timing-function'] = '';\n\nfunction animate(properties, opt = {}) {\n    this.stop();\n    for (let i = 0; i < this.length; i++) {\n        animateNode(this[i], properties, opt);\n    }\n    return this;\n}\n\nfunction animateNode(el, properties, opt = {}) {\n\n    let {\n        duration = 400,\n        easing = 'ease-in-out',\n        delay = 0,\n        complete\n    } = opt;\n\n    const delayId = setTimeout(function() {\n\n        const $el = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(el);\n        let fired = false;\n        let endEvent = 'transitionend';\n\n        // Convert milliseconds to seconds for CSS\n        duration = duration / 1000;\n        delay = delay / 1000;\n\n        // Set up CSS values for transition or keyframe animation\n        const cssValues = {};\n        if (typeof properties === 'string') {\n            // Keyframe animation\n            cssValues['animation-name'] = properties;\n            cssValues['animation-duration'] = duration + 's';\n            cssValues['animation-delay'] = delay + 's';\n            cssValues['animation-timing-function'] = easing;\n            endEvent = 'animationend';\n        } else {\n            // CSS transitions\n            const transitionProperties = [];\n            for (var key in properties) {\n                if (properties.hasOwnProperty(key)) {\n                    cssValues[key] = properties[key];\n                    transitionProperties.push(key);\n                }\n            }\n\n            if (duration > 0) {\n                cssValues['transition-property'] = transitionProperties.join(', ');\n                cssValues['transition-duration'] = duration + 's';\n                cssValues['transition-delay'] = delay + 's';\n                cssValues['transition-timing-function'] = easing;\n            }\n        }\n\n        const wrappedCallback = function(event){\n            if (event) {\n                if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from \"below\"\n                event.target.removeEventListener(endEvent, wrappedCallback);\n            } else {\n                el.removeEventListener(endEvent, wrappedCallback); // triggered by setTimeout\n            }\n            fired = true;\n            $el.css(cssReset);\n            complete && complete.call(el);\n        };\n\n        if (duration > 0){\n            el.addEventListener(endEvent, wrappedCallback);\n            // transitionEnd is not always firing on older Android phones\n            // so make sure it gets fired\n            const callbackId = setTimeout(function() {\n                if (fired) return;\n                wrappedCallback(null);\n            }, ((duration + delay) * 1000) + 25);\n\n            _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.set(el, animationKey, {\n                id: callbackId,\n                stop: () => {\n                    clearTimeout(callbackId);\n                    el.removeEventListener(endEvent, wrappedCallback);\n                }\n            });\n        }\n\n        $el.css(cssValues);\n\n        if (duration <= 0) {\n            wrappedCallback(null);\n        }\n    });\n\n    _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.set(el, animationKey, {\n        stop: () => clearTimeout(delayId)\n    });\n}\n\nfunction stop() {\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        const animation = _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.get(el, animationKey);\n        if (!animation) continue;\n        animation.stop();\n        _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.remove(el, animationKey);\n    }\n    this.css(cssReset);\n    return this;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9hbmltYXRpb25zLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBCO0FBQ1k7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxxQ0FBcUM7QUFDNUM7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUEsb0JBQW9CLG9EQUFDO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxjQUFjO0FBQ2QsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLFlBQVksK0NBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLElBQUksK0NBQVE7QUFDWjtBQUNBLEtBQUs7QUFDTDs7QUFFTztBQUNQLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSwwQkFBMEIsK0NBQVE7QUFDbEM7QUFDQTtBQUNBLFFBQVEsK0NBQVE7QUFDaEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvRG9tL2FuaW1hdGlvbnMubWpzPzE2MGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQgZnJvbSAnLi9Eb20ubWpzJztcbmltcG9ydCB7IGRhdGFQcml2IH0gZnJvbSAnLi92YXJzLm1qcyc7XG5cbmNvbnN0IGFuaW1hdGlvbktleSA9ICdhbmltYXRpb25GcmFtZUlkJztcbmNvbnN0IGNzc1Jlc2V0ID0ge307XG5cbmNzc1Jlc2V0Wyd0cmFuc2l0aW9uLXByb3BlcnR5J10gPVxuY3NzUmVzZXRbJ3RyYW5zaXRpb24tZHVyYXRpb24nXSA9XG5jc3NSZXNldFsndHJhbnNpdGlvbi1kZWxheSddID1cbmNzc1Jlc2V0Wyd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddID1cbmNzc1Jlc2V0WydhbmltYXRpb24tbmFtZSddID1cbmNzc1Jlc2V0WydhbmltYXRpb24tZHVyYXRpb24nXSA9XG5jc3NSZXNldFsnYW5pbWF0aW9uLWRlbGF5J10gPVxuY3NzUmVzZXRbJ2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb24nXSA9ICcnO1xuXG5leHBvcnQgZnVuY3Rpb24gYW5pbWF0ZShwcm9wZXJ0aWVzLCBvcHQgPSB7fSkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhbmltYXRlTm9kZSh0aGlzW2ldLCBwcm9wZXJ0aWVzLCBvcHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZU5vZGUoZWwsIHByb3BlcnRpZXMsIG9wdCA9IHt9KSB7XG5cbiAgICBsZXQge1xuICAgICAgICBkdXJhdGlvbiA9IDQwMCxcbiAgICAgICAgZWFzaW5nID0gJ2Vhc2UtaW4tb3V0JyxcbiAgICAgICAgZGVsYXkgPSAwLFxuICAgICAgICBjb21wbGV0ZVxuICAgIH0gPSBvcHQ7XG5cbiAgICBjb25zdCBkZWxheUlkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICBjb25zdCAkZWwgPSAkKGVsKTtcbiAgICAgICAgbGV0IGZpcmVkID0gZmFsc2U7XG4gICAgICAgIGxldCBlbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcblxuICAgICAgICAvLyBDb252ZXJ0IG1pbGxpc2Vjb25kcyB0byBzZWNvbmRzIGZvciBDU1NcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDA7XG4gICAgICAgIGRlbGF5ID0gZGVsYXkgLyAxMDAwO1xuXG4gICAgICAgIC8vIFNldCB1cCBDU1MgdmFsdWVzIGZvciB0cmFuc2l0aW9uIG9yIGtleWZyYW1lIGFuaW1hdGlvblxuICAgICAgICBjb25zdCBjc3NWYWx1ZXMgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gS2V5ZnJhbWUgYW5pbWF0aW9uXG4gICAgICAgICAgICBjc3NWYWx1ZXNbJ2FuaW1hdGlvbi1uYW1lJ10gPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgICAgY3NzVmFsdWVzWydhbmltYXRpb24tZHVyYXRpb24nXSA9IGR1cmF0aW9uICsgJ3MnO1xuICAgICAgICAgICAgY3NzVmFsdWVzWydhbmltYXRpb24tZGVsYXknXSA9IGRlbGF5ICsgJ3MnO1xuICAgICAgICAgICAgY3NzVmFsdWVzWydhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSBlYXNpbmc7XG4gICAgICAgICAgICBlbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zXG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNzc1ZhbHVlc1trZXldID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydGllcy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgY3NzVmFsdWVzWyd0cmFuc2l0aW9uLXByb3BlcnR5J10gPSB0cmFuc2l0aW9uUHJvcGVydGllcy5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIGNzc1ZhbHVlc1sndHJhbnNpdGlvbi1kdXJhdGlvbiddID0gZHVyYXRpb24gKyAncyc7XG4gICAgICAgICAgICAgICAgY3NzVmFsdWVzWyd0cmFuc2l0aW9uLWRlbGF5J10gPSBkZWxheSArICdzJztcbiAgICAgICAgICAgICAgICBjc3NWYWx1ZXNbJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSBlYXNpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSBmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KSByZXR1cm47IC8vIG1ha2VzIHN1cmUgdGhlIGV2ZW50IGRpZG4ndCBidWJibGUgZnJvbSBcImJlbG93XCJcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgd3JhcHBlZENhbGxiYWNrKTsgLy8gdHJpZ2dlcmVkIGJ5IHNldFRpbWVvdXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICRlbC5jc3MoY3NzUmVzZXQpO1xuICAgICAgICAgICAgY29tcGxldGUgJiYgY29tcGxldGUuY2FsbChlbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uID4gMCl7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGVuZEV2ZW50LCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbkVuZCBpcyBub3QgYWx3YXlzIGZpcmluZyBvbiBvbGRlciBBbmRyb2lkIHBob25lc1xuICAgICAgICAgICAgLy8gc28gbWFrZSBzdXJlIGl0IGdldHMgZmlyZWRcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH0sICgoZHVyYXRpb24gKyBkZWxheSkgKiAxMDAwKSArIDI1KTtcblxuICAgICAgICAgICAgZGF0YVByaXYuc2V0KGVsLCBhbmltYXRpb25LZXksIHtcbiAgICAgICAgICAgICAgICBpZDogY2FsbGJhY2tJZCxcbiAgICAgICAgICAgICAgICBzdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjYWxsYmFja0lkKTtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgd3JhcHBlZENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICRlbC5jc3MoY3NzVmFsdWVzKTtcblxuICAgICAgICBpZiAoZHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBkYXRhUHJpdi5zZXQoZWwsIGFuaW1hdGlvbktleSwge1xuICAgICAgICBzdG9wOiAoKSA9PiBjbGVhclRpbWVvdXQoZGVsYXlJZClcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpc1tpXTtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gZGF0YVByaXYuZ2V0KGVsLCBhbmltYXRpb25LZXkpO1xuICAgICAgICBpZiAoIWFuaW1hdGlvbikgY29udGludWU7XG4gICAgICAgIGFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgIGRhdGFQcml2LnJlbW92ZShlbCwgYW5pbWF0aW9uS2V5KTtcbiAgICB9XG4gICAgdGhpcy5jc3MoY3NzUmVzZXQpO1xuICAgIHJldHVybiB0aGlzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/animations.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/events.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/events.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../config/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dom.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n// TODO: should not read config outside the mvc package\n\n\n\n\n// Special events\n\nconst special = Object.create(null);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (special);\n\nspecial.load = {\n    // Prevent triggered image.load events from bubbling to window.load\n    noBubble: true,\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in $.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n[\n    ['mouseenter', 'mouseover'],\n    ['mouseleave', 'mouseout'],\n    ['pointerenter', 'pointerover'],\n    ['pointerleave', 'pointerout'],\n].forEach(([orig, fix]) => {\n    special[orig] = {\n        delegateType: fix,\n        bindType: fix,\n        handle: function(event) {\n            const target = this;\n            const related = event.relatedTarget;\n            const handleObj = event.handleObj;\n            let ret;\n            // For mouseenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if (!related || !target.contains(related)) {\n                event.type = handleObj.origType;\n                ret = handleObj.handler.apply(target, arguments);\n                event.type = fix;\n            }\n            return ret;\n        },\n    };\n});\n\n\n// Gestures\n\nconst maxDelay = _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.doubleTapInterval;\nconst minDelay = 30;\n\nspecial.dbltap = {\n    bindType: 'touchend',\n    delegateType: 'touchend',\n    handle: function(event, ...args) {\n        const { handleObj, target } = event;\n        const targetData = _Dom_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data.create(target);\n        const now = new Date().getTime();\n        const delta = 'lastTouch' in targetData ? now - targetData.lastTouch : 0;\n        if (delta < maxDelay && delta > minDelay) {\n            targetData.lastTouch = null;\n            event.type = handleObj.origType;\n            // let $ handle the triggering of \"dbltap\" event handlers\n            handleObj.handler.call(this, event, ...args);\n        } else {\n            targetData.lastTouch = now;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9ldmVudHMubWpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ2dEO0FBQ3RCOzs7QUFHMUI7O0FBRUE7O0FBRUEsK0RBQWUsT0FBTyxFQUFDOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7OztBQUdEOztBQUVBLGlCQUFpQixxREFBTTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEMsMkJBQTJCLGdEQUFDO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9ldmVudHMubWpzPzhiZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogc2hvdWxkIG5vdCByZWFkIGNvbmZpZyBvdXRzaWRlIHRoZSBtdmMgcGFja2FnZVxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL2luZGV4Lm1qcyc7XG5pbXBvcnQgJCBmcm9tICcuL0RvbS5tanMnO1xuXG5cbi8vIFNwZWNpYWwgZXZlbnRzXG5cbmNvbnN0IHNwZWNpYWwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5leHBvcnQgZGVmYXVsdCBzcGVjaWFsO1xuXG5zcGVjaWFsLmxvYWQgPSB7XG4gICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuICAgIG5vQnViYmxlOiB0cnVlLFxufTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4gJC5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG5bXG4gICAgWydtb3VzZWVudGVyJywgJ21vdXNlb3ZlciddLFxuICAgIFsnbW91c2VsZWF2ZScsICdtb3VzZW91dCddLFxuICAgIFsncG9pbnRlcmVudGVyJywgJ3BvaW50ZXJvdmVyJ10sXG4gICAgWydwb2ludGVybGVhdmUnLCAncG9pbnRlcm91dCddLFxuXS5mb3JFYWNoKChbb3JpZywgZml4XSkgPT4ge1xuICAgIHNwZWNpYWxbb3JpZ10gPSB7XG4gICAgICAgIGRlbGVnYXRlVHlwZTogZml4LFxuICAgICAgICBiaW5kVHlwZTogZml4LFxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG4gICAgICAgICAgICBsZXQgcmV0O1xuICAgICAgICAgICAgLy8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cbiAgICAgICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG4gICAgICAgICAgICBpZiAoIXJlbGF0ZWQgfHwgIXRhcmdldC5jb250YWlucyhyZWxhdGVkKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgIH07XG59KTtcblxuXG4vLyBHZXN0dXJlc1xuXG5jb25zdCBtYXhEZWxheSA9IGNvbmZpZy5kb3VibGVUYXBJbnRlcnZhbDtcbmNvbnN0IG1pbkRlbGF5ID0gMzA7XG5cbnNwZWNpYWwuZGJsdGFwID0ge1xuICAgIGJpbmRUeXBlOiAndG91Y2hlbmQnLFxuICAgIGRlbGVnYXRlVHlwZTogJ3RvdWNoZW5kJyxcbiAgICBoYW5kbGU6IGZ1bmN0aW9uKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlT2JqLCB0YXJnZXQgfSA9IGV2ZW50O1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gJC5kYXRhLmNyZWF0ZSh0YXJnZXQpO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSAnbGFzdFRvdWNoJyBpbiB0YXJnZXREYXRhID8gbm93IC0gdGFyZ2V0RGF0YS5sYXN0VG91Y2ggOiAwO1xuICAgICAgICBpZiAoZGVsdGEgPCBtYXhEZWxheSAmJiBkZWx0YSA+IG1pbkRlbGF5KSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhLmxhc3RUb3VjaCA9IG51bGw7XG4gICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuICAgICAgICAgICAgLy8gbGV0ICQgaGFuZGxlIHRoZSB0cmlnZ2VyaW5nIG9mIFwiZGJsdGFwXCIgZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyLmNhbGwodGhpcywgZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YS5sYXN0VG91Y2ggPSBub3c7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/events.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dom.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n/* harmony import */ var _methods_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/methods.mjs\");\n/* harmony import */ var _animations_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./animations.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/animations.mjs\");\n/* harmony import */ var _props_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./props.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/props.mjs\");\n/* harmony import */ var _events_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/events.mjs\");\n\n\n\n\n\n\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn, _methods_mjs__WEBPACK_IMPORTED_MODULE_1__);\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn, _animations_mjs__WEBPACK_IMPORTED_MODULE_2__);\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fn, _props_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\nObject.assign(_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.special, _events_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBQ0E7QUFDTTtBQUNBO0FBQ0c7O0FBRWxELGNBQWMsZ0RBQUMsS0FBSyx5Q0FBTztBQUMzQixjQUFjLGdEQUFDLEtBQUssNENBQVU7QUFDOUIsY0FBYyxnREFBQyxLQUFLLGtEQUFLO0FBQ3pCLGNBQWMsZ0RBQUMsZ0JBQWdCLG1EQUFPOztBQUV0QywrREFBZSxnREFBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9pbmRleC5tanM/Yjc0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWZhdWx0IGFzICQgfSBmcm9tICcuL0RvbS5tanMnO1xuaW1wb3J0ICogYXMgbWV0aG9kcyBmcm9tICcuL21ldGhvZHMubWpzJztcbmltcG9ydCAqIGFzIGFuaW1hdGlvbnMgZnJvbSAnLi9hbmltYXRpb25zLm1qcyc7XG5pbXBvcnQgeyBkZWZhdWx0IGFzIHByb3BzIH0gZnJvbSAnLi9wcm9wcy5tanMnO1xuaW1wb3J0IHsgZGVmYXVsdCBhcyBzcGVjaWFsIH0gZnJvbSAnLi9ldmVudHMubWpzJztcblxuT2JqZWN0LmFzc2lnbigkLmZuLCBtZXRob2RzKTtcbk9iamVjdC5hc3NpZ24oJC5mbiwgYW5pbWF0aW9ucyk7XG5PYmplY3QuYXNzaWduKCQuZm4sIHByb3BzKTtcbk9iamVjdC5hc3NpZ24oJC5ldmVudC5zcGVjaWFsLCBzcGVjaWFsKTtcblxuZXhwb3J0IGRlZmF1bHQgJDtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/methods.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/methods.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClass: function() { return /* binding */ addClass; },\n/* harmony export */   append: function() { return /* binding */ append; },\n/* harmony export */   appendTo: function() { return /* binding */ appendTo; },\n/* harmony export */   children: function() { return /* binding */ children; },\n/* harmony export */   clone: function() { return /* binding */ clone; },\n/* harmony export */   closest: function() { return /* binding */ closest; },\n/* harmony export */   css: function() { return /* binding */ css; },\n/* harmony export */   data: function() { return /* binding */ data; },\n/* harmony export */   detach: function() { return /* binding */ detach; },\n/* harmony export */   empty: function() { return /* binding */ empty; },\n/* harmony export */   hasClass: function() { return /* binding */ hasClass; },\n/* harmony export */   height: function() { return /* binding */ height; },\n/* harmony export */   html: function() { return /* binding */ html; },\n/* harmony export */   off: function() { return /* binding */ off; },\n/* harmony export */   offset: function() { return /* binding */ offset; },\n/* harmony export */   on: function() { return /* binding */ on; },\n/* harmony export */   one: function() { return /* binding */ one; },\n/* harmony export */   position: function() { return /* binding */ position; },\n/* harmony export */   prepend: function() { return /* binding */ prepend; },\n/* harmony export */   prependTo: function() { return /* binding */ prependTo; },\n/* harmony export */   remove: function() { return /* binding */ remove; },\n/* harmony export */   removeClass: function() { return /* binding */ removeClass; },\n/* harmony export */   toggleClass: function() { return /* binding */ toggleClass; },\n/* harmony export */   width: function() { return /* binding */ width; }\n/* harmony export */ });\n/* harmony import */ var _util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/utilHelpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dom.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Dom.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _vars_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vars.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\");\n\n\n\n\n\n// Manipulation\n\nfunction cleanNodesData(nodes) {\n    let i = nodes.length;\n    while (i--) cleanNodeData(nodes[i]);\n}\n\nfunction cleanNodeData(node) {\n    _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.remove(node);\n    _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataPriv.remove(node);\n    _vars_mjs__WEBPACK_IMPORTED_MODULE_1__.dataUser.remove(node);\n}\n\nfunction removeNodes(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\n\nfunction remove() {\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        cleanNodeData(node);\n        cleanNodesData(node.getElementsByTagName('*'));\n    }\n    removeNodes(this);\n    return this;\n}\n\nfunction detach() {\n    removeNodes(this);\n    return this;\n}\n\nfunction empty() {\n    for (let i = 0; i < this.length; i++) {\n        const node = this[i];\n        if (node.nodeType === 1) {\n            cleanNodesData(node.getElementsByTagName('*'));\n            // Remove any remaining nodes\n            node.textContent = '';\n        }\n    }\n    return this;\n}\n\nfunction clone() {\n    const clones = [];\n    for (let i = 0; i < this.length; i++) {\n        clones.push(this[i].cloneNode(true));\n    }\n    return this.pushStack(clones);\n}\n\nfunction html(html) {\n    const [el] = this;\n    if (!el) return null;\n    if (arguments.length === 0) return el.innerHTML;\n    if (html === undefined) return this; // do nothing\n    cleanNodesData(el.getElementsByTagName('*'));\n    if (typeof html === 'string' || typeof html === 'number') {\n        el.innerHTML = html;\n    } else {\n        el.innerHTML = '';\n        return this.append(html);\n    }\n    return this;\n}\n\nfunction append(...nodes) {\n    const [parent] = this;\n    if (!parent) return this;\n    nodes.forEach((node) => {\n        if (!node) return;\n        if (typeof node === 'string') {\n            parent.append(..._Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parseHTML(node));\n        } else if (node.toString() === '[object Object]') {\n            // $ object\n            this.append(...Array.from(node));\n        } else if (Array.isArray(node)) {\n            this.append(...node);\n        } else {\n            // DOM node\n            parent.appendChild(node);\n        }\n    });\n    return this;\n}\n\nfunction prepend(...nodes) {\n    const [parent] = this;\n    if (!parent) return this;\n    nodes.forEach((node) => {\n        if (!node) return;\n        if (typeof node === 'string') {\n            parent.prepend(..._Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].parseHTML(node));\n        } else if (node.toString() === '[object Object]') {\n            // $ object\n            this.prepend(...Array.from(node));\n        } else if (Array.isArray(node)) {\n            this.prepend(...node);\n        } else {\n            // DOM node\n            parent.insertBefore(node, parent.firstChild);\n        }\n    });\n    return this;\n}\n\nfunction appendTo(parent) {\n    (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parent).append(this);\n    return this;\n}\n\nfunction prependTo(parent) {\n    (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parent).prepend(this);\n    return this;\n}\n\n// Styles and attributes\n\nconst requireUnits = {};\n[\n    'width', 'height', 'top', 'bottom', 'left', 'right',\n    'padding', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight',\n    'margin', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight',\n].forEach((cssProp) => {\n    requireUnits[cssProp] = true;\n});\n\nfunction setCSSProperty(el, name, value) {\n    if (typeof value === 'number' && requireUnits[(0,_util_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_2__.camelCase)(name)]) {\n        value += 'px';\n    }\n    el.style[name] = value;\n}\n\nfunction css(name, value) {\n    let styles;\n    if (typeof name === 'string') {\n        if (value === undefined) {\n            const [el] = this;\n            if (!el) return null;\n            return el.style[name];\n        } else {\n            styles = { [name]: value };\n        }\n    } else if (!name) {\n        throw new Error('no styles provided');\n    } else {\n        styles = name;\n    }\n    for (let style in styles) {\n        if (styles.hasOwnProperty(style)) {\n            for (let i = 0; i < this.length; i++) {\n                setCSSProperty(this[i], style, styles[style]);\n            }\n        }\n    }\n    return this;\n}\n\nfunction data(name, value) {\n    if (arguments.length < 2) {\n        const [el] = this;\n        if (!el) return null;\n        if (name === undefined) {\n            return el.dataset;\n        }\n        return el.dataset[name];\n    }\n    for (let i = 0; i < this.length; i++) {\n        this[i].dataset[name] = value;\n    }\n    return this;\n}\n\n// Classes\n\nfunction setNodesClass(method, nodes, args) {\n    for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype[method].apply({ node }, args);\n    }\n}\n\nfunction removeClass() {\n    setNodesClass('removeClass', this, arguments);\n    return this;\n}\n\nfunction addClass() {\n    setNodesClass('addClass', this, arguments);\n    return this;\n}\n\nfunction toggleClass() {\n    setNodesClass('toggleClass', this, arguments);\n    return this;\n}\n\nfunction hasClass() {\n    const [node] = this;\n    if (!node) return false;\n    return _V_index_mjs__WEBPACK_IMPORTED_MODULE_3__[\"default\"].prototype.hasClass.apply({ node }, arguments);\n}\n\n// Traversing\n\nfunction children(selector) {\n    const matches = [];\n    for(let i = 0; i < this.length; i++) {\n        const node = this[i];\n        let children = Array.from(node.children);\n        if (typeof selector === 'string') {\n            children = children.filter(child => child.matches(selector));\n        }\n        matches.push(...children);\n    }\n    return this.pushStack(matches);\n}\n\nfunction closest(selector) {\n    const closest = [];\n    for (let i = 0; i < this.length; i++) {\n        const el = this[i];\n        if (typeof selector === 'string') {\n            const closestEl = el.closest(selector);\n            if (closestEl) {\n                closest.push(closestEl);\n            }\n        } else {\n            const [ancestorEl] = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(selector);\n            if (ancestorEl && ancestorEl.contains(el)) {\n                closest.push(ancestorEl);\n            }\n        }\n    }\n    return this.pushStack(closest);\n}\n\n// Events\n\nfunction on(types, selector, data, fn) {\n    _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.on(this, types, selector, data, fn);\n    return this;\n}\n\nfunction one(types, selector, data, fn) {\n    _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.on(this, types, selector, data, fn, 1);\n    return this;\n}\n\nfunction off(types, selector, fn) {\n    if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched $.Event\n        const handleObj = types.handleObj;\n        (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(types.delegateTarget).off(\n            handleObj.namespace\n                ? handleObj.origType + '.' + handleObj.namespace\n                : handleObj.origType,\n            handleObj.selector,\n            handleObj.handler\n        );\n        return this;\n    }\n    if (typeof types === 'object') {\n        // ( types-object [, selector] )\n        for (let type in types) {\n            this.off(type, selector, types[type]);\n        }\n        return this;\n    }\n    if (selector === false || typeof selector === 'function') {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n    }\n    for (let i = 0; i < this.length; i++) {\n        _Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event.remove(this[i], types, fn, selector);\n    }\n    return this;\n}\n\n// Measurements\n\nfunction width() {\n    const [el] = this;\n    if (el === window) return el.document.documentElement.clientWidth;\n    else if (!el) return undefined;\n    const styles = window.getComputedStyle(el);\n    const height = el.offsetWidth;\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderBottomWidth = parseFloat(styles.borderBottomWidth);\n    const paddingTop = parseFloat(styles.paddingTop);\n    const paddingBottom = parseFloat(styles.paddingBottom);\n    return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom;\n}\n\nfunction height() {\n    const [el] = this;\n    if (el === window) return el.document.documentElement.clientHeight;\n    if (!el) return undefined;\n    const styles = window.getComputedStyle(el);\n    const width = el.offsetHeight;\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    const borderRightWidth = parseFloat(styles.borderRightWidth);\n    const paddingLeft = parseFloat(styles.paddingLeft);\n    const paddingRight = parseFloat(styles.paddingRight);\n    return width - borderLeftWidth - borderRightWidth - paddingLeft - paddingRight;\n}\n\nfunction position() {\n    const [el] = this;\n    if (!el) return;\n    let $el = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(el);\n    let offsetParent;\n    let offset;\n    let doc;\n    let parentOffset = { top: 0, left: 0 };\n    // position:fixed elements are offset from the viewport, which itself always has zero offset\n    if ($el.css('position') === 'fixed') {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = el.getBoundingClientRect();\n    } else {\n        offset = $el.offset();\n        // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n        doc = el.ownerDocument;\n        offsetParent = el.offsetParent || doc.documentElement;\n        const isStaticallyPositioned = (el) => {\n            const { position } = getComputedStyle(el);\n            return position === 'static';\n        };\n        while (offsetParent && offsetParent !== doc.documentElement && isStaticallyPositioned(offsetParent)) {\n            offsetParent = offsetParent.offsetParent || doc.documentElement;\n        }\n        if (offsetParent && offsetParent !== el && offsetParent.nodeType === 1 && !isStaticallyPositioned(offsetParent)) {\n            // Incorporate borders into its offset, since they are outside its content origin\n            const offsetParentStyles = window.getComputedStyle(offsetParent);\n            const borderTopWidth = parseFloat(offsetParentStyles.borderTopWidth) || 0;\n            const borderLeftWidth = parseFloat(offsetParentStyles.borderLeftWidth) || 0;\n            parentOffset = (0,_Dom_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(offsetParent).offset();\n            parentOffset.top += borderTopWidth;\n            parentOffset.left += borderLeftWidth;\n        }\n    }\n    const marginTop = parseFloat(window.getComputedStyle(el).marginTop) || 0;\n    const marginLeft = parseFloat(window.getComputedStyle(el).marginLeft) || 0;\n    // Subtract parent offsets and element margins\n    return {\n        top: offset.top - parentOffset.top - marginTop,\n        left: offset.left - parentOffset.left - marginLeft\n    };\n}\n\nfunction offset(coordinates) {\n    const [el] = this;\n    //  Getter\n    if (coordinates === undefined) {\n        if (!el) return null;\n        if (!el.getClientRects().length) {\n            return { top: 0, left: 0 };\n        }\n        const rect = el.getBoundingClientRect();\n        return {\n            top: rect.top + window.scrollY,\n            left: rect.left + window.scrollX\n        };\n    }\n    // Setter\n    if (!el) return this;\n    const currentStyle = window.getComputedStyle(el);\n    if (currentStyle.position === 'static') {\n        this.css('position', 'relative');\n    }\n    const currentOffset = this.offset();\n    const topDifference = coordinates.top - currentOffset.top;\n    const leftDifference = coordinates.left - currentOffset.left;\n    this.css({\n        top: (parseFloat(currentStyle.top) || 0) + topDifference + 'px',\n        left: (parseFloat(currentStyle.left) || 0) + leftDifference + 'px'\n    });\n    return this;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9tZXRob2RzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQzdCO0FBQ1E7QUFDYzs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGdEQUFDO0FBQ0wsSUFBSSwrQ0FBUTtBQUNaLElBQUksK0NBQVE7QUFDWjs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1Asb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBQztBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0RBQUM7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRU87QUFDUCxJQUFJLG9EQUFDO0FBQ0w7QUFDQTs7QUFFTztBQUNQLElBQUksb0RBQUM7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtEQUFrRCxnRUFBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUI7QUFDdkI7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLFFBQVEsb0RBQUMsMkJBQTJCLE1BQU07QUFDMUM7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxXQUFXLG9EQUFDLDRCQUE0QixNQUFNO0FBQzlDOztBQUVBOztBQUVPO0FBQ1A7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUNBQWlDLG9EQUFDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1AsSUFBSSxnREFBQztBQUNMO0FBQ0E7O0FBRU87QUFDUCxJQUFJLGdEQUFDO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyxRQUFRLGdEQUFDO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsY0FBYyxvREFBQztBQUNmO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBQztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9tdmMvRG9tL21ldGhvZHMubWpzP2FkMzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2FtZWxDYXNlIH0gZnJvbSAnLi4vLi4vdXRpbC91dGlsSGVscGVycy5tanMnO1xuaW1wb3J0ICQgZnJvbSAnLi9Eb20ubWpzJztcbmltcG9ydCBWIGZyb20gJy4uLy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IGRhdGFQcml2LCBkYXRhVXNlciB9IGZyb20gJy4vdmFycy5tanMnO1xuXG4vLyBNYW5pcHVsYXRpb25cblxuZnVuY3Rpb24gY2xlYW5Ob2Rlc0RhdGEobm9kZXMpIHtcbiAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSBjbGVhbk5vZGVEYXRhKG5vZGVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xlYW5Ob2RlRGF0YShub2RlKSB7XG4gICAgJC5ldmVudC5yZW1vdmUobm9kZSk7XG4gICAgZGF0YVByaXYucmVtb3ZlKG5vZGUpO1xuICAgIGRhdGFVc2VyLnJlbW92ZShub2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZXMobm9kZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpc1tpXTtcbiAgICAgICAgY2xlYW5Ob2RlRGF0YShub2RlKTtcbiAgICAgICAgY2xlYW5Ob2Rlc0RhdGEobm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcbiAgICB9XG4gICAgcmVtb3ZlTm9kZXModGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgcmVtb3ZlTm9kZXModGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjbGVhbk5vZGVzRGF0YShub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJykpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZXMucHVzaCh0aGlzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhjbG9uZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHRtbChodG1sKSB7XG4gICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgaWYgKCFlbCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBlbC5pbm5lckhUTUw7XG4gICAgaWYgKGh0bWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7IC8vIGRvIG5vdGhpbmdcbiAgICBjbGVhbk5vZGVzRGF0YShlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKTtcbiAgICBpZiAodHlwZW9mIGh0bWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBodG1sID09PSAnbnVtYmVyJykge1xuICAgICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlbmQoaHRtbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kKC4uLm5vZGVzKSB7XG4gICAgY29uc3QgW3BhcmVudF0gPSB0aGlzO1xuICAgIGlmICghcGFyZW50KSByZXR1cm4gdGhpcztcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kKC4uLiQucGFyc2VIVE1MKG5vZGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgICAgICAvLyAkIG9iamVjdFxuICAgICAgICAgICAgdGhpcy5hcHBlbmQoLi4uQXJyYXkuZnJvbShub2RlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoLi4ubm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBET00gbm9kZVxuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwZW5kKC4uLm5vZGVzKSB7XG4gICAgY29uc3QgW3BhcmVudF0gPSB0aGlzO1xuICAgIGlmICghcGFyZW50KSByZXR1cm4gdGhpcztcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJlbnQucHJlcGVuZCguLi4kLnBhcnNlSFRNTChub2RlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgICAgLy8gJCBvYmplY3RcbiAgICAgICAgICAgIHRoaXMucHJlcGVuZCguLi5BcnJheS5mcm9tKG5vZGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLnByZXBlbmQoLi4ubm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBET00gbm9kZVxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFRvKHBhcmVudCkge1xuICAgICQocGFyZW50KS5hcHBlbmQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwZW5kVG8ocGFyZW50KSB7XG4gICAgJChwYXJlbnQpLnByZXBlbmQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIFN0eWxlcyBhbmQgYXR0cmlidXRlc1xuXG5jb25zdCByZXF1aXJlVW5pdHMgPSB7fTtcbltcbiAgICAnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsXG4gICAgJ3BhZGRpbmcnLCAncGFkZGluZ1RvcCcsICdwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdSaWdodCcsXG4gICAgJ21hcmdpbicsICdtYXJnaW5Ub3AnLCAnbWFyZ2luQm90dG9tJywgJ21hcmdpbkxlZnQnLCAnbWFyZ2luUmlnaHQnLFxuXS5mb3JFYWNoKChjc3NQcm9wKSA9PiB7XG4gICAgcmVxdWlyZVVuaXRzW2Nzc1Byb3BdID0gdHJ1ZTtcbn0pO1xuXG5mdW5jdGlvbiBzZXRDU1NQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiByZXF1aXJlVW5pdHNbY2FtZWxDYXNlKG5hbWUpXSkge1xuICAgICAgICB2YWx1ZSArPSAncHgnO1xuICAgIH1cbiAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzKG5hbWUsIHZhbHVlKSB7XG4gICAgbGV0IHN0eWxlcztcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBbZWxdID0gdGhpcztcbiAgICAgICAgICAgIGlmICghZWwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGVsLnN0eWxlW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzID0geyBbbmFtZV06IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFuYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gc3R5bGVzIHByb3ZpZGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzID0gbmFtZTtcbiAgICB9XG4gICAgZm9yIChsZXQgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICAgIGlmIChzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZXRDU1NQcm9wZXJ0eSh0aGlzW2ldLCBzdHlsZSwgc3R5bGVzW3N0eWxlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXRhKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLmRhdGFzZXRbbmFtZV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldLmRhdGFzZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIENsYXNzZXNcblxuZnVuY3Rpb24gc2V0Tm9kZXNDbGFzcyhtZXRob2QsIG5vZGVzLCBhcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIFYucHJvdG90eXBlW21ldGhvZF0uYXBwbHkoeyBub2RlIH0sIGFyZ3MpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKCkge1xuICAgIHNldE5vZGVzQ2xhc3MoJ3JlbW92ZUNsYXNzJywgdGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENsYXNzKCkge1xuICAgIHNldE5vZGVzQ2xhc3MoJ2FkZENsYXNzJywgdGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKCkge1xuICAgIHNldE5vZGVzQ2xhc3MoJ3RvZ2dsZUNsYXNzJywgdGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NsYXNzKCkge1xuICAgIGNvbnN0IFtub2RlXSA9IHRoaXM7XG4gICAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIFYucHJvdG90eXBlLmhhc0NsYXNzLmFwcGx5KHsgbm9kZSB9LCBhcmd1bWVudHMpO1xufVxuXG4vLyBUcmF2ZXJzaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBjaGlsZHJlbihzZWxlY3Rvcikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpc1tpXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaGVzLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2sobWF0Y2hlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yKSB7XG4gICAgY29uc3QgY2xvc2VzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXNbaV07XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0RWwgPSBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0RWwpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0LnB1c2goY2xvc2VzdEVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFthbmNlc3RvckVsXSA9ICQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgaWYgKGFuY2VzdG9yRWwgJiYgYW5jZXN0b3JFbC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0LnB1c2goYW5jZXN0b3JFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGNsb3Nlc3QpO1xufVxuXG4vLyBFdmVudHNcblxuZXhwb3J0IGZ1bmN0aW9uIG9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcbiAgICAkLmV2ZW50Lm9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb25lKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4pIHtcbiAgICAkLmV2ZW50Lm9uKHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2ZmKHR5cGVzLCBzZWxlY3RvciwgZm4pIHtcbiAgICBpZiAodHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqKSB7XG4gICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCAkLkV2ZW50XG4gICAgICAgIGNvbnN0IGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcbiAgICAgICAgJCh0eXBlcy5kZWxlZ2F0ZVRhcmdldCkub2ZmKFxuICAgICAgICAgICAgaGFuZGxlT2JqLm5hbWVzcGFjZVxuICAgICAgICAgICAgICAgID8gaGFuZGxlT2JqLm9yaWdUeXBlICsgJy4nICsgaGFuZGxlT2JqLm5hbWVzcGFjZVxuICAgICAgICAgICAgICAgIDogaGFuZGxlT2JqLm9yaWdUeXBlLFxuICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxuICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICggdHlwZXMgWywgZm5dIClcbiAgICAgICAgZm4gPSBzZWxlY3RvcjtcbiAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAkLmV2ZW50LnJlbW92ZSh0aGlzW2ldLCB0eXBlcywgZm4sIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIE1lYXN1cmVtZW50c1xuXG5leHBvcnQgZnVuY3Rpb24gd2lkdGgoKSB7XG4gICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgaWYgKGVsID09PSB3aW5kb3cpIHJldHVybiBlbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgZWxzZSBpZiAoIWVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBjb25zdCBoZWlnaHQgPSBlbC5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgICBjb25zdCBib3JkZXJCb3R0b21XaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICBjb25zdCBwYWRkaW5nVG9wID0gcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ1RvcCk7XG4gICAgY29uc3QgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGVzLnBhZGRpbmdCb3R0b20pO1xuICAgIHJldHVybiBoZWlnaHQgLSBib3JkZXJCb3R0b21XaWR0aCAtIGJvcmRlclRvcFdpZHRoIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgaWYgKGVsID09PSB3aW5kb3cpIHJldHVybiBlbC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIGlmICghZWwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIGNvbnN0IHdpZHRoID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIGNvbnN0IGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG4gICAgY29uc3QgYm9yZGVyUmlnaHRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpO1xuICAgIGNvbnN0IHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMucGFkZGluZ0xlZnQpO1xuICAgIGNvbnN0IHBhZGRpbmdSaWdodCA9IHBhcnNlRmxvYXQoc3R5bGVzLnBhZGRpbmdSaWdodCk7XG4gICAgcmV0dXJuIHdpZHRoIC0gYm9yZGVyTGVmdFdpZHRoIC0gYm9yZGVyUmlnaHRXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGxldCAkZWwgPSAkKGVsKTtcbiAgICBsZXQgb2Zmc2V0UGFyZW50O1xuICAgIGxldCBvZmZzZXQ7XG4gICAgbGV0IGRvYztcbiAgICBsZXQgcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuICAgIGlmICgkZWwuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICAgIC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgb2Zmc2V0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGVsLm9mZnNldCgpO1xuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuICAgICAgICAvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuICAgICAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICAgICAgICBvZmZzZXRQYXJlbnQgPSBlbC5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgaXNTdGF0aWNhbGx5UG9zaXRpb25lZCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbiB9ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gPT09ICdzdGF0aWMnO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZG9jLmRvY3VtZW50RWxlbWVudCAmJiBpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWwgJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICYmICFpc1N0YXRpY2FsbHlQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0UGFyZW50U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnRTdHlsZXMuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudFN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpIHx8IDA7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSAkKG9mZnNldFBhcmVudCkub2Zmc2V0KCk7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICs9IGJvcmRlclRvcFdpZHRoO1xuICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0gYm9yZGVyTGVmdFdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1hcmdpblRvcCA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLm1hcmdpblRvcCkgfHwgMDtcbiAgICBjb25zdCBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luTGVmdCkgfHwgMDtcbiAgICAvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIG1hcmdpblRvcCxcbiAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIG1hcmdpbkxlZnRcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0KGNvb3JkaW5hdGVzKSB7XG4gICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgLy8gIEdldHRlclxuICAgIGlmIChjb29yZGluYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghZWwpIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIWVsLmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTZXR0ZXJcbiAgICBpZiAoIWVsKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBjdXJyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgaWYgKGN1cnJlbnRTdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgdGhpcy5jc3MoJ3Bvc2l0aW9uJywgJ3JlbGF0aXZlJyk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuICAgIGNvbnN0IHRvcERpZmZlcmVuY2UgPSBjb29yZGluYXRlcy50b3AgLSBjdXJyZW50T2Zmc2V0LnRvcDtcbiAgICBjb25zdCBsZWZ0RGlmZmVyZW5jZSA9IGNvb3JkaW5hdGVzLmxlZnQgLSBjdXJyZW50T2Zmc2V0LmxlZnQ7XG4gICAgdGhpcy5jc3Moe1xuICAgICAgICB0b3A6IChwYXJzZUZsb2F0KGN1cnJlbnRTdHlsZS50b3ApIHx8IDApICsgdG9wRGlmZmVyZW5jZSArICdweCcsXG4gICAgICAgIGxlZnQ6IChwYXJzZUZsb2F0KGN1cnJlbnRTdHlsZS5sZWZ0KSB8fCAwKSArIGxlZnREaWZmZXJlbmNlICsgJ3B4J1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/methods.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/props.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/props.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst propertySetters = {\n    outerWidth: 'offsetWidth',\n    outerHeight: 'offsetHeight',\n    innerWidth: 'clientWidth',\n    innerHeight: 'clientHeight',\n    scrollLeft: 'scrollLeft',\n    scrollTop: 'scrollTop',\n    val: 'value',\n    text: 'textContent',\n};\n\nconst propertiesMap = {\n    disabled: 'disabled',\n    value: 'value',\n    text: 'textContent',\n};\n\nfunction prop(name, value) {\n    if (!name) throw new Error('no property provided');\n    if (arguments.length === 1) {\n        const [el] = this;\n        if (!el) return null;\n        return el[name];\n    }\n    if (value === undefined) return this;\n    for (let i = 0; i < this.length; i++) {\n        this[i][name] = value;\n    }\n    return this;\n}\n\nfunction attr(name, value) {\n    let attributes;\n    if (typeof name === 'string') {\n        if (value === undefined) {\n            const [el] = this;\n            if (!el) return null;\n            return el.getAttribute(name);\n        } else {\n            attributes = { [name]: value };\n        }\n    } else if (!name) {\n        throw new Error('no attributes provided');\n    } else {\n        attributes = name;\n    }\n    for (let attr in attributes) {\n        if (attributes.hasOwnProperty(attr)) {\n            const value = attributes[attr];\n            if (propertiesMap[attr]) {\n                this.prop(propertiesMap[attr], value);\n                continue;\n            }\n            for (let i = 0; i < this.length; i++) {\n                if (value === null) {\n                    this[i].removeAttribute(attr);\n                } else {\n                    this[i].setAttribute(attr, value);\n                }\n            }\n        }\n    }\n    return this;\n}\n\nconst methods = {\n    prop,\n    attr\n};\n\nObject.keys(propertySetters).forEach(methodName => {\n    methods[methodName] = function(...args) {\n        return this.prop(propertySetters[methodName], ...args);\n    };\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (methods);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9wcm9wcy5tanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsK0RBQWUsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS9wcm9wcy5tanM/MGRkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcm9wZXJ0eVNldHRlcnMgPSB7XG4gICAgb3V0ZXJXaWR0aDogJ29mZnNldFdpZHRoJyxcbiAgICBvdXRlckhlaWdodDogJ29mZnNldEhlaWdodCcsXG4gICAgaW5uZXJXaWR0aDogJ2NsaWVudFdpZHRoJyxcbiAgICBpbm5lckhlaWdodDogJ2NsaWVudEhlaWdodCcsXG4gICAgc2Nyb2xsTGVmdDogJ3Njcm9sbExlZnQnLFxuICAgIHNjcm9sbFRvcDogJ3Njcm9sbFRvcCcsXG4gICAgdmFsOiAndmFsdWUnLFxuICAgIHRleHQ6ICd0ZXh0Q29udGVudCcsXG59O1xuXG5jb25zdCBwcm9wZXJ0aWVzTWFwID0ge1xuICAgIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICAgIHZhbHVlOiAndmFsdWUnLFxuICAgIHRleHQ6ICd0ZXh0Q29udGVudCcsXG59O1xuXG5mdW5jdGlvbiBwcm9wKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ25vIHByb3BlcnR5IHByb3ZpZGVkJyk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgW2VsXSA9IHRoaXM7XG4gICAgICAgIGlmICghZWwpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gZWxbbmFtZV07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpc1tpXVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIGxldCBhdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IFtlbF0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFlbCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IHsgW25hbWVdOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghbmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGF0dHJpYnV0ZXMgcHJvdmlkZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzID0gbmFtZTtcbiAgICB9XG4gICAgZm9yIChsZXQgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgICAgICBpZiAocHJvcGVydGllc01hcFthdHRyXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcChwcm9wZXJ0aWVzTWFwW2F0dHJdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXS5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuY29uc3QgbWV0aG9kcyA9IHtcbiAgICBwcm9wLFxuICAgIGF0dHJcbn07XG5cbk9iamVjdC5rZXlzKHByb3BlcnR5U2V0dGVycykuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wKHByb3BlcnR5U2V0dGVyc1ttZXRob2ROYW1lXSwgLi4uYXJncyk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXRob2RzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/props.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Dom/vars.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dataPriv: function() { return /* binding */ dataPriv; },\n/* harmony export */   dataUser: function() { return /* binding */ dataUser; }\n/* harmony export */ });\n/* harmony import */ var _Data_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Data.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Data.mjs\");\n\n\nconst dataPriv = new _Data_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\nconst dataUser = new _Data_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS92YXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0I7O0FBRXhCLHFCQUFxQixpREFBSTs7QUFFekIscUJBQXFCLGlEQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0RvbS92YXJzLm1qcz80NDExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEYXRhIGZyb20gJy4uL0RhdGEubWpzJztcblxuZXhwb3J0IGNvbnN0IGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxuZXhwb3J0IGNvbnN0IGRhdGFVc2VyID0gbmV3IERhdGEoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/vars.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Events.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Events: function() { return /* binding */ Events; }\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n// Events\n// ---------------\n\n// A module that can be mixed in to *any object* in order to provide it with\n// a custom event channel. You may bind a callback to an event with `on` or\n// remove with `off`; `trigger`-ing an event fires all callbacks in\n// succession.\n//\n//     const object = {};\n//     assign(object, Events);\n//     object.on('expand', function(){ alert('expanded'); });\n//     object.trigger('expand');\n//\nvar Events = {};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// A private global variable to share between listeners and listenees.\nvar _listening;\n\n// Iterates over the standard `event, callback` (as well as the fancy multiple\n// space-separated events `\"change blur\", callback` and jQuery-style event\n// maps `{event: callback}`).\nvar eventsApi = function(iteratee, events, name, callback, opts) {\n    var i = 0, names;\n    if (name && typeof name === 'object') {\n    // Handle event maps.\n        if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;\n        for (names = Object.keys(name); i < names.length ; i++) {\n            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);\n        }\n    } else if (name && eventSplitter.test(name)) {\n    // Handle space-separated event names by delegating them individually.\n        for (names = name.split(eventSplitter); i < names.length; i++) {\n            events = iteratee(events, names[i], callback, opts);\n        }\n    } else {\n    // Finally, standard events.\n        events = iteratee(events, name, callback, opts);\n    }\n    return events;\n};\n\n// Bind an event to a `callback` function. Passing `\"all\"` will bind\n// the callback to all events fired.\nEvents.on = function(name, callback, context) {\n    this._events = eventsApi(onApi, this._events || {}, name, callback, {\n        context: context,\n        ctx: this,\n        listening: _listening\n    });\n\n    if (_listening) {\n        var listeners = this._listeners || (this._listeners = {});\n        listeners[_listening.id] = _listening;\n        // Allow the listening to use a counter, instead of tracking\n        // callbacks for library interop\n        _listening.interop = false;\n    }\n\n    return this;\n};\n\n// Inversion-of-control versions of `on`. Tell *this* object to listen to\n// an event in another object... keeping track of what it's listening to\n// for easier unbinding later.\nEvents.listenTo = function(obj, name, callback) {\n    if (!obj) return this;\n    var id = obj._listenId || (obj._listenId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('l'));\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var listening = _listening = listeningTo[id];\n\n    // This object is not listening to any other events on `obj` yet.\n    // Setup the necessary references to track the listening callbacks.\n    if (!listening) {\n        this._listenId || (this._listenId = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('l'));\n        listening = _listening = listeningTo[id] = new Listening(this, obj);\n    }\n\n    // Bind callbacks on obj.\n    var error = tryCatchOn(obj, name, callback, this);\n    _listening = void 0;\n\n    if (error) throw error;\n    // If the target obj is not Events, track events manually.\n    if (listening.interop) listening.on(name, callback);\n\n    return this;\n};\n\n// The reducing API that adds a callback to the `events` object.\nvar onApi = function(events, name, callback, options) {\n    if (callback) {\n        var handlers = events[name] || (events[name] = []);\n        var context = options.context, ctx = options.ctx, listening = options.listening;\n        if (listening) listening.count++;\n\n        handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });\n    }\n    return events;\n};\n\n// An try-catch guarded #on function, to prevent poisoning the global\n// `_listening` variable.\nvar tryCatchOn = function(obj, name, callback, context) {\n    try {\n        obj.on(name, callback, context);\n    } catch (e) {\n        return e;\n    }\n};\n\n// Remove one or many callbacks. If `context` is null, removes all\n// callbacks with that function. If `callback` is null, removes all\n// callbacks for the event. If `name` is null, removes all bound\n// callbacks for all events.\nEvents.off = function(name, callback, context) {\n    if (!this._events) return this;\n    this._events = eventsApi(offApi, this._events, name, callback, {\n        context: context,\n        listeners: this._listeners\n    });\n\n    return this;\n};\n\n// Tell this object to stop listening to either specific events ... or\n// to every object it's currently listening to.\nEvents.stopListening = function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n\n    var ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n    for (var i = 0; i < ids.length; i++) {\n        var listening = listeningTo[ids[i]];\n\n        // If listening doesn't exist, this object is not currently\n        // listening to obj. Break out early.\n        if (!listening) break;\n\n        listening.obj.off(name, callback, this);\n        if (listening.interop) listening.off(name, callback);\n    }\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(listeningTo)) this._listeningTo = void 0;\n\n    return this;\n};\n\n// The reducing API that removes a callback from the `events` object.\nvar offApi = function(events, name, callback, options) {\n    if (!events) return;\n\n    var context = options.context, listeners = options.listeners;\n    var i = 0, names;\n\n    // Delete all event listeners and \"drop\" events.\n    if (!name && !context && !callback) {\n        if(listeners != null) {\n            for (names = Object.keys(listeners); i < names.length; i++) {\n                listeners[names[i]].cleanup();\n            }\n        }\n        return;\n    }\n    names = name ? [name] : Object.keys(events);\n    for (; i < names.length; i++) {\n        name = names[i];\n        var handlers = events[name];\n\n        // Bail out if there are no events stored.\n        if (!handlers) break;\n\n        // Find any remaining events.\n        var remaining = [];\n        for (var j = 0; j < handlers.length; j++) {\n            var handler = handlers[j];\n            if (\n                callback && callback !== handler.callback &&\n        callback !== handler.callback._callback ||\n          context && context !== handler.context\n            ) {\n                remaining.push(handler);\n            } else {\n                var listening = handler.listening;\n                if (listening) listening.off(name, callback);\n            }\n        }\n\n        // Replace events if there are any remaining.  Otherwise, clean up.\n        if (remaining.length) {\n            events[name] = remaining;\n        } else {\n            delete events[name];\n        }\n    }\n\n    return events;\n};\n\n// Bind an event to only be triggered a single time. After the first time\n// the callback is invoked, its listener will be removed. If multiple events\n// are passed in using the space-separated syntax, the handler will fire\n// once for each event, not once for a combination of all events.\nEvents.once = function(name, callback, context) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));\n    if (typeof name === 'string' && context == null) callback = void 0;\n    return this.on(events, callback, context);\n};\n\n// Inversion-of-control versions of `once`.\nEvents.listenToOnce = function(obj, name, callback) {\n// Map the event into a `{event: once}` object.\n    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));\n    return this.listenTo(obj, events);\n};\n\n// Reduces the event callbacks into a map of `{event: onceWrapper}`.\n// `offer` unbinds the `onceWrapper` after it has been called.\nvar onceMap = function(map, name, callback, offer) {\n    if (callback) {\n        var once = map[name] = onceInvoke(function() {\n            offer(name, once);\n            callback.apply(this, arguments);\n        });\n        once._callback = callback;\n    }\n    return map;\n};\n\n// Creates a function that is restricted to invoking 'func' once.\n// Repeat calls to the function return the value of the first invocation.\nvar onceInvoke = function(func) {\n    var result;\n    if (typeof func != 'function') {\n        throw new TypeError('Expected a function');\n    }\n    var n = 2;\n    return function() {\n        if (--n > 0) {\n            result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n            func = undefined;\n        }\n        return result;\n    };\n};\n\n// Trigger one or many events, firing all bound callbacks. Callbacks are\n// passed the same arguments as `trigger` is, apart from the event name\n// (unless you're listening on `\"all\"`, which will cause your callback to\n// receive the true name of the event as the first argument).\nEvents.trigger = function(name) {\n    if (!this._events) return this;\n\n    var length = Math.max(0, arguments.length - 1);\n    var args = Array(length);\n    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];\n\n    eventsApi(triggerApi, this._events, name, void 0, args);\n    return this;\n};\n\n// Handles triggering the appropriate event callbacks.\nvar triggerApi = function(objEvents, name, callback, args) {\n    if (objEvents) {\n        var events = objEvents[name];\n        var allEvents = objEvents.all;\n        if (events && allEvents) allEvents = allEvents.slice();\n        if (events) triggerEvents(events, args);\n        if (allEvents) triggerEvents(allEvents, [name].concat(args));\n    }\n    return objEvents;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\n// events have 3 arguments).\nvar triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n        case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n        case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n        case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n        case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n        default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n};\n\n// A listening class that tracks and cleans up memory bindings\n// when all callbacks have been offed.\nvar Listening = function(listener, obj) {\n    this.id = listener._listenId;\n    this.listener = listener;\n    this.obj = obj;\n    this.interop = true;\n    this.count = 0;\n    this._events = void 0;\n};\n\nListening.prototype.on = Events.on;\n\n// Offs a callback (or several).\n// Uses an optimized counter if the listenee uses Events.\n// Otherwise, falls back to manual tracking to support events\n// library interop.\nListening.prototype.off = function(name, callback) {\n    var cleanup;\n    if (this.interop) {\n        this._events = eventsApi(offApi, this._events, name, callback, {\n            context: void 0,\n            listeners: void 0\n        });\n        cleanup = !this._events;\n    } else {\n        this.count--;\n        cleanup = this.count === 0;\n    }\n    if (cleanup) this.cleanup();\n};\n\n// Cleans up memory bindings between the listener and the listenee.\nListening.prototype.cleanup = function() {\n    delete this.listener._listeningTo[this.obj._listenId];\n    if (!this.interop) delete this.obj._listeners[this.id];\n};\n\n// Aliases for backwards compatibility.\nEvents.bind   = Events.on;\nEvents.unbind = Events.off;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0V2ZW50cy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFHMEI7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHdEQUFRO0FBQ3ZELGtFQUFrRTtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQVE7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpRkFBaUY7QUFDekc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBTzs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUEsK0NBQStDLG1CQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUsZ0ZBQWdGO0FBQ2hGLG9GQUFvRjtBQUNwRixnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0V2ZW50cy5tanM/NzI1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGlzRW1wdHksXG4gICAgdW5pcXVlSWQgXG59IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuXG4vLyBFdmVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byAqYW55IG9iamVjdCogaW4gb3JkZXIgdG8gcHJvdmlkZSBpdCB3aXRoXG4vLyBhIGN1c3RvbSBldmVudCBjaGFubmVsLiBZb3UgbWF5IGJpbmQgYSBjYWxsYmFjayB0byBhbiBldmVudCB3aXRoIGBvbmAgb3Jcbi8vIHJlbW92ZSB3aXRoIGBvZmZgOyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cbi8vIHN1Y2Nlc3Npb24uXG4vL1xuLy8gICAgIGNvbnN0IG9iamVjdCA9IHt9O1xuLy8gICAgIGFzc2lnbihvYmplY3QsIEV2ZW50cyk7XG4vLyAgICAgb2JqZWN0Lm9uKCdleHBhbmQnLCBmdW5jdGlvbigpeyBhbGVydCgnZXhwYW5kZWQnKTsgfSk7XG4vLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xuLy9cbmV4cG9ydCB2YXIgRXZlbnRzID0ge307XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG52YXIgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuLy8gQSBwcml2YXRlIGdsb2JhbCB2YXJpYWJsZSB0byBzaGFyZSBiZXR3ZWVuIGxpc3RlbmVycyBhbmQgbGlzdGVuZWVzLlxudmFyIF9saXN0ZW5pbmc7XG5cbi8vIEl0ZXJhdGVzIG92ZXIgdGhlIHN0YW5kYXJkIGBldmVudCwgY2FsbGJhY2tgIChhcyB3ZWxsIGFzIHRoZSBmYW5jeSBtdWx0aXBsZVxuLy8gc3BhY2Utc2VwYXJhdGVkIGV2ZW50cyBgXCJjaGFuZ2UgYmx1clwiLCBjYWxsYmFja2AgYW5kIGpRdWVyeS1zdHlsZSBldmVudFxuLy8gbWFwcyBge2V2ZW50OiBjYWxsYmFja31gKS5cbnZhciBldmVudHNBcGkgPSBmdW5jdGlvbihpdGVyYXRlZSwgZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciBpID0gMCwgbmFtZXM7XG4gICAgaWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gSGFuZGxlIGV2ZW50IG1hcHMuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gdm9pZCAwICYmICdjb250ZXh0JyBpbiBvcHRzICYmIG9wdHMuY29udGV4dCA9PT0gdm9pZCAwKSBvcHRzLmNvbnRleHQgPSBjYWxsYmFjaztcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKG5hbWUpOyBpIDwgbmFtZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHNBcGkoaXRlcmF0ZWUsIGV2ZW50cywgbmFtZXNbaV0sIG5hbWVbbmFtZXNbaV1dLCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAmJiBldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcbiAgICAvLyBIYW5kbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzIGJ5IGRlbGVnYXRpbmcgdGhlbSBpbmRpdmlkdWFsbHkuXG4gICAgICAgIGZvciAobmFtZXMgPSBuYW1lLnNwbGl0KGV2ZW50U3BsaXR0ZXIpOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IGl0ZXJhdGVlKGV2ZW50cywgbmFtZXNbaV0sIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgLy8gRmluYWxseSwgc3RhbmRhcmQgZXZlbnRzLlxuICAgICAgICBldmVudHMgPSBpdGVyYXRlZShldmVudHMsIG5hbWUsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbn07XG5cbi8vIEJpbmQgYW4gZXZlbnQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmRcbi8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuRXZlbnRzLm9uID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBldmVudHNBcGkob25BcGksIHRoaXMuX2V2ZW50cyB8fCB7fSwgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgY3R4OiB0aGlzLFxuICAgICAgICBsaXN0ZW5pbmc6IF9saXN0ZW5pbmdcbiAgICB9KTtcblxuICAgIGlmIChfbGlzdGVuaW5nKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgICAgbGlzdGVuZXJzW19saXN0ZW5pbmcuaWRdID0gX2xpc3RlbmluZztcbiAgICAgICAgLy8gQWxsb3cgdGhlIGxpc3RlbmluZyB0byB1c2UgYSBjb3VudGVyLCBpbnN0ZWFkIG9mIHRyYWNraW5nXG4gICAgICAgIC8vIGNhbGxiYWNrcyBmb3IgbGlicmFyeSBpbnRlcm9wXG4gICAgICAgIF9saXN0ZW5pbmcuaW50ZXJvcCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gSW52ZXJzaW9uLW9mLWNvbnRyb2wgdmVyc2lvbnMgb2YgYG9uYC4gVGVsbCAqdGhpcyogb2JqZWN0IHRvIGxpc3RlbiB0b1xuLy8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3MgbGlzdGVuaW5nIHRvXG4vLyBmb3IgZWFzaWVyIHVuYmluZGluZyBsYXRlci5cbkV2ZW50cy5saXN0ZW5UbyA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIHRoaXM7XG4gICAgdmFyIGlkID0gb2JqLl9saXN0ZW5JZCB8fCAob2JqLl9saXN0ZW5JZCA9IHVuaXF1ZUlkKCdsJykpO1xuICAgIHZhciBsaXN0ZW5pbmdUbyA9IHRoaXMuX2xpc3RlbmluZ1RvIHx8ICh0aGlzLl9saXN0ZW5pbmdUbyA9IHt9KTtcbiAgICB2YXIgbGlzdGVuaW5nID0gX2xpc3RlbmluZyA9IGxpc3RlbmluZ1RvW2lkXTtcblxuICAgIC8vIFRoaXMgb2JqZWN0IGlzIG5vdCBsaXN0ZW5pbmcgdG8gYW55IG90aGVyIGV2ZW50cyBvbiBgb2JqYCB5ZXQuXG4gICAgLy8gU2V0dXAgdGhlIG5lY2Vzc2FyeSByZWZlcmVuY2VzIHRvIHRyYWNrIHRoZSBsaXN0ZW5pbmcgY2FsbGJhY2tzLlxuICAgIGlmICghbGlzdGVuaW5nKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbklkIHx8ICh0aGlzLl9saXN0ZW5JZCA9IHVuaXF1ZUlkKCdsJykpO1xuICAgICAgICBsaXN0ZW5pbmcgPSBfbGlzdGVuaW5nID0gbGlzdGVuaW5nVG9baWRdID0gbmV3IExpc3RlbmluZyh0aGlzLCBvYmopO1xuICAgIH1cblxuICAgIC8vIEJpbmQgY2FsbGJhY2tzIG9uIG9iai5cbiAgICB2YXIgZXJyb3IgPSB0cnlDYXRjaE9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xuICAgIF9saXN0ZW5pbmcgPSB2b2lkIDA7XG5cbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIC8vIElmIHRoZSB0YXJnZXQgb2JqIGlzIG5vdCBFdmVudHMsIHRyYWNrIGV2ZW50cyBtYW51YWxseS5cbiAgICBpZiAobGlzdGVuaW5nLmludGVyb3ApIGxpc3RlbmluZy5vbihuYW1lLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoZSByZWR1Y2luZyBBUEkgdGhhdCBhZGRzIGEgY2FsbGJhY2sgdG8gdGhlIGBldmVudHNgIG9iamVjdC5cbnZhciBvbkFwaSA9IGZ1bmN0aW9uKGV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdIHx8IChldmVudHNbbmFtZV0gPSBbXSk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0LCBjdHggPSBvcHRpb25zLmN0eCwgbGlzdGVuaW5nID0gb3B0aW9ucy5saXN0ZW5pbmc7XG4gICAgICAgIGlmIChsaXN0ZW5pbmcpIGxpc3RlbmluZy5jb3VudCsrO1xuXG4gICAgICAgIGhhbmRsZXJzLnB1c2goeyBjYWxsYmFjazogY2FsbGJhY2ssIGNvbnRleHQ6IGNvbnRleHQsIGN0eDogY29udGV4dCB8fCBjdHgsIGxpc3RlbmluZzogbGlzdGVuaW5nIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xufTtcblxuLy8gQW4gdHJ5LWNhdGNoIGd1YXJkZWQgI29uIGZ1bmN0aW9uLCB0byBwcmV2ZW50IHBvaXNvbmluZyB0aGUgZ2xvYmFsXG4vLyBgX2xpc3RlbmluZ2AgdmFyaWFibGUuXG52YXIgdHJ5Q2F0Y2hPbiA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICBvYmoub24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxufTtcblxuLy8gUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4vLyBjYWxsYmFja3Mgd2l0aCB0aGF0IGZ1bmN0aW9uLiBJZiBgY2FsbGJhY2tgIGlzIG51bGwsIHJlbW92ZXMgYWxsXG4vLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4vLyBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG5FdmVudHMub2ZmID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzQXBpKG9mZkFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywge1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBsaXN0ZW5lcnM6IHRoaXMuX2xpc3RlbmVyc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4vLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxuRXZlbnRzLnN0b3BMaXN0ZW5pbmcgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3RlbmluZ1RvID0gdGhpcy5fbGlzdGVuaW5nVG87XG4gICAgaWYgKCFsaXN0ZW5pbmdUbykgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgaWRzID0gb2JqID8gW29iai5fbGlzdGVuSWRdIDogT2JqZWN0LmtleXMobGlzdGVuaW5nVG8pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaXN0ZW5pbmcgPSBsaXN0ZW5pbmdUb1tpZHNbaV1dO1xuXG4gICAgICAgIC8vIElmIGxpc3RlbmluZyBkb2Vzbid0IGV4aXN0LCB0aGlzIG9iamVjdCBpcyBub3QgY3VycmVudGx5XG4gICAgICAgIC8vIGxpc3RlbmluZyB0byBvYmouIEJyZWFrIG91dCBlYXJseS5cbiAgICAgICAgaWYgKCFsaXN0ZW5pbmcpIGJyZWFrO1xuXG4gICAgICAgIGxpc3RlbmluZy5vYmoub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGxpc3RlbmluZy5pbnRlcm9wKSBsaXN0ZW5pbmcub2ZmKG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKGlzRW1wdHkobGlzdGVuaW5nVG8pKSB0aGlzLl9saXN0ZW5pbmdUbyA9IHZvaWQgMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGhlIHJlZHVjaW5nIEFQSSB0aGF0IHJlbW92ZXMgYSBjYWxsYmFjayBmcm9tIHRoZSBgZXZlbnRzYCBvYmplY3QuXG52YXIgb2ZmQXBpID0gZnVuY3Rpb24oZXZlbnRzLCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmICghZXZlbnRzKSByZXR1cm47XG5cbiAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCwgbGlzdGVuZXJzID0gb3B0aW9ucy5saXN0ZW5lcnM7XG4gICAgdmFyIGkgPSAwLCBuYW1lcztcblxuICAgIC8vIERlbGV0ZSBhbGwgZXZlbnQgbGlzdGVuZXJzIGFuZCBcImRyb3BcIiBldmVudHMuXG4gICAgaWYgKCFuYW1lICYmICFjb250ZXh0ICYmICFjYWxsYmFjaykge1xuICAgICAgICBpZihsaXN0ZW5lcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGxpc3RlbmVycyk7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tuYW1lc1tpXV0uY2xlYW51cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHRoZXJlIGFyZSBubyBldmVudHMgc3RvcmVkLlxuICAgICAgICBpZiAoIWhhbmRsZXJzKSBicmVhaztcblxuICAgICAgICAvLyBGaW5kIGFueSByZW1haW5pbmcgZXZlbnRzLlxuICAgICAgICB2YXIgcmVtYWluaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNbal07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2sgJiZcbiAgICAgICAgY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2suX2NhbGxiYWNrIHx8XG4gICAgICAgICAgY29udGV4dCAmJiBjb250ZXh0ICE9PSBoYW5kbGVyLmNvbnRleHRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuaW5nID0gaGFuZGxlci5saXN0ZW5pbmc7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmluZykgbGlzdGVuaW5nLm9mZihuYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXBsYWNlIGV2ZW50cyBpZiB0aGVyZSBhcmUgYW55IHJlbWFpbmluZy4gIE90aGVyd2lzZSwgY2xlYW4gdXAuXG4gICAgICAgIGlmIChyZW1haW5pbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBldmVudHNbbmFtZV0gPSByZW1haW5pbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50cztcbn07XG5cbi8vIEJpbmQgYW4gZXZlbnQgdG8gb25seSBiZSB0cmlnZ2VyZWQgYSBzaW5nbGUgdGltZS4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWVcbi8vIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkLCBpdHMgbGlzdGVuZXIgd2lsbCBiZSByZW1vdmVkLiBJZiBtdWx0aXBsZSBldmVudHNcbi8vIGFyZSBwYXNzZWQgaW4gdXNpbmcgdGhlIHNwYWNlLXNlcGFyYXRlZCBzeW50YXgsIHRoZSBoYW5kbGVyIHdpbGwgZmlyZVxuLy8gb25jZSBmb3IgZWFjaCBldmVudCwgbm90IG9uY2UgZm9yIGEgY29tYmluYXRpb24gb2YgYWxsIGV2ZW50cy5cbkV2ZW50cy5vbmNlID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbi8vIE1hcCB0aGUgZXZlbnQgaW50byBhIGB7ZXZlbnQ6IG9uY2V9YCBvYmplY3QuXG4gICAgdmFyIGV2ZW50cyA9IGV2ZW50c0FwaShvbmNlTWFwLCB7fSwgbmFtZSwgY2FsbGJhY2ssIHRoaXMub2ZmLmJpbmQodGhpcykpO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgY29udGV4dCA9PSBudWxsKSBjYWxsYmFjayA9IHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudHMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbn07XG5cbi8vIEludmVyc2lvbi1vZi1jb250cm9sIHZlcnNpb25zIG9mIGBvbmNlYC5cbkV2ZW50cy5saXN0ZW5Ub09uY2UgPSBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4vLyBNYXAgdGhlIGV2ZW50IGludG8gYSBge2V2ZW50OiBvbmNlfWAgb2JqZWN0LlxuICAgIHZhciBldmVudHMgPSBldmVudHNBcGkob25jZU1hcCwge30sIG5hbWUsIGNhbGxiYWNrLCB0aGlzLnN0b3BMaXN0ZW5pbmcuYmluZCh0aGlzLCBvYmopKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5UbyhvYmosIGV2ZW50cyk7XG59O1xuXG4vLyBSZWR1Y2VzIHRoZSBldmVudCBjYWxsYmFja3MgaW50byBhIG1hcCBvZiBge2V2ZW50OiBvbmNlV3JhcHBlcn1gLlxuLy8gYG9mZmVyYCB1bmJpbmRzIHRoZSBgb25jZVdyYXBwZXJgIGFmdGVyIGl0IGhhcyBiZWVuIGNhbGxlZC5cbnZhciBvbmNlTWFwID0gZnVuY3Rpb24obWFwLCBuYW1lLCBjYWxsYmFjaywgb2ZmZXIpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9uY2UgPSBtYXBbbmFtZV0gPSBvbmNlSW52b2tlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgb2ZmZXIobmFtZSwgb25jZSk7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn07XG5cbi8vIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgJ2Z1bmMnIG9uY2UuXG4vLyBSZXBlYXQgY2FsbHMgdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uXG52YXIgb25jZUludm9rZSA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIG4gPSAyO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn07XG5cbi8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcbi8vICh1bmxlc3MgeW91J3JlIGxpc3RlbmluZyBvbiBgXCJhbGxcImAsIHdoaWNoIHdpbGwgY2F1c2UgeW91ciBjYWxsYmFjayB0b1xuLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuRXZlbnRzLnRyaWdnZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KDAsIGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG5cbiAgICBldmVudHNBcGkodHJpZ2dlckFwaSwgdGhpcy5fZXZlbnRzLCBuYW1lLCB2b2lkIDAsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLy8gSGFuZGxlcyB0cmlnZ2VyaW5nIHRoZSBhcHByb3ByaWF0ZSBldmVudCBjYWxsYmFja3MuXG52YXIgdHJpZ2dlckFwaSA9IGZ1bmN0aW9uKG9iakV2ZW50cywgbmFtZSwgY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICBpZiAob2JqRXZlbnRzKSB7XG4gICAgICAgIHZhciBldmVudHMgPSBvYmpFdmVudHNbbmFtZV07XG4gICAgICAgIHZhciBhbGxFdmVudHMgPSBvYmpFdmVudHMuYWxsO1xuICAgICAgICBpZiAoZXZlbnRzICYmIGFsbEV2ZW50cykgYWxsRXZlbnRzID0gYWxsRXZlbnRzLnNsaWNlKCk7XG4gICAgICAgIGlmIChldmVudHMpIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcbiAgICAgICAgaWYgKGFsbEV2ZW50cykgdHJpZ2dlckV2ZW50cyhhbGxFdmVudHMsIFtuYW1lXS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqRXZlbnRzO1xufTtcblxuLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3Jcbi8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbi8vIGV2ZW50cyBoYXZlIDMgYXJndW1lbnRzKS5cbnZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIGV2LCBpID0gLTEsIGwgPSBldmVudHMubGVuZ3RoLCBhMSA9IGFyZ3NbMF0sIGEyID0gYXJnc1sxXSwgYTMgPSBhcmdzWzJdO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCk7IHJldHVybjtcbiAgICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICAgIGNhc2UgMjogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMik7IHJldHVybjtcbiAgICAgICAgY2FzZSAzOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEsIGEyLCBhMyk7IHJldHVybjtcbiAgICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTsgcmV0dXJuO1xuICAgIH1cbn07XG5cbi8vIEEgbGlzdGVuaW5nIGNsYXNzIHRoYXQgdHJhY2tzIGFuZCBjbGVhbnMgdXAgbWVtb3J5IGJpbmRpbmdzXG4vLyB3aGVuIGFsbCBjYWxsYmFja3MgaGF2ZSBiZWVuIG9mZmVkLlxudmFyIExpc3RlbmluZyA9IGZ1bmN0aW9uKGxpc3RlbmVyLCBvYmopIHtcbiAgICB0aGlzLmlkID0gbGlzdGVuZXIuX2xpc3RlbklkO1xuICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB0aGlzLm9iaiA9IG9iajtcbiAgICB0aGlzLmludGVyb3AgPSB0cnVlO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuX2V2ZW50cyA9IHZvaWQgMDtcbn07XG5cbkxpc3RlbmluZy5wcm90b3R5cGUub24gPSBFdmVudHMub247XG5cbi8vIE9mZnMgYSBjYWxsYmFjayAob3Igc2V2ZXJhbCkuXG4vLyBVc2VzIGFuIG9wdGltaXplZCBjb3VudGVyIGlmIHRoZSBsaXN0ZW5lZSB1c2VzIEV2ZW50cy5cbi8vIE90aGVyd2lzZSwgZmFsbHMgYmFjayB0byBtYW51YWwgdHJhY2tpbmcgdG8gc3VwcG9ydCBldmVudHNcbi8vIGxpYnJhcnkgaW50ZXJvcC5cbkxpc3RlbmluZy5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2xlYW51cDtcbiAgICBpZiAodGhpcy5pbnRlcm9wKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IGV2ZW50c0FwaShvZmZBcGksIHRoaXMuX2V2ZW50cywgbmFtZSwgY2FsbGJhY2ssIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGxpc3RlbmVyczogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhbnVwID0gIXRoaXMuX2V2ZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50LS07XG4gICAgICAgIGNsZWFudXAgPSB0aGlzLmNvdW50ID09PSAwO1xuICAgIH1cbiAgICBpZiAoY2xlYW51cCkgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vLyBDbGVhbnMgdXAgbWVtb3J5IGJpbmRpbmdzIGJldHdlZW4gdGhlIGxpc3RlbmVyIGFuZCB0aGUgbGlzdGVuZWUuXG5MaXN0ZW5pbmcucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5saXN0ZW5lci5fbGlzdGVuaW5nVG9bdGhpcy5vYmouX2xpc3RlbklkXTtcbiAgICBpZiAoIXRoaXMuaW50ZXJvcCkgZGVsZXRlIHRoaXMub2JqLl9saXN0ZW5lcnNbdGhpcy5pZF07XG59O1xuXG4vLyBBbGlhc2VzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbkV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XG5FdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Listener.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Listener.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Listener: function() { return /* binding */ Listener; }\n/* harmony export */ });\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Events.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n\n\nclass Listener {\n    constructor(...callbackArguments) {\n        this.callbackArguments = callbackArguments;\n    }\n\n    listenTo(object, evt, ...args) {\n        const { callbackArguments } = this;\n        // signature 1 - (object, eventHashMap, context)\n        if (evt && typeof evt === 'object') {\n            const [context = null] = args;\n            Object.entries(evt).forEach(([eventName, cb]) => {\n                if (typeof cb !== 'function') return;\n                // Invoke the callback with callbackArguments passed first\n                if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n                _Events_mjs__WEBPACK_IMPORTED_MODULE_0__.Events.listenTo.call(this, object, eventName, cb);\n            });\n        }\n        // signature 2 - (object, event, callback, context)\n        else if (typeof evt === 'string' && typeof args[0] === 'function') {\n            let [cb, context = null] = args;\n            // Invoke the callback with callbackArguments passed first\n            if (context || callbackArguments.length > 0) cb = cb.bind(context, ...callbackArguments);\n            _Events_mjs__WEBPACK_IMPORTED_MODULE_0__.Events.listenTo.call(this, object, evt, cb);\n        }\n    }\n\n    stopListening() {\n        _Events_mjs__WEBPACK_IMPORTED_MODULE_0__.Events.stopListening.call(this);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL0xpc3RlbmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFzQzs7QUFFL0I7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFNO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtDQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLCtDQUFNO0FBQ2Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9MaXN0ZW5lci5tanM/NGIyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL0V2ZW50cy5tanMnO1xuXG5leHBvcnQgY2xhc3MgTGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKC4uLmNhbGxiYWNrQXJndW1lbnRzKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBjYWxsYmFja0FyZ3VtZW50cztcbiAgICB9XG5cbiAgICBsaXN0ZW5UbyhvYmplY3QsIGV2dCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrQXJndW1lbnRzIH0gPSB0aGlzO1xuICAgICAgICAvLyBzaWduYXR1cmUgMSAtIChvYmplY3QsIGV2ZW50SGFzaE1hcCwgY29udGV4dClcbiAgICAgICAgaWYgKGV2dCAmJiB0eXBlb2YgZXZ0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgW2NvbnRleHQgPSBudWxsXSA9IGFyZ3M7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhldnQpLmZvckVhY2goKFtldmVudE5hbWUsIGNiXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggY2FsbGJhY2tBcmd1bWVudHMgcGFzc2VkIGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgfHwgY2FsbGJhY2tBcmd1bWVudHMubGVuZ3RoID4gMCkgY2IgPSBjYi5iaW5kKGNvbnRleHQsIC4uLmNhbGxiYWNrQXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBFdmVudHMubGlzdGVuVG8uY2FsbCh0aGlzLCBvYmplY3QsIGV2ZW50TmFtZSwgY2IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2lnbmF0dXJlIDIgLSAob2JqZWN0LCBldmVudCwgY2FsbGJhY2ssIGNvbnRleHQpXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBldnQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsZXQgW2NiLCBjb250ZXh0ID0gbnVsbF0gPSBhcmdzO1xuICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGNhbGxiYWNrQXJndW1lbnRzIHBhc3NlZCBmaXJzdFxuICAgICAgICAgICAgaWYgKGNvbnRleHQgfHwgY2FsbGJhY2tBcmd1bWVudHMubGVuZ3RoID4gMCkgY2IgPSBjYi5iaW5kKGNvbnRleHQsIC4uLmNhbGxiYWNrQXJndW1lbnRzKTtcbiAgICAgICAgICAgIEV2ZW50cy5saXN0ZW5Uby5jYWxsKHRoaXMsIG9iamVjdCwgZXZ0LCBjYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wTGlzdGVuaW5nKCkge1xuICAgICAgICBFdmVudHMuc3RvcExpc3RlbmluZy5jYWxsKHRoaXMpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Listener.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/Model.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/Model.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Model: function() { return /* binding */ Model; }\n/* harmony export */ });\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mvcUtils.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n// Model\n// --------------\n\n// **Models** are the basic data object in the framework --\n// frequently representing a row in a table in a database on your server.\n// A discrete chunk of data and a bunch of useful, related methods for\n// performing computations and transformations on that data.\n\n// Create a new model with the specified attributes. A client id (`cid`)\n// is automatically generated and assigned for you.\n\nvar Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.preinitialize.apply(this, arguments);\n    this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)(this.cidPrefix);\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    var attributeDefaults = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'defaults');\n\n    // Just _.defaults would work fine, but the additional _.extends\n    // is in there for historical reasons. See #3843.\n    attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.defaults)((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, attributeDefaults, attrs), attributeDefaults);\n\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n};\n\n// Attach all inheritable methods to the Model prototype.\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(Model.prototype, _Events_mjs__WEBPACK_IMPORTED_MODULE_1__.Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // The prefix is used to create the client id which is used to identify models locally.\n    // You may want to override this if you're experiencing name clashes with model ids.\n    cidPrefix: 'c',\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the Model.\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this.attributes);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n        return this.attributes[attr];\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n        return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n        if (key == null) return this;\n\n        // Handle both `\"key\", value` and `{key: value}` -style arguments.\n        var attrs;\n        if (typeof key === 'object') {\n            attrs = key;\n            options = val;\n        } else {\n            (attrs = {})[key] = val;\n        }\n\n        options || (options = {});\n\n        // Run validation.\n        if (!this._validate(attrs, options)) return false;\n\n        // Extract attributes and options.\n        var unset      = options.unset;\n        var silent     = options.silent;\n        var changes    = [];\n        var changing   = this._changing;\n        this._changing = true;\n\n        if (!changing) {\n            this._previousAttributes = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this.attributes);\n            this.changed = {};\n        }\n\n        var current = this.attributes;\n        var changed = this.changed;\n        var prev    = this._previousAttributes;\n\n        // For each `set` attribute, update or delete the current value.\n        for (var attr in attrs) {\n            val = attrs[attr];\n            if (!(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(current[attr], val)) changes.push(attr);\n            if (!(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(prev[attr], val)) {\n                changed[attr] = val;\n            } else {\n                delete changed[attr];\n            }\n            unset ? delete current[attr] : current[attr] = val;\n        }\n\n        // Update the `id`.\n        if (this.idAttribute in attrs) {\n            var prevId = this.id;\n            this.id = this.get(this.idAttribute);\n            this.trigger('changeId', this, prevId, options);\n        }\n\n        // Trigger all relevant attribute changes.\n        if (!silent) {\n            if (changes.length) this._pending = options;\n            for (var i = 0; i < changes.length; i++) {\n                this.trigger('change:' + changes[i], this, current[changes[i]], options);\n            }\n        }\n\n        // You might be wondering why there's a `while` loop here. Changes can\n        // be recursively nested within `\"change\"` events.\n        if (changing) return this;\n        if (!silent) {\n            while (this._pending) {\n                options = this._pending;\n                this._pending = false;\n                this.trigger('change', this, options);\n            }\n        }\n        this._pending = false;\n        this._changing = false;\n        return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n        return this.set(attr, void 0, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, { unset: true }));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n        var attrs = {};\n        for (var key in this.attributes) attrs[key] = void 0;\n        return this.set(attrs, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, { unset: true }));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n        if (attr == null) return !(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(this.changed);\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.has)(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n        if (!diff) return this.hasChanged() ? (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this.changed) : false;\n        var old = this._changing ? this._previousAttributes : this.attributes;\n        var changed = {};\n        var hasChanged;\n        for (var attr in diff) {\n            var val = diff[attr];\n            if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEqual)(old[attr], val)) continue;\n            changed[attr] = val;\n            hasChanged = true;\n        }\n        return hasChanged ? changed : false;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n        if (attr == null || !this._previousAttributes) return null;\n        return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n        return (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.clone)(this._previousAttributes);\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n        return new this.constructor(this.attributes);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n        return this._validate({}, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, options, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n        if (!options.validate || !this.validate) return true;\n        attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, this.attributes, attrs);\n        var error = this.validationError = this.validate(attrs, options) || null;\n        if (!error) return true;\n        this.trigger('invalid', this, error, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(options, { validationError: error }));\n        return false;\n    }\n\n});\n\n// Set up inheritance for the model.\nModel.extend = _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_2__.extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL01vZGVsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNDO0FBQ0U7QUFVZDs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxlQUFlLHdEQUFRO0FBQ3ZCO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQU07O0FBRWxDO0FBQ0E7QUFDQSxZQUFZLHdEQUFRLENBQUMsc0RBQU0sR0FBRzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBTSxrQkFBa0IsK0NBQU07O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUscURBQUs7QUFDcEIsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1QjtBQUN2Qjs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHFEQUFLO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBTztBQUN4QixpQkFBaUIsdURBQU87QUFDeEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0RBQU0sR0FBRyxhQUFhLGFBQWE7QUFDekUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBTSxHQUFHLGFBQWEsYUFBYTtBQUNsRSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1REFBTztBQUN6QyxlQUFlLG1EQUFHO0FBQ2xCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMscURBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBSztBQUNwQixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGdDQUFnQyxFQUFFLHNEQUFNLEdBQUcsYUFBYSxnQkFBZ0I7QUFDeEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTSxHQUFHO0FBQ3pCO0FBQ0E7QUFDQSw2Q0FBNkMsc0RBQU0sWUFBWSx3QkFBd0I7QUFDdkY7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0EsZUFBZSxpREFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9Nb2RlbC5tanM/NTU3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudHMgfSBmcm9tICcuL0V2ZW50cy5tanMnO1xuaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAnLi9tdmNVdGlscy5tanMnO1xuaW1wb3J0IHtcbiAgICBhc3NpZ24sXG4gICAgY2xvbmUsXG4gICAgZGVmYXVsdHMsXG4gICAgaGFzLFxuICAgIGlzRXF1YWwsXG4gICAgaXNFbXB0eSxcbiAgICByZXN1bHQsXG4gICAgdW5pcXVlSWRcbn0gZnJvbSAnLi4vdXRpbC91dGlsLm1qcyc7XG5cbi8vIE1vZGVsXG4vLyAtLS0tLS0tLS0tLS0tLVxuXG4vLyAqKk1vZGVscyoqIGFyZSB0aGUgYmFzaWMgZGF0YSBvYmplY3QgaW4gdGhlIGZyYW1ld29yayAtLVxuLy8gZnJlcXVlbnRseSByZXByZXNlbnRpbmcgYSByb3cgaW4gYSB0YWJsZSBpbiBhIGRhdGFiYXNlIG9uIHlvdXIgc2VydmVyLlxuLy8gQSBkaXNjcmV0ZSBjaHVuayBvZiBkYXRhIGFuZCBhIGJ1bmNoIG9mIHVzZWZ1bCwgcmVsYXRlZCBtZXRob2RzIGZvclxuLy8gcGVyZm9ybWluZyBjb21wdXRhdGlvbnMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGF0IGRhdGEuXG5cbi8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxuLy8gaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGZvciB5b3UuXG5cbmV4cG9ydCB2YXIgTW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuY2lkID0gdW5pcXVlSWQodGhpcy5jaWRQcmVmaXgpO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3Rpb24pIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICB2YXIgYXR0cmlidXRlRGVmYXVsdHMgPSByZXN1bHQodGhpcywgJ2RlZmF1bHRzJyk7XG5cbiAgICAvLyBKdXN0IF8uZGVmYXVsdHMgd291bGQgd29yayBmaW5lLCBidXQgdGhlIGFkZGl0aW9uYWwgXy5leHRlbmRzXG4gICAgLy8gaXMgaW4gdGhlcmUgZm9yIGhpc3RvcmljYWwgcmVhc29ucy4gU2VlICMzODQzLlxuICAgIGF0dHJzID0gZGVmYXVsdHMoYXNzaWduKHt9LCBhdHRyaWJ1dGVEZWZhdWx0cywgYXR0cnMpLCBhdHRyaWJ1dGVEZWZhdWx0cyk7XG5cbiAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XG4gICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBBdHRhY2ggYWxsIGluaGVyaXRhYmxlIG1ldGhvZHMgdG8gdGhlIE1vZGVsIHByb3RvdHlwZS5cbmFzc2lnbihNb2RlbC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxuICAgIGNoYW5nZWQ6IG51bGwsXG5cbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgIHZhbGlkYXRpb25FcnJvcjogbnVsbCxcblxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxuICAgIC8vIENvdWNoREIgdXNlcnMgbWF5IHdhbnQgdG8gc2V0IHRoaXMgdG8gYFwiX2lkXCJgLlxuICAgIGlkQXR0cmlidXRlOiAnaWQnLFxuXG4gICAgLy8gVGhlIHByZWZpeCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY2xpZW50IGlkIHdoaWNoIGlzIHVzZWQgdG8gaWRlbnRpZnkgbW9kZWxzIGxvY2FsbHkuXG4gICAgLy8gWW91IG1heSB3YW50IHRvIG92ZXJyaWRlIHRoaXMgaWYgeW91J3JlIGV4cGVyaWVuY2luZyBuYW1lIGNsYXNoZXMgd2l0aCBtb2RlbCBpZHMuXG4gICAgY2lkUHJlZml4OiAnYycsXG5cbiAgICAvLyBwcmVpbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIFlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCBhIGZ1bmN0aW9uXG4gICAgLy8gb3Igb2JqZWN0LiAgcHJlaW5pdGlhbGl6ZSB3aWxsIHJ1biBiZWZvcmUgYW55IGluc3RhbnRpYXRpb24gbG9naWMgaXMgcnVuIGluIHRoZSBNb2RlbC5cbiAgICBwcmVpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBObyBpbXBsZW1lbnRhdGlvbi5cbiAgICB9LFxuXG4gICAgLy8gSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gTm8gaW1wbGVtZW50YXRpb24uXG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG1vZGVsJ3MgYGF0dHJpYnV0ZXNgIG9iamVjdC5cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuICAgIGdldDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIGNvbnRhaW5zIGEgdmFsdWUgdGhhdCBpcyBub3QgbnVsbFxuICAgIC8vIG9yIHVuZGVmaW5lZC5cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcyBvbiB0aGUgb2JqZWN0LCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBUaGlzIGlzXG4gICAgLy8gdGhlIGNvcmUgcHJpbWl0aXZlIG9wZXJhdGlvbiBvZiBhIG1vZGVsLCB1cGRhdGluZyB0aGUgZGF0YSBhbmQgbm90aWZ5aW5nXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIC8vIEhhbmRsZSBib3RoIGBcImtleVwiLCB2YWx1ZWAgYW5kIGB7a2V5OiB2YWx1ZX1gIC1zdHlsZSBhcmd1bWVudHMuXG4gICAgICAgIHZhciBhdHRycztcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhdHRycyA9IGtleTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBhdHRyaWJ1dGVzIGFuZCBvcHRpb25zLlxuICAgICAgICB2YXIgdW5zZXQgICAgICA9IG9wdGlvbnMudW5zZXQ7XG4gICAgICAgIHZhciBzaWxlbnQgICAgID0gb3B0aW9ucy5zaWxlbnQ7XG4gICAgICAgIHZhciBjaGFuZ2VzICAgID0gW107XG4gICAgICAgIHZhciBjaGFuZ2luZyAgID0gdGhpcy5fY2hhbmdpbmc7XG4gICAgICAgIHRoaXMuX2NoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWNoYW5naW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgPSBjbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIGNoYW5nZWQgPSB0aGlzLmNoYW5nZWQ7XG4gICAgICAgIHZhciBwcmV2ICAgID0gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO1xuXG4gICAgICAgIC8vIEZvciBlYWNoIGBzZXRgIGF0dHJpYnV0ZSwgdXBkYXRlIG9yIGRlbGV0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgICAgICAgdmFsID0gYXR0cnNbYXR0cl07XG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwoY3VycmVudFthdHRyXSwgdmFsKSkgY2hhbmdlcy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgaWYgKCFpc0VxdWFsKHByZXZbYXR0cl0sIHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkW2F0dHJdID0gdmFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2hhbmdlZFthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuc2V0ID8gZGVsZXRlIGN1cnJlbnRbYXR0cl0gOiBjdXJyZW50W2F0dHJdID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBgaWRgLlxuICAgICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykge1xuICAgICAgICAgICAgdmFyIHByZXZJZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5nZXQodGhpcy5pZEF0dHJpYnV0ZSk7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZUlkJywgdGhpcywgcHJldklkLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaWdnZXIgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gb3B0aW9ucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBjaGFuZ2VzW2ldLCB0aGlzLCBjdXJyZW50W2NoYW5nZXNbaV1dLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFlvdSBtaWdodCBiZSB3b25kZXJpbmcgd2h5IHRoZXJlJ3MgYSBgd2hpbGVgIGxvb3AgaGVyZS4gQ2hhbmdlcyBjYW5cbiAgICAgICAgLy8gYmUgcmVjdXJzaXZlbHkgbmVzdGVkIHdpdGhpbiBgXCJjaGFuZ2VcImAgZXZlbnRzLlxuICAgICAgICBpZiAoY2hhbmdpbmcpIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5fcGVuZGluZztcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxuICAgIC8vIGlmIHRoZSBhdHRyaWJ1dGUgZG9lc24ndCBleGlzdC5cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0ciwgdm9pZCAwLCBhc3NpZ24oe30sIG9wdGlvbnMsIHsgdW5zZXQ6IHRydWUgfSkpO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhciBhbGwgYXR0cmlidXRlcyBvbiB0aGUgbW9kZWwsIGZpcmluZyBgXCJjaGFuZ2VcImAuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChhdHRycywgYXNzaWduKHt9LCBvcHRpb25zLCB7IHVuc2V0OiB0cnVlIH0pKTtcbiAgICB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgLy8gSWYgeW91IHNwZWNpZnkgYW4gYXR0cmlidXRlIG5hbWUsIGRldGVybWluZSBpZiB0aGF0IGF0dHJpYnV0ZSBoYXMgY2hhbmdlZC5cbiAgICBoYXNDaGFuZ2VkOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgIGlmIChhdHRyID09IG51bGwpIHJldHVybiAhaXNFbXB0eSh0aGlzLmNoYW5nZWQpO1xuICAgICAgICByZXR1cm4gaGFzKHRoaXMuY2hhbmdlZCwgYXR0cik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCBoYXZlIGNoYW5nZWQsIG9yXG4gICAgLy8gZmFsc2UgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZWQgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0XG4gICAgLy8gcGFydHMgb2YgYSB2aWV3IG5lZWQgdG8gYmUgdXBkYXRlZCBhbmQvb3Igd2hhdCBhdHRyaWJ1dGVzIG5lZWQgdG8gYmVcbiAgICAvLyBwZXJzaXN0ZWQgdG8gdGhlIHNlcnZlci4gVW5zZXQgYXR0cmlidXRlcyB3aWxsIGJlIHNldCB0byB1bmRlZmluZWQuXG4gICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gYXR0cmlidXRlcyBvYmplY3QgdG8gZGlmZiBhZ2FpbnN0IHRoZSBtb2RlbCxcbiAgICAvLyBkZXRlcm1pbmluZyBpZiB0aGVyZSAqd291bGQgYmUqIGEgY2hhbmdlLlxuICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiBmdW5jdGlvbihkaWZmKSB7XG4gICAgICAgIGlmICghZGlmZikgcmV0dXJuIHRoaXMuaGFzQ2hhbmdlZCgpID8gY2xvbmUodGhpcy5jaGFuZ2VkKSA6IGZhbHNlO1xuICAgICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICAgIHZhciBoYXNDaGFuZ2VkO1xuICAgICAgICBmb3IgKHZhciBhdHRyIGluIGRpZmYpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkaWZmW2F0dHJdO1xuICAgICAgICAgICAgaWYgKGlzRXF1YWwob2xkW2F0dHJdLCB2YWwpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNoYW5nZWRbYXR0cl0gPSB2YWw7XG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IGNoYW5nZWQgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUsIHJlY29yZGVkIGF0IHRoZSB0aW1lIHRoZSBsYXN0XG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBpZiAoYXR0ciA9PSBudWxsIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBtb2RlbCBhdCB0aGUgdGltZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBgXCJjaGFuZ2VcImAgZXZlbnQuXG4gICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIHRoZSBtb2RlbCBpcyBjdXJyZW50bHkgaW4gYSB2YWxpZCBzdGF0ZS5cbiAgICBpc1ZhbGlkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZSh7fSwgYXNzaWduKHt9LCBvcHRpb25zLCB7IHZhbGlkYXRlOiB0cnVlIH0pKTtcbiAgICB9LFxuXG4gICAgLy8gUnVuIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgbmV4dCBjb21wbGV0ZSBzZXQgb2YgbW9kZWwgYXR0cmlidXRlcyxcbiAgICAvLyByZXR1cm5pbmcgYHRydWVgIGlmIGFsbCBpcyB3ZWxsLiBPdGhlcndpc2UsIGZpcmUgYW4gYFwiaW52YWxpZFwiYCBldmVudC5cbiAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGF0dHJzID0gYXNzaWduKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJzKTtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSB8fCBudWxsO1xuICAgICAgICBpZiAoIWVycm9yKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgZXJyb3IsIGFzc2lnbihvcHRpb25zLCB7IHZhbGlkYXRpb25FcnJvcjogZXJyb3IgfSkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KTtcblxuLy8gU2V0IHVwIGluaGVyaXRhbmNlIGZvciB0aGUgbW9kZWwuXG5Nb2RlbC5leHRlbmQgPSBleHRlbmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/Model.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/View.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   View: function() { return /* binding */ View; },\n/* harmony export */   views: function() { return /* binding */ views; }\n/* harmony export */ });\n/* harmony import */ var _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewBase.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\");\n\n\n\n\n\n\nconst views = {};\n\nconst View = _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.extend({\n\n    options: {},\n    theme: null,\n    themeClassNamePrefix: _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix('theme-'),\n    requireSetThemeOverride: false,\n    defaultTheme: _config_index_mjs__WEBPACK_IMPORTED_MODULE_2__.config.defaultTheme,\n    children: null,\n    childNodes: null,\n\n    DETACHABLE: true,\n    UPDATE_PRIORITY: 2,\n    FLAG_INSERT: 1<<30,\n    FLAG_REMOVE: 1<<29,\n    FLAG_INIT: 1<<28,\n\n    constructor: function(options) {\n\n        this.requireSetThemeOverride = options && !!options.theme;\n        this.options = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, this.options, options);\n\n        _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.call(this, options);\n    },\n\n    initialize: function() {\n\n        views[this.cid] = this;\n\n        this.setTheme(this.options.theme || this.defaultTheme);\n        this.init();\n    },\n\n    unmount: function() {\n        if (this.svgElement) {\n            this.vel.remove();\n        } else {\n            this.$el.remove();\n        }\n    },\n\n    isMounted: function() {\n        return this.el.parentNode !== null;\n    },\n\n    renderChildren: function(children) {\n        children || (children = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'children'));\n        if (children) {\n            var isSVG = this.svgElement;\n            var namespace = _V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].namespace[isSVG ? 'svg' : 'xhtml'];\n            var doc = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.parseDOMJSON(children, namespace);\n            (isSVG ? this.vel : this.$el).empty().append(doc.fragment);\n            this.childNodes = doc.selectors;\n        }\n        return this;\n    },\n\n    findAttributeNode: function(attributeName, node) {\n        let currentNode = node;\n        while (currentNode && currentNode.nodeType === 1) {\n            // attribute found\n            // (empty value does not count as attribute found)\n            if (currentNode.getAttribute(attributeName)) return currentNode;\n            // do not climb up the DOM\n            if (currentNode === this.el) return null;\n            // try parent node\n            currentNode = currentNode.parentNode;\n        }\n        return null;\n    },\n\n    findAttribute: function(attributeName, node) {\n        const matchedNode = this.findAttributeNode(attributeName, node);\n        return matchedNode && matchedNode.getAttribute(attributeName);\n    },\n\n    // Override the mvc ViewBase `_ensureElement()` method in order to create an\n    // svg element (e.g., `<g>`) node that wraps all the nodes of the Cell view.\n    // Expose class name setter as a separate method.\n    _ensureElement: function() {\n        if (!this.el) {\n            var tagName = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'tagName');\n            var attrs = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'attributes'));\n            var style = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'style'));\n            if (this.id) attrs.id = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'id');\n            this.setElement(this._createElement(tagName));\n            this._setAttributes(attrs);\n            this._setStyle(style);\n        } else {\n            this.setElement(_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'el'));\n        }\n        this._ensureElClassName();\n    },\n\n    _setAttributes: function(attrs) {\n        if (this.svgElement) {\n            this.vel.attr(attrs);\n        } else {\n            this.$el.attr(attrs);\n        }\n    },\n\n    _setStyle: function(style) {\n        this.$el.css(style);\n    },\n\n    _createElement: function(tagName) {\n        if (this.svgElement) {\n            return document.createElementNS(_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"].namespace.svg, tagName);\n        } else {\n            return document.createElement(tagName);\n        }\n    },\n\n    // Utilize an alternative DOM manipulation API by\n    // adding an element reference wrapped in Vectorizer.\n    _setElement: function(el) {\n        this.$el = el instanceof _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"] ? el : (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(el);\n        this.el = this.$el[0];\n        if (this.svgElement) this.vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this.el);\n    },\n\n    _ensureElClassName: function() {\n        var className = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'className');\n        if (!className) return;\n        var prefixedClassName = _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix(className);\n        // Note: className removal here kept for backwards compatibility only\n        if (this.svgElement) {\n            this.vel.removeClass(className).addClass(prefixedClassName);\n        } else {\n            this.$el.removeClass(className).addClass(prefixedClassName);\n        }\n    },\n\n    init: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    onRender: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    confirmUpdate: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n        return 0;\n    },\n\n    setTheme: function(theme, opt) {\n\n        opt = opt || {};\n\n        // Theme is already set, override is required, and override has not been set.\n        // Don't set the theme.\n        if (this.theme && this.requireSetThemeOverride && !opt.override) {\n            return this;\n        }\n\n        this.removeThemeClassName();\n        this.addThemeClassName(theme);\n        this.onSetTheme(this.theme/* oldTheme */, theme/* newTheme */);\n        this.theme = theme;\n\n        return this;\n    },\n\n    addThemeClassName: function(theme) {\n\n        theme = theme || this.theme;\n        if (!theme) return this;\n\n        var className = this.themeClassNamePrefix + theme;\n\n        if (this.svgElement) {\n            this.vel.addClass(className);\n        } else {\n            this.$el.addClass(className);\n        }\n\n        return this;\n    },\n\n    removeThemeClassName: function(theme) {\n\n        theme = theme || this.theme;\n\n        var className = this.themeClassNamePrefix + theme;\n\n        if (this.svgElement) {\n            this.vel.removeClass(className);\n        } else {\n            this.$el.removeClass(className);\n        }\n\n        return this;\n    },\n\n    onSetTheme: function(oldTheme, newTheme) {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    remove: function() {\n\n        this.onRemove();\n        this.undelegateDocumentEvents();\n\n        views[this.cid] = null;\n\n        _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.prototype.remove.apply(this, arguments);\n\n        return this;\n    },\n\n    onRemove: function() {\n        // Intentionally empty.\n        // This method is meant to be overridden.\n    },\n\n    getEventNamespace: function() {\n        // Returns a per-session unique namespace\n        return '.joint-event-ns-' + this.cid;\n    },\n\n    delegateElementEvents: function(element, events, data) {\n        if (!events) return this;\n        data || (data = {});\n        var eventNS = this.getEventNamespace();\n        for (var eventName in events) {\n            var method = events[eventName];\n            if (typeof method !== 'function') method = this[method];\n            if (!method) continue;\n            (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element).on(eventName + eventNS, data, method.bind(this));\n        }\n        return this;\n    },\n\n    undelegateElementEvents: function(element) {\n        (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element).off(this.getEventNamespace());\n        return this;\n    },\n\n    delegateDocumentEvents: function(events, data) {\n        events || (events = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.result(this, 'documentEvents'));\n        return this.delegateElementEvents(document, events, data);\n    },\n\n    undelegateDocumentEvents: function() {\n        return this.undelegateElementEvents(document);\n    },\n\n    eventData: function(evt, data) {\n        if (!evt) throw new Error('eventData(): event object required.');\n        var currentData = evt.data;\n        var key = '__' + this.cid + '__';\n        if (data === undefined) {\n            if (!currentData) return {};\n            return currentData[key] || {};\n        }\n        currentData || (currentData = evt.data = {});\n        currentData[key] || (currentData[key] = {});\n        _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign(currentData[key], data);\n        return this;\n    },\n\n    stopPropagation: function(evt) {\n        this.eventData(evt, { propagationStopped: true });\n        return this;\n    },\n\n    isPropagationStopped: function(evt) {\n        return !!this.eventData(evt).propagationStopped;\n    }\n\n}, {\n\n    extend: function() {\n\n        var args = Array.from(arguments);\n\n        // Deep clone the prototype and static properties objects.\n        // This prevents unexpected behavior where some properties are overwritten outside of this function.\n        var protoProps = args[0] && _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, args[0]) || {};\n        var staticProps = args[1] && _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, args[1]) || {};\n\n        // Need the real render method so that we can wrap it and call it later.\n        var renderFn = protoProps.render || (this.prototype && this.prototype.render) || null;\n\n        /*\n            Wrap the real render method so that:\n                .. `onRender` is always called.\n                .. `this` is always returned.\n        */\n        protoProps.render = function() {\n\n            if (typeof renderFn === 'function') {\n                // Call the original render method.\n                renderFn.apply(this, arguments);\n            }\n\n            if (this.render.__render__ === renderFn) {\n                // Should always call onRender() method.\n                // Should call it only once when renderFn is actual prototype method i.e. not the wrapper\n                this.onRender();\n            }\n\n            // Should always return itself.\n            return this;\n        };\n\n        protoProps.render.__render__ = renderFn;\n\n        return _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_0__.ViewBase.extend.call(this, protoProps, staticProps);\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL1ZpZXcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWdDO0FBQ1U7QUFDWDtBQUNXO0FBQ0c7O0FBRXRDOztBQUVBLGFBQWEsbURBQVE7O0FBRTVCLGVBQWU7QUFDZjtBQUNBLDBCQUEwQiwrREFBdUI7QUFDakQ7QUFDQSxrQkFBa0IscURBQU07QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLG1EQUFXLEdBQUc7O0FBRXJDLFFBQVEsbURBQVE7QUFDaEIsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxnQ0FBZ0MsbURBQVc7QUFDM0M7QUFDQTtBQUNBLDRCQUE0QixvREFBQztBQUM3QixzQkFBc0IseURBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtREFBVztBQUNyQyx3QkFBd0IsbURBQVcsR0FBRyxFQUFFLG1EQUFXO0FBQ25ELHdCQUF3QixtREFBVyxHQUFHLEVBQUUsbURBQVc7QUFDbkQsb0NBQW9DLG1EQUFXO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0QkFBNEIsbURBQVc7QUFDdkM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw0Q0FBNEMsb0RBQUM7QUFDN0MsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzREFBQyxRQUFRLDBEQUFDO0FBQzNDO0FBQ0Esd0NBQXdDLHdEQUFDO0FBQ3pDLEtBQUs7O0FBRUw7QUFDQSx3QkFBd0IsbURBQVc7QUFDbkM7QUFDQSxnQ0FBZ0MsK0RBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1EQUFROztBQUVoQjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQUM7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLFFBQVEsMERBQUM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSw0QkFBNEIsbURBQVc7QUFDdkM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsa0RBQWtEO0FBQ2xELFFBQVEsbURBQVc7QUFDbkI7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxtREFBVyxHQUFHO0FBQ2xELHFDQUFxQyxtREFBVyxHQUFHOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLG1EQUFRO0FBQ3ZCO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9WaWV3Lm1qcz8wYzY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkIGZyb20gJy4vRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcbmltcG9ydCB7IFZpZXdCYXNlIH0gZnJvbSAnLi9WaWV3QmFzZS5tanMnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2luZGV4Lm1qcyc7XG5cbmV4cG9ydCBjb25zdCB2aWV3cyA9IHt9O1xuXG5leHBvcnQgY29uc3QgVmlldyA9IFZpZXdCYXNlLmV4dGVuZCh7XG5cbiAgICBvcHRpb25zOiB7fSxcbiAgICB0aGVtZTogbnVsbCxcbiAgICB0aGVtZUNsYXNzTmFtZVByZWZpeDogdXRpbC5hZGRDbGFzc05hbWVQcmVmaXgoJ3RoZW1lLScpLFxuICAgIHJlcXVpcmVTZXRUaGVtZU92ZXJyaWRlOiBmYWxzZSxcbiAgICBkZWZhdWx0VGhlbWU6IGNvbmZpZy5kZWZhdWx0VGhlbWUsXG4gICAgY2hpbGRyZW46IG51bGwsXG4gICAgY2hpbGROb2RlczogbnVsbCxcblxuICAgIERFVEFDSEFCTEU6IHRydWUsXG4gICAgVVBEQVRFX1BSSU9SSVRZOiAyLFxuICAgIEZMQUdfSU5TRVJUOiAxPDwzMCxcbiAgICBGTEFHX1JFTU9WRTogMTw8MjksXG4gICAgRkxBR19JTklUOiAxPDwyOCxcblxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yZXF1aXJlU2V0VGhlbWVPdmVycmlkZSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnRoZW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB1dGlsLmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICBWaWV3QmFzZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2aWV3c1t0aGlzLmNpZF0gPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuc2V0VGhlbWUodGhpcy5vcHRpb25zLnRoZW1lIHx8IHRoaXMuZGVmYXVsdFRoZW1lKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfSxcblxuICAgIHVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnZlbC5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnBhcmVudE5vZGUgIT09IG51bGw7XG4gICAgfSxcblxuICAgIHJlbmRlckNoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgICBjaGlsZHJlbiB8fCAoY2hpbGRyZW4gPSB1dGlsLnJlc3VsdCh0aGlzLCAnY2hpbGRyZW4nKSk7XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgdmFyIGlzU1ZHID0gdGhpcy5zdmdFbGVtZW50O1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IFYubmFtZXNwYWNlW2lzU1ZHID8gJ3N2ZycgOiAneGh0bWwnXTtcbiAgICAgICAgICAgIHZhciBkb2MgPSB1dGlsLnBhcnNlRE9NSlNPTihjaGlsZHJlbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIChpc1NWRyA/IHRoaXMudmVsIDogdGhpcy4kZWwpLmVtcHR5KCkuYXBwZW5kKGRvYy5mcmFnbWVudCk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBkb2Muc2VsZWN0b3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmaW5kQXR0cmlidXRlTm9kZTogZnVuY3Rpb24oYXR0cmlidXRlTmFtZSwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBmb3VuZFxuICAgICAgICAgICAgLy8gKGVtcHR5IHZhbHVlIGRvZXMgbm90IGNvdW50IGFzIGF0dHJpYnV0ZSBmb3VuZClcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBjbGltYiB1cCB0aGUgRE9NXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgPT09IHRoaXMuZWwpIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gdHJ5IHBhcmVudCBub2RlXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIGZpbmRBdHRyaWJ1dGU6IGZ1bmN0aW9uKGF0dHJpYnV0ZU5hbWUsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZE5vZGUgPSB0aGlzLmZpbmRBdHRyaWJ1dGVOb2RlKGF0dHJpYnV0ZU5hbWUsIG5vZGUpO1xuICAgICAgICByZXR1cm4gbWF0Y2hlZE5vZGUgJiYgbWF0Y2hlZE5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH0sXG5cbiAgICAvLyBPdmVycmlkZSB0aGUgbXZjIFZpZXdCYXNlIGBfZW5zdXJlRWxlbWVudCgpYCBtZXRob2QgaW4gb3JkZXIgdG8gY3JlYXRlIGFuXG4gICAgLy8gc3ZnIGVsZW1lbnQgKGUuZy4sIGA8Zz5gKSBub2RlIHRoYXQgd3JhcHMgYWxsIHRoZSBub2RlcyBvZiB0aGUgQ2VsbCB2aWV3LlxuICAgIC8vIEV4cG9zZSBjbGFzcyBuYW1lIHNldHRlciBhcyBhIHNlcGFyYXRlIG1ldGhvZC5cbiAgICBfZW5zdXJlRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5lbCkge1xuICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSB1dGlsLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0gdXRpbC5hc3NpZ24oe30sIHV0aWwucmVzdWx0KHRoaXMsICdhdHRyaWJ1dGVzJykpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdXRpbC5hc3NpZ24oe30sIHV0aWwucmVzdWx0KHRoaXMsICdzdHlsZScpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IHV0aWwucmVzdWx0KHRoaXMsICdpZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFnTmFtZSkpO1xuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cmlidXRlcyhhdHRycyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEVsZW1lbnQodXRpbC5yZXN1bHQodGhpcywgJ2VsJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vuc3VyZUVsQ2xhc3NOYW1lKCk7XG4gICAgfSxcblxuICAgIF9zZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnZlbC5hdHRyKGF0dHJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLmF0dHIoYXR0cnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9zZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgdGhpcy4kZWwuY3NzKHN0eWxlKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhWLm5hbWVzcGFjZS5zdmcsIHRhZ05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVXRpbGl6ZSBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSSBieVxuICAgIC8vIGFkZGluZyBhbiBlbGVtZW50IHJlZmVyZW5jZSB3cmFwcGVkIGluIFZlY3Rvcml6ZXIuXG4gICAgX3NldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiAkID8gZWwgOiAkKGVsKTtcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB0aGlzLnZlbCA9IFYodGhpcy5lbCk7XG4gICAgfSxcblxuICAgIF9lbnN1cmVFbENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB1dGlsLnJlc3VsdCh0aGlzLCAnY2xhc3NOYW1lJyk7XG4gICAgICAgIGlmICghY2xhc3NOYW1lKSByZXR1cm47XG4gICAgICAgIHZhciBwcmVmaXhlZENsYXNzTmFtZSA9IHV0aWwuYWRkQ2xhc3NOYW1lUHJlZml4KGNsYXNzTmFtZSk7XG4gICAgICAgIC8vIE5vdGU6IGNsYXNzTmFtZSByZW1vdmFsIGhlcmUga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgb25seVxuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnZlbC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpLmFkZENsYXNzKHByZWZpeGVkQ2xhc3NOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSkuYWRkQ2xhc3MocHJlZml4ZWRDbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5LlxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuLlxuICAgIH0sXG5cbiAgICBvblJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZW1wdHkuXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4uXG4gICAgfSxcblxuICAgIGNvbmZpcm1VcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGVtcHR5LlxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuLlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgc2V0VGhlbWU6IGZ1bmN0aW9uKHRoZW1lLCBvcHQpIHtcblxuICAgICAgICBvcHQgPSBvcHQgfHwge307XG5cbiAgICAgICAgLy8gVGhlbWUgaXMgYWxyZWFkeSBzZXQsIG92ZXJyaWRlIGlzIHJlcXVpcmVkLCBhbmQgb3ZlcnJpZGUgaGFzIG5vdCBiZWVuIHNldC5cbiAgICAgICAgLy8gRG9uJ3Qgc2V0IHRoZSB0aGVtZS5cbiAgICAgICAgaWYgKHRoaXMudGhlbWUgJiYgdGhpcy5yZXF1aXJlU2V0VGhlbWVPdmVycmlkZSAmJiAhb3B0Lm92ZXJyaWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVtb3ZlVGhlbWVDbGFzc05hbWUoKTtcbiAgICAgICAgdGhpcy5hZGRUaGVtZUNsYXNzTmFtZSh0aGVtZSk7XG4gICAgICAgIHRoaXMub25TZXRUaGVtZSh0aGlzLnRoZW1lLyogb2xkVGhlbWUgKi8sIHRoZW1lLyogbmV3VGhlbWUgKi8pO1xuICAgICAgICB0aGlzLnRoZW1lID0gdGhlbWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZFRoZW1lQ2xhc3NOYW1lOiBmdW5jdGlvbih0aGVtZSkge1xuXG4gICAgICAgIHRoZW1lID0gdGhlbWUgfHwgdGhpcy50aGVtZTtcbiAgICAgICAgaWYgKCF0aGVtZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMudGhlbWVDbGFzc05hbWVQcmVmaXggKyB0aGVtZTtcblxuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnZlbC5hZGRDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW1vdmVUaGVtZUNsYXNzTmFtZTogZnVuY3Rpb24odGhlbWUpIHtcblxuICAgICAgICB0aGVtZSA9IHRoZW1lIHx8IHRoaXMudGhlbWU7XG5cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMudGhlbWVDbGFzc05hbWVQcmVmaXggKyB0aGVtZTtcblxuICAgICAgICBpZiAodGhpcy5zdmdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnZlbC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBvblNldFRoZW1lOiBmdW5jdGlvbihvbGRUaGVtZSwgbmV3VGhlbWUpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLm9uUmVtb3ZlKCk7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZURvY3VtZW50RXZlbnRzKCk7XG5cbiAgICAgICAgdmlld3NbdGhpcy5jaWRdID0gbnVsbDtcblxuICAgICAgICBWaWV3QmFzZS5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBlbXB0eS5cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAgICB9LFxuXG4gICAgZ2V0RXZlbnROYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBSZXR1cm5zIGEgcGVyLXNlc3Npb24gdW5pcXVlIG5hbWVzcGFjZVxuICAgICAgICByZXR1cm4gJy5qb2ludC1ldmVudC1ucy0nICsgdGhpcy5jaWQ7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlRWxlbWVudEV2ZW50czogZnVuY3Rpb24oZWxlbWVudCwgZXZlbnRzLCBkYXRhKSB7XG4gICAgICAgIGlmICghZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgICAgZGF0YSB8fCAoZGF0YSA9IHt9KTtcbiAgICAgICAgdmFyIGV2ZW50TlMgPSB0aGlzLmdldEV2ZW50TmFtZXNwYWNlKCk7XG4gICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBldmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSBtZXRob2QgPSB0aGlzW21ldGhvZF07XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkgY29udGludWU7XG4gICAgICAgICAgICAkKGVsZW1lbnQpLm9uKGV2ZW50TmFtZSArIGV2ZW50TlMsIGRhdGEsIG1ldGhvZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdW5kZWxlZ2F0ZUVsZW1lbnRFdmVudHM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgJChlbGVtZW50KS5vZmYodGhpcy5nZXRFdmVudE5hbWVzcGFjZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlRG9jdW1lbnRFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cywgZGF0YSkge1xuICAgICAgICBldmVudHMgfHwgKGV2ZW50cyA9IHV0aWwucmVzdWx0KHRoaXMsICdkb2N1bWVudEV2ZW50cycpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGVFbGVtZW50RXZlbnRzKGRvY3VtZW50LCBldmVudHMsIGRhdGEpO1xuICAgIH0sXG5cbiAgICB1bmRlbGVnYXRlRG9jdW1lbnRFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmRlbGVnYXRlRWxlbWVudEV2ZW50cyhkb2N1bWVudCk7XG4gICAgfSxcblxuICAgIGV2ZW50RGF0YTogZnVuY3Rpb24oZXZ0LCBkYXRhKSB7XG4gICAgICAgIGlmICghZXZ0KSB0aHJvdyBuZXcgRXJyb3IoJ2V2ZW50RGF0YSgpOiBldmVudCBvYmplY3QgcmVxdWlyZWQuJyk7XG4gICAgICAgIHZhciBjdXJyZW50RGF0YSA9IGV2dC5kYXRhO1xuICAgICAgICB2YXIga2V5ID0gJ19fJyArIHRoaXMuY2lkICsgJ19fJztcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50RGF0YSkgcmV0dXJuIHt9O1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRhW2tleV0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudERhdGEgfHwgKGN1cnJlbnREYXRhID0gZXZ0LmRhdGEgPSB7fSk7XG4gICAgICAgIGN1cnJlbnREYXRhW2tleV0gfHwgKGN1cnJlbnREYXRhW2tleV0gPSB7fSk7XG4gICAgICAgIHV0aWwuYXNzaWduKGN1cnJlbnREYXRhW2tleV0sIGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy5ldmVudERhdGEoZXZ0LCB7IHByb3BhZ2F0aW9uU3RvcHBlZDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5ldmVudERhdGEoZXZ0KS5wcm9wYWdhdGlvblN0b3BwZWQ7XG4gICAgfVxuXG59LCB7XG5cbiAgICBleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuXG4gICAgICAgIC8vIERlZXAgY2xvbmUgdGhlIHByb3RvdHlwZSBhbmQgc3RhdGljIHByb3BlcnRpZXMgb2JqZWN0cy5cbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyB1bmV4cGVjdGVkIGJlaGF2aW9yIHdoZXJlIHNvbWUgcHJvcGVydGllcyBhcmUgb3ZlcndyaXR0ZW4gb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgcHJvdG9Qcm9wcyA9IGFyZ3NbMF0gJiYgdXRpbC5hc3NpZ24oe30sIGFyZ3NbMF0pIHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGljUHJvcHMgPSBhcmdzWzFdICYmIHV0aWwuYXNzaWduKHt9LCBhcmdzWzFdKSB8fCB7fTtcblxuICAgICAgICAvLyBOZWVkIHRoZSByZWFsIHJlbmRlciBtZXRob2Qgc28gdGhhdCB3ZSBjYW4gd3JhcCBpdCBhbmQgY2FsbCBpdCBsYXRlci5cbiAgICAgICAgdmFyIHJlbmRlckZuID0gcHJvdG9Qcm9wcy5yZW5kZXIgfHwgKHRoaXMucHJvdG90eXBlICYmIHRoaXMucHJvdG90eXBlLnJlbmRlcikgfHwgbnVsbDtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgV3JhcCB0aGUgcmVhbCByZW5kZXIgbWV0aG9kIHNvIHRoYXQ6XG4gICAgICAgICAgICAgICAgLi4gYG9uUmVuZGVyYCBpcyBhbHdheXMgY2FsbGVkLlxuICAgICAgICAgICAgICAgIC4uIGB0aGlzYCBpcyBhbHdheXMgcmV0dXJuZWQuXG4gICAgICAgICovXG4gICAgICAgIHByb3RvUHJvcHMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVuZGVyRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCByZW5kZXIgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHJlbmRlckZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlci5fX3JlbmRlcl9fID09PSByZW5kZXJGbikge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBhbHdheXMgY2FsbCBvblJlbmRlcigpIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgY2FsbCBpdCBvbmx5IG9uY2Ugd2hlbiByZW5kZXJGbiBpcyBhY3R1YWwgcHJvdG90eXBlIG1ldGhvZCBpLmUuIG5vdCB0aGUgd3JhcHBlclxuICAgICAgICAgICAgICAgIHRoaXMub25SZW5kZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvdG9Qcm9wcy5yZW5kZXIuX19yZW5kZXJfXyA9IHJlbmRlckZuO1xuXG4gICAgICAgIHJldHVybiBWaWV3QmFzZS5leHRlbmQuY2FsbCh0aGlzLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcyk7XG4gICAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/ViewBase.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/ViewBase.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ViewBase: function() { return /* binding */ ViewBase; }\n/* harmony export */ });\n/* harmony import */ var _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Events.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mvcUtils.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\");\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n\n\n// ViewBase\n// -------------\n\n// ViewBases are almost more convention than they are actual code. A View\n// is simply a JavaScript object that represents a logical chunk of UI in the\n// DOM. This might be a single item, an entire list, a sidebar or panel, or\n// even the surrounding frame which wraps your whole app. Defining a chunk of\n// UI as a **View** allows you to define your DOM events declaratively, without\n// having to worry about render order ... and makes it easy for the view to\n// react to specific changes in the state of your models.\n\n// Creating a ViewBase creates its initial element outside of the DOM,\n// if an existing element is not provided...\nvar ViewBase = function(options) {\n    this.cid = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniqueId)('view');\n    this.preinitialize.apply(this, arguments);\n    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(this, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.pick)(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n};\n\n// Cached regex to split keys for `delegate`.\nvar delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n// List of view options to be set as properties.\n// TODO: `style` attribute is not supported in ViewBase class yet, but only in View class that extends ViewBase.\nvar viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events', 'style'];\n\n// Set up all inheritable **ViewBase** properties and methods.\n(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(ViewBase.prototype, _Events_mjs__WEBPACK_IMPORTED_MODULE_1__.Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // mvc.$ delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n        return this.$el.find(selector);\n    },\n\n    // preinitialize is an empty function by default. You can override it with a function\n    // or object.  preinitialize will run before any instantiation logic is run in the View\n    preinitialize: function(){\n        // No implementation.\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){\n        // No implementation.\n    },\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n        return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Events listeners.\n    remove: function() {\n        this._removeElement();\n        this.stopListening();\n        return this;\n    },\n\n    // Remove this view's element from the document and all event listeners\n    // attached to it. Exposed for subclasses using an alternative DOM\n    // manipulation API.\n    _removeElement: function() {\n        this.$el.remove();\n    },\n\n    // Change the view's element (`this.el` property) and re-delegate the\n    // view's events on the new element.\n    setElement: function(element) {\n        this.undelegateEvents();\n        this._setElement(element);\n        this.delegateEvents();\n        return this;\n    },\n\n    // Creates the `this.el` and `this.$el` references for this view using the\n    // given `el`. `el` can be a CSS selector or an HTML string, a mvc.$\n    // context or an element. Subclasses can override this to utilize an\n    // alternative DOM manipulation API and are only required to set the\n    // `this.el` property.\n    _setElement: function(el) {\n        this.$el = el instanceof _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"] ? el : (0,_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el);\n        this.el = this.$el[0];\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    delegateEvents: function(events) {\n        events || (events = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'events'));\n        if (!events) return this;\n        this.undelegateEvents();\n        for (var key in events) {\n            var method = events[key];\n            if (!(0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(method)) method = this[method];\n            if (!method) continue;\n            var match = key.match(delegateEventSplitter);\n            this.delegate(match[1], match[2], method.bind(this));\n        }\n        return this;\n    },\n\n    // Add a single event listener to the view's element (or a child element\n    // using `selector`). This only works for delegate-able events: not `focus`,\n    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.\n    delegate: function(eventName, selector, listener) {\n        this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);\n        return this;\n    },\n\n    // Clears all callbacks previously bound to the view by `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // viewbases attached to the same DOM element.\n    undelegateEvents: function() {\n        if (this.$el) this.$el.off('.delegateEvents' + this.cid);\n        return this;\n    },\n\n    // A finer-grained `undelegateEvents` for removing a single delegated event.\n    // `selector` and `listener` are both optional.\n    undelegate: function(eventName, selector, listener) {\n        this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);\n        return this;\n    },\n\n    // Produces a DOM element to be assigned to your view. Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _createElement: function(tagName) {\n        return document.createElement(tagName);\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n        if (!this.el) {\n            var attrs = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)({}, (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'attributes'));\n            if (this.id) attrs.id = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'id');\n            if (this.className) attrs['class'] = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'className');\n            this.setElement(this._createElement((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'tagName')));\n            this._setAttributes(attrs);\n        } else {\n            this.setElement((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.result)(this, 'el'));\n        }\n    },\n\n    // Set attributes from a hash on this view's element.  Exposed for\n    // subclasses using an alternative DOM manipulation API.\n    _setAttributes: function(attributes) {\n        this.$el.attr(attributes);\n    }\n\n});\n\n// Set up inheritance for the view.\nViewBase.extend = _mvcUtils_mjs__WEBPACK_IMPORTED_MODULE_3__.extend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL1ZpZXdCYXNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFnQzs7QUFFTTtBQUNFO0FBT2Q7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNPO0FBQ1AsZUFBZSx3REFBUTtBQUN2QjtBQUNBLElBQUksc0RBQU0sT0FBTyxvREFBSTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBTSxxQkFBcUIsK0NBQU07O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNEQUFDLFFBQVEsMERBQUM7QUFDM0M7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQU0sR0FBRyxFQUFFLHNEQUFNO0FBQ3pDLG9DQUFvQyxzREFBTTtBQUMxQyxpREFBaUQsc0RBQU07QUFDdkQsZ0RBQWdELHNEQUFNO0FBQ3REO0FBQ0EsVUFBVTtBQUNWLDRCQUE0QixzREFBTTtBQUNsQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCLGlEQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL1ZpZXdCYXNlLm1qcz9lZDhjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAkIGZyb20gJy4vRG9tL2luZGV4Lm1qcyc7XG5cbmltcG9ydCB7IEV2ZW50cyB9IGZyb20gJy4vRXZlbnRzLm1qcyc7XG5pbXBvcnQgeyBleHRlbmQgfSBmcm9tICcuL212Y1V0aWxzLm1qcyc7XG5pbXBvcnQge1xuICAgIGFzc2lnbixcbiAgICBpc0Z1bmN0aW9uLFxuICAgIHBpY2ssXG4gICAgcmVzdWx0LFxuICAgIHVuaXF1ZUlkXG59IGZyb20gJy4uL3V0aWwvdXRpbC5tanMnO1xuXG4vLyBWaWV3QmFzZVxuLy8gLS0tLS0tLS0tLS0tLVxuXG4vLyBWaWV3QmFzZXMgYXJlIGFsbW9zdCBtb3JlIGNvbnZlbnRpb24gdGhhbiB0aGV5IGFyZSBhY3R1YWwgY29kZS4gQSBWaWV3XG4vLyBpcyBzaW1wbHkgYSBKYXZhU2NyaXB0IG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBsb2dpY2FsIGNodW5rIG9mIFVJIGluIHRoZVxuLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXG4vLyBldmVuIHRoZSBzdXJyb3VuZGluZyBmcmFtZSB3aGljaCB3cmFwcyB5b3VyIHdob2xlIGFwcC4gRGVmaW5pbmcgYSBjaHVuayBvZlxuLy8gVUkgYXMgYSAqKlZpZXcqKiBhbGxvd3MgeW91IHRvIGRlZmluZSB5b3VyIERPTSBldmVudHMgZGVjbGFyYXRpdmVseSwgd2l0aG91dFxuLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXG4vLyByZWFjdCB0byBzcGVjaWZpYyBjaGFuZ2VzIGluIHRoZSBzdGF0ZSBvZiB5b3VyIG1vZGVscy5cblxuLy8gQ3JlYXRpbmcgYSBWaWV3QmFzZSBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxuLy8gaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbmV4cG9ydCB2YXIgVmlld0Jhc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jaWQgPSB1bmlxdWVJZCgndmlldycpO1xuICAgIHRoaXMucHJlaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGFzc2lnbih0aGlzLCBwaWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XG4gICAgdGhpcy5fZW5zdXJlRWxlbWVudCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLy8gQ2FjaGVkIHJlZ2V4IHRvIHNwbGl0IGtleXMgZm9yIGBkZWxlZ2F0ZWAuXG52YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4vLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBzZXQgYXMgcHJvcGVydGllcy5cbi8vIFRPRE86IGBzdHlsZWAgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmlld0Jhc2UgY2xhc3MgeWV0LCBidXQgb25seSBpbiBWaWV3IGNsYXNzIHRoYXQgZXh0ZW5kcyBWaWV3QmFzZS5cbnZhciB2aWV3T3B0aW9ucyA9IFsnbW9kZWwnLCAnY29sbGVjdGlvbicsICdlbCcsICdpZCcsICdhdHRyaWJ1dGVzJywgJ2NsYXNzTmFtZScsICd0YWdOYW1lJywgJ2V2ZW50cycsICdzdHlsZSddO1xuXG4vLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqVmlld0Jhc2UqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxuYXNzaWduKFZpZXdCYXNlLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvLyBtdmMuJCBkZWxlZ2F0ZSBmb3IgZWxlbWVudCBsb29rdXAsIHNjb3BlZCB0byBET00gZWxlbWVudHMgd2l0aGluIHRoZVxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5maW5kKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gcHJlaW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBZb3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggYSBmdW5jdGlvblxuICAgIC8vIG9yIG9iamVjdC4gIHByZWluaXRpYWxpemUgd2lsbCBydW4gYmVmb3JlIGFueSBpbnN0YW50aWF0aW9uIGxvZ2ljIGlzIHJ1biBpbiB0aGUgVmlld1xuICAgIHByZWluaXRpYWxpemU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIE5vIGltcGxlbWVudGF0aW9uLlxuICAgIH0sXG5cbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cbiAgICAvLyBpbml0aWFsaXphdGlvbiBsb2dpYy5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe1xuICAgICAgICAvLyBObyBpbXBsZW1lbnRhdGlvbi5cbiAgICB9LFxuXG4gICAgLy8gKipyZW5kZXIqKiBpcyB0aGUgY29yZSBmdW5jdGlvbiB0aGF0IHlvdXIgdmlldyBzaG91bGQgb3ZlcnJpZGUsIGluIG9yZGVyXG4gICAgLy8gdG8gcG9wdWxhdGUgaXRzIGVsZW1lbnQgKGB0aGlzLmVsYCksIHdpdGggdGhlIGFwcHJvcHJpYXRlIEhUTUwuIFRoZVxuICAgIC8vIGNvbnZlbnRpb24gaXMgZm9yICoqcmVuZGVyKiogdG8gYWx3YXlzIHJldHVybiBgdGhpc2AuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSB0aGlzIHZpZXcgYnkgdGFraW5nIHRoZSBlbGVtZW50IG91dCBvZiB0aGUgRE9NLCBhbmQgcmVtb3ZpbmcgYW55XG4gICAgLy8gYXBwbGljYWJsZSBFdmVudHMgbGlzdGVuZXJzLlxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgdGhpcyB2aWV3J3MgZWxlbWVudCBmcm9tIHRoZSBkb2N1bWVudCBhbmQgYWxsIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIGF0dGFjaGVkIHRvIGl0LiBFeHBvc2VkIGZvciBzdWJjbGFzc2VzIHVzaW5nIGFuIGFsdGVybmF0aXZlIERPTVxuICAgIC8vIG1hbmlwdWxhdGlvbiBBUEkuXG4gICAgX3JlbW92ZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSBhbmQgcmUtZGVsZWdhdGUgdGhlXG4gICAgLy8gdmlldydzIGV2ZW50cyBvbiB0aGUgbmV3IGVsZW1lbnQuXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlcyB0aGUgYHRoaXMuZWxgIGFuZCBgdGhpcy4kZWxgIHJlZmVyZW5jZXMgZm9yIHRoaXMgdmlldyB1c2luZyB0aGVcbiAgICAvLyBnaXZlbiBgZWxgLiBgZWxgIGNhbiBiZSBhIENTUyBzZWxlY3RvciBvciBhbiBIVE1MIHN0cmluZywgYSBtdmMuJFxuICAgIC8vIGNvbnRleHQgb3IgYW4gZWxlbWVudC4gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byB1dGlsaXplIGFuXG4gICAgLy8gYWx0ZXJuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiBBUEkgYW5kIGFyZSBvbmx5IHJlcXVpcmVkIHRvIHNldCB0aGVcbiAgICAvLyBgdGhpcy5lbGAgcHJvcGVydHkuXG4gICAgX3NldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHRoaXMuJGVsID0gZWwgaW5zdGFuY2VvZiAkID8gZWwgOiAkKGVsKTtcbiAgICAgICAgdGhpcy5lbCA9IHRoaXMuJGVsWzBdO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgY2FsbGJhY2tzLCB3aGVyZSBgdGhpcy5ldmVudHNgIGlzIGEgaGFzaCBvZlxuICAgIC8vXG4gICAgLy8gKntcImV2ZW50IHNlbGVjdG9yXCI6IFwiY2FsbGJhY2tcIn0qXG4gICAgLy9cbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICdtb3VzZWRvd24gLnRpdGxlJzogICdlZGl0JyxcbiAgICAvLyAgICAgICAnY2xpY2sgLmJ1dHRvbic6ICAgICAnc2F2ZScsXG4gICAgLy8gICAgICAgJ2NsaWNrIC5vcGVuJzogICAgICAgZnVuY3Rpb24oZSkgeyAuLi4gfVxuICAgIC8vICAgICB9XG4gICAgLy9cbiAgICAvLyBwYWlycy4gQ2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhlIHZpZXcsIHdpdGggYHRoaXNgIHNldCBwcm9wZXJseS5cbiAgICAvLyBVc2VzIGV2ZW50IGRlbGVnYXRpb24gZm9yIGVmZmljaWVuY3kuXG4gICAgLy8gT21pdHRpbmcgdGhlIHNlbGVjdG9yIGJpbmRzIHRoZSBldmVudCB0byBgdGhpcy5lbGAuXG4gICAgZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgICBldmVudHMgfHwgKGV2ZW50cyA9IHJlc3VsdCh0aGlzLCAnZXZlbnRzJykpO1xuICAgICAgICBpZiAoIWV2ZW50cykgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMudW5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2tleV07XG4gICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24obWV0aG9kKSkgbWV0aG9kID0gdGhpc1ttZXRob2RdO1xuICAgICAgICAgICAgaWYgKCFtZXRob2QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0ga2V5Lm1hdGNoKGRlbGVnYXRlRXZlbnRTcGxpdHRlcik7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlKG1hdGNoWzFdLCBtYXRjaFsyXSwgbWV0aG9kLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHZpZXcncyBlbGVtZW50IChvciBhIGNoaWxkIGVsZW1lbnRcbiAgICAvLyB1c2luZyBgc2VsZWN0b3JgKS4gVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsXG4gICAgLy8gYGJsdXJgLCBhbmQgbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuJGVsLm9uKGV2ZW50TmFtZSArICcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQsIHNlbGVjdG9yLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBDbGVhcnMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IGJvdW5kIHRvIHRoZSB2aWV3IGJ5IGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgLy8gWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgLy8gdmlld2Jhc2VzIGF0dGFjaGVkIHRvIHRoZSBzYW1lIERPTSBlbGVtZW50LlxuICAgIHVuZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy4kZWwpIHRoaXMuJGVsLm9mZignLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgZmluZXItZ3JhaW5lZCBgdW5kZWxlZ2F0ZUV2ZW50c2AgZm9yIHJlbW92aW5nIGEgc2luZ2xlIGRlbGVnYXRlZCBldmVudC5cbiAgICAvLyBgc2VsZWN0b3JgIGFuZCBgbGlzdGVuZXJgIGFyZSBib3RoIG9wdGlvbmFsLlxuICAgIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuJGVsLm9mZihldmVudE5hbWUgKyAnLmRlbGVnYXRlRXZlbnRzJyArIHRoaXMuY2lkLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJvZHVjZXMgYSBET00gZWxlbWVudCB0byBiZSBhc3NpZ25lZCB0byB5b3VyIHZpZXcuIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfY3JlYXRlRWxlbWVudDogZnVuY3Rpb24odGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICB9LFxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAgLy8gSWYgYHRoaXMuZWxgIGlzIGEgc3RyaW5nLCBwYXNzIGl0IHRocm91Z2ggYCQoKWAsIHRha2UgdGhlIGZpcnN0XG4gICAgLy8gbWF0Y2hpbmcgZWxlbWVudCwgYW5kIHJlLWFzc2lnbiBpdCB0byBgZWxgLiBPdGhlcndpc2UsIGNyZWF0ZVxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxuICAgIF9lbnN1cmVFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSBhc3NpZ24oe30sIHJlc3VsdCh0aGlzLCAnYXR0cmlidXRlcycpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkKSBhdHRycy5pZCA9IHJlc3VsdCh0aGlzLCAnaWQnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkgYXR0cnNbJ2NsYXNzJ10gPSByZXN1bHQodGhpcywgJ2NsYXNzTmFtZScpO1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHRoaXMuX2NyZWF0ZUVsZW1lbnQocmVzdWx0KHRoaXMsICd0YWdOYW1lJykpKTtcbiAgICAgICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50KHJlc3VsdCh0aGlzLCAnZWwnKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgZnJvbSBhIGhhc2ggb24gdGhpcyB2aWV3J3MgZWxlbWVudC4gIEV4cG9zZWQgZm9yXG4gICAgLy8gc3ViY2xhc3NlcyB1c2luZyBhbiBhbHRlcm5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIEFQSS5cbiAgICBfc2V0QXR0cmlidXRlczogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLiRlbC5hdHRyKGF0dHJpYnV0ZXMpO1xuICAgIH1cblxufSk7XG5cbi8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIHZpZXcuXG5WaWV3QmFzZS5leHRlbmQgPSBleHRlbmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* reexport safe */ _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   Collection: function() { return /* reexport safe */ _Collection_mjs__WEBPACK_IMPORTED_MODULE_3__.Collection; },\n/* harmony export */   Data: function() { return /* reexport safe */ _Data_mjs__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   Event: function() { return /* reexport safe */ _Dom_Event_mjs__WEBPACK_IMPORTED_MODULE_8__.Event; },\n/* harmony export */   Events: function() { return /* reexport safe */ _Events_mjs__WEBPACK_IMPORTED_MODULE_2__.Events; },\n/* harmony export */   Listener: function() { return /* reexport safe */ _Listener_mjs__WEBPACK_IMPORTED_MODULE_1__.Listener; },\n/* harmony export */   Model: function() { return /* reexport safe */ _Model_mjs__WEBPACK_IMPORTED_MODULE_4__.Model; },\n/* harmony export */   View: function() { return /* reexport safe */ _View_mjs__WEBPACK_IMPORTED_MODULE_0__.View; },\n/* harmony export */   ViewBase: function() { return /* reexport safe */ _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_5__.ViewBase; },\n/* harmony export */   views: function() { return /* reexport safe */ _View_mjs__WEBPACK_IMPORTED_MODULE_0__.views; }\n/* harmony export */ });\n/* harmony import */ var _View_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/View.mjs\");\n/* harmony import */ var _Listener_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Listener.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Listener.mjs\");\n/* harmony import */ var _Events_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Events.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Events.mjs\");\n/* harmony import */ var _Collection_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Collection.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Collection.mjs\");\n/* harmony import */ var _Model_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Model.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Model.mjs\");\n/* harmony import */ var _ViewBase_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewBase.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/ViewBase.mjs\");\n/* harmony import */ var _Data_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Data.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Data.mjs\");\n/* harmony import */ var _Dom_index_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _Dom_Event_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Dom/Event.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/Event.mjs\");\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTJCO0FBQ0k7QUFDRjtBQUNJO0FBQ0w7QUFDRztBQUNjO0FBQ0U7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9pbmRleC5tanM/NmRjMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL1ZpZXcubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vTGlzdGVuZXIubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vRXZlbnRzLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL0NvbGxlY3Rpb24ubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vTW9kZWwubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vVmlld0Jhc2UubWpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRGF0YSB9IGZyb20gJy4vRGF0YS5tanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyAkIH0gZnJvbSAnLi9Eb20vaW5kZXgubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vRG9tL0V2ZW50Lm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/mvc/mvcUtils.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMethodsUtil: function() { return /* binding */ addMethodsUtil; },\n/* harmony export */   extend: function() { return /* binding */ extend; }\n/* harmony export */ });\n/* harmony import */ var _util_util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/utilHelpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n// Helpers\n// -------\n\n// Helper function to correctly set up the prototype chain for subclasses.\n// Similar to `goog.inherits`, but uses a hash of prototype properties and\n// class properties to be extended.\nvar extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent constructor.\n    if (protoProps && (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.has)(protoProps, 'constructor')) {\n        child = protoProps.constructor;\n    } else {\n        child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.assign)(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function and add the prototype properties.\n    child.prototype = Object.assign(Object.create(parent.prototype), protoProps);\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n};\n\n// Proxy class methods to functions, wrapping the model's\n// `attributes` object or collection's `models` array behind the scenes.\n//\n// `Function#apply` can be slow so we use the method's arg count, if we know it.\nvar addMethod = function(base, length, method, attribute) {\n    switch (length) {\n        case 1: return function() {\n            return base[method](this[attribute]);\n        };\n        case 2: return function(value) {\n            return base[method](this[attribute], value);\n        };\n        case 3: return function(iteratee, context) {\n            return base[method](this[attribute], cb(iteratee, this), context);\n        };\n        case 4: return function(iteratee, defaultVal, context) {\n            return base[method](this[attribute], cb(iteratee, this), defaultVal, context);\n        };\n        default: return function() {\n            var args = Array.prototype.slice.call(arguments);\n            args.unshift(this[attribute]);\n            return base[method].apply(base, args);\n        };\n    }\n};\n\nvar addMethodsUtil = function(Class, base, methods, attribute) {\n    (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.forIn)(methods, function(length, method) {\n        if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);\n    });\n};\n\n// Support `collection.sortBy('attr')`.\nvar cb = function(iteratee, instance) {\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(iteratee)) return iteratee;\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);\n    if ((0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(iteratee)) return function(model) { return model.get(iteratee); };\n    return iteratee;\n};\n\nvar modelMatcher = function(attrs) {\n    var matcher = (0,_util_util_mjs__WEBPACK_IMPORTED_MODULE_0__.matches)(attrs);\n    return function(model) {\n        return matcher(model.attributes);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvbXZjL212Y1V0aWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFPMEI7QUFDd0I7O0FBRWxEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtREFBRztBQUN6QjtBQUNBLE1BQU07QUFDTiw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSxJQUFJLHNEQUFNOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsSUFBSSxxREFBSztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxRQUFRLDBEQUFVO0FBQ2xCLFFBQVEsd0RBQVE7QUFDaEIsUUFBUSx3REFBUSxxQ0FBcUM7QUFDckQ7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQix1REFBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL212Yy9tdmNVdGlscy5tanM/OTA4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGFzc2lnbixcbiAgICBmb3JJbixcbiAgICBoYXMsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc09iamVjdCxcbiAgICBpc1N0cmluZ1xufSBmcm9tICcuLi91dGlsL3V0aWwubWpzJztcbmltcG9ydCB7IG1hdGNoZXMgfSBmcm9tICcuLi91dGlsL3V0aWxIZWxwZXJzLm1qcyc7XG5cbi8vIEhlbHBlcnNcbi8vIC0tLS0tLS1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiBmb3Igc3ViY2xhc3Nlcy5cbi8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4vLyBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGV4dGVuZGVkLlxuZXhwb3J0IHZhciBleHRlbmQgPSBmdW5jdGlvbihwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgIHZhciBjaGlsZDtcblxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yLlxuICAgIGlmIChwcm90b1Byb3BzICYmIGhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xuICAgICAgICBjaGlsZCA9IHByb3RvUHJvcHMuY29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgYXNzaWduKGNoaWxkLCBwYXJlbnQsIHN0YXRpY1Byb3BzKTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhbmQgYWRkIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAgICBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSksIHByb3RvUHJvcHMpO1xuICAgIGNoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAgIC8vIGxhdGVyLlxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gY2hpbGQ7XG59O1xuXG4vLyBQcm94eSBjbGFzcyBtZXRob2RzIHRvIGZ1bmN0aW9ucywgd3JhcHBpbmcgdGhlIG1vZGVsJ3Ncbi8vIGBhdHRyaWJ1dGVzYCBvYmplY3Qgb3IgY29sbGVjdGlvbidzIGBtb2RlbHNgIGFycmF5IGJlaGluZCB0aGUgc2NlbmVzLlxuLy9cbi8vIGBGdW5jdGlvbiNhcHBseWAgY2FuIGJlIHNsb3cgc28gd2UgdXNlIHRoZSBtZXRob2QncyBhcmcgY291bnQsIGlmIHdlIGtub3cgaXQuXG52YXIgYWRkTWV0aG9kID0gZnVuY3Rpb24oYmFzZSwgbGVuZ3RoLCBtZXRob2QsIGF0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0pO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlW21ldGhvZF0odGhpc1thdHRyaWJ1dGVdLCBjYihpdGVyYXRlZSwgdGhpcyksIGNvbnRleHQpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihpdGVyYXRlZSwgZGVmYXVsdFZhbCwgY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXSh0aGlzW2F0dHJpYnV0ZV0sIGNiKGl0ZXJhdGVlLCB0aGlzKSwgZGVmYXVsdFZhbCwgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzW2F0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VbbWV0aG9kXS5hcHBseShiYXNlLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgdmFyIGFkZE1ldGhvZHNVdGlsID0gZnVuY3Rpb24oQ2xhc3MsIGJhc2UsIG1ldGhvZHMsIGF0dHJpYnV0ZSkge1xuICAgIGZvckluKG1ldGhvZHMsIGZ1bmN0aW9uKGxlbmd0aCwgbWV0aG9kKSB7XG4gICAgICAgIGlmIChiYXNlW21ldGhvZF0pIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gYWRkTWV0aG9kKGJhc2UsIGxlbmd0aCwgbWV0aG9kLCBhdHRyaWJ1dGUpO1xuICAgIH0pO1xufTtcblxuLy8gU3VwcG9ydCBgY29sbGVjdGlvbi5zb3J0QnkoJ2F0dHInKWAuXG52YXIgY2IgPSBmdW5jdGlvbihpdGVyYXRlZSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihpdGVyYXRlZSkpIHJldHVybiBpdGVyYXRlZTtcbiAgICBpZiAoaXNPYmplY3QoaXRlcmF0ZWUpICYmICFpbnN0YW5jZS5faXNNb2RlbChpdGVyYXRlZSkpIHJldHVybiBtb2RlbE1hdGNoZXIoaXRlcmF0ZWUpO1xuICAgIGlmIChpc1N0cmluZyhpdGVyYXRlZSkpIHJldHVybiBmdW5jdGlvbihtb2RlbCkgeyByZXR1cm4gbW9kZWwuZ2V0KGl0ZXJhdGVlKTsgfTtcbiAgICByZXR1cm4gaXRlcmF0ZWU7XG59O1xuXG52YXIgbW9kZWxNYXRjaGVyID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICB2YXIgbWF0Y2hlciA9IG1hdGNoZXMoYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlcihtb2RlbC5hdHRyaWJ1dGVzKTtcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/mvc/mvcUtils.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/index.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattan: function() { return /* reexport safe */ _manhattan_mjs__WEBPACK_IMPORTED_MODULE_3__.manhattan; },\n/* harmony export */   metro: function() { return /* reexport safe */ _metro_mjs__WEBPACK_IMPORTED_MODULE_4__.metro; },\n/* harmony export */   normal: function() { return /* reexport safe */ _normal_mjs__WEBPACK_IMPORTED_MODULE_0__.normal; },\n/* harmony export */   oneSide: function() { return /* reexport safe */ _oneSide_mjs__WEBPACK_IMPORTED_MODULE_1__.oneSide; },\n/* harmony export */   orthogonal: function() { return /* reexport safe */ _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_2__.orthogonal; },\n/* harmony export */   rightAngle: function() { return /* reexport safe */ _rightAngle_mjs__WEBPACK_IMPORTED_MODULE_5__.rightAngle; }\n/* harmony export */ });\n/* harmony import */ var _normal_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normal.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/normal.mjs\");\n/* harmony import */ var _oneSide_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./oneSide.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/oneSide.mjs\");\n/* harmony import */ var _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./orthogonal.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/orthogonal.mjs\");\n/* harmony import */ var _manhattan_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./manhattan.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/manhattan.mjs\");\n/* harmony import */ var _metro_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./metro.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/metro.mjs\");\n/* harmony import */ var _rightAngle_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rightAngle.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/rightAngle.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ0M7QUFDRztBQUNEO0FBQ0o7QUFDSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvaW5kZXgubWpzP2Q0NDIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9ub3JtYWwubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25lU2lkZS5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vcnRob2dvbmFsLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL21hbmhhdHRhbi5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9tZXRyby5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi9yaWdodEFuZ2xlLm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/manhattan.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/manhattan.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   manhattan: function() { return /* binding */ manhattan; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orthogonal.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/orthogonal.mjs\");\n\n\n\n\nvar config = {\n\n    // size of the step to find a route (the grid of the manhattan pathfinder)\n    step: 10,\n\n    // the number of route finding loops that cause the router to abort\n    // returns fallback route instead\n    maximumLoops: 2000,\n\n    // the number of decimal places to round floating point coordinates\n    precision: 1,\n\n    // maximum change of direction\n    maxAllowedDirectionChange: 90,\n\n    // should the router use perpendicular linkView option?\n    // does not connect anchor of element but rather a point close-by that is orthogonal\n    // this looks much better\n    perpendicular: true,\n\n    // should the source and/or target not be considered as obstacles?\n    excludeEnds: [], // 'source', 'target'\n\n    // should certain types of elements not be considered as obstacles?\n    excludeTypes: [],\n\n    // possible starting directions from an element\n    startDirections: ['top', 'right', 'bottom', 'left'],\n\n    // possible ending directions to an element\n    endDirections: ['top', 'right', 'bottom', 'left'],\n\n    // specify the directions used above and what they mean\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 }\n    },\n\n    // cost of an orthogonal step\n    cost: function() {\n\n        return this.step;\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: 0, offsetY: -step, cost: cost }\n        ];\n    },\n\n    // a penalty received for direction change\n    penalties: function() {\n\n        return {\n            0: 0,\n            45: this.step / 2,\n            90: this.step / 2\n        };\n    },\n\n    // padding applied on the element bounding boxes\n    paddingBox: function() {\n\n        var step = this.step;\n\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step\n        };\n    },\n\n    // A function that determines whether a given point is an obstacle or not.\n    // If used, the `padding`, `excludeEnds`and `excludeTypes` options are ignored.\n    // (point: dia.Point) => boolean;\n    isPointObstacle: null,\n\n    // a router to use when the manhattan router fails\n    // (one of the partial routes returns null)\n    fallbackRouter: function(vertices, opt, linkView) {\n\n        if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(_orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__.orthogonal)) {\n            throw new Error('Manhattan requires the orthogonal router as default fallback.');\n        }\n\n        return (0,_orthogonal_mjs__WEBPACK_IMPORTED_MODULE_1__.orthogonal)(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, config, opt), linkView);\n    },\n\n    /* Deprecated */\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        return null; // null result will trigger the fallbackRouter\n\n        // left for reference:\n        /*// Find an orthogonal route ignoring obstacles.\n\n        var point = ((opt.previousDirAngle || 0) % 180 === 0)\n                ? new g.Point(from.x, to.y)\n                : new g.Point(to.x, from.y);\n\n        return [point];*/\n    },\n\n    // if a function is provided, it's used to route the link while dragging an end\n    // i.e. function(from, to, opt) { return []; }\n    draggingRoute: null\n};\n\n// HELPER CLASSES //\n\n// Map of obstacles\n// Helper structure to identify whether a point lies inside an obstacle.\nfunction ObstacleMap(opt) {\n\n    this.map = {};\n    this.options = opt;\n    // tells how to divide the paper when creating the elements map\n    this.mapGridSize = 100;\n}\n\nObstacleMap.prototype.build = function(graph, link) {\n\n    var opt = this.options;\n\n    // source or target element could be excluded from set of obstacles\n    var excludedEnds = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.excludeEnds).reduce(function(res, item) {\n\n        var end = link.get(item);\n        if (end) {\n            var cell = graph.getCell(end.id);\n            if (cell) {\n                res.push(cell);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // Exclude any embedded elements from the source and the target element.\n    var excludedAncestors = [];\n\n    var source = graph.getCell(link.get('source').id);\n    if (source) {\n        excludedAncestors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.union(excludedAncestors, source.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    var target = graph.getCell(link.get('target').id);\n    if (target) {\n        excludedAncestors = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.union(excludedAncestors, target.getAncestors().map(function(cell) {\n            return cell.id;\n        }));\n    }\n\n    // Builds a map of all elements for quicker obstacle queries (i.e. is a point contained\n    // in any obstacle?) (a simplified grid search).\n    // The paper is divided into smaller cells, where each holds information about which\n    // elements belong to it. When we query whether a point lies inside an obstacle we\n    // don't need to go through all obstacles, we check only those in a particular cell.\n    var mapGridSize = this.mapGridSize;\n\n    graph.getElements().reduce(function(map, element) {\n\n        var isExcludedType = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.excludeTypes).includes(element.get('type'));\n        var isExcludedEnd = excludedEnds.find(function(excluded) {\n            return excluded.id === element.id;\n        });\n        var isExcludedAncestor = excludedAncestors.includes(element.id);\n\n        var isExcluded = isExcludedType || isExcludedEnd || isExcludedAncestor;\n        if (!isExcluded) {\n            var bbox = element.getBBox().moveAndExpand(opt.paddingBox);\n\n            var origin = bbox.origin().snapToGrid(mapGridSize);\n            var corner = bbox.corner().snapToGrid(mapGridSize);\n\n            for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n                for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n                    var gridKey = x + '@' + y;\n                    map[gridKey] = map[gridKey] || [];\n                    map[gridKey].push(bbox);\n                }\n            }\n        }\n\n        return map;\n    }, this.map);\n\n    return this;\n};\n\nObstacleMap.prototype.isPointAccessible = function(point) {\n\n    var mapKey = point.clone().snapToGrid(this.mapGridSize).toString();\n\n    return _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(this.map[mapKey]).every(function(obstacle) {\n        return !obstacle.containsPoint(point);\n    });\n};\n\n// Sorted Set\n// Set of items sorted by given value.\nfunction SortedSet() {\n    this.items = [];\n    this.hash = {};\n    this.values = {};\n    this.OPEN = 1;\n    this.CLOSE = 2;\n}\n\nSortedSet.prototype.add = function(item, value) {\n\n    if (this.hash[item]) {\n        // item removal\n        this.items.splice(this.items.indexOf(item), 1);\n    } else {\n        this.hash[item] = this.OPEN;\n    }\n\n    this.values[item] = value;\n\n    var index = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.sortedIndex(this.items, item, function(i) {\n        return this.values[i];\n    }.bind(this));\n\n    this.items.splice(index, 0, item);\n};\n\nSortedSet.prototype.remove = function(item) {\n\n    this.hash[item] = this.CLOSE;\n};\n\nSortedSet.prototype.isOpen = function(item) {\n\n    return this.hash[item] === this.OPEN;\n};\n\nSortedSet.prototype.isClose = function(item) {\n\n    return this.hash[item] === this.CLOSE;\n};\n\nSortedSet.prototype.isEmpty = function() {\n\n    return this.items.length === 0;\n};\n\nSortedSet.prototype.pop = function() {\n\n    var item = this.items.shift();\n    this.remove(item);\n    return item;\n};\n\n// HELPERS //\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.sourceBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.sourceBBox.clone();\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    // expand by padding box\n    if (opt && opt.paddingBox) return linkView.targetBBox.clone().moveAndExpand(opt.paddingBox);\n\n    return linkView.targetBBox.clone();\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nfunction getDirectionAngle(start, end, numDirections, grid, opt) {\n\n    var quadrant = 360 / numDirections;\n    var angleTheta = start.theta(fixAngleEnd(start, end, grid, opt));\n    var normalizedAngle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(angleTheta + (quadrant / 2));\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\n// helper function for getDirectionAngle()\n// corrects for grid deformation\n// (if a point is one grid steps away from another in both dimensions,\n// it is considered to be 45 degrees away, even if the real angle is different)\n// this causes visible angle discrepancies if `opt.step` is much larger than `paper.gridSize`\nfunction fixAngleEnd(start, end, grid, opt) {\n\n    var step = opt.step;\n\n    var diffX = end.x - start.x;\n    var diffY = end.y - start.y;\n\n    var gridStepsX = diffX / grid.x;\n    var gridStepsY = diffY / grid.y;\n\n    var distanceX = gridStepsX * step;\n    var distanceY = gridStepsY * step;\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(start.x + distanceX, start.y + distanceY);\n}\n\n// return the change in direction between two direction angles\nfunction getDirectionChange(angle1, angle2) {\n\n    var directionChange = Math.abs(angle1 - angle2);\n    return (directionChange > 180) ? (360 - directionChange) : directionChange;\n}\n\n// fix direction offsets according to current grid\nfunction getGridOffsets(directions, grid, opt) {\n\n    var step = opt.step;\n\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.directions).forEach(function(direction) {\n\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n}\n\n// get grid size in x and y dimensions, adapted to source and target positions\nfunction getGrid(step, source, target) {\n\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step)\n    };\n}\n\n// helper function for getGrid()\nfunction getGridDimension(diff, step) {\n\n    // return step if diff = 0\n    if (!diff) return step;\n\n    var absDiff = Math.abs(diff);\n    var numSteps = Math.round(absDiff / step);\n\n    // return absDiff if less than one step apart\n    if (!numSteps) return absDiff;\n\n    // otherwise, return corrected step\n    var roundedDiff = numSteps * step;\n    var remainder = absDiff - roundedDiff;\n    var stepCorrection = remainder / numSteps;\n\n    return step + stepCorrection;\n}\n\n// return a clone of point snapped to grid\nfunction snapToGrid(point, grid) {\n\n    var source = grid.source;\n\n    var snappedX = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGrid(point.x - source.x, grid.x) + source.x;\n    var snappedY = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.snapToGrid(point.y - source.y, grid.y) + source.y;\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(snappedX, snappedY);\n}\n\n// round the point to opt.precision\nfunction round(point, precision) {\n\n    return point.round(precision);\n}\n\n// snap to grid and then round the point\nfunction align(point, grid, precision) {\n\n    return round(snapToGrid(point.clone(), grid), precision);\n}\n\n// return a string representing the point\n// string is rounded in both dimensions\nfunction getKey(point) {\n\n    return point.clone().toString();\n}\n\n// return a normalized vector from given point\n// used to determine the direction of a difference of two points\nfunction normalizePoint(point) {\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(\n        point.x === 0 ? 0 : Math.abs(point.x) / point.x,\n        point.y === 0 ? 0 : Math.abs(point.y) / point.y\n    );\n}\n\n// PATHFINDING //\n\n// reconstructs a route by concatenating points with their parents\nfunction reconstructRoute(parents, points, tailPoint, from, to, grid, opt) {\n\n    var route = [];\n\n    var prevDiff = normalizePoint(to.difference(tailPoint));\n\n    // tailPoint is assumed to be aligned already\n    var currentKey = getKey(tailPoint);\n    var parent = parents[currentKey];\n\n    var point;\n    while (parent) {\n\n        // point is assumed to be aligned already\n        point = points[currentKey];\n\n        var diff = normalizePoint(point.difference(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n\n    // leadPoint is assumed to be aligned already\n    var leadPoint = points[currentKey];\n\n    var fromDiff = normalizePoint(leadPoint.difference(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n\n    return route;\n}\n\n// heuristic method to determine the distance between two points\nfunction estimateCost(from, endPoints) {\n\n    var min = Infinity;\n\n    for (var i = 0, len = endPoints.length; i < len; i++) {\n        var cost = from.manhattanDistance(endPoints[i]);\n        if (cost < min) min = cost;\n    }\n\n    return min;\n}\n\n// find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nfunction getRectPoints(anchor, bbox, directionList, grid, opt) {\n\n    var precision = opt.precision;\n    var directionMap = opt.directionMap;\n\n    var anchorCenterVector = anchor.difference(bbox.center());\n\n    var keys = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject(directionMap) ? Object.keys(directionMap) : [];\n    var dirList = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(directionList);\n    var rectPoints = keys.reduce(function(res, key) {\n\n        if (dirList.includes(key)) {\n            var direction = directionMap[key];\n\n            // create a line that is guaranteed to intersect the bbox if bbox is in the direction\n            // even if anchor lies outside of bbox\n            var endpoint = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(\n                anchor.x + direction.x * (Math.abs(anchorCenterVector.x) + bbox.width),\n                anchor.y + direction.y * (Math.abs(anchorCenterVector.y) + bbox.height)\n            );\n            var intersectionLine = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(anchor, endpoint);\n\n            // get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            var intersections = intersectionLine.intersect(bbox) || [];\n            var numIntersections = intersections.length;\n            var farthestIntersectionDistance;\n            var farthestIntersection = null;\n            for (var i = 0; i < numIntersections; i++) {\n                var currentIntersection = intersections[i];\n                var distance = anchor.squaredDistance(currentIntersection);\n                if ((farthestIntersectionDistance === undefined) || (distance > farthestIntersectionDistance)) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = currentIntersection;\n                }\n            }\n\n            // if an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                var point = align(farthestIntersection, grid, precision);\n\n                // if the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(point)) {\n                    point = align(point.offset(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n\n                // then add the point to the result array\n                // aligned\n                res.push(point);\n            }\n        }\n\n        return res;\n    }, []);\n\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        // aligned\n        rectPoints.push(align(anchor, grid, precision));\n    }\n\n    return rectPoints;\n}\n\n// finds the route between two points/rectangles (`from`, `to`) implementing A* algorithm\n// rectangles get rect points assigned by getRectPoints()\nfunction findRoute(from, to, isPointObstacle, opt) {\n\n    var precision = opt.precision;\n\n    // Get grid for this route.\n\n    var sourceAnchor, targetAnchor;\n\n    if (from instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `from` is sourceBBox\n        sourceAnchor = round(getSourceAnchor(this, opt).clone(), precision);\n    } else {\n        sourceAnchor = round(from.clone(), precision);\n    }\n\n    if (to instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `to` is targetBBox\n        targetAnchor = round(getTargetAnchor(this, opt).clone(), precision);\n    } else {\n        targetAnchor = round(to.clone(), precision);\n    }\n\n    var grid = getGrid(opt.step, sourceAnchor, targetAnchor);\n\n    // Get pathfinding points.\n\n    var start, end; // aligned with grid by definition\n    var startPoints, endPoints; // assumed to be aligned with grid already\n\n    // set of points we start pathfinding from\n    if (from instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `from` is sourceBBox\n        start = sourceAnchor;\n        startPoints = getRectPoints(start, from, opt.startDirections, grid, opt);\n\n    } else {\n        start = sourceAnchor;\n        startPoints = [start];\n    }\n\n    // set of points we want the pathfinding to finish at\n    if (to instanceof _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.Rect) { // `to` is targetBBox\n        end = targetAnchor;\n        endPoints = getRectPoints(targetAnchor, to, opt.endDirections, grid, opt);\n\n    } else {\n        end = targetAnchor;\n        endPoints = [end];\n    }\n\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter(p => !isPointObstacle(p));\n    endPoints = endPoints.filter(p => !isPointObstacle(p));\n\n    // Check that there is an accessible route point on both sides.\n    // Otherwise, use fallbackRoute().\n    if (startPoints.length > 0 && endPoints.length > 0) {\n\n        // The set of tentative points to be evaluated, initially containing the start points.\n        // Rounded to nearest integer for simplicity.\n        var openSet = new SortedSet();\n        // Keeps reference to actual points for given elements of the open set.\n        var points = {};\n        // Keeps reference to a point that is immediate predecessor of given element.\n        var parents = {};\n        // Cost from start to a point along best known path.\n        var costs = {};\n\n        for (var i = 0, n = startPoints.length; i < n; i++) {\n            // startPoint is assumed to be aligned already\n            var startPoint = startPoints[i];\n\n            var key = getKey(startPoint);\n\n            openSet.add(key, estimateCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n\n        var previousRouteDirectionAngle = opt.previousDirectionAngle; // undefined for first route\n        var isPathBeginning = (previousRouteDirectionAngle === undefined);\n\n        // directions\n        var direction, directionChange;\n        var directions = opt.directions;\n        getGridOffsets(directions, grid, opt);\n\n        var numDirections = directions.length;\n\n        var endPointsKeys = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(endPoints).reduce(function(res, endPoint) {\n            // endPoint is assumed to be aligned already\n\n            var key = getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n\n        // main route finding loop\n        var loopsRemaining = opt.maximumLoops;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n\n            // remove current from the open list\n            var currentKey = openSet.pop();\n            var currentPoint = points[currentKey];\n            var currentParent = parents[currentKey];\n            var currentCost = costs[currentKey];\n\n            var isRouteBeginning = (currentParent === undefined); // undefined for route starts\n            var isStart = currentPoint.equals(start); // (is source anchor or `from` point) = can leave in any direction\n\n            var previousDirectionAngle;\n            if (!isRouteBeginning) previousDirectionAngle = getDirectionAngle(currentParent, currentPoint, numDirections, grid, opt); // a vertex on the route\n            else if (!isPathBeginning) previousDirectionAngle = previousRouteDirectionAngle; // beginning of route on the path\n            else if (!isStart) previousDirectionAngle = getDirectionAngle(start, currentPoint, numDirections, grid, opt); // beginning of path, start rect point\n            else previousDirectionAngle = null; // beginning of path, source anchor or `from` point\n\n            // check if we reached any endpoint\n            var samePoints = startPoints.length === endPoints.length;\n            if (samePoints) {\n                for (var j = 0; j < startPoints.length; j++) {\n                    if (!startPoints[j].equals(endPoints[j])) {\n                        samePoints = false;\n                        break;\n                    }\n                }\n            }\n            var skipEndCheck = (isRouteBeginning && samePoints);\n            if (!skipEndCheck && (endPointsKeys.indexOf(currentKey) >= 0)) {\n                opt.previousDirectionAngle = previousDirectionAngle;\n                return reconstructRoute(parents, points, currentPoint, start, end, grid, opt);\n            }\n\n            // go over all possible directions and find neighbors\n            for (i = 0; i < numDirections; i++) {\n                direction = directions[i];\n\n                var directionAngle = direction.angle;\n                directionChange = getDirectionChange(previousDirectionAngle, directionAngle);\n\n                // if the direction changed rapidly, don't use this point\n                // any direction is allowed for starting points\n                if (!(isPathBeginning && isStart) && directionChange > opt.maxAllowedDirectionChange) continue;\n\n                var neighborPoint = align(currentPoint.clone().offset(direction.gridOffsetX, direction.gridOffsetY), grid, precision);\n                var neighborKey = getKey(neighborPoint);\n\n                // Closed points from the openSet were already evaluated.\n                if (openSet.isClose(neighborKey) || isPointObstacle(neighborPoint)) continue;\n\n                // We can only enter end points at an acceptable angle.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) { // neighbor is an end point\n\n                    var isNeighborEnd = neighborPoint.equals(end); // (is target anchor or `to` point) = can be entered in any direction\n\n                    if (!isNeighborEnd) {\n                        var endDirectionAngle = getDirectionAngle(neighborPoint, end, numDirections, grid, opt);\n                        var endDirectionChange = getDirectionChange(directionAngle, endDirectionAngle);\n\n                        if (endDirectionChange > opt.maxAllowedDirectionChange) continue;\n                    }\n                }\n\n                // The current direction is ok.\n\n                var neighborCost = direction.cost;\n                var neighborPenalty = isStart ? 0 : opt.penalties[directionChange]; // no penalties for start point\n                var costFromStart = currentCost + neighborCost + neighborPenalty;\n\n                if (!openSet.isOpen(neighborKey) || (costFromStart < costs[neighborKey])) {\n                    // neighbor point has not been processed yet\n                    // or the cost of the path from start is lower than previously calculated\n\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + estimateCost(neighborPoint, endPoints));\n                }\n            }\n\n            loopsRemaining--;\n        }\n    }\n\n    // no route found (`to` point either wasn't accessible or finding route took\n    // way too much calculation)\n    return opt.fallbackRoute.call(this, start, end, opt);\n}\n\n// resolve some of the options\nfunction resolveOptions(opt) {\n\n    opt.directions = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'directions');\n    opt.penalties = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'penalties');\n    opt.paddingBox = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'paddingBox');\n    opt.padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.result(opt, 'padding');\n\n    if (opt.padding) {\n        // if both provided, opt.padding wins over opt.paddingBox\n        var sides = _util_index_mjs__WEBPACK_IMPORTED_MODULE_6__.normalizeSides(opt.padding);\n        opt.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom\n        };\n    }\n\n    _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(opt.directions).forEach(function(direction) {\n\n        var point1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(0, 0);\n        var point2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point(direction.offsetX, direction.offsetY);\n\n        direction.angle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(point1.theta(point2));\n    });\n}\n\n// initialization of the route finding\nfunction router(vertices, opt, linkView) {\n\n    resolveOptions(opt);\n\n    // enable/disable linkView perpendicular option\n    linkView.options.perpendicular = !!opt.perpendicular;\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    //var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // pathfinding\n    let isPointObstacle;\n    if (typeof opt.isPointObstacle === 'function') {\n        isPointObstacle = opt.isPointObstacle;\n    } else {\n        const map = new ObstacleMap(opt);\n        map.build(linkView.paper.model, linkView.model);\n        isPointObstacle = (point) => !map.isPointAccessible(point);\n    }\n\n    var oldVertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray(vertices).map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.Point);\n    var newVertices = [];\n    var tailPoint = sourceAnchor; // the origin of first route's grid, does not need snapping\n\n    // find a route by concatenating all partial routes (routes need to pass through vertices)\n    // source -> vertex[1] -> ... -> vertex[n] -> target\n    var to, from;\n\n    for (var i = 0, len = oldVertices.length; i <= len; i++) {\n\n        var partialRoute = null;\n\n        from = to || sourceBBox;\n        to = oldVertices[i];\n\n        if (!to) {\n            // this is the last iteration\n            // we ran through all vertices in oldVertices\n            // 'to' is not a vertex.\n\n            to = targetBBox;\n\n            // If the target is a point (i.e. it's not an element), we\n            // should use dragging route instead of main routing method if it has been provided.\n            var isEndingAtPoint = !linkView.model.get('source').id || !linkView.model.get('target').id;\n\n            if (isEndingAtPoint && _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction(opt.draggingRoute)) {\n                // Make sure we are passing points only (not rects).\n                var dragFrom = (from === sourceBBox) ? sourceAnchor : from;\n                var dragTo = to.origin();\n\n                partialRoute = opt.draggingRoute.call(linkView, dragFrom, dragTo, opt);\n            }\n        }\n\n        // if partial route has not been calculated yet use the main routing method to find one\n        partialRoute = partialRoute || findRoute.call(linkView, from, to, isPointObstacle, opt);\n\n        if (partialRoute === null) { // the partial route cannot be found\n            return opt.fallbackRouter(vertices, opt, linkView);\n        }\n\n        var leadPoint = partialRoute[0];\n\n        // remove the first point if the previous partial route had the same point as last\n        if (leadPoint && leadPoint.equals(tailPoint)) partialRoute.shift();\n\n        // save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n\n        Array.prototype.push.apply(newVertices, partialRoute);\n    }\n\n    return newVertices;\n}\n\n// public function\nconst manhattan = function(vertices, opt, linkView) {\n    return router(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.assign({}, config, opt), linkView);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9tYW5oYXR0YW4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ007QUFDSTs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixpQkFBaUIsWUFBWTtBQUM3QixrQkFBa0IsWUFBWTtBQUM5QixnQkFBZ0I7QUFDaEIsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWMsdUNBQXVDO0FBQ3JELGNBQWMsd0NBQXdDO0FBQ3RELGNBQWMsdUNBQXVDO0FBQ3JELGNBQWM7QUFDZDtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsdURBQWUsQ0FBQyx1REFBVTtBQUN2QztBQUNBOztBQUVBLGVBQWUsMkRBQVUsV0FBVyxtREFBVyxHQUFHO0FBQ2xELEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsS0FBSzs7QUFFTDtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLG9E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O0FBRUE7QUFDTztBQUNQLDRCQUE0QixtREFBVyxHQUFHO0FBQzFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9tYW5oYXR0YW4ubWpzPzFmYjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwvaW5kZXgubWpzJztcbmltcG9ydCB7IG9ydGhvZ29uYWwgfSBmcm9tICcuL29ydGhvZ29uYWwubWpzJztcblxudmFyIGNvbmZpZyA9IHtcblxuICAgIC8vIHNpemUgb2YgdGhlIHN0ZXAgdG8gZmluZCBhIHJvdXRlICh0aGUgZ3JpZCBvZiB0aGUgbWFuaGF0dGFuIHBhdGhmaW5kZXIpXG4gICAgc3RlcDogMTAsXG5cbiAgICAvLyB0aGUgbnVtYmVyIG9mIHJvdXRlIGZpbmRpbmcgbG9vcHMgdGhhdCBjYXVzZSB0aGUgcm91dGVyIHRvIGFib3J0XG4gICAgLy8gcmV0dXJucyBmYWxsYmFjayByb3V0ZSBpbnN0ZWFkXG4gICAgbWF4aW11bUxvb3BzOiAyMDAwLFxuXG4gICAgLy8gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0byByb3VuZCBmbG9hdGluZyBwb2ludCBjb29yZGluYXRlc1xuICAgIHByZWNpc2lvbjogMSxcblxuICAgIC8vIG1heGltdW0gY2hhbmdlIG9mIGRpcmVjdGlvblxuICAgIG1heEFsbG93ZWREaXJlY3Rpb25DaGFuZ2U6IDkwLFxuXG4gICAgLy8gc2hvdWxkIHRoZSByb3V0ZXIgdXNlIHBlcnBlbmRpY3VsYXIgbGlua1ZpZXcgb3B0aW9uP1xuICAgIC8vIGRvZXMgbm90IGNvbm5lY3QgYW5jaG9yIG9mIGVsZW1lbnQgYnV0IHJhdGhlciBhIHBvaW50IGNsb3NlLWJ5IHRoYXQgaXMgb3J0aG9nb25hbFxuICAgIC8vIHRoaXMgbG9va3MgbXVjaCBiZXR0ZXJcbiAgICBwZXJwZW5kaWN1bGFyOiB0cnVlLFxuXG4gICAgLy8gc2hvdWxkIHRoZSBzb3VyY2UgYW5kL29yIHRhcmdldCBub3QgYmUgY29uc2lkZXJlZCBhcyBvYnN0YWNsZXM/XG4gICAgZXhjbHVkZUVuZHM6IFtdLCAvLyAnc291cmNlJywgJ3RhcmdldCdcblxuICAgIC8vIHNob3VsZCBjZXJ0YWluIHR5cGVzIG9mIGVsZW1lbnRzIG5vdCBiZSBjb25zaWRlcmVkIGFzIG9ic3RhY2xlcz9cbiAgICBleGNsdWRlVHlwZXM6IFtdLFxuXG4gICAgLy8gcG9zc2libGUgc3RhcnRpbmcgZGlyZWN0aW9ucyBmcm9tIGFuIGVsZW1lbnRcbiAgICBzdGFydERpcmVjdGlvbnM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG5cbiAgICAvLyBwb3NzaWJsZSBlbmRpbmcgZGlyZWN0aW9ucyB0byBhbiBlbGVtZW50XG4gICAgZW5kRGlyZWN0aW9uczogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcblxuICAgIC8vIHNwZWNpZnkgdGhlIGRpcmVjdGlvbnMgdXNlZCBhYm92ZSBhbmQgd2hhdCB0aGV5IG1lYW5cbiAgICBkaXJlY3Rpb25NYXA6IHtcbiAgICAgICAgdG9wOiB7IHg6IDAsIHk6IC0xIH0sXG4gICAgICAgIHJpZ2h0OiB7IHg6IDEsIHk6IDAgfSxcbiAgICAgICAgYm90dG9tOiB7IHg6IDAsIHk6IDEgfSxcbiAgICAgICAgbGVmdDogeyB4OiAtMSwgeTogMCB9XG4gICAgfSxcblxuICAgIC8vIGNvc3Qgb2YgYW4gb3J0aG9nb25hbCBzdGVwXG4gICAgY29zdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcDtcbiAgICB9LFxuXG4gICAgLy8gYW4gYXJyYXkgb2YgZGlyZWN0aW9ucyB0byBmaW5kIG5leHQgcG9pbnRzIG9uIHRoZSByb3V0ZVxuICAgIC8vIGRpZmZlcmVudCBmcm9tIHN0YXJ0L2VuZCBkaXJlY3Rpb25zXG4gICAgZGlyZWN0aW9uczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG4gICAgICAgIHZhciBjb3N0ID0gdGhpcy5jb3N0KCk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogc3RlcCwgb2Zmc2V0WTogMCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAtc3RlcCwgb2Zmc2V0WTogMCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAwLCBvZmZzZXRZOiBzdGVwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IDAsIG9mZnNldFk6IC1zdGVwLCBjb3N0OiBjb3N0IH1cbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgLy8gYSBwZW5hbHR5IHJlY2VpdmVkIGZvciBkaXJlY3Rpb24gY2hhbmdlXG4gICAgcGVuYWx0aWVzOiBmdW5jdGlvbigpIHtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgMDogMCxcbiAgICAgICAgICAgIDQ1OiB0aGlzLnN0ZXAgLyAyLFxuICAgICAgICAgICAgOTA6IHRoaXMuc3RlcCAvIDJcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gcGFkZGluZyBhcHBsaWVkIG9uIHRoZSBlbGVtZW50IGJvdW5kaW5nIGJveGVzXG4gICAgcGFkZGluZ0JveDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnN0ZXA7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IC1zdGVwLFxuICAgICAgICAgICAgeTogLXN0ZXAsXG4gICAgICAgICAgICB3aWR0aDogMiAqIHN0ZXAsXG4gICAgICAgICAgICBoZWlnaHQ6IDIgKiBzdGVwXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBwb2ludCBpcyBhbiBvYnN0YWNsZSBvciBub3QuXG4gICAgLy8gSWYgdXNlZCwgdGhlIGBwYWRkaW5nYCwgYGV4Y2x1ZGVFbmRzYGFuZCBgZXhjbHVkZVR5cGVzYCBvcHRpb25zIGFyZSBpZ25vcmVkLlxuICAgIC8vIChwb2ludDogZGlhLlBvaW50KSA9PiBib29sZWFuO1xuICAgIGlzUG9pbnRPYnN0YWNsZTogbnVsbCxcblxuICAgIC8vIGEgcm91dGVyIHRvIHVzZSB3aGVuIHRoZSBtYW5oYXR0YW4gcm91dGVyIGZhaWxzXG4gICAgLy8gKG9uZSBvZiB0aGUgcGFydGlhbCByb3V0ZXMgcmV0dXJucyBudWxsKVxuICAgIGZhbGxiYWNrUm91dGVyOiBmdW5jdGlvbih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuXG4gICAgICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKG9ydGhvZ29uYWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbmhhdHRhbiByZXF1aXJlcyB0aGUgb3J0aG9nb25hbCByb3V0ZXIgYXMgZGVmYXVsdCBmYWxsYmFjay4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcnRob2dvbmFsKHZlcnRpY2VzLCB1dGlsLmFzc2lnbih7fSwgY29uZmlnLCBvcHQpLCBsaW5rVmlldyk7XG4gICAgfSxcblxuICAgIC8qIERlcHJlY2F0ZWQgKi9cbiAgICAvLyBhIHNpbXBsZSByb3V0ZSB1c2VkIGluIHNpdHVhdGlvbnMgd2hlbiBtYWluIHJvdXRpbmcgbWV0aG9kIGZhaWxzXG4gICAgLy8gKGV4Y2VlZCBtYXggbnVtYmVyIG9mIGxvb3AgaXRlcmF0aW9ucywgaW5hY2Nlc3NpYmxlKVxuICAgIGZhbGxiYWNrUm91dGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHQpIHtcblxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gbnVsbCByZXN1bHQgd2lsbCB0cmlnZ2VyIHRoZSBmYWxsYmFja1JvdXRlclxuXG4gICAgICAgIC8vIGxlZnQgZm9yIHJlZmVyZW5jZTpcbiAgICAgICAgLyovLyBGaW5kIGFuIG9ydGhvZ29uYWwgcm91dGUgaWdub3Jpbmcgb2JzdGFjbGVzLlxuXG4gICAgICAgIHZhciBwb2ludCA9ICgob3B0LnByZXZpb3VzRGlyQW5nbGUgfHwgMCkgJSAxODAgPT09IDApXG4gICAgICAgICAgICAgICAgPyBuZXcgZy5Qb2ludChmcm9tLngsIHRvLnkpXG4gICAgICAgICAgICAgICAgOiBuZXcgZy5Qb2ludCh0by54LCBmcm9tLnkpO1xuXG4gICAgICAgIHJldHVybiBbcG9pbnRdOyovXG4gICAgfSxcblxuICAgIC8vIGlmIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0J3MgdXNlZCB0byByb3V0ZSB0aGUgbGluayB3aGlsZSBkcmFnZ2luZyBhbiBlbmRcbiAgICAvLyBpLmUuIGZ1bmN0aW9uKGZyb20sIHRvLCBvcHQpIHsgcmV0dXJuIFtdOyB9XG4gICAgZHJhZ2dpbmdSb3V0ZTogbnVsbFxufTtcblxuLy8gSEVMUEVSIENMQVNTRVMgLy9cblxuLy8gTWFwIG9mIG9ic3RhY2xlc1xuLy8gSGVscGVyIHN0cnVjdHVyZSB0byBpZGVudGlmeSB3aGV0aGVyIGEgcG9pbnQgbGllcyBpbnNpZGUgYW4gb2JzdGFjbGUuXG5mdW5jdGlvbiBPYnN0YWNsZU1hcChvcHQpIHtcblxuICAgIHRoaXMubWFwID0ge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0O1xuICAgIC8vIHRlbGxzIGhvdyB0byBkaXZpZGUgdGhlIHBhcGVyIHdoZW4gY3JlYXRpbmcgdGhlIGVsZW1lbnRzIG1hcFxuICAgIHRoaXMubWFwR3JpZFNpemUgPSAxMDA7XG59XG5cbk9ic3RhY2xlTWFwLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKGdyYXBoLCBsaW5rKSB7XG5cbiAgICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgLy8gc291cmNlIG9yIHRhcmdldCBlbGVtZW50IGNvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gc2V0IG9mIG9ic3RhY2xlc1xuICAgIHZhciBleGNsdWRlZEVuZHMgPSB1dGlsLnRvQXJyYXkob3B0LmV4Y2x1ZGVFbmRzKS5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBpdGVtKSB7XG5cbiAgICAgICAgdmFyIGVuZCA9IGxpbmsuZ2V0KGl0ZW0pO1xuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IGdyYXBoLmdldENlbGwoZW5kLmlkKTtcbiAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEV4Y2x1ZGUgYW55IGVtYmVkZGVkIGVsZW1lbnRzIGZyb20gdGhlIHNvdXJjZSBhbmQgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBleGNsdWRlZEFuY2VzdG9ycyA9IFtdO1xuXG4gICAgdmFyIHNvdXJjZSA9IGdyYXBoLmdldENlbGwobGluay5nZXQoJ3NvdXJjZScpLmlkKTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGV4Y2x1ZGVkQW5jZXN0b3JzID0gdXRpbC51bmlvbihleGNsdWRlZEFuY2VzdG9ycywgc291cmNlLmdldEFuY2VzdG9ycygpLm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2VsbC5pZDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBncmFwaC5nZXRDZWxsKGxpbmsuZ2V0KCd0YXJnZXQnKS5pZCk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBleGNsdWRlZEFuY2VzdG9ycyA9IHV0aWwudW5pb24oZXhjbHVkZWRBbmNlc3RvcnMsIHRhcmdldC5nZXRBbmNlc3RvcnMoKS5tYXAoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuaWQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZHMgYSBtYXAgb2YgYWxsIGVsZW1lbnRzIGZvciBxdWlja2VyIG9ic3RhY2xlIHF1ZXJpZXMgKGkuZS4gaXMgYSBwb2ludCBjb250YWluZWRcbiAgICAvLyBpbiBhbnkgb2JzdGFjbGU/KSAoYSBzaW1wbGlmaWVkIGdyaWQgc2VhcmNoKS5cbiAgICAvLyBUaGUgcGFwZXIgaXMgZGl2aWRlZCBpbnRvIHNtYWxsZXIgY2VsbHMsIHdoZXJlIGVhY2ggaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgd2hpY2hcbiAgICAvLyBlbGVtZW50cyBiZWxvbmcgdG8gaXQuIFdoZW4gd2UgcXVlcnkgd2hldGhlciBhIHBvaW50IGxpZXMgaW5zaWRlIGFuIG9ic3RhY2xlIHdlXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBnbyB0aHJvdWdoIGFsbCBvYnN0YWNsZXMsIHdlIGNoZWNrIG9ubHkgdGhvc2UgaW4gYSBwYXJ0aWN1bGFyIGNlbGwuXG4gICAgdmFyIG1hcEdyaWRTaXplID0gdGhpcy5tYXBHcmlkU2l6ZTtcblxuICAgIGdyYXBoLmdldEVsZW1lbnRzKCkucmVkdWNlKGZ1bmN0aW9uKG1hcCwgZWxlbWVudCkge1xuXG4gICAgICAgIHZhciBpc0V4Y2x1ZGVkVHlwZSA9IHV0aWwudG9BcnJheShvcHQuZXhjbHVkZVR5cGVzKS5pbmNsdWRlcyhlbGVtZW50LmdldCgndHlwZScpKTtcbiAgICAgICAgdmFyIGlzRXhjbHVkZWRFbmQgPSBleGNsdWRlZEVuZHMuZmluZChmdW5jdGlvbihleGNsdWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmlkID09PSBlbGVtZW50LmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzRXhjbHVkZWRBbmNlc3RvciA9IGV4Y2x1ZGVkQW5jZXN0b3JzLmluY2x1ZGVzKGVsZW1lbnQuaWQpO1xuXG4gICAgICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZFR5cGUgfHwgaXNFeGNsdWRlZEVuZCB8fCBpc0V4Y2x1ZGVkQW5jZXN0b3I7XG4gICAgICAgIGlmICghaXNFeGNsdWRlZCkge1xuICAgICAgICAgICAgdmFyIGJib3ggPSBlbGVtZW50LmdldEJCb3goKS5tb3ZlQW5kRXhwYW5kKG9wdC5wYWRkaW5nQm94KTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGJib3gub3JpZ2luKCkuc25hcFRvR3JpZChtYXBHcmlkU2l6ZSk7XG4gICAgICAgICAgICB2YXIgY29ybmVyID0gYmJveC5jb3JuZXIoKS5zbmFwVG9HcmlkKG1hcEdyaWRTaXplKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IG9yaWdpbi54OyB4IDw9IGNvcm5lci54OyB4ICs9IG1hcEdyaWRTaXplKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IG9yaWdpbi55OyB5IDw9IGNvcm5lci55OyB5ICs9IG1hcEdyaWRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmlkS2V5ID0geCArICdAJyArIHk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtncmlkS2V5XSA9IG1hcFtncmlkS2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWFwW2dyaWRLZXldLnB1c2goYmJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB0aGlzLm1hcCk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk9ic3RhY2xlTWFwLnByb3RvdHlwZS5pc1BvaW50QWNjZXNzaWJsZSA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cbiAgICB2YXIgbWFwS2V5ID0gcG9pbnQuY2xvbmUoKS5zbmFwVG9HcmlkKHRoaXMubWFwR3JpZFNpemUpLnRvU3RyaW5nKCk7XG5cbiAgICByZXR1cm4gdXRpbC50b0FycmF5KHRoaXMubWFwW21hcEtleV0pLmV2ZXJ5KGZ1bmN0aW9uKG9ic3RhY2xlKSB7XG4gICAgICAgIHJldHVybiAhb2JzdGFjbGUuY29udGFpbnNQb2ludChwb2ludCk7XG4gICAgfSk7XG59O1xuXG4vLyBTb3J0ZWQgU2V0XG4vLyBTZXQgb2YgaXRlbXMgc29ydGVkIGJ5IGdpdmVuIHZhbHVlLlxuZnVuY3Rpb24gU29ydGVkU2V0KCkge1xuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLmhhc2ggPSB7fTtcbiAgICB0aGlzLnZhbHVlcyA9IHt9O1xuICAgIHRoaXMuT1BFTiA9IDE7XG4gICAgdGhpcy5DTE9TRSA9IDI7XG59XG5cblNvcnRlZFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblxuICAgIGlmICh0aGlzLmhhc2hbaXRlbV0pIHtcbiAgICAgICAgLy8gaXRlbSByZW1vdmFsXG4gICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYXNoW2l0ZW1dID0gdGhpcy5PUEVOO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWVzW2l0ZW1dID0gdmFsdWU7XG5cbiAgICB2YXIgaW5kZXggPSB1dGlsLnNvcnRlZEluZGV4KHRoaXMuaXRlbXMsIGl0ZW0sIGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2ldO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG59O1xuXG5Tb3J0ZWRTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblxuICAgIHRoaXMuaGFzaFtpdGVtXSA9IHRoaXMuQ0xPU0U7XG59O1xuXG5Tb3J0ZWRTZXQucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uKGl0ZW0pIHtcblxuICAgIHJldHVybiB0aGlzLmhhc2hbaXRlbV0gPT09IHRoaXMuT1BFTjtcbn07XG5cblNvcnRlZFNldC5wcm90b3R5cGUuaXNDbG9zZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblxuICAgIHJldHVybiB0aGlzLmhhc2hbaXRlbV0gPT09IHRoaXMuQ0xPU0U7XG59O1xuXG5Tb3J0ZWRTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMDtcbn07XG5cblNvcnRlZFNldC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICB0aGlzLnJlbW92ZShpdGVtKTtcbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8vIEhFTFBFUlMgLy9cblxuLy8gcmV0dXJuIHNvdXJjZSBiYm94XG5mdW5jdGlvbiBnZXRTb3VyY2VCQm94KGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIC8vIGV4cGFuZCBieSBwYWRkaW5nIGJveFxuICAgIGlmIChvcHQgJiYgb3B0LnBhZGRpbmdCb3gpIHJldHVybiBsaW5rVmlldy5zb3VyY2VCQm94LmNsb25lKCkubW92ZUFuZEV4cGFuZChvcHQucGFkZGluZ0JveCk7XG5cbiAgICByZXR1cm4gbGlua1ZpZXcuc291cmNlQkJveC5jbG9uZSgpO1xufVxuXG4vLyByZXR1cm4gdGFyZ2V0IGJib3hcbmZ1bmN0aW9uIGdldFRhcmdldEJCb3gobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgLy8gZXhwYW5kIGJ5IHBhZGRpbmcgYm94XG4gICAgaWYgKG9wdCAmJiBvcHQucGFkZGluZ0JveCkgcmV0dXJuIGxpbmtWaWV3LnRhcmdldEJCb3guY2xvbmUoKS5tb3ZlQW5kRXhwYW5kKG9wdC5wYWRkaW5nQm94KTtcblxuICAgIHJldHVybiBsaW5rVmlldy50YXJnZXRCQm94LmNsb25lKCk7XG59XG5cbi8vIHJldHVybiBzb3VyY2UgYW5jaG9yXG5mdW5jdGlvbiBnZXRTb3VyY2VBbmNob3IobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgaWYgKGxpbmtWaWV3LnNvdXJjZUFuY2hvcikgcmV0dXJuIGxpbmtWaWV3LnNvdXJjZUFuY2hvcjtcblxuICAgIC8vIGZhbGxiYWNrOiBjZW50ZXIgb2YgYmJveFxuICAgIHZhciBzb3VyY2VCQm94ID0gZ2V0U291cmNlQkJveChsaW5rVmlldywgb3B0KTtcbiAgICByZXR1cm4gc291cmNlQkJveC5jZW50ZXIoKTtcbn1cblxuLy8gcmV0dXJuIHRhcmdldCBhbmNob3JcbmZ1bmN0aW9uIGdldFRhcmdldEFuY2hvcihsaW5rVmlldywgb3B0KSB7XG5cbiAgICBpZiAobGlua1ZpZXcudGFyZ2V0QW5jaG9yKSByZXR1cm4gbGlua1ZpZXcudGFyZ2V0QW5jaG9yO1xuXG4gICAgLy8gZmFsbGJhY2s6IGNlbnRlciBvZiBiYm94XG4gICAgdmFyIHRhcmdldEJCb3ggPSBnZXRUYXJnZXRCQm94KGxpbmtWaWV3LCBvcHQpO1xuICAgIHJldHVybiB0YXJnZXRCQm94LmNlbnRlcigpOyAvLyBkZWZhdWx0XG59XG5cbi8vIHJldHVybnMgYSBkaXJlY3Rpb24gaW5kZXggZnJvbSBzdGFydCBwb2ludCB0byBlbmQgcG9pbnRcbi8vIGNvcnJlY3RzIGZvciBncmlkIGRlZm9ybWF0aW9uIGJldHdlZW4gc3RhcnQgYW5kIGVuZFxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uQW5nbGUoc3RhcnQsIGVuZCwgbnVtRGlyZWN0aW9ucywgZ3JpZCwgb3B0KSB7XG5cbiAgICB2YXIgcXVhZHJhbnQgPSAzNjAgLyBudW1EaXJlY3Rpb25zO1xuICAgIHZhciBhbmdsZVRoZXRhID0gc3RhcnQudGhldGEoZml4QW5nbGVFbmQoc3RhcnQsIGVuZCwgZ3JpZCwgb3B0KSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRBbmdsZSA9IGcubm9ybWFsaXplQW5nbGUoYW5nbGVUaGV0YSArIChxdWFkcmFudCAvIDIpKTtcbiAgICByZXR1cm4gcXVhZHJhbnQgKiBNYXRoLmZsb29yKG5vcm1hbGl6ZWRBbmdsZSAvIHF1YWRyYW50KTtcbn1cblxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBnZXREaXJlY3Rpb25BbmdsZSgpXG4vLyBjb3JyZWN0cyBmb3IgZ3JpZCBkZWZvcm1hdGlvblxuLy8gKGlmIGEgcG9pbnQgaXMgb25lIGdyaWQgc3RlcHMgYXdheSBmcm9tIGFub3RoZXIgaW4gYm90aCBkaW1lbnNpb25zLFxuLy8gaXQgaXMgY29uc2lkZXJlZCB0byBiZSA0NSBkZWdyZWVzIGF3YXksIGV2ZW4gaWYgdGhlIHJlYWwgYW5nbGUgaXMgZGlmZmVyZW50KVxuLy8gdGhpcyBjYXVzZXMgdmlzaWJsZSBhbmdsZSBkaXNjcmVwYW5jaWVzIGlmIGBvcHQuc3RlcGAgaXMgbXVjaCBsYXJnZXIgdGhhbiBgcGFwZXIuZ3JpZFNpemVgXG5mdW5jdGlvbiBmaXhBbmdsZUVuZChzdGFydCwgZW5kLCBncmlkLCBvcHQpIHtcblxuICAgIHZhciBzdGVwID0gb3B0LnN0ZXA7XG5cbiAgICB2YXIgZGlmZlggPSBlbmQueCAtIHN0YXJ0Lng7XG4gICAgdmFyIGRpZmZZID0gZW5kLnkgLSBzdGFydC55O1xuXG4gICAgdmFyIGdyaWRTdGVwc1ggPSBkaWZmWCAvIGdyaWQueDtcbiAgICB2YXIgZ3JpZFN0ZXBzWSA9IGRpZmZZIC8gZ3JpZC55O1xuXG4gICAgdmFyIGRpc3RhbmNlWCA9IGdyaWRTdGVwc1ggKiBzdGVwO1xuICAgIHZhciBkaXN0YW5jZVkgPSBncmlkU3RlcHNZICogc3RlcDtcblxuICAgIHJldHVybiBuZXcgZy5Qb2ludChzdGFydC54ICsgZGlzdGFuY2VYLCBzdGFydC55ICsgZGlzdGFuY2VZKTtcbn1cblxuLy8gcmV0dXJuIHRoZSBjaGFuZ2UgaW4gZGlyZWN0aW9uIGJldHdlZW4gdHdvIGRpcmVjdGlvbiBhbmdsZXNcbmZ1bmN0aW9uIGdldERpcmVjdGlvbkNoYW5nZShhbmdsZTEsIGFuZ2xlMikge1xuXG4gICAgdmFyIGRpcmVjdGlvbkNoYW5nZSA9IE1hdGguYWJzKGFuZ2xlMSAtIGFuZ2xlMik7XG4gICAgcmV0dXJuIChkaXJlY3Rpb25DaGFuZ2UgPiAxODApID8gKDM2MCAtIGRpcmVjdGlvbkNoYW5nZSkgOiBkaXJlY3Rpb25DaGFuZ2U7XG59XG5cbi8vIGZpeCBkaXJlY3Rpb24gb2Zmc2V0cyBhY2NvcmRpbmcgdG8gY3VycmVudCBncmlkXG5mdW5jdGlvbiBnZXRHcmlkT2Zmc2V0cyhkaXJlY3Rpb25zLCBncmlkLCBvcHQpIHtcblxuICAgIHZhciBzdGVwID0gb3B0LnN0ZXA7XG5cbiAgICB1dGlsLnRvQXJyYXkob3B0LmRpcmVjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgZGlyZWN0aW9uLmdyaWRPZmZzZXRYID0gKGRpcmVjdGlvbi5vZmZzZXRYIC8gc3RlcCkgKiBncmlkLng7XG4gICAgICAgIGRpcmVjdGlvbi5ncmlkT2Zmc2V0WSA9IChkaXJlY3Rpb24ub2Zmc2V0WSAvIHN0ZXApICogZ3JpZC55O1xuICAgIH0pO1xufVxuXG4vLyBnZXQgZ3JpZCBzaXplIGluIHggYW5kIHkgZGltZW5zaW9ucywgYWRhcHRlZCB0byBzb3VyY2UgYW5kIHRhcmdldCBwb3NpdGlvbnNcbmZ1bmN0aW9uIGdldEdyaWQoc3RlcCwgc291cmNlLCB0YXJnZXQpIHtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLmNsb25lKCksXG4gICAgICAgIHg6IGdldEdyaWREaW1lbnNpb24odGFyZ2V0LnggLSBzb3VyY2UueCwgc3RlcCksXG4gICAgICAgIHk6IGdldEdyaWREaW1lbnNpb24odGFyZ2V0LnkgLSBzb3VyY2UueSwgc3RlcClcbiAgICB9O1xufVxuXG4vLyBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldEdyaWQoKVxuZnVuY3Rpb24gZ2V0R3JpZERpbWVuc2lvbihkaWZmLCBzdGVwKSB7XG5cbiAgICAvLyByZXR1cm4gc3RlcCBpZiBkaWZmID0gMFxuICAgIGlmICghZGlmZikgcmV0dXJuIHN0ZXA7XG5cbiAgICB2YXIgYWJzRGlmZiA9IE1hdGguYWJzKGRpZmYpO1xuICAgIHZhciBudW1TdGVwcyA9IE1hdGgucm91bmQoYWJzRGlmZiAvIHN0ZXApO1xuXG4gICAgLy8gcmV0dXJuIGFic0RpZmYgaWYgbGVzcyB0aGFuIG9uZSBzdGVwIGFwYXJ0XG4gICAgaWYgKCFudW1TdGVwcykgcmV0dXJuIGFic0RpZmY7XG5cbiAgICAvLyBvdGhlcndpc2UsIHJldHVybiBjb3JyZWN0ZWQgc3RlcFxuICAgIHZhciByb3VuZGVkRGlmZiA9IG51bVN0ZXBzICogc3RlcDtcbiAgICB2YXIgcmVtYWluZGVyID0gYWJzRGlmZiAtIHJvdW5kZWREaWZmO1xuICAgIHZhciBzdGVwQ29ycmVjdGlvbiA9IHJlbWFpbmRlciAvIG51bVN0ZXBzO1xuXG4gICAgcmV0dXJuIHN0ZXAgKyBzdGVwQ29ycmVjdGlvbjtcbn1cblxuLy8gcmV0dXJuIGEgY2xvbmUgb2YgcG9pbnQgc25hcHBlZCB0byBncmlkXG5mdW5jdGlvbiBzbmFwVG9HcmlkKHBvaW50LCBncmlkKSB7XG5cbiAgICB2YXIgc291cmNlID0gZ3JpZC5zb3VyY2U7XG5cbiAgICB2YXIgc25hcHBlZFggPSBnLnNuYXBUb0dyaWQocG9pbnQueCAtIHNvdXJjZS54LCBncmlkLngpICsgc291cmNlLng7XG4gICAgdmFyIHNuYXBwZWRZID0gZy5zbmFwVG9HcmlkKHBvaW50LnkgLSBzb3VyY2UueSwgZ3JpZC55KSArIHNvdXJjZS55O1xuXG4gICAgcmV0dXJuIG5ldyBnLlBvaW50KHNuYXBwZWRYLCBzbmFwcGVkWSk7XG59XG5cbi8vIHJvdW5kIHRoZSBwb2ludCB0byBvcHQucHJlY2lzaW9uXG5mdW5jdGlvbiByb3VuZChwb2ludCwgcHJlY2lzaW9uKSB7XG5cbiAgICByZXR1cm4gcG9pbnQucm91bmQocHJlY2lzaW9uKTtcbn1cblxuLy8gc25hcCB0byBncmlkIGFuZCB0aGVuIHJvdW5kIHRoZSBwb2ludFxuZnVuY3Rpb24gYWxpZ24ocG9pbnQsIGdyaWQsIHByZWNpc2lvbikge1xuXG4gICAgcmV0dXJuIHJvdW5kKHNuYXBUb0dyaWQocG9pbnQuY2xvbmUoKSwgZ3JpZCksIHByZWNpc2lvbik7XG59XG5cbi8vIHJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBvaW50XG4vLyBzdHJpbmcgaXMgcm91bmRlZCBpbiBib3RoIGRpbWVuc2lvbnNcbmZ1bmN0aW9uIGdldEtleShwb2ludCkge1xuXG4gICAgcmV0dXJuIHBvaW50LmNsb25lKCkudG9TdHJpbmcoKTtcbn1cblxuLy8gcmV0dXJuIGEgbm9ybWFsaXplZCB2ZWN0b3IgZnJvbSBnaXZlbiBwb2ludFxuLy8gdXNlZCB0byBkZXRlcm1pbmUgdGhlIGRpcmVjdGlvbiBvZiBhIGRpZmZlcmVuY2Ugb2YgdHdvIHBvaW50c1xuZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQocG9pbnQpIHtcblxuICAgIHJldHVybiBuZXcgZy5Qb2ludChcbiAgICAgICAgcG9pbnQueCA9PT0gMCA/IDAgOiBNYXRoLmFicyhwb2ludC54KSAvIHBvaW50LngsXG4gICAgICAgIHBvaW50LnkgPT09IDAgPyAwIDogTWF0aC5hYnMocG9pbnQueSkgLyBwb2ludC55XG4gICAgKTtcbn1cblxuLy8gUEFUSEZJTkRJTkcgLy9cblxuLy8gcmVjb25zdHJ1Y3RzIGEgcm91dGUgYnkgY29uY2F0ZW5hdGluZyBwb2ludHMgd2l0aCB0aGVpciBwYXJlbnRzXG5mdW5jdGlvbiByZWNvbnN0cnVjdFJvdXRlKHBhcmVudHMsIHBvaW50cywgdGFpbFBvaW50LCBmcm9tLCB0bywgZ3JpZCwgb3B0KSB7XG5cbiAgICB2YXIgcm91dGUgPSBbXTtcblxuICAgIHZhciBwcmV2RGlmZiA9IG5vcm1hbGl6ZVBvaW50KHRvLmRpZmZlcmVuY2UodGFpbFBvaW50KSk7XG5cbiAgICAvLyB0YWlsUG9pbnQgaXMgYXNzdW1lZCB0byBiZSBhbGlnbmVkIGFscmVhZHlcbiAgICB2YXIgY3VycmVudEtleSA9IGdldEtleSh0YWlsUG9pbnQpO1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2N1cnJlbnRLZXldO1xuXG4gICAgdmFyIHBvaW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcblxuICAgICAgICAvLyBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgYWxyZWFkeVxuICAgICAgICBwb2ludCA9IHBvaW50c1tjdXJyZW50S2V5XTtcblxuICAgICAgICB2YXIgZGlmZiA9IG5vcm1hbGl6ZVBvaW50KHBvaW50LmRpZmZlcmVuY2UocGFyZW50KSk7XG4gICAgICAgIGlmICghZGlmZi5lcXVhbHMocHJldkRpZmYpKSB7XG4gICAgICAgICAgICByb3V0ZS51bnNoaWZ0KHBvaW50KTtcbiAgICAgICAgICAgIHByZXZEaWZmID0gZGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcmVudCBpcyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgYWxyZWFkeVxuICAgICAgICBjdXJyZW50S2V5ID0gZ2V0S2V5KHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudHNbY3VycmVudEtleV07XG4gICAgfVxuXG4gICAgLy8gbGVhZFBvaW50IGlzIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCBhbHJlYWR5XG4gICAgdmFyIGxlYWRQb2ludCA9IHBvaW50c1tjdXJyZW50S2V5XTtcblxuICAgIHZhciBmcm9tRGlmZiA9IG5vcm1hbGl6ZVBvaW50KGxlYWRQb2ludC5kaWZmZXJlbmNlKGZyb20pKTtcbiAgICBpZiAoIWZyb21EaWZmLmVxdWFscyhwcmV2RGlmZikpIHtcbiAgICAgICAgcm91dGUudW5zaGlmdChsZWFkUG9pbnQpO1xuICAgIH1cblxuICAgIHJldHVybiByb3V0ZTtcbn1cblxuLy8gaGV1cmlzdGljIG1ldGhvZCB0byBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuZnVuY3Rpb24gZXN0aW1hdGVDb3N0KGZyb20sIGVuZFBvaW50cykge1xuXG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVuZFBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgY29zdCA9IGZyb20ubWFuaGF0dGFuRGlzdGFuY2UoZW5kUG9pbnRzW2ldKTtcbiAgICAgICAgaWYgKGNvc3QgPCBtaW4pIG1pbiA9IGNvc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbn1cblxuLy8gZmluZCBwb2ludHMgYXJvdW5kIHRoZSBiYm94IHRha2luZyBnaXZlbiBkaXJlY3Rpb25zIGludG8gYWNjb3VudFxuLy8gbGluZXMgYXJlIGRyYXduIGZyb20gYW5jaG9yIGluIGdpdmVuIGRpcmVjdGlvbnMsIGludGVyc2VjdGlvbnMgcmVjb3JkZWRcbi8vIGlmIGFuY2hvciBpcyBvdXRzaWRlIGJib3gsIG9ubHkgdGhvc2UgZGlyZWN0aW9ucyB0aGF0IGludGVyc2VjdCBnZXQgYSByZWN0IHBvaW50XG4vLyB0aGUgYW5jaG9yIGl0c2VsZiBpcyByZXR1cm5lZCBhcyByZWN0IHBvaW50IChyZXByZXNlbnRpbmcgc29tZSBkaXJlY3Rpb25zKVxuLy8gKHNpbmNlIHRob3NlIGRpcmVjdGlvbnMgYXJlIHVub2JzdHJ1Y3RlZCBieSB0aGUgYmJveClcbmZ1bmN0aW9uIGdldFJlY3RQb2ludHMoYW5jaG9yLCBiYm94LCBkaXJlY3Rpb25MaXN0LCBncmlkLCBvcHQpIHtcblxuICAgIHZhciBwcmVjaXNpb24gPSBvcHQucHJlY2lzaW9uO1xuICAgIHZhciBkaXJlY3Rpb25NYXAgPSBvcHQuZGlyZWN0aW9uTWFwO1xuXG4gICAgdmFyIGFuY2hvckNlbnRlclZlY3RvciA9IGFuY2hvci5kaWZmZXJlbmNlKGJib3guY2VudGVyKCkpO1xuXG4gICAgdmFyIGtleXMgPSB1dGlsLmlzT2JqZWN0KGRpcmVjdGlvbk1hcCkgPyBPYmplY3Qua2V5cyhkaXJlY3Rpb25NYXApIDogW107XG4gICAgdmFyIGRpckxpc3QgPSB1dGlsLnRvQXJyYXkoZGlyZWN0aW9uTGlzdCk7XG4gICAgdmFyIHJlY3RQb2ludHMgPSBrZXlzLnJlZHVjZShmdW5jdGlvbihyZXMsIGtleSkge1xuXG4gICAgICAgIGlmIChkaXJMaXN0LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25NYXBba2V5XTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbGluZSB0aGF0IGlzIGd1YXJhbnRlZWQgdG8gaW50ZXJzZWN0IHRoZSBiYm94IGlmIGJib3ggaXMgaW4gdGhlIGRpcmVjdGlvblxuICAgICAgICAgICAgLy8gZXZlbiBpZiBhbmNob3IgbGllcyBvdXRzaWRlIG9mIGJib3hcbiAgICAgICAgICAgIHZhciBlbmRwb2ludCA9IG5ldyBnLlBvaW50KFxuICAgICAgICAgICAgICAgIGFuY2hvci54ICsgZGlyZWN0aW9uLnggKiAoTWF0aC5hYnMoYW5jaG9yQ2VudGVyVmVjdG9yLngpICsgYmJveC53aWR0aCksXG4gICAgICAgICAgICAgICAgYW5jaG9yLnkgKyBkaXJlY3Rpb24ueSAqIChNYXRoLmFicyhhbmNob3JDZW50ZXJWZWN0b3IueSkgKyBiYm94LmhlaWdodClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uTGluZSA9IG5ldyBnLkxpbmUoYW5jaG9yLCBlbmRwb2ludCk7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgZmFydGhlciBpbnRlcnNlY3Rpb24sIGluIGNhc2UgdGhlcmUgYXJlIHR3b1xuICAgICAgICAgICAgLy8gKHRoYXQgaGFwcGVucyBpZiBhbmNob3IgbGllcyBuZXh0IHRvIGJib3gpXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdGlvbkxpbmUuaW50ZXJzZWN0KGJib3gpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIG51bUludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBmYXJ0aGVzdEludGVyc2VjdGlvbkRpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGZhcnRoZXN0SW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSW50ZXJzZWN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGFuY2hvci5zcXVhcmVkRGlzdGFuY2UoY3VycmVudEludGVyc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKChmYXJ0aGVzdEludGVyc2VjdGlvbkRpc3RhbmNlID09PSB1bmRlZmluZWQpIHx8IChkaXN0YW5jZSA+IGZhcnRoZXN0SW50ZXJzZWN0aW9uRGlzdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhcnRoZXN0SW50ZXJzZWN0aW9uRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZmFydGhlc3RJbnRlcnNlY3Rpb24gPSBjdXJyZW50SW50ZXJzZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYW4gaW50ZXJzZWN0aW9uIHdhcyBmb3VuZCBpbiB0aGlzIGRpcmVjdGlvbiwgaXQgaXMgb3VyIHJlY3RQb2ludFxuICAgICAgICAgICAgaWYgKGZhcnRoZXN0SW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gYWxpZ24oZmFydGhlc3RJbnRlcnNlY3Rpb24sIGdyaWQsIHByZWNpc2lvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcmVjdFBvaW50IGxpZXMgaW5zaWRlIHRoZSBiYm94LCBvZmZzZXQgaXQgYnkgb25lIG1vcmUgc3RlcFxuICAgICAgICAgICAgICAgIGlmIChiYm94LmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gYWxpZ24ocG9pbnQub2Zmc2V0KGRpcmVjdGlvbi54ICogZ3JpZC54LCBkaXJlY3Rpb24ueSAqIGdyaWQueSksIGdyaWQsIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBhZGQgdGhlIHBvaW50IHRvIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgICAgICAvLyBhbGlnbmVkXG4gICAgICAgICAgICAgICAgcmVzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBpZiBhbmNob3IgbGllcyBvdXRzaWRlIG9mIGJib3gsIGFkZCBpdCB0byB0aGUgYXJyYXkgb2YgcG9pbnRzXG4gICAgaWYgKCFiYm94LmNvbnRhaW5zUG9pbnQoYW5jaG9yKSkge1xuICAgICAgICAvLyBhbGlnbmVkXG4gICAgICAgIHJlY3RQb2ludHMucHVzaChhbGlnbihhbmNob3IsIGdyaWQsIHByZWNpc2lvbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZWN0UG9pbnRzO1xufVxuXG4vLyBmaW5kcyB0aGUgcm91dGUgYmV0d2VlbiB0d28gcG9pbnRzL3JlY3RhbmdsZXMgKGBmcm9tYCwgYHRvYCkgaW1wbGVtZW50aW5nIEEqIGFsZ29yaXRobVxuLy8gcmVjdGFuZ2xlcyBnZXQgcmVjdCBwb2ludHMgYXNzaWduZWQgYnkgZ2V0UmVjdFBvaW50cygpXG5mdW5jdGlvbiBmaW5kUm91dGUoZnJvbSwgdG8sIGlzUG9pbnRPYnN0YWNsZSwgb3B0KSB7XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gb3B0LnByZWNpc2lvbjtcblxuICAgIC8vIEdldCBncmlkIGZvciB0aGlzIHJvdXRlLlxuXG4gICAgdmFyIHNvdXJjZUFuY2hvciwgdGFyZ2V0QW5jaG9yO1xuXG4gICAgaWYgKGZyb20gaW5zdGFuY2VvZiBnLlJlY3QpIHsgLy8gYGZyb21gIGlzIHNvdXJjZUJCb3hcbiAgICAgICAgc291cmNlQW5jaG9yID0gcm91bmQoZ2V0U291cmNlQW5jaG9yKHRoaXMsIG9wdCkuY2xvbmUoKSwgcHJlY2lzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VBbmNob3IgPSByb3VuZChmcm9tLmNsb25lKCksIHByZWNpc2lvbik7XG4gICAgfVxuXG4gICAgaWYgKHRvIGluc3RhbmNlb2YgZy5SZWN0KSB7IC8vIGB0b2AgaXMgdGFyZ2V0QkJveFxuICAgICAgICB0YXJnZXRBbmNob3IgPSByb3VuZChnZXRUYXJnZXRBbmNob3IodGhpcywgb3B0KS5jbG9uZSgpLCBwcmVjaXNpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEFuY2hvciA9IHJvdW5kKHRvLmNsb25lKCksIHByZWNpc2lvbik7XG4gICAgfVxuXG4gICAgdmFyIGdyaWQgPSBnZXRHcmlkKG9wdC5zdGVwLCBzb3VyY2VBbmNob3IsIHRhcmdldEFuY2hvcik7XG5cbiAgICAvLyBHZXQgcGF0aGZpbmRpbmcgcG9pbnRzLlxuXG4gICAgdmFyIHN0YXJ0LCBlbmQ7IC8vIGFsaWduZWQgd2l0aCBncmlkIGJ5IGRlZmluaXRpb25cbiAgICB2YXIgc3RhcnRQb2ludHMsIGVuZFBvaW50czsgLy8gYXNzdW1lZCB0byBiZSBhbGlnbmVkIHdpdGggZ3JpZCBhbHJlYWR5XG5cbiAgICAvLyBzZXQgb2YgcG9pbnRzIHdlIHN0YXJ0IHBhdGhmaW5kaW5nIGZyb21cbiAgICBpZiAoZnJvbSBpbnN0YW5jZW9mIGcuUmVjdCkgeyAvLyBgZnJvbWAgaXMgc291cmNlQkJveFxuICAgICAgICBzdGFydCA9IHNvdXJjZUFuY2hvcjtcbiAgICAgICAgc3RhcnRQb2ludHMgPSBnZXRSZWN0UG9pbnRzKHN0YXJ0LCBmcm9tLCBvcHQuc3RhcnREaXJlY3Rpb25zLCBncmlkLCBvcHQpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzb3VyY2VBbmNob3I7XG4gICAgICAgIHN0YXJ0UG9pbnRzID0gW3N0YXJ0XTtcbiAgICB9XG5cbiAgICAvLyBzZXQgb2YgcG9pbnRzIHdlIHdhbnQgdGhlIHBhdGhmaW5kaW5nIHRvIGZpbmlzaCBhdFxuICAgIGlmICh0byBpbnN0YW5jZW9mIGcuUmVjdCkgeyAvLyBgdG9gIGlzIHRhcmdldEJCb3hcbiAgICAgICAgZW5kID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICBlbmRQb2ludHMgPSBnZXRSZWN0UG9pbnRzKHRhcmdldEFuY2hvciwgdG8sIG9wdC5lbmREaXJlY3Rpb25zLCBncmlkLCBvcHQpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdGFyZ2V0QW5jaG9yO1xuICAgICAgICBlbmRQb2ludHMgPSBbZW5kXTtcbiAgICB9XG5cbiAgICAvLyB0YWtlIGludG8gYWNjb3VudCBvbmx5IGFjY2Vzc2libGUgcmVjdCBwb2ludHMgKHRob3NlIG5vdCB1bmRlciBvYnN0YWNsZXMpXG4gICAgc3RhcnRQb2ludHMgPSBzdGFydFBvaW50cy5maWx0ZXIocCA9PiAhaXNQb2ludE9ic3RhY2xlKHApKTtcbiAgICBlbmRQb2ludHMgPSBlbmRQb2ludHMuZmlsdGVyKHAgPT4gIWlzUG9pbnRPYnN0YWNsZShwKSk7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzIGFuIGFjY2Vzc2libGUgcm91dGUgcG9pbnQgb24gYm90aCBzaWRlcy5cbiAgICAvLyBPdGhlcndpc2UsIHVzZSBmYWxsYmFja1JvdXRlKCkuXG4gICAgaWYgKHN0YXJ0UG9pbnRzLmxlbmd0aCA+IDAgJiYgZW5kUG9pbnRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAvLyBUaGUgc2V0IG9mIHRlbnRhdGl2ZSBwb2ludHMgdG8gYmUgZXZhbHVhdGVkLCBpbml0aWFsbHkgY29udGFpbmluZyB0aGUgc3RhcnQgcG9pbnRzLlxuICAgICAgICAvLyBSb3VuZGVkIHRvIG5lYXJlc3QgaW50ZWdlciBmb3Igc2ltcGxpY2l0eS5cbiAgICAgICAgdmFyIG9wZW5TZXQgPSBuZXcgU29ydGVkU2V0KCk7XG4gICAgICAgIC8vIEtlZXBzIHJlZmVyZW5jZSB0byBhY3R1YWwgcG9pbnRzIGZvciBnaXZlbiBlbGVtZW50cyBvZiB0aGUgb3BlbiBzZXQuXG4gICAgICAgIHZhciBwb2ludHMgPSB7fTtcbiAgICAgICAgLy8gS2VlcHMgcmVmZXJlbmNlIHRvIGEgcG9pbnQgdGhhdCBpcyBpbW1lZGlhdGUgcHJlZGVjZXNzb3Igb2YgZ2l2ZW4gZWxlbWVudC5cbiAgICAgICAgdmFyIHBhcmVudHMgPSB7fTtcbiAgICAgICAgLy8gQ29zdCBmcm9tIHN0YXJ0IHRvIGEgcG9pbnQgYWxvbmcgYmVzdCBrbm93biBwYXRoLlxuICAgICAgICB2YXIgY29zdHMgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHN0YXJ0UG9pbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgLy8gc3RhcnRQb2ludCBpcyBhc3N1bWVkIHRvIGJlIGFsaWduZWQgYWxyZWFkeVxuICAgICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFBvaW50c1tpXTtcblxuICAgICAgICAgICAgdmFyIGtleSA9IGdldEtleShzdGFydFBvaW50KTtcblxuICAgICAgICAgICAgb3BlblNldC5hZGQoa2V5LCBlc3RpbWF0ZUNvc3Qoc3RhcnRQb2ludCwgZW5kUG9pbnRzKSk7XG4gICAgICAgICAgICBwb2ludHNba2V5XSA9IHN0YXJ0UG9pbnQ7XG4gICAgICAgICAgICBjb3N0c1trZXldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2aW91c1JvdXRlRGlyZWN0aW9uQW5nbGUgPSBvcHQucHJldmlvdXNEaXJlY3Rpb25BbmdsZTsgLy8gdW5kZWZpbmVkIGZvciBmaXJzdCByb3V0ZVxuICAgICAgICB2YXIgaXNQYXRoQmVnaW5uaW5nID0gKHByZXZpb3VzUm91dGVEaXJlY3Rpb25BbmdsZSA9PT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAvLyBkaXJlY3Rpb25zXG4gICAgICAgIHZhciBkaXJlY3Rpb24sIGRpcmVjdGlvbkNoYW5nZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBvcHQuZGlyZWN0aW9ucztcbiAgICAgICAgZ2V0R3JpZE9mZnNldHMoZGlyZWN0aW9ucywgZ3JpZCwgb3B0KTtcblxuICAgICAgICB2YXIgbnVtRGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBlbmRQb2ludHNLZXlzID0gdXRpbC50b0FycmF5KGVuZFBvaW50cykucmVkdWNlKGZ1bmN0aW9uKHJlcywgZW5kUG9pbnQpIHtcbiAgICAgICAgICAgIC8vIGVuZFBvaW50IGlzIGFzc3VtZWQgdG8gYmUgYWxpZ25lZCBhbHJlYWR5XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBnZXRLZXkoZW5kUG9pbnQpO1xuICAgICAgICAgICAgcmVzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICAvLyBtYWluIHJvdXRlIGZpbmRpbmcgbG9vcFxuICAgICAgICB2YXIgbG9vcHNSZW1haW5pbmcgPSBvcHQubWF4aW11bUxvb3BzO1xuICAgICAgICB3aGlsZSAoIW9wZW5TZXQuaXNFbXB0eSgpICYmIGxvb3BzUmVtYWluaW5nID4gMCkge1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgY3VycmVudCBmcm9tIHRoZSBvcGVuIGxpc3RcbiAgICAgICAgICAgIHZhciBjdXJyZW50S2V5ID0gb3BlblNldC5wb3AoKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBwb2ludHNbY3VycmVudEtleV07XG4gICAgICAgICAgICB2YXIgY3VycmVudFBhcmVudCA9IHBhcmVudHNbY3VycmVudEtleV07XG4gICAgICAgICAgICB2YXIgY3VycmVudENvc3QgPSBjb3N0c1tjdXJyZW50S2V5XTtcblxuICAgICAgICAgICAgdmFyIGlzUm91dGVCZWdpbm5pbmcgPSAoY3VycmVudFBhcmVudCA9PT0gdW5kZWZpbmVkKTsgLy8gdW5kZWZpbmVkIGZvciByb3V0ZSBzdGFydHNcbiAgICAgICAgICAgIHZhciBpc1N0YXJ0ID0gY3VycmVudFBvaW50LmVxdWFscyhzdGFydCk7IC8vIChpcyBzb3VyY2UgYW5jaG9yIG9yIGBmcm9tYCBwb2ludCkgPSBjYW4gbGVhdmUgaW4gYW55IGRpcmVjdGlvblxuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEaXJlY3Rpb25BbmdsZTtcbiAgICAgICAgICAgIGlmICghaXNSb3V0ZUJlZ2lubmluZykgcHJldmlvdXNEaXJlY3Rpb25BbmdsZSA9IGdldERpcmVjdGlvbkFuZ2xlKGN1cnJlbnRQYXJlbnQsIGN1cnJlbnRQb2ludCwgbnVtRGlyZWN0aW9ucywgZ3JpZCwgb3B0KTsgLy8gYSB2ZXJ0ZXggb24gdGhlIHJvdXRlXG4gICAgICAgICAgICBlbHNlIGlmICghaXNQYXRoQmVnaW5uaW5nKSBwcmV2aW91c0RpcmVjdGlvbkFuZ2xlID0gcHJldmlvdXNSb3V0ZURpcmVjdGlvbkFuZ2xlOyAvLyBiZWdpbm5pbmcgb2Ygcm91dGUgb24gdGhlIHBhdGhcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1N0YXJ0KSBwcmV2aW91c0RpcmVjdGlvbkFuZ2xlID0gZ2V0RGlyZWN0aW9uQW5nbGUoc3RhcnQsIGN1cnJlbnRQb2ludCwgbnVtRGlyZWN0aW9ucywgZ3JpZCwgb3B0KTsgLy8gYmVnaW5uaW5nIG9mIHBhdGgsIHN0YXJ0IHJlY3QgcG9pbnRcbiAgICAgICAgICAgIGVsc2UgcHJldmlvdXNEaXJlY3Rpb25BbmdsZSA9IG51bGw7IC8vIGJlZ2lubmluZyBvZiBwYXRoLCBzb3VyY2UgYW5jaG9yIG9yIGBmcm9tYCBwb2ludFxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSByZWFjaGVkIGFueSBlbmRwb2ludFxuICAgICAgICAgICAgdmFyIHNhbWVQb2ludHMgPSBzdGFydFBvaW50cy5sZW5ndGggPT09IGVuZFBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoc2FtZVBvaW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhcnRQb2ludHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFydFBvaW50c1tqXS5lcXVhbHMoZW5kUG9pbnRzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtZVBvaW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2tpcEVuZENoZWNrID0gKGlzUm91dGVCZWdpbm5pbmcgJiYgc2FtZVBvaW50cyk7XG4gICAgICAgICAgICBpZiAoIXNraXBFbmRDaGVjayAmJiAoZW5kUG9pbnRzS2V5cy5pbmRleE9mKGN1cnJlbnRLZXkpID49IDApKSB7XG4gICAgICAgICAgICAgICAgb3B0LnByZXZpb3VzRGlyZWN0aW9uQW5nbGUgPSBwcmV2aW91c0RpcmVjdGlvbkFuZ2xlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvbnN0cnVjdFJvdXRlKHBhcmVudHMsIHBvaW50cywgY3VycmVudFBvaW50LCBzdGFydCwgZW5kLCBncmlkLCBvcHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBnbyBvdmVyIGFsbCBwb3NzaWJsZSBkaXJlY3Rpb25zIGFuZCBmaW5kIG5laWdoYm9yc1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bURpcmVjdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9IGRpcmVjdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uQW5nbGUgPSBkaXJlY3Rpb24uYW5nbGU7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uQ2hhbmdlID0gZ2V0RGlyZWN0aW9uQ2hhbmdlKHByZXZpb3VzRGlyZWN0aW9uQW5nbGUsIGRpcmVjdGlvbkFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkaXJlY3Rpb24gY2hhbmdlZCByYXBpZGx5LCBkb24ndCB1c2UgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgIC8vIGFueSBkaXJlY3Rpb24gaXMgYWxsb3dlZCBmb3Igc3RhcnRpbmcgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNQYXRoQmVnaW5uaW5nICYmIGlzU3RhcnQpICYmIGRpcmVjdGlvbkNoYW5nZSA+IG9wdC5tYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvclBvaW50ID0gYWxpZ24oY3VycmVudFBvaW50LmNsb25lKCkub2Zmc2V0KGRpcmVjdGlvbi5ncmlkT2Zmc2V0WCwgZGlyZWN0aW9uLmdyaWRPZmZzZXRZKSwgZ3JpZCwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JLZXkgPSBnZXRLZXkobmVpZ2hib3JQb2ludCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbG9zZWQgcG9pbnRzIGZyb20gdGhlIG9wZW5TZXQgd2VyZSBhbHJlYWR5IGV2YWx1YXRlZC5cbiAgICAgICAgICAgICAgICBpZiAob3BlblNldC5pc0Nsb3NlKG5laWdoYm9yS2V5KSB8fCBpc1BvaW50T2JzdGFjbGUobmVpZ2hib3JQb2ludCkpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIG9ubHkgZW50ZXIgZW5kIHBvaW50cyBhdCBhbiBhY2NlcHRhYmxlIGFuZ2xlLlxuICAgICAgICAgICAgICAgIGlmIChlbmRQb2ludHNLZXlzLmluZGV4T2YobmVpZ2hib3JLZXkpID49IDApIHsgLy8gbmVpZ2hib3IgaXMgYW4gZW5kIHBvaW50XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmVpZ2hib3JFbmQgPSBuZWlnaGJvclBvaW50LmVxdWFscyhlbmQpOyAvLyAoaXMgdGFyZ2V0IGFuY2hvciBvciBgdG9gIHBvaW50KSA9IGNhbiBiZSBlbnRlcmVkIGluIGFueSBkaXJlY3Rpb25cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmVpZ2hib3JFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmREaXJlY3Rpb25BbmdsZSA9IGdldERpcmVjdGlvbkFuZ2xlKG5laWdoYm9yUG9pbnQsIGVuZCwgbnVtRGlyZWN0aW9ucywgZ3JpZCwgb3B0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmREaXJlY3Rpb25DaGFuZ2UgPSBnZXREaXJlY3Rpb25DaGFuZ2UoZGlyZWN0aW9uQW5nbGUsIGVuZERpcmVjdGlvbkFuZ2xlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZERpcmVjdGlvbkNoYW5nZSA+IG9wdC5tYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGRpcmVjdGlvbiBpcyBvay5cblxuICAgICAgICAgICAgICAgIHZhciBuZWlnaGJvckNvc3QgPSBkaXJlY3Rpb24uY29zdDtcbiAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JQZW5hbHR5ID0gaXNTdGFydCA/IDAgOiBvcHQucGVuYWx0aWVzW2RpcmVjdGlvbkNoYW5nZV07IC8vIG5vIHBlbmFsdGllcyBmb3Igc3RhcnQgcG9pbnRcbiAgICAgICAgICAgICAgICB2YXIgY29zdEZyb21TdGFydCA9IGN1cnJlbnRDb3N0ICsgbmVpZ2hib3JDb3N0ICsgbmVpZ2hib3JQZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuU2V0LmlzT3BlbihuZWlnaGJvcktleSkgfHwgKGNvc3RGcm9tU3RhcnQgPCBjb3N0c1tuZWlnaGJvcktleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5laWdoYm9yIHBvaW50IGhhcyBub3QgYmVlbiBwcm9jZXNzZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIHRoZSBjb3N0IG9mIHRoZSBwYXRoIGZyb20gc3RhcnQgaXMgbG93ZXIgdGhhbiBwcmV2aW91c2x5IGNhbGN1bGF0ZWRcblxuICAgICAgICAgICAgICAgICAgICBwb2ludHNbbmVpZ2hib3JLZXldID0gbmVpZ2hib3JQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50c1tuZWlnaGJvcktleV0gPSBjdXJyZW50UG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvc3RzW25laWdoYm9yS2V5XSA9IGNvc3RGcm9tU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5TZXQuYWRkKG5laWdoYm9yS2V5LCBjb3N0RnJvbVN0YXJ0ICsgZXN0aW1hdGVDb3N0KG5laWdoYm9yUG9pbnQsIGVuZFBvaW50cykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9vcHNSZW1haW5pbmctLTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIHJvdXRlIGZvdW5kIChgdG9gIHBvaW50IGVpdGhlciB3YXNuJ3QgYWNjZXNzaWJsZSBvciBmaW5kaW5nIHJvdXRlIHRvb2tcbiAgICAvLyB3YXkgdG9vIG11Y2ggY2FsY3VsYXRpb24pXG4gICAgcmV0dXJuIG9wdC5mYWxsYmFja1JvdXRlLmNhbGwodGhpcywgc3RhcnQsIGVuZCwgb3B0KTtcbn1cblxuLy8gcmVzb2x2ZSBzb21lIG9mIHRoZSBvcHRpb25zXG5mdW5jdGlvbiByZXNvbHZlT3B0aW9ucyhvcHQpIHtcblxuICAgIG9wdC5kaXJlY3Rpb25zID0gdXRpbC5yZXN1bHQob3B0LCAnZGlyZWN0aW9ucycpO1xuICAgIG9wdC5wZW5hbHRpZXMgPSB1dGlsLnJlc3VsdChvcHQsICdwZW5hbHRpZXMnKTtcbiAgICBvcHQucGFkZGluZ0JveCA9IHV0aWwucmVzdWx0KG9wdCwgJ3BhZGRpbmdCb3gnKTtcbiAgICBvcHQucGFkZGluZyA9IHV0aWwucmVzdWx0KG9wdCwgJ3BhZGRpbmcnKTtcblxuICAgIGlmIChvcHQucGFkZGluZykge1xuICAgICAgICAvLyBpZiBib3RoIHByb3ZpZGVkLCBvcHQucGFkZGluZyB3aW5zIG92ZXIgb3B0LnBhZGRpbmdCb3hcbiAgICAgICAgdmFyIHNpZGVzID0gdXRpbC5ub3JtYWxpemVTaWRlcyhvcHQucGFkZGluZyk7XG4gICAgICAgIG9wdC5wYWRkaW5nQm94ID0ge1xuICAgICAgICAgICAgeDogLXNpZGVzLmxlZnQsXG4gICAgICAgICAgICB5OiAtc2lkZXMudG9wLFxuICAgICAgICAgICAgd2lkdGg6IHNpZGVzLmxlZnQgKyBzaWRlcy5yaWdodCxcbiAgICAgICAgICAgIGhlaWdodDogc2lkZXMudG9wICsgc2lkZXMuYm90dG9tXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdXRpbC50b0FycmF5KG9wdC5kaXJlY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuXG4gICAgICAgIHZhciBwb2ludDEgPSBuZXcgZy5Qb2ludCgwLCAwKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IG5ldyBnLlBvaW50KGRpcmVjdGlvbi5vZmZzZXRYLCBkaXJlY3Rpb24ub2Zmc2V0WSk7XG5cbiAgICAgICAgZGlyZWN0aW9uLmFuZ2xlID0gZy5ub3JtYWxpemVBbmdsZShwb2ludDEudGhldGEocG9pbnQyKSk7XG4gICAgfSk7XG59XG5cbi8vIGluaXRpYWxpemF0aW9uIG9mIHRoZSByb3V0ZSBmaW5kaW5nXG5mdW5jdGlvbiByb3V0ZXIodmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgIHJlc29sdmVPcHRpb25zKG9wdCk7XG5cbiAgICAvLyBlbmFibGUvZGlzYWJsZSBsaW5rVmlldyBwZXJwZW5kaWN1bGFyIG9wdGlvblxuICAgIGxpbmtWaWV3Lm9wdGlvbnMucGVycGVuZGljdWxhciA9ICEhb3B0LnBlcnBlbmRpY3VsYXI7XG5cbiAgICB2YXIgc291cmNlQkJveCA9IGdldFNvdXJjZUJCb3gobGlua1ZpZXcsIG9wdCk7XG4gICAgdmFyIHRhcmdldEJCb3ggPSBnZXRUYXJnZXRCQm94KGxpbmtWaWV3LCBvcHQpO1xuXG4gICAgdmFyIHNvdXJjZUFuY2hvciA9IGdldFNvdXJjZUFuY2hvcihsaW5rVmlldywgb3B0KTtcbiAgICAvL3ZhciB0YXJnZXRBbmNob3IgPSBnZXRUYXJnZXRBbmNob3IobGlua1ZpZXcsIG9wdCk7XG5cbiAgICAvLyBwYXRoZmluZGluZ1xuICAgIGxldCBpc1BvaW50T2JzdGFjbGU7XG4gICAgaWYgKHR5cGVvZiBvcHQuaXNQb2ludE9ic3RhY2xlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlzUG9pbnRPYnN0YWNsZSA9IG9wdC5pc1BvaW50T2JzdGFjbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IE9ic3RhY2xlTWFwKG9wdCk7XG4gICAgICAgIG1hcC5idWlsZChsaW5rVmlldy5wYXBlci5tb2RlbCwgbGlua1ZpZXcubW9kZWwpO1xuICAgICAgICBpc1BvaW50T2JzdGFjbGUgPSAocG9pbnQpID0+ICFtYXAuaXNQb2ludEFjY2Vzc2libGUocG9pbnQpO1xuICAgIH1cblxuICAgIHZhciBvbGRWZXJ0aWNlcyA9IHV0aWwudG9BcnJheSh2ZXJ0aWNlcykubWFwKGcuUG9pbnQpO1xuICAgIHZhciBuZXdWZXJ0aWNlcyA9IFtdO1xuICAgIHZhciB0YWlsUG9pbnQgPSBzb3VyY2VBbmNob3I7IC8vIHRoZSBvcmlnaW4gb2YgZmlyc3Qgcm91dGUncyBncmlkLCBkb2VzIG5vdCBuZWVkIHNuYXBwaW5nXG5cbiAgICAvLyBmaW5kIGEgcm91dGUgYnkgY29uY2F0ZW5hdGluZyBhbGwgcGFydGlhbCByb3V0ZXMgKHJvdXRlcyBuZWVkIHRvIHBhc3MgdGhyb3VnaCB2ZXJ0aWNlcylcbiAgICAvLyBzb3VyY2UgLT4gdmVydGV4WzFdIC0+IC4uLiAtPiB2ZXJ0ZXhbbl0gLT4gdGFyZ2V0XG4gICAgdmFyIHRvLCBmcm9tO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9sZFZlcnRpY2VzLmxlbmd0aDsgaSA8PSBsZW47IGkrKykge1xuXG4gICAgICAgIHZhciBwYXJ0aWFsUm91dGUgPSBudWxsO1xuXG4gICAgICAgIGZyb20gPSB0byB8fCBzb3VyY2VCQm94O1xuICAgICAgICB0byA9IG9sZFZlcnRpY2VzW2ldO1xuXG4gICAgICAgIGlmICghdG8pIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3QgaXRlcmF0aW9uXG4gICAgICAgICAgICAvLyB3ZSByYW4gdGhyb3VnaCBhbGwgdmVydGljZXMgaW4gb2xkVmVydGljZXNcbiAgICAgICAgICAgIC8vICd0bycgaXMgbm90IGEgdmVydGV4LlxuXG4gICAgICAgICAgICB0byA9IHRhcmdldEJCb3g7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwb2ludCAoaS5lLiBpdCdzIG5vdCBhbiBlbGVtZW50KSwgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCB1c2UgZHJhZ2dpbmcgcm91dGUgaW5zdGVhZCBvZiBtYWluIHJvdXRpbmcgbWV0aG9kIGlmIGl0IGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAgICAgICAgdmFyIGlzRW5kaW5nQXRQb2ludCA9ICFsaW5rVmlldy5tb2RlbC5nZXQoJ3NvdXJjZScpLmlkIHx8ICFsaW5rVmlldy5tb2RlbC5nZXQoJ3RhcmdldCcpLmlkO1xuXG4gICAgICAgICAgICBpZiAoaXNFbmRpbmdBdFBvaW50ICYmIHV0aWwuaXNGdW5jdGlvbihvcHQuZHJhZ2dpbmdSb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgYXJlIHBhc3NpbmcgcG9pbnRzIG9ubHkgKG5vdCByZWN0cykuXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdGcm9tID0gKGZyb20gPT09IHNvdXJjZUJCb3gpID8gc291cmNlQW5jaG9yIDogZnJvbTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ1RvID0gdG8ub3JpZ2luKCk7XG5cbiAgICAgICAgICAgICAgICBwYXJ0aWFsUm91dGUgPSBvcHQuZHJhZ2dpbmdSb3V0ZS5jYWxsKGxpbmtWaWV3LCBkcmFnRnJvbSwgZHJhZ1RvLCBvcHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgcGFydGlhbCByb3V0ZSBoYXMgbm90IGJlZW4gY2FsY3VsYXRlZCB5ZXQgdXNlIHRoZSBtYWluIHJvdXRpbmcgbWV0aG9kIHRvIGZpbmQgb25lXG4gICAgICAgIHBhcnRpYWxSb3V0ZSA9IHBhcnRpYWxSb3V0ZSB8fCBmaW5kUm91dGUuY2FsbChsaW5rVmlldywgZnJvbSwgdG8sIGlzUG9pbnRPYnN0YWNsZSwgb3B0KTtcblxuICAgICAgICBpZiAocGFydGlhbFJvdXRlID09PSBudWxsKSB7IC8vIHRoZSBwYXJ0aWFsIHJvdXRlIGNhbm5vdCBiZSBmb3VuZFxuICAgICAgICAgICAgcmV0dXJuIG9wdC5mYWxsYmFja1JvdXRlcih2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVhZFBvaW50ID0gcGFydGlhbFJvdXRlWzBdO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZmlyc3QgcG9pbnQgaWYgdGhlIHByZXZpb3VzIHBhcnRpYWwgcm91dGUgaGFkIHRoZSBzYW1lIHBvaW50IGFzIGxhc3RcbiAgICAgICAgaWYgKGxlYWRQb2ludCAmJiBsZWFkUG9pbnQuZXF1YWxzKHRhaWxQb2ludCkpIHBhcnRpYWxSb3V0ZS5zaGlmdCgpO1xuXG4gICAgICAgIC8vIHNhdmUgdGFpbFBvaW50IGZvciBuZXh0IGl0ZXJhdGlvblxuICAgICAgICB0YWlsUG9pbnQgPSBwYXJ0aWFsUm91dGVbcGFydGlhbFJvdXRlLmxlbmd0aCAtIDFdIHx8IHRhaWxQb2ludDtcblxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShuZXdWZXJ0aWNlcywgcGFydGlhbFJvdXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3VmVydGljZXM7XG59XG5cbi8vIHB1YmxpYyBmdW5jdGlvblxuZXhwb3J0IGNvbnN0IG1hbmhhdHRhbiA9IGZ1bmN0aW9uKHZlcnRpY2VzLCBvcHQsIGxpbmtWaWV3KSB7XG4gICAgcmV0dXJuIHJvdXRlcih2ZXJ0aWNlcywgdXRpbC5hc3NpZ24oe30sIGNvbmZpZywgb3B0KSwgbGlua1ZpZXcpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/manhattan.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/metro.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/metro.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   metro: function() { return /* binding */ metro; }\n/* harmony export */ });\n/* harmony import */ var _manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./manhattan.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/routers/manhattan.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n\n\n\n\nvar config = {\n\n    maxAllowedDirectionChange: 45,\n\n    // cost of a diagonal step\n    diagonalCost: function() {\n\n        var step = this.step;\n        return Math.ceil(Math.sqrt(step * step << 1));\n    },\n\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions: function() {\n\n        var step = this.step;\n        var cost = this.cost();\n        var diagonalCost = this.diagonalCost();\n\n        return [\n            { offsetX: step, offsetY: 0, cost: cost },\n            { offsetX: step, offsetY: step, cost: diagonalCost },\n            { offsetX: 0, offsetY: step, cost: cost },\n            { offsetX: -step, offsetY: step, cost: diagonalCost },\n            { offsetX: -step, offsetY: 0, cost: cost },\n            { offsetX: -step, offsetY: -step, cost: diagonalCost },\n            { offsetX: 0, offsetY: -step, cost: cost },\n            { offsetX: step, offsetY: -step, cost: diagonalCost }\n        ];\n    },\n\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute: function(from, to, opt) {\n\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n\n        var theta = from.theta(to);\n\n        var route = [];\n\n        var a = { x: to.x, y: from.y };\n        var b = { x: from.x, y: to.y };\n\n        if (theta % 180 > 90) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        var p1 = (theta % 90) < 45 ? a : b;\n        var l1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(from, p1);\n\n        var alpha = 90 * Math.ceil(theta / 90);\n\n        var p2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Point.fromPolar(l1.squaredLength(), _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.toRad(alpha + 135), p1);\n        var l2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Line(to, p2);\n\n        var intersectionPoint = l1.intersection(l2);\n        var point = intersectionPoint ? intersectionPoint : to;\n\n        var directionFrom = intersectionPoint ? point : from;\n\n        var quadrant = 360 / opt.directions.length;\n        var angleTheta = directionFrom.theta(to);\n        var normalizedAngle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeAngle(angleTheta + (quadrant / 2));\n        var directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n\n        opt.previousDirectionAngle = directionAngle;\n\n        if (point) route.push(point.round());\n        route.push(to);\n\n        return route;\n    }\n};\n\n// public function\nconst metro = function(vertices, opt, linkView) {\n\n    if (!_util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction(_manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__.manhattan)) {\n        throw new Error('Metro requires the manhattan router.');\n    }\n\n    return (0,_manhattan_mjs__WEBPACK_IMPORTED_MODULE_4__.manhattan)(vertices, _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.assign({}, config, opt), linkView);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9tZXRyby5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQ0Y7QUFDTjs7QUFFcEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYyxrREFBa0Q7QUFDaEUsY0FBYyx1Q0FBdUM7QUFDckQsY0FBYyxtREFBbUQ7QUFDakUsY0FBYyx3Q0FBd0M7QUFDdEQsY0FBYyxvREFBb0Q7QUFDbEUsY0FBYyx3Q0FBd0M7QUFDdEQsY0FBYztBQUNkO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw4Q0FBTTs7QUFFM0I7O0FBRUEsaUJBQWlCLCtDQUFPLCtCQUErQiwrQ0FBTztBQUM5RCxxQkFBcUIsOENBQU07O0FBRTNCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qix3REFBZ0I7QUFDOUM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTzs7QUFFUCxTQUFTLHVEQUFlLENBQUMscURBQVM7QUFDbEM7QUFDQTs7QUFFQSxXQUFXLHlEQUFTLFdBQVcsbURBQVcsR0FBRztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvbWV0cm8ubWpzPzg5NjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFuaGF0dGFuIH0gZnJvbSAnLi9tYW5oYXR0YW4ubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuaW1wb3J0ICogYXMgZyBmcm9tICcuLi9nL2luZGV4Lm1qcyc7XG5cbnZhciBjb25maWcgPSB7XG5cbiAgICBtYXhBbGxvd2VkRGlyZWN0aW9uQ2hhbmdlOiA0NSxcblxuICAgIC8vIGNvc3Qgb2YgYSBkaWFnb25hbCBzdGVwXG4gICAgZGlhZ29uYWxDb3N0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLnNxcnQoc3RlcCAqIHN0ZXAgPDwgMSkpO1xuICAgIH0sXG5cbiAgICAvLyBhbiBhcnJheSBvZiBkaXJlY3Rpb25zIHRvIGZpbmQgbmV4dCBwb2ludHMgb24gdGhlIHJvdXRlXG4gICAgLy8gZGlmZmVyZW50IGZyb20gc3RhcnQvZW5kIGRpcmVjdGlvbnNcbiAgICBkaXJlY3Rpb25zOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuc3RlcDtcbiAgICAgICAgdmFyIGNvc3QgPSB0aGlzLmNvc3QoKTtcbiAgICAgICAgdmFyIGRpYWdvbmFsQ29zdCA9IHRoaXMuZGlhZ29uYWxDb3N0KCk7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogc3RlcCwgb2Zmc2V0WTogMCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiBzdGVwLCBvZmZzZXRZOiBzdGVwLCBjb3N0OiBkaWFnb25hbENvc3QgfSxcbiAgICAgICAgICAgIHsgb2Zmc2V0WDogMCwgb2Zmc2V0WTogc3RlcCwgY29zdDogY29zdCB9LFxuICAgICAgICAgICAgeyBvZmZzZXRYOiAtc3RlcCwgb2Zmc2V0WTogc3RlcCwgY29zdDogZGlhZ29uYWxDb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IC1zdGVwLCBvZmZzZXRZOiAwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IC1zdGVwLCBvZmZzZXRZOiAtc3RlcCwgY29zdDogZGlhZ29uYWxDb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IDAsIG9mZnNldFk6IC1zdGVwLCBjb3N0OiBjb3N0IH0sXG4gICAgICAgICAgICB7IG9mZnNldFg6IHN0ZXAsIG9mZnNldFk6IC1zdGVwLCBjb3N0OiBkaWFnb25hbENvc3QgfVxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICAvLyBhIHNpbXBsZSByb3V0ZSB1c2VkIGluIHNpdHVhdGlvbnMgd2hlbiBtYWluIHJvdXRpbmcgbWV0aG9kIGZhaWxzXG4gICAgLy8gKGV4Y2VlZCBtYXggbnVtYmVyIG9mIGxvb3AgaXRlcmF0aW9ucywgaW5hY2Nlc3NpYmxlKVxuICAgIGZhbGxiYWNrUm91dGU6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHQpIHtcblxuICAgICAgICAvLyBGaW5kIGEgcm91dGUgd2hpY2ggYnJlYWtzIGJ5IDQ1IGRlZ3JlZXMgaWdub3JpbmcgYWxsIG9ic3RhY2xlcy5cblxuICAgICAgICB2YXIgdGhldGEgPSBmcm9tLnRoZXRhKHRvKTtcblxuICAgICAgICB2YXIgcm91dGUgPSBbXTtcblxuICAgICAgICB2YXIgYSA9IHsgeDogdG8ueCwgeTogZnJvbS55IH07XG4gICAgICAgIHZhciBiID0geyB4OiBmcm9tLngsIHk6IHRvLnkgfTtcblxuICAgICAgICBpZiAodGhldGEgJSAxODAgPiA5MCkge1xuICAgICAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICBiID0gdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwMSA9ICh0aGV0YSAlIDkwKSA8IDQ1ID8gYSA6IGI7XG4gICAgICAgIHZhciBsMSA9IG5ldyBnLkxpbmUoZnJvbSwgcDEpO1xuXG4gICAgICAgIHZhciBhbHBoYSA9IDkwICogTWF0aC5jZWlsKHRoZXRhIC8gOTApO1xuXG4gICAgICAgIHZhciBwMiA9IGcuUG9pbnQuZnJvbVBvbGFyKGwxLnNxdWFyZWRMZW5ndGgoKSwgZy50b1JhZChhbHBoYSArIDEzNSksIHAxKTtcbiAgICAgICAgdmFyIGwyID0gbmV3IGcuTGluZSh0bywgcDIpO1xuXG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IGwxLmludGVyc2VjdGlvbihsMik7XG4gICAgICAgIHZhciBwb2ludCA9IGludGVyc2VjdGlvblBvaW50ID8gaW50ZXJzZWN0aW9uUG9pbnQgOiB0bztcblxuICAgICAgICB2YXIgZGlyZWN0aW9uRnJvbSA9IGludGVyc2VjdGlvblBvaW50ID8gcG9pbnQgOiBmcm9tO1xuXG4gICAgICAgIHZhciBxdWFkcmFudCA9IDM2MCAvIG9wdC5kaXJlY3Rpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIGFuZ2xlVGhldGEgPSBkaXJlY3Rpb25Gcm9tLnRoZXRhKHRvKTtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRBbmdsZSA9IGcubm9ybWFsaXplQW5nbGUoYW5nbGVUaGV0YSArIChxdWFkcmFudCAvIDIpKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbkFuZ2xlID0gcXVhZHJhbnQgKiBNYXRoLmZsb29yKG5vcm1hbGl6ZWRBbmdsZSAvIHF1YWRyYW50KTtcblxuICAgICAgICBvcHQucHJldmlvdXNEaXJlY3Rpb25BbmdsZSA9IGRpcmVjdGlvbkFuZ2xlO1xuXG4gICAgICAgIGlmIChwb2ludCkgcm91dGUucHVzaChwb2ludC5yb3VuZCgpKTtcbiAgICAgICAgcm91dGUucHVzaCh0byk7XG5cbiAgICAgICAgcmV0dXJuIHJvdXRlO1xuICAgIH1cbn07XG5cbi8vIHB1YmxpYyBmdW5jdGlvblxuZXhwb3J0IGNvbnN0IG1ldHJvID0gZnVuY3Rpb24odmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgIGlmICghdXRpbC5pc0Z1bmN0aW9uKG1hbmhhdHRhbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRybyByZXF1aXJlcyB0aGUgbWFuaGF0dGFuIHJvdXRlci4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFuaGF0dGFuKHZlcnRpY2VzLCB1dGlsLmFzc2lnbih7fSwgY29uZmlnLCBvcHQpLCBsaW5rVmlldyk7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/metro.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/normal.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/normal.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normal: function() { return /* binding */ normal; }\n/* harmony export */ });\n// Does not make any changes to vertices.\n// Returns the arguments that are passed to it, unchanged.\nconst normal = function(vertices, opt, linkView) {\n\n    return vertices;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9ub3JtYWwubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ087O0FBRVA7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvbm9ybWFsLm1qcz85YjVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERvZXMgbm90IG1ha2UgYW55IGNoYW5nZXMgdG8gdmVydGljZXMuXG4vLyBSZXR1cm5zIHRoZSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkIHRvIGl0LCB1bmNoYW5nZWQuXG5leHBvcnQgY29uc3Qgbm9ybWFsID0gZnVuY3Rpb24odmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgIHJldHVybiB2ZXJ0aWNlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/normal.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/oneSide.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/oneSide.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   oneSide: function() { return /* binding */ oneSide; }\n/* harmony export */ });\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n\n\n// Routes the link always to/from a certain side\n//\n// Arguments:\n//   padding ... gap between the element and the first vertex. :: Default 40.\n//   side ... 'left' | 'right' | 'top' | 'bottom' :: Default 'bottom'.\n//\nconst oneSide = function(vertices, opt, linkView) {\n\n    var side = opt.side || 'bottom';\n    var padding = _util_index_mjs__WEBPACK_IMPORTED_MODULE_0__.normalizeSides(opt.padding || 40);\n\n    // LinkView contains cached source an target bboxes.\n    // Note that those are Geometry rectangle objects.\n    var sourceBBox = linkView.sourceBBox;\n    var targetBBox = linkView.targetBBox;\n    var sourcePoint = sourceBBox.center();\n    var targetPoint = targetBBox.center();\n\n    var coordinate, dimension, direction;\n\n    switch (side) {\n        case 'bottom':\n            direction = 1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'top':\n            direction = -1;\n            coordinate = 'y';\n            dimension = 'height';\n            break;\n        case 'left':\n            direction = -1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        case 'right':\n            direction = 1;\n            coordinate = 'x';\n            dimension = 'width';\n            break;\n        default:\n            throw new Error('Router: invalid side');\n    }\n\n    // move the points from the center of the element to outside of it.\n    sourcePoint[coordinate] += direction * (sourceBBox[dimension] / 2 + padding[side]);\n    targetPoint[coordinate] += direction * (targetBBox[dimension] / 2 + padding[side]);\n\n    // make link orthogonal (at least the first and last vertex).\n    if ((direction * (sourcePoint[coordinate] - targetPoint[coordinate])) > 0) {\n        targetPoint[coordinate] = sourcePoint[coordinate];\n    } else {\n        sourcePoint[coordinate] = targetPoint[coordinate];\n    }\n\n    return [sourcePoint].concat(vertices, targetPoint);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9vbmVTaWRlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQSxrQkFBa0IsMkRBQW1COztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9vbmVTaWRlLm1qcz9iMzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG4vLyBSb3V0ZXMgdGhlIGxpbmsgYWx3YXlzIHRvL2Zyb20gYSBjZXJ0YWluIHNpZGVcbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAgIHBhZGRpbmcgLi4uIGdhcCBiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCB0aGUgZmlyc3QgdmVydGV4LiA6OiBEZWZhdWx0IDQwLlxuLy8gICBzaWRlIC4uLiAnbGVmdCcgfCAncmlnaHQnIHwgJ3RvcCcgfCAnYm90dG9tJyA6OiBEZWZhdWx0ICdib3R0b20nLlxuLy9cbmV4cG9ydCBjb25zdCBvbmVTaWRlID0gZnVuY3Rpb24odmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcblxuICAgIHZhciBzaWRlID0gb3B0LnNpZGUgfHwgJ2JvdHRvbSc7XG4gICAgdmFyIHBhZGRpbmcgPSB1dGlsLm5vcm1hbGl6ZVNpZGVzKG9wdC5wYWRkaW5nIHx8IDQwKTtcblxuICAgIC8vIExpbmtWaWV3IGNvbnRhaW5zIGNhY2hlZCBzb3VyY2UgYW4gdGFyZ2V0IGJib3hlcy5cbiAgICAvLyBOb3RlIHRoYXQgdGhvc2UgYXJlIEdlb21ldHJ5IHJlY3RhbmdsZSBvYmplY3RzLlxuICAgIHZhciBzb3VyY2VCQm94ID0gbGlua1ZpZXcuc291cmNlQkJveDtcbiAgICB2YXIgdGFyZ2V0QkJveCA9IGxpbmtWaWV3LnRhcmdldEJCb3g7XG4gICAgdmFyIHNvdXJjZVBvaW50ID0gc291cmNlQkJveC5jZW50ZXIoKTtcbiAgICB2YXIgdGFyZ2V0UG9pbnQgPSB0YXJnZXRCQm94LmNlbnRlcigpO1xuXG4gICAgdmFyIGNvb3JkaW5hdGUsIGRpbWVuc2lvbiwgZGlyZWN0aW9uO1xuXG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd5JztcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBkaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneSc7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnaGVpZ2h0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgICAgICAgY29vcmRpbmF0ZSA9ICd4JztcbiAgICAgICAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSAneCc7XG4gICAgICAgICAgICBkaW1lbnNpb24gPSAnd2lkdGgnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdXRlcjogaW52YWxpZCBzaWRlJyk7XG4gICAgfVxuXG4gICAgLy8gbW92ZSB0aGUgcG9pbnRzIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZWxlbWVudCB0byBvdXRzaWRlIG9mIGl0LlxuICAgIHNvdXJjZVBvaW50W2Nvb3JkaW5hdGVdICs9IGRpcmVjdGlvbiAqIChzb3VyY2VCQm94W2RpbWVuc2lvbl0gLyAyICsgcGFkZGluZ1tzaWRlXSk7XG4gICAgdGFyZ2V0UG9pbnRbY29vcmRpbmF0ZV0gKz0gZGlyZWN0aW9uICogKHRhcmdldEJCb3hbZGltZW5zaW9uXSAvIDIgKyBwYWRkaW5nW3NpZGVdKTtcblxuICAgIC8vIG1ha2UgbGluayBvcnRob2dvbmFsIChhdCBsZWFzdCB0aGUgZmlyc3QgYW5kIGxhc3QgdmVydGV4KS5cbiAgICBpZiAoKGRpcmVjdGlvbiAqIChzb3VyY2VQb2ludFtjb29yZGluYXRlXSAtIHRhcmdldFBvaW50W2Nvb3JkaW5hdGVdKSkgPiAwKSB7XG4gICAgICAgIHRhcmdldFBvaW50W2Nvb3JkaW5hdGVdID0gc291cmNlUG9pbnRbY29vcmRpbmF0ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlUG9pbnRbY29vcmRpbmF0ZV0gPSB0YXJnZXRQb2ludFtjb29yZGluYXRlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NvdXJjZVBvaW50XS5jb25jYXQodmVydGljZXMsIHRhcmdldFBvaW50KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/oneSide.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/orthogonal.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/orthogonal.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orthogonal: function() { return /* binding */ orthogonal; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n// bearing -> opposite bearing\nvar opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n};\n\n// bearing -> radians\nvar radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n};\n\n// HELPERS //\n\n// returns a point `p` where lines p,p1 and p,p2 are perpendicular and p is not contained\n// in the given box\nfunction freeJoin(p1, p2, bbox) {\n\n    var p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p1.x, p2.y);\n    if (bbox.containsPoint(p)) p = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(p2.x, p1.y);\n    // kept for reference\n    // if (bbox.containsPoint(p)) p = null;\n\n    return p;\n}\n\n// returns either width or height of a bbox based on the given bearing\nfunction getBBoxSize(bbox, bearing) {\n\n    return bbox[(bearing === 'W' || bearing === 'E') ? 'width' : 'height'];\n}\n\n// simple bearing method (calculates only orthogonal cardinals)\nfunction getBearing(from, to) {\n\n    if (from.x === to.x) return (from.y > to.y) ? 'N' : 'S';\n    if (from.y === to.y) return (from.x > to.x) ? 'W' : 'E';\n    return null;\n}\n\n// transform point to a rect\nfunction getPointBox(p) {\n\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(p.x, p.y, 0, 0);\n}\n\nfunction getPaddingBox(opt) {\n\n    // if both provided, opt.padding wins over opt.elementPadding\n    var sides = _util_index_mjs__WEBPACK_IMPORTED_MODULE_2__.normalizeSides(opt.padding || opt.elementPadding || 20);\n\n    return {\n        x: -sides.left,\n        y: -sides.top,\n        width: sides.left + sides.right,\n        height: sides.top + sides.bottom\n    };\n}\n\n// return source bbox\nfunction getSourceBBox(linkView, opt) {\n\n    return linkView.sourceBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return target bbox\nfunction getTargetBBox(linkView, opt) {\n\n    return linkView.targetBBox.clone().moveAndExpand(getPaddingBox(opt));\n}\n\n// return source anchor\nfunction getSourceAnchor(linkView, opt) {\n\n    if (linkView.sourceAnchor) return linkView.sourceAnchor;\n\n    // fallback: center of bbox\n    var sourceBBox = getSourceBBox(linkView, opt);\n    return sourceBBox.center();\n}\n\n// return target anchor\nfunction getTargetAnchor(linkView, opt) {\n\n    if (linkView.targetAnchor) return linkView.targetAnchor;\n\n    // fallback: center of bbox\n    var targetBBox = getTargetBBox(linkView, opt);\n    return targetBBox.center(); // default\n}\n\n// PARTIAL ROUTERS //\n\nfunction vertexVertex(from, to, bearing) {\n\n    var p1 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from.x, to.y);\n    var p2 = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = opposites[bearing];\n\n    var p = (d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))) ? p1 : p2;\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction elementVertex(from, to, fromBBox) {\n\n    var p = freeJoin(from, to, fromBBox);\n\n    return { points: [p], direction: getBearing(p, to) };\n}\n\nfunction vertexElement(from, to, toBBox, bearing) {\n\n    var route = {};\n\n    var points = [new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from.x, to.y), new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to.x, from.y)];\n    var freePoints = points.filter(function(pt) {\n        return !toBBox.containsPoint(pt);\n    });\n    var freeBearingPoints = freePoints.filter(function(pt) {\n        return getBearing(pt, from) !== bearing;\n    });\n\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n        // Try to pick a point which bears the same direction as the previous segment.\n\n        p = freeBearingPoints.filter(function(pt) {\n            return getBearing(from, pt) === bearing;\n        }).pop();\n        p = p || freeBearingPoints[0];\n\n        route.points = [p];\n        route.direction = getBearing(p, to);\n\n    } else {\n        // Here we found only points which are either contained in the element or they would create\n        // a link segment going in opposite direction from the previous one.\n        // We take the point inside element and move it outside the element in the direction the\n        // route is going. Now we can join this point with the current end (using freeJoin).\n\n        p = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.difference(points, freePoints)[0];\n\n        var p2 = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to)).move(p, -getBBoxSize(toBBox, bearing) / 2);\n        var p1 = freeJoin(p2, from, toBBox);\n\n        route.points = [p1, p2];\n        route.direction = getBearing(p2, to);\n    }\n\n    return route;\n}\n\nfunction elementElement(from, to, fromBBox, toBBox) {\n\n    var route = elementVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n\n        route = elementVertex(from, to, fromBBox);\n        var p2 = route.points[0];\n\n        if (toBBox.containsPoint(p2)) {\n\n            var fromBorder = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(from)).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n            var toBorder = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point(to)).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n            var mid = (new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(fromBorder, toBorder)).midpoint();\n\n            var startRoute = elementVertex(from, mid, fromBBox);\n            var endRoute = vertexVertex(mid, to, startRoute.direction);\n\n            route.points = [startRoute.points[0], endRoute.points[0]];\n            route.direction = endRoute.direction;\n        }\n    }\n\n    return route;\n}\n\n// Finds route for situations where one element is inside the other.\n// Typically the route is directed outside the outer element first and\n// then back towards the inner element.\nfunction insideElement(from, to, fromBBox, toBBox, bearing) {\n\n    var route = {};\n    var boundary = fromBBox.union(toBBox).inflate(1);\n\n    // start from the point which is closer to the boundary\n    var reversed = boundary.center().distance(to) > boundary.center().distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n\n    var p1, p2, p3;\n\n    if (bearing) {\n        // Points on circle with radius equals 'W + H` are always outside the rectangle\n        // with width W and height H if the center of that circle is the center of that rectangle.\n        p1 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n        p1 = boundary.pointNearestToPoint(p1).move(p1, -1);\n\n    } else {\n        p1 = boundary.pointNearestToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n\n    if (p1.round().equals(p2.round())) {\n        p2 = _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point.fromPolar(boundary.width + boundary.height, _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.toRad(p1.theta(start)) + Math.PI / 2, end);\n        p2 = boundary.pointNearestToPoint(p2).move(end, 1).round();\n        p3 = freeJoin(p1, p2, boundary);\n        route.points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n\n    } else {\n        route.points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    route.direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n\n    return route;\n}\n\n// MAIN ROUTER //\n\n// Return points through which a connection needs to be drawn in order to obtain an orthogonal link\n// routing from source to target going through `vertices`.\nfunction orthogonal(vertices, opt, linkView) {\n\n    var sourceBBox = getSourceBBox(linkView, opt);\n    var targetBBox = getTargetBBox(linkView, opt);\n\n    var sourceAnchor = getSourceAnchor(linkView, opt);\n    var targetAnchor = getTargetAnchor(linkView, opt);\n\n    // if anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(getPointBox(sourceAnchor));\n    targetBBox = targetBBox.union(getPointBox(targetAnchor));\n\n    vertices = _util_index_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray(vertices).map(_g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Point);\n    vertices.unshift(sourceAnchor);\n    vertices.push(targetAnchor);\n\n    var bearing; // bearing of previous route segment\n\n    var orthogonalVertices = []; // the array of found orthogonal vertices to be returned\n    for (var i = 0, max = vertices.length - 1; i < max; i++) {\n\n        var route = null;\n\n        var from = vertices[i];\n        var to = vertices[i + 1];\n\n        var isOrthogonal = !!getBearing(from, to);\n\n        if (i === 0) { // source\n\n            if (i + 1 === max) { // route source -> target\n\n                // Expand one of the elements by 1px to detect situations when the two\n                // elements are positioned next to each other with no gap in between.\n                if (sourceBBox.intersect(targetBBox.clone().inflate(1))) {\n                    route = insideElement(from, to, sourceBBox, targetBBox);\n\n                } else if (!isOrthogonal) {\n                    route = elementElement(from, to, sourceBBox, targetBBox);\n                }\n\n            } else { // route source -> vertex\n\n                if (sourceBBox.containsPoint(to)) {\n                    route = insideElement(from, to, sourceBBox, getPointBox(to).moveAndExpand(getPaddingBox(opt)));\n\n                } else if (!isOrthogonal) {\n                    route = elementVertex(from, to, sourceBBox);\n                }\n            }\n\n        } else if (i + 1 === max) { // route vertex -> target\n\n            // prevent overlaps with previous line segment\n            var isOrthogonalLoop = isOrthogonal && getBearing(to, from) === bearing;\n\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = insideElement(from, to, getPointBox(from).moveAndExpand(getPaddingBox(opt)), targetBBox, bearing);\n\n            } else if (!isOrthogonal) {\n                route = vertexElement(from, to, targetBBox, bearing);\n            }\n\n        } else if (!isOrthogonal) { // route vertex -> vertex\n            route = vertexVertex(from, to, bearing);\n        }\n\n        // applicable to all routes:\n\n        // set bearing for next iteration\n        if (route) {\n            Array.prototype.push.apply(orthogonalVertices, route.points);\n            bearing = route.direction;\n\n        } else {\n            // orthogonal route and not looped\n            bearing = getBearing(from, to);\n        }\n\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < max) {\n            orthogonalVertices.push(to);\n        }\n    }\n\n    return orthogonalVertices;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9vcnRob2dvbmFsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9DO0FBQ007O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsK0NBQU87QUFDdkIsdUNBQXVDLCtDQUFPO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsOENBQU07QUFDckI7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsMkRBQW1COztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBOztBQUVBOztBQUVBLGlCQUFpQiwrQ0FBTztBQUN4QixpQkFBaUIsK0NBQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7O0FBRUEsc0JBQXNCLCtDQUFPLG9CQUFvQiwrQ0FBTztBQUN4RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHVEQUFlOztBQUUzQixzQkFBc0IsK0NBQU87QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtDQUFrQywrQ0FBTztBQUN6QyxnQ0FBZ0MsK0NBQU87QUFDdkMsMkJBQTJCLDhDQUFNOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtDQUFPO0FBQ3BCOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSwrQ0FBTyw2Q0FBNkMsK0NBQU87QUFDeEU7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxvREFBWSxlQUFlLCtDQUFPO0FBQ2pEO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQixpQ0FBaUM7QUFDakMsK0NBQStDLFNBQVM7O0FBRXhEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCOztBQUV2QixpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLGNBQWMsT0FBTzs7QUFFckI7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBLFVBQVUsMEJBQTBCOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7O0FBRUEsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3JvdXRlcnMvb3J0aG9nb25hbC5tanM/N2NkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBnIGZyb20gJy4uL2cvaW5kZXgubWpzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbC9pbmRleC5tanMnO1xuXG4vLyBiZWFyaW5nIC0+IG9wcG9zaXRlIGJlYXJpbmdcbnZhciBvcHBvc2l0ZXMgPSB7XG4gICAgTjogJ1MnLFxuICAgIFM6ICdOJyxcbiAgICBFOiAnVycsXG4gICAgVzogJ0UnXG59O1xuXG4vLyBiZWFyaW5nIC0+IHJhZGlhbnNcbnZhciByYWRpYW5zID0ge1xuICAgIE46IC1NYXRoLlBJIC8gMiAqIDMsXG4gICAgUzogLU1hdGguUEkgLyAyLFxuICAgIEU6IDAsXG4gICAgVzogTWF0aC5QSVxufTtcblxuLy8gSEVMUEVSUyAvL1xuXG4vLyByZXR1cm5zIGEgcG9pbnQgYHBgIHdoZXJlIGxpbmVzIHAscDEgYW5kIHAscDIgYXJlIHBlcnBlbmRpY3VsYXIgYW5kIHAgaXMgbm90IGNvbnRhaW5lZFxuLy8gaW4gdGhlIGdpdmVuIGJveFxuZnVuY3Rpb24gZnJlZUpvaW4ocDEsIHAyLCBiYm94KSB7XG5cbiAgICB2YXIgcCA9IG5ldyBnLlBvaW50KHAxLngsIHAyLnkpO1xuICAgIGlmIChiYm94LmNvbnRhaW5zUG9pbnQocCkpIHAgPSBuZXcgZy5Qb2ludChwMi54LCBwMS55KTtcbiAgICAvLyBrZXB0IGZvciByZWZlcmVuY2VcbiAgICAvLyBpZiAoYmJveC5jb250YWluc1BvaW50KHApKSBwID0gbnVsbDtcblxuICAgIHJldHVybiBwO1xufVxuXG4vLyByZXR1cm5zIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgb2YgYSBiYm94IGJhc2VkIG9uIHRoZSBnaXZlbiBiZWFyaW5nXG5mdW5jdGlvbiBnZXRCQm94U2l6ZShiYm94LCBiZWFyaW5nKSB7XG5cbiAgICByZXR1cm4gYmJveFsoYmVhcmluZyA9PT0gJ1cnIHx8IGJlYXJpbmcgPT09ICdFJykgPyAnd2lkdGgnIDogJ2hlaWdodCddO1xufVxuXG4vLyBzaW1wbGUgYmVhcmluZyBtZXRob2QgKGNhbGN1bGF0ZXMgb25seSBvcnRob2dvbmFsIGNhcmRpbmFscylcbmZ1bmN0aW9uIGdldEJlYXJpbmcoZnJvbSwgdG8pIHtcblxuICAgIGlmIChmcm9tLnggPT09IHRvLngpIHJldHVybiAoZnJvbS55ID4gdG8ueSkgPyAnTicgOiAnUyc7XG4gICAgaWYgKGZyb20ueSA9PT0gdG8ueSkgcmV0dXJuIChmcm9tLnggPiB0by54KSA/ICdXJyA6ICdFJztcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gdHJhbnNmb3JtIHBvaW50IHRvIGEgcmVjdFxuZnVuY3Rpb24gZ2V0UG9pbnRCb3gocCkge1xuXG4gICAgcmV0dXJuIG5ldyBnLlJlY3QocC54LCBwLnksIDAsIDApO1xufVxuXG5mdW5jdGlvbiBnZXRQYWRkaW5nQm94KG9wdCkge1xuXG4gICAgLy8gaWYgYm90aCBwcm92aWRlZCwgb3B0LnBhZGRpbmcgd2lucyBvdmVyIG9wdC5lbGVtZW50UGFkZGluZ1xuICAgIHZhciBzaWRlcyA9IHV0aWwubm9ybWFsaXplU2lkZXMob3B0LnBhZGRpbmcgfHwgb3B0LmVsZW1lbnRQYWRkaW5nIHx8IDIwKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IC1zaWRlcy5sZWZ0LFxuICAgICAgICB5OiAtc2lkZXMudG9wLFxuICAgICAgICB3aWR0aDogc2lkZXMubGVmdCArIHNpZGVzLnJpZ2h0LFxuICAgICAgICBoZWlnaHQ6IHNpZGVzLnRvcCArIHNpZGVzLmJvdHRvbVxuICAgIH07XG59XG5cbi8vIHJldHVybiBzb3VyY2UgYmJveFxuZnVuY3Rpb24gZ2V0U291cmNlQkJveChsaW5rVmlldywgb3B0KSB7XG5cbiAgICByZXR1cm4gbGlua1ZpZXcuc291cmNlQkJveC5jbG9uZSgpLm1vdmVBbmRFeHBhbmQoZ2V0UGFkZGluZ0JveChvcHQpKTtcbn1cblxuLy8gcmV0dXJuIHRhcmdldCBiYm94XG5mdW5jdGlvbiBnZXRUYXJnZXRCQm94KGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIHJldHVybiBsaW5rVmlldy50YXJnZXRCQm94LmNsb25lKCkubW92ZUFuZEV4cGFuZChnZXRQYWRkaW5nQm94KG9wdCkpO1xufVxuXG4vLyByZXR1cm4gc291cmNlIGFuY2hvclxuZnVuY3Rpb24gZ2V0U291cmNlQW5jaG9yKGxpbmtWaWV3LCBvcHQpIHtcblxuICAgIGlmIChsaW5rVmlldy5zb3VyY2VBbmNob3IpIHJldHVybiBsaW5rVmlldy5zb3VyY2VBbmNob3I7XG5cbiAgICAvLyBmYWxsYmFjazogY2VudGVyIG9mIGJib3hcbiAgICB2YXIgc291cmNlQkJveCA9IGdldFNvdXJjZUJCb3gobGlua1ZpZXcsIG9wdCk7XG4gICAgcmV0dXJuIHNvdXJjZUJCb3guY2VudGVyKCk7XG59XG5cbi8vIHJldHVybiB0YXJnZXQgYW5jaG9yXG5mdW5jdGlvbiBnZXRUYXJnZXRBbmNob3IobGlua1ZpZXcsIG9wdCkge1xuXG4gICAgaWYgKGxpbmtWaWV3LnRhcmdldEFuY2hvcikgcmV0dXJuIGxpbmtWaWV3LnRhcmdldEFuY2hvcjtcblxuICAgIC8vIGZhbGxiYWNrOiBjZW50ZXIgb2YgYmJveFxuICAgIHZhciB0YXJnZXRCQm94ID0gZ2V0VGFyZ2V0QkJveChsaW5rVmlldywgb3B0KTtcbiAgICByZXR1cm4gdGFyZ2V0QkJveC5jZW50ZXIoKTsgLy8gZGVmYXVsdFxufVxuXG4vLyBQQVJUSUFMIFJPVVRFUlMgLy9cblxuZnVuY3Rpb24gdmVydGV4VmVydGV4KGZyb20sIHRvLCBiZWFyaW5nKSB7XG5cbiAgICB2YXIgcDEgPSBuZXcgZy5Qb2ludChmcm9tLngsIHRvLnkpO1xuICAgIHZhciBwMiA9IG5ldyBnLlBvaW50KHRvLngsIGZyb20ueSk7XG4gICAgdmFyIGQxID0gZ2V0QmVhcmluZyhmcm9tLCBwMSk7XG4gICAgdmFyIGQyID0gZ2V0QmVhcmluZyhmcm9tLCBwMik7XG4gICAgdmFyIG9wcG9zaXRlID0gb3Bwb3NpdGVzW2JlYXJpbmddO1xuXG4gICAgdmFyIHAgPSAoZDEgPT09IGJlYXJpbmcgfHwgKGQxICE9PSBvcHBvc2l0ZSAmJiAoZDIgPT09IG9wcG9zaXRlIHx8IGQyICE9PSBiZWFyaW5nKSkpID8gcDEgOiBwMjtcblxuICAgIHJldHVybiB7IHBvaW50czogW3BdLCBkaXJlY3Rpb246IGdldEJlYXJpbmcocCwgdG8pIH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRWZXJ0ZXgoZnJvbSwgdG8sIGZyb21CQm94KSB7XG5cbiAgICB2YXIgcCA9IGZyZWVKb2luKGZyb20sIHRvLCBmcm9tQkJveCk7XG5cbiAgICByZXR1cm4geyBwb2ludHM6IFtwXSwgZGlyZWN0aW9uOiBnZXRCZWFyaW5nKHAsIHRvKSB9O1xufVxuXG5mdW5jdGlvbiB2ZXJ0ZXhFbGVtZW50KGZyb20sIHRvLCB0b0JCb3gsIGJlYXJpbmcpIHtcblxuICAgIHZhciByb3V0ZSA9IHt9O1xuXG4gICAgdmFyIHBvaW50cyA9IFtuZXcgZy5Qb2ludChmcm9tLngsIHRvLnkpLCBuZXcgZy5Qb2ludCh0by54LCBmcm9tLnkpXTtcbiAgICB2YXIgZnJlZVBvaW50cyA9IHBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcbiAgICAgICAgcmV0dXJuICF0b0JCb3guY29udGFpbnNQb2ludChwdCk7XG4gICAgfSk7XG4gICAgdmFyIGZyZWVCZWFyaW5nUG9pbnRzID0gZnJlZVBvaW50cy5maWx0ZXIoZnVuY3Rpb24ocHQpIHtcbiAgICAgICAgcmV0dXJuIGdldEJlYXJpbmcocHQsIGZyb20pICE9PSBiZWFyaW5nO1xuICAgIH0pO1xuXG4gICAgdmFyIHA7XG5cbiAgICBpZiAoZnJlZUJlYXJpbmdQb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUcnkgdG8gcGljayBhIHBvaW50IHdoaWNoIGJlYXJzIHRoZSBzYW1lIGRpcmVjdGlvbiBhcyB0aGUgcHJldmlvdXMgc2VnbWVudC5cblxuICAgICAgICBwID0gZnJlZUJlYXJpbmdQb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmVhcmluZyhmcm9tLCBwdCkgPT09IGJlYXJpbmc7XG4gICAgICAgIH0pLnBvcCgpO1xuICAgICAgICBwID0gcCB8fCBmcmVlQmVhcmluZ1BvaW50c1swXTtcblxuICAgICAgICByb3V0ZS5wb2ludHMgPSBbcF07XG4gICAgICAgIHJvdXRlLmRpcmVjdGlvbiA9IGdldEJlYXJpbmcocCwgdG8pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGVyZSB3ZSBmb3VuZCBvbmx5IHBvaW50cyB3aGljaCBhcmUgZWl0aGVyIGNvbnRhaW5lZCBpbiB0aGUgZWxlbWVudCBvciB0aGV5IHdvdWxkIGNyZWF0ZVxuICAgICAgICAvLyBhIGxpbmsgc2VnbWVudCBnb2luZyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb24gZnJvbSB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICAvLyBXZSB0YWtlIHRoZSBwb2ludCBpbnNpZGUgZWxlbWVudCBhbmQgbW92ZSBpdCBvdXRzaWRlIHRoZSBlbGVtZW50IGluIHRoZSBkaXJlY3Rpb24gdGhlXG4gICAgICAgIC8vIHJvdXRlIGlzIGdvaW5nLiBOb3cgd2UgY2FuIGpvaW4gdGhpcyBwb2ludCB3aXRoIHRoZSBjdXJyZW50IGVuZCAodXNpbmcgZnJlZUpvaW4pLlxuXG4gICAgICAgIHAgPSB1dGlsLmRpZmZlcmVuY2UocG9pbnRzLCBmcmVlUG9pbnRzKVswXTtcblxuICAgICAgICB2YXIgcDIgPSAobmV3IGcuUG9pbnQodG8pKS5tb3ZlKHAsIC1nZXRCQm94U2l6ZSh0b0JCb3gsIGJlYXJpbmcpIC8gMik7XG4gICAgICAgIHZhciBwMSA9IGZyZWVKb2luKHAyLCBmcm9tLCB0b0JCb3gpO1xuXG4gICAgICAgIHJvdXRlLnBvaW50cyA9IFtwMSwgcDJdO1xuICAgICAgICByb3V0ZS5kaXJlY3Rpb24gPSBnZXRCZWFyaW5nKHAyLCB0byk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdXRlO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50RWxlbWVudChmcm9tLCB0bywgZnJvbUJCb3gsIHRvQkJveCkge1xuXG4gICAgdmFyIHJvdXRlID0gZWxlbWVudFZlcnRleCh0bywgZnJvbSwgdG9CQm94KTtcbiAgICB2YXIgcDEgPSByb3V0ZS5wb2ludHNbMF07XG5cbiAgICBpZiAoZnJvbUJCb3guY29udGFpbnNQb2ludChwMSkpIHtcblxuICAgICAgICByb3V0ZSA9IGVsZW1lbnRWZXJ0ZXgoZnJvbSwgdG8sIGZyb21CQm94KTtcbiAgICAgICAgdmFyIHAyID0gcm91dGUucG9pbnRzWzBdO1xuXG4gICAgICAgIGlmICh0b0JCb3guY29udGFpbnNQb2ludChwMikpIHtcblxuICAgICAgICAgICAgdmFyIGZyb21Cb3JkZXIgPSAobmV3IGcuUG9pbnQoZnJvbSkpLm1vdmUocDIsIC1nZXRCQm94U2l6ZShmcm9tQkJveCwgZ2V0QmVhcmluZyhmcm9tLCBwMikpIC8gMik7XG4gICAgICAgICAgICB2YXIgdG9Cb3JkZXIgPSAobmV3IGcuUG9pbnQodG8pKS5tb3ZlKHAxLCAtZ2V0QkJveFNpemUodG9CQm94LCBnZXRCZWFyaW5nKHRvLCBwMSkpIC8gMik7XG4gICAgICAgICAgICB2YXIgbWlkID0gKG5ldyBnLkxpbmUoZnJvbUJvcmRlciwgdG9Cb3JkZXIpKS5taWRwb2ludCgpO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnRSb3V0ZSA9IGVsZW1lbnRWZXJ0ZXgoZnJvbSwgbWlkLCBmcm9tQkJveCk7XG4gICAgICAgICAgICB2YXIgZW5kUm91dGUgPSB2ZXJ0ZXhWZXJ0ZXgobWlkLCB0bywgc3RhcnRSb3V0ZS5kaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICByb3V0ZS5wb2ludHMgPSBbc3RhcnRSb3V0ZS5wb2ludHNbMF0sIGVuZFJvdXRlLnBvaW50c1swXV07XG4gICAgICAgICAgICByb3V0ZS5kaXJlY3Rpb24gPSBlbmRSb3V0ZS5kaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGU7XG59XG5cbi8vIEZpbmRzIHJvdXRlIGZvciBzaXR1YXRpb25zIHdoZXJlIG9uZSBlbGVtZW50IGlzIGluc2lkZSB0aGUgb3RoZXIuXG4vLyBUeXBpY2FsbHkgdGhlIHJvdXRlIGlzIGRpcmVjdGVkIG91dHNpZGUgdGhlIG91dGVyIGVsZW1lbnQgZmlyc3QgYW5kXG4vLyB0aGVuIGJhY2sgdG93YXJkcyB0aGUgaW5uZXIgZWxlbWVudC5cbmZ1bmN0aW9uIGluc2lkZUVsZW1lbnQoZnJvbSwgdG8sIGZyb21CQm94LCB0b0JCb3gsIGJlYXJpbmcpIHtcblxuICAgIHZhciByb3V0ZSA9IHt9O1xuICAgIHZhciBib3VuZGFyeSA9IGZyb21CQm94LnVuaW9uKHRvQkJveCkuaW5mbGF0ZSgxKTtcblxuICAgIC8vIHN0YXJ0IGZyb20gdGhlIHBvaW50IHdoaWNoIGlzIGNsb3NlciB0byB0aGUgYm91bmRhcnlcbiAgICB2YXIgcmV2ZXJzZWQgPSBib3VuZGFyeS5jZW50ZXIoKS5kaXN0YW5jZSh0bykgPiBib3VuZGFyeS5jZW50ZXIoKS5kaXN0YW5jZShmcm9tKTtcbiAgICB2YXIgc3RhcnQgPSByZXZlcnNlZCA/IHRvIDogZnJvbTtcbiAgICB2YXIgZW5kID0gcmV2ZXJzZWQgPyBmcm9tIDogdG87XG5cbiAgICB2YXIgcDEsIHAyLCBwMztcblxuICAgIGlmIChiZWFyaW5nKSB7XG4gICAgICAgIC8vIFBvaW50cyBvbiBjaXJjbGUgd2l0aCByYWRpdXMgZXF1YWxzICdXICsgSGAgYXJlIGFsd2F5cyBvdXRzaWRlIHRoZSByZWN0YW5nbGVcbiAgICAgICAgLy8gd2l0aCB3aWR0aCBXIGFuZCBoZWlnaHQgSCBpZiB0aGUgY2VudGVyIG9mIHRoYXQgY2lyY2xlIGlzIHRoZSBjZW50ZXIgb2YgdGhhdCByZWN0YW5nbGUuXG4gICAgICAgIHAxID0gZy5Qb2ludC5mcm9tUG9sYXIoYm91bmRhcnkud2lkdGggKyBib3VuZGFyeS5oZWlnaHQsIHJhZGlhbnNbYmVhcmluZ10sIHN0YXJ0KTtcbiAgICAgICAgcDEgPSBib3VuZGFyeS5wb2ludE5lYXJlc3RUb1BvaW50KHAxKS5tb3ZlKHAxLCAtMSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwMSA9IGJvdW5kYXJ5LnBvaW50TmVhcmVzdFRvUG9pbnQoc3RhcnQpLm1vdmUoc3RhcnQsIDEpO1xuICAgIH1cblxuICAgIHAyID0gZnJlZUpvaW4ocDEsIGVuZCwgYm91bmRhcnkpO1xuXG4gICAgaWYgKHAxLnJvdW5kKCkuZXF1YWxzKHAyLnJvdW5kKCkpKSB7XG4gICAgICAgIHAyID0gZy5Qb2ludC5mcm9tUG9sYXIoYm91bmRhcnkud2lkdGggKyBib3VuZGFyeS5oZWlnaHQsIGcudG9SYWQocDEudGhldGEoc3RhcnQpKSArIE1hdGguUEkgLyAyLCBlbmQpO1xuICAgICAgICBwMiA9IGJvdW5kYXJ5LnBvaW50TmVhcmVzdFRvUG9pbnQocDIpLm1vdmUoZW5kLCAxKS5yb3VuZCgpO1xuICAgICAgICBwMyA9IGZyZWVKb2luKHAxLCBwMiwgYm91bmRhcnkpO1xuICAgICAgICByb3V0ZS5wb2ludHMgPSByZXZlcnNlZCA/IFtwMiwgcDMsIHAxXSA6IFtwMSwgcDMsIHAyXTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlLnBvaW50cyA9IHJldmVyc2VkID8gW3AyLCBwMV0gOiBbcDEsIHAyXTtcbiAgICB9XG5cbiAgICByb3V0ZS5kaXJlY3Rpb24gPSByZXZlcnNlZCA/IGdldEJlYXJpbmcocDEsIHRvKSA6IGdldEJlYXJpbmcocDIsIHRvKTtcblxuICAgIHJldHVybiByb3V0ZTtcbn1cblxuLy8gTUFJTiBST1VURVIgLy9cblxuLy8gUmV0dXJuIHBvaW50cyB0aHJvdWdoIHdoaWNoIGEgY29ubmVjdGlvbiBuZWVkcyB0byBiZSBkcmF3biBpbiBvcmRlciB0byBvYnRhaW4gYW4gb3J0aG9nb25hbCBsaW5rXG4vLyByb3V0aW5nIGZyb20gc291cmNlIHRvIHRhcmdldCBnb2luZyB0aHJvdWdoIGB2ZXJ0aWNlc2AuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG9nb25hbCh2ZXJ0aWNlcywgb3B0LCBsaW5rVmlldykge1xuXG4gICAgdmFyIHNvdXJjZUJCb3ggPSBnZXRTb3VyY2VCQm94KGxpbmtWaWV3LCBvcHQpO1xuICAgIHZhciB0YXJnZXRCQm94ID0gZ2V0VGFyZ2V0QkJveChsaW5rVmlldywgb3B0KTtcblxuICAgIHZhciBzb3VyY2VBbmNob3IgPSBnZXRTb3VyY2VBbmNob3IobGlua1ZpZXcsIG9wdCk7XG4gICAgdmFyIHRhcmdldEFuY2hvciA9IGdldFRhcmdldEFuY2hvcihsaW5rVmlldywgb3B0KTtcblxuICAgIC8vIGlmIGFuY2hvciBsaWVzIG91dHNpZGUgb2YgYmJveCwgdGhlIGJib3ggZXhwYW5kcyB0byBpbmNsdWRlIGl0XG4gICAgc291cmNlQkJveCA9IHNvdXJjZUJCb3gudW5pb24oZ2V0UG9pbnRCb3goc291cmNlQW5jaG9yKSk7XG4gICAgdGFyZ2V0QkJveCA9IHRhcmdldEJCb3gudW5pb24oZ2V0UG9pbnRCb3godGFyZ2V0QW5jaG9yKSk7XG5cbiAgICB2ZXJ0aWNlcyA9IHV0aWwudG9BcnJheSh2ZXJ0aWNlcykubWFwKGcuUG9pbnQpO1xuICAgIHZlcnRpY2VzLnVuc2hpZnQoc291cmNlQW5jaG9yKTtcbiAgICB2ZXJ0aWNlcy5wdXNoKHRhcmdldEFuY2hvcik7XG5cbiAgICB2YXIgYmVhcmluZzsgLy8gYmVhcmluZyBvZiBwcmV2aW91cyByb3V0ZSBzZWdtZW50XG5cbiAgICB2YXIgb3J0aG9nb25hbFZlcnRpY2VzID0gW107IC8vIHRoZSBhcnJheSBvZiBmb3VuZCBvcnRob2dvbmFsIHZlcnRpY2VzIHRvIGJlIHJldHVybmVkXG4gICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGkgPCBtYXg7IGkrKykge1xuXG4gICAgICAgIHZhciByb3V0ZSA9IG51bGw7XG5cbiAgICAgICAgdmFyIGZyb20gPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgdmFyIHRvID0gdmVydGljZXNbaSArIDFdO1xuXG4gICAgICAgIHZhciBpc09ydGhvZ29uYWwgPSAhIWdldEJlYXJpbmcoZnJvbSwgdG8pO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7IC8vIHNvdXJjZVxuXG4gICAgICAgICAgICBpZiAoaSArIDEgPT09IG1heCkgeyAvLyByb3V0ZSBzb3VyY2UgLT4gdGFyZ2V0XG5cbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgb25lIG9mIHRoZSBlbGVtZW50cyBieSAxcHggdG8gZGV0ZWN0IHNpdHVhdGlvbnMgd2hlbiB0aGUgdHdvXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgYXJlIHBvc2l0aW9uZWQgbmV4dCB0byBlYWNoIG90aGVyIHdpdGggbm8gZ2FwIGluIGJldHdlZW4uXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUJCb3guaW50ZXJzZWN0KHRhcmdldEJCb3guY2xvbmUoKS5pbmZsYXRlKDEpKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IGluc2lkZUVsZW1lbnQoZnJvbSwgdG8sIHNvdXJjZUJCb3gsIHRhcmdldEJCb3gpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNPcnRob2dvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gZWxlbWVudEVsZW1lbnQoZnJvbSwgdG8sIHNvdXJjZUJCb3gsIHRhcmdldEJCb3gpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gcm91dGUgc291cmNlIC0+IHZlcnRleFxuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBpbnNpZGVFbGVtZW50KGZyb20sIHRvLCBzb3VyY2VCQm94LCBnZXRQb2ludEJveCh0bykubW92ZUFuZEV4cGFuZChnZXRQYWRkaW5nQm94KG9wdCkpKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT3J0aG9nb25hbCkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IGVsZW1lbnRWZXJ0ZXgoZnJvbSwgdG8sIHNvdXJjZUJCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBtYXgpIHsgLy8gcm91dGUgdmVydGV4IC0+IHRhcmdldFxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG92ZXJsYXBzIHdpdGggcHJldmlvdXMgbGluZSBzZWdtZW50XG4gICAgICAgICAgICB2YXIgaXNPcnRob2dvbmFsTG9vcCA9IGlzT3J0aG9nb25hbCAmJiBnZXRCZWFyaW5nKHRvLCBmcm9tKSA9PT0gYmVhcmluZztcblxuICAgICAgICAgICAgaWYgKHRhcmdldEJCb3guY29udGFpbnNQb2ludChmcm9tKSB8fCBpc09ydGhvZ29uYWxMb29wKSB7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBpbnNpZGVFbGVtZW50KGZyb20sIHRvLCBnZXRQb2ludEJveChmcm9tKS5tb3ZlQW5kRXhwYW5kKGdldFBhZGRpbmdCb3gob3B0KSksIHRhcmdldEJCb3gsIGJlYXJpbmcpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09ydGhvZ29uYWwpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IHZlcnRleEVsZW1lbnQoZnJvbSwgdG8sIHRhcmdldEJCb3gsIGJlYXJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzT3J0aG9nb25hbCkgeyAvLyByb3V0ZSB2ZXJ0ZXggLT4gdmVydGV4XG4gICAgICAgICAgICByb3V0ZSA9IHZlcnRleFZlcnRleChmcm9tLCB0bywgYmVhcmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBsaWNhYmxlIHRvIGFsbCByb3V0ZXM6XG5cbiAgICAgICAgLy8gc2V0IGJlYXJpbmcgZm9yIG5leHQgaXRlcmF0aW9uXG4gICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkob3J0aG9nb25hbFZlcnRpY2VzLCByb3V0ZS5wb2ludHMpO1xuICAgICAgICAgICAgYmVhcmluZyA9IHJvdXRlLmRpcmVjdGlvbjtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3J0aG9nb25hbCByb3V0ZSBhbmQgbm90IGxvb3BlZFxuICAgICAgICAgICAgYmVhcmluZyA9IGdldEJlYXJpbmcoZnJvbSwgdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHVzaCBgdG9gIHBvaW50IHRvIGlkZW50aWZpZWQgb3J0aG9nb25hbCB2ZXJ0aWNlcyBhcnJheVxuICAgICAgICBpZiAoaSArIDEgPCBtYXgpIHtcbiAgICAgICAgICAgIG9ydGhvZ29uYWxWZXJ0aWNlcy5wdXNoKHRvKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcnRob2dvbmFsVmVydGljZXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/orthogonal.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/routers/rightAngle.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@joint/core/src/routers/rightAngle.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rightAngle: function() { return /* binding */ rightAngle; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/polyline.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/point.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/geometry.helpers.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/line.mjs\");\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/index.mjs\");\n\n\nconst Directions = {\n    AUTO: 'auto',\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    ANCHOR_SIDE: 'anchor-side',\n    MAGNET_SIDE: 'magnet-side'\n};\n\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\n\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\n\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\n\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Polyline(points).simplify({ threshold: 1 }).points;\n}\n\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n\n    let sourceSide;\n\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n\n    let targetSide;\n\n    if (!targetView) {\n        const targetLinkAnchorBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n\n    return [sourceSide, targetSide];\n}\n\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty > smy0) return Directions.TOP;\n    if (tx > smx1 && ty > smy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.BOTTOM;\n}\n\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty < smy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty < smy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n        return Directions.LEFT;\n    }\n\n    return Directions.TOP;\n}\n\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= smx0 && ty < smy0) return Directions.LEFT;\n    if (tx >= smx0 && ty > smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.RIGHT;\n}\n\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= smx1 && ty < smy0) return Directions.RIGHT;\n    if (tx <= smx1 && ty > smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.LEFT;\n}\n\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n\n    switch (sourceSide) {\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\n\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n\n    switch (roundedAngle) {\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\n\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n\n    const isElement = view && view.model.isElement();\n\n    const {\n        x: x0,\n        y: y0,\n        width = 0,\n        height = 0\n    } = isElement ? _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\n\nfunction pointDataFromVertex({ x, y }) {\n    const point = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_2__.Point(x, y);\n\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\n\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n\n    const { x0, y0, width, height } = pointData;\n\n    switch (side) {\n        case 'left':\n            outsidePoint.x = x0 - margin;\n            break;\n        case 'right':\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case 'top':\n            outsidePoint.y = y0 - margin;\n            break;\n        case 'bottom':\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n\n    return outsidePoint;\n}\n\nfunction createLoop(from, to, { dx = 0, dy = 0 }) {\n    const p1 = { x: from.point.x + dx, y: from.point.y + dy };\n    const p2 = { x: to.point.x + dx, y: to.point.y + dy };\n\n    return [from.point, p1, p2, to.point];\n}\n\nfunction loopSegment(from, to, connectionSegmentAngle, margin) {\n    // Find out the loop coordinates.\n    const angle = _g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeAngle(connectionSegmentAngle - 90);\n\n    let dx = 0;\n    let dy = 0;\n\n    if (angle === 90) {\n        dy = -margin;\n    } else if (angle === 180) {\n        dx = -margin;\n    } else if (angle === 270) {\n        dy = margin;\n    } else if (angle === 0) {\n        dx = margin;\n    }\n\n    const loopRoute = createLoop(from, to, { dx, dy });\n\n    const secondCreatedPoint = loopRoute[2];\n    const loopEndSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(to.point, secondCreatedPoint);\n    // The direction in which the loop should continue.\n    const continueDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n\n    return {\n        loopRoute,\n        continueDirection\n    };\n}\n\n// Calculates the distances along the horizontal axis for the left and right route.\nfunction getHorizontalDistance(source, target) {\n\n    const { x0: sx0, x1: sx1, outsidePoint: sourcePoint } = source;\n    const { x0: tx0, x1: tx1, outsidePoint: targetPoint } = target;\n\n    // Furthest left boundary\n    let leftBoundary = Math.min(sx0, tx0);\n    // Furthest right boundary\n    let rightBoundary = Math.max(sx1, tx1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const aboveShape = source.y0 < target.y0 ? source : target;\n        const belowShape = aboveShape === source ? target : source;\n\n        // The source and target anchors are on the top => then the `aboveShape` defines the boundary.\n        // The source and target anchors are on the bottom => then the `belowShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.TOP ? aboveShape : belowShape;\n\n        leftBoundary = boundaryDefiningShape.x0;\n        rightBoundary = boundaryDefiningShape.x1;\n    }\n\n    const { x: sox } = sourcePoint;\n    const { x: tox } = targetPoint;\n\n    // Calculate the distances for the left route\n    const leftDistance1 = Math.abs(sox - leftBoundary);\n    const leftDistance2 = Math.abs(tox - leftBoundary);\n    const leftD = leftDistance1 + leftDistance2;\n\n    // Calculate the distances for the right route\n    const rightDistance1 = Math.abs(sox - rightBoundary);\n    const rightDistance2 = Math.abs(tox - rightBoundary);\n    const rightD = rightDistance1 + rightDistance2;\n\n    return [leftD, rightD];\n}\n\n// Calculates the distances along the vertical axis for the top and bottom route.\nfunction getVerticalDistance(source, target) {\n\n    const { y0: sy0, y1: sy1, outsidePoint: sourcePoint } = source;\n    const { y0: ty0, y1: ty1, outsidePoint: targetPoint } = target;\n\n    // Furthest top boundary\n    let topBoundary = Math.min(sy0, ty0);\n    // Furthest bottom boundary\n    let bottomBoundary = Math.max(sy1, ty1);\n\n    // If the source and target elements are on the same side, we need to figure out what shape defines the boundary.\n    if (source.direction === target.direction) {\n\n        const leftShape = source.x0 < target.x0 ? source : target;\n        const rightShape = leftShape === source ? target : source;\n\n        // The source and target anchors are on the left => then the `leftShape` defines the boundary.\n        // The source and target anchors are on the right => then the `rightShape` defines the boundary.\n        const boundaryDefiningShape = source.direction === Directions.LEFT ? leftShape : rightShape;\n\n        topBoundary = boundaryDefiningShape.y0;\n        bottomBoundary = boundaryDefiningShape.y1;  \n    }\n\n    const { y: soy } = sourcePoint;\n    const { y: toy } = targetPoint;\n\n    // Calculate the distances for the top route\n    const topDistance1 = Math.abs(soy - topBoundary);\n    const topDistance2 = Math.abs(toy - topBoundary);\n    const topD = topDistance1 + topDistance2;\n\n    // Calculate the distances for the bottom route\n    const bottomDistance1 = Math.abs(soy - bottomBoundary);\n    const bottomDistance2 = Math.abs(toy - bottomBoundary);\n    const bottomD = bottomDistance1 + bottomDistance2;\n\n    return [topD, bottomD];\n}\n\n// Inflate bbox in 3 directions depending on the direction of the anchor\n// don't inflate in the opposite direction of the anchor\nfunction moveAndExpandBBox(bbox, direction, margin) {\n    switch (direction) {\n        case Directions.LEFT:\n            bbox.inflate(0, margin).moveAndExpand({ x: -margin, width: margin });\n            break;\n        case Directions.RIGHT:\n            bbox.inflate(0, margin).moveAndExpand({ width: margin });\n            break;\n        case Directions.TOP:\n            bbox.inflate(margin, 0).moveAndExpand({ y: -margin, height: margin });\n            break;\n        case Directions.BOTTOM:\n            bbox.inflate(margin, 0).moveAndExpand({ height: margin });\n            break;\n    }\n\n    return bbox;\n}\n\nfunction routeBetweenPoints(source, target, opt = {}) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n    const { targetInSourceBBox = false } = opt;\n\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n\n    const [sourceSide, targetSide] = resolveSides(source, target);\n\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight }, targetMargin);\n\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n    const sourceBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(sx0, sy0, sourceWidth, sourceHeight);\n    const targetBBox = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_1__.Rect(tx0, ty0, targetWidth, targetHeight);\n    const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n    const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\n    const sourceForDistance = Object.assign({}, source, { x1: sx1, y1: sy1, outsidePoint: sourceOutsidePoint, direction: sourceSide });\n    const targetForDistance = Object.assign({}, target, { x1: tx1, y1: ty1, outsidePoint: targetOutsidePoint, direction: targetSide });\n\n    // Distances used to determine the shortest route along the connections on horizontal sides for\n    // bottom => bottom\n    // top => bottom\n    // bottom => top\n    // top => top\n    const [leftD, rightD] = getHorizontalDistance(sourceForDistance, targetForDistance);\n\n    // Distances used to determine the shortest route along the connection on vertical sides for\n    // left => left\n    // left => right\n    // right => right\n    // right => left\n    const [topD, bottomD] = getVerticalDistance(sourceForDistance, targetForDistance);\n\n    // All possible combinations of source and target sides\n    if (sourceSide === 'left' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx0 < tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.min(sox, tmx0);\n                x2 = Math.max(tox, smx1);\n            \n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on minimal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on maximal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy },\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (soy + toy) / 2;\n            \n            return [\n                { x: sox, y: soy },\n                { x: sox, y: middleOfAnchors },\n                { x: tox, y: middleOfAnchors },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smx1 > tox) {\n            let y = middleOfHorizontalSides;\n            let x1 = sox;\n            let x2 = tox;\n\n            const isUpwardsShorter = topD < bottomD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((y >= smy0 && y <= smy1) || (y >= tmy0 && y <= tmy1)) {\n                if (smy1 >= tmy0 && isUpwardsShorter) {\n                    y = Math.min(tmy0, smy0);\n                } else if (smy0 <= tmy1 && !isUpwardsShorter) {\n                    y = Math.max(tmy1, smy1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                x1 = Math.max(sox, tmx1);\n                x2 = Math.min(tox, smx0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isUpwardsShorter && soy < ty0) || (!isUpwardsShorter && soy > ty1)) {\n                    // the path should no longer rely on maximal x boundary in `x1`\n                    x1 = sox;\n                } else if ((isUpwardsShorter && toy < sy0) || (!isUpwardsShorter && toy > sy1)) {\n                    // the path should no longer rely on minimal x boundary in `x2`\n                    x2 = tox;\n                }\n            }\n\n            return [\n                { x: x1, y: soy },\n                { x: x1, y },\n                { x: x2, y },\n                { x: x2, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy0 < toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n\n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.min(soy, tmy0);\n                y2 = Math.max(toy, smy1);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on minimal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on maximal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetOutsidePoint);\n        const isPointInsideTarget = inflatedTargetBBox.containsPoint(sourceOutsidePoint);\n\n        // Use S-shaped connection\n        if (isPointInsideSource || isPointInsideTarget) {\n            const middleOfAnchors = (sox + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: middleOfAnchors, y: soy },\n                { x: middleOfAnchors, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n\n        if (smy1 > toy) {\n            let x = middleOfVerticalSides;\n            let y1 = soy;\n            let y2 = toy;\n            \n            const isLeftShorter = leftD < rightD;\n\n            // If the source and target elements overlap, we need to make sure the connection\n            // goes around the target element.\n            if ((x >= smx0 && x <= smx1) || (x >= tmx0 && x <= tmx1)) {\n                if (smx1 >= tmx0 && isLeftShorter) {\n                    x = Math.min(tmx0, smx0);\n                } else if (smx0 <= tmx1 && !isLeftShorter) {\n                    x = Math.max(tmx1, smx1);\n                }\n\n                // This handles the case when the source and target elements overlap as well as\n                // the case when the source is to the left of the target element.\n                y1 = Math.max(soy, tmy1);\n                y2 = Math.min(toy, smy0);\n\n                // This is an edge case when the source and target intersect and\n                if ((isLeftShorter && sox < tx0) || (!isLeftShorter && sox > tx1)) {\n                    // the path should no longer rely on maximal y boundary in `y1`\n                    y1 = soy;\n                } else if ((isLeftShorter && tox < sx0) || (!isLeftShorter && tox > sx1)) {\n                    // the path should no longer rely on minimal y boundary in `y2`\n                    y2 = toy;\n                }\n            }\n\n            return [\n                { x: sox, y: y1 },\n                { x, y: y1 },\n                { x, y: y2 },\n                { x: tox, y: y2 }\n            ];\n        }\n\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'top') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox)) ||\n            (soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.min(soy, toy) },\n                { x: tox, y: Math.min(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n\n        if (toy < soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox)) ||\n            (soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox));\n\n        // U-shape connection is a straight line if `sox` and `tox` are the same\n        if (useUShapeConnection && sox !== tox) {\n            return [\n                { x: sox, y: Math.max(soy, toy) },\n                { x: tox, y: Math.max(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n\n        if (toy > soy) {\n            // Use the shortest path along the connections on horizontal sides\n            if (rightD > leftD) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (rightD > leftD) {\n                x = Math.min(tox, smx0);\n            } else {\n                x = Math.max(tox, smx1);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'left') {\n        const useUShapeConnection = \n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy)) ||\n            (sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.min(sox, tox), y: soy },\n                { x: Math.min(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n\n        if (tox > sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'right') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            _g_index_mjs__WEBPACK_IMPORTED_MODULE_5__.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy)) ||\n            (sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy));\n\n        // U-shape connection is a straight line if `soy` and `toy` are the same\n        if (useUShapeConnection && soy !== toy) {\n            return [\n                { x: Math.max(sox, tox), y: soy },\n                { x: Math.max(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n\n        if (tox <= sox) {\n            if (topD <= bottomD) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (topD <= bottomD) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox < tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox > tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }];\n        }\n\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox < tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox > tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x < smx1 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.min(smx0, tmx0);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy < toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const y = Math.min(soy - sourceMargin, toy);\n                const x = Math.min(smx0, tmx0);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Add the `sourceMargin` since the source anchor is above the target anchor\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy > toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.min(smy0, tmy0);\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.min(soy - sourceMargin, toy);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y }, // Path adjustment for right side start\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Adjust sourceMargin calculation since the source anchor is now on the right\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy > toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.min(smy0, tmy0);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy < toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    }\n}\n\nfunction getLoopCoordinates(direction, angle, margin) {\n    const isHorizontal = direction === Directions.LEFT || direction === Directions.RIGHT;\n\n    let dx = 0;\n    let dy = 0;\n\n    switch (_g_index_mjs__WEBPACK_IMPORTED_MODULE_3__.normalizeAngle(Math.round(angle))) {\n        case 0:\n        case 90:\n            dx = isHorizontal ? 0 : margin;\n            dy = isHorizontal ? margin : 0;\n            break;\n        case 180:\n        case 270:\n            dx = isHorizontal ? 0 : -margin;\n            dy = isHorizontal ? -margin : 0;\n            break;\n    }\n\n    return { dx, dy };\n}\n\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\n    let resultVertices = [];\n\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n\n    const verticesData = vertices.map((v) => pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n\n    const [resolvedSourceDirection] = resolveSides(sourcePoint, firstVertex);\n    const isElement = sourcePoint.view && sourcePoint.view.model.isElement();\n    const sourceBBox = isElement ? moveAndExpandBBox(sourcePoint.view.model.getBBox(), resolvedSourceDirection, margin) : null;\n    const isVertexInside = isElement ? sourceBBox.containsPoint(firstVertex.point) : false;\n\n    if (isVertexInside) {\n        const outsidePoint = getOutsidePoint(resolvedSourceDirection, sourcePoint, margin);\n        const firstPointOverlap = outsidePoint.equals(firstVertex.point);\n\n        const alignsVertically = sourcePoint.point.x === firstVertex.point.x;\n        const alignsHorizontally = sourcePoint.point.y === firstVertex.point.y;\n\n        const isVerticalAndAligns = alignsVertically && (resolvedSourceDirection === Directions.TOP || resolvedSourceDirection === Directions.BOTTOM);\n        const isHorizontalAndAligns = alignsHorizontally && (resolvedSourceDirection === Directions.LEFT || resolvedSourceDirection === Directions.RIGHT);\n\n        const firstSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(sourcePoint.point, outsidePoint);\n        const isVertexOnSegment = firstSegment.containsPoint(firstVertex.point);\n\n        const isVertexAlignedAndInside = isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns);\n\n        \n\n        if (firstPointOverlap) {\n            resultVertices.push(sourcePoint.point, firstVertex.point);\n            // Set the access direction as the opposite of the source direction that will be used to connect the route with the next vertex\n            firstVertex.direction = OPPOSITE_DIRECTIONS[resolvedSourceDirection];\n        } else if (isVertexOnSegment || isVertexAlignedAndInside) {\n            // Case where there is a need to create a loop\n            const angle = getSegmentAngle(isVertexOnSegment ? firstSegment : new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(sourcePoint.point, firstVertex.point));\n            const { dx, dy } = getLoopCoordinates(resolvedSourceDirection, angle, margin);\n\n            const loop = createLoop({ point: outsidePoint }, firstVertex, { dx, dy });\n            const secondCreatedPoint = loop[2];\n            const loopEndSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(firstVertex.point, secondCreatedPoint);\n\n            const accessDirection = ANGLE_DIRECTION_MAP[getSegmentAngle(loopEndSegment)];\n            firstVertex.direction = accessDirection;\n            resultVertices.push(...loop);\n        } else {\n            // No need to create a route, use the `routeBetweenPoints` to construct a route\n            firstVertex.direction = resolvedSourceDirection;\n            firstVertex.margin = margin;\n            resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex, { targetInSourceBBox: true }), firstVertex.point);\n        }\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n\n    for (let i = 0; i < verticesData.length - 1; i++) {\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n\n        const connectionSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints([...resultVertices, from.point]);\n            // const simplifiedRoute2 = simplifyPoints([from.point, ...resultVertices]);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(simplifiedRoute[simplifiedRoute.length - 2], simplifiedRoute[simplifiedRoute.length - 1]);\n            // const accessSegment2 = new g.Line(simplifiedRoute2[simplifiedRoute2.length - 2], simplifiedRoute2[simplifiedRoute2.length - 1]);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n            // const accessDirection2 = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment2))];\n            // console.log(accessDirection);\n            // console.log(accessDirection2);\n            // if (accessDirection !== accessDirection2) {\n            //     console.log('error');\n            // }\n            // console.log('------------------');\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly\n                resultVertices.push(from.point, to.point);\n                const [, toDirection] = resolveSides(from, to);\n                to.direction = toDirection;\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute, continueDirection } = loopSegment(from, to, connectionSegmentAngle, margin);\n                to.direction = continueDirection;\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n\n            continue;\n        }\n\n        // Vertices are not aligned vertically nor horizontally\n        // so we need to route between them\n\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n\n        from.direction = fromDirection;\n        to.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n\n    const lastVertex = verticesData[verticesData.length - 1];\n\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        const [, resolvedTargetDirection] = resolveSides(lastVertex, targetPoint);\n        const outsidePoint = getOutsidePoint(resolvedTargetDirection, targetPoint, margin);\n\n        // the last point of `simplified` array is the last defined vertex\n        // this will ensure that the last segment continues in a straight line\n        const simplified = simplifyPoints([...resultVertices, lastVertex.point]);\n        const simplifiedSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(simplified[simplified.length - 2], simplified[simplified.length - 1]);\n        const simplifiedSegmentAngle = Math.round(getSegmentAngle(simplifiedSegment));\n        const definedDirection = ANGLE_DIRECTION_MAP[simplifiedSegmentAngle];\n\n        const lastPointOverlap = outsidePoint.equals(lastVertex.point);\n\n        if (!lastPointOverlap || (lastPointOverlap && definedDirection === resolvedTargetDirection)) {\n\n            lastVertex.direction = definedDirection;\n\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\n            const lastSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\n            const targetBBox = moveAndExpandBBox(targetPoint.view.model.getBBox(), resolvedTargetDirection, margin);\n\n            const alignsVertically = lastVertex.point.x === targetPoint.point.x;\n            const alignsHorizontally = lastVertex.point.y === targetPoint.point.y;\n            const isVertexInside = targetBBox.containsPoint(lastVertex.point);\n\n            const isVerticalAndAligns = alignsVertically && (resolvedTargetDirection === Directions.TOP || resolvedTargetDirection === Directions.BOTTOM);\n            const isHorizontalAndAligns = alignsHorizontally && (resolvedTargetDirection === Directions.LEFT || resolvedTargetDirection === Directions.RIGHT);\n\n            \n            if (!lastPointOverlap && isVertexInside && (isHorizontalAndAligns || isVerticalAndAligns)) {\n                // Handle special cases when the last vertex is inside the target element\n                // and in is aligned with the connection point => construct a loop\n                const { dx, dy } = getLoopCoordinates(resolvedTargetDirection, simplifiedSegmentAngle, margin);\n                lastSegmentRoute = createLoop(lastVertex, { point: outsidePoint }, { dx, dy });\n            } else if (isVertexInside && resolvedTargetDirection !== OPPOSITE_DIRECTIONS[definedDirection]) {\n                lastVertex.margin = margin;\n                lastVertex.direction = resolvedTargetDirection;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            } else if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const from = lastVertex;\n        const to = targetPoint;\n\n        const connectionSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(from.point, to.point);\n        const connectionSegmentAngle = getSegmentAngle(connectionSegment);\n        if (connectionSegmentAngle % 90 === 0) {\n            // Segment is horizontal or vertical\n            const connectionDirection = ANGLE_DIRECTION_MAP[connectionSegmentAngle];\n\n            const simplifiedRoute = simplifyPoints(resultVertices);\n            // Find out the direction that is used to connect the current route with the next vertex\n            const accessSegment = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_4__.Line(simplifiedRoute[simplifiedRoute.length - 2], from.point);\n            const accessDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(accessSegment))];\n\n            if (connectionDirection !== OPPOSITE_DIRECTIONS[accessDirection]) {\n                // The directions are not opposite, so we can connect the vertices directly by adding the first point\n                // the target point is handled separately\n                resultVertices.push(from.point);\n            } else {\n                // The directions are overlapping, so we need to create a loop\n                const { loopRoute } = loopSegment(from, to, connectionSegmentAngle, margin);\n                // Remove the last point since it is the target that is handled separately\n                loopRoute.pop();\n                // Constructing a loop\n                resultVertices.push(...loopRoute);\n            }\n        } else {\n            // The last vertex and the target are not aligned vertically nor horizontally\n            // so we need to route between them\n            const [fromDirection, toDirection] = resolveDirection(from, to);\n\n            from.direction = fromDirection;\n            to.direction = toDirection;\n\n            resultVertices.push(...routeBetweenPoints(from, to));\n        }\n    }\n\n    return simplifyPoints(resultVertices);\n}\n\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n\n    return [sourceDirection, targetDirection];\n}\n\nrightAngleRouter.Directions = Directions;\n\nconst rightAngle = rightAngleRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9yaWdodEFuZ2xlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFVLG9CQUFvQixjQUFjO0FBQzNEOztBQUVBO0FBQ0EsWUFBWSx1R0FBdUc7QUFDbkgsWUFBWSx1R0FBdUc7O0FBRW5IOztBQUVBO0FBQ0EseUNBQXlDLDhDQUFNO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsOENBQU07QUFDL0M7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx5REFBeUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxpQkFBaUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVkseURBQXlEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxRQUFRO0FBQ3BCLFlBQVksaUJBQWlCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBOztBQUVPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvcm91dGVycy9yaWdodEFuZ2xlLm1qcz9mNDFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5jb25zdCBEaXJlY3Rpb25zID0ge1xuICAgIEFVVE86ICdhdXRvJyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgUklHSFQ6ICdyaWdodCcsXG4gICAgVE9QOiAndG9wJyxcbiAgICBCT1RUT006ICdib3R0b20nLFxuICAgIEFOQ0hPUl9TSURFOiAnYW5jaG9yLXNpZGUnLFxuICAgIE1BR05FVF9TSURFOiAnbWFnbmV0LXNpZGUnXG59O1xuXG5jb25zdCBERUZJTkVEX0RJUkVDVElPTlMgPSBbRGlyZWN0aW9ucy5MRUZULCBEaXJlY3Rpb25zLlJJR0hULCBEaXJlY3Rpb25zLlRPUCwgRGlyZWN0aW9ucy5CT1RUT01dO1xuXG5jb25zdCBPUFBPU0lURV9ESVJFQ1RJT05TID0ge1xuICAgIFtEaXJlY3Rpb25zLkxFRlRdOiBEaXJlY3Rpb25zLlJJR0hULFxuICAgIFtEaXJlY3Rpb25zLlJJR0hUXTogRGlyZWN0aW9ucy5MRUZULFxuICAgIFtEaXJlY3Rpb25zLlRPUF06IERpcmVjdGlvbnMuQk9UVE9NLFxuICAgIFtEaXJlY3Rpb25zLkJPVFRPTV06IERpcmVjdGlvbnMuVE9QXG59O1xuXG5jb25zdCBWRVJUSUNBTF9ESVJFQ1RJT05TID0gW0RpcmVjdGlvbnMuVE9QLCBEaXJlY3Rpb25zLkJPVFRPTV07XG5cbmNvbnN0IEFOR0xFX0RJUkVDVElPTl9NQVAgPSB7XG4gICAgMDogRGlyZWN0aW9ucy5SSUdIVCxcbiAgICAxODA6IERpcmVjdGlvbnMuTEVGVCxcbiAgICAyNzA6IERpcmVjdGlvbnMuVE9QLFxuICAgIDkwOiBEaXJlY3Rpb25zLkJPVFRPTVxufTtcblxuZnVuY3Rpb24gZ2V0U2VnbWVudEFuZ2xlKGxpbmUpIHtcbiAgICAvLyBUT0RPOiB0aGUgYW5nbGUoKSBtZXRob2QgaXMgZ2VuZXJhbCBhbmQgdGhlcmVmb3JlIHVubmVjZXNzYXJpbHkgaGVhdnkgZm9yIG9ydGhvZ29uYWwgbGlua3NcbiAgICByZXR1cm4gbGluZS5hbmdsZSgpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVBvaW50cyhwb2ludHMpIHtcbiAgICAvLyBUT0RPOiB1c2Ugb3duIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIChmaWx0ZXIgcG9pbnRzIHRoYXQgZG8gbm90IGNoYW5nZSBkaXJlY3Rpb24pLlxuICAgIC8vIFRvIHNpbXBsaWZ5IHNlZ21lbnRzIHRoYXQgYXJlIGFsbW9zdCBhbGlnbmVkIChzdGFydCBhbmQgZW5kIHBvaW50cyBkaWZmZXIgYnkgZS5nLiAwLjVweCksIHVzZSBhIHRocmVzaG9sZCBvZiAxLlxuICAgIHJldHVybiBuZXcgZy5Qb2x5bGluZShwb2ludHMpLnNpbXBsaWZ5KHsgdGhyZXNob2xkOiAxIH0pLnBvaW50cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNpZGVzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgY29uc3QgeyBwb2ludDogc291cmNlUG9pbnQsIHgwOiBzeDAsIHkwOiBzeTAsIHZpZXc6IHNvdXJjZVZpZXcsIGJib3g6IHNvdXJjZUJCb3gsIGRpcmVjdGlvbjogc291cmNlRGlyZWN0aW9uIH0gPSBzb3VyY2U7XG4gICAgY29uc3QgeyBwb2ludDogdGFyZ2V0UG9pbnQsIHgwOiB0eDAsIHkwOiB0eTAsIHZpZXc6IHRhcmdldFZpZXcsIGJib3g6IHRhcmdldEJCb3gsIGRpcmVjdGlvbjogdGFyZ2V0RGlyZWN0aW9uIH0gPSB0YXJnZXQ7XG5cbiAgICBsZXQgc291cmNlU2lkZTtcblxuICAgIGlmICghc291cmNlVmlldykge1xuICAgICAgICBjb25zdCBzb3VyY2VMaW5rQW5jaG9yQkJveCA9IG5ldyBnLlJlY3Qoc3gwLCBzeTAsIDAsIDApO1xuICAgICAgICBzb3VyY2VTaWRlID0gREVGSU5FRF9ESVJFQ1RJT05TLmluY2x1ZGVzKHNvdXJjZURpcmVjdGlvbikgPyBzb3VyY2VEaXJlY3Rpb24gOiBzb3VyY2VMaW5rQW5jaG9yQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQodGFyZ2V0UG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoc291cmNlVmlldy5tb2RlbC5pc0xpbmsoKSkge1xuICAgICAgICBzb3VyY2VTaWRlID0gZ2V0RGlyZWN0aW9uRm9yTGlua0Nvbm5lY3Rpb24odGFyZ2V0UG9pbnQsIHNvdXJjZVBvaW50LCBzb3VyY2VWaWV3KTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZURpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5BTkNIT1JfU0lERSkge1xuICAgICAgICBzb3VyY2VTaWRlID0gc291cmNlQkJveC5zaWRlTmVhcmVzdFRvUG9pbnQoc291cmNlUG9pbnQpO1xuICAgIH0gZWxzZSBpZiAoc291cmNlRGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLk1BR05FVF9TSURFKSB7XG4gICAgICAgIHNvdXJjZVNpZGUgPSBzb3VyY2VWaWV3Lm1vZGVsLmdldEJCb3goKS5zaWRlTmVhcmVzdFRvUG9pbnQoc291cmNlUG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVNpZGUgPSBzb3VyY2VEaXJlY3Rpb247XG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFNpZGU7XG5cbiAgICBpZiAoIXRhcmdldFZpZXcpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0TGlua0FuY2hvckJCb3ggPSBuZXcgZy5SZWN0KHR4MCwgdHkwLCAwLCAwKTtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IERFRklORURfRElSRUNUSU9OUy5pbmNsdWRlcyh0YXJnZXREaXJlY3Rpb24pID8gdGFyZ2V0RGlyZWN0aW9uIDogdGFyZ2V0TGlua0FuY2hvckJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHNvdXJjZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldFZpZXcubW9kZWwuaXNMaW5rKCkpIHtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IGdldERpcmVjdGlvbkZvckxpbmtDb25uZWN0aW9uKHNvdXJjZVBvaW50LCB0YXJnZXRQb2ludCwgdGFyZ2V0Vmlldyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXREaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuQU5DSE9SX1NJREUpIHtcbiAgICAgICAgdGFyZ2V0U2lkZSA9IHRhcmdldEJCb3guc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldERpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5NQUdORVRfU0lERSkge1xuICAgICAgICB0YXJnZXRTaWRlID0gdGFyZ2V0Vmlldy5tb2RlbC5nZXRCQm94KCkuc2lkZU5lYXJlc3RUb1BvaW50KHRhcmdldFBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRTaWRlID0gdGFyZ2V0RGlyZWN0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBbc291cmNlU2lkZSwgdGFyZ2V0U2lkZV07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb3JUb3BTb3VyY2VTaWRlKHNvdXJjZSwgdGFyZ2V0LCBuZXh0SW5MaW5lKSB7XG4gICAgY29uc3QgeyB4MDogc3gwLCB5MDogc3kwLCB3aWR0aCwgaGVpZ2h0LCBwb2ludDogYW5jaG9yLCBtYXJnaW4gfSA9IHNvdXJjZTtcbiAgICBjb25zdCBzeDEgPSBzeDAgKyB3aWR0aDtcbiAgICBjb25zdCBzeTEgPSBzeTAgKyBoZWlnaHQ7XG4gICAgY29uc3Qgc214MCA9IHN4MCAtIG1hcmdpbjtcbiAgICBjb25zdCBzbXgxID0gc3gxICsgbWFyZ2luO1xuICAgIGNvbnN0IHNteTAgPSBzeTAgLSBtYXJnaW47XG5cbiAgICBjb25zdCB7IHg6IGF4IH0gPSBhbmNob3I7XG4gICAgY29uc3QgeyB4MDogdHgsIHkwOiB0eSB9ID0gdGFyZ2V0O1xuXG4gICAgaWYgKHR4ID09PSBheCAmJiB0eSA8IHN5MCkgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgIGlmICh0eCA8IGF4ICYmIHR5IDwgc215MCkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54ID09PSBheCkgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICB9XG4gICAgaWYgKHR4ID4gYXggJiYgdHkgPCBzbXkwKSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnggPT09IGF4KSByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuICAgIGlmICh0eCA8IHNteDAgJiYgdHkgPiBzbXkwKSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4ID4gc214MSAmJiB0eSA+IHNteTApIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICBpZiAodHggPj0gc214MCAmJiB0eCA8PSBheCAmJiB0eSA+IHN5MSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54IDwgdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuICAgIGlmICh0eCA8PSBzbXgxICYmIHR4ID49IGF4ICYmIHR5ID4gc3kxKSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnggPCB0eCkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICB9XG5cbiAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb3JCb3R0b21Tb3VyY2VTaWRlKHNvdXJjZSwgdGFyZ2V0LCBuZXh0SW5MaW5lKSB7XG4gICAgY29uc3QgeyB4MDogc3gwLCB5MDogc3kwLCB3aWR0aCwgaGVpZ2h0LCBwb2ludDogYW5jaG9yLCBtYXJnaW4gfSA9IHNvdXJjZTtcbiAgICBjb25zdCBzeDEgPSBzeDAgKyB3aWR0aDtcbiAgICBjb25zdCBzeTEgPSBzeTAgKyBoZWlnaHQ7XG4gICAgY29uc3Qgc214MCA9IHN4MCAtIG1hcmdpbjtcbiAgICBjb25zdCBzbXgxID0gc3gxICsgbWFyZ2luO1xuICAgIGNvbnN0IHNteTEgPSBzeTEgKyBtYXJnaW47XG5cbiAgICBjb25zdCB7IHg6IGF4IH0gPSBhbmNob3I7XG4gICAgY29uc3QgeyB4MDogdHgsIHkwOiB0eSB9ID0gdGFyZ2V0O1xuXG4gICAgaWYgKHR4ID09PSBheCAmJiB0eSA+IHN5MSkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIGlmICh0eCA8IGF4ICYmIHR5ID4gc215MSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54ID09PSBheCkgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICB9XG4gICAgaWYgKHR4ID4gYXggJiYgdHkgPiBzbXkxKSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnggPT09IGF4KSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuICAgIGlmICh0eCA8IHNteDAgJiYgdHkgPCBzbXkxKSByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgaWYgKHR4ID4gc214MSAmJiB0eSA8IHNteTEpIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPj0gc214MCAmJiB0eCA8PSBheCAmJiB0eSA8IHN5MCkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC54IDwgdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgfVxuICAgIGlmICh0eCA8PSBzbXgxICYmIHR4ID49IGF4ICYmIHR5IDwgc3kwKSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnggPCB0eCkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICB9XG5cbiAgICByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb3JMZWZ0U291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IHsgeTA6IHN5MCwgeDA6IHN4MCwgd2lkdGgsIGhlaWdodCwgcG9pbnQ6IGFuY2hvciwgbWFyZ2luIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgd2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgaGVpZ2h0O1xuICAgIGNvbnN0IHNteDAgPSBzeDAgLSBtYXJnaW47XG4gICAgY29uc3Qgc215MCA9IHN5MCAtIG1hcmdpbjtcbiAgICBjb25zdCBzbXkxID0gc3kxICsgbWFyZ2luO1xuXG4gICAgY29uc3QgeyB4OiBheCwgeTogYXkgfSA9IGFuY2hvcjtcbiAgICBjb25zdCB7IHgwOiB0eCwgeTA6IHR5IH0gPSB0YXJnZXQ7XG5cbiAgICBpZiAodHggPCBheCAmJiB0eSA9PT0gYXkpIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIGlmICh0eCA8PSBzbXgwICYmIHR5IDwgYXkpIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPD0gc214MCAmJiB0eSA+IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4ID49IHNteDAgJiYgdHkgPCBzbXkwKSByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIGlmICh0eCA+PSBzbXgwICYmIHR5ID4gc215MSkgcmV0dXJuIERpcmVjdGlvbnMuTEVGVDtcbiAgICBpZiAodHggPiBzeDEgJiYgdHkgPj0gc215MCAmJiB0eSA8PSBheSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC55IDwgdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICB9XG4gICAgaWYgKHR4ID4gc3gxICYmIHR5IDw9IHNteTEgJiYgdHkgPj0gYXkpIHtcbiAgICAgICAgaWYgKG5leHRJbkxpbmUucG9pbnQueSA8IHR5KSB7XG4gICAgICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5CT1RUT007XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgfVxuXG4gICAgcmV0dXJuIERpcmVjdGlvbnMuUklHSFQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGb3JSaWdodFNvdXJjZVNpZGUoc291cmNlLCB0YXJnZXQsIG5leHRJbkxpbmUpIHtcbiAgICBjb25zdCB7IHkwOiBzeTAsIHgwOiBzeDAsIHdpZHRoLCBoZWlnaHQsIHBvaW50OiBhbmNob3IsIG1hcmdpbiB9ID0gc291cmNlO1xuICAgIGNvbnN0IHN4MSA9IHN4MCArIHdpZHRoO1xuICAgIGNvbnN0IHN5MSA9IHN5MCArIGhlaWdodDtcbiAgICBjb25zdCBzbXgxID0gc3gxICsgbWFyZ2luO1xuICAgIGNvbnN0IHNteTAgPSBzeTAgLSBtYXJnaW47XG4gICAgY29uc3Qgc215MSA9IHN5MSArIG1hcmdpbjtcblxuICAgIGNvbnN0IHsgeDogYXgsIHk6IGF5IH0gPSBhbmNob3I7XG4gICAgY29uc3QgeyB4MDogdHgsIHkwOiB0eSB9ID0gdGFyZ2V0O1xuXG4gICAgaWYgKHR4ID4gYXggJiYgdHkgPT09IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xuICAgIGlmICh0eCA+PSBzbXgxICYmIHR5IDwgYXkpIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICBpZiAodHggPj0gc214MSAmJiB0eSA+IGF5KSByZXR1cm4gRGlyZWN0aW9ucy5UT1A7XG4gICAgaWYgKHR4IDw9IHNteDEgJiYgdHkgPCBzbXkwKSByZXR1cm4gRGlyZWN0aW9ucy5SSUdIVDtcbiAgICBpZiAodHggPD0gc214MSAmJiB0eSA+IHNteTEpIHJldHVybiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIGlmICh0eCA8IHN4MCAmJiB0eSA+PSBzbXkwICYmIHR5IDw9IGF5KSB7XG4gICAgICAgIGlmIChuZXh0SW5MaW5lLnBvaW50LnkgPCB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuQk9UVE9NO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbnMuVE9QO1xuICAgIH1cbiAgICBpZiAodHggPCBzeDAgJiYgdHkgPD0gc215MSAmJiB0eSA+PSBheSkge1xuICAgICAgICBpZiAobmV4dEluTGluZS5wb2ludC55IDwgdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBEaXJlY3Rpb25zLlRPUDtcbiAgICB9XG5cbiAgICByZXR1cm4gRGlyZWN0aW9ucy5MRUZUO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5pdGlhbERpcmVjdGlvbihzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSkge1xuICAgIGNvbnN0IFtzb3VyY2VTaWRlXSA9IHJlc29sdmVTaWRlcyhzb3VyY2UsIHRhcmdldCk7XG5cbiAgICBzd2l0Y2ggKHNvdXJjZVNpZGUpIHtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlRPUDpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yVG9wU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5SSUdIVDpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yUmlnaHRTb3VyY2VTaWRlKHNvdXJjZSwgdGFyZ2V0LCBuZXh0SW5MaW5lKTtcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLkJPVFRPTTpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlRm9yQm90dG9tU291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVGb3JMZWZ0U291cmNlU2lkZShzb3VyY2UsIHRhcmdldCwgbmV4dEluTGluZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREaXJlY3Rpb25Gb3JMaW5rQ29ubmVjdGlvbihsaW5rT3JpZ2luLCBjb25uZWN0aW9uUG9pbnQsIGxpbmtWaWV3KSB7XG4gICAgY29uc3QgdGFuZ2VudCA9IGxpbmtWaWV3LmdldFRhbmdlbnRBdExlbmd0aChsaW5rVmlldy5nZXRDbG9zZXN0UG9pbnRMZW5ndGgoY29ubmVjdGlvblBvaW50KSk7XG4gICAgY29uc3Qgcm91bmRlZEFuZ2xlID0gTWF0aC5yb3VuZChnZXRTZWdtZW50QW5nbGUodGFuZ2VudCkgLyA5MCkgKiA5MDtcblxuICAgIGlmIChyb3VuZGVkQW5nbGUgJSAxODAgPT09IDAgJiYgbGlua09yaWdpbi55ID09PSBjb25uZWN0aW9uUG9pbnQueSkge1xuICAgICAgICByZXR1cm4gbGlua09yaWdpbi54IDwgY29ubmVjdGlvblBvaW50LnggPyBEaXJlY3Rpb25zLkxFRlQgOiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIH0gZWxzZSBpZiAobGlua09yaWdpbi54ID09PSBjb25uZWN0aW9uUG9pbnQueCkge1xuICAgICAgICByZXR1cm4gbGlua09yaWdpbi55IDwgY29ubmVjdGlvblBvaW50LnkgPyBEaXJlY3Rpb25zLlRPUCA6IERpcmVjdGlvbnMuQk9UVE9NO1xuICAgIH1cblxuICAgIHN3aXRjaCAocm91bmRlZEFuZ2xlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxODA6XG4gICAgICAgIGNhc2UgMzYwOlxuICAgICAgICAgICAgcmV0dXJuIGxpbmtPcmlnaW4ueSA8IGNvbm5lY3Rpb25Qb2ludC55ID8gRGlyZWN0aW9ucy5UT1AgOiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICByZXR1cm4gbGlua09yaWdpbi54IDwgY29ubmVjdGlvblBvaW50LnggPyBEaXJlY3Rpb25zLkxFRlQgOiBEaXJlY3Rpb25zLlJJR0hUO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9pbnREYXRhRnJvbUFuY2hvcih2aWV3LCBwb2ludCwgYmJveCwgZGlyZWN0aW9uLCBpc1BvcnQsIGZhbGxCYWNrQW5jaG9yLCBtYXJnaW4pIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkFVVE8pIHtcbiAgICAgICAgZGlyZWN0aW9uID0gaXNQb3J0ID8gRGlyZWN0aW9ucy5NQUdORVRfU0lERSA6IERpcmVjdGlvbnMuQU5DSE9SX1NJREU7XG4gICAgfVxuXG4gICAgY29uc3QgaXNFbGVtZW50ID0gdmlldyAmJiB2aWV3Lm1vZGVsLmlzRWxlbWVudCgpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB4OiB4MCxcbiAgICAgICAgeTogeTAsXG4gICAgICAgIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMFxuICAgIH0gPSBpc0VsZW1lbnQgPyBnLlJlY3QuZnJvbVJlY3RVbmlvbihiYm94LCB2aWV3Lm1vZGVsLmdldEJCb3goKSkgOiBmYWxsQmFja0FuY2hvcjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50LFxuICAgICAgICB4MCxcbiAgICAgICAgeTAsXG4gICAgICAgIHZpZXcsXG4gICAgICAgIGJib3gsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbWFyZ2luOiBpc0VsZW1lbnQgPyBtYXJnaW4gOiAwXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcG9pbnREYXRhRnJvbVZlcnRleCh7IHgsIHkgfSkge1xuICAgIGNvbnN0IHBvaW50ID0gbmV3IGcuUG9pbnQoeCwgeSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludCxcbiAgICAgICAgeDA6IHBvaW50LngsXG4gICAgICAgIHkwOiBwb2ludC55LFxuICAgICAgICB2aWV3OiBudWxsLFxuICAgICAgICBiYm94OiBuZXcgZy5SZWN0KHgsIHksIDAsIDApLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBkaXJlY3Rpb246IG51bGwsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldE91dHNpZGVQb2ludChzaWRlLCBwb2ludERhdGEsIG1hcmdpbikge1xuICAgIGNvbnN0IG91dHNpZGVQb2ludCA9IHBvaW50RGF0YS5wb2ludC5jbG9uZSgpO1xuXG4gICAgY29uc3QgeyB4MCwgeTAsIHdpZHRoLCBoZWlnaHQgfSA9IHBvaW50RGF0YTtcblxuICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIG91dHNpZGVQb2ludC54ID0geDAgLSBtYXJnaW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgb3V0c2lkZVBvaW50LnggPSB4MCArIHdpZHRoICsgbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBvdXRzaWRlUG9pbnQueSA9IHkwIC0gbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBvdXRzaWRlUG9pbnQueSA9IHkwICsgaGVpZ2h0ICsgbWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHNpZGVQb2ludDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9vcChmcm9tLCB0bywgeyBkeCA9IDAsIGR5ID0gMCB9KSB7XG4gICAgY29uc3QgcDEgPSB7IHg6IGZyb20ucG9pbnQueCArIGR4LCB5OiBmcm9tLnBvaW50LnkgKyBkeSB9O1xuICAgIGNvbnN0IHAyID0geyB4OiB0by5wb2ludC54ICsgZHgsIHk6IHRvLnBvaW50LnkgKyBkeSB9O1xuXG4gICAgcmV0dXJuIFtmcm9tLnBvaW50LCBwMSwgcDIsIHRvLnBvaW50XTtcbn1cblxuZnVuY3Rpb24gbG9vcFNlZ21lbnQoZnJvbSwgdG8sIGNvbm5lY3Rpb25TZWdtZW50QW5nbGUsIG1hcmdpbikge1xuICAgIC8vIEZpbmQgb3V0IHRoZSBsb29wIGNvb3JkaW5hdGVzLlxuICAgIGNvbnN0IGFuZ2xlID0gZy5ub3JtYWxpemVBbmdsZShjb25uZWN0aW9uU2VnbWVudEFuZ2xlIC0gOTApO1xuXG4gICAgbGV0IGR4ID0gMDtcbiAgICBsZXQgZHkgPSAwO1xuXG4gICAgaWYgKGFuZ2xlID09PSA5MCkge1xuICAgICAgICBkeSA9IC1tYXJnaW47XG4gICAgfSBlbHNlIGlmIChhbmdsZSA9PT0gMTgwKSB7XG4gICAgICAgIGR4ID0gLW1hcmdpbjtcbiAgICB9IGVsc2UgaWYgKGFuZ2xlID09PSAyNzApIHtcbiAgICAgICAgZHkgPSBtYXJnaW47XG4gICAgfSBlbHNlIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgICBkeCA9IG1hcmdpbjtcbiAgICB9XG5cbiAgICBjb25zdCBsb29wUm91dGUgPSBjcmVhdGVMb29wKGZyb20sIHRvLCB7IGR4LCBkeSB9KTtcblxuICAgIGNvbnN0IHNlY29uZENyZWF0ZWRQb2ludCA9IGxvb3BSb3V0ZVsyXTtcbiAgICBjb25zdCBsb29wRW5kU2VnbWVudCA9IG5ldyBnLkxpbmUodG8ucG9pbnQsIHNlY29uZENyZWF0ZWRQb2ludCk7XG4gICAgLy8gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgbG9vcCBzaG91bGQgY29udGludWUuXG4gICAgY29uc3QgY29udGludWVEaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW2dldFNlZ21lbnRBbmdsZShsb29wRW5kU2VnbWVudCldO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9vcFJvdXRlLFxuICAgICAgICBjb250aW51ZURpcmVjdGlvblxuICAgIH07XG59XG5cbi8vIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlcyBhbG9uZyB0aGUgaG9yaXpvbnRhbCBheGlzIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgcm91dGUuXG5mdW5jdGlvbiBnZXRIb3Jpem9udGFsRGlzdGFuY2Uoc291cmNlLCB0YXJnZXQpIHtcblxuICAgIGNvbnN0IHsgeDA6IHN4MCwgeDE6IHN4MSwgb3V0c2lkZVBvaW50OiBzb3VyY2VQb2ludCB9ID0gc291cmNlO1xuICAgIGNvbnN0IHsgeDA6IHR4MCwgeDE6IHR4MSwgb3V0c2lkZVBvaW50OiB0YXJnZXRQb2ludCB9ID0gdGFyZ2V0O1xuXG4gICAgLy8gRnVydGhlc3QgbGVmdCBib3VuZGFyeVxuICAgIGxldCBsZWZ0Qm91bmRhcnkgPSBNYXRoLm1pbihzeDAsIHR4MCk7XG4gICAgLy8gRnVydGhlc3QgcmlnaHQgYm91bmRhcnlcbiAgICBsZXQgcmlnaHRCb3VuZGFyeSA9IE1hdGgubWF4KHN4MSwgdHgxKTtcblxuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBhcmUgb24gdGhlIHNhbWUgc2lkZSwgd2UgbmVlZCB0byBmaWd1cmUgb3V0IHdoYXQgc2hhcGUgZGVmaW5lcyB0aGUgYm91bmRhcnkuXG4gICAgaWYgKHNvdXJjZS5kaXJlY3Rpb24gPT09IHRhcmdldC5kaXJlY3Rpb24pIHtcblxuICAgICAgICBjb25zdCBhYm92ZVNoYXBlID0gc291cmNlLnkwIDwgdGFyZ2V0LnkwID8gc291cmNlIDogdGFyZ2V0O1xuICAgICAgICBjb25zdCBiZWxvd1NoYXBlID0gYWJvdmVTaGFwZSA9PT0gc291cmNlID8gdGFyZ2V0IDogc291cmNlO1xuXG4gICAgICAgIC8vIFRoZSBzb3VyY2UgYW5kIHRhcmdldCBhbmNob3JzIGFyZSBvbiB0aGUgdG9wID0+IHRoZW4gdGhlIGBhYm92ZVNoYXBlYCBkZWZpbmVzIHRoZSBib3VuZGFyeS5cbiAgICAgICAgLy8gVGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGFuY2hvcnMgYXJlIG9uIHRoZSBib3R0b20gPT4gdGhlbiB0aGUgYGJlbG93U2hhcGVgIGRlZmluZXMgdGhlIGJvdW5kYXJ5LlxuICAgICAgICBjb25zdCBib3VuZGFyeURlZmluaW5nU2hhcGUgPSBzb3VyY2UuZGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlRPUCA/IGFib3ZlU2hhcGUgOiBiZWxvd1NoYXBlO1xuXG4gICAgICAgIGxlZnRCb3VuZGFyeSA9IGJvdW5kYXJ5RGVmaW5pbmdTaGFwZS54MDtcbiAgICAgICAgcmlnaHRCb3VuZGFyeSA9IGJvdW5kYXJ5RGVmaW5pbmdTaGFwZS54MTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHg6IHNveCB9ID0gc291cmNlUG9pbnQ7XG4gICAgY29uc3QgeyB4OiB0b3ggfSA9IHRhcmdldFBvaW50O1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZXMgZm9yIHRoZSBsZWZ0IHJvdXRlXG4gICAgY29uc3QgbGVmdERpc3RhbmNlMSA9IE1hdGguYWJzKHNveCAtIGxlZnRCb3VuZGFyeSk7XG4gICAgY29uc3QgbGVmdERpc3RhbmNlMiA9IE1hdGguYWJzKHRveCAtIGxlZnRCb3VuZGFyeSk7XG4gICAgY29uc3QgbGVmdEQgPSBsZWZ0RGlzdGFuY2UxICsgbGVmdERpc3RhbmNlMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2VzIGZvciB0aGUgcmlnaHQgcm91dGVcbiAgICBjb25zdCByaWdodERpc3RhbmNlMSA9IE1hdGguYWJzKHNveCAtIHJpZ2h0Qm91bmRhcnkpO1xuICAgIGNvbnN0IHJpZ2h0RGlzdGFuY2UyID0gTWF0aC5hYnModG94IC0gcmlnaHRCb3VuZGFyeSk7XG4gICAgY29uc3QgcmlnaHREID0gcmlnaHREaXN0YW5jZTEgKyByaWdodERpc3RhbmNlMjtcblxuICAgIHJldHVybiBbbGVmdEQsIHJpZ2h0RF07XG59XG5cbi8vIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlcyBhbG9uZyB0aGUgdmVydGljYWwgYXhpcyBmb3IgdGhlIHRvcCBhbmQgYm90dG9tIHJvdXRlLlxuZnVuY3Rpb24gZ2V0VmVydGljYWxEaXN0YW5jZShzb3VyY2UsIHRhcmdldCkge1xuXG4gICAgY29uc3QgeyB5MDogc3kwLCB5MTogc3kxLCBvdXRzaWRlUG9pbnQ6IHNvdXJjZVBvaW50IH0gPSBzb3VyY2U7XG4gICAgY29uc3QgeyB5MDogdHkwLCB5MTogdHkxLCBvdXRzaWRlUG9pbnQ6IHRhcmdldFBvaW50IH0gPSB0YXJnZXQ7XG5cbiAgICAvLyBGdXJ0aGVzdCB0b3AgYm91bmRhcnlcbiAgICBsZXQgdG9wQm91bmRhcnkgPSBNYXRoLm1pbihzeTAsIHR5MCk7XG4gICAgLy8gRnVydGhlc3QgYm90dG9tIGJvdW5kYXJ5XG4gICAgbGV0IGJvdHRvbUJvdW5kYXJ5ID0gTWF0aC5tYXgoc3kxLCB0eTEpO1xuXG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzIGFyZSBvbiB0aGUgc2FtZSBzaWRlLCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgd2hhdCBzaGFwZSBkZWZpbmVzIHRoZSBib3VuZGFyeS5cbiAgICBpZiAoc291cmNlLmRpcmVjdGlvbiA9PT0gdGFyZ2V0LmRpcmVjdGlvbikge1xuXG4gICAgICAgIGNvbnN0IGxlZnRTaGFwZSA9IHNvdXJjZS54MCA8IHRhcmdldC54MCA/IHNvdXJjZSA6IHRhcmdldDtcbiAgICAgICAgY29uc3QgcmlnaHRTaGFwZSA9IGxlZnRTaGFwZSA9PT0gc291cmNlID8gdGFyZ2V0IDogc291cmNlO1xuXG4gICAgICAgIC8vIFRoZSBzb3VyY2UgYW5kIHRhcmdldCBhbmNob3JzIGFyZSBvbiB0aGUgbGVmdCA9PiB0aGVuIHRoZSBgbGVmdFNoYXBlYCBkZWZpbmVzIHRoZSBib3VuZGFyeS5cbiAgICAgICAgLy8gVGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGFuY2hvcnMgYXJlIG9uIHRoZSByaWdodCA9PiB0aGVuIHRoZSBgcmlnaHRTaGFwZWAgZGVmaW5lcyB0aGUgYm91bmRhcnkuXG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5RGVmaW5pbmdTaGFwZSA9IHNvdXJjZS5kaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuTEVGVCA/IGxlZnRTaGFwZSA6IHJpZ2h0U2hhcGU7XG5cbiAgICAgICAgdG9wQm91bmRhcnkgPSBib3VuZGFyeURlZmluaW5nU2hhcGUueTA7XG4gICAgICAgIGJvdHRvbUJvdW5kYXJ5ID0gYm91bmRhcnlEZWZpbmluZ1NoYXBlLnkxOyAgXG4gICAgfVxuXG4gICAgY29uc3QgeyB5OiBzb3kgfSA9IHNvdXJjZVBvaW50O1xuICAgIGNvbnN0IHsgeTogdG95IH0gPSB0YXJnZXRQb2ludDtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2VzIGZvciB0aGUgdG9wIHJvdXRlXG4gICAgY29uc3QgdG9wRGlzdGFuY2UxID0gTWF0aC5hYnMoc295IC0gdG9wQm91bmRhcnkpO1xuICAgIGNvbnN0IHRvcERpc3RhbmNlMiA9IE1hdGguYWJzKHRveSAtIHRvcEJvdW5kYXJ5KTtcbiAgICBjb25zdCB0b3BEID0gdG9wRGlzdGFuY2UxICsgdG9wRGlzdGFuY2UyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZXMgZm9yIHRoZSBib3R0b20gcm91dGVcbiAgICBjb25zdCBib3R0b21EaXN0YW5jZTEgPSBNYXRoLmFicyhzb3kgLSBib3R0b21Cb3VuZGFyeSk7XG4gICAgY29uc3QgYm90dG9tRGlzdGFuY2UyID0gTWF0aC5hYnModG95IC0gYm90dG9tQm91bmRhcnkpO1xuICAgIGNvbnN0IGJvdHRvbUQgPSBib3R0b21EaXN0YW5jZTEgKyBib3R0b21EaXN0YW5jZTI7XG5cbiAgICByZXR1cm4gW3RvcEQsIGJvdHRvbURdO1xufVxuXG4vLyBJbmZsYXRlIGJib3ggaW4gMyBkaXJlY3Rpb25zIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBhbmNob3Jcbi8vIGRvbid0IGluZmxhdGUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiB0aGUgYW5jaG9yXG5mdW5jdGlvbiBtb3ZlQW5kRXhwYW5kQkJveChiYm94LCBkaXJlY3Rpb24sIG1hcmdpbikge1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGNhc2UgRGlyZWN0aW9ucy5MRUZUOlxuICAgICAgICAgICAgYmJveC5pbmZsYXRlKDAsIG1hcmdpbikubW92ZUFuZEV4cGFuZCh7IHg6IC1tYXJnaW4sIHdpZHRoOiBtYXJnaW4gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlJJR0hUOlxuICAgICAgICAgICAgYmJveC5pbmZsYXRlKDAsIG1hcmdpbikubW92ZUFuZEV4cGFuZCh7IHdpZHRoOiBtYXJnaW4gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBEaXJlY3Rpb25zLlRPUDpcbiAgICAgICAgICAgIGJib3guaW5mbGF0ZShtYXJnaW4sIDApLm1vdmVBbmRFeHBhbmQoeyB5OiAtbWFyZ2luLCBoZWlnaHQ6IG1hcmdpbiB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERpcmVjdGlvbnMuQk9UVE9NOlxuICAgICAgICAgICAgYmJveC5pbmZsYXRlKG1hcmdpbiwgMCkubW92ZUFuZEV4cGFuZCh7IGhlaWdodDogbWFyZ2luIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJib3g7XG59XG5cbmZ1bmN0aW9uIHJvdXRlQmV0d2VlblBvaW50cyhzb3VyY2UsIHRhcmdldCwgb3B0ID0ge30pIHtcbiAgICBjb25zdCB7IHBvaW50OiBzb3VyY2VQb2ludCwgeDA6IHN4MCwgeTA6IHN5MCwgd2lkdGg6IHNvdXJjZVdpZHRoLCBoZWlnaHQ6IHNvdXJjZUhlaWdodCwgbWFyZ2luOiBzb3VyY2VNYXJnaW4gfSA9IHNvdXJjZTtcbiAgICBjb25zdCB7IHBvaW50OiB0YXJnZXRQb2ludCwgeDA6IHR4MCwgeTA6IHR5MCwgd2lkdGg6IHRhcmdldFdpZHRoLCBoZWlnaHQ6IHRhcmdldEhlaWdodCwgbWFyZ2luOiB0YXJnZXRNYXJnaW4gfSA9IHRhcmdldDtcbiAgICBjb25zdCB7IHRhcmdldEluU291cmNlQkJveCA9IGZhbHNlIH0gPSBvcHQ7XG5cbiAgICBjb25zdCB0eDEgPSB0eDAgKyB0YXJnZXRXaWR0aDtcbiAgICBjb25zdCB0eTEgPSB0eTAgKyB0YXJnZXRIZWlnaHQ7XG4gICAgY29uc3Qgc3gxID0gc3gwICsgc291cmNlV2lkdGg7XG4gICAgY29uc3Qgc3kxID0gc3kwICsgc291cmNlSGVpZ2h0O1xuXG4gICAgLy8gS2V5IGNvb3JkaW5hdGVzIGluY2x1ZGluZyB0aGUgbWFyZ2luXG4gICAgY29uc3Qgc214MCA9IHN4MCAtIHNvdXJjZU1hcmdpbjtcbiAgICBjb25zdCBzbXgxID0gc3gxICsgc291cmNlTWFyZ2luO1xuICAgIGNvbnN0IHNteTAgPSBzeTAgLSBzb3VyY2VNYXJnaW47XG4gICAgY29uc3Qgc215MSA9IHN5MSArIHNvdXJjZU1hcmdpbjtcblxuICAgIGNvbnN0IHRteDAgPSB0eDAgLSB0YXJnZXRNYXJnaW47XG4gICAgY29uc3QgdG14MSA9IHR4MSArIHRhcmdldE1hcmdpbjtcbiAgICBjb25zdCB0bXkwID0gdHkwIC0gdGFyZ2V0TWFyZ2luO1xuICAgIGNvbnN0IHRteTEgPSB0eTEgKyB0YXJnZXRNYXJnaW47XG5cbiAgICBjb25zdCBbc291cmNlU2lkZSwgdGFyZ2V0U2lkZV0gPSByZXNvbHZlU2lkZXMoc291cmNlLCB0YXJnZXQpO1xuXG4gICAgY29uc3Qgc291cmNlT3V0c2lkZVBvaW50ID0gZ2V0T3V0c2lkZVBvaW50KHNvdXJjZVNpZGUsIHsgcG9pbnQ6IHNvdXJjZVBvaW50LCB4MDogc3gwLCB5MDogc3kwLCB3aWR0aDogc291cmNlV2lkdGgsIGhlaWdodDogc291cmNlSGVpZ2h0IH0sIHNvdXJjZU1hcmdpbik7XG4gICAgY29uc3QgdGFyZ2V0T3V0c2lkZVBvaW50ID0gZ2V0T3V0c2lkZVBvaW50KHRhcmdldFNpZGUsIHsgcG9pbnQ6IHRhcmdldFBvaW50LCB4MDogdHgwLCB5MDogdHkwLCB3aWR0aDogdGFyZ2V0V2lkdGgsIGhlaWdodDogdGFyZ2V0SGVpZ2h0IH0sIHRhcmdldE1hcmdpbik7XG5cbiAgICBjb25zdCB7IHg6IHNveCwgeTogc295IH0gPSBzb3VyY2VPdXRzaWRlUG9pbnQ7XG4gICAgY29uc3QgeyB4OiB0b3gsIHk6IHRveSB9ID0gdGFyZ2V0T3V0c2lkZVBvaW50O1xuICAgIGNvbnN0IHRjeCA9ICh0eDAgKyB0eDEpIC8gMjtcbiAgICBjb25zdCB0Y3kgPSAodHkwICsgdHkxKSAvIDI7XG4gICAgY29uc3Qgc2N4ID0gKHN4MCArIHN4MSkgLyAyO1xuICAgIGNvbnN0IHNjeSA9IChzeTAgKyBzeTEpIC8gMjtcbiAgICBjb25zdCBtaWRkbGVPZlZlcnRpY2FsU2lkZXMgPSAoc2N4IDwgdGN4ID8gKHN4MSArIHR4MCkgOiAodHgxICsgc3gwKSkgLyAyO1xuICAgIGNvbnN0IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzID0gKHNjeSA8IHRjeSA/IChzeTEgKyB0eTApIDogKHR5MSArIHN5MCkpIC8gMjtcblxuICAgIGNvbnN0IHNvdXJjZUJCb3ggPSBuZXcgZy5SZWN0KHN4MCwgc3kwLCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KTtcbiAgICBjb25zdCB0YXJnZXRCQm94ID0gbmV3IGcuUmVjdCh0eDAsIHR5MCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XG4gICAgY29uc3QgaW5mbGF0ZWRTb3VyY2VCQm94ID0gc291cmNlQkJveC5jbG9uZSgpLmluZmxhdGUoc291cmNlTWFyZ2luKTtcbiAgICBjb25zdCBpbmZsYXRlZFRhcmdldEJCb3ggPSB0YXJnZXRCQm94LmNsb25lKCkuaW5mbGF0ZSh0YXJnZXRNYXJnaW4pO1xuXG4gICAgY29uc3Qgc291cmNlRm9yRGlzdGFuY2UgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UsIHsgeDE6IHN4MSwgeTE6IHN5MSwgb3V0c2lkZVBvaW50OiBzb3VyY2VPdXRzaWRlUG9pbnQsIGRpcmVjdGlvbjogc291cmNlU2lkZSB9KTtcbiAgICBjb25zdCB0YXJnZXRGb3JEaXN0YW5jZSA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgeyB4MTogdHgxLCB5MTogdHkxLCBvdXRzaWRlUG9pbnQ6IHRhcmdldE91dHNpZGVQb2ludCwgZGlyZWN0aW9uOiB0YXJnZXRTaWRlIH0pO1xuXG4gICAgLy8gRGlzdGFuY2VzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzaG9ydGVzdCByb3V0ZSBhbG9uZyB0aGUgY29ubmVjdGlvbnMgb24gaG9yaXpvbnRhbCBzaWRlcyBmb3JcbiAgICAvLyBib3R0b20gPT4gYm90dG9tXG4gICAgLy8gdG9wID0+IGJvdHRvbVxuICAgIC8vIGJvdHRvbSA9PiB0b3BcbiAgICAvLyB0b3AgPT4gdG9wXG4gICAgY29uc3QgW2xlZnRELCByaWdodERdID0gZ2V0SG9yaXpvbnRhbERpc3RhbmNlKHNvdXJjZUZvckRpc3RhbmNlLCB0YXJnZXRGb3JEaXN0YW5jZSk7XG5cbiAgICAvLyBEaXN0YW5jZXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHNob3J0ZXN0IHJvdXRlIGFsb25nIHRoZSBjb25uZWN0aW9uIG9uIHZlcnRpY2FsIHNpZGVzIGZvclxuICAgIC8vIGxlZnQgPT4gbGVmdFxuICAgIC8vIGxlZnQgPT4gcmlnaHRcbiAgICAvLyByaWdodCA9PiByaWdodFxuICAgIC8vIHJpZ2h0ID0+IGxlZnRcbiAgICBjb25zdCBbdG9wRCwgYm90dG9tRF0gPSBnZXRWZXJ0aWNhbERpc3RhbmNlKHNvdXJjZUZvckRpc3RhbmNlLCB0YXJnZXRGb3JEaXN0YW5jZSk7XG5cbiAgICAvLyBBbGwgcG9zc2libGUgY29tYmluYXRpb25zIG9mIHNvdXJjZSBhbmQgdGFyZ2V0IHNpZGVzXG4gICAgaWYgKHNvdXJjZVNpZGUgPT09ICdsZWZ0JyAmJiB0YXJnZXRTaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRPdXRzaWRlUG9pbnQpO1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlVGFyZ2V0ID0gaW5mbGF0ZWRUYXJnZXRCQm94LmNvbnRhaW5zUG9pbnQoc291cmNlT3V0c2lkZVBvaW50KTtcblxuICAgICAgICAvLyBVc2UgUy1zaGFwZWQgY29ubmVjdGlvblxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSB8fCBpc1BvaW50SW5zaWRlVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBtaWRkbGVPZkFuY2hvcnMgPSAoc295ICsgdG95KSAvIDI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBtaWRkbGVPZkFuY2hvcnMgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogbWlkZGxlT2ZBbmNob3JzIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteDAgPCB0b3gpIHtcbiAgICAgICAgICAgIGxldCB5ID0gbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXM7XG4gICAgICAgICAgICBsZXQgeDEgPSBzb3g7XG4gICAgICAgICAgICBsZXQgeDIgPSB0b3g7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzVXB3YXJkc1Nob3J0ZXIgPSB0b3BEIDwgYm90dG9tRDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzIG92ZXJsYXAsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBnb2VzIGFyb3VuZCB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoKHkgPj0gc215MCAmJiB5IDw9IHNteTEpIHx8ICh5ID49IHRteTAgJiYgeSA8PSB0bXkxKSkge1xuICAgICAgICAgICAgICAgIGlmIChzbXkxID49IHRteTAgJiYgaXNVcHdhcmRzU2hvcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4odG15MCwgc215MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbXkwIDw9IHRteTEgJiYgIWlzVXB3YXJkc1Nob3J0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHRteTEsIHNteTEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBvdmVybGFwIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FzZSB3aGVuIHRoZSBzb3VyY2UgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHgxID0gTWF0aC5taW4oc294LCB0bXgwKTtcbiAgICAgICAgICAgICAgICB4MiA9IE1hdGgubWF4KHRveCwgc214MSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVkZ2UgY2FzZSB3aGVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBpbnRlcnNlY3QgYW5kXG4gICAgICAgICAgICAgICAgaWYgKChpc1Vwd2FyZHNTaG9ydGVyICYmIHNveSA8IHR5MCkgfHwgKCFpc1Vwd2FyZHNTaG9ydGVyICYmIHNveSA+IHR5MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGggc2hvdWxkIG5vIGxvbmdlciByZWx5IG9uIG1pbmltYWwgeCBib3VuZGFyeSBpbiBgeDFgXG4gICAgICAgICAgICAgICAgICAgIHgxID0gc294O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGlzVXB3YXJkc1Nob3J0ZXIgJiYgdG95IDwgc3kwKSB8fCAoIWlzVXB3YXJkc1Nob3J0ZXIgJiYgdG95ID4gc3kxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0aCBzaG91bGQgbm8gbG9uZ2VyIHJlbHkgb24gbWF4aW1hbCB4IGJvdW5kYXJ5IGluIGB4MmBcbiAgICAgICAgICAgICAgICAgICAgeDIgPSB0b3g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogeDEsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogeDEsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgyLCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB4MiwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gKHNveCArIHRveCkgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogdG95IH0sXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAncmlnaHQnICYmIHRhcmdldFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0T3V0c2lkZVBvaW50KTtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVRhcmdldCA9IGluZmxhdGVkVGFyZ2V0QkJveC5jb250YWluc1BvaW50KHNvdXJjZU91dHNpZGVQb2ludCk7XG5cbiAgICAgICAgLy8gVXNlIFMtc2hhcGVkIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UgfHwgaXNQb2ludEluc2lkZVRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlT2ZBbmNob3JzID0gKHNveSArIHRveSkgLyAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogbWlkZGxlT2ZBbmNob3JzIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IG1pZGRsZU9mQW5jaG9ycyB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXgxID4gdG94KSB7XG4gICAgICAgICAgICBsZXQgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuICAgICAgICAgICAgbGV0IHgxID0gc294O1xuICAgICAgICAgICAgbGV0IHgyID0gdG94O1xuXG4gICAgICAgICAgICBjb25zdCBpc1Vwd2FyZHNTaG9ydGVyID0gdG9wRCA8IGJvdHRvbUQ7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBvdmVybGFwLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgLy8gZ29lcyBhcm91bmQgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgICAgaWYgKCh5ID49IHNteTAgJiYgeSA8PSBzbXkxKSB8fCAoeSA+PSB0bXkwICYmIHkgPD0gdG15MSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc215MSA+PSB0bXkwICYmIGlzVXB3YXJkc1Nob3J0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHRteTAsIHNteTApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc215MCA8PSB0bXkxICYmICFpc1Vwd2FyZHNTaG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCh0bXkxLCBzbXkxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudHMgb3ZlcmxhcCBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgICAgLy8gdGhlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICB4MSA9IE1hdGgubWF4KHNveCwgdG14MSk7XG4gICAgICAgICAgICAgICAgeDIgPSBNYXRoLm1pbih0b3gsIHNteDApO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBlZGdlIGNhc2Ugd2hlbiB0aGUgc291cmNlIGFuZCB0YXJnZXQgaW50ZXJzZWN0IGFuZFxuICAgICAgICAgICAgICAgIGlmICgoaXNVcHdhcmRzU2hvcnRlciAmJiBzb3kgPCB0eTApIHx8ICghaXNVcHdhcmRzU2hvcnRlciAmJiBzb3kgPiB0eTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXRoIHNob3VsZCBubyBsb25nZXIgcmVseSBvbiBtYXhpbWFsIHggYm91bmRhcnkgaW4gYHgxYFxuICAgICAgICAgICAgICAgICAgICB4MSA9IHNveDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChpc1Vwd2FyZHNTaG9ydGVyICYmIHRveSA8IHN5MCkgfHwgKCFpc1Vwd2FyZHNTaG9ydGVyICYmIHRveSA+IHN5MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGggc2hvdWxkIG5vIGxvbmdlciByZWx5IG9uIG1pbmltYWwgeCBib3VuZGFyeSBpbiBgeDJgXG4gICAgICAgICAgICAgICAgICAgIHgyID0gdG94O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHgxLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHgxLCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB4MiwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogeDIsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IChzb3ggKyB0b3gpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAndG9wJyAmJiB0YXJnZXRTaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0T3V0c2lkZVBvaW50KTtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVRhcmdldCA9IGluZmxhdGVkVGFyZ2V0QkJveC5jb250YWluc1BvaW50KHNvdXJjZU91dHNpZGVQb2ludCk7XG5cbiAgICAgICAgLy8gVXNlIFMtc2hhcGVkIGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UgfHwgaXNQb2ludEluc2lkZVRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgbWlkZGxlT2ZBbmNob3JzID0gKHNveCArIHRveCkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IG1pZGRsZU9mQW5jaG9ycywgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBtaWRkbGVPZkFuY2hvcnMsIHk6IHRveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXkwIDwgdG95KSB7XG4gICAgICAgICAgICBsZXQgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcbiAgICAgICAgICAgIGxldCB5MSA9IHNveTtcbiAgICAgICAgICAgIGxldCB5MiA9IHRveTtcblxuICAgICAgICAgICAgY29uc3QgaXNMZWZ0U2hvcnRlciA9IGxlZnREIDwgcmlnaHREO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc291cmNlIGFuZCB0YXJnZXQgZWxlbWVudHMgb3ZlcmxhcCwgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgIC8vIGdvZXMgYXJvdW5kIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgICAgIGlmICgoeCA+PSBzbXgwICYmIHggPD0gc214MSkgfHwgKHggPj0gdG14MCAmJiB4IDw9IHRteDEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNteDEgPj0gdG14MCAmJiBpc0xlZnRTaG9ydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBNYXRoLm1pbih0bXgwLCBzbXgwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNteDAgPD0gdG14MSAmJiAhaXNMZWZ0U2hvcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgodG14MSwgc214MSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzIG92ZXJsYXAgYXMgd2VsbCBhc1xuICAgICAgICAgICAgICAgIC8vIHRoZSBjYXNlIHdoZW4gdGhlIHNvdXJjZSBpcyB0byB0aGUgbGVmdCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgeTEgPSBNYXRoLm1pbihzb3ksIHRteTApO1xuICAgICAgICAgICAgICAgIHkyID0gTWF0aC5tYXgodG95LCBzbXkxKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZWRnZSBjYXNlIHdoZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGludGVyc2VjdCBhbmRcbiAgICAgICAgICAgICAgICBpZiAoKGlzTGVmdFNob3J0ZXIgJiYgc294IDwgdHgwKSB8fCAoIWlzTGVmdFNob3J0ZXIgJiYgc294ID4gdHgxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0aCBzaG91bGQgbm8gbG9uZ2VyIHJlbHkgb24gbWluaW1hbCB5IGJvdW5kYXJ5IGluIGB5MWBcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBzb3k7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoaXNMZWZ0U2hvcnRlciAmJiB0b3ggPCBzeDApIHx8ICghaXNMZWZ0U2hvcnRlciAmJiB0b3ggPiBzeDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwYXRoIHNob3VsZCBubyBsb25nZXIgcmVseSBvbiBtYXhpbWFsIHkgYm91bmRhcnkgaW4gYHkyYFxuICAgICAgICAgICAgICAgICAgICB5MiA9IHRveTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHkxIH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB5MSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogeTIgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogeTIgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHkgPSAoc295ICsgdG95KSAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2JvdHRvbScgJiYgdGFyZ2V0U2lkZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldE91dHNpZGVQb2ludCk7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVUYXJnZXQgPSBpbmZsYXRlZFRhcmdldEJCb3guY29udGFpbnNQb2ludChzb3VyY2VPdXRzaWRlUG9pbnQpO1xuXG4gICAgICAgIC8vIFVzZSBTLXNoYXBlZCBjb25uZWN0aW9uXG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlIHx8IGlzUG9pbnRJbnNpZGVUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZGRsZU9mQW5jaG9ycyA9IChzb3ggKyB0b3gpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBtaWRkbGVPZkFuY2hvcnMsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogbWlkZGxlT2ZBbmNob3JzLCB5OiB0b3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc215MSA+IHRveSkge1xuICAgICAgICAgICAgbGV0IHggPSBtaWRkbGVPZlZlcnRpY2FsU2lkZXM7XG4gICAgICAgICAgICBsZXQgeTEgPSBzb3k7XG4gICAgICAgICAgICBsZXQgeTIgPSB0b3k7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGlzTGVmdFNob3J0ZXIgPSBsZWZ0RCA8IHJpZ2h0RDtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzIG92ZXJsYXAsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBnb2VzIGFyb3VuZCB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgICAgICBpZiAoKHggPj0gc214MCAmJiB4IDw9IHNteDEpIHx8ICh4ID49IHRteDAgJiYgeCA8PSB0bXgxKSkge1xuICAgICAgICAgICAgICAgIGlmIChzbXgxID49IHRteDAgJiYgaXNMZWZ0U2hvcnRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4odG14MCwgc214MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbXgwIDw9IHRteDEgJiYgIWlzTGVmdFNob3J0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHRteDEsIHNteDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBlbGVtZW50cyBvdmVybGFwIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FzZSB3aGVuIHRoZSBzb3VyY2UgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHkxID0gTWF0aC5tYXgoc295LCB0bXkxKTtcbiAgICAgICAgICAgICAgICB5MiA9IE1hdGgubWluKHRveSwgc215MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGVkZ2UgY2FzZSB3aGVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBpbnRlcnNlY3QgYW5kXG4gICAgICAgICAgICAgICAgaWYgKChpc0xlZnRTaG9ydGVyICYmIHNveCA8IHR4MCkgfHwgKCFpc0xlZnRTaG9ydGVyICYmIHNveCA+IHR4MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdGggc2hvdWxkIG5vIGxvbmdlciByZWx5IG9uIG1heGltYWwgeSBib3VuZGFyeSBpbiBgeTFgXG4gICAgICAgICAgICAgICAgICAgIHkxID0gc295O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGlzTGVmdFNob3J0ZXIgJiYgdG94IDwgc3gwKSB8fCAoIWlzTGVmdFNob3J0ZXIgJiYgdG94ID4gc3gxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGF0aCBzaG91bGQgbm8gbG9uZ2VyIHJlbHkgb24gbWluaW1hbCB5IGJvdW5kYXJ5IGluIGB5MmBcbiAgICAgICAgICAgICAgICAgICAgeTIgPSB0b3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiB5MSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogeTEgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHkyIH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHkyIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB5ID0gKHNveSArIHRveSkgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICd0b3AnICYmIHRhcmdldFNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgIGNvbnN0IHVzZVVTaGFwZUNvbm5lY3Rpb24gPVxuICAgICAgICAgICAgdGFyZ2V0SW5Tb3VyY2VCQm94IHx8XG4gICAgICAgICAgICBnLmludGVyc2VjdGlvbi5yZWN0V2l0aFJlY3QoaW5mbGF0ZWRTb3VyY2VCQm94LCB0YXJnZXRCQm94KSB8fFxuICAgICAgICAgICAgKHNveSA8PSB0eTAgJiYgKGluZmxhdGVkU291cmNlQkJveC5ib3R0b21SaWdodCgpLnggPD0gdG94IHx8IGluZmxhdGVkU291cmNlQkJveC5ib3R0b21MZWZ0KCkueCA+PSB0b3gpKSB8fFxuICAgICAgICAgICAgKHNveSA+PSB0eTAgJiYgKGluZmxhdGVkVGFyZ2V0QkJveC5ib3R0b21SaWdodCgpLnggPD0gc294IHx8IGluZmxhdGVkVGFyZ2V0QkJveC5ib3R0b21MZWZ0KCkueCA+PSBzb3gpKTtcblxuICAgICAgICAvLyBVLXNoYXBlIGNvbm5lY3Rpb24gaXMgYSBzdHJhaWdodCBsaW5lIGlmIGBzb3hgIGFuZCBgdG94YCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKHVzZVVTaGFwZUNvbm5lY3Rpb24gJiYgc294ICE9PSB0b3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IE1hdGgubWluKHNveSwgdG95KSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBNYXRoLm1pbihzb3ksIHRveSkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB4O1xuICAgICAgICBsZXQgeTEgPSBNYXRoLm1pbigoc3kxICsgdHkwKSAvIDIsIHRveSk7XG4gICAgICAgIGxldCB5MiA9IE1hdGgubWluKChzeTAgKyB0eTEpIC8gMiwgc295KTtcblxuICAgICAgICBpZiAodG95IDwgc295KSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHNob3J0ZXN0IHBhdGggYWxvbmcgdGhlIGNvbm5lY3Rpb25zIG9uIGhvcml6b250YWwgc2lkZXNcbiAgICAgICAgICAgIGlmIChyaWdodEQgPiBsZWZ0RCkge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1pbihzb3gsIHRteDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgoc294LCB0bXgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyaWdodEQgPiBsZWZ0RCkge1xuICAgICAgICAgICAgICAgIHggPSBNYXRoLm1pbih0b3gsIHNteDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5tYXgodG94LCBzbXgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogeTIgfSxcbiAgICAgICAgICAgIHsgeCwgeTogeTIgfSxcbiAgICAgICAgICAgIHsgeCwgeTogeTEgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5OiB5MSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAnYm90dG9tJyAmJiB0YXJnZXRTaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBjb25zdCB1c2VVU2hhcGVDb25uZWN0aW9uID1cbiAgICAgICAgICAgIHRhcmdldEluU291cmNlQkJveCB8fFxuICAgICAgICAgICAgZy5pbnRlcnNlY3Rpb24ucmVjdFdpdGhSZWN0KGluZmxhdGVkU291cmNlQkJveCwgdGFyZ2V0QkJveCkgfHxcbiAgICAgICAgICAgIChzb3kgPj0gdG95ICYmIChpbmZsYXRlZFNvdXJjZUJCb3gudG9wUmlnaHQoKS54IDw9IHRveCB8fCBpbmZsYXRlZFNvdXJjZUJCb3gudG9wTGVmdCgpLnggPj0gdG94KSkgfHxcbiAgICAgICAgICAgIChzb3kgPD0gdG95ICYmIChpbmZsYXRlZFRhcmdldEJCb3gudG9wUmlnaHQoKS54IDw9IHNveCB8fCBpbmZsYXRlZFRhcmdldEJCb3gudG9wTGVmdCgpLnggPj0gc294KSk7XG5cbiAgICAgICAgLy8gVS1zaGFwZSBjb25uZWN0aW9uIGlzIGEgc3RyYWlnaHQgbGluZSBpZiBgc294YCBhbmQgYHRveGAgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmICh1c2VVU2hhcGVDb25uZWN0aW9uICYmIHNveCAhPT0gdG94KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBNYXRoLm1heChzb3ksIHRveSkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogTWF0aC5tYXgoc295LCB0b3kpIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHkxID0gTWF0aC5tYXgoKHN5MCArIHR5MSkgLyAyLCB0b3kpO1xuICAgICAgICBsZXQgeTIgPSBNYXRoLm1heCgoc3kxICsgdHkwKSAvIDIsIHNveSk7XG5cbiAgICAgICAgaWYgKHRveSA+IHNveSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBzaG9ydGVzdCBwYXRoIGFsb25nIHRoZSBjb25uZWN0aW9ucyBvbiBob3Jpem9udGFsIHNpZGVzXG4gICAgICAgICAgICBpZiAocmlnaHREID4gbGVmdEQpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4oc294LCB0bXgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHNveCwgdG14MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocmlnaHREID4gbGVmdEQpIHtcbiAgICAgICAgICAgICAgICB4ID0gTWF0aC5taW4odG94LCBzbXgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KHRveCwgc214MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHkyIH0sXG4gICAgICAgICAgICB7IHgsIHk6IHkyIH0sXG4gICAgICAgICAgICB7IHgsIHk6IHkxIH0sXG4gICAgICAgICAgICB7IHg6IHRveCwgeTogeTEgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2xlZnQnICYmIHRhcmdldFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICBjb25zdCB1c2VVU2hhcGVDb25uZWN0aW9uID0gXG4gICAgICAgICAgICB0YXJnZXRJblNvdXJjZUJCb3ggfHxcbiAgICAgICAgICAgIGcuaW50ZXJzZWN0aW9uLnJlY3RXaXRoUmVjdChpbmZsYXRlZFNvdXJjZUJCb3gsIHRhcmdldEJCb3gpIHx8XG4gICAgICAgICAgICAoc294IDw9IHRveCAmJiAoaW5mbGF0ZWRTb3VyY2VCQm94LmJvdHRvbVJpZ2h0KCkueSA8PSB0b3kgfHwgaW5mbGF0ZWRTb3VyY2VCQm94LnRvcFJpZ2h0KCkueSA+PSB0b3kpKSB8fFxuICAgICAgICAgICAgKHNveCA+PSB0b3ggJiYgKGluZmxhdGVkVGFyZ2V0QkJveC5ib3R0b21SaWdodCgpLnkgPD0gc295IHx8IGluZmxhdGVkVGFyZ2V0QkJveC50b3BSaWdodCgpLnkgPj0gc295KSk7XG5cbiAgICAgICAgLy8gVS1zaGFwZSBjb25uZWN0aW9uIGlzIGEgc3RyYWlnaHQgbGluZSBpZiBgc295YCBhbmQgYHRveWAgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmICh1c2VVU2hhcGVDb25uZWN0aW9uICYmIHNveSAhPT0gdG95KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogTWF0aC5taW4oc294LCB0b3gpLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IE1hdGgubWluKHNveCwgdG94KSwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHgxID0gTWF0aC5taW4oKHN4MSArIHR4MCkgLyAyLCB0b3gpO1xuICAgICAgICBsZXQgeDIgPSBNYXRoLm1pbigoc3gwICsgdHgxKSAvIDIsIHNveCk7XG5cbiAgICAgICAgaWYgKHRveCA+IHNveCkge1xuICAgICAgICAgICAgaWYgKHRvcEQgPD0gYm90dG9tRCkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1pbihzbXkwLCB0b3kpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5tYXgoc215MSwgdG95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b3BEIDw9IGJvdHRvbUQpIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4odG15MCwgc295KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHRteTEsIHNveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiB4MiwgeTogc295IH0sXG4gICAgICAgICAgICB7IHg6IHgyLCB5IH0sXG4gICAgICAgICAgICB7IHg6IHgxLCB5IH0sXG4gICAgICAgICAgICB7IHg6IHgxLCB5OiB0b3kgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3JpZ2h0JyAmJiB0YXJnZXRTaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnN0IHVzZVVTaGFwZUNvbm5lY3Rpb24gPVxuICAgICAgICAgICAgdGFyZ2V0SW5Tb3VyY2VCQm94IHx8XG4gICAgICAgICAgICBnLmludGVyc2VjdGlvbi5yZWN0V2l0aFJlY3QoaW5mbGF0ZWRTb3VyY2VCQm94LCB0YXJnZXRCQm94KSB8fFxuICAgICAgICAgICAgKHNveCA+PSB0b3ggJiYgKGluZmxhdGVkU291cmNlQkJveC5ib3R0b21MZWZ0KCkueSA8PSB0b3kgfHwgaW5mbGF0ZWRTb3VyY2VCQm94LnRvcExlZnQoKS55ID49IHRveSkpIHx8XG4gICAgICAgICAgICAoc294IDw9IHRveCAmJiAoaW5mbGF0ZWRUYXJnZXRCQm94LmJvdHRvbUxlZnQoKS55IDw9IHNveSB8fCBpbmZsYXRlZFRhcmdldEJCb3gudG9wTGVmdCgpLnkgPj0gc295KSk7XG5cbiAgICAgICAgLy8gVS1zaGFwZSBjb25uZWN0aW9uIGlzIGEgc3RyYWlnaHQgbGluZSBpZiBgc295YCBhbmQgYHRveWAgYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmICh1c2VVU2hhcGVDb25uZWN0aW9uICYmIHNveSAhPT0gdG95KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogTWF0aC5tYXgoc294LCB0b3gpLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IE1hdGgubWF4KHNveCwgdG94KSwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IHgxID0gTWF0aC5tYXgoKHN4MCArIHR4MSkgLyAyLCB0b3gpO1xuICAgICAgICBsZXQgeDIgPSBNYXRoLm1heCgoc3gxICsgdHgwKSAvIDIsIHNveCk7XG5cbiAgICAgICAgaWYgKHRveCA8PSBzb3gpIHtcbiAgICAgICAgICAgIGlmICh0b3BEIDw9IGJvdHRvbUQpIHtcbiAgICAgICAgICAgICAgICB5ID0gTWF0aC5taW4oc215MCwgdG95KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWF4KHNteTEsIHRveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9wRCA8PSBib3R0b21EKSB7XG4gICAgICAgICAgICAgICAgeSA9IE1hdGgubWluKHRteTAsIHNveSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCh0bXkxLCBzb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogeDIsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiB4MiwgeSB9LFxuICAgICAgICAgICAgeyB4OiB4MSwgeSB9LFxuICAgICAgICAgICAgeyB4OiB4MSwgeTogdG95IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICd0b3AnICYmIHRhcmdldFNpZGUgPT09ICdyaWdodCcpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldFBvaW50KTtcblxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBvaW50IGlzIGluc2lkZSB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPD0gdG14MSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChzb3ggKyBzb3VyY2VNYXJnaW4sIHRveCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHNteTAsIHRteTApO1xuXG4gICAgICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgYHNvdXJjZU1hcmdpbmAgc2luY2UgdGhlIHNvdXJjZSBhbmNob3IgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRhcmdldCBhbmNob3JcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvck1pZGRsZVggPSAoc294IC0gc291cmNlTWFyZ2luICsgdG94KSAvIDI7XG5cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogYW5jaG9yTWlkZGxlWCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBhbmNob3JNaWRkbGVYLCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbXkwID4gdG95KSB7XG4gICAgICAgICAgICBpZiAoc294IDwgdG94KSB7XG4gICAgICAgICAgICAgICAgbGV0IHkgPSB0bXkwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRteTEgPD0gc215MCAmJiB0bXgxID49IHNveCkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4OiB0b3gsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFt7IHg6IHNveCwgeTogdG95IH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KG1pZGRsZU9mVmVydGljYWxTaWRlcywgdG14MSk7XG5cbiAgICAgICAgaWYgKHNveCA+IHRveCAmJiBzeTEgPj0gdG95KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA+IHNteDAgJiYgc295IDwgdHkxKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc215MCwgdG15MCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc214MSwgdG14MSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ3RvcCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc294ID49IHRteDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4oc294IC0gc291cmNlTWFyZ2luLCB0b3gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzbXkwLCB0bXkwKTtcblxuICAgICAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHgsIHk6IHRveSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBgc291cmNlTWFyZ2luYCBzaW5jZSB0aGUgc291cmNlIGFuY2hvciBpcyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVYID0gKHNveCArIHNvdXJjZU1hcmdpbiArIHRveCkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGFuY2hvck1pZGRsZVgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogYW5jaG9yTWlkZGxlWCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc215MCA+IHRveSkge1xuICAgICAgICAgICAgaWYgKHNveCA+IHRveCkge1xuICAgICAgICAgICAgICAgIGxldCB5ID0gdG15MDtcblxuICAgICAgICAgICAgICAgIGlmICh0bXkxIDw9IHNteTAgJiYgdG14MCA8PSBzb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbeyB4OiBzb3gsIHk6IHRveSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbih0bXgwLCBtaWRkbGVPZlZlcnRpY2FsU2lkZXMpO1xuXG4gICAgICAgIGlmIChzb3ggPCB0b3ggJiYgc3kxID49IHRveSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4IDwgc214MSAmJiBzb3kgPCB0eTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzbXkwLCB0bXkwKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzbXgwLCB0bXgwKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAnYm90dG9tJyAmJiB0YXJnZXRTaWRlID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc294IDw9IHRteDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc294ICsgc291cmNlTWFyZ2luLCB0b3gpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcblxuICAgICAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIGBzb3VyY2VNYXJnaW5gIHNpbmNlIHRoZSBzb3VyY2UgYW5jaG9yIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVYID0gKHNveCAtIHNvdXJjZU1hcmdpbiArIHRveCkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGFuY2hvck1pZGRsZVgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeDogYW5jaG9yTWlkZGxlWCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc215MSA8IHRveSkge1xuICAgICAgICAgICAgaWYgKHNveCA8IHRveCkge1xuICAgICAgICAgICAgICAgIGxldCB5ID0gdG15MTtcblxuICAgICAgICAgICAgICAgIGlmICh0bXkwID49IHNteTEgJiYgdG14MSA+PSBzb3gpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IG1pZGRsZU9mSG9yaXpvbnRhbFNpZGVzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbeyB4OiBzb3gsIHk6IHRveSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChtaWRkbGVPZlZlcnRpY2FsU2lkZXMsIHRteDEpO1xuXG4gICAgICAgIGlmIChzb3ggPiB0b3ggJiYgc3kwIDw9IHRveSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPiBzbXgwICYmIHNveSA+IHR5MCkge1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHNteTEsIHRteTEpO1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHNteDEsIHRteDEpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogdG95IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdib3R0b20nICYmIHRhcmdldFNpZGUgPT09ICdsZWZ0Jykge1xuICAgICAgICBjb25zdCBpc1BvaW50SW5zaWRlU291cmNlID0gaW5mbGF0ZWRTb3VyY2VCQm94LmNvbnRhaW5zUG9pbnQodGFyZ2V0UG9pbnQpO1xuXG4gICAgICAgIC8vIFRoZSB0YXJnZXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICBpZiAoaXNQb2ludEluc2lkZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNveCA+PSB0bXgwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHNveCAtIHNvdXJjZU1hcmdpbiwgdG94KTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc215MSwgdG15MSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNvdXJjZSBhbmNob3JcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYHNvdXJjZU1hcmdpbmAgc2luY2UgdGhlIHNvdXJjZSBhbmNob3IgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdGFyZ2V0IGFuY2hvclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yTWlkZGxlWCA9IChzb3ggKyBzb3VyY2VNYXJnaW4gKyB0b3gpIC8gMjtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBhbmNob3JNaWRkbGVYLCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IGFuY2hvck1pZGRsZVgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNteTEgPCB0b3kpIHtcbiAgICAgICAgICAgIGlmIChzb3ggPiB0b3gpIHtcbiAgICAgICAgICAgICAgICBsZXQgeSA9IHRteTE7XG5cbiAgICAgICAgICAgICAgICBpZiAodG15MCA+PSBzbXkxICYmIHRteDAgPD0gc294KSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBtaWRkbGVPZkhvcml6b250YWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogc294LCB5OiB0b3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4ID0gTWF0aC5taW4odG14MCwgbWlkZGxlT2ZWZXJ0aWNhbFNpZGVzKTtcblxuICAgICAgICBpZiAoc294IDwgdG94ICYmIHN5MCA8PSB0b3kpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5OiB0b3kgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4IDwgc214MSAmJiBzb3kgPiB0eTApIHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChzbXkxLCB0bXkxKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzbXgwLCB0bXgwKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHgsIHk6IHRveSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAnbGVmdCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldFBvaW50KTtcblxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBvaW50IGlzIGluc2lkZSB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPD0gdG15MSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzbXgwLCB0bXgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc295ICsgc291cmNlTWFyZ2luLCB0b3kpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIGFib3ZlIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVZID0gKHNveSAtIHNvdXJjZU1hcmdpbiArIHRveSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogYW5jaG9yTWlkZGxlWSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBhbmNob3JNaWRkbGVZIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc214MCA+IHRveCkge1xuICAgICAgICAgICAgaWYgKHNveSA8IHRveSkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gdG14MDtcblxuICAgICAgICAgICAgICAgIGlmICh0bXgxIDw9IHNteDAgJiYgdG15MSA+PSBzb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogdG94LCB5OiBzb3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgodG15MSwgbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXMpO1xuXG4gICAgICAgIGlmIChzb3kgPiB0b3kgJiYgc3gxID49IHRveCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBzbXkwICYmIHNveCA8IHR4MSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKHNteDAsIHRteDApO1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHNteTEsIHRteTEpO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoc291cmNlU2lkZSA9PT0gJ2xlZnQnICYmIHRhcmdldFNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc295ID49IHRteTApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4oc295IC0gc291cmNlTWFyZ2luLCB0b3kpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzbXgwLCB0bXgwKTtcblxuICAgICAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIHRvcCBzaWRlIG9mIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIGJlbG93IHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGBzb3VyY2VNYXJnaW5gIHNpbmNlIHRoZSBzb3VyY2UgYW5jaG9yIGlzIGFib3ZlIHRoZSB0YXJnZXQgYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVZID0gKHNveSArIHNvdXJjZU1hcmdpbiArIHRveSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogYW5jaG9yTWlkZGxlWSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBhbmNob3JNaWRkbGVZIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc214MCA+IHRveCkge1xuICAgICAgICAgICAgaWYgKHNveSA+IHRveSkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gdG14MDtcblxuICAgICAgICAgICAgICAgIGlmICh0bXgxIDw9IHNteDAgJiYgdG15MCA8PSBzb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogdG94LCB5OiBzb3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4odG15MCwgbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXMpO1xuXG4gICAgICAgIGlmIChzb3kgPCB0b3kgJiYgc3gxID49IHRveCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgc215MSAmJiBzb3ggPCB0eDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihzbXgwLCB0bXgwKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzbXkwLCB0bXkwKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHgsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgIHsgeDogc294LCB5IH0sXG4gICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChzb3VyY2VTaWRlID09PSAncmlnaHQnICYmIHRhcmdldFNpZGUgPT09ICd0b3AnKSB7XG4gICAgICAgIGNvbnN0IGlzUG9pbnRJbnNpZGVTb3VyY2UgPSBpbmZsYXRlZFNvdXJjZUJCb3guY29udGFpbnNQb2ludCh0YXJnZXRQb2ludCk7XG5cbiAgICAgICAgLy8gVGhlIHRhcmdldCBwb2ludCBpcyBpbnNpZGUgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIGlmIChpc1BvaW50SW5zaWRlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc295ID49IHRteTApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5tYXgoc214MSwgdG14MSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWluKHNveSAtIHNvdXJjZU1hcmdpbiwgdG95KTtcblxuICAgICAgICAgICAgICAgIC8vIFRhcmdldCBhbmNob3IgaXMgb24gdGhlIHRvcCBzaWRlIG9mIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0sIC8vIFBhdGggYWRqdXN0bWVudCBmb3IgcmlnaHQgc2lkZSBzdGFydFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGFyZ2V0IGFuY2hvciBpcyBiZWxvdyB0aGUgc291cmNlIGFuY2hvclxuICAgICAgICAgICAgLy8gQWRqdXN0IHNvdXJjZU1hcmdpbiBjYWxjdWxhdGlvbiBzaW5jZSB0aGUgc291cmNlIGFuY2hvciBpcyBub3cgb24gdGhlIHJpZ2h0XG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVZID0gKHNveSArIHNvdXJjZU1hcmdpbiArIHRveSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogYW5jaG9yTWlkZGxlWSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBhbmNob3JNaWRkbGVZIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc214MSA8IHRveCkge1xuICAgICAgICAgICAgaWYgKHNveSA+IHRveSkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gdG14MTtcblxuICAgICAgICAgICAgICAgIGlmICh0bXgwID49IHNteDEgJiYgdG15MCA8PSBzb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogdG94LCB5OiBzb3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB5ID0gTWF0aC5taW4odG15MCwgbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXMpO1xuXG4gICAgICAgIGlmIChzb3kgPCB0b3kgJiYgc3gwIDw9IHRveCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgc215MSAmJiBzb3ggPiB0eDApIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChzbXgxLCB0bXgxKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1pbihzbXkwLCB0bXkwKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgIHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB4OiBzb3gsIHk6IHNveSB9LFxuICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgXTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVNpZGUgPT09ICdyaWdodCcgJiYgdGFyZ2V0U2lkZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgY29uc3QgaXNQb2ludEluc2lkZVNvdXJjZSA9IGluZmxhdGVkU291cmNlQkJveC5jb250YWluc1BvaW50KHRhcmdldFBvaW50KTtcblxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHBvaW50IGlzIGluc2lkZSB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgaWYgKGlzUG9pbnRJbnNpZGVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3kgPD0gdG15MSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLm1heChzbXgxLCB0bXgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgoc295ICsgc291cmNlTWFyZ2luLCB0b3kpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgICAgIHsgeDogdG94LCB5IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUYXJnZXQgYW5jaG9yIGlzIGFib3ZlIHRoZSBzb3VyY2UgYW5jaG9yXG4gICAgICAgICAgICBjb25zdCBhbmNob3JNaWRkbGVZID0gKHNveSAtIHNvdXJjZU1hcmdpbiArIHRveSkgLyAyO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeDogc294LCB5OiBzb3kgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogYW5jaG9yTWlkZGxlWSB9LFxuICAgICAgICAgICAgICAgIHsgeDogdG94LCB5OiBhbmNob3JNaWRkbGVZIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc214MSA8IHRveCkge1xuICAgICAgICAgICAgaWYgKHNveSA8IHRveSkge1xuICAgICAgICAgICAgICAgIGxldCB4ID0gdG14MTtcblxuICAgICAgICAgICAgICAgIGlmICh0bXgwID49IHNteDEgJiYgdG15MSA+PSBzb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IG1pZGRsZU9mVmVydGljYWxTaWRlcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHNveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHgsIHk6IHRveSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHg6IHRveCwgeTogdG95IH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW3sgeDogdG94LCB5OiBzb3kgfV07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB5ID0gTWF0aC5tYXgodG15MSwgbWlkZGxlT2ZIb3Jpem9udGFsU2lkZXMpO1xuXG4gICAgICAgIGlmIChzb3kgPiB0b3kgJiYgc3gwIDw9IHRveCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4OiBzb3gsIHkgfSxcbiAgICAgICAgICAgICAgICB7IHg6IHRveCwgeSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBzbXkwICYmIHNveCA+IHR4MCkge1xuICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWF4KHNteDEsIHRteDEpO1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgubWF4KHNteTEsIHRteTEpO1xuXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgeCwgeTogc295IH0sXG4gICAgICAgICAgICAgICAgeyB4LCB5IH0sXG4gICAgICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHg6IHNveCwgeTogc295IH0sXG4gICAgICAgICAgICB7IHg6IHNveCwgeSB9LFxuICAgICAgICAgICAgeyB4OiB0b3gsIHkgfVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0TG9vcENvb3JkaW5hdGVzKGRpcmVjdGlvbiwgYW5nbGUsIG1hcmdpbikge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5MRUZUIHx8IGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5SSUdIVDtcblxuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcblxuICAgIHN3aXRjaCAoZy5ub3JtYWxpemVBbmdsZShNYXRoLnJvdW5kKGFuZ2xlKSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgZHggPSBpc0hvcml6b250YWwgPyAwIDogbWFyZ2luO1xuICAgICAgICAgICAgZHkgPSBpc0hvcml6b250YWwgPyBtYXJnaW4gOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICAgIGR4ID0gaXNIb3Jpem9udGFsID8gMCA6IC1tYXJnaW47XG4gICAgICAgICAgICBkeSA9IGlzSG9yaXpvbnRhbCA/IC1tYXJnaW4gOiAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZHgsIGR5IH07XG59XG5cbmZ1bmN0aW9uIHJpZ2h0QW5nbGVSb3V0ZXIodmVydGljZXMsIG9wdCwgbGlua1ZpZXcpIHtcbiAgICBjb25zdCB7IHNvdXJjZURpcmVjdGlvbiA9IERpcmVjdGlvbnMuQVVUTywgdGFyZ2V0RGlyZWN0aW9uID0gRGlyZWN0aW9ucy5BVVRPIH0gPSBvcHQ7XG4gICAgY29uc3QgbWFyZ2luID0gb3B0Lm1hcmdpbiB8fCAyMDtcbiAgICBjb25zdCB1c2VWZXJ0aWNlcyA9IG9wdC51c2VWZXJ0aWNlcyB8fCBmYWxzZTtcblxuICAgIGNvbnN0IGlzU291cmNlUG9ydCA9ICEhbGlua1ZpZXcubW9kZWwuc291cmNlKCkucG9ydDtcbiAgICBjb25zdCBzb3VyY2VQb2ludCA9IHBvaW50RGF0YUZyb21BbmNob3IobGlua1ZpZXcuc291cmNlVmlldywgbGlua1ZpZXcuc291cmNlQW5jaG9yLCBsaW5rVmlldy5zb3VyY2VCQm94LCBzb3VyY2VEaXJlY3Rpb24sIGlzU291cmNlUG9ydCwgbGlua1ZpZXcuc291cmNlQW5jaG9yLCBtYXJnaW4pO1xuXG4gICAgY29uc3QgaXNUYXJnZXRQb3J0ID0gISFsaW5rVmlldy5tb2RlbC50YXJnZXQoKS5wb3J0O1xuICAgIGNvbnN0IHRhcmdldFBvaW50ID0gcG9pbnREYXRhRnJvbUFuY2hvcihsaW5rVmlldy50YXJnZXRWaWV3LCBsaW5rVmlldy50YXJnZXRBbmNob3IsIGxpbmtWaWV3LnRhcmdldEJCb3gsIHRhcmdldERpcmVjdGlvbiwgaXNUYXJnZXRQb3J0LCBsaW5rVmlldy50YXJnZXRBbmNob3IsIG1hcmdpbik7XG5cbiAgICBsZXQgcmVzdWx0VmVydGljZXMgPSBbXTtcblxuICAgIGlmICghdXNlVmVydGljZXMgfHwgdmVydGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzaW1wbGlmeVBvaW50cyhyb3V0ZUJldHdlZW5Qb2ludHMoc291cmNlUG9pbnQsIHRhcmdldFBvaW50KSk7XG4gICAgfVxuXG4gICAgY29uc3QgdmVydGljZXNEYXRhID0gdmVydGljZXMubWFwKCh2KSA9PiBwb2ludERhdGFGcm9tVmVydGV4KHYpKTtcbiAgICBjb25zdCBbZmlyc3RWZXJ0ZXhdID0gdmVydGljZXNEYXRhO1xuXG4gICAgY29uc3QgW3Jlc29sdmVkU291cmNlRGlyZWN0aW9uXSA9IHJlc29sdmVTaWRlcyhzb3VyY2VQb2ludCwgZmlyc3RWZXJ0ZXgpO1xuICAgIGNvbnN0IGlzRWxlbWVudCA9IHNvdXJjZVBvaW50LnZpZXcgJiYgc291cmNlUG9pbnQudmlldy5tb2RlbC5pc0VsZW1lbnQoKTtcbiAgICBjb25zdCBzb3VyY2VCQm94ID0gaXNFbGVtZW50ID8gbW92ZUFuZEV4cGFuZEJCb3goc291cmNlUG9pbnQudmlldy5tb2RlbC5nZXRCQm94KCksIHJlc29sdmVkU291cmNlRGlyZWN0aW9uLCBtYXJnaW4pIDogbnVsbDtcbiAgICBjb25zdCBpc1ZlcnRleEluc2lkZSA9IGlzRWxlbWVudCA/IHNvdXJjZUJCb3guY29udGFpbnNQb2ludChmaXJzdFZlcnRleC5wb2ludCkgOiBmYWxzZTtcblxuICAgIGlmIChpc1ZlcnRleEluc2lkZSkge1xuICAgICAgICBjb25zdCBvdXRzaWRlUG9pbnQgPSBnZXRPdXRzaWRlUG9pbnQocmVzb2x2ZWRTb3VyY2VEaXJlY3Rpb24sIHNvdXJjZVBvaW50LCBtYXJnaW4pO1xuICAgICAgICBjb25zdCBmaXJzdFBvaW50T3ZlcmxhcCA9IG91dHNpZGVQb2ludC5lcXVhbHMoZmlyc3RWZXJ0ZXgucG9pbnQpO1xuXG4gICAgICAgIGNvbnN0IGFsaWduc1ZlcnRpY2FsbHkgPSBzb3VyY2VQb2ludC5wb2ludC54ID09PSBmaXJzdFZlcnRleC5wb2ludC54O1xuICAgICAgICBjb25zdCBhbGlnbnNIb3Jpem9udGFsbHkgPSBzb3VyY2VQb2ludC5wb2ludC55ID09PSBmaXJzdFZlcnRleC5wb2ludC55O1xuXG4gICAgICAgIGNvbnN0IGlzVmVydGljYWxBbmRBbGlnbnMgPSBhbGlnbnNWZXJ0aWNhbGx5ICYmIChyZXNvbHZlZFNvdXJjZURpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5UT1AgfHwgcmVzb2x2ZWRTb3VyY2VEaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuQk9UVE9NKTtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsQW5kQWxpZ25zID0gYWxpZ25zSG9yaXpvbnRhbGx5ICYmIChyZXNvbHZlZFNvdXJjZURpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5MRUZUIHx8IHJlc29sdmVkU291cmNlRGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlJJR0hUKTtcblxuICAgICAgICBjb25zdCBmaXJzdFNlZ21lbnQgPSBuZXcgZy5MaW5lKHNvdXJjZVBvaW50LnBvaW50LCBvdXRzaWRlUG9pbnQpO1xuICAgICAgICBjb25zdCBpc1ZlcnRleE9uU2VnbWVudCA9IGZpcnN0U2VnbWVudC5jb250YWluc1BvaW50KGZpcnN0VmVydGV4LnBvaW50KTtcblxuICAgICAgICBjb25zdCBpc1ZlcnRleEFsaWduZWRBbmRJbnNpZGUgPSBpc1ZlcnRleEluc2lkZSAmJiAoaXNIb3Jpem9udGFsQW5kQWxpZ25zIHx8IGlzVmVydGljYWxBbmRBbGlnbnMpO1xuXG4gICAgICAgIFxuXG4gICAgICAgIGlmIChmaXJzdFBvaW50T3ZlcmxhcCkge1xuICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaChzb3VyY2VQb2ludC5wb2ludCwgZmlyc3RWZXJ0ZXgucG9pbnQpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBhY2Nlc3MgZGlyZWN0aW9uIGFzIHRoZSBvcHBvc2l0ZSBvZiB0aGUgc291cmNlIGRpcmVjdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25uZWN0IHRoZSByb3V0ZSB3aXRoIHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgZmlyc3RWZXJ0ZXguZGlyZWN0aW9uID0gT1BQT1NJVEVfRElSRUNUSU9OU1tyZXNvbHZlZFNvdXJjZURpcmVjdGlvbl07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWZXJ0ZXhPblNlZ21lbnQgfHwgaXNWZXJ0ZXhBbGlnbmVkQW5kSW5zaWRlKSB7XG4gICAgICAgICAgICAvLyBDYXNlIHdoZXJlIHRoZXJlIGlzIGEgbmVlZCB0byBjcmVhdGUgYSBsb29wXG4gICAgICAgICAgICBjb25zdCBhbmdsZSA9IGdldFNlZ21lbnRBbmdsZShpc1ZlcnRleE9uU2VnbWVudCA/IGZpcnN0U2VnbWVudCA6IG5ldyBnLkxpbmUoc291cmNlUG9pbnQucG9pbnQsIGZpcnN0VmVydGV4LnBvaW50KSk7XG4gICAgICAgICAgICBjb25zdCB7IGR4LCBkeSB9ID0gZ2V0TG9vcENvb3JkaW5hdGVzKHJlc29sdmVkU291cmNlRGlyZWN0aW9uLCBhbmdsZSwgbWFyZ2luKTtcblxuICAgICAgICAgICAgY29uc3QgbG9vcCA9IGNyZWF0ZUxvb3AoeyBwb2ludDogb3V0c2lkZVBvaW50IH0sIGZpcnN0VmVydGV4LCB7IGR4LCBkeSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZENyZWF0ZWRQb2ludCA9IGxvb3BbMl07XG4gICAgICAgICAgICBjb25zdCBsb29wRW5kU2VnbWVudCA9IG5ldyBnLkxpbmUoZmlyc3RWZXJ0ZXgucG9pbnQsIHNlY29uZENyZWF0ZWRQb2ludCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0RpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbZ2V0U2VnbWVudEFuZ2xlKGxvb3BFbmRTZWdtZW50KV07XG4gICAgICAgICAgICBmaXJzdFZlcnRleC5kaXJlY3Rpb24gPSBhY2Nlc3NEaXJlY3Rpb247XG4gICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLmxvb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjcmVhdGUgYSByb3V0ZSwgdXNlIHRoZSBgcm91dGVCZXR3ZWVuUG9pbnRzYCB0byBjb25zdHJ1Y3QgYSByb3V0ZVxuICAgICAgICAgICAgZmlyc3RWZXJ0ZXguZGlyZWN0aW9uID0gcmVzb2x2ZWRTb3VyY2VEaXJlY3Rpb247XG4gICAgICAgICAgICBmaXJzdFZlcnRleC5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhzb3VyY2VQb2ludCwgZmlyc3RWZXJ0ZXgsIHsgdGFyZ2V0SW5Tb3VyY2VCQm94OiB0cnVlIH0pLCBmaXJzdFZlcnRleC5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcG9pbnQgcmVzcG9uc2libGUgZm9yIHRoZSBpbml0aWFsIGRpcmVjdGlvbiBvZiB0aGUgcm91dGVcbiAgICAgICAgY29uc3QgbmV4dCA9IHZlcnRpY2VzRGF0YVsxXSB8fCB0YXJnZXRQb2ludDtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmVzb2x2ZUluaXRpYWxEaXJlY3Rpb24oc291cmNlUG9pbnQsIGZpcnN0VmVydGV4LCBuZXh0KTtcbiAgICAgICAgZmlyc3RWZXJ0ZXguZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG4gICAgICAgIHJlc3VsdFZlcnRpY2VzLnB1c2goLi4ucm91dGVCZXR3ZWVuUG9pbnRzKHNvdXJjZVBvaW50LCBmaXJzdFZlcnRleCksIGZpcnN0VmVydGV4LnBvaW50KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzRGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHZlcnRpY2VzRGF0YVtpXTtcbiAgICAgICAgY29uc3QgdG8gPSB2ZXJ0aWNlc0RhdGFbaSArIDFdO1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TZWdtZW50ID0gbmV3IGcuTGluZShmcm9tLnBvaW50LCB0by5wb2ludCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TZWdtZW50QW5nbGUgPSBnZXRTZWdtZW50QW5nbGUoY29ubmVjdGlvblNlZ21lbnQpO1xuICAgICAgICBpZiAoY29ubmVjdGlvblNlZ21lbnRBbmdsZSAlIDkwID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTZWdtZW50IGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25EaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW2Nvbm5lY3Rpb25TZWdtZW50QW5nbGVdO1xuXG4gICAgICAgICAgICBjb25zdCBzaW1wbGlmaWVkUm91dGUgPSBzaW1wbGlmeVBvaW50cyhbLi4ucmVzdWx0VmVydGljZXMsIGZyb20ucG9pbnRdKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHNpbXBsaWZpZWRSb3V0ZTIgPSBzaW1wbGlmeVBvaW50cyhbZnJvbS5wb2ludCwgLi4ucmVzdWx0VmVydGljZXNdKTtcbiAgICAgICAgICAgIC8vIEZpbmQgb3V0IHRoZSBkaXJlY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGNvbm5lY3QgdGhlIGN1cnJlbnQgcm91dGUgd2l0aCB0aGUgbmV4dCB2ZXJ0ZXhcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1NlZ21lbnQgPSBuZXcgZy5MaW5lKHNpbXBsaWZpZWRSb3V0ZVtzaW1wbGlmaWVkUm91dGUubGVuZ3RoIC0gMl0sIHNpbXBsaWZpZWRSb3V0ZVtzaW1wbGlmaWVkUm91dGUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgLy8gY29uc3QgYWNjZXNzU2VnbWVudDIgPSBuZXcgZy5MaW5lKHNpbXBsaWZpZWRSb3V0ZTJbc2ltcGxpZmllZFJvdXRlMi5sZW5ndGggLSAyXSwgc2ltcGxpZmllZFJvdXRlMltzaW1wbGlmaWVkUm91dGUyLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0RpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbTWF0aC5yb3VuZChnZXRTZWdtZW50QW5nbGUoYWNjZXNzU2VnbWVudCkpXTtcbiAgICAgICAgICAgIC8vIGNvbnN0IGFjY2Vzc0RpcmVjdGlvbjIgPSBBTkdMRV9ESVJFQ1RJT05fTUFQW01hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKGFjY2Vzc1NlZ21lbnQyKSldO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYWNjZXNzRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGFjY2Vzc0RpcmVjdGlvbjIpO1xuICAgICAgICAgICAgLy8gaWYgKGFjY2Vzc0RpcmVjdGlvbiAhPT0gYWNjZXNzRGlyZWN0aW9uMikge1xuICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdlcnJvcicpO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLScpO1xuXG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbkRpcmVjdGlvbiAhPT0gT1BQT1NJVEVfRElSRUNUSU9OU1thY2Nlc3NEaXJlY3Rpb25dKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRpcmVjdGlvbnMgYXJlIG5vdCBvcHBvc2l0ZSwgc28gd2UgY2FuIGNvbm5lY3QgdGhlIHZlcnRpY2VzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaChmcm9tLnBvaW50LCB0by5wb2ludCk7XG4gICAgICAgICAgICAgICAgY29uc3QgWywgdG9EaXJlY3Rpb25dID0gcmVzb2x2ZVNpZGVzKGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB0by5kaXJlY3Rpb24gPSB0b0RpcmVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRpcmVjdGlvbnMgYXJlIG92ZXJsYXBwaW5nLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGxvb3BcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxvb3BSb3V0ZSwgY29udGludWVEaXJlY3Rpb24gfSA9IGxvb3BTZWdtZW50KGZyb20sIHRvLCBjb25uZWN0aW9uU2VnbWVudEFuZ2xlLCBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIHRvLmRpcmVjdGlvbiA9IGNvbnRpbnVlRGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdGluZyBhIGxvb3BcbiAgICAgICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLmxvb3BSb3V0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmVydGljZXMgYXJlIG5vdCBhbGlnbmVkIHZlcnRpY2FsbHkgbm9yIGhvcml6b250YWxseVxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJvdXRlIGJldHdlZW4gdGhlbVxuXG4gICAgICAgIGNvbnN0IFtmcm9tRGlyZWN0aW9uLCB0b0RpcmVjdGlvbl0gPSByZXNvbHZlRGlyZWN0aW9uKGZyb20sIHRvKTtcblxuICAgICAgICBmcm9tLmRpcmVjdGlvbiA9IGZyb21EaXJlY3Rpb247XG4gICAgICAgIHRvLmRpcmVjdGlvbiA9IHRvRGlyZWN0aW9uO1xuXG4gICAgICAgIHJlc3VsdFZlcnRpY2VzLnB1c2goLi4ucm91dGVCZXR3ZWVuUG9pbnRzKGZyb20sIHRvKSwgdG8ucG9pbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RWZXJ0ZXggPSB2ZXJ0aWNlc0RhdGFbdmVydGljZXNEYXRhLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHRhcmdldFBvaW50LnZpZXcgJiYgdGFyZ2V0UG9pbnQudmlldy5tb2RlbC5pc0VsZW1lbnQoKSkge1xuICAgICAgICBjb25zdCBbLCByZXNvbHZlZFRhcmdldERpcmVjdGlvbl0gPSByZXNvbHZlU2lkZXMobGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICBjb25zdCBvdXRzaWRlUG9pbnQgPSBnZXRPdXRzaWRlUG9pbnQocmVzb2x2ZWRUYXJnZXREaXJlY3Rpb24sIHRhcmdldFBvaW50LCBtYXJnaW4pO1xuXG4gICAgICAgIC8vIHRoZSBsYXN0IHBvaW50IG9mIGBzaW1wbGlmaWVkYCBhcnJheSBpcyB0aGUgbGFzdCBkZWZpbmVkIHZlcnRleFxuICAgICAgICAvLyB0aGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGxhc3Qgc2VnbWVudCBjb250aW51ZXMgaW4gYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIGNvbnN0IHNpbXBsaWZpZWQgPSBzaW1wbGlmeVBvaW50cyhbLi4ucmVzdWx0VmVydGljZXMsIGxhc3RWZXJ0ZXgucG9pbnRdKTtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZFNlZ21lbnQgPSBuZXcgZy5MaW5lKHNpbXBsaWZpZWRbc2ltcGxpZmllZC5sZW5ndGggLSAyXSwgc2ltcGxpZmllZFtzaW1wbGlmaWVkLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZFNlZ21lbnRBbmdsZSA9IE1hdGgucm91bmQoZ2V0U2VnbWVudEFuZ2xlKHNpbXBsaWZpZWRTZWdtZW50KSk7XG4gICAgICAgIGNvbnN0IGRlZmluZWREaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW3NpbXBsaWZpZWRTZWdtZW50QW5nbGVdO1xuXG4gICAgICAgIGNvbnN0IGxhc3RQb2ludE92ZXJsYXAgPSBvdXRzaWRlUG9pbnQuZXF1YWxzKGxhc3RWZXJ0ZXgucG9pbnQpO1xuXG4gICAgICAgIGlmICghbGFzdFBvaW50T3ZlcmxhcCB8fCAobGFzdFBvaW50T3ZlcmxhcCAmJiBkZWZpbmVkRGlyZWN0aW9uID09PSByZXNvbHZlZFRhcmdldERpcmVjdGlvbikpIHtcblxuICAgICAgICAgICAgbGFzdFZlcnRleC5kaXJlY3Rpb24gPSBkZWZpbmVkRGlyZWN0aW9uO1xuXG4gICAgICAgICAgICBsZXQgbGFzdFNlZ21lbnRSb3V0ZSA9IHJvdXRlQmV0d2VlblBvaW50cyhsYXN0VmVydGV4LCB0YXJnZXRQb2ludCk7XG4gICAgICAgICAgICBjb25zdCBbcDEsIHAyXSA9IHNpbXBsaWZ5UG9pbnRzKFsuLi5sYXN0U2VnbWVudFJvdXRlLCB0YXJnZXRQb2ludC5wb2ludF0pO1xuXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VnbWVudCA9IG5ldyBnLkxpbmUocDEsIHAyKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdW5kZWRMYXN0U2VnbWVudEFuZ2xlID0gTWF0aC5yb3VuZChnZXRTZWdtZW50QW5nbGUobGFzdFNlZ21lbnQpKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWdtZW50RGlyZWN0aW9uID0gQU5HTEVfRElSRUNUSU9OX01BUFtyb3VuZGVkTGFzdFNlZ21lbnRBbmdsZV07XG5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEJCb3ggPSBtb3ZlQW5kRXhwYW5kQkJveCh0YXJnZXRQb2ludC52aWV3Lm1vZGVsLmdldEJCb3goKSwgcmVzb2x2ZWRUYXJnZXREaXJlY3Rpb24sIG1hcmdpbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGFsaWduc1ZlcnRpY2FsbHkgPSBsYXN0VmVydGV4LnBvaW50LnggPT09IHRhcmdldFBvaW50LnBvaW50Lng7XG4gICAgICAgICAgICBjb25zdCBhbGlnbnNIb3Jpem9udGFsbHkgPSBsYXN0VmVydGV4LnBvaW50LnkgPT09IHRhcmdldFBvaW50LnBvaW50Lnk7XG4gICAgICAgICAgICBjb25zdCBpc1ZlcnRleEluc2lkZSA9IHRhcmdldEJCb3guY29udGFpbnNQb2ludChsYXN0VmVydGV4LnBvaW50KTtcblxuICAgICAgICAgICAgY29uc3QgaXNWZXJ0aWNhbEFuZEFsaWducyA9IGFsaWduc1ZlcnRpY2FsbHkgJiYgKHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlRPUCB8fCByZXNvbHZlZFRhcmdldERpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5CT1RUT00pO1xuICAgICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsQW5kQWxpZ25zID0gYWxpZ25zSG9yaXpvbnRhbGx5ICYmIChyZXNvbHZlZFRhcmdldERpcmVjdGlvbiA9PT0gRGlyZWN0aW9ucy5MRUZUIHx8IHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLlJJR0hUKTtcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWxhc3RQb2ludE92ZXJsYXAgJiYgaXNWZXJ0ZXhJbnNpZGUgJiYgKGlzSG9yaXpvbnRhbEFuZEFsaWducyB8fCBpc1ZlcnRpY2FsQW5kQWxpZ25zKSkge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2VzIHdoZW4gdGhlIGxhc3QgdmVydGV4IGlzIGluc2lkZSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBhbmQgaW4gaXMgYWxpZ25lZCB3aXRoIHRoZSBjb25uZWN0aW9uIHBvaW50ID0+IGNvbnN0cnVjdCBhIGxvb3BcbiAgICAgICAgICAgICAgICBjb25zdCB7IGR4LCBkeSB9ID0gZ2V0TG9vcENvb3JkaW5hdGVzKHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uLCBzaW1wbGlmaWVkU2VnbWVudEFuZ2xlLCBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50Um91dGUgPSBjcmVhdGVMb29wKGxhc3RWZXJ0ZXgsIHsgcG9pbnQ6IG91dHNpZGVQb2ludCB9LCB7IGR4LCBkeSB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNWZXJ0ZXhJbnNpZGUgJiYgcmVzb2x2ZWRUYXJnZXREaXJlY3Rpb24gIT09IE9QUE9TSVRFX0RJUkVDVElPTlNbZGVmaW5lZERpcmVjdGlvbl0pIHtcbiAgICAgICAgICAgICAgICBsYXN0VmVydGV4Lm1hcmdpbiA9IG1hcmdpbjtcbiAgICAgICAgICAgICAgICBsYXN0VmVydGV4LmRpcmVjdGlvbiA9IHJlc29sdmVkVGFyZ2V0RGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50Um91dGUgPSByb3V0ZUJldHdlZW5Qb2ludHMobGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0U2VnbWVudERpcmVjdGlvbiAhPT0gZGVmaW5lZERpcmVjdGlvbiAmJiBkZWZpbmVkRGlyZWN0aW9uID09PSBPUFBPU0lURV9ESVJFQ1RJT05TW2xhc3RTZWdtZW50RGlyZWN0aW9uXSkge1xuICAgICAgICAgICAgICAgIGxhc3RWZXJ0ZXgubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50Um91dGUgPSByb3V0ZUJldHdlZW5Qb2ludHMobGFzdFZlcnRleCwgdGFyZ2V0UG9pbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLmxhc3RTZWdtZW50Um91dGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2luY2UgdGhlIHRhcmdldCBpcyBvbmx5IGEgcG9pbnQgd2UgY2FuIGFwcGx5IHRoZSBzYW1lIGxvZ2ljIGFzIGlmIHdlIGNvbm5lY3RlZCB0d28gdmVydGljZXNEYXRhXG4gICAgICAgIGNvbnN0IGZyb20gPSBsYXN0VmVydGV4O1xuICAgICAgICBjb25zdCB0byA9IHRhcmdldFBvaW50O1xuXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TZWdtZW50ID0gbmV3IGcuTGluZShmcm9tLnBvaW50LCB0by5wb2ludCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25TZWdtZW50QW5nbGUgPSBnZXRTZWdtZW50QW5nbGUoY29ubmVjdGlvblNlZ21lbnQpO1xuICAgICAgICBpZiAoY29ubmVjdGlvblNlZ21lbnRBbmdsZSAlIDkwID09PSAwKSB7XG4gICAgICAgICAgICAvLyBTZWdtZW50IGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25EaXJlY3Rpb24gPSBBTkdMRV9ESVJFQ1RJT05fTUFQW2Nvbm5lY3Rpb25TZWdtZW50QW5nbGVdO1xuXG4gICAgICAgICAgICBjb25zdCBzaW1wbGlmaWVkUm91dGUgPSBzaW1wbGlmeVBvaW50cyhyZXN1bHRWZXJ0aWNlcyk7XG4gICAgICAgICAgICAvLyBGaW5kIG91dCB0aGUgZGlyZWN0aW9uIHRoYXQgaXMgdXNlZCB0byBjb25uZWN0IHRoZSBjdXJyZW50IHJvdXRlIHdpdGggdGhlIG5leHQgdmVydGV4XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NTZWdtZW50ID0gbmV3IGcuTGluZShzaW1wbGlmaWVkUm91dGVbc2ltcGxpZmllZFJvdXRlLmxlbmd0aCAtIDJdLCBmcm9tLnBvaW50KTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0RpcmVjdGlvbiA9IEFOR0xFX0RJUkVDVElPTl9NQVBbTWF0aC5yb3VuZChnZXRTZWdtZW50QW5nbGUoYWNjZXNzU2VnbWVudCkpXTtcblxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25EaXJlY3Rpb24gIT09IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkaXJlY3Rpb25zIGFyZSBub3Qgb3Bwb3NpdGUsIHNvIHdlIGNhbiBjb25uZWN0IHRoZSB2ZXJ0aWNlcyBkaXJlY3RseSBieSBhZGRpbmcgdGhlIGZpcnN0IHBvaW50XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBwb2ludCBpcyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAgICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKGZyb20ucG9pbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGlyZWN0aW9ucyBhcmUgb3ZlcmxhcHBpbmcsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGEgbG9vcFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbG9vcFJvdXRlIH0gPSBsb29wU2VnbWVudChmcm9tLCB0bywgY29ubmVjdGlvblNlZ21lbnRBbmdsZSwgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgcG9pbnQgc2luY2UgaXQgaXMgdGhlIHRhcmdldCB0aGF0IGlzIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIGxvb3BSb3V0ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3RpbmcgYSBsb29wXG4gICAgICAgICAgICAgICAgcmVzdWx0VmVydGljZXMucHVzaCguLi5sb29wUm91dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgdmVydGV4IGFuZCB0aGUgdGFyZ2V0IGFyZSBub3QgYWxpZ25lZCB2ZXJ0aWNhbGx5IG5vciBob3Jpem9udGFsbHlcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcm91dGUgYmV0d2VlbiB0aGVtXG4gICAgICAgICAgICBjb25zdCBbZnJvbURpcmVjdGlvbiwgdG9EaXJlY3Rpb25dID0gcmVzb2x2ZURpcmVjdGlvbihmcm9tLCB0byk7XG5cbiAgICAgICAgICAgIGZyb20uZGlyZWN0aW9uID0gZnJvbURpcmVjdGlvbjtcbiAgICAgICAgICAgIHRvLmRpcmVjdGlvbiA9IHRvRGlyZWN0aW9uO1xuXG4gICAgICAgICAgICByZXN1bHRWZXJ0aWNlcy5wdXNoKC4uLnJvdXRlQmV0d2VlblBvaW50cyhmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbXBsaWZ5UG9pbnRzKHJlc3VsdFZlcnRpY2VzKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpcmVjdGlvbihmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY2Vzc0RpcmVjdGlvbiA9IGZyb20uZGlyZWN0aW9uO1xuICAgIGNvbnN0IGlzRGlyZWN0aW9uVmVydGljYWwgPSBWRVJUSUNBTF9ESVJFQ1RJT05TLmluY2x1ZGVzKGFjY2Vzc0RpcmVjdGlvbik7XG5cbiAgICBsZXQgc291cmNlRGlyZWN0aW9uID0gZnJvbS5kaXJlY3Rpb247XG4gICAgbGV0IHRhcmdldERpcmVjdGlvbiA9IHRvLmRpcmVjdGlvbjtcblxuICAgIGlmIChpc0RpcmVjdGlvblZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IGlzVG9BYm92ZSA9IGZyb20ucG9pbnQueSA+IHRvLnBvaW50Lnk7XG4gICAgICAgIGNvbnN0IGR4ID0gdG8ucG9pbnQueCAtIGZyb20ucG9pbnQueDtcblxuICAgICAgICBpZiAoYWNjZXNzRGlyZWN0aW9uID09PSBEaXJlY3Rpb25zLkJPVFRPTSkge1xuICAgICAgICAgICAgLy8gSWYgaXNUb0Fib3ZlID09PSBmYWxzZSBhbmQgd2UgbmVlZCBmaWd1cmUgb3V0IGlmIHRvIGdvIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICAgIHNvdXJjZURpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXSA6IGR4ID49IDAgPyBEaXJlY3Rpb25zLlJJR0hUIDogRGlyZWN0aW9ucy5MRUZUO1xuXG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0Fib3ZlID8gRGlyZWN0aW9ucy5MRUZUIDogRGlyZWN0aW9ucy5UT1A7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IERpcmVjdGlvbnMuUklHSFQgOiBEaXJlY3Rpb25zLlRPUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGlzVG9BYm92ZSA9PT0gdHJ1ZSBhbmQgd2UgbmVlZCBmaWd1cmUgb3V0IGlmIHRvIGdvIGxlZnQgb3IgcmlnaHRcbiAgICAgICAgICAgIHNvdXJjZURpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IGR4ID49IDAgPyBEaXJlY3Rpb25zLlJJR0hUIDogRGlyZWN0aW9ucy5MRUZUIDogT1BQT1NJVEVfRElSRUNUSU9OU1thY2Nlc3NEaXJlY3Rpb25dO1xuXG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RGlyZWN0aW9uID0gaXNUb0Fib3ZlID8gRGlyZWN0aW9ucy5CT1RUT00gOiBEaXJlY3Rpb25zLkxFRlQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9BYm92ZSA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5SSUdIVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGlzVG9MZWZ0ID0gZnJvbS5wb2ludC54ID4gdG8ucG9pbnQueDtcbiAgICAgICAgY29uc3QgZHkgPSB0by5wb2ludC55IC0gZnJvbS5wb2ludC55O1xuXG4gICAgICAgIGlmIChhY2Nlc3NEaXJlY3Rpb24gPT09IERpcmVjdGlvbnMuUklHSFQpIHtcbiAgICAgICAgICAgIHNvdXJjZURpcmVjdGlvbiA9IGlzVG9MZWZ0ID8gT1BQT1NJVEVfRElSRUNUSU9OU1thY2Nlc3NEaXJlY3Rpb25dIDogZHkgPj0gMCA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5UT1A7XG5cbiAgICAgICAgICAgIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvTGVmdCA/IERpcmVjdGlvbnMuVE9QIDogRGlyZWN0aW9ucy5MRUZUO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvTGVmdCA/IERpcmVjdGlvbnMuQk9UVE9NIDogRGlyZWN0aW9ucy5MRUZUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlRGlyZWN0aW9uID0gaXNUb0xlZnQgPyBkeSA+PSAwID8gRGlyZWN0aW9ucy5CT1RUT00gOiBEaXJlY3Rpb25zLlRPUCA6IE9QUE9TSVRFX0RJUkVDVElPTlNbYWNjZXNzRGlyZWN0aW9uXTtcblxuICAgICAgICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERpcmVjdGlvbiA9IGlzVG9MZWZ0ID8gRGlyZWN0aW9ucy5SSUdIVCA6IERpcmVjdGlvbnMuVE9QO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaXJlY3Rpb24gPSBpc1RvTGVmdCA/IERpcmVjdGlvbnMuUklHSFQgOiBEaXJlY3Rpb25zLkJPVFRPTTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbc291cmNlRGlyZWN0aW9uLCB0YXJnZXREaXJlY3Rpb25dO1xufVxuXG5yaWdodEFuZ2xlUm91dGVyLkRpcmVjdGlvbnMgPSBEaXJlY3Rpb25zO1xuXG5leHBvcnQgY29uc3QgcmlnaHRBbmdsZSA9IHJpZ2h0QW5nbGVSb3V0ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/routers/rightAngle.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/shapes/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@joint/core/src/shapes/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   standard: function() { return /* reexport module object */ _standard_mjs__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _standard_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./standard.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/shapes/standard.mjs\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvc2hhcGVzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy9zaGFwZXMvaW5kZXgubWpzPzA0MjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc3RhbmRhcmQgZnJvbSAnLi9zdGFuZGFyZC5tanMnO1xuXG5leHBvcnQgeyBzdGFuZGFyZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/shapes/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/shapes/standard.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/shapes/standard.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderedImage: function() { return /* binding */ BorderedImage; },\n/* harmony export */   Circle: function() { return /* binding */ Circle; },\n/* harmony export */   Cylinder: function() { return /* binding */ Cylinder; },\n/* harmony export */   DoubleLink: function() { return /* binding */ DoubleLink; },\n/* harmony export */   Ellipse: function() { return /* binding */ Ellipse; },\n/* harmony export */   EmbeddedImage: function() { return /* binding */ EmbeddedImage; },\n/* harmony export */   HeaderedRectangle: function() { return /* binding */ HeaderedRectangle; },\n/* harmony export */   Image: function() { return /* binding */ Image; },\n/* harmony export */   InscribedImage: function() { return /* binding */ InscribedImage; },\n/* harmony export */   Link: function() { return /* binding */ Link; },\n/* harmony export */   Path: function() { return /* binding */ Path; },\n/* harmony export */   Polygon: function() { return /* binding */ Polygon; },\n/* harmony export */   Polyline: function() { return /* binding */ Polyline; },\n/* harmony export */   Rectangle: function() { return /* binding */ Rectangle; },\n/* harmony export */   ShadowLink: function() { return /* binding */ ShadowLink; },\n/* harmony export */   TextBlock: function() { return /* binding */ TextBlock; }\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dia/Element.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Element.mjs\");\n/* harmony import */ var _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dia/Link.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Link.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _util_index_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n/* harmony import */ var _dia_attributes_index_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dia/attributes/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/attributes/index.mjs\");\n/* harmony import */ var _env_index_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../env/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/env/index.mjs\");\n\n\n\n\n\n\n\n\n// ELEMENTS\n\nconst Rectangle = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Rectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body',\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Circle = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Circle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(s/2)',\n            cy: 'calc(s/2)',\n            r: 'calc(s/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'circle',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Ellipse = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Ellipse', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Path = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Path', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            d: 'M 0 0 H calc(w) V calc(h) H 0 Z',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Polygon = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Polygon', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polygon',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Polyline = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Polyline', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            points: '0 0 calc(w) 0 calc(w) calc(h) 0 calc(h)',\n            strokeWidth: 2,\n            stroke: '#333333',\n            fill: '#FFFFFF'\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'polyline',\n        selector: 'body'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst Image = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Image', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        image: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst BorderedImage = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.BorderedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5,\n            fill: '#FFFFFF'\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(w-1)',\n            height: 'calc(h-1)',\n            x: 0.5,\n            y: 0.5\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'background',\n        attributes: {\n            'stroke': 'none'\n        }\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'rect',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst EmbeddedImage = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.EmbeddedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#FFFFFF',\n            strokeWidth: 2\n        },\n        image: {\n            // xlinkHref: '[URL]'\n            width: 'calc(0.3*w)',\n            height: 'calc(h-20)',\n            x: 10,\n            y: 10,\n            preserveAspectRatio: 'xMidYMin'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'left',\n            x: 'calc(0.3*w+20)', // 10 + 10\n            y: 10,\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst InscribedImage = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.InscribedImage', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        border: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        background: {\n            rx: 'calc(w/2)',\n            ry: 'calc(h/2)',\n            cx: 'calc(w/2)',\n            cy: 'calc(h/2)',\n            fill: '#FFFFFF'\n        },\n        image: {\n            // The image corners touch the border when its size is Math.sqrt(2) / 2 = 0.707.. ~= 70%\n            width: 'calc(0.68*w)',\n            height: 'calc(0.68*h)',\n            // The image offset is calculated as (100% - 68%) / 2\n            x: 'calc(0.16*w)',\n            y: 'calc(0.16*h)',\n            preserveAspectRatio: 'xMidYMid'\n            // xlinkHref: '[URL]'\n        },\n        label: {\n            textVerticalAnchor: 'top',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+10)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'ellipse',\n        selector: 'background'\n    }, {\n        tagName: 'image',\n        selector: 'image'\n    }, {\n        tagName: 'ellipse',\n        selector: 'border',\n        attributes: {\n            'fill': 'none'\n        }\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }]\n});\n\nconst HeaderedRectangle = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.HeaderedRectangle', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        header: {\n            width: 'calc(w)',\n            height: 30,\n            strokeWidth: 2,\n            stroke: '#000000',\n            fill: '#FFFFFF'\n        },\n        headerText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 15,\n            fontSize: 16,\n            fill: '#333333'\n        },\n        bodyText: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h/2+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, {\n        tagName: 'rect',\n        selector: 'header'\n    }, {\n        tagName: 'text',\n        selector: 'headerText'\n    }, {\n        tagName: 'text',\n        selector: 'bodyText'\n    }]\n});\n\nvar CYLINDER_TILT = 10;\n\nconst Cylinder = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.Cylinder', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            lateralArea: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        top: {\n            cx: 'calc(w/2)',\n            cy: CYLINDER_TILT,\n            rx: 'calc(w/2)',\n            ry: CYLINDER_TILT,\n            fill: '#FFFFFF',\n            stroke: '#333333',\n            strokeWidth: 2\n        },\n        label: {\n            textVerticalAnchor: 'middle',\n            textAnchor: 'middle',\n            x: 'calc(w/2)',\n            y: 'calc(h+15)',\n            fontSize: 14,\n            fill: '#333333'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'body'\n    }, {\n        tagName: 'ellipse',\n        selector: 'top'\n    }, {\n        tagName: 'text',\n        selector: 'label'\n    }],\n\n    topRy: function(t, opt) {\n        // getter\n        if (t === undefined) return this.attr('body/lateralArea');\n\n        // setter\n        var bodyAttrs = { lateralArea: t };\n\n        var isPercentageSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(t);\n        var ty = (isPercentageSetter) ? `calc(${parseFloat(t) / 100}*h)` : t;\n        var topAttrs = { cy: ty, ry: ty };\n\n        return this.attr({ body: bodyAttrs, top: topAttrs }, opt);\n    }\n\n}, {\n    attributes: {\n        'lateral-area': {\n            set: function(t, refBBox) {\n                var isPercentageSetter = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage)(t);\n                if (isPercentageSetter) t = parseFloat(t) / 100;\n\n                var x = refBBox.x;\n                var y = refBBox.y;\n                var w = refBBox.width;\n                var h = refBBox.height;\n\n                // curve control point variables\n                var rx = w / 2;\n                var ry = isPercentageSetter ? (h * t) : t;\n\n                var kappa = _V_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].KAPPA;\n                var cx = kappa * rx;\n                var cy = kappa * (isPercentageSetter ? (h * t) : t);\n\n                // shape variables\n                var xLeft = x;\n                var xCenter = x + (w / 2);\n                var xRight = x + w;\n\n                var ySideTop = y + ry;\n                var yCurveTop = ySideTop - ry;\n                var ySideBottom = y + h - ry;\n                var yCurveBottom = y + h;\n\n                // return calculated shape\n                var data = [\n                    'M', xLeft, ySideTop,\n                    'L', xLeft, ySideBottom,\n                    'C', x, (ySideBottom + cy), (xCenter - cx), yCurveBottom, xCenter, yCurveBottom,\n                    'C', (xCenter + cx), yCurveBottom, xRight, (ySideBottom + cy), xRight, ySideBottom,\n                    'L', xRight, ySideTop,\n                    'C', xRight, (ySideTop - cy), (xCenter + cx), yCurveTop, xCenter, yCurveTop,\n                    'C', (xCenter - cx), yCurveTop, xLeft, (ySideTop - cy), xLeft, ySideTop,\n                    'Z'\n                ];\n                return { d: data.join(' ') };\n            },\n            unset: 'd'\n        }\n    }\n});\n\nvar foLabelMarkup = {\n    tagName: 'foreignObject',\n    selector: 'foreignObject',\n    attributes: {\n        'overflow': 'hidden'\n    },\n    children: [{\n        tagName: 'div',\n        namespaceURI: 'http://www.w3.org/1999/xhtml',\n        selector: 'label',\n        style: {\n            width: '100%',\n            height: '100%',\n            position: 'static',\n            backgroundColor: 'transparent',\n            textAlign: 'center',\n            margin: 0,\n            padding: '0px 5px',\n            boxSizing: 'border-box',\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'center'\n        }\n    }]\n};\n\nvar svgLabelMarkup = {\n    tagName: 'text',\n    selector: 'label',\n    attributes: {\n        'text-anchor': 'middle'\n    }\n};\n\nvar labelMarkup = (_env_index_mjs__WEBPACK_IMPORTED_MODULE_3__.env.test('svgforeignobject')) ? foLabelMarkup : svgLabelMarkup;\n\nconst TextBlock = _dia_Element_mjs__WEBPACK_IMPORTED_MODULE_0__.Element.define('standard.TextBlock', {\n    attrs: {\n        root: {\n            cursor: 'move'\n        },\n        body: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n            stroke: '#333333',\n            fill: '#ffffff',\n            strokeWidth: 2\n        },\n        foreignObject: {\n            width: 'calc(w)',\n            height: 'calc(h)',\n        },\n        label: {\n            style: {\n                fontSize: 14\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'rect',\n        selector: 'body'\n    }, labelMarkup]\n}, {\n    attributes: {\n        text: {\n            set: function(text, refBBox, node, attrs) {\n                if (node instanceof HTMLElement) {\n                    node.textContent = text;\n                } else {\n                    // No foreign object\n                    var style = attrs['style'] || {};\n                    var wrapValue = { text, width: -5, height: '100%' };\n                    var wrapAttrs = (0,_util_index_mjs__WEBPACK_IMPORTED_MODULE_4__.assign)({ 'text-vertical-anchor': 'middle' }, style);\n                    _dia_attributes_index_mjs__WEBPACK_IMPORTED_MODULE_5__.attributes['text-wrap'].set.call(this, wrapValue, refBBox, node, wrapAttrs);\n                    return { fill: style.color || null };\n                }\n            },\n            unset: function(node) {\n                node.textContent = '';\n                if (node instanceof SVGElement) {\n                    return 'fill';\n                }\n            },\n            position: function(text, refBBox, node) {\n                // No foreign object\n                if (node instanceof SVGElement) return refBBox.center();\n            }\n        }\n    }\n});\n\n// LINKS\n\nconst Link = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__.Link.define('standard.Link', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#333333',\n            strokeWidth: 2,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 10 -5 0 0 10 5 z'\n            }\n        },\n        wrapper: {\n            connection: true,\n            strokeWidth: 10,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'wrapper',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer',\n            'stroke': 'transparent',\n            'stroke-linecap': 'round'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nconst DoubleLink = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__.Link.define('standard.DoubleLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#DDDDDD',\n            strokeWidth: 4,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                type: 'path',\n                stroke: '#000000',\n                d: 'M 10 -3 10 -10 -2 0 10 10 10 3'\n            }\n        },\n        outline: {\n            connection: true,\n            stroke: '#000000',\n            strokeWidth: 6,\n            strokeLinejoin: 'round'\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'outline',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }]\n});\n\nconst ShadowLink = _dia_Link_mjs__WEBPACK_IMPORTED_MODULE_6__.Link.define('standard.ShadowLink', {\n    attrs: {\n        line: {\n            connection: true,\n            stroke: '#FF0000',\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M 0 -10 -10 0 0 10 z'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        },\n        shadow: {\n            connection: true,\n            transform: 'translate(3,6)',\n            stroke: '#000000',\n            strokeOpacity: 0.2,\n            strokeWidth: 20,\n            strokeLinejoin: 'round',\n            targetMarker: {\n                'type': 'path',\n                'd': 'M 0 -10 -10 0 0 10 z',\n                'stroke': 'none'\n            },\n            sourceMarker: {\n                'type': 'path',\n                'stroke': 'none',\n                'd': 'M -10 -10 0 0 -10 10 0 10 0 -10 z'\n            }\n        }\n    }\n}, {\n    markup: [{\n        tagName: 'path',\n        selector: 'shadow',\n        attributes: {\n            'fill': 'none',\n            'pointer-events': 'none'\n        }\n    }, {\n        tagName: 'path',\n        selector: 'line',\n        attributes: {\n            'fill': 'none',\n            'cursor': 'pointer'\n        }\n    }]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvc2hhcGVzL3N0YW5kYXJkLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNjO0FBQ007QUFDTTtBQUNBO0FBQ2xCOzs7QUFHdkM7O0FBRU8sa0JBQWtCLHFEQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sZUFBZSxxREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sZ0JBQWdCLHFEQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLGFBQWEscURBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sZ0JBQWdCLHFEQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLGlCQUFpQixxREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFTSxjQUFjLHFEQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFTSxzQkFBc0IscURBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRU0sc0JBQXNCLHFEQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFTSx1QkFBdUIscURBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVNLDBCQUEwQixxREFBTztBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3NoYXBlcy9zdGFuZGFyZC5tanM/ZWMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vZGlhL0VsZW1lbnQubWpzJztcbmltcG9ydCB7IExpbmsgYXMgTGlua0Jhc2UgfSBmcm9tICcuLi9kaWEvTGluay5tanMnO1xuaW1wb3J0IHsgaXNQZXJjZW50YWdlLCBhc3NpZ24gfSBmcm9tICcuLi91dGlsL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBhdHRyaWJ1dGVzIH0gZnJvbSAnLi4vZGlhL2F0dHJpYnV0ZXMvaW5kZXgubWpzJztcbmltcG9ydCB7IGVudiB9IGZyb20gJy4uL2Vudi9pbmRleC5tanMnO1xuXG5cbi8vIEVMRU1FTlRTXG5cbmV4cG9ydCBjb25zdCBSZWN0YW5nbGUgPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuUmVjdGFuZ2xlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgpJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5JyxcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBDaXJjbGUgPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuQ2lyY2xlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGN4OiAnY2FsYyhzLzIpJyxcbiAgICAgICAgICAgIGN5OiAnY2FsYyhzLzIpJyxcbiAgICAgICAgICAgIHI6ICdjYWxjKHMvMiknLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ2NpcmNsZScsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBFbGxpcHNlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLkVsbGlwc2UnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgY3g6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgY3k6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgcng6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgcnk6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ2VsbGlwc2UnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgUGF0aCA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5QYXRoJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIGQ6ICdNIDAgMCBIIGNhbGModykgViBjYWxjKGgpIEggMCBaJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5J1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsJ1xuICAgIH1dXG59KTtcblxuZXhwb3J0IGNvbnN0IFBvbHlnb24gPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuUG9seWdvbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBwb2ludHM6ICcwIDAgY2FsYyh3KSAwIGNhbGModykgY2FsYyhoKSAwIGNhbGMoaCknLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoLzIpJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3BvbHlnb24nLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgUG9seWxpbmUgPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuUG9seWxpbmUnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgcG9pbnRzOiAnMCAwIGNhbGModykgMCBjYWxjKHcpIGNhbGMoaCkgMCBjYWxjKGgpJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHg6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdwb2x5bGluZScsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBJbWFnZSA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5JbWFnZScsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKHcpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaCknLFxuICAgICAgICAgICAgLy8geGxpbmtIcmVmOiAnW1VSTF0nXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICd0b3AnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHk6ICdjYWxjKGgrMTApJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ2ltYWdlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdpbWFnZSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBCb3JkZXJlZEltYWdlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLkJvcmRlcmVkSW1hZ2UnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyOiB7XG4gICAgICAgICAgICB3aWR0aDogJ2NhbGModyknLFxuICAgICAgICAgICAgaGVpZ2h0OiAnY2FsYyhoKScsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3LTEpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaC0xKScsXG4gICAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgICB5OiAwLjUsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIC8vIHhsaW5rSHJlZjogJ1tVUkxdJ1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKHctMSknLFxuICAgICAgICAgICAgaGVpZ2h0OiAnY2FsYyhoLTEpJyxcbiAgICAgICAgICAgIHg6IDAuNSxcbiAgICAgICAgICAgIHk6IDAuNVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAndG9wJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoKzEwKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ3N0cm9rZSc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAnaW1hZ2UnLFxuICAgICAgICBzZWxlY3RvcjogJ2ltYWdlJ1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvcmRlcicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdmaWxsJzogJ25vbmUnXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBFbWJlZGRlZEltYWdlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLkVtYmVkZGVkSW1hZ2UnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKHcpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaCknLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRicsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBpbWFnZToge1xuICAgICAgICAgICAgLy8geGxpbmtIcmVmOiAnW1VSTF0nXG4gICAgICAgICAgICB3aWR0aDogJ2NhbGMoMC4zKncpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaC0yMCknLFxuICAgICAgICAgICAgeDogMTAsXG4gICAgICAgICAgICB5OiAxMCxcbiAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICd4TWlkWU1pbidcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHRleHRWZXJ0aWNhbEFuY2hvcjogJ3RvcCcsXG4gICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbGVmdCcsXG4gICAgICAgICAgICB4OiAnY2FsYygwLjMqdysyMCknLCAvLyAxMCArIDEwXG4gICAgICAgICAgICB5OiAxMCxcbiAgICAgICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgICAgICAgIGZpbGw6ICcjMzMzMzMzJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3JlY3QnLFxuICAgICAgICBzZWxlY3RvcjogJ2JvZHknXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAnaW1hZ2UnLFxuICAgICAgICBzZWxlY3RvcjogJ2ltYWdlJ1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3RleHQnLFxuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsJ1xuICAgIH1dXG59KTtcblxuZXhwb3J0IGNvbnN0IEluc2NyaWJlZEltYWdlID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLkluc2NyaWJlZEltYWdlJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICAgIGN1cnNvcjogJ21vdmUnXG4gICAgICAgIH0sXG4gICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgcng6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgcnk6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgY3g6ICdjYWxjKHcvMiknLFxuICAgICAgICAgICAgY3k6ICdjYWxjKGgvMiknLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgICAgICByeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICByeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBjeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICBjeTogJ2NhbGMoaC8yKScsXG4gICAgICAgICAgICBmaWxsOiAnI0ZGRkZGRidcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIC8vIFRoZSBpbWFnZSBjb3JuZXJzIHRvdWNoIHRoZSBib3JkZXIgd2hlbiBpdHMgc2l6ZSBpcyBNYXRoLnNxcnQoMikgLyAyID0gMC43MDcuLiB+PSA3MCVcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYygwLjY4KncpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoMC42OCpoKScsXG4gICAgICAgICAgICAvLyBUaGUgaW1hZ2Ugb2Zmc2V0IGlzIGNhbGN1bGF0ZWQgYXMgKDEwMCUgLSA2OCUpIC8gMlxuICAgICAgICAgICAgeDogJ2NhbGMoMC4xNip3KScsXG4gICAgICAgICAgICB5OiAnY2FsYygwLjE2KmgpJyxcbiAgICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICd4TWlkWU1pZCdcbiAgICAgICAgICAgIC8vIHhsaW5rSHJlZjogJ1tVUkxdJ1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAndG9wJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoKzEwKScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdlbGxpcHNlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdiYWNrZ3JvdW5kJ1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ2ltYWdlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdpbWFnZSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdlbGxpcHNlJyxcbiAgICAgICAgc2VsZWN0b3I6ICdib3JkZXInLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGFiZWwnXG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgSGVhZGVyZWRSZWN0YW5nbGUgPSBFbGVtZW50LmRlZmluZSgnc3RhbmRhcmQuSGVhZGVyZWRSZWN0YW5nbGUnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZSdcbiAgICAgICAgfSxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgICAgd2lkdGg6ICdjYWxjKHcpJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2NhbGMoaCknLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICBoZWlnaHQ6IDMwLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJ1xuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJUZXh0OiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHk6IDE1LFxuICAgICAgICAgICAgZm9udFNpemU6IDE2LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHlUZXh0OiB7XG4gICAgICAgICAgICB0ZXh0VmVydGljYWxBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICB4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHk6ICdjYWxjKGgvMisxNSknLFxuICAgICAgICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgICAgICAgZmlsbDogJyMzMzMzMzMnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keSdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdyZWN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdoZWFkZXInXG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAndGV4dCcsXG4gICAgICAgIHNlbGVjdG9yOiAnaGVhZGVyVGV4dCdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5VGV4dCdcbiAgICB9XVxufSk7XG5cbnZhciBDWUxJTkRFUl9USUxUID0gMTA7XG5cbmV4cG9ydCBjb25zdCBDeWxpbmRlciA9IEVsZW1lbnQuZGVmaW5lKCdzdGFuZGFyZC5DeWxpbmRlcicsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBsYXRlcmFsQXJlYTogQ1lMSU5ERVJfVElMVCxcbiAgICAgICAgICAgIGZpbGw6ICcjRkZGRkZGJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDJcbiAgICAgICAgfSxcbiAgICAgICAgdG9wOiB7XG4gICAgICAgICAgICBjeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICBjeTogQ1lMSU5ERVJfVElMVCxcbiAgICAgICAgICAgIHJ4OiAnY2FsYyh3LzIpJyxcbiAgICAgICAgICAgIHJ5OiBDWUxJTkRFUl9USUxULFxuICAgICAgICAgICAgZmlsbDogJyNGRkZGRkYnLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzMzMzMzMycsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMlxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgdGV4dFZlcnRpY2FsQW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuICAgICAgICAgICAgeDogJ2NhbGMody8yKScsXG4gICAgICAgICAgICB5OiAnY2FsYyhoKzE1KScsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBmaWxsOiAnIzMzMzMzMydcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBtYXJrdXA6IFt7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdib2R5J1xuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ2VsbGlwc2UnLFxuICAgICAgICBzZWxlY3RvcjogJ3RvcCdcbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdsYWJlbCdcbiAgICB9XSxcblxuICAgIHRvcFJ5OiBmdW5jdGlvbih0LCBvcHQpIHtcbiAgICAgICAgLy8gZ2V0dGVyXG4gICAgICAgIGlmICh0ID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmF0dHIoJ2JvZHkvbGF0ZXJhbEFyZWEnKTtcblxuICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgdmFyIGJvZHlBdHRycyA9IHsgbGF0ZXJhbEFyZWE6IHQgfTtcblxuICAgICAgICB2YXIgaXNQZXJjZW50YWdlU2V0dGVyID0gaXNQZXJjZW50YWdlKHQpO1xuICAgICAgICB2YXIgdHkgPSAoaXNQZXJjZW50YWdlU2V0dGVyKSA/IGBjYWxjKCR7cGFyc2VGbG9hdCh0KSAvIDEwMH0qaClgIDogdDtcbiAgICAgICAgdmFyIHRvcEF0dHJzID0geyBjeTogdHksIHJ5OiB0eSB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoeyBib2R5OiBib2R5QXR0cnMsIHRvcDogdG9wQXR0cnMgfSwgb3B0KTtcbiAgICB9XG5cbn0sIHtcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdsYXRlcmFsLWFyZWEnOiB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHQsIHJlZkJCb3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNQZXJjZW50YWdlU2V0dGVyID0gaXNQZXJjZW50YWdlKHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1BlcmNlbnRhZ2VTZXR0ZXIpIHQgPSBwYXJzZUZsb2F0KHQpIC8gMTAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSByZWZCQm94Lng7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSByZWZCQm94Lnk7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSByZWZCQm94LndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBoID0gcmVmQkJveC5oZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBjdXJ2ZSBjb250cm9sIHBvaW50IHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgIHZhciByeCA9IHcgLyAyO1xuICAgICAgICAgICAgICAgIHZhciByeSA9IGlzUGVyY2VudGFnZVNldHRlciA/IChoICogdCkgOiB0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGthcHBhID0gVi5LQVBQQTtcbiAgICAgICAgICAgICAgICB2YXIgY3ggPSBrYXBwYSAqIHJ4O1xuICAgICAgICAgICAgICAgIHZhciBjeSA9IGthcHBhICogKGlzUGVyY2VudGFnZVNldHRlciA/IChoICogdCkgOiB0KTtcblxuICAgICAgICAgICAgICAgIC8vIHNoYXBlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgIHZhciB4TGVmdCA9IHg7XG4gICAgICAgICAgICAgICAgdmFyIHhDZW50ZXIgPSB4ICsgKHcgLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgeFJpZ2h0ID0geCArIHc7XG5cbiAgICAgICAgICAgICAgICB2YXIgeVNpZGVUb3AgPSB5ICsgcnk7XG4gICAgICAgICAgICAgICAgdmFyIHlDdXJ2ZVRvcCA9IHlTaWRlVG9wIC0gcnk7XG4gICAgICAgICAgICAgICAgdmFyIHlTaWRlQm90dG9tID0geSArIGggLSByeTtcbiAgICAgICAgICAgICAgICB2YXIgeUN1cnZlQm90dG9tID0geSArIGg7XG5cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gY2FsY3VsYXRlZCBzaGFwZVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICAnTScsIHhMZWZ0LCB5U2lkZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgJ0wnLCB4TGVmdCwgeVNpZGVCb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICdDJywgeCwgKHlTaWRlQm90dG9tICsgY3kpLCAoeENlbnRlciAtIGN4KSwgeUN1cnZlQm90dG9tLCB4Q2VudGVyLCB5Q3VydmVCb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICdDJywgKHhDZW50ZXIgKyBjeCksIHlDdXJ2ZUJvdHRvbSwgeFJpZ2h0LCAoeVNpZGVCb3R0b20gKyBjeSksIHhSaWdodCwgeVNpZGVCb3R0b20sXG4gICAgICAgICAgICAgICAgICAgICdMJywgeFJpZ2h0LCB5U2lkZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgJ0MnLCB4UmlnaHQsICh5U2lkZVRvcCAtIGN5KSwgKHhDZW50ZXIgKyBjeCksIHlDdXJ2ZVRvcCwgeENlbnRlciwgeUN1cnZlVG9wLFxuICAgICAgICAgICAgICAgICAgICAnQycsICh4Q2VudGVyIC0gY3gpLCB5Q3VydmVUb3AsIHhMZWZ0LCAoeVNpZGVUb3AgLSBjeSksIHhMZWZ0LCB5U2lkZVRvcCxcbiAgICAgICAgICAgICAgICAgICAgJ1onXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkOiBkYXRhLmpvaW4oJyAnKSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0OiAnZCdcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgZm9MYWJlbE1hcmt1cCA9IHtcbiAgICB0YWdOYW1lOiAnZm9yZWlnbk9iamVjdCcsXG4gICAgc2VsZWN0b3I6ICdmb3JlaWduT2JqZWN0JyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICdvdmVyZmxvdyc6ICdoaWRkZW4nXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgIG5hbWVzcGFjZVVSSTogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuICAgICAgICBzZWxlY3RvcjogJ2xhYmVsJyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhdGljJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAnMHB4IDVweCcsXG4gICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgICAgIH1cbiAgICB9XVxufTtcblxudmFyIHN2Z0xhYmVsTWFya3VwID0ge1xuICAgIHRhZ05hbWU6ICd0ZXh0JyxcbiAgICBzZWxlY3RvcjogJ2xhYmVsJyxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnXG4gICAgfVxufTtcblxudmFyIGxhYmVsTWFya3VwID0gKGVudi50ZXN0KCdzdmdmb3JlaWdub2JqZWN0JykpID8gZm9MYWJlbE1hcmt1cCA6IHN2Z0xhYmVsTWFya3VwO1xuXG5leHBvcnQgY29uc3QgVGV4dEJsb2NrID0gRWxlbWVudC5kZWZpbmUoJ3N0YW5kYXJkLlRleHRCbG9jaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgICByb290OiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdtb3ZlJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICB3aWR0aDogJ2NhbGModyknLFxuICAgICAgICAgICAgaGVpZ2h0OiAnY2FsYyhoKScsXG4gICAgICAgICAgICBzdHJva2U6ICcjMzMzMzMzJyxcbiAgICAgICAgICAgIGZpbGw6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIGZvcmVpZ25PYmplY3Q6IHtcbiAgICAgICAgICAgIHdpZHRoOiAnY2FsYyh3KScsXG4gICAgICAgICAgICBoZWlnaHQ6ICdjYWxjKGgpJyxcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDE0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncmVjdCcsXG4gICAgICAgIHNlbGVjdG9yOiAnYm9keSdcbiAgICB9LCBsYWJlbE1hcmt1cF1cbn0sIHtcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24odGV4dCwgcmVmQkJveCwgbm9kZSwgYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGZvcmVpZ24gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGF0dHJzWydzdHlsZSddIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcFZhbHVlID0geyB0ZXh0LCB3aWR0aDogLTUsIGhlaWdodDogJzEwMCUnIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwQXR0cnMgPSBhc3NpZ24oeyAndGV4dC12ZXJ0aWNhbC1hbmNob3InOiAnbWlkZGxlJyB9LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbJ3RleHQtd3JhcCddLnNldC5jYWxsKHRoaXMsIHdyYXBWYWx1ZSwgcmVmQkJveCwgbm9kZSwgd3JhcEF0dHJzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmlsbDogc3R5bGUuY29sb3IgfHwgbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdmaWxsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKHRleHQsIHJlZkJCb3gsIG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBmb3JlaWduIG9iamVjdFxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkgcmV0dXJuIHJlZkJCb3guY2VudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLy8gTElOS1NcblxuZXhwb3J0IGNvbnN0IExpbmsgPSBMaW5rQmFzZS5kZWZpbmUoJ3N0YW5kYXJkLkxpbmsnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN0cm9rZTogJyMzMzMzMzMnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIsXG4gICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgIHRhcmdldE1hcmtlcjoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICdkJzogJ00gMTAgLTUgMCAwIDEwIDUgeidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd3JhcHBlcjoge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAxMCxcbiAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnXG4gICAgICAgIH1cbiAgICB9XG59LCB7XG4gICAgbWFya3VwOiBbe1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnd3JhcHBlcicsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAgICAgJ2N1cnNvcic6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICdzdHJva2UnOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJ3JvdW5kJ1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICB0YWdOYW1lOiAncGF0aCcsXG4gICAgICAgIHNlbGVjdG9yOiAnbGluZScsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgICAgIH1cbiAgICB9XVxufSk7XG5cbmV4cG9ydCBjb25zdCBEb3VibGVMaW5rID0gTGlua0Jhc2UuZGVmaW5lKCdzdGFuZGFyZC5Eb3VibGVMaW5rJywge1xuICAgIGF0dHJzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgICAgICBzdHJva2U6ICcjREREREREJyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiA0LFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICB0YXJnZXRNYXJrZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgZDogJ00gMTAgLTMgMTAgLTEwIC0yIDAgMTAgMTAgMTAgMydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3V0bGluZToge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDYsXG4gICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJ1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ291dGxpbmUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdjdXJzb3InOiAncG9pbnRlcidcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ2xpbmUnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAnZmlsbCc6ICdub25lJyxcbiAgICAgICAgICAgICdwb2ludGVyLWV2ZW50cyc6ICdub25lJ1xuICAgICAgICB9XG4gICAgfV1cbn0pO1xuXG5leHBvcnQgY29uc3QgU2hhZG93TGluayA9IExpbmtCYXNlLmRlZmluZSgnc3RhbmRhcmQuU2hhZG93TGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgc3Ryb2tlOiAnI0ZGMDAwMCcsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMjAsXG4gICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgIHRhcmdldE1hcmtlcjoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJ2QnOiAnTSAwIC0xMCAtMTAgMCAwIDEwIHonXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc291cmNlTWFya2VyOiB7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAncGF0aCcsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnZCc6ICdNIC0xMCAtMTAgMCAwIC0xMCAxMCAwIDEwIDAgLTEwIHonXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYWRvdzoge1xuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgzLDYpJyxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogMC4yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDIwLFxuICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICB0YXJnZXRNYXJrZXI6IHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdwYXRoJyxcbiAgICAgICAgICAgICAgICAnZCc6ICdNIDAgLTEwIC0xMCAwIDAgMTAgeicsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZU1hcmtlcjoge1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ3BhdGgnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJ2QnOiAnTSAtMTAgLTEwIDAgMCAtMTAgMTAgMCAxMCAwIC0xMCB6J1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIG1hcmt1cDogW3tcbiAgICAgICAgdGFnTmFtZTogJ3BhdGgnLFxuICAgICAgICBzZWxlY3RvcjogJ3NoYWRvdycsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICdmaWxsJzogJ25vbmUnLFxuICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnXG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIHRhZ05hbWU6ICdwYXRoJyxcbiAgICAgICAgc2VsZWN0b3I6ICdsaW5lJyxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgJ2ZpbGwnOiAnbm9uZScsXG4gICAgICAgICAgICAnY3Vyc29yJzogJ3BvaW50ZXInXG4gICAgICAgIH1cbiAgICB9XVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/shapes/standard.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/util/calc.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evalCalcExpression: function() { return /* binding */ evalCalcExpression; },\n/* harmony export */   evalCalcFormula: function() { return /* binding */ evalCalcFormula; },\n/* harmony export */   isCalcExpression: function() { return /* binding */ isCalcExpression; }\n/* harmony export */ });\nconst props = {\n    x: 'x',\n    y: 'y',\n    width: 'w',\n    height: 'h',\n    minimum: 's',\n    maximum: 'l',\n    diagonal: 'd'\n};\nconst propsList = Object.keys(props).map(key => props[key]).join('');\nconst numberPattern = '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?';\nconst findSpacesRegex = /\\s/g;\nconst parseFormulaRegExp = new RegExp(`^(${numberPattern}\\\\*)?([${propsList}])(/${numberPattern})?([-+]{1,2}${numberPattern})?$`, 'g');\n\nfunction throwInvalid(expression) {\n    throw new Error(`Invalid calc() expression: ${expression}`);\n}\n\n/*\n* Evaluate the given calc formula.\n* e.g. 'w + 10' in a rect 100x100 -> 110\n*/\nfunction evalCalcFormula(formula, rect) {\n    const match = parseFormulaRegExp.exec(formula.replace(findSpacesRegex, ''));\n    if (!match) throwInvalid(formula);\n    parseFormulaRegExp.lastIndex = 0; // reset regex results for the next run\n    const [,multiply, property, divide, add] = match;\n    const { x, y, width, height } = rect;\n    let value = 0;\n    switch (property) {\n        case props.width: {\n            value = width;\n            break;\n        }\n        case props.height: {\n            value = height;\n            break;\n        }\n        case props.x: {\n            value = x;\n            break;\n        }\n        case props.y: {\n            value = y;\n            break;\n        }\n        case props.minimum: {\n            value = Math.min(height, width);\n            break;\n        }\n        case props.maximum: {\n            value = Math.max(height, width);\n            break;\n        }\n        case props.diagonal: {\n            value = Math.sqrt((height * height) + (width * width));\n            break;\n        }\n    }\n    if (multiply) {\n        // e.g \"2*\"\n        value *= parseFloat(multiply);\n    }\n    if (divide) {\n        // e.g \"/2\"\n        value /= parseFloat(divide.slice(1));\n    }\n    if (add) {\n        value += evalAddExpression(add);\n    }\n    return value;\n}\n\nfunction evalAddExpression(addExpression) {\n    if (!addExpression) return 0;\n    const [sign] = addExpression;\n    switch (sign) {\n        case '+': {\n            return parseFloat(addExpression.substr(1));\n        }\n        case '-': {\n            return -parseFloat(addExpression.substr(1));\n        }\n    }\n    return parseFloat(addExpression);\n}\n\n/*\n* Check if the given value is a calc expression.\n* e.g. 'calc(10 + 100)' -> true\n*/\nfunction isCalcExpression(value) {\n    return typeof value === 'string' && value.includes('calc');\n}\n\nconst calcStart = 'calc(';\nconst calcStartOffset = calcStart.length;\n\n/*\n* Evaluate all calc formulas in the given expression.\n* e.g. 'calc(w + 10)' in rect 100x100 -> '110'\n*/\nfunction evalCalcExpression(expression, rect) {\n    let value = expression;\n    let startSearchIndex = 0;\n    do {\n        let calcIndex = value.indexOf(calcStart, startSearchIndex);\n        if (calcIndex === -1) return value;\n        let calcEndIndex = calcIndex + calcStartOffset;\n        let brackets = 1;\n        findClosingBracket: do {\n            switch (value[calcEndIndex]) {\n                case '(': {\n                    brackets++;\n                    break;\n                }\n                case ')': {\n                    brackets--;\n                    if (brackets === 0) break findClosingBracket;\n                    break;\n                }\n                case undefined: {\n                    // Could not find the closing bracket.\n                    throwInvalid(value);\n                }\n            }\n            calcEndIndex++;\n        } while (true);\n        // Get the calc() expression without nested calcs (recursion)\n        let expression = value.slice(calcIndex + calcStartOffset, calcEndIndex);\n        if (isCalcExpression(expression)) {\n            expression = evalCalcExpression(expression, rect);\n        }\n        // Eval the calc() expression without nested calcs.\n        const calcValue = String(evalCalcFormula(expression, rect));\n        // Replace the calc() expression and continue search\n        value = value.slice(0, calcIndex) + calcValue + value.slice(calcEndIndex + 1);\n        startSearchIndex = calcIndex + calcValue.length;\n    } while (true);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC9jYWxjLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYyxTQUFTLFVBQVUsTUFBTSxjQUFjLFFBQVEsSUFBSSxFQUFFLGNBQWM7O0FBRTVIO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvY2FsYy5tanM/MWI5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcm9wcyA9IHtcbiAgICB4OiAneCcsXG4gICAgeTogJ3knLFxuICAgIHdpZHRoOiAndycsXG4gICAgaGVpZ2h0OiAnaCcsXG4gICAgbWluaW11bTogJ3MnLFxuICAgIG1heGltdW06ICdsJyxcbiAgICBkaWFnb25hbDogJ2QnXG59O1xuY29uc3QgcHJvcHNMaXN0ID0gT2JqZWN0LmtleXMocHJvcHMpLm1hcChrZXkgPT4gcHJvcHNba2V5XSkuam9pbignJyk7XG5jb25zdCBudW1iZXJQYXR0ZXJuID0gJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nO1xuY29uc3QgZmluZFNwYWNlc1JlZ2V4ID0gL1xccy9nO1xuY29uc3QgcGFyc2VGb3JtdWxhUmVnRXhwID0gbmV3IFJlZ0V4cChgXigke251bWJlclBhdHRlcm59XFxcXCopPyhbJHtwcm9wc0xpc3R9XSkoLyR7bnVtYmVyUGF0dGVybn0pPyhbLStdezEsMn0ke251bWJlclBhdHRlcm59KT8kYCwgJ2cnKTtcblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkKGV4cHJlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2FsYygpIGV4cHJlc3Npb246ICR7ZXhwcmVzc2lvbn1gKTtcbn1cblxuLypcbiogRXZhbHVhdGUgdGhlIGdpdmVuIGNhbGMgZm9ybXVsYS5cbiogZS5nLiAndyArIDEwJyBpbiBhIHJlY3QgMTAweDEwMCAtPiAxMTBcbiovXG5leHBvcnQgZnVuY3Rpb24gZXZhbENhbGNGb3JtdWxhKGZvcm11bGEsIHJlY3QpIHtcbiAgICBjb25zdCBtYXRjaCA9IHBhcnNlRm9ybXVsYVJlZ0V4cC5leGVjKGZvcm11bGEucmVwbGFjZShmaW5kU3BhY2VzUmVnZXgsICcnKSk7XG4gICAgaWYgKCFtYXRjaCkgdGhyb3dJbnZhbGlkKGZvcm11bGEpO1xuICAgIHBhcnNlRm9ybXVsYVJlZ0V4cC5sYXN0SW5kZXggPSAwOyAvLyByZXNldCByZWdleCByZXN1bHRzIGZvciB0aGUgbmV4dCBydW5cbiAgICBjb25zdCBbLG11bHRpcGx5LCBwcm9wZXJ0eSwgZGl2aWRlLCBhZGRdID0gbWF0Y2g7XG4gICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSByZWN0O1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlIHByb3BzLndpZHRoOiB7XG4gICAgICAgICAgICB2YWx1ZSA9IHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBwcm9wcy5oZWlnaHQ6IHtcbiAgICAgICAgICAgIHZhbHVlID0gaGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBwcm9wcy54OiB7XG4gICAgICAgICAgICB2YWx1ZSA9IHg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIHByb3BzLnk6IHtcbiAgICAgICAgICAgIHZhbHVlID0geTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMubWluaW11bToge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMubWF4aW11bToge1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChoZWlnaHQsIHdpZHRoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgcHJvcHMuZGlhZ29uYWw6IHtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5zcXJ0KChoZWlnaHQgKiBoZWlnaHQpICsgKHdpZHRoICogd2lkdGgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtdWx0aXBseSkge1xuICAgICAgICAvLyBlLmcgXCIyKlwiXG4gICAgICAgIHZhbHVlICo9IHBhcnNlRmxvYXQobXVsdGlwbHkpO1xuICAgIH1cbiAgICBpZiAoZGl2aWRlKSB7XG4gICAgICAgIC8vIGUuZyBcIi8yXCJcbiAgICAgICAgdmFsdWUgLz0gcGFyc2VGbG9hdChkaXZpZGUuc2xpY2UoMSkpO1xuICAgIH1cbiAgICBpZiAoYWRkKSB7XG4gICAgICAgIHZhbHVlICs9IGV2YWxBZGRFeHByZXNzaW9uKGFkZCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZXZhbEFkZEV4cHJlc3Npb24oYWRkRXhwcmVzc2lvbikge1xuICAgIGlmICghYWRkRXhwcmVzc2lvbikgcmV0dXJuIDA7XG4gICAgY29uc3QgW3NpZ25dID0gYWRkRXhwcmVzc2lvbjtcbiAgICBzd2l0Y2ggKHNpZ24pIHtcbiAgICAgICAgY2FzZSAnKyc6IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGFkZEV4cHJlc3Npb24uc3Vic3RyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICctJzoge1xuICAgICAgICAgICAgcmV0dXJuIC1wYXJzZUZsb2F0KGFkZEV4cHJlc3Npb24uc3Vic3RyKDEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGbG9hdChhZGRFeHByZXNzaW9uKTtcbn1cblxuLypcbiogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgY2FsYyBleHByZXNzaW9uLlxuKiBlLmcuICdjYWxjKDEwICsgMTAwKScgLT4gdHJ1ZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGNFeHByZXNzaW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuaW5jbHVkZXMoJ2NhbGMnKTtcbn1cblxuY29uc3QgY2FsY1N0YXJ0ID0gJ2NhbGMoJztcbmNvbnN0IGNhbGNTdGFydE9mZnNldCA9IGNhbGNTdGFydC5sZW5ndGg7XG5cbi8qXG4qIEV2YWx1YXRlIGFsbCBjYWxjIGZvcm11bGFzIGluIHRoZSBnaXZlbiBleHByZXNzaW9uLlxuKiBlLmcuICdjYWxjKHcgKyAxMCknIGluIHJlY3QgMTAweDEwMCAtPiAnMTEwJ1xuKi9cbmV4cG9ydCBmdW5jdGlvbiBldmFsQ2FsY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgcmVjdCkge1xuICAgIGxldCB2YWx1ZSA9IGV4cHJlc3Npb247XG4gICAgbGV0IHN0YXJ0U2VhcmNoSW5kZXggPSAwO1xuICAgIGRvIHtcbiAgICAgICAgbGV0IGNhbGNJbmRleCA9IHZhbHVlLmluZGV4T2YoY2FsY1N0YXJ0LCBzdGFydFNlYXJjaEluZGV4KTtcbiAgICAgICAgaWYgKGNhbGNJbmRleCA9PT0gLTEpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbGV0IGNhbGNFbmRJbmRleCA9IGNhbGNJbmRleCArIGNhbGNTdGFydE9mZnNldDtcbiAgICAgICAgbGV0IGJyYWNrZXRzID0gMTtcbiAgICAgICAgZmluZENsb3NpbmdCcmFja2V0OiBkbyB7XG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlW2NhbGNFbmRJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICcoJzoge1xuICAgICAgICAgICAgICAgICAgICBicmFja2V0cysrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnKSc6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhY2tldHMtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzID09PSAwKSBicmVhayBmaW5kQ2xvc2luZ0JyYWNrZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDoge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VsZCBub3QgZmluZCB0aGUgY2xvc2luZyBicmFja2V0LlxuICAgICAgICAgICAgICAgICAgICB0aHJvd0ludmFsaWQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGNFbmRJbmRleCsrO1xuICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgLy8gR2V0IHRoZSBjYWxjKCkgZXhwcmVzc2lvbiB3aXRob3V0IG5lc3RlZCBjYWxjcyAocmVjdXJzaW9uKVxuICAgICAgICBsZXQgZXhwcmVzc2lvbiA9IHZhbHVlLnNsaWNlKGNhbGNJbmRleCArIGNhbGNTdGFydE9mZnNldCwgY2FsY0VuZEluZGV4KTtcbiAgICAgICAgaWYgKGlzQ2FsY0V4cHJlc3Npb24oZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBldmFsQ2FsY0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgcmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXZhbCB0aGUgY2FsYygpIGV4cHJlc3Npb24gd2l0aG91dCBuZXN0ZWQgY2FsY3MuXG4gICAgICAgIGNvbnN0IGNhbGNWYWx1ZSA9IFN0cmluZyhldmFsQ2FsY0Zvcm11bGEoZXhwcmVzc2lvbiwgcmVjdCkpO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBjYWxjKCkgZXhwcmVzc2lvbiBhbmQgY29udGludWUgc2VhcmNoXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2FsY0luZGV4KSArIGNhbGNWYWx1ZSArIHZhbHVlLnNsaWNlKGNhbGNFbmRJbmRleCArIDEpO1xuICAgICAgICBzdGFydFNlYXJjaEluZGV4ID0gY2FsY0luZGV4ICsgY2FsY1ZhbHVlLmxlbmd0aDtcbiAgICB9IHdoaWxlICh0cnVlKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/cloneCells.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@joint/core/src/util/cloneCells.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cloneCells: function() { return /* binding */ cloneCells; }\n/* harmony export */ });\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n// Clone `cells` returning an object that maps the original cell ID to the clone. The number\n// of clones is exactly the same as the `cells.length`.\n// This function simply clones all the `cells`. However, it also reconstructs\n// all the `source/target` and `parent/embed` references within the `cells`.\n// This is the main difference from the `cell.clone()` method. The\n// `cell.clone()` method works on one single cell only.\n// For example, for a graph: `A --- L ---> B`, `cloneCells([A, L, B])`\n// returns `[A2, L2, B2]` resulting to a graph: `A2 --- L2 ---> B2`, i.e.\n// the source and target of the link `L2` is changed to point to `A2` and `B2`.\nfunction cloneCells(cells) {\n\n    cells = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.uniq)(cells);\n\n    // A map of the form [original cell ID] -> [clone] helping\n    // us to reconstruct references for source/target and parent/embeds.\n    // This is also the returned value.\n    const cloneMap = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cells).reduce(function(map, cell) {\n        map[cell.id] = cell.clone();\n        return map;\n    }, {});\n\n    (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cells).forEach(function(cell) {\n\n        const clone = cloneMap[cell.id];\n        // assert(clone exists)\n\n        if (clone.isLink()) {\n            const source = clone.source();\n            const target = clone.target();\n            if (source.id && cloneMap[source.id]) {\n                // Source points to an element and the element is among the clones.\n                // => Update the source of the cloned link.\n                clone.prop('source/id', cloneMap[source.id].id);\n            }\n            if (target.id && cloneMap[target.id]) {\n                // Target points to an element and the element is among the clones.\n                // => Update the target of the cloned link.\n                clone.prop('target/id', cloneMap[target.id].id);\n            }\n        }\n\n        // Find the parent of the original cell\n        const parent = cell.get('parent');\n        if (parent && cloneMap[parent]) {\n            clone.set('parent', cloneMap[parent].id);\n        }\n\n        // Find the embeds of the original cell\n        const embeds = (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(cell.get('embeds')).reduce(function(newEmbeds, embed) {\n            // Embedded cells that are not being cloned can not be carried\n            // over with other embedded cells.\n            if (cloneMap[embed]) {\n                newEmbeds.push(cloneMap[embed].id);\n            }\n            return newEmbeds;\n        }, []);\n\n        if (!(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(embeds)) {\n            clone.set('embeds', embeds);\n        }\n    });\n\n    return cloneMap;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC9jbG9uZUNlbGxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVAsWUFBWSwrQ0FBSTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFPO0FBQzVCO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQsSUFBSSxrREFBTzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixrREFBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULGFBQWEsa0RBQU87QUFDcEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvY2xvbmVDZWxscy5tanM/MzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bmlxLCB0b0FycmF5LCBpc0VtcHR5IH0gZnJvbSAnLi91dGlsLm1qcyc7XG5cbi8vIENsb25lIGBjZWxsc2AgcmV0dXJuaW5nIGFuIG9iamVjdCB0aGF0IG1hcHMgdGhlIG9yaWdpbmFsIGNlbGwgSUQgdG8gdGhlIGNsb25lLiBUaGUgbnVtYmVyXG4vLyBvZiBjbG9uZXMgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgYGNlbGxzLmxlbmd0aGAuXG4vLyBUaGlzIGZ1bmN0aW9uIHNpbXBseSBjbG9uZXMgYWxsIHRoZSBgY2VsbHNgLiBIb3dldmVyLCBpdCBhbHNvIHJlY29uc3RydWN0c1xuLy8gYWxsIHRoZSBgc291cmNlL3RhcmdldGAgYW5kIGBwYXJlbnQvZW1iZWRgIHJlZmVyZW5jZXMgd2l0aGluIHRoZSBgY2VsbHNgLlxuLy8gVGhpcyBpcyB0aGUgbWFpbiBkaWZmZXJlbmNlIGZyb20gdGhlIGBjZWxsLmNsb25lKClgIG1ldGhvZC4gVGhlXG4vLyBgY2VsbC5jbG9uZSgpYCBtZXRob2Qgd29ya3Mgb24gb25lIHNpbmdsZSBjZWxsIG9ubHkuXG4vLyBGb3IgZXhhbXBsZSwgZm9yIGEgZ3JhcGg6IGBBIC0tLSBMIC0tLT4gQmAsIGBjbG9uZUNlbGxzKFtBLCBMLCBCXSlgXG4vLyByZXR1cm5zIGBbQTIsIEwyLCBCMl1gIHJlc3VsdGluZyB0byBhIGdyYXBoOiBgQTIgLS0tIEwyIC0tLT4gQjJgLCBpLmUuXG4vLyB0aGUgc291cmNlIGFuZCB0YXJnZXQgb2YgdGhlIGxpbmsgYEwyYCBpcyBjaGFuZ2VkIHRvIHBvaW50IHRvIGBBMmAgYW5kIGBCMmAuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVDZWxscyhjZWxscykge1xuXG4gICAgY2VsbHMgPSB1bmlxKGNlbGxzKTtcblxuICAgIC8vIEEgbWFwIG9mIHRoZSBmb3JtIFtvcmlnaW5hbCBjZWxsIElEXSAtPiBbY2xvbmVdIGhlbHBpbmdcbiAgICAvLyB1cyB0byByZWNvbnN0cnVjdCByZWZlcmVuY2VzIGZvciBzb3VyY2UvdGFyZ2V0IGFuZCBwYXJlbnQvZW1iZWRzLlxuICAgIC8vIFRoaXMgaXMgYWxzbyB0aGUgcmV0dXJuZWQgdmFsdWUuXG4gICAgY29uc3QgY2xvbmVNYXAgPSB0b0FycmF5KGNlbGxzKS5yZWR1Y2UoZnVuY3Rpb24obWFwLCBjZWxsKSB7XG4gICAgICAgIG1hcFtjZWxsLmlkXSA9IGNlbGwuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSk7XG5cbiAgICB0b0FycmF5KGNlbGxzKS5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpIHtcblxuICAgICAgICBjb25zdCBjbG9uZSA9IGNsb25lTWFwW2NlbGwuaWRdO1xuICAgICAgICAvLyBhc3NlcnQoY2xvbmUgZXhpc3RzKVxuXG4gICAgICAgIGlmIChjbG9uZS5pc0xpbmsoKSkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gY2xvbmUuc291cmNlKCk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBjbG9uZS50YXJnZXQoKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaWQgJiYgY2xvbmVNYXBbc291cmNlLmlkXSkge1xuICAgICAgICAgICAgICAgIC8vIFNvdXJjZSBwb2ludHMgdG8gYW4gZWxlbWVudCBhbmQgdGhlIGVsZW1lbnQgaXMgYW1vbmcgdGhlIGNsb25lcy5cbiAgICAgICAgICAgICAgICAvLyA9PiBVcGRhdGUgdGhlIHNvdXJjZSBvZiB0aGUgY2xvbmVkIGxpbmsuXG4gICAgICAgICAgICAgICAgY2xvbmUucHJvcCgnc291cmNlL2lkJywgY2xvbmVNYXBbc291cmNlLmlkXS5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0LmlkICYmIGNsb25lTWFwW3RhcmdldC5pZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUYXJnZXQgcG9pbnRzIHRvIGFuIGVsZW1lbnQgYW5kIHRoZSBlbGVtZW50IGlzIGFtb25nIHRoZSBjbG9uZXMuXG4gICAgICAgICAgICAgICAgLy8gPT4gVXBkYXRlIHRoZSB0YXJnZXQgb2YgdGhlIGNsb25lZCBsaW5rLlxuICAgICAgICAgICAgICAgIGNsb25lLnByb3AoJ3RhcmdldC9pZCcsIGNsb25lTWFwW3RhcmdldC5pZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50IG9mIHRoZSBvcmlnaW5hbCBjZWxsXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNlbGwuZ2V0KCdwYXJlbnQnKTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBjbG9uZU1hcFtwYXJlbnRdKSB7XG4gICAgICAgICAgICBjbG9uZS5zZXQoJ3BhcmVudCcsIGNsb25lTWFwW3BhcmVudF0uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZW1iZWRzIG9mIHRoZSBvcmlnaW5hbCBjZWxsXG4gICAgICAgIGNvbnN0IGVtYmVkcyA9IHRvQXJyYXkoY2VsbC5nZXQoJ2VtYmVkcycpKS5yZWR1Y2UoZnVuY3Rpb24obmV3RW1iZWRzLCBlbWJlZCkge1xuICAgICAgICAgICAgLy8gRW1iZWRkZWQgY2VsbHMgdGhhdCBhcmUgbm90IGJlaW5nIGNsb25lZCBjYW4gbm90IGJlIGNhcnJpZWRcbiAgICAgICAgICAgIC8vIG92ZXIgd2l0aCBvdGhlciBlbWJlZGRlZCBjZWxscy5cbiAgICAgICAgICAgIGlmIChjbG9uZU1hcFtlbWJlZF0pIHtcbiAgICAgICAgICAgICAgICBuZXdFbWJlZHMucHVzaChjbG9uZU1hcFtlbWJlZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ld0VtYmVkcztcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGlmICghaXNFbXB0eShlbWJlZHMpKSB7XG4gICAgICAgICAgICBjbG9uZS5zZXQoJ2VtYmVkcycsIGVtYmVkcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjbG9uZU1hcDtcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/cloneCells.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/getRectPoint.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@joint/core/src/util/getRectPoint.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Positions: function() { return /* binding */ Positions; },\n/* harmony export */   getRectPoint: function() { return /* binding */ getRectPoint; }\n/* harmony export */ });\n/* harmony import */ var _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../g/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/g/rect.mjs\");\n\n\nconst Positions = {\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left',\n    TOP_LEFT: 'top-left',\n    TOP_RIGHT: 'top-right',\n    BOTTOM_LEFT: 'bottom-left',\n    BOTTOM_RIGHT: 'bottom-right',\n    CENTER: 'center',\n};\n\nfunction getRectPoint(rect, position) {\n    const r = new _g_index_mjs__WEBPACK_IMPORTED_MODULE_0__.Rect(rect);\n    switch (position) {\n        case undefined:\n            throw new Error('Position required');\n\n        // Middle Points\n        case Positions.LEFT:\n        case 'leftMiddle':\n            return r.leftMiddle();\n\n        case Positions.RIGHT:\n        case 'rightMiddle':\n            return r.rightMiddle();\n\n        case Positions.TOP:\n        case 'topMiddle':\n            return r.topMiddle();\n\n        case Positions.BOTTOM:\n        case 'bottomMiddle':\n            return r.bottomMiddle();\n\n        // Corners\n        case Positions.TOP_LEFT:\n        case 'topLeft':\n        case 'origin':\n            return r.topLeft();\n\n        case Positions.TOP_RIGHT:\n        case 'topRight':\n            return r.topRight();\n\n        case Positions.BOTTOM_LEFT:\n        case 'bottomLeft':\n            return r.bottomLeft();\n\n        case Positions.BOTTOM_RIGHT:\n        case 'bottomRight':\n        case 'corner':\n            return r.bottomRight();\n\n        // Center\n        case Positions.CENTER:\n            return r.center();\n\n        // TODO: calc(), percentage etc.\n        default:\n            throw new Error(`Unknown position: ${position}`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC9nZXRSZWN0UG9pbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQzs7QUFFN0I7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLGtCQUFrQiw4Q0FBTTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvZ2V0UmVjdFBvaW50Lm1qcz80NDY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGcgZnJvbSAnLi4vZy9pbmRleC5tanMnO1xuXG5leHBvcnQgY29uc3QgUG9zaXRpb25zID0ge1xuICAgIFRPUDogJ3RvcCcsXG4gICAgUklHSFQ6ICdyaWdodCcsXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcbiAgICBMRUZUOiAnbGVmdCcsXG4gICAgVE9QX0xFRlQ6ICd0b3AtbGVmdCcsXG4gICAgVE9QX1JJR0hUOiAndG9wLXJpZ2h0JyxcbiAgICBCT1RUT01fTEVGVDogJ2JvdHRvbS1sZWZ0JyxcbiAgICBCT1RUT01fUklHSFQ6ICdib3R0b20tcmlnaHQnLFxuICAgIENFTlRFUjogJ2NlbnRlcicsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjdFBvaW50KHJlY3QsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgciA9IG5ldyBnLlJlY3QocmVjdCk7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gcmVxdWlyZWQnKTtcblxuICAgICAgICAvLyBNaWRkbGUgUG9pbnRzXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLkxFRlQ6XG4gICAgICAgIGNhc2UgJ2xlZnRNaWRkbGUnOlxuICAgICAgICAgICAgcmV0dXJuIHIubGVmdE1pZGRsZSgpO1xuXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLlJJR0hUOlxuICAgICAgICBjYXNlICdyaWdodE1pZGRsZSc6XG4gICAgICAgICAgICByZXR1cm4gci5yaWdodE1pZGRsZSgpO1xuXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLlRPUDpcbiAgICAgICAgY2FzZSAndG9wTWlkZGxlJzpcbiAgICAgICAgICAgIHJldHVybiByLnRvcE1pZGRsZSgpO1xuXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLkJPVFRPTTpcbiAgICAgICAgY2FzZSAnYm90dG9tTWlkZGxlJzpcbiAgICAgICAgICAgIHJldHVybiByLmJvdHRvbU1pZGRsZSgpO1xuXG4gICAgICAgIC8vIENvcm5lcnNcbiAgICAgICAgY2FzZSBQb3NpdGlvbnMuVE9QX0xFRlQ6XG4gICAgICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgICBjYXNlICdvcmlnaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHIudG9wTGVmdCgpO1xuXG4gICAgICAgIGNhc2UgUG9zaXRpb25zLlRPUF9SSUdIVDpcbiAgICAgICAgY2FzZSAndG9wUmlnaHQnOlxuICAgICAgICAgICAgcmV0dXJuIHIudG9wUmlnaHQoKTtcblxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5CT1RUT01fTEVGVDpcbiAgICAgICAgY2FzZSAnYm90dG9tTGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gci5ib3R0b21MZWZ0KCk7XG5cbiAgICAgICAgY2FzZSBQb3NpdGlvbnMuQk9UVE9NX1JJR0hUOlxuICAgICAgICBjYXNlICdib3R0b21SaWdodCc6XG4gICAgICAgIGNhc2UgJ2Nvcm5lcic6XG4gICAgICAgICAgICByZXR1cm4gci5ib3R0b21SaWdodCgpO1xuXG4gICAgICAgIC8vIENlbnRlclxuICAgICAgICBjYXNlIFBvc2l0aW9ucy5DRU5URVI6XG4gICAgICAgICAgICByZXR1cm4gci5jZW50ZXIoKTtcblxuICAgICAgICAvLyBUT0RPOiBjYWxjKCksIHBlcmNlbnRhZ2UgZXRjLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBvc2l0aW9uOiAke3Bvc2l0aW9ufWApO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/getRectPoint.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@joint/core/src/util/index.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClassNamePrefix: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.addClassNamePrefix; },\n/* harmony export */   assign: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.assign; },\n/* harmony export */   bindAll: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.bindAll; },\n/* harmony export */   breakText: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.breakText; },\n/* harmony export */   camelCase: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.camelCase; },\n/* harmony export */   cancelFrame: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.cancelFrame; },\n/* harmony export */   cap: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.cap; },\n/* harmony export */   clone: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.clone; },\n/* harmony export */   cloneCells: function() { return /* reexport safe */ _cloneCells_mjs__WEBPACK_IMPORTED_MODULE_2__.cloneCells; },\n/* harmony export */   cloneDeep: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.cloneDeep; },\n/* harmony export */   dataUriToBlob: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.dataUriToBlob; },\n/* harmony export */   debounce: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.debounce; },\n/* harmony export */   deepMixin: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.deepMixin; },\n/* harmony export */   deepSupplement: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.deepSupplement; },\n/* harmony export */   defaults: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaults; },\n/* harmony export */   defaultsDeep: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultsDeep; },\n/* harmony export */   difference: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.difference; },\n/* harmony export */   downloadBlob: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.downloadBlob; },\n/* harmony export */   downloadDataUri: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.downloadDataUri; },\n/* harmony export */   evalCalcExpression: function() { return /* reexport safe */ _calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcExpression; },\n/* harmony export */   evalCalcFormula: function() { return /* reexport safe */ _calc_mjs__WEBPACK_IMPORTED_MODULE_4__.evalCalcFormula; },\n/* harmony export */   filter: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.filter; },\n/* harmony export */   flattenDeep: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenDeep; },\n/* harmony export */   flattenObject: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.flattenObject; },\n/* harmony export */   forIn: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.forIn; },\n/* harmony export */   format: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.format; },\n/* harmony export */   getByPath: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.getByPath; },\n/* harmony export */   getElementBBox: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.getElementBBox; },\n/* harmony export */   getRectPoint: function() { return /* reexport safe */ _getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_5__.getRectPoint; },\n/* harmony export */   groupBy: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.groupBy; },\n/* harmony export */   guid: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.guid; },\n/* harmony export */   has: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.has; },\n/* harmony export */   hashCode: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.hashCode; },\n/* harmony export */   imageToDataUri: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.imageToDataUri; },\n/* harmony export */   interpolate: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.interpolate; },\n/* harmony export */   intersection: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.intersection; },\n/* harmony export */   invoke: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.invoke; },\n/* harmony export */   invokeProperty: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.invokeProperty; },\n/* harmony export */   isBoolean: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isBoolean; },\n/* harmony export */   isCalcExpression: function() { return /* reexport safe */ _calc_mjs__WEBPACK_IMPORTED_MODULE_4__.isCalcExpression; },\n/* harmony export */   isEmpty: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEmpty; },\n/* harmony export */   isEqual: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isEqual; },\n/* harmony export */   isFunction: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction; },\n/* harmony export */   isNumber: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isNumber; },\n/* harmony export */   isObject: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject; },\n/* harmony export */   isPercentage: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPercentage; },\n/* harmony export */   isPlainObject: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isPlainObject; },\n/* harmony export */   isString: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.isString; },\n/* harmony export */   merge: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.merge; },\n/* harmony export */   mixin: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.mixin; },\n/* harmony export */   nextFrame: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.nextFrame; },\n/* harmony export */   noop: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.noop; },\n/* harmony export */   normalizeEvent: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeEvent; },\n/* harmony export */   normalizeSides: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeSides; },\n/* harmony export */   normalizeWheel: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.normalizeWheel; },\n/* harmony export */   objectDifference: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.objectDifference; },\n/* harmony export */   omit: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.omit; },\n/* harmony export */   parseCssNumeric: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.parseCssNumeric; },\n/* harmony export */   parseDOMJSON: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.parseDOMJSON; },\n/* harmony export */   pick: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.pick; },\n/* harmony export */   removeClassNamePrefix: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.removeClassNamePrefix; },\n/* harmony export */   result: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.result; },\n/* harmony export */   sanitizeHTML: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sanitizeHTML; },\n/* harmony export */   setAttributesBySelector: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.setAttributesBySelector; },\n/* harmony export */   setByPath: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.setByPath; },\n/* harmony export */   sortBy: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortBy; },\n/* harmony export */   sortElements: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortElements; },\n/* harmony export */   sortedIndex: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.sortedIndex; },\n/* harmony export */   supplement: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.supplement; },\n/* harmony export */   svg: function() { return /* reexport safe */ _svgTagTemplate_mjs__WEBPACK_IMPORTED_MODULE_3__.svg; },\n/* harmony export */   template: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.template; },\n/* harmony export */   timing: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.timing; },\n/* harmony export */   toArray: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.toArray; },\n/* harmony export */   toKebabCase: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.toKebabCase; },\n/* harmony export */   toggleFullScreen: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.toggleFullScreen; },\n/* harmony export */   union: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.union; },\n/* harmony export */   uniq: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.uniq; },\n/* harmony export */   uniqueId: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.uniqueId; },\n/* harmony export */   unsetByPath: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.unsetByPath; },\n/* harmony export */   uuid: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.uuid; },\n/* harmony export */   without: function() { return /* reexport safe */ _util_mjs__WEBPACK_IMPORTED_MODULE_1__.without; },\n/* harmony export */   wrapWith: function() { return /* reexport safe */ _wrappers_mjs__WEBPACK_IMPORTED_MODULE_0__.wrapWith; },\n/* harmony export */   wrappers: function() { return /* reexport safe */ _wrappers_mjs__WEBPACK_IMPORTED_MODULE_0__.wrappers; }\n/* harmony export */ });\n/* harmony import */ var _wrappers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrappers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/wrappers.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\");\n/* harmony import */ var _cloneCells_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cloneCells.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/cloneCells.mjs\");\n/* harmony import */ var _svgTagTemplate_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./svgTagTemplate.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/svgTagTemplate.mjs\");\n/* harmony import */ var _calc_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./calc.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/calc.mjs\");\n/* harmony import */ var _getRectPoint_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getRectPoint.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/getRectPoint.mjs\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDSjtBQUNNO0FBQ0k7QUFDVjtBQUN1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvaW5kZXgubWpzPzdhMGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi93cmFwcGVycy5tanMnO1xuZXhwb3J0ICogZnJvbSAnLi91dGlsLm1qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Nsb25lQ2VsbHMubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vc3ZnVGFnVGVtcGxhdGUubWpzJztcbmV4cG9ydCAqIGZyb20gJy4vY2FsYy5tanMnO1xuZXhwb3J0IHsgZ2V0UmVjdFBvaW50IH0gZnJvbSAnLi9nZXRSZWN0UG9pbnQubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/svgTagTemplate.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@joint/core/src/util/svgTagTemplate.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   svg: function() { return /* binding */ svg; }\n/* harmony export */ });\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n\n\nfunction svg(strings, ...expressions) {\n    const svgParts = [];\n    strings.forEach((part, index) => {\n        svgParts.push(part);\n        if (index in expressions) {\n            svgParts.push(expressions[index]);\n        }\n    });\n    const markup = parseFromSVGString(svgParts.join(''));\n    return markup;\n}\n\nfunction parseFromSVGString(str) {\n    const parser = new DOMParser();\n    const markupString = `<svg>${str.trim()}</svg>`;\n    const xmldocument = parser.parseFromString(markupString.replace(/@/g, ''), 'application/xml');\n    if (xmldocument.getElementsByTagName('parsererror')[0]) {\n        throw new Error('Invalid SVG markup');\n    }\n    const document = parser.parseFromString(markupString, 'text/html');\n    const svg = document.querySelector('svg');\n    return build(svg);\n}\n\nfunction buildNode(node) {\n    const markupNode = {};\n    const { tagName, attributes, namespaceURI, style, childNodes } = node;\n\n    markupNode.namespaceURI = namespaceURI;\n    markupNode.tagName = (namespaceURI === _V_index_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].namespace.xhtml)\n        // XHTML documents must use lower case for all HTML element and attribute names.\n        // The tagName property returns upper case value for HTML elements.\n        // e.g. <DIV> vs.<div/>\n        ? tagName.toLowerCase()\n        : tagName;\n\n    const stylesObject = {};\n    for (var i = style.length; i--;) {\n        var nameString = style[i];\n        stylesObject[nameString] = style.getPropertyValue(nameString);\n    }\n    markupNode.style = stylesObject;\n\n    // selector fallbacks to tagName\n    const selectorAttribute = attributes.getNamedItem('@selector');\n    if (selectorAttribute) {\n        markupNode.selector = selectorAttribute.value;\n        attributes.removeNamedItem('@selector');\n    }\n\n    const groupSelectorAttribute = attributes.getNamedItem('@group-selector');\n    if (groupSelectorAttribute) {\n        const groupSelectors = groupSelectorAttribute.value.split(',');\n        markupNode.groupSelector = groupSelectors.map(s => s.trim());\n\n        attributes.removeNamedItem('@group-selector');\n    }\n\n    const className = attributes.getNamedItem('class');\n    if (className) {\n        markupNode.className = className.value;\n    }\n\n    const children = [];\n    childNodes.forEach(node => {\n        switch (node.nodeType) {\n            case Node.TEXT_NODE: {\n                const trimmedText = node.data.replace(/\\s\\s+/g, ' ');\n                if (trimmedText.trim()) {\n                    children.push(trimmedText);\n                }\n                break;\n            }\n            case Node.ELEMENT_NODE: {\n                children.push(buildNode(node));\n                break;\n            }\n            default:\n                break;\n        }\n    });\n    if (children.length) {\n        markupNode.children = children;\n    }\n\n    const nodeAttrs = {};\n\n    Array.from(attributes).forEach(nodeAttribute => {\n        const { name, value } = nodeAttribute;\n        nodeAttrs[name] = value;\n    });\n\n    if (Object.keys(nodeAttrs).length > 0) {\n        markupNode.attributes = nodeAttrs;\n    }\n\n    return markupNode;\n}\n\nfunction build(root) {\n    const markup = [];\n\n    Array.from(root.children).forEach(node => {\n        markup.push(buildNode(node));\n    });\n\n    return markup;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC9zdmdUYWdUZW1wbGF0ZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRXhCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx1REFBdUQ7O0FBRW5FO0FBQ0EsMkNBQTJDLG9EQUFDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL3N2Z1RhZ1RlbXBsYXRlLm1qcz80NjlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWIGZyb20gJy4uL1YvaW5kZXgubWpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHN2ZyhzdHJpbmdzLCAuLi5leHByZXNzaW9ucykge1xuICAgIGNvbnN0IHN2Z1BhcnRzID0gW107XG4gICAgc3RyaW5ncy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICBzdmdQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICBpZiAoaW5kZXggaW4gZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHN2Z1BhcnRzLnB1c2goZXhwcmVzc2lvbnNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG1hcmt1cCA9IHBhcnNlRnJvbVNWR1N0cmluZyhzdmdQYXJ0cy5qb2luKCcnKSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbn1cblxuZnVuY3Rpb24gcGFyc2VGcm9tU1ZHU3RyaW5nKHN0cikge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBjb25zdCBtYXJrdXBTdHJpbmcgPSBgPHN2Zz4ke3N0ci50cmltKCl9PC9zdmc+YDtcbiAgICBjb25zdCB4bWxkb2N1bWVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcobWFya3VwU3RyaW5nLnJlcGxhY2UoL0AvZywgJycpLCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgaWYgKHhtbGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpWzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTVkcgbWFya3VwJyk7XG4gICAgfVxuICAgIGNvbnN0IGRvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhtYXJrdXBTdHJpbmcsICd0ZXh0L2h0bWwnKTtcbiAgICBjb25zdCBzdmcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICByZXR1cm4gYnVpbGQoc3ZnKTtcbn1cblxuZnVuY3Rpb24gYnVpbGROb2RlKG5vZGUpIHtcbiAgICBjb25zdCBtYXJrdXBOb2RlID0ge307XG4gICAgY29uc3QgeyB0YWdOYW1lLCBhdHRyaWJ1dGVzLCBuYW1lc3BhY2VVUkksIHN0eWxlLCBjaGlsZE5vZGVzIH0gPSBub2RlO1xuXG4gICAgbWFya3VwTm9kZS5uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG4gICAgbWFya3VwTm9kZS50YWdOYW1lID0gKG5hbWVzcGFjZVVSSSA9PT0gVi5uYW1lc3BhY2UueGh0bWwpXG4gICAgICAgIC8vIFhIVE1MIGRvY3VtZW50cyBtdXN0IHVzZSBsb3dlciBjYXNlIGZvciBhbGwgSFRNTCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMuXG4gICAgICAgIC8vIFRoZSB0YWdOYW1lIHByb3BlcnR5IHJldHVybnMgdXBwZXIgY2FzZSB2YWx1ZSBmb3IgSFRNTCBlbGVtZW50cy5cbiAgICAgICAgLy8gZS5nLiA8RElWPiB2cy48ZGl2Lz5cbiAgICAgICAgPyB0YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgOiB0YWdOYW1lO1xuXG4gICAgY29uc3Qgc3R5bGVzT2JqZWN0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IHN0eWxlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgbmFtZVN0cmluZyA9IHN0eWxlW2ldO1xuICAgICAgICBzdHlsZXNPYmplY3RbbmFtZVN0cmluZ10gPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWVTdHJpbmcpO1xuICAgIH1cbiAgICBtYXJrdXBOb2RlLnN0eWxlID0gc3R5bGVzT2JqZWN0O1xuXG4gICAgLy8gc2VsZWN0b3IgZmFsbGJhY2tzIHRvIHRhZ05hbWVcbiAgICBjb25zdCBzZWxlY3RvckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdAc2VsZWN0b3InKTtcbiAgICBpZiAoc2VsZWN0b3JBdHRyaWJ1dGUpIHtcbiAgICAgICAgbWFya3VwTm9kZS5zZWxlY3RvciA9IHNlbGVjdG9yQXR0cmlidXRlLnZhbHVlO1xuICAgICAgICBhdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbSgnQHNlbGVjdG9yJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXBTZWxlY3RvckF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdAZ3JvdXAtc2VsZWN0b3InKTtcbiAgICBpZiAoZ3JvdXBTZWxlY3RvckF0dHJpYnV0ZSkge1xuICAgICAgICBjb25zdCBncm91cFNlbGVjdG9ycyA9IGdyb3VwU2VsZWN0b3JBdHRyaWJ1dGUudmFsdWUuc3BsaXQoJywnKTtcbiAgICAgICAgbWFya3VwTm9kZS5ncm91cFNlbGVjdG9yID0gZ3JvdXBTZWxlY3RvcnMubWFwKHMgPT4gcy50cmltKCkpO1xuXG4gICAgICAgIGF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtKCdAZ3JvdXAtc2VsZWN0b3InKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbGFzc05hbWUgPSBhdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnY2xhc3MnKTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIG1hcmt1cE5vZGUuY2xhc3NOYW1lID0gY2xhc3NOYW1lLnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgY2hpbGROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTm9kZS5URVhUX05PREU6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVGV4dCA9IG5vZGUuZGF0YS5yZXBsYWNlKC9cXHNcXHMrL2csICcgJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyaW1tZWRUZXh0LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRyaW1tZWRUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOiB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWlsZE5vZGUobm9kZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbWFya3VwTm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVBdHRycyA9IHt9O1xuXG4gICAgQXJyYXkuZnJvbShhdHRyaWJ1dGVzKS5mb3JFYWNoKG5vZGVBdHRyaWJ1dGUgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHZhbHVlIH0gPSBub2RlQXR0cmlidXRlO1xuICAgICAgICBub2RlQXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhub2RlQXR0cnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbWFya3VwTm9kZS5hdHRyaWJ1dGVzID0gbm9kZUF0dHJzO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXBOb2RlO1xufVxuXG5mdW5jdGlvbiBidWlsZChyb290KSB7XG4gICAgY29uc3QgbWFya3VwID0gW107XG5cbiAgICBBcnJheS5mcm9tKHJvb3QuY2hpbGRyZW4pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIG1hcmt1cC5wdXNoKGJ1aWxkTm9kZShub2RlKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbWFya3VwO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/svgTagTemplate.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@joint/core/src/util/util.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addClassNamePrefix: function() { return /* binding */ addClassNamePrefix; },\n/* harmony export */   assign: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.assign; },\n/* harmony export */   bindAll: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.bindAll; },\n/* harmony export */   breakText: function() { return /* binding */ breakText; },\n/* harmony export */   camelCase: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.camelCase; },\n/* harmony export */   cancelFrame: function() { return /* binding */ cancelFrame; },\n/* harmony export */   cap: function() { return /* binding */ cap; },\n/* harmony export */   clone: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.clone; },\n/* harmony export */   cloneDeep: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.cloneDeep; },\n/* harmony export */   dataUriToBlob: function() { return /* binding */ dataUriToBlob; },\n/* harmony export */   debounce: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.debounce; },\n/* harmony export */   deepMixin: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.deepMixin; },\n/* harmony export */   deepSupplement: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.deepSupplement; },\n/* harmony export */   defaults: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.defaults; },\n/* harmony export */   defaultsDeep: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.defaultsDeep; },\n/* harmony export */   difference: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.difference; },\n/* harmony export */   downloadBlob: function() { return /* binding */ downloadBlob; },\n/* harmony export */   downloadDataUri: function() { return /* binding */ downloadDataUri; },\n/* harmony export */   filter: function() { return /* binding */ filter; },\n/* harmony export */   flattenDeep: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.flattenDeep; },\n/* harmony export */   flattenObject: function() { return /* binding */ flattenObject; },\n/* harmony export */   forIn: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.forIn; },\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   getByPath: function() { return /* binding */ getByPath; },\n/* harmony export */   getElementBBox: function() { return /* binding */ getElementBBox; },\n/* harmony export */   groupBy: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.groupBy; },\n/* harmony export */   guid: function() { return /* binding */ guid; },\n/* harmony export */   has: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.has; },\n/* harmony export */   hashCode: function() { return /* binding */ hashCode; },\n/* harmony export */   imageToDataUri: function() { return /* binding */ imageToDataUri; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   intersection: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.intersection; },\n/* harmony export */   invoke: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.invoke; },\n/* harmony export */   invokeProperty: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.invokeProperty; },\n/* harmony export */   isBoolean: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isBoolean; },\n/* harmony export */   isEmpty: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEmpty; },\n/* harmony export */   isEqual: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEqual; },\n/* harmony export */   isFunction: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction; },\n/* harmony export */   isNumber: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumber; },\n/* harmony export */   isObject: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject; },\n/* harmony export */   isPercentage: function() { return /* binding */ isPercentage; },\n/* harmony export */   isPlainObject: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isPlainObject; },\n/* harmony export */   isString: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString; },\n/* harmony export */   merge: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.merge; },\n/* harmony export */   mixin: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.mixin; },\n/* harmony export */   nextFrame: function() { return /* binding */ nextFrame; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   normalizeEvent: function() { return /* binding */ normalizeEvent; },\n/* harmony export */   normalizeSides: function() { return /* binding */ normalizeSides; },\n/* harmony export */   normalizeWheel: function() { return /* binding */ normalizeWheel; },\n/* harmony export */   objectDifference: function() { return /* binding */ objectDifference; },\n/* harmony export */   omit: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.omit; },\n/* harmony export */   parseCssNumeric: function() { return /* binding */ parseCssNumeric; },\n/* harmony export */   parseDOMJSON: function() { return /* binding */ parseDOMJSON; },\n/* harmony export */   pick: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.pick; },\n/* harmony export */   removeClassNamePrefix: function() { return /* binding */ removeClassNamePrefix; },\n/* harmony export */   result: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.result; },\n/* harmony export */   sanitizeHTML: function() { return /* binding */ sanitizeHTML; },\n/* harmony export */   setAttributesBySelector: function() { return /* binding */ setAttributesBySelector; },\n/* harmony export */   setByPath: function() { return /* binding */ setByPath; },\n/* harmony export */   sortBy: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortBy; },\n/* harmony export */   sortElements: function() { return /* binding */ sortElements; },\n/* harmony export */   sortedIndex: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.sortedIndex; },\n/* harmony export */   supplement: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.supplement; },\n/* harmony export */   template: function() { return /* binding */ template; },\n/* harmony export */   timing: function() { return /* binding */ timing; },\n/* harmony export */   toArray: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.toArray; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; },\n/* harmony export */   toggleFullScreen: function() { return /* binding */ toggleFullScreen; },\n/* harmony export */   union: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.union; },\n/* harmony export */   uniq: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uniq; },\n/* harmony export */   uniqueId: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.uniqueId; },\n/* harmony export */   unsetByPath: function() { return /* binding */ unsetByPath; },\n/* harmony export */   uuid: function() { return /* binding */ uuid; },\n/* harmony export */   without: function() { return /* reexport safe */ _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.without; }\n/* harmony export */ });\n/* harmony import */ var _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mvc/Dom/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/mvc/Dom/index.mjs\");\n/* harmony import */ var _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../V/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/V/index.mjs\");\n/* harmony import */ var _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/index.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/config/index.mjs\");\n/* harmony import */ var _utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utilHelpers.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\n\n\nconst addClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix.length) !== _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix) {\n            _className = _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix + _className;\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nconst removeClassNamePrefix = function(className) {\n\n    if (!className) return className;\n\n    return className.toString().split(' ').map(function(_className) {\n\n        if (_className.substr(0, _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix.length) === _config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix) {\n            _className = _className.substr(_config_index_mjs__WEBPACK_IMPORTED_MODULE_0__.config.classNamePrefix.length);\n        }\n\n        return _className;\n\n    }).join(' ');\n};\n\nconst parseDOMJSON = function(json, namespace) {\n\n    const selectors = {};\n    const groupSelectors = {};\n    const svgNamespace = _V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"].namespace.svg;\n\n    const initialNS = namespace || svgNamespace;\n    const fragment = document.createDocumentFragment();\n\n    const parseNode = function(siblingsDef, parentNode, parentNS) {\n        for (let i = 0; i < siblingsDef.length; i++) {\n            const nodeDef = siblingsDef[i];\n\n            // Text node\n            if (typeof nodeDef === 'string') {\n                const textNode = document.createTextNode(nodeDef);\n                parentNode.appendChild(textNode);\n                continue;\n            }\n\n            // TagName\n            if (!nodeDef.hasOwnProperty('tagName')) throw new Error('json-dom-parser: missing tagName');\n            const tagName = nodeDef.tagName;\n\n            let node;\n\n            // Namespace URI\n            const ns = (nodeDef.hasOwnProperty('namespaceURI')) ? nodeDef.namespaceURI : parentNS;\n            node = document.createElementNS(ns, tagName);\n            const svg = (ns === svgNamespace);\n\n            const wrapperNode = (svg) ? (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node) : (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node);\n            // Attributes\n            const attributes = nodeDef.attributes;\n            if (attributes) wrapperNode.attr(attributes);\n            // Style\n            const style = nodeDef.style;\n            if (style) (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node).css(style);\n            // ClassName\n            if (nodeDef.hasOwnProperty('className')) {\n                const className = nodeDef.className;\n                if (svg) {\n                    node.className.baseVal = className;\n                } else {\n                    node.className = className;\n                }\n            }\n            // TextContent\n            if (nodeDef.hasOwnProperty('textContent')) {\n                node.textContent = nodeDef.textContent;\n            }\n            // Selector\n            if (nodeDef.hasOwnProperty('selector')) {\n                const nodeSelector = nodeDef.selector;\n                if (selectors[nodeSelector]) throw new Error('json-dom-parser: selector must be unique');\n                selectors[nodeSelector] = node;\n                wrapperNode.attr('joint-selector', nodeSelector);\n            }\n            // Groups\n            if (nodeDef.hasOwnProperty('groupSelector')) {\n                let nodeGroups = nodeDef.groupSelector;\n                if (!Array.isArray(nodeGroups)) nodeGroups = [nodeGroups];\n                for (let j = 0; j < nodeGroups.length; j++) {\n                    const nodeGroup = nodeGroups[j];\n                    let group = groupSelectors[nodeGroup];\n                    if (!group) group = groupSelectors[nodeGroup] = [];\n                    group.push(node);\n                }\n            }\n\n            parentNode.appendChild(node);\n\n            // Children\n            const childrenDef = nodeDef.children;\n            if (Array.isArray(childrenDef)) {\n                parseNode(childrenDef, node, ns);\n            }\n        }\n    };\n    parseNode(json, fragment, initialNS);\n    return {\n        fragment: fragment,\n        selectors: selectors,\n        groupSelectors: groupSelectors\n    };\n};\n\n// Return a simple hash code from a string. See http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/.\nconst hashCode = function(str) {\n\n    let hash = 0;\n    if (str.length === 0) return hash;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        hash = ((hash << 5) - hash) + c;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash;\n};\n\nconst getByPath = function(obj, path, delimiter) {\n\n    var keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    var key;\n    var i = 0;\n    var length = keys.length;\n    while (i < length) {\n        key = keys[i++];\n        if (Object(obj) === obj && key in obj) {\n            obj = obj[key];\n        } else {\n            return undefined;\n        }\n    }\n    return obj;\n};\n\nconst isGetSafe = function(obj, key) {\n    // Prevent prototype pollution\n    // https://snyk.io/vuln/SNYK-JS-JSON8MERGEPATCH-1038399\n    if (typeof key !== 'string' && typeof key !== 'number') {\n        key = String(key);\n    }\n    if (key === 'constructor' && typeof obj[key] === 'function') {\n        return false;\n    }\n    if (key === '__proto__') {\n        return false;\n    }\n    return true;\n};\n\nconst setByPath = function(obj, path, value, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        // diver creates an empty object if there is no nested object under such a key.\n        // This means that one can populate an empty nested object with setByPath().\n        diver = value || (diver[key] = {});\n    }\n\n    diver[keys[last]] = value;\n\n    return obj;\n};\n\nconst unsetByPath = function(obj, path, delimiter) {\n\n    const keys = Array.isArray(path) ? path : path.split(delimiter || '/');\n    const last = keys.length - 1;\n    let diver = obj;\n    let i = 0;\n\n    for (; i < last; i++) {\n        const key = keys[i];\n        if (!isGetSafe(diver, key)) return obj;\n        const value = diver[key];\n        if (!value) return obj;\n        diver = value;\n    }\n\n    delete diver[keys[last]];\n\n    return obj;\n};\n\nconst flattenObject = function(obj, delim, stop) {\n\n    delim = delim || '/';\n    var ret = {};\n\n    for (var key in obj) {\n\n        if (!obj.hasOwnProperty(key)) continue;\n\n        var shouldGoDeeper = typeof obj[key] === 'object';\n        if (shouldGoDeeper && stop && stop(obj[key])) {\n            shouldGoDeeper = false;\n        }\n\n        if (shouldGoDeeper) {\n\n            var flatObject = flattenObject(obj[key], delim, stop);\n\n            for (var flatKey in flatObject) {\n                if (!flatObject.hasOwnProperty(flatKey)) continue;\n                ret[key + delim + flatKey] = flatObject[flatKey];\n            }\n\n        } else {\n\n            ret[key] = obj[key];\n        }\n    }\n\n    return ret;\n};\n\nconst uuid = function() {\n\n    // credit: http://stackoverflow.com/posts/2117523/revisions\n\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (Math.random() * 16) | 0;\n        var v = (c === 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n};\n\n// Generates global unique id and stores it as a property of the object, if provided.\nconst guid = function(obj) {\n\n    guid.id = guid.id || 1;\n\n    if (obj === undefined) {\n        return 'j_' + guid.id++;\n    }\n\n    obj.id = (obj.id === undefined ? 'j_' + guid.id++ : obj.id);\n    return obj.id;\n};\n\nconst toKebabCase = function(string) {\n\n    return string.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\nconst normalizeEvent = function(evt) {\n\n    if (evt.normalized) return evt;\n\n    const { originalEvent, target } = evt;\n\n    // If the event is a touch event, normalize it to a mouse event.\n    const touch = originalEvent && originalEvent.changedTouches && originalEvent.changedTouches[0];\n    if (touch) {\n        for (let property in touch) {\n            // copy all the properties from the first touch that are not\n            // defined on TouchEvent (clientX, clientY, pageX, pageY, screenX, screenY, identifier, ...)\n            if (evt[property] === undefined) {\n                evt[property] = touch[property];\n            }\n        }\n    }\n    // IE: evt.target could be set to SVGElementInstance for SVGUseElement\n    if (target) {\n        const useElement = target.correspondingUseElement;\n        if (useElement) evt.target = useElement;\n    }\n\n    evt.normalized = true;\n\n    return evt;\n};\n\nconst normalizeWheel = function(evt) {\n    // Sane values derived empirically\n    const PIXEL_STEP  = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n\n    let sX = 0, sY = 0, pX = 0, pY = 0;\n\n    // Legacy\n    if ('detail'      in evt) { sY = evt.detail; }\n    if ('wheelDelta'  in evt) { sY = -evt.wheelDelta / 120; }\n    if ('wheelDeltaY' in evt) { sY = -evt.wheelDeltaY / 120; }\n    if ('wheelDeltaX' in evt) { sX = -evt.wheelDeltaX / 120; }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ( 'axis' in evt && evt.axis === evt.HORIZONTAL_AXIS ) {\n        sX = sY;\n        sY = 0;\n    }\n\n    pX = 'deltaX' in evt ? evt.deltaX : sX * PIXEL_STEP;\n    pY = 'deltaY' in evt ? evt.deltaY : sY * PIXEL_STEP;\n\n    if ((pX || pY) && evt.deltaMode) {\n        if (evt.deltaMode == 1) {\n            pX *= LINE_HEIGHT;\n            pY *= LINE_HEIGHT;\n        } else {\n            pX *= PAGE_HEIGHT;\n            pY *= PAGE_HEIGHT;\n        }\n    }\n\n    // macOS switches deltaX and deltaY automatically when scrolling with shift key, so this is needed in other cases\n    if (evt.deltaX === 0 && evt.deltaY !== 0 && evt.shiftKey) {\n        pX = pY;\n        pY = 0;\n        sX = sY;\n        sY = 0;\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }\n    if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }\n\n    return {\n        spinX  : sX,\n        spinY  : sY,\n        deltaX : pX,\n        deltaY : pY,\n    };\n};\n\nconst cap = function(val, max) {\n    return val > max ? max : val < -max ? -max : val;\n};\n\nconst nextFrame = (function() {\n\n    var raf;\n\n    if (typeof window !== 'undefined') {\n\n        raf = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            window.mozRequestAnimationFrame ||\n            window.oRequestAnimationFrame ||\n            window.msRequestAnimationFrame;\n    }\n\n    if (!raf) {\n\n        var lastTime = 0;\n\n        raf = function(callback) {\n\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = setTimeout(function() {\n                callback(currTime + timeToCall);\n            }, timeToCall);\n\n            lastTime = currTime + timeToCall;\n\n            return id;\n        };\n    }\n\n    return function(callback, context, ...rest) {\n        return (context !== undefined)\n            ? raf(callback.bind(context, ...rest))\n            : raf(callback);\n    };\n\n})();\n\nconst cancelFrame = (function() {\n\n    var caf;\n    var client = typeof window != 'undefined';\n\n    if (client) {\n\n        caf = window.cancelAnimationFrame ||\n            window.webkitCancelAnimationFrame ||\n            window.webkitCancelRequestAnimationFrame ||\n            window.msCancelAnimationFrame ||\n            window.msCancelRequestAnimationFrame ||\n            window.oCancelAnimationFrame ||\n            window.oCancelRequestAnimationFrame ||\n            window.mozCancelAnimationFrame ||\n            window.mozCancelRequestAnimationFrame;\n    }\n\n    caf = caf || clearTimeout;\n\n    return client ? caf.bind(window) : caf;\n\n})();\n\nconst isPercentage = function(val) {\n\n    return (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString)(val) && val.slice(-1) === '%';\n};\n\nconst parseCssNumeric = function(val, restrictUnits) {\n\n    function getUnit(validUnitExp) {\n\n        // one or more numbers, followed by\n        // any number of (\n        //  `.`, followed by\n        //  one or more numbers\n        // ), followed by\n        // `validUnitExp`, followed by\n        // end of string\n        var matches = new RegExp('(?:\\\\d+(?:\\\\.\\\\d+)*)(' + validUnitExp + ')$').exec(val);\n\n        if (!matches) return null;\n        return matches[1];\n    }\n\n    var number = parseFloat(val);\n\n    // if `val` cannot be parsed as a number, return `null`\n    if (Number.isNaN(number)) return null;\n\n    // else: we know `output.value`\n    var output = {};\n    output.value = number;\n\n    // determine the unit\n    var validUnitExp;\n    if (restrictUnits == null) {\n        // no restriction\n        // accept any unit, as well as no unit\n        validUnitExp = '[A-Za-z]*';\n\n    } else if (Array.isArray(restrictUnits)) {\n        // if this is an empty array, top restriction - return `null`\n        if (restrictUnits.length === 0) return null;\n\n        // else: restriction - an array of valid unit strings\n        validUnitExp = restrictUnits.join('|');\n\n    } else if ((0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isString)(restrictUnits)) {\n        // restriction - a single valid unit string\n        validUnitExp = restrictUnits;\n    }\n    var unit = getUnit(validUnitExp);\n\n    // if we found no matches for `restrictUnits`, return `null`\n    if (unit === null) return null;\n\n    // else: we know the unit\n    output.unit = unit;\n    return output;\n};\n\nconst NO_SPACE = 0;\n\nfunction splitWordWithEOL(word, eol) {\n    const eolWords = word.split(eol);\n    let n = 1;\n    for (let j = 0, jl = eolWords.length - 1; j < jl; j++) {\n        const replacement = [];\n        if (j > 0 || eolWords[0] !== '') replacement.push(NO_SPACE);\n        replacement.push(eol);\n        if (j < jl - 1 || eolWords[jl] !== '') replacement.push(NO_SPACE);\n        eolWords.splice(n, 0, ...replacement);\n        n += replacement.length + 1;\n    }\n    return eolWords.filter(word => word !== '');\n}\n\n\nfunction getLineHeight(heightValue, textElement) {\n    if (heightValue === null) {\n        // Default 1em lineHeight\n        return textElement.getBBox().height;\n    }\n\n    switch (heightValue.unit) {\n        case 'em':\n            return textElement.getBBox().height * heightValue.value;\n        case 'px':\n        case '':\n            return heightValue.value;\n    }\n}\n\nconst breakText = function(text, size, styles = {}, opt = {}) {\n\n    var width = size.width;\n    var height = size.height;\n\n    var svgDocument = opt.svgDocument || (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('svg').node;\n    var textSpan = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('tspan').node;\n    var textElement = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])('text').attr(styles).append(textSpan).node;\n    var textNode = document.createTextNode('');\n\n    // Prevent flickering\n    textElement.style.opacity = 0;\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    textElement.style.display = 'block';\n    textSpan.style.display = 'block';\n\n    textSpan.appendChild(textNode);\n    svgDocument.appendChild(textElement); // lgtm [js/xss-through-dom]\n\n    if (!opt.svgDocument) {\n\n        document.body.appendChild(svgDocument);\n    }\n\n    const preserveSpaces = opt.preserveSpaces;\n    const space = ' ';\n    const separator = (opt.separator || opt.separator === '') ? opt.separator : space;\n    // If separator is a RegExp, we use the space character to join words together again (not ideal)\n    const separatorChar = (typeof separator === 'string') ? separator : space;\n    var eol = opt.eol || '\\n';\n    var hyphen = opt.hyphen ? new RegExp(opt.hyphen) : /[^\\w\\d\\u00C0-\\u1FFF\\u2800-\\uFFFD]/;\n    var maxLineCount = opt.maxLineCount;\n    if (!(0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isNumber)(maxLineCount)) maxLineCount = Infinity;\n\n    var words = text.split(separator);\n    var full = [];\n    var lines = [];\n    var p, h;\n    var lineHeight;\n\n    if (preserveSpaces) {\n        (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(textSpan).attr('xml:space', 'preserve');\n    }\n\n    for (var i = 0, l = 0, len = words.length; i < len; i++) {\n\n        var word = words[i];\n\n        if (!word && !preserveSpaces) continue;\n        if (typeof word !== 'string') continue;\n\n        var isEol = false;\n        if (eol && word.indexOf(eol) >= 0) {\n            // word contains end-of-line character\n            if (word.length > 1) {\n                // separate word and continue cycle\n                const eolWords = splitWordWithEOL(words[i], eol);\n                words.splice(i, 1, ...eolWords);\n                i--;\n                len = words.length;\n                continue;\n            } else {\n                // creates a new line\n                if (preserveSpaces && typeof words[i - 1] === 'string' ) {\n                    words.splice(i, NO_SPACE, '', NO_SPACE);\n                    len += 2;\n                    i--;\n                    continue;\n                }\n                lines[++l] = (!preserveSpaces || typeof words[i + 1] === 'string') ? '' : undefined;\n                isEol = true;\n            }\n        }\n\n        if (!isEol) {\n\n            let data;\n            if (preserveSpaces) {\n                data = lines[l] !== undefined ? lines[l] + separatorChar + word : word;\n            } else {\n                data = lines[l] ? lines[l] + separatorChar + word : word;\n            }\n\n            textNode.data = data;\n\n            if (textSpan.getComputedTextLength() <= width) {\n\n                // the current line fits\n                lines[l] = data;\n\n                if (p || h) {\n                    // We were partitioning. Put rest of the word onto next line\n                    full[l++] = true;\n\n                    // cancel partitioning and splitting by hyphens\n                    p = 0;\n                    h = 0;\n                }\n\n            } else {\n\n                if (!lines[l] || p) {\n\n                    var partition = !!p;\n\n                    p = word.length - 1;\n\n                    if (partition || !p) {\n\n                        // word has only one character.\n                        if (!p) {\n\n                            if (!lines[l]) {\n\n                                // we won't fit this text within our rect\n                                lines = [];\n\n                                break;\n                            }\n\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n\n                            // cancel partitions created\n                            words.splice(i, 2, word + words[i + 1]);\n\n                            // adjust word length\n                            len--;\n\n                            full[l++] = true;\n                            i--;\n\n                            continue;\n                        }\n\n                        // move last letter to the beginning of the next word\n                        words[i] = word.substring(0, p);\n                        const nextWord = words[i + 1];\n                        words[i + 1] = word.substring(p) + (nextWord === undefined || nextWord === NO_SPACE ? '' : nextWord);\n\n                    } else {\n\n                        if (h) {\n                        // cancel splitting and put the words together again\n                            words.splice(i, 2, words[i] + words[i + 1]);\n                            h = 0;\n                        } else {\n                            var hyphenIndex = word.search(hyphen);\n                            if (hyphenIndex > -1 && hyphenIndex !== word.length - 1 && hyphenIndex !== 0) {\n                                h = hyphenIndex + 1;\n                                p = 0;\n                            }\n\n                            // We initiate partitioning or splitting\n                            // split the long word into two words\n                            words.splice(i, 1, word.substring(0, h || p), word.substring(h|| p));\n                            // adjust words length\n                            len++;\n\n                        }\n\n                        if (l && !full[l - 1]) {\n                        // if the previous line is not full, try to fit max part of\n                        // the current word there\n                            l--;\n                        }\n                    }\n\n                    if (!preserveSpaces || lines[l] !== '') {\n                        i--;\n                    }\n\n                    continue;\n                }\n\n                l++;\n                i--;\n            }\n        }\n        var lastL = null;\n\n        if (lines.length > maxLineCount) {\n\n            lastL = maxLineCount - 1;\n\n        } else if (height !== undefined) {\n\n            // if size.height is defined we have to check whether the height of the entire\n            // text exceeds the rect height\n\n            if (lineHeight === undefined && textNode.data !== '') {\n\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === 'auto') {\n                    lineHeight = getLineHeight({ value: 1.5, unit: 'em' }, textElement);\n                } else {\n                    const parsed = parseCssNumeric(styles.lineHeight, ['em', 'px', '']);\n\n                    lineHeight = getLineHeight(parsed, textElement);\n                }\n            }\n\n            if (lineHeight * lines.length > height) {\n                // remove overflowing lines\n                lastL = Math.floor(height / lineHeight) - 1;\n            }\n        }\n\n        if (lastL !== null) {\n\n            lines.splice(lastL + 1);\n\n            // add ellipsis\n            var ellipsis = opt.ellipsis;\n            if (!ellipsis || lastL < 0) break;\n            if (typeof ellipsis !== 'string') ellipsis = '\\u2026';\n\n            var lastLine = lines[lastL];\n            if (!lastLine && !isEol) break;\n            var k = lastLine.length;\n            var lastLineWithOmission, lastChar;\n            do {\n                lastChar = lastLine[k];\n                lastLineWithOmission = lastLine.substring(0, k);\n                if (!lastChar) {\n                    lastLineWithOmission += separatorChar;\n                } else if (lastChar.match(separator)) {\n                    lastLineWithOmission += lastChar;\n                }\n                lastLineWithOmission += ellipsis;\n                textNode.data = lastLineWithOmission;\n                if (textSpan.getComputedTextLength() <= width) {\n                    lines[lastL] = lastLineWithOmission;\n                    break;\n                }\n                k--;\n            } while (k >= 0);\n            break;\n        }\n    }\n\n    if (opt.svgDocument) {\n\n        // svg document was provided, remove the text element only\n        svgDocument.removeChild(textElement);\n\n    } else {\n\n        // clean svg document\n        document.body.removeChild(svgDocument);\n    }\n\n    return lines.join(eol);\n};\n\n// Sanitize HTML\n// Based on https://gist.github.com/ufologist/5a0da51b2b9ef1b861c30254172ac3c9\n// Parses a string into an array of DOM nodes.\n// Then outputs it back as a string.\nconst sanitizeHTML = function(html) {\n\n    // Ignores tags that are invalid inside a <div> tag (e.g. <body>, <head>)\n    const [outputEl] = _mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"].parseHTML('<div>' + html + '</div>');\n\n    Array.from(outputEl.getElementsByTagName('*')).forEach(function(node) { // for all nodes\n        const names = node.getAttributeNames();\n        names.forEach(function(name) {\n            const value = node.getAttribute(name);\n            // Remove attribute names that start with \"on\" (e.g. onload, onerror...).\n            // Remove attribute values that start with \"javascript:\" pseudo protocol (e.g. `href=\"javascript:alert(1)\"`).\n            if (name.startsWith('on') || value.startsWith('javascript:' || 0 || 0)) {\n                node.removeAttribute(name);\n            }\n        });\n    });\n\n    return outputEl.innerHTML;\n};\n\n// Download `blob` as file with `fileName`.\n// Does not work in IE9.\nconst downloadBlob = function(blob, fileName) {\n\n    if (window.navigator.msSaveBlob) { // requires IE 10+\n        // pulls up a save dialog\n        window.navigator.msSaveBlob(blob, fileName);\n\n    } else { // other browsers\n        // downloads directly in Chrome and Safari\n\n        // presents a save/open dialog in Firefox\n        // Firefox bug: `from` field in save dialog always shows `from:blob:`\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement('a');\n\n        link.href = url;\n        link.download = fileName;\n        document.body.appendChild(link);\n\n        link.click();\n\n        document.body.removeChild(link);\n        window.URL.revokeObjectURL(url); // mark the url for garbage collection\n    }\n};\n\n// Download `dataUri` as file with `fileName`.\n// Does not work in IE9.\nconst downloadDataUri = function(dataUri, fileName) {\n\n    const blob = dataUriToBlob(dataUri);\n    downloadBlob(blob, fileName);\n};\n\n// Convert an uri-encoded data component (possibly also base64-encoded) to a blob.\nconst dataUriToBlob = function(dataUri) {\n\n    // first, make sure there are no newlines in the data uri\n    dataUri = dataUri.replace(/\\s/g, '');\n    dataUri = decodeURIComponent(dataUri);\n\n    var firstCommaIndex = dataUri.indexOf(','); // split dataUri as `dataTypeString`,`data`\n\n    var dataTypeString = dataUri.slice(0, firstCommaIndex); // e.g. 'data:image/jpeg;base64'\n    var mimeString = dataTypeString.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n    var data = dataUri.slice(firstCommaIndex + 1);\n    var decodedString;\n    if (dataTypeString.indexOf('base64') >= 0) { // data may be encoded in base64\n        decodedString = atob(data); // decode data\n    } else {\n        // convert the decoded string to UTF-8\n        decodedString = unescape(encodeURIComponent(data));\n    }\n    // write the bytes of the string to a typed array\n    var ia = new Uint8Array(decodedString.length);\n    for (var i = 0; i < decodedString.length; i++) {\n        ia[i] = decodedString.charCodeAt(i);\n    }\n\n    return new Blob([ia], { type: mimeString }); // return the typed array as Blob\n};\n\n// Read an image at `url` and return it as base64-encoded data uri.\n// The mime type of the image is inferred from the `url` file extension.\n// If data uri is provided as `url`, it is returned back unchanged.\n// `callback` is a method with `err` as first argument and `dataUri` as second argument.\n// Works with IE9.\nconst imageToDataUri = function(url, callback) {\n\n    if (!url || url.substr(0, 'data:'.length) === 'data:') {\n        // No need to convert to data uri if it is already in data uri.\n\n        // This not only convenient but desired. For example,\n        // IE throws a security error if data:image/svg+xml is used to render\n        // an image to the canvas and an attempt is made to read out data uri.\n        // Now if our image is already in data uri, there is no need to render it to the canvas\n        // and so we can bypass this error.\n\n        // Keep the async nature of the function.\n        return setTimeout(function() {\n            callback(null, url);\n        }, 0);\n    }\n\n    // chrome, IE10+\n    var modernHandler = function(xhr, callback) {\n\n        if (xhr.status === 200) {\n\n            var reader = new FileReader();\n\n            reader.onload = function(evt) {\n                var dataUri = evt.target.result;\n                callback(null, dataUri);\n            };\n\n            reader.onerror = function() {\n                callback(new Error('Failed to load image ' + url));\n            };\n\n            reader.readAsDataURL(xhr.response);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var legacyHandler = function(xhr, callback) {\n\n        var Uint8ToString = function(u8a) {\n            var CHUNK_SZ = 0x8000;\n            var c = [];\n            for (var i = 0; i < u8a.length; i += CHUNK_SZ) {\n                c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n            }\n            return c.join('');\n        };\n\n        if (xhr.status === 200) {\n\n            var bytes = new Uint8Array(xhr.response);\n\n            var suffix = (url.split('.').pop()) || 'png';\n            var map = {\n                'svg': 'svg+xml'\n            };\n            var meta = 'data:image/' + (map[suffix] || suffix) + ';base64,';\n            var b64encoded = meta + btoa(Uint8ToString(bytes));\n            callback(null, b64encoded);\n        } else {\n            callback(new Error('Failed to load image ' + url));\n        }\n    };\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', function() {\n        callback(new Error('Failed to load image ' + url));\n    });\n\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n\n    xhr.addEventListener('load', function() {\n        if (window.FileReader) {\n            modernHandler(xhr, callback);\n        } else {\n            legacyHandler(xhr, callback);\n        }\n    });\n\n    xhr.send();\n};\n\nconst getElementBBox = function(el) {\n\n    var $el = (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(el);\n    if ($el.length === 0) {\n        throw new Error('Element not found');\n    }\n\n    var element = $el[0];\n    var doc = element.ownerDocument;\n    var clientBBox = element.getBoundingClientRect();\n\n    var strokeWidthX = 0;\n    var strokeWidthY = 0;\n\n    // Firefox correction\n    if (element.ownerSVGElement) {\n\n        var vel = (0,_V_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n        var bbox = vel.getBBox({ target: vel.svg() });\n\n        // if FF getBoundingClientRect includes stroke-width, getBBox doesn't.\n        // To unify this across all browsers we need to adjust the final bBox with `stroke-width` value.\n        strokeWidthX = (clientBBox.width - bbox.width);\n        strokeWidthY = (clientBBox.height - bbox.height);\n    }\n\n    return {\n        x: clientBBox.left + window.pageXOffset - doc.documentElement.offsetLeft + strokeWidthX / 2,\n        y: clientBBox.top + window.pageYOffset - doc.documentElement.offsetTop + strokeWidthY / 2,\n        width: clientBBox.width - strokeWidthX,\n        height: clientBBox.height - strokeWidthY\n    };\n};\n\n\n// Highly inspired by the jquery.sortElements plugin by Padolsey.\n// See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\nconst sortElements = function(elements, comparator) {\n\n    elements = (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(elements).toArray();\n    var placements = elements.map(function(sortElement) {\n\n        var parentNode = sortElement.parentNode;\n        // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);\n\n        return function() {\n\n            if (parentNode === this) {\n                throw new Error('You can\\'t sort elements if any one is a descendant of another.');\n            }\n\n            // Insert before flag:\n            parentNode.insertBefore(this, nextSibling);\n            // Remove flag:\n            parentNode.removeChild(nextSibling);\n        };\n    });\n\n    elements.sort(comparator);\n    for (var i = 0; i < placements.length; i++) {\n        placements[i].call(elements[i]);\n    }\n    return elements;\n};\n\n// Sets attributes on the given element and its descendants based on the selector.\n// `attrs` object: { [SELECTOR1]: { attrs1 }, [SELECTOR2]: { attrs2}, ... } e.g. { 'input': { color : 'red' }}\nconst setAttributesBySelector = function(element, attrs) {\n\n    var $element = (0,_mvc_Dom_index_mjs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element);\n\n    (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.forIn)(attrs, function(attrs, selector) {\n        var $elements = $element.find(selector).addBack().filter(selector);\n        // Make a special case for setting classes.\n        // We do not want to overwrite any existing class.\n        if ((0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.has)(attrs, 'class')) {\n            $elements.addClass(attrs['class']);\n            attrs = (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.omit)(attrs, 'class');\n        }\n        $elements.attr(attrs);\n    });\n};\n\n// Return a new object with all four sides (top, right, bottom, left) in it.\n// Value of each side is taken from the given argument (either number or object).\n// Default value for a side is 0.\n// Examples:\n// normalizeSides(5) --> { top: 5, right: 5, bottom: 5, left: 5 }\n// normalizeSides({ horizontal: 5 }) --> { top: 0, right: 5, bottom: 0, left: 5 }\n// normalizeSides({ left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 10, left: 5 }) --> { top: 0, right: 10, bottom: 0, left: 5 }\n// normalizeSides({ horizontal: 0, left: 5 }) --> { top: 0, right: 0, bottom: 0, left: 5 }\nconst normalizeSides = function(box) {\n\n    if (Object(box) !== box) { // `box` is not an object\n        var val = 0; // `val` left as 0 if `box` cannot be understood as finite number\n        if (isFinite(box)) val = +box; // actually also accepts string numbers (e.g. '100')\n\n        return { top: val, right: val, bottom: val, left: val };\n    }\n\n    // `box` is an object\n    var top, right, bottom, left;\n    top = right = bottom = left = 0;\n\n    if (isFinite(box.vertical)) top = bottom = +box.vertical;\n    if (isFinite(box.horizontal)) right = left = +box.horizontal;\n\n    if (isFinite(box.top)) top = +box.top; // overwrite vertical\n    if (isFinite(box.right)) right = +box.right; // overwrite horizontal\n    if (isFinite(box.bottom)) bottom = +box.bottom; // overwrite vertical\n    if (isFinite(box.left)) left = +box.left; // overwrite horizontal\n\n    return { top: top, right: right, bottom: bottom, left: left };\n};\n\nconst timing = {\n\n    linear: function(t) {\n        return t;\n    },\n\n    quad: function(t) {\n        return t * t;\n    },\n\n    cubic: function(t) {\n        return t * t * t;\n    },\n\n    inout: function(t) {\n        if (t <= 0) return 0;\n        if (t >= 1) return 1;\n        var t2 = t * t;\n        var t3 = t2 * t;\n        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n    },\n\n    exponential: function(t) {\n        return Math.pow(2, 10 * (t - 1));\n    },\n\n    bounce: function(t) {\n        for (var a = 0, b = 1; 1; a += b, b /= 2) {\n            if (t >= (7 - 4 * a) / 11) {\n                var q = (11 - 6 * a - 11 * t) / 4;\n                return -q * q + b * b;\n            }\n        }\n    },\n\n    reverse: function(f) {\n        return function(t) {\n            return 1 - f(1 - t);\n        };\n    },\n\n    reflect: function(f) {\n        return function(t) {\n            return .5 * (t < .5 ? f(2 * t) : (2 - f(2 - 2 * t)));\n        };\n    },\n\n    clamp: function(f, n, x) {\n        n = n || 0;\n        x = x || 1;\n        return function(t) {\n            var r = f(t);\n            return r < n ? n : r > x ? x : r;\n        };\n    },\n\n    back: function(s) {\n        if (!s) s = 1.70158;\n        return function(t) {\n            return t * t * ((s + 1) * t - s);\n        };\n    },\n\n    elastic: function(x) {\n        if (!x) x = 1.5;\n        return function(t) {\n            return Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * x / 3 * t);\n        };\n    }\n};\n\nconst interpolate = {\n\n    number: function(a, b) {\n        var d = b - a;\n        return function(t) {\n            return a + d * t;\n        };\n    },\n\n    object: function(a, b) {\n        var s = Object.keys(a);\n        return function(t) {\n            var i, p;\n            var r = {};\n            for (i = s.length - 1; i != -1; i--) {\n                p = s[i];\n                r[p] = a[p] + (b[p] - a[p]) * t;\n            }\n            return r;\n        };\n    },\n\n    hexColor: function(a, b) {\n\n        var ca = parseInt(a.slice(1), 16);\n        var cb = parseInt(b.slice(1), 16);\n        var ra = ca & 0x0000ff;\n        var rd = (cb & 0x0000ff) - ra;\n        var ga = ca & 0x00ff00;\n        var gd = (cb & 0x00ff00) - ga;\n        var ba = ca & 0xff0000;\n        var bd = (cb & 0xff0000) - ba;\n\n        return function(t) {\n\n            var r = (ra + rd * t) & 0x000000ff;\n            var g = (ga + gd * t) & 0x0000ff00;\n            var b = (ba + bd * t) & 0x00ff0000;\n\n            return '#' + (1 << 24 | r | g | b).toString(16).slice(1);\n        };\n    },\n\n    unit: function(a, b) {\n\n        var r = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/;\n        var ma = r.exec(a);\n        var mb = r.exec(b);\n        var p = mb[1].indexOf('.');\n        var f = p > 0 ? mb[1].length - p - 1 : 0;\n        a = +ma[1];\n        var d = +mb[1] - a;\n        var u = ma[2];\n\n        return function(t) {\n            return (a + d * t).toFixed(f) + u;\n        };\n    }\n};\n\n// SVG filters.\n// (values in parentheses are default values)\nconst filter = {\n\n    // `color` ... outline color ('blue')\n    // `width`... outline width (1)\n    // `opacity` ... outline opacity (1)\n    // `margin` ... gap between outline and the element (2)\n    outline: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology in=\"SourceAlpha\" result=\"morphedOuter\" operator=\"dilate\" radius=\"${outerRadius}\" /><feMorphology in=\"SourceAlpha\" result=\"morphedInner\" operator=\"dilate\" radius=\"${innerRadius}\" /><feComposite result=\"morphedOuterColored\" in=\"colored\" in2=\"morphedOuter\" operator=\"in\"/><feComposite operator=\"xor\" in=\"morphedOuterColored\" in2=\"morphedInner\" result=\"outline\"/><feMerge><feMergeNode in=\"outline\"/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        var margin = Number.isFinite(args.margin) ? args.margin : 2;\n        var width = Number.isFinite(args.width) ? args.width : 1;\n\n        return template(tpl)({\n            color: args.color || 'blue',\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            outerRadius: margin + width,\n            innerRadius: margin\n        });\n    },\n\n    // `color` ... color ('red')\n    // `width`... width (1)\n    // `blur` ... blur (0)\n    // `opacity` ... opacity (1)\n    highlight: function(args) {\n\n        var tpl = '<filter><feFlood flood-color=\"${color}\" flood-opacity=\"${opacity}\" result=\"colored\"/><feMorphology result=\"morphed\" in=\"SourceGraphic\" operator=\"dilate\" radius=\"${width}\"/><feComposite result=\"composed\" in=\"colored\" in2=\"morphed\" operator=\"in\"/><feGaussianBlur result=\"blured\" in=\"composed\" stdDeviation=\"${blur}\"/><feBlend in=\"SourceGraphic\" in2=\"blured\" mode=\"normal\"/></filter>';\n\n        return template(tpl)({\n            color: args.color || 'red',\n            width: Number.isFinite(args.width) ? args.width : 1,\n            blur: Number.isFinite(args.blur) ? args.blur : 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1\n        });\n    },\n\n    // `x` ... horizontal blur (2)\n    // `y` ... vertical blur (optional)\n    blur: function(args) {\n\n        var x = Number.isFinite(args.x) ? args.x : 2;\n\n        return template('<filter><feGaussianBlur stdDeviation=\"${stdDeviation}\"/></filter>')({\n            stdDeviation: Number.isFinite(args.y) ? [x, args.y] : x\n        });\n    },\n\n    // `dx` ... horizontal shift (0)\n    // `dy` ... vertical shift (0)\n    // `blur` ... blur (4)\n    // `color` ... color ('black')\n    // `opacity` ... opacity (1)\n    dropShadow: function(args) {\n\n        var tpl = 'SVGFEDropShadowElement' in window\n            ? '<filter><feDropShadow stdDeviation=\"${blur}\" dx=\"${dx}\" dy=\"${dy}\" flood-color=\"${color}\" flood-opacity=\"${opacity}\"/></filter>'\n            : '<filter><feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"${blur}\"/><feOffset dx=\"${dx}\" dy=\"${dy}\" result=\"offsetblur\"/><feFlood flood-color=\"${color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"${opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge></filter>';\n\n        return template(tpl)({\n            dx: args.dx || 0,\n            dy: args.dy || 0,\n            opacity: Number.isFinite(args.opacity) ? args.opacity : 1,\n            color: args.color || 'black',\n            blur: Number.isFinite(args.blur) ? args.blur : 4\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely grayscale. A value of 0 leaves the input unchanged.\n    grayscale: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${b} ${h} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely sepia. A value of 0 leaves the input unchanged.\n    sepia: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"matrix\" values=\"${a} ${b} ${c} 0 0 ${d} ${e} ${f} 0 0 ${g} ${h} ${i} 0 0 0 0 0 1 0\"/></filter>')({\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 0 is completely un-saturated. A value of 1 (default) leaves the input unchanged.\n    saturate: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feColorMatrix type=\"saturate\" values=\"${amount}\"/></filter>')({\n            amount: 1 - amount\n        });\n    },\n\n    // `angle` ...  the number of degrees around the color circle the input samples will be adjusted (0).\n    hueRotate: function(args) {\n\n        return template('<filter><feColorMatrix type=\"hueRotate\" values=\"${angle}\"/></filter>')({\n            angle: args.angle || 0\n        });\n    },\n\n    // `amount` ... the proportion of the conversion (1). A value of 1 (default) is completely inverted. A value of 0 leaves the input unchanged.\n    invert: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncG type=\"table\" tableValues=\"${amount} ${amount2}\"/><feFuncB type=\"table\" tableValues=\"${amount} ${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: 1 - amount\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    brightness: function(args) {\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\"/><feFuncG type=\"linear\" slope=\"${amount}\"/><feFuncB type=\"linear\" slope=\"${amount}\"/></feComponentTransfer></filter>')({\n            amount: Number.isFinite(args.amount) ? args.amount : 1\n        });\n    },\n\n    // `amount` ... proportion of the conversion (1). A value of 0 will create an image that is completely black. A value of 1 (default) leaves the input unchanged.\n    contrast: function(args) {\n\n        var amount = Number.isFinite(args.amount) ? args.amount : 1;\n\n        return template('<filter><feComponentTransfer><feFuncR type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncG type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/><feFuncB type=\"linear\" slope=\"${amount}\" intercept=\"${amount2}\"/></feComponentTransfer></filter>')({\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    }\n};\n\nconst format = {\n\n    // Formatting numbers via the Python Format Specification Mini-language.\n    // See http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n    // Heavilly inspired by the D3.js library implementation.\n    number: function(specifier, value, locale) {\n\n        locale = locale || {\n\n            currency: ['$', ''],\n            decimal: '.',\n            thousands: ',',\n            grouping: [3]\n        };\n\n        // See Python format specification mini-language: http://docs.python.org/release/3.1.3/library/string.html#format-specification-mini-language.\n        // [[fill]align][sign][symbol][0][width][,][.precision][type]\n        var re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n\n        var match = re.exec(specifier);\n        var fill = match[1] || ' ';\n        var align = match[2] || '>';\n        var sign = match[3] || '';\n        var symbol = match[4] || '';\n        var zfill = match[5];\n        var width = +match[6];\n        var comma = match[7];\n        var precision = match[8];\n        var type = match[9];\n        var scale = 1;\n        var prefix = '';\n        var suffix = '';\n        var integer = false;\n\n        if (precision) precision = +precision.substring(1);\n\n        if (zfill || fill === '0' && align === '=') {\n            zfill = fill = '0';\n            align = '=';\n            if (comma) width -= Math.floor((width - 1) / 4);\n        }\n\n        switch (type) {\n            case 'n':\n                comma = true;\n                type = 'g';\n                break;\n            case '%':\n                scale = 100;\n                suffix = '%';\n                type = 'f';\n                break;\n            case 'p':\n                scale = 100;\n                suffix = '%';\n                type = 'r';\n                break;\n            case 'b':\n            case 'o':\n            case 'x':\n            case 'X':\n                if (symbol === '#') prefix = '0' + type.toLowerCase();\n                break;\n            case 'c':\n            case 'd':\n                integer = true;\n                precision = 0;\n                break;\n            case 's':\n                scale = -1;\n                type = 'r';\n                break;\n        }\n\n        if (symbol === '$') {\n            prefix = locale.currency[0];\n            suffix = locale.currency[1];\n        }\n\n        // If no precision is specified for `'r'`, fallback to general notation.\n        if (type == 'r' && !precision) type = 'g';\n\n        // Ensure that the requested precision is in the supported range.\n        if (precision != null) {\n            if (type == 'g') precision = Math.max(1, Math.min(21, precision));\n            else if (type == 'e' || type == 'f') precision = Math.max(0, Math.min(20, precision));\n        }\n\n        var zcomma = zfill && comma;\n\n        // Return the empty string for floats formatted as ints.\n        if (integer && (value % 1)) return '';\n\n        // Convert negative to positive, and record the sign prefix.\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign;\n\n        var fullSuffix = suffix;\n\n        // Apply the scale, computing it from the value's exponent for si format.\n        // Preserve the existing suffix, if any, such as the currency symbol.\n        if (scale < 0) {\n            var unit = this.prefix(value, precision);\n            value = unit.scale(value);\n            fullSuffix = unit.symbol + suffix;\n        } else {\n            value *= scale;\n        }\n\n        // Convert to the desired precision.\n        value = this.convert(type, value, precision);\n\n        // Break the value into the integer part (before) and decimal part (after).\n        var i = value.lastIndexOf('.');\n        var before = i < 0 ? value : value.substring(0, i);\n        var after = i < 0 ? '' : locale.decimal + value.substring(i + 1);\n\n        function formatGroup(value) {\n\n            var i = value.length;\n            var t = [];\n            var j = 0;\n            var g = locale.grouping[0];\n            while (i > 0 && g > 0) {\n                t.push(value.substring(i -= g, i + g));\n                g = locale.grouping[j = (j + 1) % locale.grouping.length];\n            }\n            return t.reverse().join(locale.thousands);\n        }\n\n        // If the fill character is not `'0'`, grouping is applied before padding.\n        if (!zfill && comma && locale.grouping) {\n\n            before = formatGroup(before);\n        }\n\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length);\n        var padding = length < width ? new Array(length = width - length + 1).join(fill) : '';\n\n        // If the fill character is `'0'`, grouping is applied after padding.\n        if (zcomma) before = formatGroup(padding + before);\n\n        // Apply prefix.\n        negative += prefix;\n\n        // Rejoin integer and decimal parts.\n        value = before + after;\n\n        return (align === '<' ? negative + value + padding\n            : align === '>' ? padding + negative + value\n                : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length)\n                    : negative + (zcomma ? value : padding + value)) + fullSuffix;\n    },\n\n    // Formatting string via the Python Format string.\n    // See https://docs.python.org/2/library/string.html#format-string-syntax)\n    string: function(formatString, value) {\n\n        var fieldDelimiterIndex;\n        var fieldDelimiter = '{';\n        var endPlaceholder = false;\n        var formattedStringArray = [];\n\n        while ((fieldDelimiterIndex = formatString.indexOf(fieldDelimiter)) !== -1) {\n\n            var pieceFormattedString, formatSpec, fieldName;\n\n            pieceFormattedString = formatString.slice(0, fieldDelimiterIndex);\n\n            if (endPlaceholder) {\n                formatSpec = pieceFormattedString.split(':');\n                fieldName = formatSpec.shift().split('.');\n                pieceFormattedString = value;\n\n                for (var i = 0; i < fieldName.length; i++)\n                    pieceFormattedString = pieceFormattedString[fieldName[i]];\n\n                if (formatSpec.length)\n                    pieceFormattedString = this.number(formatSpec, pieceFormattedString);\n            }\n\n            formattedStringArray.push(pieceFormattedString);\n\n            formatString = formatString.slice(fieldDelimiterIndex + 1);\n            endPlaceholder = !endPlaceholder;\n            fieldDelimiter = (endPlaceholder) ? '}' : '{';\n        }\n        formattedStringArray.push(formatString);\n\n        return formattedStringArray.join('');\n    },\n\n    convert: function(type, value, precision) {\n\n        switch (type) {\n            case 'b':\n                return value.toString(2);\n            case 'c':\n                return String.fromCharCode(value);\n            case 'o':\n                return value.toString(8);\n            case 'x':\n                return value.toString(16);\n            case 'X':\n                return value.toString(16).toUpperCase();\n            case 'g':\n                return value.toPrecision(precision);\n            case 'e':\n                return value.toExponential(precision);\n            case 'f':\n                return value.toFixed(precision);\n            case 'r':\n                return (value = this.round(value, this.precision(value, precision))).toFixed(Math.max(0, Math.min(20, this.precision(value * (1 + 1e-15), precision))));\n            default:\n                return value + '';\n        }\n    },\n\n    round: function(value, precision) {\n\n        return precision\n            ? Math.round(value * (precision = Math.pow(10, precision))) / precision\n            : Math.round(value);\n    },\n\n    precision: function(value, precision) {\n\n        return precision - (value ? Math.ceil(Math.log(value) / Math.LN10) : 1);\n    },\n\n    prefix: function(value, precision) {\n\n        var prefixes = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].map(function(d, i) {\n            var k = Math.pow(10, Math.abs(8 - i) * 3);\n            return {\n                scale: i > 8 ? function(d) {\n                    return d / k;\n                } : function(d) {\n                    return d * k;\n                },\n                symbol: d\n            };\n        });\n\n        var i = 0;\n        if (value) {\n            if (value < 0) value *= -1;\n            if (precision) value = this.round(value, this.precision(value, precision));\n            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n            i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n        }\n        return prefixes[8 + i / 3];\n    }\n};\n\n/*\n    Pre-compile the HTML to be used as a template.\n*/\nconst template = function(html) {\n\n    /*\n        Must support the variation in templating syntax found here:\n        https://lodash.com/docs#template\n    */\n    var regex = /<%= ([^ ]+) %>|\\$\\{ ?([^{} ]+) ?\\}|\\{\\{([^{} ]+)\\}\\}/g;\n\n    return function(data) {\n\n        data = data || {};\n\n        return html.replace(regex, function(match) {\n\n            var args = Array.from(arguments);\n            var attr = args.slice(1, 4).find(function(_attr) {\n                return !!_attr;\n            });\n\n            var attrArray = attr.split('.');\n            var value = data[attrArray.shift()];\n\n            while (value !== undefined && attrArray.length) {\n                value = value[attrArray.shift()];\n            }\n\n            return value !== undefined ? value : '';\n        });\n    };\n};\n\n/**\n * @param {Element} el Element, which content is intent to display in full-screen mode, 'window.top.document.body' is default.\n */\nconst toggleFullScreen = function(el) {\n\n    var topDocument = window.top.document;\n    el = el || topDocument.body;\n\n    function prefixedResult(el, prop) {\n\n        var prefixes = ['webkit', 'moz', 'ms', 'o', ''];\n        for (var i = 0; i < prefixes.length; i++) {\n            var prefix = prefixes[i];\n            var propName = prefix ? (prefix + prop) : (prop.substr(0, 1).toLowerCase() + prop.substr(1));\n            if (el[propName] !== undefined) {\n                return (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isFunction)(el[propName]) ? el[propName]() : el[propName];\n            }\n        }\n    }\n\n    if (prefixedResult(topDocument, 'FullscreenElement') || prefixedResult(topDocument, 'FullScreenElement')) {\n        prefixedResult(topDocument, 'ExitFullscreen') || // Spec.\n        prefixedResult(topDocument, 'CancelFullScreen'); // Firefox\n    } else {\n        prefixedResult(el, 'RequestFullscreen') || // Spec.\n        prefixedResult(el, 'RequestFullScreen'); // Firefox\n    }\n};\n\nfunction findDifference(obj, baseObj, currentDepth, maxDepth) {\n\n    if (currentDepth === maxDepth) {\n        return {};\n    }\n\n    const diff = {};\n\n    Object.keys(obj).forEach((key) => {\n\n        const objValue = obj[key];\n        const baseValue = baseObj[key];\n\n        if (!Array.isArray(objValue) && !Array.isArray(baseValue) && (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject)(objValue) && (0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isObject)(baseValue)) {\n\n            const nestedDepth = currentDepth + 1;\n            const nestedDiff = findDifference(objValue, baseValue, nestedDepth, maxDepth);\n\n            if (Object.keys(nestedDiff).length > 0) {\n                diff[key] = nestedDiff;\n            } else if ((currentDepth === 0 || nestedDepth === maxDepth)) {\n                diff[key] = {};\n            }\n\n        } else if (!(0,_utilHelpers_mjs__WEBPACK_IMPORTED_MODULE_3__.isEqual)(objValue, baseValue)) {\n            diff[key] = objValue;\n        }\n    });\n\n    return diff;\n}\n\nfunction objectDifference(object, base, opt) {\n\n    const { maxDepth = Number.POSITIVE_INFINITY } = opt || {};\n\n    return findDifference(object, base, 0, maxDepth);\n}\n\n\n\nconst noop = function() {\n    // Do nothing.\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC91dGlsLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ047QUFDYztBQXlDbEI7O0FBRXBCOztBQUVQOztBQUVBOztBQUVBLGlDQUFpQyxxREFBTSw2QkFBNkIscURBQU07QUFDMUUseUJBQXlCLHFEQUFNO0FBQy9COztBQUVBOztBQUVBLEtBQUs7QUFDTDs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQSxpQ0FBaUMscURBQU0sNkJBQTZCLHFEQUFNO0FBQzFFLDJDQUEyQyxxREFBTTtBQUNqRDs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7O0FBRU87O0FBRVA7QUFDQTtBQUNBLHlCQUF5QixvREFBQzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0Msd0RBQUMsU0FBUyw4REFBQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhEQUFDO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPOztBQUVQO0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBVTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxNQUFNO0FBQ047QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxRUFBcUUsMERBQVEsY0FBYywwREFBUTs7QUFFbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUEsVUFBVSxVQUFVLHlEQUFPO0FBQzNCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRU87O0FBRVAsWUFBWSxzQ0FBc0M7O0FBRWxEO0FBQ0E7O0FBMENFOztBQUVLO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGpvaW50L2NvcmUvc3JjL3V0aWwvdXRpbC5tanM/MjJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJCBmcm9tICcuLi9tdmMvRG9tL2luZGV4Lm1qcyc7XG5pbXBvcnQgViBmcm9tICcuLi9WL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcvaW5kZXgubWpzJztcbmltcG9ydCB7XG4gICAgaXNCb29sZWFuLFxuICAgIGlzT2JqZWN0LFxuICAgIGlzTnVtYmVyLFxuICAgIGlzU3RyaW5nLFxuICAgIG1peGluLFxuICAgIGRlZXBNaXhpbixcbiAgICBzdXBwbGVtZW50LFxuICAgIGRlZmF1bHRzLFxuICAgIGRlZmF1bHRzRGVlcCxcbiAgICBkZWVwU3VwcGxlbWVudCxcbiAgICBhc3NpZ24sXG4gICAgaW52b2tlLFxuICAgIGludm9rZVByb3BlcnR5LFxuICAgIHNvcnRlZEluZGV4LFxuICAgIHVuaXEsXG4gICAgY2xvbmUsXG4gICAgY2xvbmVEZWVwLFxuICAgIGlzRW1wdHksXG4gICAgaXNFcXVhbCxcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzUGxhaW5PYmplY3QsXG4gICAgdG9BcnJheSxcbiAgICBkZWJvdW5jZSxcbiAgICBncm91cEJ5LFxuICAgIHNvcnRCeSxcbiAgICBmbGF0dGVuRGVlcCxcbiAgICB3aXRob3V0LFxuICAgIGRpZmZlcmVuY2UsXG4gICAgaW50ZXJzZWN0aW9uLFxuICAgIHVuaW9uLFxuICAgIGhhcyxcbiAgICByZXN1bHQsXG4gICAgb21pdCxcbiAgICBwaWNrLFxuICAgIGJpbmRBbGwsXG4gICAgZm9ySW4sXG4gICAgY2FtZWxDYXNlLFxuICAgIHVuaXF1ZUlkLFxuICAgIG1lcmdlXG59IGZyb20gJy4vdXRpbEhlbHBlcnMubWpzJztcblxuZXhwb3J0IGNvbnN0IGFkZENsYXNzTmFtZVByZWZpeCA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuXG4gICAgaWYgKCFjbGFzc05hbWUpIHJldHVybiBjbGFzc05hbWU7XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lLnRvU3RyaW5nKCkuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oX2NsYXNzTmFtZSkge1xuXG4gICAgICAgIGlmIChfY2xhc3NOYW1lLnN1YnN0cigwLCBjb25maWcuY2xhc3NOYW1lUHJlZml4Lmxlbmd0aCkgIT09IGNvbmZpZy5jbGFzc05hbWVQcmVmaXgpIHtcbiAgICAgICAgICAgIF9jbGFzc05hbWUgPSBjb25maWcuY2xhc3NOYW1lUHJlZml4ICsgX2NsYXNzTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfY2xhc3NOYW1lO1xuXG4gICAgfSkuam9pbignICcpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZUNsYXNzTmFtZVByZWZpeCA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuXG4gICAgaWYgKCFjbGFzc05hbWUpIHJldHVybiBjbGFzc05hbWU7XG5cbiAgICByZXR1cm4gY2xhc3NOYW1lLnRvU3RyaW5nKCkuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24oX2NsYXNzTmFtZSkge1xuXG4gICAgICAgIGlmIChfY2xhc3NOYW1lLnN1YnN0cigwLCBjb25maWcuY2xhc3NOYW1lUHJlZml4Lmxlbmd0aCkgPT09IGNvbmZpZy5jbGFzc05hbWVQcmVmaXgpIHtcbiAgICAgICAgICAgIF9jbGFzc05hbWUgPSBfY2xhc3NOYW1lLnN1YnN0cihjb25maWcuY2xhc3NOYW1lUHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NsYXNzTmFtZTtcblxuICAgIH0pLmpvaW4oJyAnKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZURPTUpTT04gPSBmdW5jdGlvbihqc29uLCBuYW1lc3BhY2UpIHtcblxuICAgIGNvbnN0IHNlbGVjdG9ycyA9IHt9O1xuICAgIGNvbnN0IGdyb3VwU2VsZWN0b3JzID0ge307XG4gICAgY29uc3Qgc3ZnTmFtZXNwYWNlID0gVi5uYW1lc3BhY2Uuc3ZnO1xuXG4gICAgY29uc3QgaW5pdGlhbE5TID0gbmFtZXNwYWNlIHx8IHN2Z05hbWVzcGFjZTtcbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGNvbnN0IHBhcnNlTm9kZSA9IGZ1bmN0aW9uKHNpYmxpbmdzRGVmLCBwYXJlbnROb2RlLCBwYXJlbnROUykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzRGVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlRGVmID0gc2libGluZ3NEZWZbaV07XG5cbiAgICAgICAgICAgIC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlRGVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZURlZik7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRhZ05hbWVcbiAgICAgICAgICAgIGlmICghbm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgndGFnTmFtZScpKSB0aHJvdyBuZXcgRXJyb3IoJ2pzb24tZG9tLXBhcnNlcjogbWlzc2luZyB0YWdOYW1lJyk7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gbm9kZURlZi50YWdOYW1lO1xuXG4gICAgICAgICAgICBsZXQgbm9kZTtcblxuICAgICAgICAgICAgLy8gTmFtZXNwYWNlIFVSSVxuICAgICAgICAgICAgY29uc3QgbnMgPSAobm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgnbmFtZXNwYWNlVVJJJykpID8gbm9kZURlZi5uYW1lc3BhY2VVUkkgOiBwYXJlbnROUztcbiAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsIHRhZ05hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc3ZnID0gKG5zID09PSBzdmdOYW1lc3BhY2UpO1xuXG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyTm9kZSA9IChzdmcpID8gVihub2RlKSA6ICQobm9kZSk7XG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGVzXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZURlZi5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHdyYXBwZXJOb2RlLmF0dHIoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAvLyBTdHlsZVxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBub2RlRGVmLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlKSAkKG5vZGUpLmNzcyhzdHlsZSk7XG4gICAgICAgICAgICAvLyBDbGFzc05hbWVcbiAgICAgICAgICAgIGlmIChub2RlRGVmLmhhc093blByb3BlcnR5KCdjbGFzc05hbWUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG5vZGVEZWYuY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUuYmFzZVZhbCA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUZXh0Q29udGVudFxuICAgICAgICAgICAgaWYgKG5vZGVEZWYuaGFzT3duUHJvcGVydHkoJ3RleHRDb250ZW50JykpIHtcbiAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gbm9kZURlZi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlbGVjdG9yXG4gICAgICAgICAgICBpZiAobm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0b3InKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVTZWxlY3RvciA9IG5vZGVEZWYuc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yc1tub2RlU2VsZWN0b3JdKSB0aHJvdyBuZXcgRXJyb3IoJ2pzb24tZG9tLXBhcnNlcjogc2VsZWN0b3IgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnNbbm9kZVNlbGVjdG9yXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgd3JhcHBlck5vZGUuYXR0cignam9pbnQtc2VsZWN0b3InLCBub2RlU2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR3JvdXBzXG4gICAgICAgICAgICBpZiAobm9kZURlZi5oYXNPd25Qcm9wZXJ0eSgnZ3JvdXBTZWxlY3RvcicpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGVHcm91cHMgPSBub2RlRGVmLmdyb3VwU2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVHcm91cHMpKSBub2RlR3JvdXBzID0gW25vZGVHcm91cHNdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZUdyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlR3JvdXAgPSBub2RlR3JvdXBzW2pdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXAgPSBncm91cFNlbGVjdG9yc1tub2RlR3JvdXBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwKSBncm91cCA9IGdyb3VwU2VsZWN0b3JzW25vZGVHcm91cF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIENoaWxkcmVuXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkRlZiA9IG5vZGVEZWYuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbkRlZikpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU5vZGUoY2hpbGRyZW5EZWYsIG5vZGUsIG5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VOb2RlKGpzb24sIGZyYWdtZW50LCBpbml0aWFsTlMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgc2VsZWN0b3JzOiBzZWxlY3RvcnMsXG4gICAgICAgIGdyb3VwU2VsZWN0b3JzOiBncm91cFNlbGVjdG9yc1xuICAgIH07XG59O1xuXG4vLyBSZXR1cm4gYSBzaW1wbGUgaGFzaCBjb2RlIGZyb20gYSBzdHJpbmcuIFNlZSBodHRwOi8vd2VyeGx0ZC5jb20vd3AvMjAxMC8wNS8xMy9qYXZhc2NyaXB0LWltcGxlbWVudGF0aW9uLW9mLWphdmFzLXN0cmluZy1oYXNoY29kZS1tZXRob2QvLlxuZXhwb3J0IGNvbnN0IGhhc2hDb2RlID0gZnVuY3Rpb24oc3RyKSB7XG5cbiAgICBsZXQgaGFzaCA9IDA7XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHJldHVybiBoYXNoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgYztcbiAgICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QnlQYXRoID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBkZWxpbWl0ZXIpIHtcblxuICAgIHZhciBrZXlzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KGRlbGltaXRlciB8fCAnLycpO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBrZXkgPSBrZXlzW2krK107XG4gICAgICAgIGlmIChPYmplY3Qob2JqKSA9PT0gb2JqICYmIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuY29uc3QgaXNHZXRTYWZlID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICAvLyBQcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAvLyBodHRwczovL3NueWsuaW8vdnVsbi9TTllLLUpTLUpTT044TUVSR0VQQVRDSC0xMDM4Mzk5XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGtleSA9IFN0cmluZyhrZXkpO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnQgY29uc3Qgc2V0QnlQYXRoID0gZnVuY3Rpb24ob2JqLCBwYXRoLCB2YWx1ZSwgZGVsaW1pdGVyKSB7XG5cbiAgICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KGRlbGltaXRlciB8fCAnLycpO1xuICAgIGNvbnN0IGxhc3QgPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGRpdmVyID0gb2JqO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghaXNHZXRTYWZlKGRpdmVyLCBrZXkpKSByZXR1cm4gb2JqO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRpdmVyW2tleV07XG4gICAgICAgIC8vIGRpdmVyIGNyZWF0ZXMgYW4gZW1wdHkgb2JqZWN0IGlmIHRoZXJlIGlzIG5vIG5lc3RlZCBvYmplY3QgdW5kZXIgc3VjaCBhIGtleS5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IG9uZSBjYW4gcG9wdWxhdGUgYW4gZW1wdHkgbmVzdGVkIG9iamVjdCB3aXRoIHNldEJ5UGF0aCgpLlxuICAgICAgICBkaXZlciA9IHZhbHVlIHx8IChkaXZlcltrZXldID0ge30pO1xuICAgIH1cblxuICAgIGRpdmVyW2tleXNbbGFzdF1dID0gdmFsdWU7XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGNvbnN0IHVuc2V0QnlQYXRoID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBkZWxpbWl0ZXIpIHtcblxuICAgIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoZGVsaW1pdGVyIHx8ICcvJyk7XG4gICAgY29uc3QgbGFzdCA9IGtleXMubGVuZ3RoIC0gMTtcbiAgICBsZXQgZGl2ZXIgPSBvYmo7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFpc0dldFNhZmUoZGl2ZXIsIGtleSkpIHJldHVybiBvYmo7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZGl2ZXJba2V5XTtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG9iajtcbiAgICAgICAgZGl2ZXIgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBkZWxldGUgZGl2ZXJba2V5c1tsYXN0XV07XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGNvbnN0IGZsYXR0ZW5PYmplY3QgPSBmdW5jdGlvbihvYmosIGRlbGltLCBzdG9wKSB7XG5cbiAgICBkZWxpbSA9IGRlbGltIHx8ICcvJztcbiAgICB2YXIgcmV0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG5cbiAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XG5cbiAgICAgICAgdmFyIHNob3VsZEdvRGVlcGVyID0gdHlwZW9mIG9ialtrZXldID09PSAnb2JqZWN0JztcbiAgICAgICAgaWYgKHNob3VsZEdvRGVlcGVyICYmIHN0b3AgJiYgc3RvcChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHNob3VsZEdvRGVlcGVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkR29EZWVwZXIpIHtcblxuICAgICAgICAgICAgdmFyIGZsYXRPYmplY3QgPSBmbGF0dGVuT2JqZWN0KG9ialtrZXldLCBkZWxpbSwgc3RvcCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGZsYXRLZXkgaW4gZmxhdE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghZmxhdE9iamVjdC5oYXNPd25Qcm9wZXJ0eShmbGF0S2V5KSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmV0W2tleSArIGRlbGltICsgZmxhdEtleV0gPSBmbGF0T2JqZWN0W2ZsYXRLZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0IGNvbnN0IHV1aWQgPSBmdW5jdGlvbigpIHtcblxuICAgIC8vIGNyZWRpdDogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3Bvc3RzLzIxMTc1MjMvcmV2aXNpb25zXG5cbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwO1xuICAgICAgICB2YXIgdiA9IChjID09PSAneCcpID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxuLy8gR2VuZXJhdGVzIGdsb2JhbCB1bmlxdWUgaWQgYW5kIHN0b3JlcyBpdCBhcyBhIHByb3BlcnR5IG9mIHRoZSBvYmplY3QsIGlmIHByb3ZpZGVkLlxuZXhwb3J0IGNvbnN0IGd1aWQgPSBmdW5jdGlvbihvYmopIHtcblxuICAgIGd1aWQuaWQgPSBndWlkLmlkIHx8IDE7XG5cbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICdqXycgKyBndWlkLmlkKys7XG4gICAgfVxuXG4gICAgb2JqLmlkID0gKG9iai5pZCA9PT0gdW5kZWZpbmVkID8gJ2pfJyArIGd1aWQuaWQrKyA6IG9iai5pZCk7XG4gICAgcmV0dXJuIG9iai5pZDtcbn07XG5cbmV4cG9ydCBjb25zdCB0b0tlYmFiQ2FzZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bQS1aXS9nLCAnLSQmJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBub3JtYWxpemVFdmVudCA9IGZ1bmN0aW9uKGV2dCkge1xuXG4gICAgaWYgKGV2dC5ub3JtYWxpemVkKSByZXR1cm4gZXZ0O1xuXG4gICAgY29uc3QgeyBvcmlnaW5hbEV2ZW50LCB0YXJnZXQgfSA9IGV2dDtcblxuICAgIC8vIElmIHRoZSBldmVudCBpcyBhIHRvdWNoIGV2ZW50LCBub3JtYWxpemUgaXQgdG8gYSBtb3VzZSBldmVudC5cbiAgICBjb25zdCB0b3VjaCA9IG9yaWdpbmFsRXZlbnQgJiYgb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGlmICh0b3VjaCkge1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0b3VjaCkge1xuICAgICAgICAgICAgLy8gY29weSBhbGwgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgZmlyc3QgdG91Y2ggdGhhdCBhcmUgbm90XG4gICAgICAgICAgICAvLyBkZWZpbmVkIG9uIFRvdWNoRXZlbnQgKGNsaWVudFgsIGNsaWVudFksIHBhZ2VYLCBwYWdlWSwgc2NyZWVuWCwgc2NyZWVuWSwgaWRlbnRpZmllciwgLi4uKVxuICAgICAgICAgICAgaWYgKGV2dFtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGV2dFtwcm9wZXJ0eV0gPSB0b3VjaFtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSUU6IGV2dC50YXJnZXQgY291bGQgYmUgc2V0IHRvIFNWR0VsZW1lbnRJbnN0YW5jZSBmb3IgU1ZHVXNlRWxlbWVudFxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdXNlRWxlbWVudCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgICAgICAgaWYgKHVzZUVsZW1lbnQpIGV2dC50YXJnZXQgPSB1c2VFbGVtZW50O1xuICAgIH1cblxuICAgIGV2dC5ub3JtYWxpemVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBldnQ7XG59O1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplV2hlZWwgPSBmdW5jdGlvbihldnQpIHtcbiAgICAvLyBTYW5lIHZhbHVlcyBkZXJpdmVkIGVtcGlyaWNhbGx5XG4gICAgY29uc3QgUElYRUxfU1RFUCAgPSAxMDtcbiAgICBjb25zdCBMSU5FX0hFSUdIVCA9IDQwO1xuICAgIGNvbnN0IFBBR0VfSEVJR0hUID0gODAwO1xuXG4gICAgbGV0IHNYID0gMCwgc1kgPSAwLCBwWCA9IDAsIHBZID0gMDtcblxuICAgIC8vIExlZ2FjeVxuICAgIGlmICgnZGV0YWlsJyAgICAgIGluIGV2dCkgeyBzWSA9IGV2dC5kZXRhaWw7IH1cbiAgICBpZiAoJ3doZWVsRGVsdGEnICBpbiBldnQpIHsgc1kgPSAtZXZ0LndoZWVsRGVsdGEgLyAxMjA7IH1cbiAgICBpZiAoJ3doZWVsRGVsdGFZJyBpbiBldnQpIHsgc1kgPSAtZXZ0LndoZWVsRGVsdGFZIC8gMTIwOyB9XG4gICAgaWYgKCd3aGVlbERlbHRhWCcgaW4gZXZ0KSB7IHNYID0gLWV2dC53aGVlbERlbHRhWCAvIDEyMDsgfVxuXG4gICAgLy8gc2lkZSBzY3JvbGxpbmcgb24gRkYgd2l0aCBET01Nb3VzZVNjcm9sbFxuICAgIGlmICggJ2F4aXMnIGluIGV2dCAmJiBldnQuYXhpcyA9PT0gZXZ0LkhPUklaT05UQUxfQVhJUyApIHtcbiAgICAgICAgc1ggPSBzWTtcbiAgICAgICAgc1kgPSAwO1xuICAgIH1cblxuICAgIHBYID0gJ2RlbHRhWCcgaW4gZXZ0ID8gZXZ0LmRlbHRhWCA6IHNYICogUElYRUxfU1RFUDtcbiAgICBwWSA9ICdkZWx0YVknIGluIGV2dCA/IGV2dC5kZWx0YVkgOiBzWSAqIFBJWEVMX1NURVA7XG5cbiAgICBpZiAoKHBYIHx8IHBZKSAmJiBldnQuZGVsdGFNb2RlKSB7XG4gICAgICAgIGlmIChldnQuZGVsdGFNb2RlID09IDEpIHtcbiAgICAgICAgICAgIHBYICo9IExJTkVfSEVJR0hUO1xuICAgICAgICAgICAgcFkgKj0gTElORV9IRUlHSFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwWCAqPSBQQUdFX0hFSUdIVDtcbiAgICAgICAgICAgIHBZICo9IFBBR0VfSEVJR0hUO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFjT1Mgc3dpdGNoZXMgZGVsdGFYIGFuZCBkZWx0YVkgYXV0b21hdGljYWxseSB3aGVuIHNjcm9sbGluZyB3aXRoIHNoaWZ0IGtleSwgc28gdGhpcyBpcyBuZWVkZWQgaW4gb3RoZXIgY2FzZXNcbiAgICBpZiAoZXZ0LmRlbHRhWCA9PT0gMCAmJiBldnQuZGVsdGFZICE9PSAwICYmIGV2dC5zaGlmdEtleSkge1xuICAgICAgICBwWCA9IHBZO1xuICAgICAgICBwWSA9IDA7XG4gICAgICAgIHNYID0gc1k7XG4gICAgICAgIHNZID0gMDtcbiAgICB9XG5cbiAgICAvLyBGYWxsLWJhY2sgaWYgc3BpbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFxuICAgIGlmIChwWCAmJiAhc1gpIHsgc1ggPSAocFggPCAxKSA/IC0xIDogMTsgfVxuICAgIGlmIChwWSAmJiAhc1kpIHsgc1kgPSAocFkgPCAxKSA/IC0xIDogMTsgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3BpblggIDogc1gsXG4gICAgICAgIHNwaW5ZICA6IHNZLFxuICAgICAgICBkZWx0YVggOiBwWCxcbiAgICAgICAgZGVsdGFZIDogcFksXG4gICAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXAgPSBmdW5jdGlvbih2YWwsIG1heCkge1xuICAgIHJldHVybiB2YWwgPiBtYXggPyBtYXggOiB2YWwgPCAtbWF4ID8gLW1heCA6IHZhbDtcbn07XG5cbmV4cG9ydCBjb25zdCBuZXh0RnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgcmFmO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIXJhZikge1xuXG4gICAgICAgIHZhciBsYXN0VGltZSA9IDA7XG5cbiAgICAgICAgcmFmID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgICAgIHZhciBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgICAgIH0sIHRpbWVUb0NhbGwpO1xuXG4gICAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcblxuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaywgY29udGV4dCwgLi4ucmVzdCkge1xuICAgICAgICByZXR1cm4gKGNvbnRleHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgID8gcmFmKGNhbGxiYWNrLmJpbmQoY29udGV4dCwgLi4ucmVzdCkpXG4gICAgICAgICAgICA6IHJhZihjYWxsYmFjayk7XG4gICAgfTtcblxufSkoKTtcblxuZXhwb3J0IGNvbnN0IGNhbmNlbEZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGNhZjtcbiAgICB2YXIgY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJztcblxuICAgIGlmIChjbGllbnQpIHtcblxuICAgICAgICBjYWYgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93LndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm9DYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm9DYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICB9XG5cbiAgICBjYWYgPSBjYWYgfHwgY2xlYXJUaW1lb3V0O1xuXG4gICAgcmV0dXJuIGNsaWVudCA/IGNhZi5iaW5kKHdpbmRvdykgOiBjYWY7XG5cbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBpc1BlcmNlbnRhZ2UgPSBmdW5jdGlvbih2YWwpIHtcblxuICAgIHJldHVybiBpc1N0cmluZyh2YWwpICYmIHZhbC5zbGljZSgtMSkgPT09ICclJztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNzc051bWVyaWMgPSBmdW5jdGlvbih2YWwsIHJlc3RyaWN0VW5pdHMpIHtcblxuICAgIGZ1bmN0aW9uIGdldFVuaXQodmFsaWRVbml0RXhwKSB7XG5cbiAgICAgICAgLy8gb25lIG9yIG1vcmUgbnVtYmVycywgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gYW55IG51bWJlciBvZiAoXG4gICAgICAgIC8vICBgLmAsIGZvbGxvd2VkIGJ5XG4gICAgICAgIC8vICBvbmUgb3IgbW9yZSBudW1iZXJzXG4gICAgICAgIC8vICksIGZvbGxvd2VkIGJ5XG4gICAgICAgIC8vIGB2YWxpZFVuaXRFeHBgLCBmb2xsb3dlZCBieVxuICAgICAgICAvLyBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIHZhciBtYXRjaGVzID0gbmV3IFJlZ0V4cCgnKD86XFxcXGQrKD86XFxcXC5cXFxcZCspKikoJyArIHZhbGlkVW5pdEV4cCArICcpJCcpLmV4ZWModmFsKTtcblxuICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICB9XG5cbiAgICB2YXIgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWwpO1xuXG4gICAgLy8gaWYgYHZhbGAgY2Fubm90IGJlIHBhcnNlZCBhcyBhIG51bWJlciwgcmV0dXJuIGBudWxsYFxuICAgIGlmIChOdW1iZXIuaXNOYU4obnVtYmVyKSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBlbHNlOiB3ZSBrbm93IGBvdXRwdXQudmFsdWVgXG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIG91dHB1dC52YWx1ZSA9IG51bWJlcjtcblxuICAgIC8vIGRldGVybWluZSB0aGUgdW5pdFxuICAgIHZhciB2YWxpZFVuaXRFeHA7XG4gICAgaWYgKHJlc3RyaWN0VW5pdHMgPT0gbnVsbCkge1xuICAgICAgICAvLyBubyByZXN0cmljdGlvblxuICAgICAgICAvLyBhY2NlcHQgYW55IHVuaXQsIGFzIHdlbGwgYXMgbm8gdW5pdFxuICAgICAgICB2YWxpZFVuaXRFeHAgPSAnW0EtWmEtel0qJztcblxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXN0cmljdFVuaXRzKSkge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGVtcHR5IGFycmF5LCB0b3AgcmVzdHJpY3Rpb24gLSByZXR1cm4gYG51bGxgXG4gICAgICAgIGlmIChyZXN0cmljdFVuaXRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgLy8gZWxzZTogcmVzdHJpY3Rpb24gLSBhbiBhcnJheSBvZiB2YWxpZCB1bml0IHN0cmluZ3NcbiAgICAgICAgdmFsaWRVbml0RXhwID0gcmVzdHJpY3RVbml0cy5qb2luKCd8Jyk7XG5cbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHJlc3RyaWN0VW5pdHMpKSB7XG4gICAgICAgIC8vIHJlc3RyaWN0aW9uIC0gYSBzaW5nbGUgdmFsaWQgdW5pdCBzdHJpbmdcbiAgICAgICAgdmFsaWRVbml0RXhwID0gcmVzdHJpY3RVbml0cztcbiAgICB9XG4gICAgdmFyIHVuaXQgPSBnZXRVbml0KHZhbGlkVW5pdEV4cCk7XG5cbiAgICAvLyBpZiB3ZSBmb3VuZCBubyBtYXRjaGVzIGZvciBgcmVzdHJpY3RVbml0c2AsIHJldHVybiBgbnVsbGBcbiAgICBpZiAodW5pdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBlbHNlOiB3ZSBrbm93IHRoZSB1bml0XG4gICAgb3V0cHV0LnVuaXQgPSB1bml0O1xuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5jb25zdCBOT19TUEFDRSA9IDA7XG5cbmZ1bmN0aW9uIHNwbGl0V29yZFdpdGhFT0wod29yZCwgZW9sKSB7XG4gICAgY29uc3QgZW9sV29yZHMgPSB3b3JkLnNwbGl0KGVvbCk7XG4gICAgbGV0IG4gPSAxO1xuICAgIGZvciAobGV0IGogPSAwLCBqbCA9IGVvbFdvcmRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gW107XG4gICAgICAgIGlmIChqID4gMCB8fCBlb2xXb3Jkc1swXSAhPT0gJycpIHJlcGxhY2VtZW50LnB1c2goTk9fU1BBQ0UpO1xuICAgICAgICByZXBsYWNlbWVudC5wdXNoKGVvbCk7XG4gICAgICAgIGlmIChqIDwgamwgLSAxIHx8IGVvbFdvcmRzW2psXSAhPT0gJycpIHJlcGxhY2VtZW50LnB1c2goTk9fU1BBQ0UpO1xuICAgICAgICBlb2xXb3Jkcy5zcGxpY2UobiwgMCwgLi4ucmVwbGFjZW1lbnQpO1xuICAgICAgICBuICs9IHJlcGxhY2VtZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIHJldHVybiBlb2xXb3Jkcy5maWx0ZXIod29yZCA9PiB3b3JkICE9PSAnJyk7XG59XG5cblxuZnVuY3Rpb24gZ2V0TGluZUhlaWdodChoZWlnaHRWYWx1ZSwgdGV4dEVsZW1lbnQpIHtcbiAgICBpZiAoaGVpZ2h0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gRGVmYXVsdCAxZW0gbGluZUhlaWdodFxuICAgICAgICByZXR1cm4gdGV4dEVsZW1lbnQuZ2V0QkJveCgpLmhlaWdodDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGhlaWdodFZhbHVlLnVuaXQpIHtcbiAgICAgICAgY2FzZSAnZW0nOlxuICAgICAgICAgICAgcmV0dXJuIHRleHRFbGVtZW50LmdldEJCb3goKS5oZWlnaHQgKiBoZWlnaHRWYWx1ZS52YWx1ZTtcbiAgICAgICAgY2FzZSAncHgnOlxuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgICAgcmV0dXJuIGhlaWdodFZhbHVlLnZhbHVlO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGJyZWFrVGV4dCA9IGZ1bmN0aW9uKHRleHQsIHNpemUsIHN0eWxlcyA9IHt9LCBvcHQgPSB7fSkge1xuXG4gICAgdmFyIHdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cbiAgICB2YXIgc3ZnRG9jdW1lbnQgPSBvcHQuc3ZnRG9jdW1lbnQgfHwgVignc3ZnJykubm9kZTtcbiAgICB2YXIgdGV4dFNwYW4gPSBWKCd0c3BhbicpLm5vZGU7XG4gICAgdmFyIHRleHRFbGVtZW50ID0gVigndGV4dCcpLmF0dHIoc3R5bGVzKS5hcHBlbmQodGV4dFNwYW4pLm5vZGU7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuXG4gICAgLy8gUHJldmVudCBmbGlja2VyaW5nXG4gICAgdGV4dEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgLy8gUHJldmVudCBGRiBmcm9tIHRocm93aW5nIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3aGVuIGBnZXRCQm94KClgXG4gICAgLy8gY2FsbGVkIG9uIGVsZW1lbnQgdGhhdCBpcyBub3QgaW4gdGhlIHJlbmRlciB0cmVlIChpcyBub3QgbWVhc3VyYWJsZSkuXG4gICAgLy8gPHRzcGFuPi5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSByZXR1cm5zIGFsd2F5cyAwIGluIHRoaXMgY2FzZS5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIGB0ZXh0RWxlbWVudGAgcmVzcC4gYHRleHRTcGFuYCBjYW4gYmVjb21lIGhpZGRlblxuICAgIC8vIHdoZW4gaXQncyBhcHBlbmRlZCB0byB0aGUgRE9NIGFuZCBhIGBkaXNwbGF5OiBub25lYCBDU1Mgc3R5bGVzaGVldFxuICAgIC8vIHJ1bGUgZ2V0cyBhcHBsaWVkLlxuICAgIHRleHRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRleHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGV4dFNwYW4uYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIHN2Z0RvY3VtZW50LmFwcGVuZENoaWxkKHRleHRFbGVtZW50KTsgLy8gbGd0bSBbanMveHNzLXRocm91Z2gtZG9tXVxuXG4gICAgaWYgKCFvcHQuc3ZnRG9jdW1lbnQpIHtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Z0RvY3VtZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmVzZXJ2ZVNwYWNlcyA9IG9wdC5wcmVzZXJ2ZVNwYWNlcztcbiAgICBjb25zdCBzcGFjZSA9ICcgJztcbiAgICBjb25zdCBzZXBhcmF0b3IgPSAob3B0LnNlcGFyYXRvciB8fCBvcHQuc2VwYXJhdG9yID09PSAnJykgPyBvcHQuc2VwYXJhdG9yIDogc3BhY2U7XG4gICAgLy8gSWYgc2VwYXJhdG9yIGlzIGEgUmVnRXhwLCB3ZSB1c2UgdGhlIHNwYWNlIGNoYXJhY3RlciB0byBqb2luIHdvcmRzIHRvZ2V0aGVyIGFnYWluIChub3QgaWRlYWwpXG4gICAgY29uc3Qgc2VwYXJhdG9yQ2hhciA9ICh0eXBlb2Ygc2VwYXJhdG9yID09PSAnc3RyaW5nJykgPyBzZXBhcmF0b3IgOiBzcGFjZTtcbiAgICB2YXIgZW9sID0gb3B0LmVvbCB8fCAnXFxuJztcbiAgICB2YXIgaHlwaGVuID0gb3B0Lmh5cGhlbiA/IG5ldyBSZWdFeHAob3B0Lmh5cGhlbikgOiAvW15cXHdcXGRcXHUwMEMwLVxcdTFGRkZcXHUyODAwLVxcdUZGRkRdLztcbiAgICB2YXIgbWF4TGluZUNvdW50ID0gb3B0Lm1heExpbmVDb3VudDtcbiAgICBpZiAoIWlzTnVtYmVyKG1heExpbmVDb3VudCkpIG1heExpbmVDb3VudCA9IEluZmluaXR5O1xuXG4gICAgdmFyIHdvcmRzID0gdGV4dC5zcGxpdChzZXBhcmF0b3IpO1xuICAgIHZhciBmdWxsID0gW107XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdmFyIHAsIGg7XG4gICAgdmFyIGxpbmVIZWlnaHQ7XG5cbiAgICBpZiAocHJlc2VydmVTcGFjZXMpIHtcbiAgICAgICAgVih0ZXh0U3BhbikuYXR0cigneG1sOnNwYWNlJywgJ3ByZXNlcnZlJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSAwLCBsZW4gPSB3b3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgIHZhciB3b3JkID0gd29yZHNbaV07XG5cbiAgICAgICAgaWYgKCF3b3JkICYmICFwcmVzZXJ2ZVNwYWNlcykgY29udGludWU7XG4gICAgICAgIGlmICh0eXBlb2Ygd29yZCAhPT0gJ3N0cmluZycpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBpc0VvbCA9IGZhbHNlO1xuICAgICAgICBpZiAoZW9sICYmIHdvcmQuaW5kZXhPZihlb2wpID49IDApIHtcbiAgICAgICAgICAgIC8vIHdvcmQgY29udGFpbnMgZW5kLW9mLWxpbmUgY2hhcmFjdGVyXG4gICAgICAgICAgICBpZiAod29yZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGUgd29yZCBhbmQgY29udGludWUgY3ljbGVcbiAgICAgICAgICAgICAgICBjb25zdCBlb2xXb3JkcyA9IHNwbGl0V29yZFdpdGhFT0wod29yZHNbaV0sIGVvbCk7XG4gICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGksIDEsIC4uLmVvbFdvcmRzKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgbGVuID0gd29yZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGVzIGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVTcGFjZXMgJiYgdHlwZW9mIHdvcmRzW2kgLSAxXSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLnNwbGljZShpLCBOT19TUEFDRSwgJycsIE5PX1NQQUNFKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmVzWysrbF0gPSAoIXByZXNlcnZlU3BhY2VzIHx8IHR5cGVvZiB3b3Jkc1tpICsgMV0gPT09ICdzdHJpbmcnKSA/ICcnIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlzRW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNFb2wpIHtcblxuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVTcGFjZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbGluZXNbbF0gIT09IHVuZGVmaW5lZCA/IGxpbmVzW2xdICsgc2VwYXJhdG9yQ2hhciArIHdvcmQgOiB3b3JkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbGluZXNbbF0gPyBsaW5lc1tsXSArIHNlcGFyYXRvckNoYXIgKyB3b3JkIDogd29yZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dE5vZGUuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICAgIGlmICh0ZXh0U3Bhbi5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSA8PSB3aWR0aCkge1xuXG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgbGluZSBmaXRzXG4gICAgICAgICAgICAgICAgbGluZXNbbF0gPSBkYXRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHAgfHwgaCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3ZXJlIHBhcnRpdGlvbmluZy4gUHV0IHJlc3Qgb2YgdGhlIHdvcmQgb250byBuZXh0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgZnVsbFtsKytdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYW5jZWwgcGFydGl0aW9uaW5nIGFuZCBzcGxpdHRpbmcgYnkgaHlwaGVuc1xuICAgICAgICAgICAgICAgICAgICBwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lc1tsXSB8fCBwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpdGlvbiA9ICEhcDtcblxuICAgICAgICAgICAgICAgICAgICBwID0gd29yZC5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aXRpb24gfHwgIXApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd29yZCBoYXMgb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmVzW2xdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugd29uJ3QgZml0IHRoaXMgdGV4dCB3aXRoaW4gb3VyIHJlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJ0aXRpb25pbmcgZGlkbid0IGhlbHAgb24gdGhlIG5vbi1lbXB0eSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IGFnYWluLCBidXQgdGhpcyB0aW1lIHN0YXJ0IHdpdGggYSBuZXcgbGluZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsIHBhcnRpdGlvbnMgY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzLnNwbGljZShpLCAyLCB3b3JkICsgd29yZHNbaSArIDFdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkanVzdCB3b3JkIGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbi0tO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbFtsKytdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLS07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBsYXN0IGxldHRlciB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IHdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzW2ldID0gd29yZC5zdWJzdHJpbmcoMCwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0V29yZCA9IHdvcmRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzW2kgKyAxXSA9IHdvcmQuc3Vic3RyaW5nKHApICsgKG5leHRXb3JkID09PSB1bmRlZmluZWQgfHwgbmV4dFdvcmQgPT09IE5PX1NQQUNFID8gJycgOiBuZXh0V29yZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbmNlbCBzcGxpdHRpbmcgYW5kIHB1dCB0aGUgd29yZHMgdG9nZXRoZXIgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSwgMiwgd29yZHNbaV0gKyB3b3Jkc1tpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaHlwaGVuSW5kZXggPSB3b3JkLnNlYXJjaChoeXBoZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeXBoZW5JbmRleCA+IC0xICYmIGh5cGhlbkluZGV4ICE9PSB3b3JkLmxlbmd0aCAtIDEgJiYgaHlwaGVuSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGh5cGhlbkluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaW5pdGlhdGUgcGFydGl0aW9uaW5nIG9yIHNwbGl0dGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBsb25nIHdvcmQgaW50byB0d28gd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSwgMSwgd29yZC5zdWJzdHJpbmcoMCwgaCB8fCBwKSwgd29yZC5zdWJzdHJpbmcoaHx8IHApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3Qgd29yZHMgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuKys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGwgJiYgIWZ1bGxbbCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJldmlvdXMgbGluZSBpcyBub3QgZnVsbCwgdHJ5IHRvIGZpdCBtYXggcGFydCBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgd29yZCB0aGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJlc2VydmVTcGFjZXMgfHwgbGluZXNbbF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0TCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IG1heExpbmVDb3VudCkge1xuXG4gICAgICAgICAgICBsYXN0TCA9IG1heExpbmVDb3VudCAtIDE7XG5cbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAvLyBpZiBzaXplLmhlaWdodCBpcyBkZWZpbmVkIHdlIGhhdmUgdG8gY2hlY2sgd2hldGhlciB0aGUgaGVpZ2h0IG9mIHRoZSBlbnRpcmVcbiAgICAgICAgICAgIC8vIHRleHQgZXhjZWVkcyB0aGUgcmVjdCBoZWlnaHRcblxuICAgICAgICAgICAgaWYgKGxpbmVIZWlnaHQgPT09IHVuZGVmaW5lZCAmJiB0ZXh0Tm9kZS5kYXRhICE9PSAnJykge1xuXG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzYW1lIGRlZmF1bHRzIGFzIGluIFYucHJvdG90eXBlLnRleHRcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVzLmxpbmVIZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodCh7IHZhbHVlOiAxLjUsIHVuaXQ6ICdlbScgfSwgdGV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ3NzTnVtZXJpYyhzdHlsZXMubGluZUhlaWdodCwgWydlbScsICdweCcsICcnXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodCA9IGdldExpbmVIZWlnaHQocGFyc2VkLCB0ZXh0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGluZUhlaWdodCAqIGxpbmVzLmxlbmd0aCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBvdmVyZmxvd2luZyBsaW5lc1xuICAgICAgICAgICAgICAgIGxhc3RMID0gTWF0aC5mbG9vcihoZWlnaHQgLyBsaW5lSGVpZ2h0KSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdEwgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgbGluZXMuc3BsaWNlKGxhc3RMICsgMSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCBlbGxpcHNpc1xuICAgICAgICAgICAgdmFyIGVsbGlwc2lzID0gb3B0LmVsbGlwc2lzO1xuICAgICAgICAgICAgaWYgKCFlbGxpcHNpcyB8fCBsYXN0TCA8IDApIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGxpcHNpcyAhPT0gJ3N0cmluZycpIGVsbGlwc2lzID0gJ1xcdTIwMjYnO1xuXG4gICAgICAgICAgICB2YXIgbGFzdExpbmUgPSBsaW5lc1tsYXN0TF07XG4gICAgICAgICAgICBpZiAoIWxhc3RMaW5lICYmICFpc0VvbCkgYnJlYWs7XG4gICAgICAgICAgICB2YXIgayA9IGxhc3RMaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsYXN0TGluZVdpdGhPbWlzc2lvbiwgbGFzdENoYXI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGFzdENoYXIgPSBsYXN0TGluZVtrXTtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVdpdGhPbWlzc2lvbiA9IGxhc3RMaW5lLnN1YnN0cmluZygwLCBrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMaW5lV2l0aE9taXNzaW9uICs9IHNlcGFyYXRvckNoYXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2hhci5tYXRjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMaW5lV2l0aE9taXNzaW9uICs9IGxhc3RDaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0TGluZVdpdGhPbWlzc2lvbiArPSBlbGxpcHNpcztcbiAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5kYXRhID0gbGFzdExpbmVXaXRoT21pc3Npb247XG4gICAgICAgICAgICAgICAgaWYgKHRleHRTcGFuLmdldENvbXB1dGVkVGV4dExlbmd0aCgpIDw9IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2xhc3RMXSA9IGxhc3RMaW5lV2l0aE9taXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgfSB3aGlsZSAoayA+PSAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdC5zdmdEb2N1bWVudCkge1xuXG4gICAgICAgIC8vIHN2ZyBkb2N1bWVudCB3YXMgcHJvdmlkZWQsIHJlbW92ZSB0aGUgdGV4dCBlbGVtZW50IG9ubHlcbiAgICAgICAgc3ZnRG9jdW1lbnQucmVtb3ZlQ2hpbGQodGV4dEVsZW1lbnQpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBjbGVhbiBzdmcgZG9jdW1lbnRcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzdmdEb2N1bWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oZW9sKTtcbn07XG5cbi8vIFNhbml0aXplIEhUTUxcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3Vmb2xvZ2lzdC81YTBkYTUxYjJiOWVmMWI4NjFjMzAyNTQxNzJhYzNjOVxuLy8gUGFyc2VzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgb2YgRE9NIG5vZGVzLlxuLy8gVGhlbiBvdXRwdXRzIGl0IGJhY2sgYXMgYSBzdHJpbmcuXG5leHBvcnQgY29uc3Qgc2FuaXRpemVIVE1MID0gZnVuY3Rpb24oaHRtbCkge1xuXG4gICAgLy8gSWdub3JlcyB0YWdzIHRoYXQgYXJlIGludmFsaWQgaW5zaWRlIGEgPGRpdj4gdGFnIChlLmcuIDxib2R5PiwgPGhlYWQ+KVxuICAgIGNvbnN0IFtvdXRwdXRFbF0gPSAkLnBhcnNlSFRNTCgnPGRpdj4nICsgaHRtbCArICc8L2Rpdj4nKTtcblxuICAgIEFycmF5LmZyb20ob3V0cHV0RWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSkuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7IC8vIGZvciBhbGwgbm9kZXNcbiAgICAgICAgY29uc3QgbmFtZXMgPSBub2RlLmdldEF0dHJpYnV0ZU5hbWVzKCk7XG4gICAgICAgIG5hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBzdGFydCB3aXRoIFwib25cIiAoZS5nLiBvbmxvYWQsIG9uZXJyb3IuLi4pLlxuICAgICAgICAgICAgLy8gUmVtb3ZlIGF0dHJpYnV0ZSB2YWx1ZXMgdGhhdCBzdGFydCB3aXRoIFwiamF2YXNjcmlwdDpcIiBwc2V1ZG8gcHJvdG9jb2wgKGUuZy4gYGhyZWY9XCJqYXZhc2NyaXB0OmFsZXJ0KDEpXCJgKS5cbiAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ29uJykgfHwgdmFsdWUuc3RhcnRzV2l0aCgnamF2YXNjcmlwdDonIHx8IHZhbHVlLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgdmFsdWUuc3RhcnRzV2l0aCgndmJzY3JpcHQ6JykpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG91dHB1dEVsLmlubmVySFRNTDtcbn07XG5cbi8vIERvd25sb2FkIGBibG9iYCBhcyBmaWxlIHdpdGggYGZpbGVOYW1lYC5cbi8vIERvZXMgbm90IHdvcmsgaW4gSUU5LlxuZXhwb3J0IGNvbnN0IGRvd25sb2FkQmxvYiA9IGZ1bmN0aW9uKGJsb2IsIGZpbGVOYW1lKSB7XG5cbiAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1NhdmVCbG9iKSB7IC8vIHJlcXVpcmVzIElFIDEwK1xuICAgICAgICAvLyBwdWxscyB1cCBhIHNhdmUgZGlhbG9nXG4gICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlQmxvYihibG9iLCBmaWxlTmFtZSk7XG5cbiAgICB9IGVsc2UgeyAvLyBvdGhlciBicm93c2Vyc1xuICAgICAgICAvLyBkb3dubG9hZHMgZGlyZWN0bHkgaW4gQ2hyb21lIGFuZCBTYWZhcmlcblxuICAgICAgICAvLyBwcmVzZW50cyBhIHNhdmUvb3BlbiBkaWFsb2cgaW4gRmlyZWZveFxuICAgICAgICAvLyBGaXJlZm94IGJ1ZzogYGZyb21gIGZpZWxkIGluIHNhdmUgZGlhbG9nIGFsd2F5cyBzaG93cyBgZnJvbTpibG9iOmBcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTA1MzMyN1xuXG4gICAgICAgIHZhciB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICAgICAgbGluay5ocmVmID0gdXJsO1xuICAgICAgICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG5cbiAgICAgICAgbGluay5jbGljaygpO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7IC8vIG1hcmsgdGhlIHVybCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgfVxufTtcblxuLy8gRG93bmxvYWQgYGRhdGFVcmlgIGFzIGZpbGUgd2l0aCBgZmlsZU5hbWVgLlxuLy8gRG9lcyBub3Qgd29yayBpbiBJRTkuXG5leHBvcnQgY29uc3QgZG93bmxvYWREYXRhVXJpID0gZnVuY3Rpb24oZGF0YVVyaSwgZmlsZU5hbWUpIHtcblxuICAgIGNvbnN0IGJsb2IgPSBkYXRhVXJpVG9CbG9iKGRhdGFVcmkpO1xuICAgIGRvd25sb2FkQmxvYihibG9iLCBmaWxlTmFtZSk7XG59O1xuXG4vLyBDb252ZXJ0IGFuIHVyaS1lbmNvZGVkIGRhdGEgY29tcG9uZW50IChwb3NzaWJseSBhbHNvIGJhc2U2NC1lbmNvZGVkKSB0byBhIGJsb2IuXG5leHBvcnQgY29uc3QgZGF0YVVyaVRvQmxvYiA9IGZ1bmN0aW9uKGRhdGFVcmkpIHtcblxuICAgIC8vIGZpcnN0LCBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG5ld2xpbmVzIGluIHRoZSBkYXRhIHVyaVxuICAgIGRhdGFVcmkgPSBkYXRhVXJpLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgZGF0YVVyaSA9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhVXJpKTtcblxuICAgIHZhciBmaXJzdENvbW1hSW5kZXggPSBkYXRhVXJpLmluZGV4T2YoJywnKTsgLy8gc3BsaXQgZGF0YVVyaSBhcyBgZGF0YVR5cGVTdHJpbmdgLGBkYXRhYFxuXG4gICAgdmFyIGRhdGFUeXBlU3RyaW5nID0gZGF0YVVyaS5zbGljZSgwLCBmaXJzdENvbW1hSW5kZXgpOyAvLyBlLmcuICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0J1xuICAgIHZhciBtaW1lU3RyaW5nID0gZGF0YVR5cGVTdHJpbmcuc3BsaXQoJzonKVsxXS5zcGxpdCgnOycpWzBdOyAvLyBlLmcuICdpbWFnZS9qcGVnJ1xuXG4gICAgdmFyIGRhdGEgPSBkYXRhVXJpLnNsaWNlKGZpcnN0Q29tbWFJbmRleCArIDEpO1xuICAgIHZhciBkZWNvZGVkU3RyaW5nO1xuICAgIGlmIChkYXRhVHlwZVN0cmluZy5pbmRleE9mKCdiYXNlNjQnKSA+PSAwKSB7IC8vIGRhdGEgbWF5IGJlIGVuY29kZWQgaW4gYmFzZTY0XG4gICAgICAgIGRlY29kZWRTdHJpbmcgPSBhdG9iKGRhdGEpOyAvLyBkZWNvZGUgZGF0YVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIGRlY29kZWQgc3RyaW5nIHRvIFVURi04XG4gICAgICAgIGRlY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xuICAgIH1cbiAgICAvLyB3cml0ZSB0aGUgYnl0ZXMgb2YgdGhlIHN0cmluZyB0byBhIHR5cGVkIGFycmF5XG4gICAgdmFyIGlhID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZFN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RlZFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpYVtpXSA9IGRlY29kZWRTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJsb2IoW2lhXSwgeyB0eXBlOiBtaW1lU3RyaW5nIH0pOyAvLyByZXR1cm4gdGhlIHR5cGVkIGFycmF5IGFzIEJsb2Jcbn07XG5cbi8vIFJlYWQgYW4gaW1hZ2UgYXQgYHVybGAgYW5kIHJldHVybiBpdCBhcyBiYXNlNjQtZW5jb2RlZCBkYXRhIHVyaS5cbi8vIFRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlIGlzIGluZmVycmVkIGZyb20gdGhlIGB1cmxgIGZpbGUgZXh0ZW5zaW9uLlxuLy8gSWYgZGF0YSB1cmkgaXMgcHJvdmlkZWQgYXMgYHVybGAsIGl0IGlzIHJldHVybmVkIGJhY2sgdW5jaGFuZ2VkLlxuLy8gYGNhbGxiYWNrYCBpcyBhIG1ldGhvZCB3aXRoIGBlcnJgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCBgZGF0YVVyaWAgYXMgc2Vjb25kIGFyZ3VtZW50LlxuLy8gV29ya3Mgd2l0aCBJRTkuXG5leHBvcnQgY29uc3QgaW1hZ2VUb0RhdGFVcmkgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXVybCB8fCB1cmwuc3Vic3RyKDAsICdkYXRhOicubGVuZ3RoKSA9PT0gJ2RhdGE6Jykge1xuICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnZlcnQgdG8gZGF0YSB1cmkgaWYgaXQgaXMgYWxyZWFkeSBpbiBkYXRhIHVyaS5cblxuICAgICAgICAvLyBUaGlzIG5vdCBvbmx5IGNvbnZlbmllbnQgYnV0IGRlc2lyZWQuIEZvciBleGFtcGxlLFxuICAgICAgICAvLyBJRSB0aHJvd3MgYSBzZWN1cml0eSBlcnJvciBpZiBkYXRhOmltYWdlL3N2Zyt4bWwgaXMgdXNlZCB0byByZW5kZXJcbiAgICAgICAgLy8gYW4gaW1hZ2UgdG8gdGhlIGNhbnZhcyBhbmQgYW4gYXR0ZW1wdCBpcyBtYWRlIHRvIHJlYWQgb3V0IGRhdGEgdXJpLlxuICAgICAgICAvLyBOb3cgaWYgb3VyIGltYWdlIGlzIGFscmVhZHkgaW4gZGF0YSB1cmksIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVuZGVyIGl0IHRvIHRoZSBjYW52YXNcbiAgICAgICAgLy8gYW5kIHNvIHdlIGNhbiBieXBhc3MgdGhpcyBlcnJvci5cblxuICAgICAgICAvLyBLZWVwIHRoZSBhc3luYyBuYXR1cmUgb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHVybCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8vIGNocm9tZSwgSUUxMCtcbiAgICB2YXIgbW9kZXJuSGFuZGxlciA9IGZ1bmN0aW9uKHhociwgY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG5cbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFVcmkgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhVXJpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSAnICsgdXJsKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTCh4aHIucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSAnICsgdXJsKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxlZ2FjeUhhbmRsZXIgPSBmdW5jdGlvbih4aHIsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdmFyIFVpbnQ4VG9TdHJpbmcgPSBmdW5jdGlvbih1OGEpIHtcbiAgICAgICAgICAgIHZhciBDSFVOS19TWiA9IDB4ODAwMDtcbiAgICAgICAgICAgIHZhciBjID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHU4YS5sZW5ndGg7IGkgKz0gQ0hVTktfU1opIHtcbiAgICAgICAgICAgICAgICBjLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1OGEuc3ViYXJyYXkoaSwgaSArIENIVU5LX1NaKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGMuam9pbignJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuXG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gKHVybC5zcGxpdCgnLicpLnBvcCgpKSB8fCAncG5nJztcbiAgICAgICAgICAgIHZhciBtYXAgPSB7XG4gICAgICAgICAgICAgICAgJ3N2Zyc6ICdzdmcreG1sJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBtZXRhID0gJ2RhdGE6aW1hZ2UvJyArIChtYXBbc3VmZml4XSB8fCBzdWZmaXgpICsgJztiYXNlNjQsJztcbiAgICAgICAgICAgIHZhciBiNjRlbmNvZGVkID0gbWV0YSArIGJ0b2EoVWludDhUb1N0cmluZyhieXRlcykpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYjY0ZW5jb2RlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGltYWdlICcgKyB1cmwpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSAnICsgdXJsKSk7XG4gICAgfSk7XG5cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gd2luZG93LkZpbGVSZWFkZXIgPyAnYmxvYicgOiAnYXJyYXlidWZmZXInO1xuXG4gICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5GaWxlUmVhZGVyKSB7XG4gICAgICAgICAgICBtb2Rlcm5IYW5kbGVyKHhociwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVnYWN5SGFuZGxlcih4aHIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgeGhyLnNlbmQoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QkJveCA9IGZ1bmN0aW9uKGVsKSB7XG5cbiAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgaWYgKCRlbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gJGVsWzBdO1xuICAgIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgdmFyIGNsaWVudEJCb3ggPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdmFyIHN0cm9rZVdpZHRoWCA9IDA7XG4gICAgdmFyIHN0cm9rZVdpZHRoWSA9IDA7XG5cbiAgICAvLyBGaXJlZm94IGNvcnJlY3Rpb25cbiAgICBpZiAoZWxlbWVudC5vd25lclNWR0VsZW1lbnQpIHtcblxuICAgICAgICB2YXIgdmVsID0gVihlbGVtZW50KTtcbiAgICAgICAgdmFyIGJib3ggPSB2ZWwuZ2V0QkJveCh7IHRhcmdldDogdmVsLnN2ZygpIH0pO1xuXG4gICAgICAgIC8vIGlmIEZGIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpbmNsdWRlcyBzdHJva2Utd2lkdGgsIGdldEJCb3ggZG9lc24ndC5cbiAgICAgICAgLy8gVG8gdW5pZnkgdGhpcyBhY3Jvc3MgYWxsIGJyb3dzZXJzIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBmaW5hbCBiQm94IHdpdGggYHN0cm9rZS13aWR0aGAgdmFsdWUuXG4gICAgICAgIHN0cm9rZVdpZHRoWCA9IChjbGllbnRCQm94LndpZHRoIC0gYmJveC53aWR0aCk7XG4gICAgICAgIHN0cm9rZVdpZHRoWSA9IChjbGllbnRCQm94LmhlaWdodCAtIGJib3guaGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBjbGllbnRCQm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkb2MuZG9jdW1lbnRFbGVtZW50Lm9mZnNldExlZnQgKyBzdHJva2VXaWR0aFggLyAyLFxuICAgICAgICB5OiBjbGllbnRCQm94LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0VG9wICsgc3Ryb2tlV2lkdGhZIC8gMixcbiAgICAgICAgd2lkdGg6IGNsaWVudEJCb3gud2lkdGggLSBzdHJva2VXaWR0aFgsXG4gICAgICAgIGhlaWdodDogY2xpZW50QkJveC5oZWlnaHQgLSBzdHJva2VXaWR0aFlcbiAgICB9O1xufTtcblxuXG4vLyBIaWdobHkgaW5zcGlyZWQgYnkgdGhlIGpxdWVyeS5zb3J0RWxlbWVudHMgcGx1Z2luIGJ5IFBhZG9sc2V5LlxuLy8gU2VlIGh0dHA6Ly9qYW1lcy5wYWRvbHNleS5jb20vamF2YXNjcmlwdC9zb3J0aW5nLWVsZW1lbnRzLXdpdGgtanF1ZXJ5Ly5cbmV4cG9ydCBjb25zdCBzb3J0RWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cywgY29tcGFyYXRvcikge1xuXG4gICAgZWxlbWVudHMgPSAkKGVsZW1lbnRzKS50b0FycmF5KCk7XG4gICAgdmFyIHBsYWNlbWVudHMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24oc29ydEVsZW1lbnQpIHtcblxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHNvcnRFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBlbGVtZW50IGl0c2VsZiB3aWxsIGNoYW5nZSBwb3NpdGlvbiwgd2UgaGF2ZVxuICAgICAgICAvLyB0byBoYXZlIHNvbWUgd2F5IG9mIHN0b3JpbmcgaXQncyBvcmlnaW5hbCBwb3NpdGlvbiBpblxuICAgICAgICAvLyB0aGUgRE9NLiBUaGUgZWFzaWVzdCB3YXkgaXMgdG8gaGF2ZSBhICdmbGFnJyBub2RlOlxuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBwYXJlbnROb2RlLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyksIHNvcnRFbGVtZW50Lm5leHRTaWJsaW5nKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuXFwndCBzb3J0IGVsZW1lbnRzIGlmIGFueSBvbmUgaXMgYSBkZXNjZW5kYW50IG9mIGFub3RoZXIuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCBiZWZvcmUgZmxhZzpcbiAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmbGFnOlxuICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXh0U2libGluZyk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBlbGVtZW50cy5zb3J0KGNvbXBhcmF0b3IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwbGFjZW1lbnRzW2ldLmNhbGwoZWxlbWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG59O1xuXG4vLyBTZXRzIGF0dHJpYnV0ZXMgb24gdGhlIGdpdmVuIGVsZW1lbnQgYW5kIGl0cyBkZXNjZW5kYW50cyBiYXNlZCBvbiB0aGUgc2VsZWN0b3IuXG4vLyBgYXR0cnNgIG9iamVjdDogeyBbU0VMRUNUT1IxXTogeyBhdHRyczEgfSwgW1NFTEVDVE9SMl06IHsgYXR0cnMyfSwgLi4uIH0gZS5nLiB7ICdpbnB1dCc6IHsgY29sb3IgOiAncmVkJyB9fVxuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZXNCeVNlbGVjdG9yID0gZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcblxuICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cbiAgICBmb3JJbihhdHRycywgZnVuY3Rpb24oYXR0cnMsIHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciAkZWxlbWVudHMgPSAkZWxlbWVudC5maW5kKHNlbGVjdG9yKS5hZGRCYWNrKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgICAgLy8gTWFrZSBhIHNwZWNpYWwgY2FzZSBmb3Igc2V0dGluZyBjbGFzc2VzLlxuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGNsYXNzLlxuICAgICAgICBpZiAoaGFzKGF0dHJzLCAnY2xhc3MnKSkge1xuICAgICAgICAgICAgJGVsZW1lbnRzLmFkZENsYXNzKGF0dHJzWydjbGFzcyddKTtcbiAgICAgICAgICAgIGF0dHJzID0gb21pdChhdHRycywgJ2NsYXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgJGVsZW1lbnRzLmF0dHIoYXR0cnMpO1xuICAgIH0pO1xufTtcblxuLy8gUmV0dXJuIGEgbmV3IG9iamVjdCB3aXRoIGFsbCBmb3VyIHNpZGVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpIGluIGl0LlxuLy8gVmFsdWUgb2YgZWFjaCBzaWRlIGlzIHRha2VuIGZyb20gdGhlIGdpdmVuIGFyZ3VtZW50IChlaXRoZXIgbnVtYmVyIG9yIG9iamVjdCkuXG4vLyBEZWZhdWx0IHZhbHVlIGZvciBhIHNpZGUgaXMgMC5cbi8vIEV4YW1wbGVzOlxuLy8gbm9ybWFsaXplU2lkZXMoNSkgLS0+IHsgdG9wOiA1LCByaWdodDogNSwgYm90dG9tOiA1LCBsZWZ0OiA1IH1cbi8vIG5vcm1hbGl6ZVNpZGVzKHsgaG9yaXpvbnRhbDogNSB9KSAtLT4geyB0b3A6IDAsIHJpZ2h0OiA1LCBib3R0b206IDAsIGxlZnQ6IDUgfVxuLy8gbm9ybWFsaXplU2lkZXMoeyBsZWZ0OiA1IH0pIC0tPiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogNSB9XG4vLyBub3JtYWxpemVTaWRlcyh7IGhvcml6b250YWw6IDEwLCBsZWZ0OiA1IH0pIC0tPiB7IHRvcDogMCwgcmlnaHQ6IDEwLCBib3R0b206IDAsIGxlZnQ6IDUgfVxuLy8gbm9ybWFsaXplU2lkZXMoeyBob3Jpem9udGFsOiAwLCBsZWZ0OiA1IH0pIC0tPiB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogNSB9XG5leHBvcnQgY29uc3Qgbm9ybWFsaXplU2lkZXMgPSBmdW5jdGlvbihib3gpIHtcblxuICAgIGlmIChPYmplY3QoYm94KSAhPT0gYm94KSB7IC8vIGBib3hgIGlzIG5vdCBhbiBvYmplY3RcbiAgICAgICAgdmFyIHZhbCA9IDA7IC8vIGB2YWxgIGxlZnQgYXMgMCBpZiBgYm94YCBjYW5ub3QgYmUgdW5kZXJzdG9vZCBhcyBmaW5pdGUgbnVtYmVyXG4gICAgICAgIGlmIChpc0Zpbml0ZShib3gpKSB2YWwgPSArYm94OyAvLyBhY3R1YWxseSBhbHNvIGFjY2VwdHMgc3RyaW5nIG51bWJlcnMgKGUuZy4gJzEwMCcpXG5cbiAgICAgICAgcmV0dXJuIHsgdG9wOiB2YWwsIHJpZ2h0OiB2YWwsIGJvdHRvbTogdmFsLCBsZWZ0OiB2YWwgfTtcbiAgICB9XG5cbiAgICAvLyBgYm94YCBpcyBhbiBvYmplY3RcbiAgICB2YXIgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0O1xuICAgIHRvcCA9IHJpZ2h0ID0gYm90dG9tID0gbGVmdCA9IDA7XG5cbiAgICBpZiAoaXNGaW5pdGUoYm94LnZlcnRpY2FsKSkgdG9wID0gYm90dG9tID0gK2JveC52ZXJ0aWNhbDtcbiAgICBpZiAoaXNGaW5pdGUoYm94Lmhvcml6b250YWwpKSByaWdodCA9IGxlZnQgPSArYm94Lmhvcml6b250YWw7XG5cbiAgICBpZiAoaXNGaW5pdGUoYm94LnRvcCkpIHRvcCA9ICtib3gudG9wOyAvLyBvdmVyd3JpdGUgdmVydGljYWxcbiAgICBpZiAoaXNGaW5pdGUoYm94LnJpZ2h0KSkgcmlnaHQgPSArYm94LnJpZ2h0OyAvLyBvdmVyd3JpdGUgaG9yaXpvbnRhbFxuICAgIGlmIChpc0Zpbml0ZShib3guYm90dG9tKSkgYm90dG9tID0gK2JveC5ib3R0b207IC8vIG92ZXJ3cml0ZSB2ZXJ0aWNhbFxuICAgIGlmIChpc0Zpbml0ZShib3gubGVmdCkpIGxlZnQgPSArYm94LmxlZnQ7IC8vIG92ZXJ3cml0ZSBob3Jpem9udGFsXG5cbiAgICByZXR1cm4geyB0b3A6IHRvcCwgcmlnaHQ6IHJpZ2h0LCBib3R0b206IGJvdHRvbSwgbGVmdDogbGVmdCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHRpbWluZyA9IHtcblxuICAgIGxpbmVhcjogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9LFxuXG4gICAgcXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCAqIHQ7XG4gICAgfSxcblxuICAgIGN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgfSxcblxuICAgIGlub3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDw9IDApIHJldHVybiAwO1xuICAgICAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICAgICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgICAgIHZhciB0MyA9IHQyICogdDtcbiAgICAgICAgcmV0dXJuIDQgKiAodCA8IC41ID8gdDMgOiAzICogKHQgLSB0MikgKyB0MyAtIC43NSk7XG4gICAgfSxcblxuICAgIGV4cG9uZW50aWFsOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgIH0sXG5cbiAgICBib3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgYSA9IDAsIGIgPSAxOyAxOyBhICs9IGIsIGIgLz0gMikge1xuICAgICAgICAgICAgaWYgKHQgPj0gKDcgLSA0ICogYSkgLyAxMSkge1xuICAgICAgICAgICAgICAgIHZhciBxID0gKDExIC0gNiAqIGEgLSAxMSAqIHQpIC8gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gLXEgKiBxICsgYiAqIGI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBmKDEgLSB0KTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVmbGVjdDogZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIC41ICogKHQgPCAuNSA/IGYoMiAqIHQpIDogKDIgLSBmKDIgLSAyICogdCkpKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgY2xhbXA6IGZ1bmN0aW9uKGYsIG4sIHgpIHtcbiAgICAgICAgbiA9IG4gfHwgMDtcbiAgICAgICAgeCA9IHggfHwgMTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciByID0gZih0KTtcbiAgICAgICAgICAgIHJldHVybiByIDwgbiA/IG4gOiByID4geCA/IHggOiByO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBiYWNrOiBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmICghcykgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZWxhc3RpYzogZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoIXgpIHggPSAxLjU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSAqIE1hdGguY29zKDIwICogTWF0aC5QSSAqIHggLyAzICogdCk7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGludGVycG9sYXRlID0ge1xuXG4gICAgbnVtYmVyOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHZhciBkID0gYiAtIGE7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gYSArIGQgKiB0O1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvYmplY3Q6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgdmFyIHMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIHZhciBpLCBwO1xuICAgICAgICAgICAgdmFyIHIgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IHMubGVuZ3RoIC0gMTsgaSAhPSAtMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcCA9IHNbaV07XG4gICAgICAgICAgICAgICAgcltwXSA9IGFbcF0gKyAoYltwXSAtIGFbcF0pICogdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBoZXhDb2xvcjogZnVuY3Rpb24oYSwgYikge1xuXG4gICAgICAgIHZhciBjYSA9IHBhcnNlSW50KGEuc2xpY2UoMSksIDE2KTtcbiAgICAgICAgdmFyIGNiID0gcGFyc2VJbnQoYi5zbGljZSgxKSwgMTYpO1xuICAgICAgICB2YXIgcmEgPSBjYSAmIDB4MDAwMGZmO1xuICAgICAgICB2YXIgcmQgPSAoY2IgJiAweDAwMDBmZikgLSByYTtcbiAgICAgICAgdmFyIGdhID0gY2EgJiAweDAwZmYwMDtcbiAgICAgICAgdmFyIGdkID0gKGNiICYgMHgwMGZmMDApIC0gZ2E7XG4gICAgICAgIHZhciBiYSA9IGNhICYgMHhmZjAwMDA7XG4gICAgICAgIHZhciBiZCA9IChjYiAmIDB4ZmYwMDAwKSAtIGJhO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG5cbiAgICAgICAgICAgIHZhciByID0gKHJhICsgcmQgKiB0KSAmIDB4MDAwMDAwZmY7XG4gICAgICAgICAgICB2YXIgZyA9IChnYSArIGdkICogdCkgJiAweDAwMDBmZjAwO1xuICAgICAgICAgICAgdmFyIGIgPSAoYmEgKyBiZCAqIHQpICYgMHgwMGZmMDAwMDtcblxuICAgICAgICAgICAgcmV0dXJuICcjJyArICgxIDw8IDI0IHwgciB8IGcgfCBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHVuaXQ6IGZ1bmN0aW9uKGEsIGIpIHtcblxuICAgICAgICB2YXIgciA9IC8oLT9bMC05XSouWzAtOV0qKShweHxlbXxjbXxtbXxpbnxwdHxwY3wlKS87XG4gICAgICAgIHZhciBtYSA9IHIuZXhlYyhhKTtcbiAgICAgICAgdmFyIG1iID0gci5leGVjKGIpO1xuICAgICAgICB2YXIgcCA9IG1iWzFdLmluZGV4T2YoJy4nKTtcbiAgICAgICAgdmFyIGYgPSBwID4gMCA/IG1iWzFdLmxlbmd0aCAtIHAgLSAxIDogMDtcbiAgICAgICAgYSA9ICttYVsxXTtcbiAgICAgICAgdmFyIGQgPSArbWJbMV0gLSBhO1xuICAgICAgICB2YXIgdSA9IG1hWzJdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgKyBkICogdCkudG9GaXhlZChmKSArIHU7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuLy8gU1ZHIGZpbHRlcnMuXG4vLyAodmFsdWVzIGluIHBhcmVudGhlc2VzIGFyZSBkZWZhdWx0IHZhbHVlcylcbmV4cG9ydCBjb25zdCBmaWx0ZXIgPSB7XG5cbiAgICAvLyBgY29sb3JgIC4uLiBvdXRsaW5lIGNvbG9yICgnYmx1ZScpXG4gICAgLy8gYHdpZHRoYC4uLiBvdXRsaW5lIHdpZHRoICgxKVxuICAgIC8vIGBvcGFjaXR5YCAuLi4gb3V0bGluZSBvcGFjaXR5ICgxKVxuICAgIC8vIGBtYXJnaW5gIC4uLiBnYXAgYmV0d2VlbiBvdXRsaW5lIGFuZCB0aGUgZWxlbWVudCAoMilcbiAgICBvdXRsaW5lOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIHRwbCA9ICc8ZmlsdGVyPjxmZUZsb29kIGZsb29kLWNvbG9yPVwiJHtjb2xvcn1cIiBmbG9vZC1vcGFjaXR5PVwiJHtvcGFjaXR5fVwiIHJlc3VsdD1cImNvbG9yZWRcIi8+PGZlTW9ycGhvbG9neSBpbj1cIlNvdXJjZUFscGhhXCIgcmVzdWx0PVwibW9ycGhlZE91dGVyXCIgb3BlcmF0b3I9XCJkaWxhdGVcIiByYWRpdXM9XCIke291dGVyUmFkaXVzfVwiIC8+PGZlTW9ycGhvbG9neSBpbj1cIlNvdXJjZUFscGhhXCIgcmVzdWx0PVwibW9ycGhlZElubmVyXCIgb3BlcmF0b3I9XCJkaWxhdGVcIiByYWRpdXM9XCIke2lubmVyUmFkaXVzfVwiIC8+PGZlQ29tcG9zaXRlIHJlc3VsdD1cIm1vcnBoZWRPdXRlckNvbG9yZWRcIiBpbj1cImNvbG9yZWRcIiBpbjI9XCJtb3JwaGVkT3V0ZXJcIiBvcGVyYXRvcj1cImluXCIvPjxmZUNvbXBvc2l0ZSBvcGVyYXRvcj1cInhvclwiIGluPVwibW9ycGhlZE91dGVyQ29sb3JlZFwiIGluMj1cIm1vcnBoZWRJbm5lclwiIHJlc3VsdD1cIm91dGxpbmVcIi8+PGZlTWVyZ2U+PGZlTWVyZ2VOb2RlIGluPVwib3V0bGluZVwiLz48ZmVNZXJnZU5vZGUgaW49XCJTb3VyY2VHcmFwaGljXCIvPjwvZmVNZXJnZT48L2ZpbHRlcj4nO1xuXG4gICAgICAgIHZhciBtYXJnaW4gPSBOdW1iZXIuaXNGaW5pdGUoYXJncy5tYXJnaW4pID8gYXJncy5tYXJnaW4gOiAyO1xuICAgICAgICB2YXIgd2lkdGggPSBOdW1iZXIuaXNGaW5pdGUoYXJncy53aWR0aCkgPyBhcmdzLndpZHRoIDogMTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUodHBsKSh7XG4gICAgICAgICAgICBjb2xvcjogYXJncy5jb2xvciB8fCAnYmx1ZScsXG4gICAgICAgICAgICBvcGFjaXR5OiBOdW1iZXIuaXNGaW5pdGUoYXJncy5vcGFjaXR5KSA/IGFyZ3Mub3BhY2l0eSA6IDEsXG4gICAgICAgICAgICBvdXRlclJhZGl1czogbWFyZ2luICsgd2lkdGgsXG4gICAgICAgICAgICBpbm5lclJhZGl1czogbWFyZ2luXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgY29sb3JgIC4uLiBjb2xvciAoJ3JlZCcpXG4gICAgLy8gYHdpZHRoYC4uLiB3aWR0aCAoMSlcbiAgICAvLyBgYmx1cmAgLi4uIGJsdXIgKDApXG4gICAgLy8gYG9wYWNpdHlgIC4uLiBvcGFjaXR5ICgxKVxuICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciB0cGwgPSAnPGZpbHRlcj48ZmVGbG9vZCBmbG9vZC1jb2xvcj1cIiR7Y29sb3J9XCIgZmxvb2Qtb3BhY2l0eT1cIiR7b3BhY2l0eX1cIiByZXN1bHQ9XCJjb2xvcmVkXCIvPjxmZU1vcnBob2xvZ3kgcmVzdWx0PVwibW9ycGhlZFwiIGluPVwiU291cmNlR3JhcGhpY1wiIG9wZXJhdG9yPVwiZGlsYXRlXCIgcmFkaXVzPVwiJHt3aWR0aH1cIi8+PGZlQ29tcG9zaXRlIHJlc3VsdD1cImNvbXBvc2VkXCIgaW49XCJjb2xvcmVkXCIgaW4yPVwibW9ycGhlZFwiIG9wZXJhdG9yPVwiaW5cIi8+PGZlR2F1c3NpYW5CbHVyIHJlc3VsdD1cImJsdXJlZFwiIGluPVwiY29tcG9zZWRcIiBzdGREZXZpYXRpb249XCIke2JsdXJ9XCIvPjxmZUJsZW5kIGluPVwiU291cmNlR3JhcGhpY1wiIGluMj1cImJsdXJlZFwiIG1vZGU9XCJub3JtYWxcIi8+PC9maWx0ZXI+JztcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUodHBsKSh7XG4gICAgICAgICAgICBjb2xvcjogYXJncy5jb2xvciB8fCAncmVkJyxcbiAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIuaXNGaW5pdGUoYXJncy53aWR0aCkgPyBhcmdzLndpZHRoIDogMSxcbiAgICAgICAgICAgIGJsdXI6IE51bWJlci5pc0Zpbml0ZShhcmdzLmJsdXIpID8gYXJncy5ibHVyIDogMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IE51bWJlci5pc0Zpbml0ZShhcmdzLm9wYWNpdHkpID8gYXJncy5vcGFjaXR5IDogMVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYHhgIC4uLiBob3Jpem9udGFsIGJsdXIgKDIpXG4gICAgLy8gYHlgIC4uLiB2ZXJ0aWNhbCBibHVyIChvcHRpb25hbClcbiAgICBibHVyOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIHggPSBOdW1iZXIuaXNGaW5pdGUoYXJncy54KSA/IGFyZ3MueCA6IDI7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249XCIke3N0ZERldmlhdGlvbn1cIi8+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgc3RkRGV2aWF0aW9uOiBOdW1iZXIuaXNGaW5pdGUoYXJncy55KSA/IFt4LCBhcmdzLnldIDogeFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGR4YCAuLi4gaG9yaXpvbnRhbCBzaGlmdCAoMClcbiAgICAvLyBgZHlgIC4uLiB2ZXJ0aWNhbCBzaGlmdCAoMClcbiAgICAvLyBgYmx1cmAgLi4uIGJsdXIgKDQpXG4gICAgLy8gYGNvbG9yYCAuLi4gY29sb3IgKCdibGFjaycpXG4gICAgLy8gYG9wYWNpdHlgIC4uLiBvcGFjaXR5ICgxKVxuICAgIGRyb3BTaGFkb3c6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgdHBsID0gJ1NWR0ZFRHJvcFNoYWRvd0VsZW1lbnQnIGluIHdpbmRvd1xuICAgICAgICAgICAgPyAnPGZpbHRlcj48ZmVEcm9wU2hhZG93IHN0ZERldmlhdGlvbj1cIiR7Ymx1cn1cIiBkeD1cIiR7ZHh9XCIgZHk9XCIke2R5fVwiIGZsb29kLWNvbG9yPVwiJHtjb2xvcn1cIiBmbG9vZC1vcGFjaXR5PVwiJHtvcGFjaXR5fVwiLz48L2ZpbHRlcj4nXG4gICAgICAgICAgICA6ICc8ZmlsdGVyPjxmZUdhdXNzaWFuQmx1ciBpbj1cIlNvdXJjZUFscGhhXCIgc3RkRGV2aWF0aW9uPVwiJHtibHVyfVwiLz48ZmVPZmZzZXQgZHg9XCIke2R4fVwiIGR5PVwiJHtkeX1cIiByZXN1bHQ9XCJvZmZzZXRibHVyXCIvPjxmZUZsb29kIGZsb29kLWNvbG9yPVwiJHtjb2xvcn1cIi8+PGZlQ29tcG9zaXRlIGluMj1cIm9mZnNldGJsdXJcIiBvcGVyYXRvcj1cImluXCIvPjxmZUNvbXBvbmVudFRyYW5zZmVyPjxmZUZ1bmNBIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7b3BhY2l0eX1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPjxmZU1lcmdlPjxmZU1lcmdlTm9kZS8+PGZlTWVyZ2VOb2RlIGluPVwiU291cmNlR3JhcGhpY1wiLz48L2ZlTWVyZ2U+PC9maWx0ZXI+JztcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUodHBsKSh7XG4gICAgICAgICAgICBkeDogYXJncy5keCB8fCAwLFxuICAgICAgICAgICAgZHk6IGFyZ3MuZHkgfHwgMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IE51bWJlci5pc0Zpbml0ZShhcmdzLm9wYWNpdHkpID8gYXJncy5vcGFjaXR5IDogMSxcbiAgICAgICAgICAgIGNvbG9yOiBhcmdzLmNvbG9yIHx8ICdibGFjaycsXG4gICAgICAgICAgICBibHVyOiBOdW1iZXIuaXNGaW5pdGUoYXJncy5ibHVyKSA/IGFyZ3MuYmx1ciA6IDRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbW91bnRgIC4uLiB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgY29udmVyc2lvbiAoMSkuIEEgdmFsdWUgb2YgMSAoZGVmYXVsdCkgaXMgY29tcGxldGVseSBncmF5c2NhbGUuIEEgdmFsdWUgb2YgMCBsZWF2ZXMgdGhlIGlucHV0IHVuY2hhbmdlZC5cbiAgICBncmF5c2NhbGU6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgYW1vdW50ID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MuYW1vdW50KSA/IGFyZ3MuYW1vdW50IDogMTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29sb3JNYXRyaXggdHlwZT1cIm1hdHJpeFwiIHZhbHVlcz1cIiR7YX0gJHtifSAke2N9IDAgMCAke2R9ICR7ZX0gJHtmfSAwIDAgJHtnfSAke2J9ICR7aH0gMCAwIDAgMCAwIDEgMFwiLz48L2ZpbHRlcj4nKSh7XG4gICAgICAgICAgICBhOiAwLjIxMjYgKyAwLjc4NzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBiOiAwLjcxNTIgLSAwLjcxNTIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjA3MjIgLSAwLjA3MjIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBkOiAwLjIxMjYgLSAwLjIxMjYgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBlOiAwLjcxNTIgKyAwLjI4NDggKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjA3MjIgLSAwLjA3MjIgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBnOiAwLjIxMjYgLSAwLjIxMjYgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBoOiAwLjA3MjIgKyAwLjkyNzggKiAoMSAtIGFtb3VudClcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbW91bnRgIC4uLiB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgY29udmVyc2lvbiAoMSkuIEEgdmFsdWUgb2YgMSAoZGVmYXVsdCkgaXMgY29tcGxldGVseSBzZXBpYS4gQSB2YWx1ZSBvZiAwIGxlYXZlcyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgIHNlcGlhOiBmdW5jdGlvbihhcmdzKSB7XG5cbiAgICAgICAgdmFyIGFtb3VudCA9IE51bWJlci5pc0Zpbml0ZShhcmdzLmFtb3VudCkgPyBhcmdzLmFtb3VudCA6IDE7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKCc8ZmlsdGVyPjxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiB2YWx1ZXM9XCIke2F9ICR7Yn0gJHtjfSAwIDAgJHtkfSAke2V9ICR7Zn0gMCAwICR7Z30gJHtofSAke2l9IDAgMCAwIDAgMCAxIDBcIi8+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYTogMC4zOTMgKyAwLjYwNyAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGI6IDAuNzY5IC0gMC43NjkgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBjOiAwLjE4OSAtIDAuMTg5ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZDogMC4zNDkgLSAwLjM0OSAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGU6IDAuNjg2ICsgMC4zMTQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBmOiAwLjE2OCAtIDAuMTY4ICogKDEgLSBhbW91bnQpLFxuICAgICAgICAgICAgZzogMC4yNzIgLSAwLjI3MiAqICgxIC0gYW1vdW50KSxcbiAgICAgICAgICAgIGg6IDAuNTM0IC0gMC41MzQgKiAoMSAtIGFtb3VudCksXG4gICAgICAgICAgICBpOiAwLjEzMSArIDAuODY5ICogKDEgLSBhbW91bnQpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW1vdW50YCAuLi4gdGhlIHByb3BvcnRpb24gb2YgdGhlIGNvbnZlcnNpb24gKDEpLiBBIHZhbHVlIG9mIDAgaXMgY29tcGxldGVseSB1bi1zYXR1cmF0ZWQuIEEgdmFsdWUgb2YgMSAoZGVmYXVsdCkgbGVhdmVzIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gICAgc2F0dXJhdGU6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgYW1vdW50ID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MuYW1vdW50KSA/IGFyZ3MuYW1vdW50IDogMTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29sb3JNYXRyaXggdHlwZT1cInNhdHVyYXRlXCIgdmFsdWVzPVwiJHthbW91bnR9XCIvPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGFtb3VudDogMSAtIGFtb3VudFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gYGFuZ2xlYCAuLi4gIHRoZSBudW1iZXIgb2YgZGVncmVlcyBhcm91bmQgdGhlIGNvbG9yIGNpcmNsZSB0aGUgaW5wdXQgc2FtcGxlcyB3aWxsIGJlIGFkanVzdGVkICgwKS5cbiAgICBodWVSb3RhdGU6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29sb3JNYXRyaXggdHlwZT1cImh1ZVJvdGF0ZVwiIHZhbHVlcz1cIiR7YW5nbGV9XCIvPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGFuZ2xlOiBhcmdzLmFuZ2xlIHx8IDBcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGBhbW91bnRgIC4uLiB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgY29udmVyc2lvbiAoMSkuIEEgdmFsdWUgb2YgMSAoZGVmYXVsdCkgaXMgY29tcGxldGVseSBpbnZlcnRlZC4gQSB2YWx1ZSBvZiAwIGxlYXZlcyB0aGUgaW5wdXQgdW5jaGFuZ2VkLlxuICAgIGludmVydDogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHZhciBhbW91bnQgPSBOdW1iZXIuaXNGaW5pdGUoYXJncy5hbW91bnQpID8gYXJncy5hbW91bnQgOiAxO1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwidGFibGVcIiB0YWJsZVZhbHVlcz1cIiR7YW1vdW50fSAke2Ftb3VudDJ9XCIvPjxmZUZ1bmNHIHR5cGU9XCJ0YWJsZVwiIHRhYmxlVmFsdWVzPVwiJHthbW91bnR9ICR7YW1vdW50Mn1cIi8+PGZlRnVuY0IgdHlwZT1cInRhYmxlXCIgdGFibGVWYWx1ZXM9XCIke2Ftb3VudH0gJHthbW91bnQyfVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBhbW91bnQyOiAxIC0gYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW1vdW50YCAuLi4gcHJvcG9ydGlvbiBvZiB0aGUgY29udmVyc2lvbiAoMSkuIEEgdmFsdWUgb2YgMCB3aWxsIGNyZWF0ZSBhbiBpbWFnZSB0aGF0IGlzIGNvbXBsZXRlbHkgYmxhY2suIEEgdmFsdWUgb2YgMSAoZGVmYXVsdCkgbGVhdmVzIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gICAgYnJpZ2h0bmVzczogZnVuY3Rpb24oYXJncykge1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSgnPGZpbHRlcj48ZmVDb21wb25lbnRUcmFuc2Zlcj48ZmVGdW5jUiB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke2Ftb3VudH1cIi8+PGZlRnVuY0cgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHthbW91bnR9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7YW1vdW50fVwiLz48L2ZlQ29tcG9uZW50VHJhbnNmZXI+PC9maWx0ZXI+Jykoe1xuICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIuaXNGaW5pdGUoYXJncy5hbW91bnQpID8gYXJncy5hbW91bnQgOiAxXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBgYW1vdW50YCAuLi4gcHJvcG9ydGlvbiBvZiB0aGUgY29udmVyc2lvbiAoMSkuIEEgdmFsdWUgb2YgMCB3aWxsIGNyZWF0ZSBhbiBpbWFnZSB0aGF0IGlzIGNvbXBsZXRlbHkgYmxhY2suIEEgdmFsdWUgb2YgMSAoZGVmYXVsdCkgbGVhdmVzIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gICAgY29udHJhc3Q6IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgICAgICB2YXIgYW1vdW50ID0gTnVtYmVyLmlzRmluaXRlKGFyZ3MuYW1vdW50KSA/IGFyZ3MuYW1vdW50IDogMTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoJzxmaWx0ZXI+PGZlQ29tcG9uZW50VHJhbnNmZXI+PGZlRnVuY1IgdHlwZT1cImxpbmVhclwiIHNsb3BlPVwiJHthbW91bnR9XCIgaW50ZXJjZXB0PVwiJHthbW91bnQyfVwiLz48ZmVGdW5jRyB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIke2Ftb3VudH1cIiBpbnRlcmNlcHQ9XCIke2Ftb3VudDJ9XCIvPjxmZUZ1bmNCIHR5cGU9XCJsaW5lYXJcIiBzbG9wZT1cIiR7YW1vdW50fVwiIGludGVyY2VwdD1cIiR7YW1vdW50Mn1cIi8+PC9mZUNvbXBvbmVudFRyYW5zZmVyPjwvZmlsdGVyPicpKHtcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgYW1vdW50MjogLjUgLSBhbW91bnQgLyAyXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXQgPSB7XG5cbiAgICAvLyBGb3JtYXR0aW5nIG51bWJlcnMgdmlhIHRoZSBQeXRob24gRm9ybWF0IFNwZWNpZmljYXRpb24gTWluaS1sYW5ndWFnZS5cbiAgICAvLyBTZWUgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9yZWxlYXNlLzMuMS4zL2xpYnJhcnkvc3RyaW5nLmh0bWwjZm9ybWF0LXNwZWNpZmljYXRpb24tbWluaS1sYW5ndWFnZS5cbiAgICAvLyBIZWF2aWxseSBpbnNwaXJlZCBieSB0aGUgRDMuanMgbGlicmFyeSBpbXBsZW1lbnRhdGlvbi5cbiAgICBudW1iZXI6IGZ1bmN0aW9uKHNwZWNpZmllciwgdmFsdWUsIGxvY2FsZSkge1xuXG4gICAgICAgIGxvY2FsZSA9IGxvY2FsZSB8fCB7XG5cbiAgICAgICAgICAgIGN1cnJlbmN5OiBbJyQnLCAnJ10sXG4gICAgICAgICAgICBkZWNpbWFsOiAnLicsXG4gICAgICAgICAgICB0aG91c2FuZHM6ICcsJyxcbiAgICAgICAgICAgIGdyb3VwaW5nOiBbM11cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZWUgUHl0aG9uIGZvcm1hdCBzcGVjaWZpY2F0aW9uIG1pbmktbGFuZ3VhZ2U6IGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvcmVsZWFzZS8zLjEuMy9saWJyYXJ5L3N0cmluZy5odG1sI2Zvcm1hdC1zcGVjaWZpY2F0aW9uLW1pbmktbGFuZ3VhZ2UuXG4gICAgICAgIC8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bdHlwZV1cbiAgICAgICAgdmFyIHJlID0gLyg/OihbXntdKT8oWzw+PV5dKSk/KFsrXFwtIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuLT9cXGQrKT8oW2EteiVdKT8vaTtcblxuICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcik7XG4gICAgICAgIHZhciBmaWxsID0gbWF0Y2hbMV0gfHwgJyAnO1xuICAgICAgICB2YXIgYWxpZ24gPSBtYXRjaFsyXSB8fCAnPic7XG4gICAgICAgIHZhciBzaWduID0gbWF0Y2hbM10gfHwgJyc7XG4gICAgICAgIHZhciBzeW1ib2wgPSBtYXRjaFs0XSB8fCAnJztcbiAgICAgICAgdmFyIHpmaWxsID0gbWF0Y2hbNV07XG4gICAgICAgIHZhciB3aWR0aCA9ICttYXRjaFs2XTtcbiAgICAgICAgdmFyIGNvbW1hID0gbWF0Y2hbN107XG4gICAgICAgIHZhciBwcmVjaXNpb24gPSBtYXRjaFs4XTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFs5XTtcbiAgICAgICAgdmFyIHNjYWxlID0gMTtcbiAgICAgICAgdmFyIHByZWZpeCA9ICcnO1xuICAgICAgICB2YXIgc3VmZml4ID0gJyc7XG4gICAgICAgIHZhciBpbnRlZ2VyID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHByZWNpc2lvbikgcHJlY2lzaW9uID0gK3ByZWNpc2lvbi5zdWJzdHJpbmcoMSk7XG5cbiAgICAgICAgaWYgKHpmaWxsIHx8IGZpbGwgPT09ICcwJyAmJiBhbGlnbiA9PT0gJz0nKSB7XG4gICAgICAgICAgICB6ZmlsbCA9IGZpbGwgPSAnMCc7XG4gICAgICAgICAgICBhbGlnbiA9ICc9JztcbiAgICAgICAgICAgIGlmIChjb21tYSkgd2lkdGggLT0gTWF0aC5mbG9vcigod2lkdGggLSAxKSAvIDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICBjb21tYSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIHNjYWxlID0gMTAwO1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9ICclJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gJyUnO1xuICAgICAgICAgICAgICAgIHR5cGUgPSAncic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSAnIycpIHByZWZpeCA9ICcwJyArIHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgaW50ZWdlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgIHNjYWxlID0gLTE7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzeW1ib2wgPT09ICckJykge1xuICAgICAgICAgICAgcHJlZml4ID0gbG9jYWxlLmN1cnJlbmN5WzBdO1xuICAgICAgICAgICAgc3VmZml4ID0gbG9jYWxlLmN1cnJlbmN5WzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgbm8gcHJlY2lzaW9uIGlzIHNwZWNpZmllZCBmb3IgYCdyJ2AsIGZhbGxiYWNrIHRvIGdlbmVyYWwgbm90YXRpb24uXG4gICAgICAgIGlmICh0eXBlID09ICdyJyAmJiAhcHJlY2lzaW9uKSB0eXBlID0gJ2cnO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSByZXF1ZXN0ZWQgcHJlY2lzaW9uIGlzIGluIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgICAgIGlmIChwcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2cnKSBwcmVjaXNpb24gPSBNYXRoLm1heCgxLCBNYXRoLm1pbigyMSwgcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09ICdlJyB8fCB0eXBlID09ICdmJykgcHJlY2lzaW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpjb21tYSA9IHpmaWxsICYmIGNvbW1hO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgZW1wdHkgc3RyaW5nIGZvciBmbG9hdHMgZm9ybWF0dGVkIGFzIGludHMuXG4gICAgICAgIGlmIChpbnRlZ2VyICYmICh2YWx1ZSAlIDEpKSByZXR1cm4gJyc7XG5cbiAgICAgICAgLy8gQ29udmVydCBuZWdhdGl2ZSB0byBwb3NpdGl2ZSwgYW5kIHJlY29yZCB0aGUgc2lnbiBwcmVmaXguXG4gICAgICAgIHZhciBuZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gKHZhbHVlID0gLXZhbHVlLCAnLScpIDogc2lnbjtcblxuICAgICAgICB2YXIgZnVsbFN1ZmZpeCA9IHN1ZmZpeDtcblxuICAgICAgICAvLyBBcHBseSB0aGUgc2NhbGUsIGNvbXB1dGluZyBpdCBmcm9tIHRoZSB2YWx1ZSdzIGV4cG9uZW50IGZvciBzaSBmb3JtYXQuXG4gICAgICAgIC8vIFByZXNlcnZlIHRoZSBleGlzdGluZyBzdWZmaXgsIGlmIGFueSwgc3VjaCBhcyB0aGUgY3VycmVuY3kgc3ltYm9sLlxuICAgICAgICBpZiAoc2NhbGUgPCAwKSB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IHRoaXMucHJlZml4KHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgdmFsdWUgPSB1bml0LnNjYWxlKHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bGxTdWZmaXggPSB1bml0LnN5bWJvbCArIHN1ZmZpeDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICo9IHNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB0byB0aGUgZGVzaXJlZCBwcmVjaXNpb24uXG4gICAgICAgIHZhbHVlID0gdGhpcy5jb252ZXJ0KHR5cGUsIHZhbHVlLCBwcmVjaXNpb24pO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSB2YWx1ZSBpbnRvIHRoZSBpbnRlZ2VyIHBhcnQgKGJlZm9yZSkgYW5kIGRlY2ltYWwgcGFydCAoYWZ0ZXIpLlxuICAgICAgICB2YXIgaSA9IHZhbHVlLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgIHZhciBiZWZvcmUgPSBpIDwgMCA/IHZhbHVlIDogdmFsdWUuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICB2YXIgYWZ0ZXIgPSBpIDwgMCA/ICcnIDogbG9jYWxlLmRlY2ltYWwgKyB2YWx1ZS5zdWJzdHJpbmcoaSArIDEpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdEdyb3VwKHZhbHVlKSB7XG5cbiAgICAgICAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHQgPSBbXTtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIHZhciBnID0gbG9jYWxlLmdyb3VwaW5nWzBdO1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgICAgICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICAgICAgICAgICAgZyA9IGxvY2FsZS5ncm91cGluZ1tqID0gKGogKyAxKSAlIGxvY2FsZS5ncm91cGluZy5sZW5ndGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4obG9jYWxlLnRob3VzYW5kcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IGAnMCdgLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgICBpZiAoIXpmaWxsICYmIGNvbW1hICYmIGxvY2FsZS5ncm91cGluZykge1xuXG4gICAgICAgICAgICBiZWZvcmUgPSBmb3JtYXRHcm91cChiZWZvcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHByZWZpeC5sZW5ndGggKyBiZWZvcmUubGVuZ3RoICsgYWZ0ZXIubGVuZ3RoICsgKHpjb21tYSA/IDAgOiBuZWdhdGl2ZS5sZW5ndGgpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KGxlbmd0aCA9IHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6ICcnO1xuXG4gICAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBgJzAnYCwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgICBpZiAoemNvbW1hKSBiZWZvcmUgPSBmb3JtYXRHcm91cChwYWRkaW5nICsgYmVmb3JlKTtcblxuICAgICAgICAvLyBBcHBseSBwcmVmaXguXG4gICAgICAgIG5lZ2F0aXZlICs9IHByZWZpeDtcblxuICAgICAgICAvLyBSZWpvaW4gaW50ZWdlciBhbmQgZGVjaW1hbCBwYXJ0cy5cbiAgICAgICAgdmFsdWUgPSBiZWZvcmUgKyBhZnRlcjtcblxuICAgICAgICByZXR1cm4gKGFsaWduID09PSAnPCcgPyBuZWdhdGl2ZSArIHZhbHVlICsgcGFkZGluZ1xuICAgICAgICAgICAgOiBhbGlnbiA9PT0gJz4nID8gcGFkZGluZyArIG5lZ2F0aXZlICsgdmFsdWVcbiAgICAgICAgICAgICAgICA6IGFsaWduID09PSAnXicgPyBwYWRkaW5nLnN1YnN0cmluZygwLCBsZW5ndGggPj49IDEpICsgbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmcuc3Vic3RyaW5nKGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgOiBuZWdhdGl2ZSArICh6Y29tbWEgPyB2YWx1ZSA6IHBhZGRpbmcgKyB2YWx1ZSkpICsgZnVsbFN1ZmZpeDtcbiAgICB9LFxuXG4gICAgLy8gRm9ybWF0dGluZyBzdHJpbmcgdmlhIHRoZSBQeXRob24gRm9ybWF0IHN0cmluZy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L3N0cmluZy5odG1sI2Zvcm1hdC1zdHJpbmctc3ludGF4KVxuICAgIHN0cmluZzogZnVuY3Rpb24oZm9ybWF0U3RyaW5nLCB2YWx1ZSkge1xuXG4gICAgICAgIHZhciBmaWVsZERlbGltaXRlckluZGV4O1xuICAgICAgICB2YXIgZmllbGREZWxpbWl0ZXIgPSAneyc7XG4gICAgICAgIHZhciBlbmRQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgICB2YXIgZm9ybWF0dGVkU3RyaW5nQXJyYXkgPSBbXTtcblxuICAgICAgICB3aGlsZSAoKGZpZWxkRGVsaW1pdGVySW5kZXggPSBmb3JtYXRTdHJpbmcuaW5kZXhPZihmaWVsZERlbGltaXRlcikpICE9PSAtMSkge1xuXG4gICAgICAgICAgICB2YXIgcGllY2VGb3JtYXR0ZWRTdHJpbmcsIGZvcm1hdFNwZWMsIGZpZWxkTmFtZTtcblxuICAgICAgICAgICAgcGllY2VGb3JtYXR0ZWRTdHJpbmcgPSBmb3JtYXRTdHJpbmcuc2xpY2UoMCwgZmllbGREZWxpbWl0ZXJJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChlbmRQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgIGZvcm1hdFNwZWMgPSBwaWVjZUZvcm1hdHRlZFN0cmluZy5zcGxpdCgnOicpO1xuICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZvcm1hdFNwZWMuc2hpZnQoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIHBpZWNlRm9ybWF0dGVkU3RyaW5nID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgcGllY2VGb3JtYXR0ZWRTdHJpbmcgPSBwaWVjZUZvcm1hdHRlZFN0cmluZ1tmaWVsZE5hbWVbaV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdFNwZWMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBwaWVjZUZvcm1hdHRlZFN0cmluZyA9IHRoaXMubnVtYmVyKGZvcm1hdFNwZWMsIHBpZWNlRm9ybWF0dGVkU3RyaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0dGVkU3RyaW5nQXJyYXkucHVzaChwaWVjZUZvcm1hdHRlZFN0cmluZyk7XG5cbiAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9IGZvcm1hdFN0cmluZy5zbGljZShmaWVsZERlbGltaXRlckluZGV4ICsgMSk7XG4gICAgICAgICAgICBlbmRQbGFjZWhvbGRlciA9ICFlbmRQbGFjZWhvbGRlcjtcbiAgICAgICAgICAgIGZpZWxkRGVsaW1pdGVyID0gKGVuZFBsYWNlaG9sZGVyKSA/ICd9JyA6ICd7JztcbiAgICAgICAgfVxuICAgICAgICBmb3JtYXR0ZWRTdHJpbmdBcnJheS5wdXNoKGZvcm1hdFN0cmluZyk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFN0cmluZ0FycmF5LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBjb252ZXJ0OiBmdW5jdGlvbih0eXBlLCB2YWx1ZSwgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoMik7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoOCk7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvUHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9FeHBvbmVudGlhbChwcmVjaXNpb24pO1xuICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPSB0aGlzLnJvdW5kKHZhbHVlLCB0aGlzLnByZWNpc2lvbih2YWx1ZSwgcHJlY2lzaW9uKSkpLnRvRml4ZWQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHRoaXMucHJlY2lzaW9uKHZhbHVlICogKDEgKyAxZS0xNSksIHByZWNpc2lvbikpKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJvdW5kOiBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG5cbiAgICAgICAgcmV0dXJuIHByZWNpc2lvblxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKHZhbHVlICogKHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pKSkgLyBwcmVjaXNpb25cbiAgICAgICAgICAgIDogTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIHByZWNpc2lvbjogZnVuY3Rpb24odmFsdWUsIHByZWNpc2lvbikge1xuXG4gICAgICAgIHJldHVybiBwcmVjaXNpb24gLSAodmFsdWUgPyBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwKSA6IDEpO1xuICAgIH0sXG5cbiAgICBwcmVmaXg6IGZ1bmN0aW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcblxuICAgICAgICB2YXIgcHJlZml4ZXMgPSBbJ3knLCAneicsICdhJywgJ2YnLCAncCcsICduJywgJ8K1JywgJ20nLCAnJywgJ2snLCAnTScsICdHJywgJ1QnLCAnUCcsICdFJywgJ1onLCAnWSddLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICB2YXIgayA9IE1hdGgucG93KDEwLCBNYXRoLmFicyg4IC0gaSkgKiAzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NhbGU6IGkgPiA4ID8gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZCAvIGs7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQgKiBrO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgKj0gLTE7XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uKSB2YWx1ZSA9IHRoaXMucm91bmQodmFsdWUsIHRoaXMucHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgIGkgPSAxICsgTWF0aC5mbG9vcigxZS0xMiArIE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCk7XG4gICAgICAgICAgICBpID0gTWF0aC5tYXgoLTI0LCBNYXRoLm1pbigyNCwgTWF0aC5mbG9vcigoaSA8PSAwID8gaSArIDEgOiBpIC0gMSkgLyAzKSAqIDMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ZXNbOCArIGkgLyAzXTtcbiAgICB9XG59O1xuXG4vKlxuICAgIFByZS1jb21waWxlIHRoZSBIVE1MIHRvIGJlIHVzZWQgYXMgYSB0ZW1wbGF0ZS5cbiovXG5leHBvcnQgY29uc3QgdGVtcGxhdGUgPSBmdW5jdGlvbihodG1sKSB7XG5cbiAgICAvKlxuICAgICAgICBNdXN0IHN1cHBvcnQgdGhlIHZhcmlhdGlvbiBpbiB0ZW1wbGF0aW5nIHN5bnRheCBmb3VuZCBoZXJlOlxuICAgICAgICBodHRwczovL2xvZGFzaC5jb20vZG9jcyN0ZW1wbGF0ZVxuICAgICovXG4gICAgdmFyIHJlZ2V4ID0gLzwlPSAoW14gXSspICU+fFxcJFxceyA/KFtee30gXSspID9cXH18XFx7XFx7KFtee30gXSspXFx9XFx9L2c7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoKSB7XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkuZnJvbShhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGF0dHIgPSBhcmdzLnNsaWNlKDEsIDQpLmZpbmQoZnVuY3Rpb24oX2F0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFfYXR0cjtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgYXR0ckFycmF5ID0gYXR0ci5zcGxpdCgnLicpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVthdHRyQXJyYXkuc2hpZnQoKV07XG5cbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGF0dHJBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW2F0dHJBcnJheS5zaGlmdCgpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6ICcnO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQsIHdoaWNoIGNvbnRlbnQgaXMgaW50ZW50IHRvIGRpc3BsYXkgaW4gZnVsbC1zY3JlZW4gbW9kZSwgJ3dpbmRvdy50b3AuZG9jdW1lbnQuYm9keScgaXMgZGVmYXVsdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUZ1bGxTY3JlZW4gPSBmdW5jdGlvbihlbCkge1xuXG4gICAgdmFyIHRvcERvY3VtZW50ID0gd2luZG93LnRvcC5kb2N1bWVudDtcbiAgICBlbCA9IGVsIHx8IHRvcERvY3VtZW50LmJvZHk7XG5cbiAgICBmdW5jdGlvbiBwcmVmaXhlZFJlc3VsdChlbCwgcHJvcCkge1xuXG4gICAgICAgIHZhciBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdtcycsICdvJywgJyddO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcmVmaXggPyAocHJlZml4ICsgcHJvcCkgOiAocHJvcC5zdWJzdHIoMCwgMSkudG9Mb3dlckNhc2UoKSArIHByb3Auc3Vic3RyKDEpKTtcbiAgICAgICAgICAgIGlmIChlbFtwcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGVsW3Byb3BOYW1lXSkgPyBlbFtwcm9wTmFtZV0oKSA6IGVsW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmVmaXhlZFJlc3VsdCh0b3BEb2N1bWVudCwgJ0Z1bGxzY3JlZW5FbGVtZW50JykgfHwgcHJlZml4ZWRSZXN1bHQodG9wRG9jdW1lbnQsICdGdWxsU2NyZWVuRWxlbWVudCcpKSB7XG4gICAgICAgIHByZWZpeGVkUmVzdWx0KHRvcERvY3VtZW50LCAnRXhpdEZ1bGxzY3JlZW4nKSB8fCAvLyBTcGVjLlxuICAgICAgICBwcmVmaXhlZFJlc3VsdCh0b3BEb2N1bWVudCwgJ0NhbmNlbEZ1bGxTY3JlZW4nKTsgLy8gRmlyZWZveFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeGVkUmVzdWx0KGVsLCAnUmVxdWVzdEZ1bGxzY3JlZW4nKSB8fCAvLyBTcGVjLlxuICAgICAgICBwcmVmaXhlZFJlc3VsdChlbCwgJ1JlcXVlc3RGdWxsU2NyZWVuJyk7IC8vIEZpcmVmb3hcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kRGlmZmVyZW5jZShvYmosIGJhc2VPYmosIGN1cnJlbnREZXB0aCwgbWF4RGVwdGgpIHtcblxuICAgIGlmIChjdXJyZW50RGVwdGggPT09IG1heERlcHRoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VPYmpba2V5XTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqVmFsdWUpICYmICFBcnJheS5pc0FycmF5KGJhc2VWYWx1ZSkgJiYgaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KGJhc2VWYWx1ZSkpIHtcblxuICAgICAgICAgICAgY29uc3QgbmVzdGVkRGVwdGggPSBjdXJyZW50RGVwdGggKyAxO1xuICAgICAgICAgICAgY29uc3QgbmVzdGVkRGlmZiA9IGZpbmREaWZmZXJlbmNlKG9ialZhbHVlLCBiYXNlVmFsdWUsIG5lc3RlZERlcHRoLCBtYXhEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXN0ZWREaWZmKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlmZltrZXldID0gbmVzdGVkRGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGN1cnJlbnREZXB0aCA9PT0gMCB8fCBuZXN0ZWREZXB0aCA9PT0gbWF4RGVwdGgpKSB7XG4gICAgICAgICAgICAgICAgZGlmZltrZXldID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICghaXNFcXVhbChvYmpWYWx1ZSwgYmFzZVZhbHVlKSkge1xuICAgICAgICAgICAgZGlmZltrZXldID0gb2JqVmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBkaWZmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0RGlmZmVyZW5jZShvYmplY3QsIGJhc2UsIG9wdCkge1xuXG4gICAgY29uc3QgeyBtYXhEZXB0aCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9ID0gb3B0IHx8IHt9O1xuXG4gICAgcmV0dXJuIGZpbmREaWZmZXJlbmNlKG9iamVjdCwgYmFzZSwgMCwgbWF4RGVwdGgpO1xufVxuXG5leHBvcnQge1xuICAgIGlzQm9vbGVhbixcbiAgICBpc09iamVjdCxcbiAgICBpc051bWJlcixcbiAgICBpc1N0cmluZyxcbiAgICBtaXhpbixcbiAgICBkZWVwTWl4aW4sXG4gICAgc3VwcGxlbWVudCxcbiAgICBkZWZhdWx0cyxcbiAgICBkZWVwU3VwcGxlbWVudCxcbiAgICBkZWZhdWx0c0RlZXAsXG4gICAgYXNzaWduLFxuICAgIGludm9rZSxcbiAgICBpbnZva2VQcm9wZXJ0eSxcbiAgICBzb3J0ZWRJbmRleCxcbiAgICB1bmlxLFxuICAgIGNsb25lLFxuICAgIGNsb25lRGVlcCxcbiAgICBpc0VtcHR5LFxuICAgIGlzRXF1YWwsXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1BsYWluT2JqZWN0LFxuICAgIHRvQXJyYXksXG4gICAgZGVib3VuY2UsXG4gICAgZ3JvdXBCeSxcbiAgICBzb3J0QnksXG4gICAgZmxhdHRlbkRlZXAsXG4gICAgd2l0aG91dCxcbiAgICBkaWZmZXJlbmNlLFxuICAgIGludGVyc2VjdGlvbixcbiAgICB1bmlvbixcbiAgICBoYXMsXG4gICAgcmVzdWx0LFxuICAgIG9taXQsXG4gICAgcGljayxcbiAgICBiaW5kQWxsLFxuICAgIGZvckluLFxuICAgIGNhbWVsQ2FzZSxcbiAgICB1bmlxdWVJZCxcbiAgICBtZXJnZVxufTtcblxuZXhwb3J0IGNvbnN0IG5vb3AgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBEbyBub3RoaW5nLlxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/util.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@joint/core/src/util/utilHelpers.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   bindAll: function() { return /* binding */ bindAll; },\n/* harmony export */   camelCase: function() { return /* binding */ camelCase; },\n/* harmony export */   clone: function() { return /* binding */ clone; },\n/* harmony export */   cloneDeep: function() { return /* binding */ cloneDeep; },\n/* harmony export */   debounce: function() { return /* binding */ debounce; },\n/* harmony export */   deepMixin: function() { return /* binding */ deepMixin; },\n/* harmony export */   deepSupplement: function() { return /* binding */ deepSupplement; },\n/* harmony export */   defaults: function() { return /* binding */ defaults; },\n/* harmony export */   defaultsDeep: function() { return /* binding */ defaultsDeep; },\n/* harmony export */   difference: function() { return /* binding */ difference; },\n/* harmony export */   flattenDeep: function() { return /* binding */ flattenDeep; },\n/* harmony export */   forIn: function() { return /* binding */ forIn; },\n/* harmony export */   groupBy: function() { return /* binding */ groupBy; },\n/* harmony export */   has: function() { return /* binding */ has; },\n/* harmony export */   intersection: function() { return /* binding */ intersection; },\n/* harmony export */   invoke: function() { return /* binding */ invoke; },\n/* harmony export */   invokeProperty: function() { return /* binding */ invokeProperty; },\n/* harmony export */   isBoolean: function() { return /* binding */ isBoolean; },\n/* harmony export */   isEmpty: function() { return /* binding */ isEmpty; },\n/* harmony export */   isEqual: function() { return /* binding */ isEqual; },\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isNumber: function() { return /* binding */ isNumber; },\n/* harmony export */   isObject: function() { return /* binding */ isObject; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   matches: function() { return /* binding */ matches; },\n/* harmony export */   merge: function() { return /* binding */ merge; },\n/* harmony export */   mixin: function() { return /* binding */ mixin; },\n/* harmony export */   omit: function() { return /* binding */ omit; },\n/* harmony export */   pick: function() { return /* binding */ pick; },\n/* harmony export */   result: function() { return /* binding */ result; },\n/* harmony export */   sortBy: function() { return /* binding */ sortBy; },\n/* harmony export */   sortedIndex: function() { return /* binding */ sortedIndex; },\n/* harmony export */   supplement: function() { return /* binding */ supplement; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   union: function() { return /* binding */ union; },\n/* harmony export */   uniq: function() { return /* binding */ uniq; },\n/* harmony export */   uniqueId: function() { return /* binding */ uniqueId; },\n/* harmony export */   without: function() { return /* binding */ without; }\n/* harmony export */ });\n// code is inspired by https://github.com/lodash/lodash\n\n/* eslint-disable no-case-declarations */\n// -- helper constants\nconst argsTag = '[object Arguments]';\nconst arrayTag = '[object Array]';\nconst boolTag = '[object Boolean]';\nconst dateTag = '[object Date]';\nconst errorTag = '[object Error]';\nconst funcTag = '[object Function]';\nconst mapTag = '[object Map]';\nconst numberTag = '[object Number]';\nconst nullTag = '[object Null]';\nconst objectTag = '[object Object]';\nconst regexpTag = '[object RegExp]';\nconst setTag = '[object Set]';\nconst stringTag = '[object String]';\nconst symbolTag = '[object Symbol]';\nconst undefinedTag = '[object Undefined]';\nconst weakMapTag = '[object WeakMap]';\nconst arrayBufferTag = '[object ArrayBuffer]';\nconst dataViewTag = '[object DataView]';\nconst float32Tag = '[object Float32Array]';\nconst float64Tag = '[object Float64Array]';\nconst int8Tag = '[object Int8Array]';\nconst int16Tag = '[object Int16Array]';\nconst int32Tag = '[object Int32Array]';\nconst uint8Tag = '[object Uint8Array]';\nconst uint8ClampedTag = '[object Uint8ClampedArray]';\nconst uint16Tag = '[object Uint16Array]';\nconst uint32Tag = '[object Uint32Array]';\n\nconst CLONEABLE_TAGS = {\n    [argsTag]: true,\n    [arrayTag]: true,\n    [arrayBufferTag]: true,\n    [dataViewTag]: true,\n    [boolTag]: true,\n    [dateTag]: true,\n    [float32Tag]: true,\n    [float64Tag]: true,\n    [int8Tag]: true,\n    [int16Tag]: true,\n    [int32Tag]: true,\n    [mapTag]: true,\n    [numberTag]: true,\n    [objectTag]: true,\n    [regexpTag]: true,\n    [setTag]: true,\n    [stringTag]: true,\n    [symbolTag]: true,\n    [uint8Tag]: true,\n    [uint8ClampedTag]: true,\n    [uint16Tag]: true,\n    [uint32Tag]: true,\n    [errorTag]: false,\n    [funcTag]: false,\n    [weakMapTag]: false,\n};\n\n/** Used to compose unicode character classes. */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f';\nconst reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nconst rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff';\nconst rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff';\nconst rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\nconst rsDingbatRange = '\\\\u2700-\\\\u27bf';\nconst rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff';\nconst rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7';\nconst rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf';\nconst rsPunctuationRange = '\\\\u2000-\\\\u206f';\nconst rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000';\nconst rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\nconst rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n/** Used to compose unicode capture groups. */\nconst rsApos = '[\\'\\u2019]';\nconst rsBreak = `[${rsBreakRange}]`;\nconst rsCombo = `[${rsComboRange}]`;\nconst rsDigit = '\\\\d';\nconst rsDingbat = `[${rsDingbatRange}]`;\nconst rsLower = `[${rsLowerRange}]`;\nconst rsMisc = `[^${rsAstralRange}${rsBreakRange + rsDigit + rsDingbatRange + rsLowerRange + rsUpperRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsUpper = `[${rsUpperRange}]`;\nconst rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nconst rsMiscLower = `(?:${rsLower}|${rsMisc})`;\nconst rsMiscUpper = `(?:${rsUpper}|${rsMisc})`;\nconst rsOptContrLower = `(?:${rsApos}(?:d|ll|m|re|s|t|ve))?`;\nconst rsOptContrUpper = `(?:${rsApos}(?:D|LL|M|RE|S|T|VE))?`;\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = `(?:${rsZWJ}(?:${[rsNonAstral, rsRegional, rsSurrPair].join('|')})${rsOptVar + reOptMod})*`;\nconst rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])';\nconst rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsEmoji = `(?:${[rsDingbat, rsRegional, rsSurrPair].join('|')})${rsSeq}`;\n\nconst reUnicodeWords = RegExp([\n    `${rsUpper}?${rsLower}+${rsOptContrLower}(?=${[rsBreak, rsUpper, '$'].join('|')})`,\n    `${rsMiscUpper}+${rsOptContrUpper}(?=${[rsBreak, rsUpper + rsMiscLower, '$'].join('|')})`,\n    `${rsUpper}?${rsMiscLower}+${rsOptContrLower}`,\n    `${rsUpper}+${rsOptContrUpper}`,\n    rsOrdUpper,\n    rsOrdLower,\n    `${rsDigit}+`,\n    rsEmoji\n].join('|'), 'g');\n\nconst LARGE_ARRAY_SIZE = 200;\nconst HASH_UNDEFINED = '__hash_undefined__';\n\n// Used to match `toStringTag` values of typed arrays\nconst reTypedTag = /^\\[object (?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)Array\\]$/;\n\n// Used to compose unicode capture groups\nconst rsAstral = `[${rsAstralRange}]`;\n\n// Used to compose unicode regexes\nconst rsNonAstralCombo = `${rsNonAstral}${rsCombo}?`;\nconst rsSymbol = `(?:${[rsNonAstralCombo, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')})`;\n\n// Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode)\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol + rsSeq}`, 'g');\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n    , 'g');\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n\nconst hasUnicodeWord = RegExp.prototype.test.bind(\n    /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/\n);\n\nconst MAX_ARRAY_INDEX = 4294967295 - 1;\n\n/** Used to match words composed of alphanumeric characters. */\n// eslint-disable-next-line no-control-regex\nconst reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n\n\n// -- helper functions\nconst hasUnicode = (string) => {\n    return reUnicode.test(string);\n};\n\nconst unicodeToArray = (string) => {\n    return string.match(reUnicode) || [];\n};\n\nconst asciiToArray = (string) => {\n    return string.split('');\n};\n\nconst stringToArray = (string) => {\n    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n};\n\nconst values = (object) => {\n    if (object == null) {\n        return [];\n    }\n\n    return keys(object).map((key) => object[key]);\n};\n\nconst keys = (object) => {\n    return isArrayLike(object) ? arrayLikeKeys(object) : Object.keys(Object(object));\n};\n\nconst baseKeys = (object) => {\n    if (!isPrototype(object)) {\n        return Object.keys(object);\n    }\n    var result = [];\n    for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n            result.push(key);\n        }\n    }\n\n    return result;\n};\n\nconst arrayLikeKeys = (value, inherited) => {\n    const isArr = Array.isArray(value);\n    const isArg = !isArr && isObjectLike(value) && getTag(value) === argsTag;\n    const isType = !isArr && !isArg && isTypedArray(value);\n    const skipIndexes = isArr || isArg || isType;\n    const length = value.length;\n    const result = new Array(skipIndexes ? length : 0);\n    let index = skipIndexes ? -1 : length;\n    while (++index < length) {\n        result[index] = `${index}`;\n    }\n    for (const key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n                // Safari 9 has enumerable `arguments.length` in strict mode.\n                key === 'length' ||\n                // Skip index properties.\n                isIndex(key, length)\n            ))\n        ) {\n            result.push(key);\n        }\n    }\n    return result;\n};\n\nconst assocIndexOf = (array, key) => {\n    let { length } = array;\n    while (length--) {\n        if (eq(array[length][0], key)) {\n            return length;\n        }\n    }\n    return -1;\n};\n\nconst eq = (value, other) => {\n    return value === other || (value !== value && other !== other);\n};\n\nconst isObjectLike = (value) => {\n    return value != null && typeof value == 'object';\n};\n\nconst isIterateeCall = (value, index, object) => {\n    if (!isObject(object)) {\n        return false;\n    }\n    const type = typeof index;\n\n    const isPossibleIteratee = type == 'number' ?\n        (isArrayLike(object) && index > -1 && index < object.length) :\n        (type == 'string' && index in object);\n\n    if (isPossibleIteratee) {\n        return eq(object[index], value);\n    }\n    return false;\n};\n\nconst isSet = (value) => {\n    return isObjectLike(value) && getTag(value) == setTag;\n};\n\nconst isMap = (value) => {\n    return isObjectLike(value) && getTag(value) == mapTag;\n};\n\nconst isPrototype = (value) => {\n    const Ctor = value && value.constructor;\n    const proto = (typeof Ctor === 'function' && Ctor.prototype) || Object.prototype;\n\n    return value === proto;\n};\n\nconst assignValue = (object, key, value) => {\n    const objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n        object[key] = value;\n    }\n};\n\nconst copyObject = (source, props, object) => {\n    let index = -1;\n    const length = props.length;\n\n    while (++index < length) {\n        const key = props[index];\n        assignValue(object, key, source[key]);\n    }\n    return object;\n};\n\nconst isArrayLike = (value) => {\n    return value != null && typeof value !== 'function' && typeof value.length === 'number' &&\n        value.length > -1 && value.length % 1 === 0;\n};\n\nconst isSymbol = (value) => {\n    return typeof value == 'symbol' ||\n        (isObjectLike(value) && getTag(value) === symbolTag);\n};\n\nconst initCloneArray = (array) => {\n    const length = array.length;\n    let result = new array.constructor(length);\n\n    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n    }\n\n    return result;\n};\n\nconst copyArray = (source, array) => {\n    let index = -1;\n    const length = source.length;\n\n    array || (array = new Array(length));\n    while (++index < length) {\n        array[index] = source[index];\n    }\n    return array;\n};\n\nconst getTag = (value) => {\n    if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n    }\n\n    return Object.prototype.toString.call(value);\n};\n\nconst cloneArrayBuffer = (arrayBuffer) => {\n    const result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n    new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n    return result;\n};\n\nconst cloneTypedArray = (typedArray, isDeep) => {\n    const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n};\n\nconst cloneRegExp = (regexp) =>{\n    const result = new regexp.constructor(regexp.source, /\\w*$/.exec(regexp));\n    result.lastIndex = regexp.lastIndex;\n    return result;\n};\n\nconst initCloneObject = (object) => {\n    return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? Object.create(Object.getPrototypeOf(object))\n        : {};\n};\n\nconst getSymbols = (object) => {\n    if (object == null) {\n        return [];\n    }\n\n    object = Object(object);\n    const symbols = Object.getOwnPropertySymbols(object);\n\n    return symbols.filter((symbol) => propertyIsEnumerable.call(object, symbol));\n};\n\nconst copySymbols = (source, object) => {\n    return copyObject(source, getSymbols(source), object);\n};\n\nfunction cloneDataView(dataView, isDeep) {\n    const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nconst initCloneByTag = (object, tag, isDeep) => {\n    const Constructor = object.constructor;\n    switch(tag) {\n        case arrayBufferTag:\n            return cloneArrayBuffer(object);\n        case boolTag:\n        case dateTag:\n            return new Constructor(+object);\n        case dataViewTag:\n            return cloneDataView(object, isDeep);\n        case float32Tag:\n        case float64Tag:\n        case int8Tag:\n        case int16Tag:\n        case int32Tag:\n        case uint8Tag:\n        case uint8ClampedTag:\n        case uint16Tag:\n        case uint32Tag:\n            return cloneTypedArray(object, isDeep);\n        case mapTag:\n            return new Constructor(object);\n        case numberTag:\n        case stringTag:\n            return new Constructor(object);\n        case regexpTag:\n            return cloneRegExp(object);\n        case setTag:\n            return new Constructor;\n        case symbolTag:\n            return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(object)) : {};\n    }\n};\n\nconst isTypedArray = (value) => {\n    return isObjectLike(value) && reTypedTag.test(getTag(value));\n};\n\nconst getAllKeys = (object) => {\n    const result = Object.keys(object);\n    if(!Array.isArray(object) && object != null) {\n        result.push(...getSymbols(Object(object)));\n    }\n\n    return result;\n};\n\nconst getSymbolsIn = (object) => {\n    const result = [];\n    while (object) {\n        result.push(...getSymbols(object));\n        object = Object.getPrototypeOf(Object(object));\n    }\n\n    return result;\n};\n\nconst getAllKeysIn = (object) => {\n    const result = [];\n\n    for (const key in object) {\n        result.push(key);\n    }\n\n    if (!Array.isArray(object)) {\n        result.push(...getSymbolsIn(object));\n    }\n\n    return result;\n};\n\nconst getMapData = ({ __data__ }, key) => {\n    const data = __data__;\n    return isKeyable(key)\n        ? data[typeof key === 'string' ? 'string' : 'hash']\n        : data.map;\n};\n\nconst equalObjects = (object, other, equalFunc, stack) => {\n    const objProps = getAllKeys(object);\n    const objLength = objProps.length;\n    const othProps = getAllKeys(other);\n    const othLength = othProps.length;\n\n    if (objLength != othLength) {\n        return false;\n    }\n    let key;\n    let index = objLength;\n    while (index--) {\n        key = objProps[index];\n        if (!(hasOwnProperty.call(other, key))) {\n            return false;\n        }\n    }\n\n    const objStacked = stack.get(object);\n    const othStacked = stack.get(other);\n    if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n    }\n    let result = true;\n    stack.set(object, other);\n    stack.set(other, object);\n\n    let compared;\n    let skipCtor;\n\n    while (++index < objLength) {\n        key = objProps[index];\n        const objValue = object[key];\n        const othValue = other[key];\n\n        if (!(compared === undefined\n            ? (objValue === othValue || equalFunc(objValue, othValue, stack))\n            : compared\n        )) {\n            result = false;\n            break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n    }\n\n    if (result && !skipCtor) {\n        const objCtor = object.constructor;\n        const othCtor = other.constructor;\n\n        if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor === 'function' && objCtor instanceof objCtor &&\n            typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n            result = false;\n        }\n    }\n    stack['delete'](object);\n    stack['delete'](other);\n    return result;\n};\n\nconst baseIsEqual = (value, other, stack) => {\n    if (value === other) {\n        return true;\n    }\n    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n    }\n\n    return baseIsEqualDeep(value, other, baseIsEqual, stack);\n};\n\nconst baseIsEqualDeep = (object, other, equalFunc, stack) => {\n    let objIsArr = Array.isArray(object);\n    const othIsArr = Array.isArray(other);\n    let objTag = objIsArr ? arrayTag : getTag(object);\n    let othTag = othIsArr ? arrayTag : getTag(other);\n\n    objTag = objTag == argsTag ? objectTag : objTag;\n    othTag = othTag == argsTag ? objectTag : othTag;\n\n    let objIsObj = objTag == objectTag;\n    const othIsObj = othTag == objectTag;\n    const isSameTag = objTag == othTag;\n\n    if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n            ? equalArrays(object, other, false, equalFunc, stack)\n            : equalByTag(object, other, objTag, equalFunc, stack);\n    }\n\n    const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__');\n    const othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n        const objUnwrapped = objIsWrapped ? object.value() : object;\n        const othUnwrapped = othIsWrapped ? other.value() : other;\n\n        stack || (stack = new Stack);\n        return equalFunc(objUnwrapped, othUnwrapped, stack);\n    }\n\n    if (!isSameTag) {\n        return false;\n    }\n\n    stack || (stack = new Stack);\n    return equalObjects(object, other, equalFunc, stack);\n};\n\nconst equalArrays = (array, other, compareUnordered, equalFunc, stack) => {\n    const isPartial = false;\n    const arrLength = array.length;\n    const othLength = other.length;\n\n    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n    }\n    // Assume cyclic values are equal.\n    const arrStacked = stack.get(array);\n    const othStacked = stack.get(other);\n    if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n    }\n    let index = -1;\n    let result = true;\n    const seen = compareUnordered ? new SetCache : undefined;\n\n    stack.set(array, other);\n    stack.set(other, array);\n\n    while (++index < arrLength) {\n        let compared;\n        const arrValue = array[index];\n        const othValue = other[index];\n\n        if (compared !== undefined) {\n            if (compared) {\n                continue;\n            }\n            result = false;\n            break;\n        }\n\n        if (seen) {\n            if (!some(other, (othValue, othIndex) => {\n                if (!cacheHas(seen, othIndex) &&\n            (arrValue === othValue || equalFunc(arrValue, othValue, stack))) {\n                    return seen.push(othIndex);\n                }\n            })) {\n                result = false;\n                break;\n            }\n        } else if (!(\n            arrValue === othValue ||\n            equalFunc(arrValue, othValue, stack)\n        )) {\n            result = false;\n            break;\n        }\n    }\n    stack['delete'](array);\n    stack['delete'](other);\n    return result;\n};\n\nconst some = (array, predicate) => {\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n        if (predicate(array[index], index, array)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nconst cacheHas = (cache, key) => {\n    return cache.has(key);\n};\n\nconst compareArrayBufferTag = (object, other, equalFunc, stack) => {\n    if ((object.byteLength != other.byteLength) ||\n                !equalFunc(new Uint8Array(object), new Uint8Array(other), stack)) {\n        return false;\n    }\n    return true;\n};\n\nconst equalByTag = (object, other, tag, equalFunc, stack) => {\n\n    switch (tag) {\n        case dataViewTag:\n            if ((object.byteLength != other.byteLength) ||\n                (object.byteOffset != other.byteOffset)) {\n                return false;\n            }\n            object = object.buffer;\n            other = other.buffer;\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case arrayBufferTag:\n            return compareArrayBufferTag(object, other, equalFunc, stack);\n        case boolTag:\n        case dateTag:\n        case numberTag:\n            return eq(+object, +other);\n        case errorTag:\n            return object.name == other.name && object.message == other.message;\n        case regexpTag:\n        case stringTag:\n            return object == `${other}`;\n        case mapTag:\n            // This use of 'var' is intentional. Don't remove if replacing all instances.\n            var convert = mapToArray;\n        // Intentional fallthrough\n        // eslint-disable-next-line no-fallthrough\n        case setTag:\n            convert || (convert = setToArray);\n\n            if (object.size != other.size) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            const stacked = stack.get(object);\n            if (stacked) {\n                return stacked == other;\n            }\n\n            // Recursively compare objects (susceptible to call stack limits).\n            stack.set(object, other);\n            const result = equalArrays(convert(object), convert(other), true, equalFunc, stack);\n            stack['delete'](object);\n            return result;\n        case symbolTag:\n            return Symbol.prototype.valueOf.call(object) == Symbol.prototype.valueOf.call(other);\n    }\n\n    return false;\n};\n\nconst mapToArray = (map) => {\n    let index = -1;\n    let result = Array(map.size);\n\n    map.forEach((value, key) => {\n        result[++index] = [key, value];\n    });\n    return result;\n};\n\nconst setToArray = (set) => {\n    let index = -1;\n    const result = new Array(set.size);\n\n    set.forEach((value) => {\n        result[++index] = value;\n    });\n    return result;\n};\n\nconst isKey = (value, object) => {\n    if (Array.isArray(value)) {\n        return false;\n    }\n    const type = typeof value;\n    if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {\n        return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n};\n\nconst stringToPath = (string) => {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push('');\n    }\n    string.replace(rePropName, (match, expression, quote, subString) => {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, '$1');\n        }\n        else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n    });\n    return result;\n};\n\nconst castPath = (path, object) => {\n    if (Array.isArray(path)) {\n        return path;\n    }\n\n    return isKey(path, object) ? [path] : stringToPath(`${path}`);\n};\n\nconst get = (object, path) => {\n    path = castPath(path, object);\n\n    let index = 0;\n    const length = path.length;\n\n    while (object != null && index < length) {\n        object = object[toKey(path[index])];\n        index++;\n    }\n\n    return (index && index == length) ? object : undefined;\n};\n\nfunction compareAscending(value, other) {\n    if (value !== other) {\n        const valIsDefined = value !== undefined;\n        const valIsNull = value === null;\n        const valIsReflexive = value === value;\n        const valIsSymbol = isSymbol(value);\n\n        const othIsDefined = other !== undefined;\n        const othIsNull = other === null;\n        const othIsReflexive = other === other;\n        const othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n            return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n            return -1;\n        }\n    }\n    return 0;\n}\n\nfunction compareMultiple(object, other, orders) {\n    let index = -1;\n    const objCriteria = object.criteria;\n    const othCriteria = other.criteria;\n    const length = objCriteria.length;\n    const ordersLength = orders.length;\n\n    while (++index < length) {\n        const order = index < ordersLength ? orders[index] : null;\n        const cmpFn = (order && typeof order === 'function') ? order : compareAscending;\n        const result = cmpFn(objCriteria[index], othCriteria[index]);\n        if (result) {\n            if (order && typeof order !== 'function') {\n                return result * (order == 'desc' ? -1 : 1);\n            }\n            return result;\n        }\n    }\n\n    return object.index - other.index;\n}\n\nconst diff = (array, values) => {\n    let includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    let isCommon = true;\n    const result = [];\n    const valuesLength = values.length;\n\n    if (!array.length) {\n        return result;\n    }\n\n    if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = (cache, key) => cache.has(key);\n        isCommon = false;\n        values = new SetCache(values);\n    }\n\n    outer:\n    for (let key in array) {\n        let value = array[key];\n        const computed = value;\n\n        value = (value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n            let valuesIndex = valuesLength;\n            while (valuesIndex--) {\n                if (values[valuesIndex] === computed) {\n                    continue outer;\n                }\n            }\n            result.push(value);\n        }\n        else if (!includes(values, computed)) {\n            result.push(value);\n        }\n    }\n\n    return result;\n};\n\nconst intersect = (arrays) => {\n    const includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    const cacheHas = (cache, key) => cache.has(key);\n    const length = arrays[0].length;\n    const othLength = arrays.length;\n    const caches = new Array(othLength);\n    const result = [];\n\n    let array;\n    let maxLength = Infinity;\n    let othIndex = othLength;\n\n    while (othIndex--) {\n        array = arrays[othIndex];\n\n        maxLength = Math.min(array.length, maxLength);\n        caches[othIndex] = length >= 120 && array.length >= 120\n            ? new SetCache(othIndex && array)\n            : undefined;\n    }\n    array = arrays[0];\n\n    let index = -1;\n    const seen = caches[0];\n\n    outer:\n    while (++index < length && result.length < maxLength) {\n        let value = array[index];\n        const computed = value;\n\n        value = (value !== 0) ? value : 0;\n        if (!(seen\n            ? cacheHas(seen, computed)\n            : includes(result, computed)\n        )) {\n            othIndex = othLength;\n            while (--othIndex) {\n                const cache = caches[othIndex];\n                if (!(cache\n                    ? cacheHas(cache, computed)\n                    : includes(arrays[othIndex], computed))\n                ) {\n                    continue outer;\n                }\n            }\n            if (seen) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nconst toKey = (value) => {\n    if (typeof value === 'string' || isSymbol(value)) {\n        return value;\n    }\n    const result = `${value}`;\n    return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;\n};\n\nconst baseClone = (value, isDeep = false, isFlat = false, isFull = true, customizer, key, object, stack) => {\n    let result;\n\n    if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n    }\n\n    if (result !== undefined) {\n        return result;\n    }\n\n    if (!isObject(value)) {\n        return value;\n    }\n\n    const isArr = Array.isArray(value);\n    const tag = getTag(value);\n\n    if (isArr) {\n        result = initCloneArray(value);\n\n        if (!isDeep) {\n            return copyArray(value, result);\n        }\n    } else {\n        const isFunc = typeof value === 'function';\n\n        if (tag === objectTag || tag === argsTag || (isFunc && !object)) {\n            result = (isFlat || isFunc) ? {} : initCloneObject(value);\n            if (!isDeep) {\n                return isFlat ?\n                    copySymbolsIn(value, copyObject(value, Object.keys(value), result)) :\n                    copySymbols(value, Object.assign(result, value));\n            }\n        } else {\n            if (isFunc || !CLONEABLE_TAGS[tag]) {\n                return object ? value : {};\n            }\n            result = initCloneByTag(value, tag, isDeep);\n        }\n    }\n\n    stack || (stack = new Stack);\n    const stacked = stack.get(value);\n\n    if (stacked) {\n        return stacked;\n    }\n\n    stack.set(value, result);\n\n    if (isMap(value)) {\n        value.forEach((subValue, key) => {\n            result.set(key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n        });\n\n        return result;\n    }\n\n    if (isSet(value)) {\n        value.forEach(subValue => {\n            result.add(baseClone(subValue, isDeep, isFlat, isFull, customizer, subValue, value, stack));\n        });\n\n        return result;\n    }\n\n    if(isTypedArray(value)) {\n        return result;\n    }\n\n    const keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n    const props =  isArr ? undefined : keysFunc(value);\n\n    (props || value).forEach((subValue, key) => {\n        if (props) {\n            key = subValue;\n            subValue = value[key];\n        }\n\n        assignValue(result, key, baseClone(subValue, isDeep, isFlat, isFull, customizer, key, value, stack));\n    });\n\n    return result;\n};\n\nconst copySymbolsIn = (source, object) => {\n    return copyObject(source, getSymbolsIn(source), object);\n};\n\nconst parent = (object, path) => {\n    return path.length < 2 ? object : get(object, path.slice(0, -1));\n};\n\nconst set = (object, path, value) => {\n    if (!isObject(object)) {\n        return object;\n    }\n    path = castPath(path, object);\n\n    const length = path.length;\n    const lastIndex = length - 1;\n\n    let index = -1;\n    let nested = object;\n\n    while (nested != null && ++index < length) {\n        const key = toKey(path[index]);\n        let newValue = value;\n\n        if (index != lastIndex) {\n            const objValue = nested[key];\n            newValue = undefined;\n            if (newValue === undefined) {\n                newValue = isObject(objValue)\n                    ? objValue\n                    : (isIndex(path[index + 1]) ? [] : {});\n            }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n    }\n    return object;\n};\n\nconst isIndex = (value, length) => {\n    const type = typeof value;\n    length = length == null ? Number.MAX_SAFE_INTEGER : length;\n\n    return !!length &&\n    (type === 'number' ||\n        (type !== 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n};\n\nconst unset = (object, path) => {\n    path = castPath(path, object);\n    object = parent(object, path);\n    const lastSegment = path[path.length - 1];\n    return object == null || delete object[toKey(lastSegment)];\n};\n\nconst isKeyable = (value) => {\n    const type = typeof value;\n    return (type === 'string' || type === 'number' || type === 'symbol' || type === 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n};\n\nconst keysIn = (object) => {\n    const result = [];\n    for (const key in object) {\n        result.push(key);\n    }\n    return result;\n};\n\nconst toPlainObject = (value) => {\n    value = Object(value);\n    const result = {};\n    for (const key in value) {\n        result[key] = value[key];\n    }\n    return result;\n};\n\nconst safeGet = (object, key) => {\n    if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n    }\n\n    if (key == '__proto__') {\n        return;\n    }\n\n    return object[key];\n};\n\nfunction createAssigner(assigner, isMerge = false) {\n    return (object, ...sources) => {\n        let index = -1;\n        let length = sources.length;\n        let customizer = length > 1 ? sources[length - 1] : undefined;\n        const guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer === 'function')\n            ? (length--, customizer)\n            : isMerge ? (a, b) => {\n                if (Array.isArray(a) && !Array.isArray(b)) {\n                    return b;\n                }\n            } : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n            customizer = length < 3 ? undefined : customizer;\n            length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n            const source = sources[index];\n            if (source) {\n                assigner(object, source, index, customizer);\n            }\n        }\n        return object;\n    };\n}\n\nconst baseMerge = (object, source, srcIndex, customizer, stack) => {\n    if (object === source) {\n        return;\n    }\n\n    forIn(source, (srcValue, key) => {\n        if (isObject(srcValue)) {\n            stack || (stack = new Stack);\n            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        } else {\n            let newValue = customizer\n                ? customizer(object[key], srcValue, `${key}`, object, source, stack)\n                : undefined;\n\n            if (newValue === undefined) {\n                newValue = srcValue;\n            }\n\n            assignMergeValue(object, key, newValue);\n        }\n    });\n};\n\nconst baseMergeDeep = (object, source, key, srcIndex, mergeFunc, customizer, stack) => {\n    const objValue = safeGet(object, key);\n    const srcValue = safeGet(source, key);\n    const stacked = stack.get(srcValue);\n\n    if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n    }\n\n    let newValue = customizer\n        ? customizer(objValue, srcValue, `${key}`, object, source, stack)\n        : undefined;\n\n    let isCommon = newValue === undefined;\n\n    if (isCommon) {\n        const isArr = Array.isArray(srcValue);\n        const isTyped = !isArr && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isTyped) {\n            if (Array.isArray(objValue)) {\n                newValue = objValue;\n            }\n            else if (isObjectLike(objValue) && isArrayLike(objValue)) {\n                newValue = copyArray(objValue);\n            }\n            else if (isTyped) {\n                isCommon = false;\n                newValue = cloneTypedArray(srcValue, true);\n            }\n            else {\n                newValue = [];\n            }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n            newValue = objValue;\n            if (isArguments(objValue)) {\n                newValue = toPlainObject(objValue);\n            }\n            else if (typeof objValue === 'function' || !isObject(objValue)) {\n                newValue = initCloneObject(srcValue);\n            }\n        }\n        else {\n            isCommon = false;\n        }\n    }\n    if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n    }\n    assignMergeValue(object, key, newValue);\n};\n\nconst assignMergeValue = (object, key, value) => {\n    if ((value !== undefined && !eq(object[key], value)) ||\n        (value === undefined && !(key in object))) {\n        assignValue(object, key, value);\n    }\n};\n\nfunction baseFor(object, iteratee, keysFunc) {\n    const iterable = Object(object);\n    const props = keysFunc(object);\n    let { length } = props;\n    let index = -1;\n\n    while (length--) {\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n    return object;\n}\n\nconst baseForOwn = (object, iteratee) => {\n    return object && baseFor(object, iteratee, keys);\n};\n\nconst baseEach = (collection, iteratee) => {\n    if (collection == null) {\n        return collection;\n    }\n    if (!isArrayLike(collection)) {\n        return baseForOwn(collection, iteratee);\n    }\n    const length = collection.length;\n    const iterable = Object(collection);\n    let index = -1;\n\n    while (++index < length) {\n        if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n        }\n    }\n    return collection;\n};\n\nfunction last(array) {\n    const length = array == null ? 0 : array.length;\n    return length ? array[length - 1] : undefined;\n}\n\nconst createSet = (Set && (1 / setToArray(new Set([undefined,-0]))[1]) == 1 / 0)\n    ? (values) => new Set(values)\n    : () => { /* no-op */ };\n\nfunction customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n    if (isObject(objValue) && isObject(srcValue)) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n    }\n    return objValue;\n}\n\nfunction baseOrderBy(collection, iteratees, orders) {\n    if (iteratees.length) {\n        iteratees = iteratees.map((iteratee) => {\n            if (Array.isArray(iteratee)) {\n                return (value) => get(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n\n            return iteratee;\n        });\n    } else {\n        iteratees = [(value) => value];\n    }\n\n    let criteriaIndex = -1;\n    let eachIndex = -1;\n\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n    baseEach(collection, (value) => {\n        const criteria = iteratees.map((iteratee) => iteratee(value));\n\n        result[++eachIndex] = {\n            criteria,\n            index: ++criteriaIndex,\n            value\n        };\n    });\n\n    return baseSortBy(result, (object, other) => compareMultiple(object, other, orders));\n}\n\nfunction baseSortBy(array, comparer) {\n    let { length } = array;\n\n    array.sort(comparer);\n    while (length--) {\n        array[length] = array[length].value;\n    }\n    return array;\n}\n\nfunction isStrictComparable(value) {\n    return value === value && !isObject(value);\n}\n\nfunction matchesStrictComparable(key, srcValue) {\n    return (object) => {\n        if (object == null) {\n            return false;\n        }\n        return object[key] === srcValue &&\n            (srcValue !== undefined || (key in Object(object)));\n    };\n}\n\nfunction hasIn(object, path) {\n    return object != null && hasPath(object, path, baseHasIn);\n}\n\nfunction baseMatchesProperty(path, srcValue) {\n    if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n    }\n    return (object) => {\n        const objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n            ? hasIn(object, path)\n            : baseIsEqual(srcValue, objValue);\n    };\n}\n\nfunction baseMatches(source) {\n    const matchData = getMatchData(source);\n    if (matchData.length === 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n    }\n    return (object) => object === source || baseIsMatch(object, source, matchData);\n}\n\nfunction getMatchData(object) {\n    const result = keys(object);\n    let length = result.length;\n\n    while (length--) {\n        const key = result[length];\n        const value = object[key];\n        result[length] = [key, value, isStrictComparable(value)];\n    }\n    return result;\n}\n\nfunction baseIsMatch(object, source, matchData, customizer) {\n    let index = matchData.length;\n    const length = index;\n    const noCustomizer = !customizer;\n\n    if (object == null) {\n        return !length;\n    }\n    let data;\n    let result;\n    object = Object(object);\n    while (index--) {\n        data = matchData[index];\n        if ((noCustomizer && data[2])\n            ? data[1] !== object[data[0]]\n            : !(data[0] in object)\n        ) {\n            return false;\n        }\n    }\n    while (++index < length) {\n        data = matchData[index];\n        const key = data[0];\n        const objValue = object[key];\n        const srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n            if (objValue === undefined && !(key in object)) {\n                return false;\n            }\n        } else {\n            const stack = new Stack;\n            if (customizer) {\n                result = customizer(objValue, srcValue, key, object, source, stack);\n            }\n            if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, stack)\n                : result\n            )) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction property(path) {\n    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nfunction baseProperty(key) {\n    return (object) => object == null ? undefined : object[key];\n}\n\nfunction basePropertyDeep(path) {\n    return (object) => get(object, path);\n}\n\nfunction baseIteratee(value) {\n    if (typeof value == 'function') {\n        return value;\n    }\n    if (value == null) {\n        return (val) => val;\n    }\n    if (typeof value == 'object') {\n        return Array.isArray(value)\n            ? baseMatchesProperty(value[0], value[1])\n            : baseMatches(value);\n    }\n    return property(value);\n}\n\nfunction getIteratee() {\n    const result = baseIteratee;\n    return arguments.length ? result(arguments[0], arguments[1]) : result;\n}\n\nconst arrayReduce = (array, iteratee, accumulator, initAccum) => {\n    let index = -1;\n    const length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n        accumulator = array[++index];\n    }\n    while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n};\n\nconst baseReduce = (collection, iteratee, accumulator, initAccum, eachFunc) => {\n    eachFunc(collection, (value, index, collection) => {\n        accumulator = initAccum\n            ? (initAccum = false, value)\n            : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n};\n\nfunction reduce(collection, iteratee, accumulator) {\n    const func = Array.isArray(collection) ? arrayReduce : baseReduce;\n    const initAccum = arguments.length < 3;\n    return func(collection, iteratee, accumulator, initAccum, baseEach);\n}\n\nconst isFlattenable = (value) => {\n    return Array.isArray(value) || isArguments(value) ||\n    !!(value && value[Symbol.isConcatSpreadable]);\n};\n\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n    let index = -1;\n    const length = array.length;\n\n    predicate || (predicate = isFlattenable);\n    result || (result = []);\n\n    while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n            if (depth > 1) {\n                // Recursively flatten arrays (susceptible to call stack limits).\n                baseFlatten(value, depth - 1, predicate, isStrict, result);\n            } else {\n                result.push(...value);\n            }\n        } else if (!isStrict) {\n            result[result.length] = value;\n        }\n    }\n    return result;\n}\n\nconst isArguments = (value) => {\n    return isObjectLike(value) && getTag(value) == '[object Arguments]';\n};\n\nconst basePick = (object, paths) => {\n    return basePickBy(object, paths, (value, path) => hasIn(object, path));\n};\n\nconst basePickBy = (object, paths, predicate) => {\n    let index = -1;\n    const length = paths.length;\n    const result = {};\n\n    while (++index < length) {\n        const path = paths[index];\n        const value = get(object, path);\n        if (predicate(value, path)) {\n            set(result, castPath(path, object), value);\n        }\n    }\n    return result;\n};\n\nconst isLength = (value) => {\n    return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= Number.MAX_SAFE_INTEGER;\n};\n\nconst baseHasIn = (object, key) =>{\n    return object != null && key in Object(object);\n};\n\nconst hasPath = (object, path, hasFunc) => {\n    path = castPath(path, object);\n\n    var index = -1,\n        length = path.length,\n        result = false;\n\n    while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n            break;\n        }\n        object = object[key];\n    }\n    if (result || ++index != length) {\n        return result;\n    }\n    length = object == null ? 0 : object.length;\n    return !!length && isLength(length) && isIndex(key, length) &&\n        (Array.isArray(object) || isArguments(object));\n};\n\nconst asciiWords = (string) => {\n    return string.match(reAsciiWord);\n};\n\nconst unicodeWords = (string) => {\n    return string.match(reUnicodeWords);\n};\n\nconst words = (string, pattern) => {\n    if (pattern === undefined) {\n        const result = hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n        return result || [];\n    }\n    return string.match(pattern) || [];\n};\n\nconst castSlice = (array, start, end) => {\n    const { length } = array;\n    end = end === undefined ? length : end;\n    return (!start && end >= length) ? array : array.slice(start, end);\n};\n\nconst upperFirst = createCaseFirst('toUpperCase');\n\nfunction createCaseFirst(methodName) {\n    return (string) => {\n        if (!string) {\n            return '';\n        }\n\n        const strSymbols = hasUnicode(string)\n            ? stringToArray(string)\n            : undefined;\n\n        const chr = strSymbols\n            ? strSymbols[0]\n            : string[0];\n\n        const trailing = strSymbols\n            ? castSlice(strSymbols, 1).join('')\n            : string.slice(1);\n\n        return chr[methodName]() + trailing;\n    };\n}\n\nfunction matches(source) {\n    return baseMatches(baseClone(source, true));\n}\n\n// -- helper classes\nclass Stack {\n    constructor(entries) {\n        const data = this.__data__ = new ListCache(entries);\n        this.size = data.size;\n    }\n\n    clear() {\n        this.__data__ = new ListCache;\n        this.size = 0;\n    }\n\n    delete(key) {\n        const data = this.__data__;\n        const result = data['delete'](key);\n\n        this.size = data.size;\n        return result;\n    }\n\n    get(key) {\n        return this.__data__.get(key);\n    }\n\n    has(key) {\n        return this.__data__.has(key);\n    }\n\n    set(key, value) {\n        let data = this.__data__;\n        if (data instanceof ListCache) {\n            const pairs = data.__data__;\n            if (pairs.length < LARGE_ARRAY_SIZE - 1) {\n                pairs.push([key, value]);\n                this.size = ++data.size;\n                return this;\n            }\n            data = this.__data__ = new MapCache(pairs);\n        }\n        data.set(key, value);\n        this.size = data.size;\n        return this;\n    }\n}\n\nclass ListCache {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n\n    delete(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n\n        if (index < 0) {\n            return false;\n        }\n        const lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            data.splice(index, 1);\n        }\n        --this.size;\n        return true;\n    }\n\n    get(key) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n\n    has(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    set(key, value) {\n        const data = this.__data__;\n        const index = assocIndexOf(data, key);\n\n        if (index < 0) {\n            ++this.size;\n            data.push([key, value]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n}\n\nclass MapCache {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.size = 0;\n        this.__data__ = {\n            'hash': new Hash,\n            'map': new Map,\n            'string': new Hash\n        };\n    }\n\n    delete(key) {\n        const result = getMapData(this, key)['delete'](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n\n    get(key) {\n        return getMapData(this, key).get(key);\n    }\n\n    has(key) {\n        return getMapData(this, key).has(key);\n    }\n\n    set(key, value) {\n        const data = getMapData(this, key);\n        const size = data.size;\n\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n}\n\nclass Hash {\n    constructor(entries) {\n        let index = -1;\n        const length = entries == null ? 0 : entries.length;\n\n        this.clear();\n        while (++index < length) {\n            const entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n\n    clear() {\n        this.__data__ = Object.create(null);\n        this.size = 0;\n    }\n\n    delete(key) {\n        const result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n\n    get(key) {\n        const data = this.__data__;\n        const result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n    }\n\n    has(key) {\n        const data = this.__data__;\n        return data[key] !== undefined;\n    }\n\n    set(key, value) {\n        const data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n}\n\nclass SetCache {\n    constructor(values) {\n        let index = -1;\n        const length = values == null ? 0 : values.length;\n\n        this.__data__ = new MapCache;\n        while (++index < length) {\n            this.add(values[index]);\n        }\n    }\n\n    add(value) {\n        this.__data__.set(value, HASH_UNDEFINED);\n        return this;\n    }\n\n    has(value) {\n        return this.__data__.has(value);\n    }\n}\n\nSetCache.prototype.push = SetCache.prototype.add;\n\n// -- top level functions\n\nconst isBoolean = function(value) {\n    var toString = Object.prototype.toString;\n    return value === true || value === false || (!!value && typeof value === 'object' && toString.call(value) === boolTag);\n};\n\nconst isObject = function(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function');\n};\n\nconst isNumber = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'number' || (!!value && typeof value === 'object' && toString.call(value) === numberTag);\n};\n\nconst isString = function(value) {\n    var toString = Object.prototype.toString;\n    return typeof value === 'string' || (!!value && typeof value === 'object' && toString.call(value) === stringTag);\n};\n\nconst assign = createAssigner((object, source) => {\n    if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n    }\n    for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n            assignValue(object, key, source[key]);\n        }\n    }\n});\n\nconst mixin = assign;\n\nconst deepMixin = mixin;\n\nconst supplement = (object, ...sources) => {\n    let index = -1;\n    let length = sources.length;\n    const guard = length > 2 ? sources[2] : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n    }\n\n    while (++index < length) {\n        const source = sources[index];\n\n        if (source == null) {\n            continue;\n        }\n\n        const props = Object.keys(source);\n        const propsLength = props.length;\n        let propsIndex = -1;\n\n        while (++propsIndex < propsLength) {\n            const key = props[propsIndex];\n            const value = object[key];\n\n            if (value === undefined ||\n                (eq(value, Object.prototype[key]) && !hasOwnProperty.call(object, key))) {\n                object[key] = source[key];\n            }\n        }\n    }\n\n    return object;\n};\n\nconst defaults = supplement;\n\nconst deepSupplement = function defaultsDeep(...args) {\n    args.push(undefined, customDefaultsMerge);\n    return merge.apply(undefined, args);\n};\n\nconst defaultsDeep = deepSupplement;\n\n// _.invokeMap\nconst invoke = (collection, path, ...args) => {\n    let index = -1;\n    const isFunc = typeof path === 'function';\n    const result = isArrayLike(collection) ? new Array(collection.length) : [];\n\n    baseEach(collection, (value) => {\n        result[++index] = isFunc ? path.apply(value, args) : invokeProperty(value, path, ...args);\n    });\n\n    return result;\n};\n\n// _.invoke\nconst invokeProperty = (object, path, ...args) => {\n    path = castPath(path, object);\n    object = parent(object, path);\n    const func = object == null ? object : object[toKey(last(path))];\n    return func == null ? undefined : func.apply(object, args);\n};\n\nconst sortedIndex = (array, value, iteratee) => {\n    let low = 0;\n    let high = array == null ? 0 : array.length;\n    if (high == 0) {\n        return 0;\n    }\n\n    iteratee = getIteratee(iteratee, 2);\n    value = iteratee(value);\n\n    const valIsNaN = value !== value;\n    const valIsNull = value === null;\n    const valIsSymbol = isSymbol(value);\n    const valIsUndefined = value === undefined;\n\n    while (low < high) {\n        let setLow;\n        const mid = Math.floor((low + high) / 2);\n        const computed = iteratee(array[mid]);\n        const othIsDefined = computed !== undefined;\n        const othIsNull = computed === null;\n        const othIsReflexive = computed === computed;\n        const othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n            setLow = othIsReflexive;\n        } else if (valIsUndefined) {\n            setLow = othIsReflexive &&othIsDefined;\n        } else if (valIsNull) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull;\n        } else if (valIsSymbol) {\n            setLow = othIsReflexive && othIsDefined && !othIsNull && !othIsSymbol;\n        } else if (othIsNull || othIsSymbol) {\n            setLow = false;\n        } else {\n            setLow = computed < value;\n        }\n        if (setLow) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return Math.min(high, MAX_ARRAY_INDEX);\n};\n\nconst uniq = (array, iteratee) => {\n    let index = -1;\n    let includes = (array, value) => {\n        const length = array == null ? 0 : array.length;\n        return !!length && array.indexOf(value) > -1;\n    };\n    iteratee = getIteratee(iteratee, 2);\n    let isCommon = true;\n\n    const { length } = array;\n    const result = [];\n    let seen = result;\n\n    if (length >= LARGE_ARRAY_SIZE) {\n        const set = iteratee ? null : createSet(array);\n        if (set) {\n            return setToArray(set);\n        }\n        isCommon = false;\n        includes = (cache, key) => cache.has(key);\n        seen = new SetCache;\n    } else {\n        seen = iteratee ? [] : result;\n    }\n    outer:\n    while (++index < length) {\n        let value = array[index];\n        const computed = iteratee ? iteratee(value) : value;\n\n        value = (value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n            let seenIndex = seen.length;\n            while (seenIndex--) {\n                if (seen[seenIndex] === computed) {\n                    continue outer;\n                }\n            }\n            if (iteratee) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n        else if (!includes(seen, computed)) {\n            if (seen !== result) {\n                seen.push(computed);\n            }\n            result.push(value);\n        }\n    }\n    return result;\n};\n\nconst clone = (value) => baseClone(value);\n\nconst cloneDeep = (value) => baseClone(value, true);\n\nconst isEmpty = (value) => {\n    if (value == null) {\n        return true;\n    }\n    if (isArrayLike(value) &&\n        (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function' ||\n            isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n    }\n    const tag = getTag(value);\n    if (tag == '[object Map]' || tag == '[object Set]') {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !baseKeys(value).length;\n    }\n    for (const key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n};\nconst isEqual = (object, other) => baseIsEqual(object, other);\n\nconst isFunction = (value) => typeof value === 'function';\n\nconst isPlainObject = (value) => {\n    if (!isObjectLike(value) || getTag(value) != '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n};\n\nconst toArray = (value) => {\n    if (!value) {\n        return [];\n    }\n\n    if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n    }\n\n    if (Symbol.iterator && Symbol.iterator in Object(value)) {\n        const iterator = value[Symbol.iterator]();\n        let data;\n        const result = [];\n\n        while (!(data = iterator.next()).done) {\n            result.push(data.value);\n        }\n        return result;\n    }\n\n    const tag = getTag(value);\n    const func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n    return func(value);\n};\n\nfunction debounce(func, wait, opt) {\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n\n    let lastArgs;\n    let lastThis;\n    let maxWait;\n    let result;\n    let timerId;\n    let lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n\n    const useRaf = (!wait && wait !== 0 && window && typeof window.requestAnimationFrame === 'function');\n\n    wait = +wait || 0;\n\n    if (isObject(opt)) {\n        leading = !!opt.leading;\n        maxing = 'maxWait' in opt;\n        maxWait = maxing ? Math.max(+opt.maxWait || 0, wait) : maxWait;\n        trailing = 'trailing' in opt ? !!opt.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n\n    function startTimer(pendingFunc, wait) {\n        if (useRaf) {\n            window.cancelAnimationFrame(timerId);\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n\n    function cancelTimer(id) {\n        if (useRaf) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n\n        return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) || (timeSinceLastCall < 0) ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n        timerId = undefined;\n\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n\n    debounced.cancel = () => {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    };\n    debounced.flush = () => timerId === undefined ? result : trailingEdge(Date.now());\n    debounced.pending = () => timerId !== undefined;\n\n    return debounced;\n}\n\nconst groupBy = (collection, iteratee) => {\n    iteratee = getIteratee(iteratee, 2);\n\n    return reduce(collection, (result, value) => {\n        const key = iteratee(value);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(value);\n        } else {\n            assignValue(result, key, [value]);\n        }\n        return result;\n    }, {});\n};\n\nconst sortBy = (collection, iteratees = []) => {\n    if (collection == null) {\n        return [];\n    }\n\n    const length = iteratees.length;\n    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n    }\n\n    if (!Array.isArray(iteratees)) {\n        iteratees = [getIteratee(iteratees, 2)];\n    }\n\n    return baseOrderBy(collection, iteratees.flat(1), []);\n};\n\nconst flattenDeep = (array) => {\n    const length = array == null ? 0 : array.length;\n    return length ? baseFlatten(array, Infinity) : [];\n};\n\nconst without = (array, ...values) => isArrayLike(array) ? diff(array, values) : [];\n\nconst difference = (array, ...values) =>\n    isObjectLike(array) && isArrayLike(array) ?\n        diff(array, values.flat(1)) : [];\n\nconst intersection = (...arrays) => {\n    const mapped = arrays.map((array) =>\n        isObjectLike(array) && isArrayLike(array) ?\n            array : []\n    );\n\n    return mapped.length && mapped[0] === arrays[0] ?\n        intersect(mapped) : [];\n};\n\nconst union = (...arrays) => {\n    const array = arrays.flat(1);\n    return uniq(array);\n};\n\nconst has = (object, key) => {\n    if (object == null) {\n        return false;\n    }\n\n    if (typeof key === 'string') {\n        key = key.split('.');\n    }\n\n    let index = -1;\n    let value = object;\n\n    while (++index < key.length) {\n        if (!value || !hasOwnProperty.call(value, key[index])) {\n            return false;\n        }\n        value = value[key[index]];\n    }\n\n    return true;\n};\n\nconst result = (object, path, defaultValue) => {\n    path = castPath(path, object);\n\n    let index = -1;\n    let length = path.length;\n\n    if (!length) {\n        length = 1;\n        object = undefined;\n    }\n    while (++index < length) {\n        let value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n            index = length;\n            value = defaultValue;\n        }\n        object = typeof value === 'function' ? value.call(object) : value;\n    }\n    return object;\n};\n\nconst omit = (object, ...paths) => {\n    let result = {};\n    if (object == null) {\n        return result;\n    }\n    let isDeep = false;\n    paths = paths.flat(1).map((path) => {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n    });\n    copyObject(object, getAllKeysIn(object), result);\n    if (isDeep) {\n        result = baseClone(result, true, true, true, (value) => isPlainObject(value) ? undefined : value);\n    }\n    let length = paths.length;\n    while (length--) {\n        unset(result, paths[length]);\n    }\n    return result;\n};\n\nconst pick = (object, ...paths) => {\n    return object == null ? {} : basePick(object, paths.flat(Infinity));\n};\n\nconst bindAll = (object, ...methodNames) => {\n    methodNames.flat(1).forEach((key) => {\n        key = toKey(key);\n        assignValue(object, key, object[key].bind(object));\n    });\n    return object;\n};\n\nconst forIn = (object, iteratee = (value) => value) => {\n    let index = -1;\n    const iterable = Object(object);\n    const props = isArrayLike(object) ? arrayLikeKeys(object, true) : keysIn(object);\n    let length = props.length;\n\n    while(length--) {\n        const key = props[++index];\n        if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n        }\n    }\n};\n\nconst camelCase = (string = '') => (\n    words(`${string}`.replace(/['\\u2019]/g, ''))\n        .reduce((result, word, index) => {\n            word = word.toLowerCase();\n            return result + (index ? upperFirst(word) : word);\n        }, '')\n);\n\nlet idCounter = 0;\n\nconst uniqueId = (prefix = '') => {\n    const id = ++idCounter;\n    return `${prefix}` + id;\n};\n\nconst merge = createAssigner((object, source, srcIndex, customizer) => {\n    baseMerge(object, source, srcIndex, customizer);\n}, true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC91dGlsSGVscGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckMsb0JBQW9CLGFBQWE7QUFDakMsb0JBQW9CLGNBQWMsRUFBRSxzRUFBc0U7QUFDMUc7QUFDQSx5QkFBeUIsUUFBUSxHQUFHLE9BQU87QUFDM0MseUJBQXlCLGNBQWM7QUFDdkMsaURBQWlELEVBQUU7QUFDbkQ7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQzs7QUFFQTtBQUNBLDBCQUEwQixRQUFRLEdBQUcsT0FBTztBQUM1QywwQkFBMEIsUUFBUSxHQUFHLE9BQU87QUFDNUMsOEJBQThCLE9BQU87QUFDckMsOEJBQThCLE9BQU87QUFDckMsb0JBQW9CLFdBQVc7QUFDL0IscUJBQXFCLFdBQVc7QUFDaEMsd0JBQXdCLE1BQU0sS0FBSyxnREFBZ0QsR0FBRyxvQkFBb0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhDQUE4QyxHQUFHLE1BQU07O0FBRTdFO0FBQ0EsT0FBTyxRQUFRLEdBQUcsUUFBUSxHQUFHLGdCQUFnQixLQUFLLGtDQUFrQztBQUNwRixPQUFPLFlBQVksR0FBRyxnQkFBZ0IsS0FBSyxnREFBZ0Q7QUFDM0YsT0FBTyxRQUFRLEdBQUcsWUFBWSxHQUFHLGdCQUFnQjtBQUNqRCxPQUFPLFFBQVEsR0FBRyxnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBLE9BQU8sUUFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGNBQWM7O0FBRW5DO0FBQ0EsNEJBQTRCLFlBQVksRUFBRSxRQUFRO0FBQ2xELHVCQUF1Qix3RUFBd0U7O0FBRS9GO0FBQ0EsNEJBQTRCLE9BQU8sS0FBSyxPQUFPLElBQUksaUJBQWlCOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBELEtBQUs7QUFDL0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdURBQXVELElBQUk7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU07O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87O0FBRUE7QUFDUDtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPOztBQUVBO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLCtCQUErQjtBQUMvQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVPO0FBQ1A7QUFDQSxjQUFjLE9BQU87QUFDckI7O0FBRU87QUFDUDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL3V0aWxIZWxwZXJzLm1qcz9kYjdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvZGUgaXMgaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2hcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbi8vIC0tIGhlbHBlciBjb25zdGFudHNcbmNvbnN0IGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcbmNvbnN0IGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJztcbmNvbnN0IGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5jb25zdCBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuY29uc3QgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5jb25zdCBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcbmNvbnN0IG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nO1xuY29uc3QgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJztcbmNvbnN0IG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuY29uc3QgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcbmNvbnN0IHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuY29uc3Qgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5jb25zdCB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcbmNvbnN0IHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5jb25zdCBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG5jb25zdCBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5jb25zdCBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc7XG5jb25zdCBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7XG5jb25zdCBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XSc7XG5jb25zdCBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJztcbmNvbnN0IGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nO1xuY29uc3QgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XSc7XG5jb25zdCB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nO1xuY29uc3QgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJztcbmNvbnN0IHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbmNvbnN0IENMT05FQUJMRV9UQUdTID0ge1xuICAgIFthcmdzVGFnXTogdHJ1ZSxcbiAgICBbYXJyYXlUYWddOiB0cnVlLFxuICAgIFthcnJheUJ1ZmZlclRhZ106IHRydWUsXG4gICAgW2RhdGFWaWV3VGFnXTogdHJ1ZSxcbiAgICBbYm9vbFRhZ106IHRydWUsXG4gICAgW2RhdGVUYWddOiB0cnVlLFxuICAgIFtmbG9hdDMyVGFnXTogdHJ1ZSxcbiAgICBbZmxvYXQ2NFRhZ106IHRydWUsXG4gICAgW2ludDhUYWddOiB0cnVlLFxuICAgIFtpbnQxNlRhZ106IHRydWUsXG4gICAgW2ludDMyVGFnXTogdHJ1ZSxcbiAgICBbbWFwVGFnXTogdHJ1ZSxcbiAgICBbbnVtYmVyVGFnXTogdHJ1ZSxcbiAgICBbb2JqZWN0VGFnXTogdHJ1ZSxcbiAgICBbcmVnZXhwVGFnXTogdHJ1ZSxcbiAgICBbc2V0VGFnXTogdHJ1ZSxcbiAgICBbc3RyaW5nVGFnXTogdHJ1ZSxcbiAgICBbc3ltYm9sVGFnXTogdHJ1ZSxcbiAgICBbdWludDhUYWddOiB0cnVlLFxuICAgIFt1aW50OENsYW1wZWRUYWddOiB0cnVlLFxuICAgIFt1aW50MTZUYWddOiB0cnVlLFxuICAgIFt1aW50MzJUYWddOiB0cnVlLFxuICAgIFtlcnJvclRhZ106IGZhbHNlLFxuICAgIFtmdW5jVGFnXTogZmFsc2UsXG4gICAgW3dlYWtNYXBUYWddOiBmYWxzZSxcbn07XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbmNvbnN0IHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZic7XG5jb25zdCByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJztcbmNvbnN0IHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJztcbmNvbnN0IHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZic7XG5jb25zdCByc0NvbWJvTWFya3NFeHRlbmRlZFJhbmdlID0gJ1xcXFx1MWFiMC1cXFxcdTFhZmYnO1xuY29uc3QgcnNDb21ib01hcmtzU3VwcGxlbWVudFJhbmdlID0gJ1xcXFx1MWRjMC1cXFxcdTFkZmYnO1xuY29uc3QgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgcnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSArIHJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZTtcbmNvbnN0IHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnO1xuY29uc3QgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZic7XG5jb25zdCByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnO1xuY29uc3QgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJztcbmNvbnN0IHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJztcbmNvbnN0IHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCc7XG5jb25zdCByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJztcbmNvbnN0IHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcbmNvbnN0IHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuY29uc3QgcnNBcG9zID0gJ1tcXCdcXHUyMDE5XSc7XG5jb25zdCByc0JyZWFrID0gYFske3JzQnJlYWtSYW5nZX1dYDtcbmNvbnN0IHJzQ29tYm8gPSBgWyR7cnNDb21ib1JhbmdlfV1gO1xuY29uc3QgcnNEaWdpdCA9ICdcXFxcZCc7XG5jb25zdCByc0RpbmdiYXQgPSBgWyR7cnNEaW5nYmF0UmFuZ2V9XWA7XG5jb25zdCByc0xvd2VyID0gYFske3JzTG93ZXJSYW5nZX1dYDtcbmNvbnN0IHJzTWlzYyA9IGBbXiR7cnNBc3RyYWxSYW5nZX0ke3JzQnJlYWtSYW5nZSArIHJzRGlnaXQgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZX1dYDtcbmNvbnN0IHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nO1xuY29uc3QgcnNNb2RpZmllciA9IGAoPzoke3JzQ29tYm99fCR7cnNGaXR6fSlgO1xuY29uc3QgcnNOb25Bc3RyYWwgPSBgW14ke3JzQXN0cmFsUmFuZ2V9XWA7XG5jb25zdCByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nO1xuY29uc3QgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nO1xuY29uc3QgcnNVcHBlciA9IGBbJHtyc1VwcGVyUmFuZ2V9XWA7XG5jb25zdCByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbmNvbnN0IHJzTWlzY0xvd2VyID0gYCg/OiR7cnNMb3dlcn18JHtyc01pc2N9KWA7XG5jb25zdCByc01pc2NVcHBlciA9IGAoPzoke3JzVXBwZXJ9fCR7cnNNaXNjfSlgO1xuY29uc3QgcnNPcHRDb250ckxvd2VyID0gYCg/OiR7cnNBcG9zfSg/OmR8bGx8bXxyZXxzfHR8dmUpKT9gO1xuY29uc3QgcnNPcHRDb250clVwcGVyID0gYCg/OiR7cnNBcG9zfSg/OkR8TEx8TXxSRXxTfFR8VkUpKT9gO1xuY29uc3QgcmVPcHRNb2QgPSBgJHtyc01vZGlmaWVyfT9gO1xuY29uc3QgcnNPcHRWYXIgPSBgWyR7cnNWYXJSYW5nZX1dP2A7XG5jb25zdCByc09wdEpvaW4gPSBgKD86JHtyc1pXSn0oPzoke1tyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpfSkke3JzT3B0VmFyICsgcmVPcHRNb2R9KSpgO1xuY29uc3QgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknO1xuY29uc3QgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknO1xuY29uc3QgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luO1xuY29uc3QgcnNFbW9qaSA9IGAoPzoke1tyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKX0pJHtyc1NlcX1gO1xuXG5jb25zdCByZVVuaWNvZGVXb3JkcyA9IFJlZ0V4cChbXG4gICAgYCR7cnNVcHBlcn0/JHtyc0xvd2VyfSske3JzT3B0Q29udHJMb3dlcn0oPz0ke1tyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKX0pYCxcbiAgICBgJHtyc01pc2NVcHBlcn0rJHtyc09wdENvbnRyVXBwZXJ9KD89JHtbcnNCcmVhaywgcnNVcHBlciArIHJzTWlzY0xvd2VyLCAnJCddLmpvaW4oJ3wnKX0pYCxcbiAgICBgJHtyc1VwcGVyfT8ke3JzTWlzY0xvd2VyfSske3JzT3B0Q29udHJMb3dlcn1gLFxuICAgIGAke3JzVXBwZXJ9KyR7cnNPcHRDb250clVwcGVyfWAsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIGAke3JzRGlnaXR9K2AsXG4gICAgcnNFbW9qaVxuXS5qb2luKCd8JyksICdnJyk7XG5cbmNvbnN0IExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5jb25zdCBIQVNIX1VOREVGSU5FRCA9ICdfX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vLyBVc2VkIHRvIG1hdGNoIGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5c1xuY29uc3QgcmVUeXBlZFRhZyA9IC9eXFxbb2JqZWN0ICg/OkZsb2F0KD86MzJ8NjQpfCg/OkludHxVaW50KSg/Ojh8MTZ8MzIpfFVpbnQ4Q2xhbXBlZClBcnJheVxcXSQvO1xuXG4vLyBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwc1xuY29uc3QgcnNBc3RyYWwgPSBgWyR7cnNBc3RyYWxSYW5nZX1dYDtcblxuLy8gVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlc1xuY29uc3QgcnNOb25Bc3RyYWxDb21ibyA9IGAke3JzTm9uQXN0cmFsfSR7cnNDb21ib30/YDtcbmNvbnN0IHJzU3ltYm9sID0gYCg/OiR7W3JzTm9uQXN0cmFsQ29tYm8sIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8Jyl9KWA7XG5cbi8vIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKVxuY29uc3QgcmVVbmljb2RlID0gUmVnRXhwKGAke3JzRml0en0oPz0ke3JzRml0en0pfCR7cnNTeW1ib2wgKyByc1NlcX1gLCAnZycpO1xuXG5jb25zdCByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vO1xuY29uc3QgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG5jb25zdCBjaGFyQ29kZU9mRG90ID0gJy4nLmNoYXJDb2RlQXQoMCk7XG5jb25zdCByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcbmNvbnN0IHJlUHJvcE5hbWUgPSBSZWdFeHAoXG4gICAgLy8gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIGRvdCBvciBicmFja2V0LlxuICAgICdbXi5bXFxcXF1dKycgKyAnfCcgK1xuICAvLyBPciBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gYnJhY2tldHMuXG4gICdcXFxcWyg/OicgK1xuICAgIC8vIE1hdGNoIGEgbm9uLXN0cmluZyBleHByZXNzaW9uLlxuICAgICcoW15cIlxcJ11bXltdKiknICsgJ3wnICtcbiAgICAvLyBPciBtYXRjaCBzdHJpbmdzIChzdXBwb3J0cyBlc2NhcGluZyBjaGFyYWN0ZXJzKS5cbiAgICAnKFtcIlxcJ10pKCg/Oig/IVxcXFwyKVteXFxcXFxcXFxdfFxcXFxcXFxcLikqPylcXFxcMicgK1xuICAnKVxcXFxdJysgJ3wnICtcbiAgLy8gT3IgbWF0Y2ggXCJcIiBhcyB0aGUgc3BhY2UgYmV0d2VlbiBjb25zZWN1dGl2ZSBkb3RzIG9yIGVtcHR5IGJyYWNrZXRzLlxuICAnKD89KD86XFxcXC58XFxcXFtcXFxcXSkoPzpcXFxcLnxcXFxcW1xcXFxdfCQpKSdcbiAgICAsICdnJyk7XG5jb25zdCByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbmNvbnN0IGhhc1VuaWNvZGVXb3JkID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoXG4gICAgL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS9cbik7XG5cbmNvbnN0IE1BWF9BUlJBWV9JTkRFWCA9IDQyOTQ5NjcyOTUgLSAxO1xuXG4vKiogVXNlZCB0byBtYXRjaCB3b3JkcyBjb21wb3NlZCBvZiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycy4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuXG5cbi8vIC0tIGhlbHBlciBmdW5jdGlvbnNcbmNvbnN0IGhhc1VuaWNvZGUgPSAoc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHJlVW5pY29kZS50ZXN0KHN0cmluZyk7XG59O1xuXG5jb25zdCB1bmljb2RlVG9BcnJheSA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107XG59O1xuXG5jb25zdCBhc2NpaVRvQXJyYXkgPSAoc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59O1xuXG5jb25zdCBzdHJpbmdUb0FycmF5ID0gKHN0cmluZykgPT4ge1xuICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZykgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59O1xuXG5jb25zdCB2YWx1ZXMgPSAob2JqZWN0KSA9PiB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cyhvYmplY3QpLm1hcCgoa2V5KSA9PiBvYmplY3Rba2V5XSk7XG59O1xuXG5jb25zdCBrZXlzID0gKG9iamVjdCkgPT4ge1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogT2JqZWN0LmtleXMoT2JqZWN0KG9iamVjdCkpO1xufTtcblxuY29uc3QgYmFzZUtleXMgPSAob2JqZWN0KSA9PiB7XG4gICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBhcnJheUxpa2VLZXlzID0gKHZhbHVlLCBpbmhlcml0ZWQpID0+IHtcbiAgICBjb25zdCBpc0FyciA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGNvbnN0IGlzQXJnID0gIWlzQXJyICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PT0gYXJnc1RhZztcbiAgICBjb25zdCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzVHlwZWRBcnJheSh2YWx1ZSk7XG4gICAgY29uc3Qgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc1R5cGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShza2lwSW5kZXhlcyA/IGxlbmd0aCA6IDApO1xuICAgIGxldCBpbmRleCA9IHNraXBJbmRleGVzID8gLTEgOiBsZW5ndGg7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGAke2luZGV4fWA7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgICAgICAga2V5ID09PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBhc3NvY0luZGV4T2YgPSAoYXJyYXksIGtleSkgPT4ge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gYXJyYXk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbmNvbnN0IGVxID0gKHZhbHVlLCBvdGhlcikgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufTtcblxuY29uc3QgaXNPYmplY3RMaWtlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufTtcblxuY29uc3QgaXNJdGVyYXRlZUNhbGwgPSAodmFsdWUsIGluZGV4LCBvYmplY3QpID0+IHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGluZGV4O1xuXG4gICAgY29uc3QgaXNQb3NzaWJsZUl0ZXJhdGVlID0gdHlwZSA9PSAnbnVtYmVyJyA/XG4gICAgICAgIChpc0FycmF5TGlrZShvYmplY3QpICYmIGluZGV4ID4gLTEgJiYgaW5kZXggPCBvYmplY3QubGVuZ3RoKSA6XG4gICAgICAgICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCk7XG5cbiAgICBpZiAoaXNQb3NzaWJsZUl0ZXJhdGVlKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59O1xuXG5jb25zdCBpc01hcCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufTtcblxuY29uc3QgaXNQcm90b3R5cGUgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3I7XG4gICAgY29uc3QgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufTtcblxuY29uc3QgYXNzaWduVmFsdWUgPSAob2JqZWN0LCBrZXksIHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbn07XG5cbmNvbnN0IGNvcHlPYmplY3QgPSAoc291cmNlLCBwcm9wcywgb2JqZWN0KSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgaXNBcnJheUxpa2UgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUubGVuZ3RoID4gLTEgJiYgdmFsdWUubGVuZ3RoICUgMSA9PT0gMDtcbn07XG5cbmNvbnN0IGlzU3ltYm9sID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09PSBzeW1ib2xUYWcpO1xufTtcblxuY29uc3QgaW5pdENsb25lQXJyYXkgPSAoYXJyYXkpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBjb3B5QXJyYXkgPSAoc291cmNlLCBhcnJheSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICBhcnJheSB8fCAoYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufTtcblxuY29uc3QgZ2V0VGFnID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufTtcblxuY29uc3QgY2xvbmVBcnJheUJ1ZmZlciA9IChhcnJheUJ1ZmZlcikgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBjbG9uZVR5cGVkQXJyYXkgPSAodHlwZWRBcnJheSwgaXNEZWVwKSA9PiB7XG4gICAgY29uc3QgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn07XG5cbmNvbnN0IGNsb25lUmVnRXhwID0gKHJlZ2V4cCkgPT57XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCAvXFx3KiQvLmV4ZWMocmVnZXhwKSk7XG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGluaXRDbG9uZU9iamVjdCA9IChvYmplY3QpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKVxuICAgICAgICA6IHt9O1xufTtcblxuY29uc3QgZ2V0U3ltYm9scyA9IChvYmplY3QpID0+IHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG5cbiAgICByZXR1cm4gc3ltYm9scy5maWx0ZXIoKHN5bWJvbCkgPT4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCkpO1xufTtcblxuY29uc3QgY29weVN5bWJvbHMgPSAoc291cmNlLCBvYmplY3QpID0+IHtcbiAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn07XG5cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbmNvbnN0IGluaXRDbG9uZUJ5VGFnID0gKG9iamVjdCwgdGFnLCBpc0RlZXApID0+IHtcbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2godGFnKSB7XG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoK29iamVjdCk7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzpcbiAgICAgICAgY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6XG4gICAgICAgIGNhc2UgaW50MTZUYWc6XG4gICAgICAgIGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6XG4gICAgICAgIGNhc2UgdWludDhDbGFtcGVkVGFnOlxuICAgICAgICBjYXNlIHVpbnQxNlRhZzpcbiAgICAgICAgY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKG9iamVjdCk7XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqZWN0KTtcbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yO1xuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICAgIHJldHVybiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YgPyBPYmplY3QoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwob2JqZWN0KSkgOiB7fTtcbiAgICB9XG59O1xuXG5jb25zdCBpc1R5cGVkQXJyYXkgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiByZVR5cGVkVGFnLnRlc3QoZ2V0VGFnKHZhbHVlKSk7XG59O1xuXG5jb25zdCBnZXRBbGxLZXlzID0gKG9iamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaCguLi5nZXRTeW1ib2xzKE9iamVjdChvYmplY3QpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldFN5bWJvbHNJbiA9IChvYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3Qob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGdldEFsbEtleXNJbiA9IChvYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmdldFN5bWJvbHNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgZ2V0TWFwRGF0YSA9ICh7IF9fZGF0YV9fIH0sIGtleSkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBfX2RhdGFfXztcbiAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICAgIDogZGF0YS5tYXA7XG59O1xuXG5jb25zdCBlcXVhbE9iamVjdHMgPSAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuICAgIGNvbnN0IG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpO1xuICAgIGNvbnN0IG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aDtcbiAgICBjb25zdCBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpO1xuICAgIGNvbnN0IG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGtleTtcbiAgICBsZXQgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgIGNvbnN0IG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIG9ialN0YWNrZWQgPT0gb3RoZXIgJiYgb3RoU3RhY2tlZCA9PSBvYmplY3Q7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgICBsZXQgY29tcGFyZWQ7XG4gICAgbGV0IHNraXBDdG9yO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICBjb25zdCBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIHN0YWNrKSlcbiAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICAgICAgY29uc3Qgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3Qgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgYmFzZUlzRXF1YWwgPSAodmFsdWUsIG90aGVyLCBzdGFjaykgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn07XG5cbmNvbnN0IGJhc2VJc0VxdWFsRGVlcCA9IChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIHN0YWNrKSA9PiB7XG4gICAgbGV0IG9iaklzQXJyID0gQXJyYXkuaXNBcnJheShvYmplY3QpO1xuICAgIGNvbnN0IG90aElzQXJyID0gQXJyYXkuaXNBcnJheShvdGhlcik7XG4gICAgbGV0IG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KTtcbiAgICBsZXQgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgIGxldCBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWc7XG4gICAgY29uc3Qgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnO1xuICAgIGNvbnN0IGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBmYWxzZSwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIGNvbnN0IG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKTtcbiAgICBjb25zdCBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICAgIGNvbnN0IG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0O1xuICAgICAgICBjb25zdCBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgc3RhY2spO1xuICAgIH1cblxuICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjayk7XG59O1xuXG5jb25zdCBlcXVhbEFycmF5cyA9IChhcnJheSwgb3RoZXIsIGNvbXBhcmVVbm9yZGVyZWQsIGVxdWFsRnVuYywgc3RhY2spID0+IHtcbiAgICBjb25zdCBpc1BhcnRpYWwgPSBmYWxzZTtcbiAgICBjb25zdCBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgY29uc3Qgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICBjb25zdCBhcnJTdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgICBjb25zdCBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGNvbnN0IHNlZW4gPSBjb21wYXJlVW5vcmRlcmVkID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICBsZXQgY29tcGFyZWQ7XG4gICAgICAgIGNvbnN0IGFyclZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBjb25zdCBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgIGlmICghc29tZShvdGhlciwgKG90aFZhbHVlLCBvdGhJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHNvbWUgPSAoYXJyYXksIHByZWRpY2F0ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGNhY2hlSGFzID0gKGNhY2hlLCBrZXkpID0+IHtcbiAgICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59O1xuXG5jb25zdCBjb21wYXJlQXJyYXlCdWZmZXJUYWcgPSAob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSwgc3RhY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBlcXVhbEJ5VGFnID0gKG9iamVjdCwgb3RoZXIsIHRhZywgZXF1YWxGdW5jLCBzdGFjaykgPT4ge1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5QnVmZmVyVGFnKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVBcnJheUJ1ZmZlclRhZyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IGAke290aGVyfWA7XG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgICAgLy8gVGhpcyB1c2Ugb2YgJ3ZhcicgaXMgaW50ZW50aW9uYWwuIERvbid0IHJlbW92ZSBpZiByZXBsYWNpbmcgYWxsIGluc3RhbmNlcy5cbiAgICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcbiAgICAgICAgLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgIGNvbnN0IHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgdHJ1ZSwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgICAgcmV0dXJuIFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IG1hcFRvQXJyYXkgPSAobWFwKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3Qgc2V0VG9BcnJheSA9IChzZXQpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBpc0tleSA9ICh2YWx1ZSwgb2JqZWN0KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn07XG5cbmNvbnN0IHN0cmluZ1RvUGF0aCA9IChzdHJpbmcpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IGNoYXJDb2RlT2ZEb3QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJycpO1xuICAgIH1cbiAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCAobWF0Y2gsIGV4cHJlc3Npb24sIHF1b3RlLCBzdWJTdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGtleSA9IG1hdGNoO1xuICAgICAgICBpZiAocXVvdGUpIHtcbiAgICAgICAgICAgIGtleSA9IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAga2V5ID0gZXhwcmVzc2lvbi50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY2FzdFBhdGggPSAocGF0aCwgb2JqZWN0KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgoYCR7cGF0aH1gKTtcbn07XG5cbmNvbnN0IGdldCA9IChvYmplY3QsIHBhdGgpID0+IHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsO1xuICAgICAgICBjb25zdCB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZTtcbiAgICAgICAgY29uc3QgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgY29uc3Qgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGw7XG4gICAgICAgIGNvbnN0IG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyO1xuICAgICAgICBjb25zdCBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgICAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3Qgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWE7XG4gICAgY29uc3Qgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYTtcbiAgICBjb25zdCBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGg7XG4gICAgY29uc3Qgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPCBvcmRlcnNMZW5ndGggPyBvcmRlcnNbaW5kZXhdIDogbnVsbDtcbiAgICAgICAgY29uc3QgY21wRm4gPSAob3JkZXIgJiYgdHlwZW9mIG9yZGVyID09PSAnZnVuY3Rpb24nKSA/IG9yZGVyIDogY29tcGFyZUFzY2VuZGluZztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY21wRm4ob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAob3JkZXIgJiYgdHlwZW9mIG9yZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbn1cblxuY29uc3QgZGlmZiA9IChhcnJheSwgdmFsdWVzKSA9PiB7XG4gICAgbGV0IGluY2x1ZGVzID0gKGFycmF5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGFycmF5LmluZGV4T2YodmFsdWUpID4gLTE7XG4gICAgfTtcbiAgICBsZXQgaXNDb21tb24gPSB0cnVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBpZiAoIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSAoY2FjaGUsIGtleSkgPT4gY2FjaGUuaGFzKGtleSk7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICAgIH1cblxuICAgIG91dGVyOlxuICAgIGZvciAobGV0IGtleSBpbiBhcnJheSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVtrZXldO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IHZhbHVlO1xuXG4gICAgICAgIHZhbHVlID0gKHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IGludGVyc2VjdCA9IChhcnJheXMpID0+IHtcbiAgICBjb25zdCBpbmNsdWRlcyA9IChhcnJheSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBhcnJheS5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICAgIH07XG4gICAgY29uc3QgY2FjaGVIYXMgPSAoY2FjaGUsIGtleSkgPT4gY2FjaGUuaGFzKGtleSk7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aDtcbiAgICBjb25zdCBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgIGNvbnN0IGNhY2hlcyA9IG5ldyBBcnJheShvdGhMZW5ndGgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgbGV0IGFycmF5O1xuICAgIGxldCBtYXhMZW5ndGggPSBJbmZpbml0eTtcbiAgICBsZXQgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG5cbiAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG5cbiAgICAgICAgbWF4TGVuZ3RoID0gTWF0aC5taW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gbGVuZ3RoID49IDEyMCAmJiBhcnJheS5sZW5ndGggPj0gMTIwXG4gICAgICAgICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICBvdXRlcjpcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQpXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICAgIDogaW5jbHVkZXMoYXJyYXlzW290aEluZGV4XSwgY29tcHV0ZWQpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvS2V5ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYCR7dmFsdWV9YDtcbiAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUluZmluaXR5KSA/ICctMCcgOiByZXN1bHQ7XG59O1xuXG5jb25zdCBiYXNlQ2xvbmUgPSAodmFsdWUsIGlzRGVlcCA9IGZhbHNlLCBpc0ZsYXQgPSBmYWxzZSwgaXNGdWxsID0gdHJ1ZSwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSA9PiB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICBjb25zdCB0YWcgPSBnZXRUYWcodmFsdWUpO1xuXG4gICAgaWYgKGlzQXJyKSB7XG4gICAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcblxuICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGlzRnVuYyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgICAgICBpZiAodGFnID09PSBvYmplY3RUYWcgfHwgdGFnID09PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRmxhdCA/XG4gICAgICAgICAgICAgICAgICAgIGNvcHlTeW1ib2xzSW4odmFsdWUsIGNvcHlPYmplY3QodmFsdWUsIE9iamVjdC5rZXlzKHZhbHVlKSwgcmVzdWx0KSkgOlxuICAgICAgICAgICAgICAgICAgICBjb3B5U3ltYm9scyh2YWx1ZSwgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNGdW5jIHx8ICFDTE9ORUFCTEVfVEFHU1t0YWddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBjb25zdCBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcblxuICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgIH1cblxuICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgoc3ViVmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0ZsYXQsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goc3ViVmFsdWUgPT4ge1xuICAgICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgaXNGbGF0LCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZihpc1R5cGVkQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICBjb25zdCBwcm9wcyA9ICBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcblxuICAgIChwcm9wcyB8fCB2YWx1ZSkuZm9yRWFjaCgoc3ViVmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0ZsYXQsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCBjb3B5U3ltYm9sc0luID0gKHNvdXJjZSwgb2JqZWN0KSA9PiB7XG4gICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn07XG5cbmNvbnN0IHBhcmVudCA9IChvYmplY3QsIHBhdGgpID0+IHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogZ2V0KG9iamVjdCwgcGF0aC5zbGljZSgwLCAtMSkpO1xufTtcblxuY29uc3Qgc2V0ID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IG5lc3RlZCA9IG9iamVjdDtcblxuICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgaXNJbmRleCA9ICh2YWx1ZSwgbGVuZ3RoKSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICh0eXBlICE9PSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn07XG5cbmNvbnN0IHVuc2V0ID0gKG9iamVjdCwgcGF0aCkgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3RTZWdtZW50KV07XG59O1xuXG5jb25zdCBpc0tleWFibGUgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbn07XG5cbmNvbnN0IGtleXNJbiA9IChvYmplY3QpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmNvbnN0IHRvUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcbiAgICB2YWx1ZSA9IE9iamVjdCh2YWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3Qgc2FmZUdldCA9IChvYmplY3QsIGtleSkgPT4ge1xuICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lciwgaXNNZXJnZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIChvYmplY3QsIC4uLnNvdXJjZXMpID0+IHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGxldCBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgbGV0IGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICAgIDogaXNNZXJnZSA/IChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG59XG5cbmNvbnN0IGJhc2VNZXJnZSA9IChvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSA9PiB7XG4gICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3JJbihzb3VyY2UsIChzcmNWYWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNyY1ZhbHVlLCBgJHtrZXl9YCwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuY29uc3QgYmFzZU1lcmdlRGVlcCA9IChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykgPT4ge1xuICAgIGNvbnN0IG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSk7XG4gICAgY29uc3Qgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KTtcbiAgICBjb25zdCBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBgJHtrZXl9YCwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgY29uc3QgaXNBcnIgPSBBcnJheS5pc0FycmF5KHNyY1ZhbHVlKTtcbiAgICAgICAgY29uc3QgaXNUeXBlZCA9ICFpc0FyciAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgIGlmIChpc0FyciB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3RMaWtlKG9ialZhbHVlKSAmJiBpc0FycmF5TGlrZShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9ialZhbHVlID09PSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICB9XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufTtcblxuY29uc3QgYXNzaWduTWVyZ2VWYWx1ZSA9IChvYmplY3QsIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCk7XG4gICAgY29uc3QgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgIGxldCB7IGxlbmd0aCB9ID0gcHJvcHM7XG4gICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcHNbKytpbmRleF07XG4gICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbmNvbnN0IGJhc2VGb3JPd24gPSAob2JqZWN0LCBpdGVyYXRlZSkgPT4ge1xuICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn07XG5cbmNvbnN0IGJhc2VFYWNoID0gKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSA9PiB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gYmFzZUZvck93bihjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xufTtcblxuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgY3JlYXRlU2V0ID0gKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbdW5kZWZpbmVkLC0wXSkpWzFdKSA9PSAxIC8gMClcbiAgICA/ICh2YWx1ZXMpID0+IG5ldyBTZXQodmFsdWVzKVxuICAgIDogKCkgPT4geyAvKiBuby1vcCAqLyB9O1xuXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMubWFwKChpdGVyYXRlZSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZ2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRlZXMgPSBbKHZhbHVlKSA9PiB2YWx1ZV07XG4gICAgfVxuXG4gICAgbGV0IGNyaXRlcmlhSW5kZXggPSAtMTtcbiAgICBsZXQgZWFjaEluZGV4ID0gLTE7XG5cbiAgICBjb25zdCByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IG5ldyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjcml0ZXJpYSA9IGl0ZXJhdGVlcy5tYXAoKGl0ZXJhdGVlKSA9PiBpdGVyYXRlZSh2YWx1ZSkpO1xuXG4gICAgICAgIHJlc3VsdFsrK2VhY2hJbmRleF0gPSB7XG4gICAgICAgICAgICBjcml0ZXJpYSxcbiAgICAgICAgICAgIGluZGV4OiArK2NyaXRlcmlhSW5kZXgsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCAob2JqZWN0LCBvdGhlcikgPT4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykpO1xufVxuXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gYXJyYXk7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgcmV0dXJuIChvYmplY3QpID0+IHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gKG9iamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgY29uc3QgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgfVxuICAgIHJldHVybiAob2JqZWN0KSA9PiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGtleXMob2JqZWN0KTtcbiAgICBsZXQgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjb25zdCBrZXkgPSByZXN1bHRbbGVuZ3RoXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICBsZXQgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGxlbmd0aCA9IGluZGV4O1xuICAgIGNvbnN0IG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgZGF0YTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGNvbnN0IGtleSA9IGRhdGFbMF07XG4gICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIGNvbnN0IHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gKG9iamVjdCkgPT4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgcmV0dXJuIChvYmplY3QpID0+IGdldChvYmplY3QsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKHZhbCkgPT4gdmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBiYXNlSXRlcmF0ZWU7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xufVxuXG5jb25zdCBhcnJheVJlZHVjZSA9IChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufTtcblxuY29uc3QgYmFzZVJlZHVjZSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpID0+IHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCAodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbn07XG5cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICBjb25zdCBmdW5jID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZTtcbiAgICBjb25zdCBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcbiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5jb25zdCBpc0ZsYXR0ZW5hYmxlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHZhbHVlICYmIHZhbHVlW1N5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVdKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBpc0FyZ3VtZW50cyA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5jb25zdCBiYXNlUGljayA9IChvYmplY3QsIHBhdGhzKSA9PiB7XG4gICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgKHZhbHVlLCBwYXRoKSA9PiBoYXNJbihvYmplY3QsIHBhdGgpKTtcbn07XG5cbmNvbnN0IGJhc2VQaWNrQnkgPSAob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgY29uc3QgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHBhdGhzW2luZGV4XTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICAgIHNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgaXNMZW5ndGggPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG59O1xuXG5jb25zdCBiYXNlSGFzSW4gPSAob2JqZWN0LCBrZXkpID0+e1xuICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59O1xuXG5jb25zdCBoYXNQYXRoID0gKG9iamVjdCwgcGF0aCwgaGFzRnVuYykgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgICAgICAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufTtcblxuY29uc3QgYXNjaWlXb3JkcyA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKTtcbn07XG5cbmNvbnN0IHVuaWNvZGVXb3JkcyA9IChzdHJpbmcpID0+IHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmRzKTtcbn07XG5cbmNvbnN0IHdvcmRzID0gKHN0cmluZywgcGF0dGVybikgPT4ge1xuICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xufTtcblxuY29uc3QgY2FzdFNsaWNlID0gKGFycmF5LCBzdGFydCwgZW5kKSA9PiB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGFycmF5O1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kO1xuICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBhcnJheS5zbGljZShzdGFydCwgZW5kKTtcbn07XG5cbmNvbnN0IHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIChzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjb25zdCBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICAgIDogc3RyaW5nWzBdO1xuXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCB0cnVlKSk7XG59XG5cbi8vIC0tIGhlbHBlciBjbGFzc2VzXG5jbGFzcyBTdGFjayB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkge1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIExpc3RDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICBjb25zdCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGRhdGEucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLS10aGlzLnNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIGNvbnN0IGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgICB9XG5cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICBjb25zdCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICsrdGhpcy5zaXplO1xuICAgICAgICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgTWFwQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAgICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAgICAgICAgICdtYXAnOiBuZXcgTWFwLFxuICAgICAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbmNsYXNzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9fZGF0YV9fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaGFzKGtleSkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgcmV0dXJuIGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBTZXRDYWNoZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBoYXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICB9XG59XG5cblNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gU2V0Q2FjaGUucHJvdG90eXBlLmFkZDtcblxuLy8gLS0gdG9wIGxldmVsIGZ1bmN0aW9uc1xuXG5leHBvcnQgY29uc3QgaXNCb29sZWFuID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHwgKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYm9vbFRhZyk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgKCEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gbnVtYmVyVGFnKTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCAoISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBzdHJpbmdUYWcpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKChvYmplY3QsIHNvdXJjZSkgPT4ge1xuICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5leHBvcnQgY29uc3QgbWl4aW4gPSBhc3NpZ247XG5cbmV4cG9ydCBjb25zdCBkZWVwTWl4aW4gPSBtaXhpbjtcblxuZXhwb3J0IGNvbnN0IHN1cHBsZW1lbnQgPSAob2JqZWN0LCAuLi5zb3VyY2VzKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGNvbnN0IGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG5cbiAgICAgICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgY29uc3QgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgIGxldCBwcm9wc0luZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKGVxKHZhbHVlLCBPYmplY3QucHJvdG90eXBlW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0cyA9IHN1cHBsZW1lbnQ7XG5cbmV4cG9ydCBjb25zdCBkZWVwU3VwcGxlbWVudCA9IGZ1bmN0aW9uIGRlZmF1bHRzRGVlcCguLi5hcmdzKSB7XG4gICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgcmV0dXJuIG1lcmdlLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdHNEZWVwID0gZGVlcFN1cHBsZW1lbnQ7XG5cbi8vIF8uaW52b2tlTWFwXG5leHBvcnQgY29uc3QgaW52b2tlID0gKGNvbGxlY3Rpb24sIHBhdGgsIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IG5ldyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBwYXRoLmFwcGx5KHZhbHVlLCBhcmdzKSA6IGludm9rZVByb3BlcnR5KHZhbHVlLCBwYXRoLCAuLi5hcmdzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBfLmludm9rZVxuZXhwb3J0IGNvbnN0IGludm9rZVByb3BlcnR5ID0gKG9iamVjdCwgcGF0aCwgLi4uYXJncykgPT4ge1xuICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgIGNvbnN0IGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZ1bmMuYXBwbHkob2JqZWN0LCBhcmdzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzb3J0ZWRJbmRleCA9IChhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSA9PiB7XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IGhpZ2ggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaGlnaCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpO1xuICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgY29uc3QgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgY29uc3QgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGw7XG4gICAgY29uc3QgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG4gICAgY29uc3QgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgbGV0IHNldExvdztcbiAgICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKTtcbiAgICAgICAgY29uc3Qgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGw7XG4gICAgICAgIGNvbnN0IG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkO1xuICAgICAgICBjb25zdCBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJm90aElzRGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc051bGwpIHtcbiAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiBvdGhJc0RlZmluZWQgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2w7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldExvdyA9IGNvbXB1dGVkIDwgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5pcSA9IChhcnJheSwgaXRlcmF0ZWUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBsZXQgaW5jbHVkZXMgPSAoYXJyYXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgYXJyYXkuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgICB9O1xuICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpO1xuICAgIGxldCBpc0NvbW1vbiA9IHRydWU7XG5cbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXJyYXk7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHNlZW4gPSByZXN1bHQ7XG5cbiAgICBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICAgICAgaWYgKHNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IChjYWNoZSwga2V5KSA9PiBjYWNoZS5oYXMoa2V5KTtcbiAgICAgICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgICB9XG4gICAgb3V0ZXI6XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAodmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICBsZXQgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgY29uc3QgY2xvbmUgPSAodmFsdWUpID0+IGJhc2VDbG9uZSh2YWx1ZSk7XG5cbmV4cG9ydCBjb25zdCBjbG9uZURlZXAgPSAodmFsdWUpID0+IGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSk7XG5cbmV4cG9ydCBjb25zdCBpc0VtcHR5ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgIGlmICh0YWcgPT0gJ1tvYmplY3QgTWFwXScgfHwgdGFnID09ICdbb2JqZWN0IFNldF0nKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICB9XG4gICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0IGNvbnN0IGlzRXF1YWwgPSAob2JqZWN0LCBvdGhlcikgPT4gYmFzZUlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cbmV4cG9ydCBjb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGdldFRhZyh2YWx1ZSkgIT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG87XG59O1xuXG5leHBvcnQgY29uc3QgdG9BcnJheSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICAgICAgd2hpbGUgKCEoZGF0YSA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGF0YS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb25zdCB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgIGNvbnN0IGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0KSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBsZXQgbGFzdEFyZ3M7XG4gICAgbGV0IGxhc3RUaGlzO1xuICAgIGxldCBtYXhXYWl0O1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHRpbWVySWQ7XG4gICAgbGV0IGxhc3RDYWxsVGltZTtcbiAgICBsZXQgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxldCBsZWFkaW5nID0gZmFsc2U7XG4gICAgbGV0IG1heGluZyA9IGZhbHNlO1xuICAgIGxldCB0cmFpbGluZyA9IHRydWU7XG5cbiAgICBjb25zdCB1c2VSYWYgPSAoIXdhaXQgJiYgd2FpdCAhPT0gMCAmJiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpO1xuXG4gICAgd2FpdCA9ICt3YWl0IHx8IDA7XG5cbiAgICBpZiAoaXNPYmplY3Qob3B0KSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHQubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdDtcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IE1hdGgubWF4KCtvcHQubWF4V2FpdCB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHQgPyAhIW9wdC50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICBjb25zdCBhcmdzID0gbGFzdEFyZ3M7XG4gICAgICAgIGNvbnN0IHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRUaW1lcihwZW5kaW5nRnVuYywgd2FpdCkge1xuICAgICAgICBpZiAodXNlUmFmKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGltZXJJZCk7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShwZW5kaW5nRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocGVuZGluZ0Z1bmMsIHdhaXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbmNlbFRpbWVyKGlkKSB7XG4gICAgICAgIGlmICh1c2VSYWYpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHRpbWVySWQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lO1xuICAgICAgICBjb25zdCB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuICAgICAgICBjb25zdCB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nID8gTWF0aC5taW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHRpbWVXYWl0aW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZTtcbiAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fCAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fFxuICAgICAgICAgICAgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVySWQgPSBzdGFydFRpbWVyKHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVib3VuY2VkKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgICAgICB0aW1lcklkID0gc3RhcnRUaW1lcih0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXJJZCA9IHN0YXJ0VGltZXIodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGRlYm91bmNlZC5jYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmNlbFRpbWVyKHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBkZWJvdW5jZWQuZmx1c2ggPSAoKSA9PiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2UoRGF0ZS5ub3coKSk7XG4gICAgZGVib3VuY2VkLnBlbmRpbmcgPSAoKSA9PiB0aW1lcklkICE9PSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5leHBvcnQgY29uc3QgZ3JvdXBCeSA9IChjb2xsZWN0aW9uLCBpdGVyYXRlZSkgPT4ge1xuICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpO1xuXG4gICAgcmV0dXJuIHJlZHVjZShjb2xsZWN0aW9uLCAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc29ydEJ5ID0gKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcyA9IFtdKSA9PiB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtnZXRJdGVyYXRlZShpdGVyYXRlZXMsIDIpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLmZsYXQoMSksIFtdKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuRGVlcCA9IChhcnJheSkgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSW5maW5pdHkpIDogW107XG59O1xuXG5leHBvcnQgY29uc3Qgd2l0aG91dCA9IChhcnJheSwgLi4udmFsdWVzKSA9PiBpc0FycmF5TGlrZShhcnJheSkgPyBkaWZmKGFycmF5LCB2YWx1ZXMpIDogW107XG5cbmV4cG9ydCBjb25zdCBkaWZmZXJlbmNlID0gKGFycmF5LCAuLi52YWx1ZXMpID0+XG4gICAgaXNPYmplY3RMaWtlKGFycmF5KSAmJiBpc0FycmF5TGlrZShhcnJheSkgP1xuICAgICAgICBkaWZmKGFycmF5LCB2YWx1ZXMuZmxhdCgxKSkgOiBbXTtcblxuZXhwb3J0IGNvbnN0IGludGVyc2VjdGlvbiA9ICguLi5hcnJheXMpID0+IHtcbiAgICBjb25zdCBtYXBwZWQgPSBhcnJheXMubWFwKChhcnJheSkgPT5cbiAgICAgICAgaXNPYmplY3RMaWtlKGFycmF5KSAmJiBpc0FycmF5TGlrZShhcnJheSkgP1xuICAgICAgICAgICAgYXJyYXkgOiBbXVxuICAgICk7XG5cbiAgICByZXR1cm4gbWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSA/XG4gICAgICAgIGludGVyc2VjdChtYXBwZWQpIDogW107XG59O1xuXG5leHBvcnQgY29uc3QgdW5pb24gPSAoLi4uYXJyYXlzKSA9PiB7XG4gICAgY29uc3QgYXJyYXkgPSBhcnJheXMuZmxhdCgxKTtcbiAgICByZXR1cm4gdW5pcShhcnJheSk7XG59O1xuXG5leHBvcnQgY29uc3QgaGFzID0gKG9iamVjdCwga2V5KSA9PiB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAga2V5ID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IHZhbHVlID0gb2JqZWN0O1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBrZXkubGVuZ3RoKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHwgIWhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtrZXlbaW5kZXhdXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydCBjb25zdCByZXN1bHQgPSAob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG5leHBvcnQgY29uc3Qgb21pdCA9IChvYmplY3QsIC4uLnBhdGhzKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgaXNEZWVwID0gZmFsc2U7XG4gICAgcGF0aHMgPSBwYXRocy5mbGF0KDEpLm1hcCgocGF0aCkgPT4ge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9KTtcbiAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCB0cnVlLCB0cnVlLCB0cnVlLCAodmFsdWUpID0+IGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWUpO1xuICAgIH1cbiAgICBsZXQgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB1bnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0IGNvbnN0IHBpY2sgPSAob2JqZWN0LCAuLi5wYXRocykgPT4ge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocy5mbGF0KEluZmluaXR5KSk7XG59O1xuXG5leHBvcnQgY29uc3QgYmluZEFsbCA9IChvYmplY3QsIC4uLm1ldGhvZE5hbWVzKSA9PiB7XG4gICAgbWV0aG9kTmFtZXMuZmxhdCgxKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG9iamVjdFtrZXldLmJpbmQob2JqZWN0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JJbiA9IChvYmplY3QsIGl0ZXJhdGVlID0gKHZhbHVlKSA9PiB2YWx1ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCk7XG4gICAgY29uc3QgcHJvcHMgPSBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDoga2V5c0luKG9iamVjdCk7XG4gICAgbGV0IGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlKGxlbmd0aC0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByb3BzWysraW5kZXhdO1xuICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjYW1lbENhc2UgPSAoc3RyaW5nID0gJycpID0+IChcbiAgICB3b3JkcyhgJHtzdHJpbmd9YC5yZXBsYWNlKC9bJ1xcdTIwMTldL2csICcnKSlcbiAgICAgICAgLnJlZHVjZSgocmVzdWx0LCB3b3JkLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyB1cHBlckZpcnN0KHdvcmQpIDogd29yZCk7XG4gICAgICAgIH0sICcnKVxuKTtcblxubGV0IGlkQ291bnRlciA9IDA7XG5cbmV4cG9ydCBjb25zdCB1bmlxdWVJZCA9IChwcmVmaXggPSAnJykgPT4ge1xuICAgIGNvbnN0IGlkID0gKytpZENvdW50ZXI7XG4gICAgcmV0dXJuIGAke3ByZWZpeH1gICsgaWQ7XG59O1xuXG5leHBvcnQgY29uc3QgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcigob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSA9PiB7XG4gICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG59LCB0cnVlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@joint/core/src/util/wrappers.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@joint/core/src/util/wrappers.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wrapWith: function() { return /* binding */ wrapWith; },\n/* harmony export */   wrappers: function() { return /* binding */ wrappers; }\n/* harmony export */ });\n/* harmony import */ var _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dia/Cell.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/dia/Cell.mjs\");\n/* harmony import */ var _util_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.mjs */ \"(app-pages-browser)/./node_modules/@joint/core/src/util/utilHelpers.mjs\");\n\n\n\nconst wrapWith = function(object, methods, wrapper) {\n\n    if ((0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isString)(wrapper)) {\n\n        if (!wrappers[wrapper]) {\n            throw new Error('Unknown wrapper: \"' + wrapper + '\"');\n        }\n\n        wrapper = wrappers[wrapper];\n    }\n\n    if (!(0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(wrapper)) {\n        throw new Error('Wrapper must be a function.');\n    }\n\n    (0,_util_mjs__WEBPACK_IMPORTED_MODULE_0__.toArray)(methods).forEach(function(method) {\n        object[method] = wrapper(object[method]);\n    });\n};\n\nconst wrappers = {\n\n    cells: function(fn) {\n\n        return function() {\n\n            var args = Array.from(arguments);\n            var n = args.length;\n            var cells = n > 0 && args[0] || [];\n            var opt = n > 1 && args[n - 1] || {};\n\n            if (!Array.isArray(cells)) {\n\n                if (opt instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                    cells = args;\n                } else if (cells instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                    if (args.length > 1) {\n                        args.pop();\n                    }\n                    cells = args;\n                }\n            }\n\n            if (opt instanceof _dia_Cell_mjs__WEBPACK_IMPORTED_MODULE_1__.Cell) {\n                opt = {};\n            }\n\n            return fn.call(this, cells, opt);\n        };\n    }\n\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Aam9pbnQvY29yZS9zcmMvdXRpbC93cmFwcGVycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1QztBQUNvQjs7QUFFcEQ7O0FBRVAsUUFBUSxtREFBUTs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxxREFBVTtBQUNuQjtBQUNBOztBQUVBLElBQUksa0RBQU87QUFDWDtBQUNBLEtBQUs7QUFDTDs7QUFFTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUMsK0NBQUk7QUFDdkM7QUFDQSxrQkFBa0IsMEJBQTBCLCtDQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsK0NBQUk7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bqb2ludC9jb3JlL3NyYy91dGlsL3dyYXBwZXJzLm1qcz9hMTM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENlbGwgfSBmcm9tICcuLi9kaWEvQ2VsbC5tanMnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIHRvQXJyYXkgfSBmcm9tICcuL3V0aWwubWpzJztcblxuZXhwb3J0IGNvbnN0IHdyYXBXaXRoID0gZnVuY3Rpb24ob2JqZWN0LCBtZXRob2RzLCB3cmFwcGVyKSB7XG5cbiAgICBpZiAoaXNTdHJpbmcod3JhcHBlcikpIHtcblxuICAgICAgICBpZiAoIXdyYXBwZXJzW3dyYXBwZXJdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gd3JhcHBlcjogXCInICsgd3JhcHBlciArICdcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgd3JhcHBlciA9IHdyYXBwZXJzW3dyYXBwZXJdO1xuICAgIH1cblxuICAgIGlmICghaXNGdW5jdGlvbih3cmFwcGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyYXBwZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHRvQXJyYXkobWV0aG9kcykuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgb2JqZWN0W21ldGhvZF0gPSB3cmFwcGVyKG9iamVjdFttZXRob2RdKTtcbiAgICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCB3cmFwcGVycyA9IHtcblxuICAgIGNlbGxzOiBmdW5jdGlvbihmbikge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gbiA+IDAgJiYgYXJnc1swXSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBvcHQgPSBuID4gMSAmJiBhcmdzW24gLSAxXSB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNlbGxzKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdCBpbnN0YW5jZW9mIENlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbHMgaW5zdGFuY2VvZiBDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdCBpbnN0YW5jZW9mIENlbGwpIHtcbiAgICAgICAgICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgY2VsbHMsIG9wdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@joint/core/src/util/wrappers.mjs\n"));

/***/ })

}]);