'use client'

import { useEffect, useRef } from 'react'
import * as am5 from '@amcharts/amcharts5'
import * as am5hierarchy from '@amcharts/amcharts5/hierarchy'
import am5themes_Animated from '@amcharts/amcharts5/themes/Animated'

interface AmChartsVisualizationProps {
  data: {
    processedNodes: any[]
    processedLinks: any[]
  }
}

export default function AmChartsVisualization({ data }: AmChartsVisualizationProps) {
  const chartRef = useRef<HTMLDivElement>(null)
  const rootRef = useRef<am5.Root | null>(null)

  // Flèches (bullets) sur les liens
  const ARROW_CONFIG = {
    width: 5,
    height: 4,
    tail: 1,
    color: '#666666',
    minDuration: 1500,
    maxDuration: 3000
  }

  // Couleurs des nœuds
  const NODE_COLORS = {
    entities: '#3498db',
    autoGenerated: '#e74c3c'
  }

  useEffect(() => {
    if (!chartRef.current || !data?.processedNodes || !data?.processedLinks) return

    // cleanup
    if (rootRef.current) {
      rootRef.current.dispose()
      rootRef.current = null
    }

    // Root
    const root = am5.Root.new(chartRef.current)
    rootRef.current = root
    root.setThemes([am5themes_Animated.new(root)])

    // Container zoomable
    const zoomableContainer = root.container.children.push(
      am5.ZoomableContainer.new(root, {
        width: am5.percent(100),
        height: am5.percent(100),
        wheelable: true,
        pinchZoom: true,
        minZoomLevel: 0.1,
        maxZoomLevel: 5
      })
    )

    // Outils de zoom (UI)
    zoomableContainer.children.push(
      am5.ZoomTools.new(root, {
        target: zoomableContainer,
        x: am5.percent(95),
        y: am5.percent(5),
        centerX: am5.percent(100),
        centerY: am5.percent(0)
      })
    )

    // Série ForceDirected
    const series = zoomableContainer.contents.children.push(
      am5hierarchy.ForceDirected.new(root, {
        singleBranchOnly: false,

        // IMPORTANT: graphe hiérarchique → montrer au moins le niveau 1
        topDepth: 1,
        initialDepth: 1,
        downDepth: 99,

        valueField: 'value',
        categoryField: 'name',
        childDataField: 'children',   // ⬅️ les enfants viennent d’un champ "children"
        idField: 'name',
        linkWithField: 'linkWith',

        centerStrength: 0.5,
        manyBodyStrength: -15,
        nodePadding: 15,

        // Taille des cercles (fixe et compacte)
        minRadius: 4,
        maxRadius: 15
      })
    )

    // Bullets (flèches animées) au milieu des liens
    series.linkBullets.push((r: am5.Root) => {
      const bullet = am5.Bullet.new(r, {
        locationX: 0.5,
        autoRotate: true,
        autoRotateAngle: 180,
        sprite: am5.Graphics.new(r, {
          fill: am5.color(ARROW_CONFIG.color),
          centerY: am5.percent(50),
          centerX: am5.percent(50),
          draw: (display) => {
            display.moveTo(0, -ARROW_CONFIG.height)
            display.lineTo(ARROW_CONFIG.width, 0)
            display.lineTo(0, ARROW_CONFIG.height)
            display.lineTo(ARROW_CONFIG.tail, 0)
            display.lineTo(0, -ARROW_CONFIG.height)
          }
        })
      })

      const duration =
        Math.random() * (ARROW_CONFIG.maxDuration - ARROW_CONFIG.minDuration) + ARROW_CONFIG.minDuration

      bullet.animate({
        key: 'locationX',
        to: -0.1,
        from: 1.1,
        duration,
        loops: Infinity,
        easing: am5.ease.quad
      })

      return bullet
    })

    // Styles liens
    series.links.template.setAll({
      strength: 0.5,
      stroke: am5.color('#95a5a6'),
      strokeWidth: 2,
      strokeOpacity: 0.7
    })

    // Styles nœuds
    series.nodes.template.setAll({
      tooltipText: 'ID: {name}',
      cursorOverStyle: 'pointer'
    })

    // Couleur de fond/bord du disque (via background)
    series.nodes.template.get('background')?.setAll({
      fillOpacity: 0.85,
      strokeWidth: 1,
      strokeOpacity: 0.8
    })

    // Couleurs par dataContext.fill si présent, sinon défaut
    series.nodes.template.get('background')?.adapters.add('fill', (fill, target) => {
      const nodeData = target.dataItem?.dataContext as any
      return nodeData?.fill ? am5.color(nodeData.fill) : am5.color(NODE_COLORS.entities)
    })
    series.nodes.template.get('background')?.adapters.add('stroke', (stroke, target) => {
      const nodeData = target.dataItem?.dataContext as any
      const base = nodeData?.fill ? am5.color(nodeData.fill) : am5.color(NODE_COLORS.entities)
      return am5.Color.brighten(base, -0.25)
    })

    // Labels (facultatif)
    series.labels.template.setAll({
      text: '{name}',
      fontSize: 12,
      fill: am5.color('#2c3e50'),
      centerX: am5.percent(50),
      centerY: am5.percent(50),
      minScale: 0.5
    })

    // ======= Données (plat -> root.children + linkWith) =======
    const prepareData = () => {
      const allNodes: any[] = []
      const processedNodeIds = new Set<string>()

      // 1) Nœuds métier
      data.processedNodes.forEach((node: any) => {
        if (!processedNodeIds.has(node.id)) {
          allNodes.push({
            name: node.id,
            value: 50,
            fill: NODE_COLORS.entities
          })
          processedNodeIds.add(node.id)
        }
      })

      // 2) Nœuds rencontrés dans les liens (créés si absents)
      data.processedLinks.forEach((link: any) => {
        if (!processedNodeIds.has(link.source)) {
          allNodes.push({ name: link.source, value: 30, fill: NODE_COLORS.autoGenerated })
          processedNodeIds.add(link.source)
        }
        if (!processedNodeIds.has(link.target)) {
          allNodes.push({ name: link.target, value: 30, fill: NODE_COLORS.autoGenerated })
          processedNodeIds.add(link.target)
        }
      })

      // 3) Construire linkWith
      const linkMap = new Map<string, string[]>()
      data.processedLinks.forEach((link: any) => {
        if (processedNodeIds.has(link.source) && processedNodeIds.has(link.target)) {
          if (!linkMap.has(link.source)) linkMap.set(link.source, [])
          linkMap.get(link.source)!.push(link.target)
        }
      })

      allNodes.forEach((n) => {
        const lw = linkMap.get(n.name)
        if (lw?.length) n.linkWith = lw
      })

      // 4) Emballer dans un root hiérarchique
      return {
        name: 'Graphe',
        value: 0,
        children: allNodes
      }
    }

    const rootData = prepareData()

    // Assigner les données (root -> children)
    series.data.setAll([rootData])

    // (Optionnel) apparition + petit dézoom auto
    series.appear(700, 70)

    setTimeout(() => {
      try {
        const count = rootData.children?.length ?? 0
        let zoomFactor = 0.3
        if (count > 50) zoomFactor = 0.15
        else if (count > 20) zoomFactor = 0.25
        ;(zoomableContainer as any).zoom?.(zoomFactor)
      } catch {
        // ignore
      }
    }, 1500)

    // Cleanup
    return () => {
      if (rootRef.current) {
        rootRef.current.dispose()
        rootRef.current = null
      }
    }
  }, [data])

  return (
    <div className="w-full h-full relative">
      <div ref={chartRef} className="w-full h-full" style={{ minHeight: '600px' }} />
      <div className="absolute bottom-4 left-4 bg-white/90 backdrop-blur-sm rounded-lg shadow-lg border border-gray-200 p-3 text-xs text-gray-600">
        <div className="flex items-center space-x-2">
          <div className="w-2 h-2 bg-purple-500 rounded-full" />
          <span>amCharts Force Directed</span>
        </div>
        <div className="mt-1">
          {data.processedNodes?.length || 0} entités • {data.processedLinks?.length || 0} liens
        </div>
        <div className="mt-1 text-xs text-gray-500">Flèches animées • Zoom: molette/pinch</div>
      </div>
    </div>
  )
}
